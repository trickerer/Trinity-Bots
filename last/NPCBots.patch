From c69e67192832d9b4c0a45a29c69a6dc1e677a71b Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@gmail.com>
Date: Fri, 25 Sep 2020 13:11:13 +0700
Subject: [PATCH] NPCBots

---
 sql/Bots/1_world_bot_appearance.sql                |   305 +
 sql/Bots/2_world_bot_extras.sql                    |   358 +
 sql/Bots/3_world_bots.sql                          |   547 +
 sql/Bots/4_world_generate_bot_equips.sql           |   159 +
 sql/Bots/5_world_botgiver.sql                      |    18 +
 sql/Bots/characters_bots.sql                       |    26 +
 ...rs_npcbot_2020_05_15_NPCBots_4.7.8a-4.7.27a.sql |     1 +
 .../characters_npcbot_2020_06_21_43fceb98.sql      |   172 +
 .../creature_template_npcbot_extras_2020_07_08.sql |     2 +
 src/common/Utilities/EventProcessor.h              |     1 +
 .../Database/Implementation/CharacterDatabase.cpp  |    16 +
 .../Database/Implementation/CharacterDatabase.h    |    12 +
 src/server/game/AI/NpcBots/bot_Events.h            |    53 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  1175 ++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 12935 +++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |   499 +
 src/server/game/AI/NpcBots/bot_archmage_ai.cpp     |   357 +
 src/server/game/AI/NpcBots/bot_bm_ai.cpp           |   905 ++
 src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp  |   589 +
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp |  2057 +++
 src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp    |   494 +
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        |  2864 ++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  2331 ++++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  1620 +++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      |  2709 ++++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  2046 +++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  1981 +++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  2771 ++++
 src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp |   552 +
 src/server/game/AI/NpcBots/bot_sphynx_ai.cpp       |   574 +
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  1950 +++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      |  2206 ++++
 src/server/game/AI/NpcBots/botcommands.cpp         |  1165 ++
 src/server/game/AI/NpcBots/botcommon.h             |   649 +
 src/server/game/AI/NpcBots/botdatamgr.cpp          |   437 +
 src/server/game/AI/NpcBots/botdatamgr.h            |    89 +
 src/server/game/AI/NpcBots/botdpstracker.cpp       |   131 +
 src/server/game/AI/NpcBots/botdpstracker.h         |    36 +
 src/server/game/AI/NpcBots/botgiver.cpp            |   241 +
 src/server/game/AI/NpcBots/botmgr.cpp              |  1283 ++
 src/server/game/AI/NpcBots/botmgr.h                |   169 +
 src/server/game/AI/NpcBots/bpet_ai.cpp             |  2271 ++++
 src/server/game/AI/NpcBots/bpet_ai.h               |   165 +
 src/server/game/AI/NpcBots/bpet_archmage.cpp       |   139 +
 src/server/game/AI/NpcBots/bpet_dark_ranger.cpp    |   213 +
 src/server/game/AI/NpcBots/bpet_death_knight.cpp   |   191 +
 src/server/game/AI/NpcBots/bpet_dreadlord.cpp      |   163 +
 src/server/game/AI/NpcBots/bpet_druid.cpp          |   146 +
 src/server/game/AI/NpcBots/bpet_hunter.cpp         |  1000 ++
 src/server/game/AI/NpcBots/bpet_mage.cpp           |   176 +
 src/server/game/AI/NpcBots/bpet_priest.cpp         |   172 +
 src/server/game/AI/NpcBots/bpet_shaman.cpp         |   191 +
 src/server/game/AI/NpcBots/bpet_warlock.cpp        |   409 +
 src/server/game/Combat/CombatManager.cpp           |    25 +
 src/server/game/Combat/ThreatManager.cpp           |     5 +
 src/server/game/DataStores/DBCStores.cpp           |     4 +-
 src/server/game/DataStores/DBCStores.h             |     2 +-
 src/server/game/DungeonFinding/LFGMgr.cpp          |   176 +
 src/server/game/DungeonFinding/LFGScripts.cpp      |     1 +
 src/server/game/Entities/Creature/Creature.cpp     |   443 +
 src/server/game/Entities/Creature/Creature.h       |    79 +
 src/server/game/Entities/Creature/CreatureData.h   |     6 +-
 .../game/Entities/Creature/TemporarySummon.cpp     |    25 +
 .../Entities/Creature/enuminfo_CreatureData.cpp    |    12 +-
 src/server/game/Entities/Object/Object.cpp         |    66 +
 src/server/game/Entities/Player/KillRewarder.cpp   |    15 +
 src/server/game/Entities/Player/Player.cpp         |   149 +
 src/server/game/Entities/Player/Player.h           |    25 +
 src/server/game/Entities/Totem/Totem.cpp           |     7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    46 +-
 src/server/game/Entities/Unit/Unit.cpp             |   542 +
 src/server/game/Entities/Unit/Unit.h               |     8 +
 src/server/game/Globals/ObjectMgr.cpp              |    81 +
 src/server/game/Globals/ObjectMgr.h                |    21 +
 src/server/game/Groups/Group.cpp                   |    65 +
 src/server/game/Groups/Group.h                     |     3 +
 src/server/game/Handlers/SpellHandler.cpp          |   102 +
 src/server/game/Maps/Map.cpp                       |    27 +
 src/server/game/Maps/MapManager.cpp                |     8 +
 src/server/game/Movement/MotionMaster.cpp          |    20 +
 src/server/game/OutdoorPvP/OutdoorPvP.cpp          |    17 +
 src/server/game/Scripting/ScriptMgr.cpp            |     8 +
 src/server/game/Server/WorldSession.cpp            |    18 +
 src/server/game/Spells/Auras/SpellAuraEffects.cpp  |    67 +
 src/server/game/Spells/Auras/SpellAuras.cpp        |    23 +
 src/server/game/Spells/Spell.cpp                   |   114 +
 src/server/game/Spells/Spell.h                     |     3 +
 src/server/game/Spells/SpellEffects.cpp            |   159 +
 src/server/game/Spells/SpellInfo.cpp               |    22 +
 src/server/scripts/Commands/cs_npc.cpp             |    20 +
 src/server/scripts/Spells/spell_dk.cpp             |    17 +
 src/server/scripts/Spells/spell_druid.cpp          |    65 +
 src/server/scripts/Spells/spell_generic.cpp        |    21 +
 src/server/scripts/Spells/spell_hunter.cpp         |    16 +
 src/server/scripts/Spells/spell_mage.cpp           |     6 +
 src/server/scripts/Spells/spell_paladin.cpp        |    60 +
 src/server/scripts/Spells/spell_priest.cpp         |    10 +
 src/server/scripts/Spells/spell_rogue.cpp          |    52 +
 src/server/scripts/Spells/spell_shaman.cpp         |   127 +
 src/server/scripts/Spells/spell_warrior.cpp        |     6 +
 src/server/shared/DataStores/DBCStructure.h        |    11 +-
 src/server/shared/DataStores/DBCfmt.h              |     2 +-
 src/server/worldserver/worldserver.conf.dist       |   240 +
 103 files changed, 54749 insertions(+), 19 deletions(-)
 create mode 100644 sql/Bots/1_world_bot_appearance.sql
 create mode 100644 sql/Bots/2_world_bot_extras.sql
 create mode 100644 sql/Bots/3_world_bots.sql
 create mode 100644 sql/Bots/4_world_generate_bot_equips.sql
 create mode 100644 sql/Bots/5_world_botgiver.sql
 create mode 100644 sql/Bots/characters_bots.sql
 create mode 100644 sql/Bots/updates/characters/characters_npcbot_2020_05_15_NPCBots_4.7.8a-4.7.27a.sql
 create mode 100644 sql/Bots/updates/characters/characters_npcbot_2020_06_21_43fceb98.sql
 create mode 100644 sql/Bots/updates/world/creature_template_npcbot_extras_2020_07_08.sql
 create mode 100644 src/server/game/AI/NpcBots/bot_Events.h
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_archmage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_bm_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_sphynx_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommon.h
 create mode 100644 src/server/game/AI/NpcBots/botdatamgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botdatamgr.h
 create mode 100644 src/server/game/AI/NpcBots/botdpstracker.cpp
 create mode 100644 src/server/game/AI/NpcBots/botdpstracker.h
 create mode 100644 src/server/game/AI/NpcBots/botgiver.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.h
 create mode 100644 src/server/game/AI/NpcBots/bpet_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bpet_archmage.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_dark_ranger.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_death_knight.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_dreadlord.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_druid.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_hunter.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_mage.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_priest.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_shaman.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_warlock.cpp

diff --git a/sql/Bots/1_world_bot_appearance.sql b/sql/Bots/1_world_bot_appearance.sql
new file mode 100644
index 0000000..82a7bca
--- /dev/null
+++ b/sql/Bots/1_world_bot_appearance.sql
@@ -0,0 +1,305 @@
+-- Handmade data, very sensitive
+DROP TABLE IF EXISTS `creature_template_npcbot_appearance`;
+
+CREATE TABLE `creature_template_npcbot_appearance` (
+  `entry` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
+  `name*` char(16) DEFAULT 'unk' COMMENT 'unused',
+  `gender` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `skin` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `face` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `hair` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `haircolor` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `features` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+insert into `creature_template_npcbot_appearance`(`entry`,`name*`,`gender`,`skin`,`face`,`hair`,`haircolor`,`features`)
+values
+(70001,'Llane',0,3,0,1,1,6),
+(70002,'Thran',0,0,0,4,5,4),
+(70003,'Lyria',1,3,4,6,4,0),
+(70004,'Ander',0,1,11,1,7,6),
+(70005,'Malosh',0,7,0,5,5,5),
+(70006,'Granis',0,0,2,9,4,4),
+(70007,'Kelstrum',0,5,4,2,2,2),
+(70008,'Dannal',0,1,0,8,5,0),
+(70009,'Austil',0,4,1,8,1,7),
+(70010,'Torm',0,7,1,2,0,2),
+(70011,'Sark',0,0,3,7,0,5),
+(70012,'Ker',1,4,0,0,0,1),
+(70013,'Harutt',0,1,3,7,0,4),
+(70014,'Krang',0,5,2,6,2,0),
+(70015,'Frang',0,0,4,1,1,3),
+(70016,'Tarshaw',0,3,3,1,0,7),
+(70017,'Grezz',0,3,5,1,0,3),
+(70018,'Sorek',0,2,1,3,1,6),
+(70019,'Zel\'mak',0,1,0,4,8,1),
+(70020,'Alyissia',1,5,1,5,2,0),
+(70021,'Kyra',1,6,8,4,6,1),
+(70022,'Arias\'ta',1,0,6,3,4,1),
+(70023,'Sildanair',1,3,0,2,4,2),
+(70024,'Chris',0,3,2,2,2,10),
+(70025,'Angela',1,2,7,3,8,6),
+(70026,'Baltus',0,0,0,1,8,1),
+(70027,'Kelv',0,5,1,7,3,1),
+(70028,'Bilban',0,2,2,2,7,1),
+(70029,'Wu',0,4,5,1,0,8),
+(70030,'Ilsa',1,5,6,7,3,4),
+(70031,'Darnath',0,7,8,3,0,0),
+(70032,'Evencane',0,5,9,2,4,2),
+(70033,'Kore',0,4,0,2,1,6),
+(70034,'Ahonan',0,6,1,1,6,5),
+(70035,'Behomat',0,4,8,3,6,3),
+(70036,'Ruada',1,1,2,1,6,0),
+(70037,'Kazi',1,1,2,3,3,0),
+(70038,'Kerra',1,2,0,2,2,0),
+(70051,'Sammuel',0,9,11,6,2,7),
+(70052,'Bromos',0,6,4,2,9,1),
+(70053,'Wilhelm',0,4,2,2,1,6),
+(70054,'Grayson',0,3,2,2,0,2),
+(70055,'Azar',0,2,4,3,1,6),
+(70056,'Valgar',0,4,3,0,0,0),
+(70057,'Beldruk',0,4,6,2,4,2),
+(70058,'Brandur',0,5,4,1,1,3),
+(70059,'Arthur',0,1,0,1,5,2),
+(70060,'Katherine',1,1,3,2,4,0),
+(70061,'Karman',0,3,11,10,5,8),
+(70062,'Jesthenis',0,4,0,0,0,0),
+(70063,'Noellene',1,0,1,1,1,0),
+(70064,'Aurelon',0,8,0,0,0,0),
+(70065,'Osselan',0,8,1,1,2,0),
+(70066,'Ithelis',0,9,2,2,2,0),
+(70067,'Bachi',0,3,0,10,1,0),
+(70068,'Baatun',0,6,4,3,0,7),
+(70069,'Kavaan',0,2,5,5,6,4),
+(70070,'Tullas',1,0,9,9,2,0),
+(70071,'Jol',1,0,8,8,6,0),
+(70072,'Cyssa',1,4,1,7,6,0),
+(70073,'Pyreanor',0,3,3,2,7,1),
+(70074,'Rukua',1,5,8,4,4,1),
+(70101,'Thorgas',0,4,5,8,4,8),
+(70102,'Ogromm',0,4,4,3,1,4),
+(70103,'Grif',0,0,1,5,4,4),
+(70104,'Kragg',0,7,4,3,2,2),
+(70105,'Kary',1,2,1,1,2,1),
+(70106,'Holt',0,18,3,4,0,3),
+(70107,'Urek',0,4,2,2,1,1),
+(70108,'Lanka',0,4,2,2,1,2),
+(70109,'Yaw',0,1,1,5,2,2),
+(70110,'Jen\'shan',1,3,0,2,6,3),
+(70111,'Thotar',0,0,3,3,1,9),
+(70112,'Ormak',0,5,8,1,0,5),
+(70113,'Xor\'juul',0,2,3,2,0,1),
+(70114,'Sian\'dur',1,2,4,1,2,4),
+(70115,'Ayanna',1,5,0,6,5,8),
+(70116,'Dazalar',0,8,0,6,2,3),
+(70117,'Danlaar',0,0,0,3,6,0),
+(70118,'Jeen\'ra',1,7,2,1,4,1),
+(70119,'Jocaste',1,6,1,1,6,1),
+(70120,'Dorion',0,4,6,5,0,5),
+(70121,'Daera',1,0,3,12,4,0),
+(70122,'Olmin',0,3,1,2,2,4),
+(70123,'Regnus',0,3,9,1,4,2),
+(70124,'Kaerbrus',0,2,0,0,2,2),
+(70125,'Einris',1,1,1,5,4,0),
+(70126,'Ulfir',0,6,2,5,8,1),
+(70127,'Thorfin',0,2,2,5,4,7),
+(70128,'Alenndaar',0,2,6,3,2,2),
+(70129,'Dargh',0,3,1,1,4,4),
+(70130,'Sallina',1,4,2,1,1,0),
+(70131,'Hannovia',1,0,2,2,1,0),
+(70132,'Keilnei',1,7,5,2,4,1),
+(70133,'Tana',1,8,1,1,2,0),
+(70134,'Oninath',0,0,0,0,0,0),
+(70135,'Zandine',1,8,0,1,4,0),
+(70136,'Deremiis',0,11,0,5,6,7),
+(70137,'Acteon',0,2,0,0,0,0),
+(70138,'Vord',0,11,0,5,6,7),
+(70139,'Killac',0,11,0,5,6,7),
+(70151,'Jorik',0,3,0,11,1,2),
+(70152,'Solm',0,7,8,4,9,6),
+(70153,'Keryn',1,4,4,7,0,0),
+(70154,'Osborne',0,4,9,9,0,1),
+(70155,'Hogral',0,6,7,10,5,7),
+(70156,'Ian',0,5,9,9,1,6),
+(70157,'David',0,4,2,1,1,1),
+(70158,'Marion',1,5,2,3,5,7),
+(70159,'Rwag',0,0,0,0,0,0),
+(70160,'Kaplak',0,3,5,0,0,3),
+(70161,'Gest',0,4,0,2,0,1),
+(70162,'Ormok',0,3,8,4,0,3),
+(70163,'Shenthul',0,3,0,5,5,1),
+(70164,'Frahun',0,2,1,3,5,4),
+(70165,'Jannok',0,3,2,4,5,3),
+(70166,'Syurna',1,0,3,5,4,0),
+(70167,'Erion',0,5,0,3,4,3),
+(70168,'Anishar',0,5,6,4,6,5),
+(70169,'Carolyn',1,0,6,3,1,7),
+(70170,'Miles',0,0,0,1,9,8),
+(70171,'Gregory',0,3,7,8,4,14),
+(70172,'Hulfdan',0,8,8,8,5,6),
+(70173,'Ormyr',0,0,6,4,4,4),
+(70174,'Fenthwick',0,0,2,2,5,0),
+(70175,'Fahrad',0,3,0,9,4,2),
+(70176,'Tony',0,3,0,1,0,2),
+(70177,'Kariel',0,1,0,0,0,0),
+(70178,'Tannaria',1,2,2,0,2,0),
+(70179,'Zelanis',0,0,1,1,1,0),
+(70180,'Elara',1,2,2,1,4,0),
+(70181,'Nerisen',0,1,1,2,1,0),
+(70201,'Anetta',1,0,9,14,5,0),
+(70202,'Laurena',1,0,1,4,5,0),
+(70203,'Josetta',1,1,3,17,2,0),
+(70204,'Branstock',0,2,7,1,8,0),
+(70205,'Maxan',0,2,0,6,1,5),
+(70206,'Duesten',0,0,9,5,1,0),
+(70207,'Beryl',0,0,0,0,0,12),
+(70208,'Miles',0,0,2,7,9,2),
+(70209,'Malakai',0,4,3,2,6,8),
+(70210,'Cobb',0,5,6,6,4,14),
+(70211,'Shanda',1,1,0,2,7,4),
+(70212,'Laurna',1,0,7,0,2,4),
+(70213,'Tai\'jin',1,0,3,1,6,5),
+(70214,'Ken\'jai',0,5,2,4,3,0),
+(70215,'Astarii',1,0,0,0,0,0),
+(70216,'Jandria',1,1,1,5,3,0),
+(70217,'Lariia',1,0,3,3,6,0),
+(70218,'Lankester',0,2,0,9,4,16),
+(70219,'Lazarus',0,0,0,6,6,14),
+(70220,'Theodrus',0,2,6,5,7,4),
+(70221,'Braenna',1,0,1,1,0,0),
+(70222,'Toldren',0,4,1,3,3,10),
+(70223,'Benjamin',0,9,11,0,0,8),
+(70224,'Joshua',0,3,0,1,1,8),
+(70225,'Zayus',0,2,0,3,1,4),
+(70226,'X\'yera',0,2,1,2,4,4),
+(70227,'Ur\'kyo',0,0,2,2,3,2),
+(70228,'Nara',1,0,7,4,1,3),
+(70229,'Alathea',1,4,3,0,4,5),
+(70230,'Rohan',0,0,9,4,7,5),
+(70231,'Arena',1,0,2,2,1,0),
+(70232,'Ponaris',0,1,0,1,2,0),
+(70233,'Zalduun',0,9,0,0,0,0),
+(70234,'Aldrae',0,3,1,1,1,0),
+(70235,'Lotheolan',0,8,8,1,2,0),
+(70236,'Belestra',1,4,0,1,3,0),
+(70237,'Caedmos',0,4,0,0,4,3),
+(70238,'Guvan',0,12,0,5,6,4),
+(70239,'Izmir',0,7,0,4,6,6),
+(70240,'Fallat',0,7,1,4,6,6),
+(70251,'Haromm',0,0,3,5,0,6),
+(70252,'Siln',1,10,1,3,2,1),
+(70253,'Tigor',0,13,2,2,2,1),
+(70254,'Beram',0,10,0,2,0,5),
+(70255,'Meela',1,8,1,3,0,0),
+(70256,'Narm',0,17,0,6,1,4),
+(70257,'Shikrik',1,3,4,5,1,1),
+(70258,'Swart',0,0,4,5,0,7),
+(70259,'Kardris',1,0,4,7,0,6),
+(70260,'Sian\'tsu',1,3,3,3,1,3),
+(70261,'Sagorne',0,6,1,1,1,2),
+-- (70262,'Firmanvaar',0,0,0,1,0,0),
+-- (70263,'Nobundo',0,0,0,0,0,0),
+-- (70264,'Tuluun',0,0,0,0,0,0),
+(70265,'Sulaa',1,7,2,2,4,6),
+(70266,'Hobahken',0,0,0,0,0,0),
+(70267,'Umbrua',1,1,7,5,5,1),
+(70268,'Javad',0,4,1,6,0,1),
+(70301,'Khelden',0,7,5,7,0,5),
+(70302,'Zaldimar',0,2,10,11,9,3),
+(70303,'Maginor',0,1,9,8,7,4),
+(70304,'Marryk',0,0,4,6,7,1),
+(70305,'Magis',0,1,5,4,6,4),
+(70306,'Isabella',1,2,0,7,1,5),
+(70307,'Cain',0,0,0,7,1,10),
+(70308,'Shymm',0,5,6,6,5,12),
+(70309,'Ursyn',1,0,5,9,1,7),
+(70310,'Thurston',0,4,1,5,5,1),
+(70311,'Pierce',0,0,2,5,8,2),
+(70312,'Anastasia',1,2,7,3,8,5),
+(70313,'Bink',1,2,1,1,6,0),
+(70314,'Juli',1,1,5,5,3,0),
+(70315,'Nittlebur',0,0,4,0,7,6),
+(70316,'Jennea',1,5,4,5,4,4),
+(70317,'Un\'Thuwa',0,1,2,1,3,4),
+(70318,'Pephredo',1,0,4,1,2,5),
+(70319,'Enyo',1,3,4,4,0,0),
+(70320,'Mai\'ah',1,1,2,1,1,5),
+(70321,'Deino',1,2,0,3,3,2),
+(70322,'Uthel\'nay',0,3,4,2,3,0),
+(70323,'Dink',0,1,3,2,6,1),
+(70324,'Julia',1,2,6,2,0,0),
+(70325,'Garridel',1,3,1,2,2,0),
+(70326,'Valaatu',1,9,6,7,6,5),
+(70327,'Zaedana',1,3,2,2,1,0),
+(70328,'Quithas',0,2,3,1,1,0),
+(70329,'Inethven',0,0,0,0,3,0),
+(70330,'Narinth',1,0,2,2,0,0),
+(70331,'Edirah',1,5,0,5,3,0),
+(70332,'Valustraa',1,5,5,9,6,5),
+(70333,'Semid',0,8,9,8,0,7),
+(70334,'Harnan',0,8,8,7,1,3),
+(70335,'Bati',1,8,1,2,1,0),
+(70336,'Derek',0,5,3,3,1,5),
+(70351,'Drusilla',1,0,10,4,0,0),
+(70352,'Alamar',0,2,2,3,2,5),
+(70353,'Demisette',1,0,9,2,0,0),
+(70354,'Maximillian',0,1,10,6,0,6),
+(70355,'Kartosh',0,0,7,0,1,6),
+(70356,'Maximillion',0,5,0,9,5,5),
+(70357,'Rupert',0,0,0,0,0,8),
+(70358,'Nartok',0,0,6,4,0,1),
+(70359,'Dhugru',0,5,6,4,3,9),
+(70360,'Grol\'dar',0,3,2,3,1,2),
+(70361,'Mirket',1,5,3,7,0,5),
+(70362,'Zevrost',0,3,7,5,5,9),
+(70363,'Kaal',0,3,1,4,2,3),
+(70364,'Luther',0,4,9,0,0,0),
+(70365,'Richard',0,5,5,0,0,0),
+(70366,'Thistleheart',0,3,2,6,3,0),
+(70367,'Briarthorn',0,0,6,1,0,3),
+(70368,'Alexander',0,0,10,11,0,6),
+(70369,'Ursula',1,1,4,18,3,6),
+(70370,'Sandahl',0,4,2,11,1,6),
+(70371,'Gimrizz',0,2,5,2,0,3),
+(70372,'Teli\'Larien',0,0,0,0,0,0),
+(70373,'Celoenus',0,0,0,2,0,0),
+(70374,'Alamma',0,0,1,0,0,0),
+(70375,'Talionia',1,0,2,1,2,0),
+(70376,'Zanien',0,0,0,0,3,0),
+(70377,'Babagaya',1,0,6,0,3,0),
+(70401,'Turak',0,4,3,5,0,5),
+(70402,'Sheal',1,7,0,3,1,1),
+(70403,'Kym',1,9,2,3,0,0),
+(70404,'Gart',0,13,1,3,2,2),
+(70405,'Gennia',1,9,3,0,1,3),
+(70406,'Mardant',0,1,1,2,0,4),
+(70407,'Kal',0,2,2,4,4,2),
+(70408,'Mathrengyl',0,5,0,2,6,3),
+(70409,'Denatharion',0,4,8,3,2,5),
+(70410,'Fylerian',0,2,1,4,5,0),
+(70411,'Sheldras',0,0,3,2,2,4),
+(70412,'Theridran',0,2,1,3,7,3),
+(70413,'Maldryn',0,2,8,5,4,0),
+(70414,'Jannos',0,5,3,2,1,5),
+(70415,'Golhine',0,0,2,6,0,4),
+(70416,'Loganaar',0,2,1,1,0,1),
+(70417,'Harene',1,6,0,3,2,4),
+(70418,'Shalannius',0,4,3,0,4,5),
+(70451,'Siouxsie',1,9,9,3,4,9),
+(70452,'Imhadria',1,10,8,6,1,0),
+(70453,'Vaelen',0,16,9,11,9,8),
+(70454,'Mynx',1,10,0,17,11,0),
+(70455,'Lankral',0,6,13,16,12,4),
+(70456,'Sliver',0,10,11,11,6,0),
+(70457,'Vereth',0,4,0,8,9,10),
+(70458,'Arly',1,7,9,2,8,4),
+(70459,'Setaal',1,14,12,15,9,2),
+(70460,'Uzo',0,8,7,8,9,18),
+(70461,'Illyrie',1,9,11,1,12,0),
+(70462,'Crok',0,11,9,10,7,3),
+(70463,'Zor\'be',0,8,7,6,9,18),
+(70464,'Datura',1,10,11,11,18,0),
+(70465,'Stefan',0,10,12,6,12,2),
+-- (70551,'Gorkramato',0,0,14,9,7,5);
+(70555,'Detrae',0,3,12,11,19,4);
diff --git a/sql/Bots/2_world_bot_extras.sql b/sql/Bots/2_world_bot_extras.sql
new file mode 100644
index 0000000..2a17a85
--- /dev/null
+++ b/sql/Bots/2_world_bot_extras.sql
@@ -0,0 +1,358 @@
+DROP TABLE IF EXISTS `creature_template_npcbot_extras`;
+
+CREATE TABLE `creature_template_npcbot_extras` (
+  `entry` mediumint(8) unsigned NOT NULL,
+  `class` tinyint(3) unsigned NOT NULL DEFAULT '1',
+  `race` tinyint(3) unsigned NOT NULL DEFAULT '1',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+INSERT INTO `creature_template_npcbot_extras` (`entry`,`class`,`race`) VALUES
+('70001', '1', '1'),
+('70002', '1', '3'),
+('70003', '1', '1'),
+('70004', '1', '3'),
+('70005', '1', '2'),
+('70006', '1', '3'),
+('70007', '1', '3'),
+('70008', '1', '5'),
+('70009', '1', '5'),
+('70010', '1', '6'),
+('70011', '1', '6'),
+('70012', '1', '6'),
+('70013', '1', '6'),
+('70014', '1', '6'),
+('70015', '1', '2'),
+('70016', '1', '2'),
+('70017', '1', '2'),
+('70018', '1', '2'),
+('70019', '1', '8'),
+('70020', '1', '4'),
+('70021', '1', '4'),
+('70022', '1', '4'),
+('70023', '1', '4'),
+('70024', '1', '5'),
+('70025', '1', '5'),
+('70026', '1', '5'),
+('70027', '1', '3'),
+('70028', '1', '7'),
+('70029', '1', '1'),
+('70030', '1', '1'),
+('70031', '1', '4'),
+('70032', '1', '1'),
+('70033', '1', '11'),
+('70034', '1', '11'),
+('70035', '1', '11'),
+('70036', '1', '11'),
+('70037', '1', '11'),
+('70038', '1', '4'),
+('70051', '2', '1'),
+('70052', '2', '3'),
+('70053', '2', '1'),
+('70054', '2', '1'),
+('70055', '2', '3'),
+('70056', '2', '3'),
+('70057', '2', '3'),
+('70058', '2', '3'),
+('70059', '2', '1'),
+('70060', '2', '1'),
+('70061', '2', '1'),
+('70062', '2', '10'),
+('70063', '2', '10'),
+('70064', '2', '11'),
+('70065', '2', '10'),
+('70066', '2', '10'),
+('70067', '2', '10'),
+('70068', '2', '11'),
+('70069', '2', '11'),
+('70070', '2', '11'),
+('70071', '2', '11'),
+('70072', '2', '10'),
+('70073', '2', '10'),
+('70074', '2', '11'),
+('70101', '3', '3'),
+('70102', '3', '2'),
+('70103', '3', '3'),
+('70104', '3', '2'),
+('70105', '3', '6'),
+('70106', '3', '6'),
+('70107', '3', '6'),
+('70108', '3', '6'),
+('70109', '3', '6'),
+('70110', '3', '8'),
+('70111', '3', '2'),
+('70112', '3', '2'),
+('70113', '3', '8'),
+('70114', '3', '8'),
+('70115', '3', '4'),
+('70116', '3', '4'),
+('70117', '3', '4'),
+('70118', '3', '4'),
+('70119', '3', '4'),
+('70120', '3', '4'),
+('70121', '3', '3'),
+('70122', '3', '3'),
+('70123', '3', '3'),
+('70124', '3', '4'),
+('70125', '3', '3'),
+('70126', '3', '3'),
+('70127', '3', '3'),
+('70128', '3', '4'),
+('70129', '3', '3'),
+('70130', '3', '10'),
+('70131', '3', '10'),
+('70132', '3', '11'),
+('70133', '3', '10'),
+('70134', '3', '10'),
+('70135', '3', '11'),
+('70136', '3', '11'),
+('70137', '3', '11'),
+('70138', '3', '11'),
+('70139', '3', '11'),
+('70151', '4', '1'),
+('70152', '4', '3'),
+('70153', '4', '1'),
+('70154', '4', '1'),
+('70155', '4', '3'),
+('70156', '4', '1'),
+('70157', '4', '5'),
+('70158', '4', '5'),
+('70159', '4', '2'),
+('70160', '4', '2'),
+('70161', '4', '2'),
+('70162', '4', '2'),
+('70163', '4', '8'),
+('70164', '4', '4'),
+('70165', '4', '4'),
+('70166', '4', '4'),
+('70167', '4', '4'),
+('70168', '4', '4'),
+('70169', '4', '5'),
+('70170', '4', '5'),
+('70171', '4', '5'),
+('70172', '4', '3'),
+('70173', '4', '3'),
+('70174', '4', '7'),
+('70175', '4', '1'),
+('70176', '4', '1'),
+('70177', '4', '10'),
+('70178', '4', '10'),
+('70179', '4', '10'),
+('70180', '4', '10'),
+('70181', '4', '10'),
+('70201', '5', '1'),
+('70202', '5', '1'),
+('70203', '5', '1'),
+('70204', '5', '3'),
+('70205', '5', '3'),
+('70206', '5', '5'),
+('70207', '5', '5'),
+('70208', '5', '5'),
+('70209', '5', '5'),
+('70210', '5', '5'),
+('70211', '5', '4'),
+('70212', '5', '4'),
+('70213', '5', '8'),
+('70214', '5', '8'),
+('70215', '5', '4'),
+('70216', '5', '4'),
+('70217', '5', '4'),
+('70218', '5', '5'),
+('70219', '5', '5'),
+('70220', '5', '3'),
+('70221', '5', '3'),
+('70222', '5', '3'),
+('70223', '5', '1'),
+('70224', '5', '1'),
+('70225', '5', '8'),
+('70226', '5', '8'),
+('70227', '5', '8'),
+('70228', '5', '4'),
+('70229', '5', '4'),
+('70230', '5', '3'),
+('70231', '5', '10'),
+('70232', '5', '10'),
+('70233', '5', '11'),
+('70234', '5', '10'),
+('70235', '5', '10'),
+('70236', '5', '10'),
+('70237', '5', '11'),
+('70238', '5', '11'),
+('70239', '5', '11'),
+('70240', '5', '11'),
+('70251', '7', '2'),
+('70252', '7', '6'),
+('70253', '7', '6'),
+('70254', '7', '6'),
+('70255', '7', '6'),
+('70256', '7', '6'),
+('70257', '7', '2'),
+('70258', '7', '2'),
+('70259', '7', '2'),
+('70260', '7', '8'),
+('70261', '7', '6'),
+('70265', '7', '11'),
+('70267', '7', '11'),
+('70268', '7', '11'),
+('70301', '8', '1'),
+('70302', '8', '1'),
+('70303', '8', '1'),
+('70304', '8', '7'),
+('70305', '8', '7'),
+('70306', '8', '5'),
+('70307', '8', '5'),
+('70308', '8', '5'),
+('70309', '8', '5'),
+('70310', '8', '5'),
+('70311', '8', '5'),
+('70312', '8', '5'),
+('70313', '8', '7'),
+('70314', '8', '7'),
+('70315', '8', '7'),
+('70316', '8', '1'),
+('70317', '8', '8'),
+('70318', '8', '8'),
+('70319', '8', '8'),
+('70320', '8', '8'),
+('70321', '8', '8'),
+('70322', '8', '8'),
+('70323', '8', '7'),
+('70324', '8', '10'),
+('70325', '8', '10'),
+('70326', '8', '11'),
+('70327', '8', '10'),
+('70328', '8', '10'),
+('70329', '8', '10'),
+('70330', '8', '10'),
+('70331', '8', '11'),
+('70332', '8', '11'),
+('70333', '8', '11'),
+('70334', '8', '11'),
+('70335', '8', '11'),
+('70336', '8', '5'),
+('70351', '9', '1'),
+('70352', '9', '7'),
+('70353', '9', '1'),
+('70354', '9', '1'),
+('70355', '9', '2'),
+('70356', '9', '5'),
+('70357', '9', '5'),
+('70358', '9', '2'),
+('70359', '9', '2'),
+('70360', '9', '2'),
+('70361', '9', '2'),
+('70362', '9', '2'),
+('70363', '9', '2'),
+('70364', '9', '5'),
+('70365', '9', '5'),
+('70366', '9', '7'),
+('70367', '9', '7'),
+('70368', '9', '1'),
+('70369', '9', '1'),
+('70370', '9', '1'),
+('70371', '9', '7'),
+('70372', '9', '10'),
+('70373', '9', '10'),
+('70374', '9', '10'),
+('70375', '9', '10'),
+('70376', '9', '10'),
+('70377', '9', '7'),
+('70401', '11', '6'),
+('70402', '11', '6'),
+('70403', '11', '6'),
+('70404', '11', '6'),
+('70405', '11', '6'),
+('70406', '11', '4'),
+('70407', '11', '4'),
+('70408', '11', '4'),
+('70409', '11', '4'),
+('70410', '11', '4'),
+('70411', '11', '4'),
+('70412', '11', '4'),
+('70413', '11', '6'),
+('70414', '11', '6'),
+('70415', '11', '4'),
+('70416', '11', '4'),
+('70417', '11', '6'),
+('70418', '11', '4'),
+('70451', '6', '4'),
+('70452', '6', '10'),
+('70453', '6', '11'),
+('70454', '6', '10'),
+('70455', '6', '1'),
+('70456', '6', '10'),
+('70457', '6', '5'),
+('70458', '6', '7'),
+('70459', '6', '11'),
+('70460', '6', '8'),
+('70461', '6', '4'),
+('70462', '6', '2'),
+('70463', '6', '8'),
+('70464', '6', '10'),
+('70465', '6', '1'),
+('70501', '0', '0'),
+('70502', '0', '0'),
+('70503', '0', '0'),
+('70504', '0', '0'),
+('70505', '0', '0'),
+('70506', '0', '0'),
+('70507', '0', '0'),
+('70508', '0', '0'),
+('70509', '0', '0'),
+('70510', '0', '0'),
+('70511', '0', '0'),
+('70512', '0', '0'),
+('70513', '0', '0'),
+('70514', '0', '0'),
+('70515', '0', '0'),
+('70516', '0', '0'),
+('70517', '0', '0'),
+('70518', '0', '0'),
+('70519', '0', '0'),
+('70520', '0', '0'),
+('70521', '0', '0'),
+('70522', '0', '0'),
+('70523', '0', '0'),
+('70524', '0', '0'),
+('70525', '0', '0'),
+('70526', '0', '0'),
+('70527', '0', '0'),
+('70528', '0', '0'),
+('70529', '0', '0'),
+('70530', '0', '0'),
+('70531', '0', '0'),
+('70532', '0', '0'),
+('70533', '0', '0'),
+('70534', '0', '0'),
+('70535', '0', '0'),
+('70536', '0', '0'),
+('70537', '0', '0'),
+('70538', '0', '0'),
+('70542', '0', '0'),
+('70543', '0', '0'),
+('70544', '0', '0'),
+('70545', '0', '0'),
+('70551', '12', '15'),
+('70552', '12', '15'),
+('70553', '13', '15'),
+('70554', '13', '15'),
+('70555', '14', '1'),
+('70556', '0', '0'),
+('70557', '15', '15'),
+('70558', '15', '15'),
+('70559', '15', '15'),
+('70560', '15', '15'),
+('70561', '15', '15'),
+('70562', '0', '0'),
+('70563', '16', '15'),
+('70564', '16', '15'),
+('70565', '16', '15'),
+('70566', '16', '15'),
+('70567', '16', '15'),
+('70568', '17', '10'),
+('70569', '17', '10'),
+('70570', '17', '10'),
+('70571', '17', '10'),
+('70572', '17', '10'),
+('70573', '0', '15'),
+('70574', '0', '15');
diff --git a/sql/Bots/3_world_bots.sql b/sql/Bots/3_world_bots.sql
new file mode 100644
index 0000000..725010f
--- /dev/null
+++ b/sql/Bots/3_world_bots.sql
@@ -0,0 +1,547 @@
+-- GENERAL --
+
+SET @BOT_START = 70001;
+SET @BOT_END   = 71000;
+
+-- move to creature_template_movement InhabitType
+-- Resistance
+-- basevariance, rangevariance -- spell_school_immune_mask -- damage modifier, expirience modifier
+
+-- TOTAL BOT ENTRIES: 352 (348)
+
+delete from `creature_template` where entry between @BOT_START and @BOT_END;
+
+insert into `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,
+`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,
+`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`type`,`type_flags`,`lootid`,
+`pickpocketloot`,`skinloot`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,
+`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`RacialLeader`,`movementId`,`RegenHealth`,
+`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`)
+values
+('70001','0','0','0','0','0','3343','0','0','0','Llane','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70002','0','0','0','0','0','3399','0','0','0','Thran','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70003','0','0','0','0','0','1300','0','0','0','Lyria','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70004','0','0','0','0','0','3431','0','0','0','Ander','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70005','0','0','0','0','0','4556','0','0','0','Malosh','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70006','0','0','0','0','0','3431','0','0','0','Granis','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70007','0','0','0','0','0','3053','0','0','0','Kelstrum','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70008','0','0','0','0','0','1578','0','0','0','Dannal','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70009','0','0','0','0','0','1599','0','0','0','Austil','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70010','0','0','0','0','0','2103','0','0','0','Torm','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70011','0','0','0','0','0','2096','0','0','0','Sark','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70012','0','0','0','0','0','2113','0','0','0','Ker','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70013','0','0','0','0','0','3793','0','0','0','Harutt','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70014','0','0','0','0','0','3794','0','0','0','Krang','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70015','0','0','0','0','0','1880','0','0','0','Frang','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70016','0','0','0','0','0','3743','0','0','0','Tarshaw','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70017','0','0','0','0','0','1374','0','0','0','Grezz','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70018','0','0','0','0','0','1375','0','0','0','Sorek','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70019','0','0','0','0','0','4242','0','0','0','Zel\'mak','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70020','0','0','0','0','0','1721','0','0','0','Alyissia','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70021','0','0','0','0','0','1707','0','0','0','Kyra','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70022','0','0','0','0','0','2196','0','0','0','Arias\'ta','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70023','0','0','0','0','0','2198','0','0','0','Sildanair','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70024','0','0','0','0','0','2620','0','0','0','Chris','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70025','0','0','0','0','0','2658','0','0','0','Angela','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70026','0','0','0','0','0','2614','0','0','0','Baltus','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70027','0','0','0','0','0','3054','0','0','0','Kelv','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70028','0','0','0','0','0','3055','0','0','0','Bilban','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70029','0','0','0','0','0','3280','0','0','0','Wu','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70030','0','0','0','0','0','3287','0','0','0','Ilsa','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70031','0','0','0','0','0','6071','0','0','0','Darnath','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70032','0','0','0','0','0','11037','0','0','0','Evencane','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70033','0','0','0','0','0','16226','0','0','0','Kore','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70034','0','0','0','0','0','17212','0','0','0','Ahonan','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70035','0','0','0','0','0','17213','0','0','0','Behomat','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70036','0','0','0','0','0','17215','0','0','0','Ruada','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70037','0','0','0','0','0','17214','0','0','0','Kazi','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70038','0','0','0','0','0','17211','0','0','0','Kerra','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+-- 70039 - 70050 reserved for warriors
+('70051','0','0','0','0','0','3346','0','0','0','Sammuel','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70052','0','0','0','0','0','3393','0','0','0','Bromos','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70053','0','0','0','0','0','1299','0','0','0','Wilhelm','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70054','0','0','0','0','0','1499','0','0','0','Grayson','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70055','0','0','0','0','0','1622','0','0','0','Azar','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70056','0','0','0','0','0','3089','0','0','0','Valgar','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70057','0','0','0','0','0','3088','0','0','0','Beldruk','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70058','0','0','0','0','0','3087','0','0','0','Brandur','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70059','0','0','0','0','0','3284','0','0','0','Arthur','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70060','0','0','0','0','0','3289','0','0','0','Katherine','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70061','0','0','0','0','0','7356','0','0','0','Karman','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70062','0','0','0','0','0','15521','0','0','0','Jesthenis','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70063','0','0','0','0','0','16685','0','0','0','Noellene','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70064','0','0','0','0','0','16224','0','0','0','Aurelon','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70065','0','0','0','0','0','16815','0','0','0','Osselan','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70066','0','0','0','0','0','16811','0','0','0','Ithelis','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70067','0','0','0','0','0','16829','0','0','0','Bachi','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70068','0','0','0','0','0','17225','0','0','0','Baatun','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70069','0','0','0','0','0','17227','0','0','0','Kavaan','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70070','0','0','0','0','0','17234','0','0','0','Tullas','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70071','0','0','0','0','0','17226','0','0','0','Jol','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70072','0','0','0','0','0','19596','0','0','0','Cyssa','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70073','0','0','0','0','0','21264','0','0','0','Pyreanor','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70074','0','0','0','0','0','29735','0','0','0','Rukua','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+-- 70075 - 70100 reserved for paldins
+('70101','0','0','0','0','0','3395','0','0','0','Thorgas','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70102','0','0','0','0','0','4560','0','0','0','Ogromm','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70103','0','0','0','0','0','3558','0','0','0','Grif','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70104','0','0','0','0','0','4372','0','0','0','Kragg','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70105','0','0','0','0','0','2112','0','0','0','Kary','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70106','0','0','0','0','0','2087','0','0','0','Holt','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70107','0','0','0','0','0','2105','0','0','0','Urek','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70108','0','0','0','0','0','3810','0','0','0','Lanka','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70109','0','0','0','0','0','3811','0','0','0','Yaw','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70110','0','0','0','0','0','1882','0','0','0','Jen\'shan','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70111','0','0','0','0','0','3744','0','0','0','Thotar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70112','0','0','0','0','0','1373','0','0','0','Ormak','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70113','0','0','0','0','0','4239','0','0','0','Xor\'juul','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70114','0','0','0','0','0','4241','0','0','0','Sian\'dur','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70115','0','0','0','0','0','1723','0','0','0','Ayanna','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70116','0','0','0','0','0','1703','0','0','0','Dazalar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70117','0','0','0','0','0','2066','0','0','0','Danlaar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70118','0','0','0','0','0','2205','0','0','0','Jeen\'ra','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70119','0','0','0','0','0','2206','0','0','0','Jocaste','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70120','0','0','0','0','0','2251','0','0','0','Dorion','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70121','0','0','0','0','0','3056','0','0','0','Daera','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70122','0','0','0','0','0','3072','0','0','0','Olmin','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70123','0','0','0','0','0','3073','0','0','0','Regnus','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70124','0','0','0','0','0','3299','0','0','0','Kaerbrus','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70125','0','0','0','0','0','3312','0','0','0','Einris','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70126','0','0','0','0','0','3309','0','0','0','Ulfir','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70127','0','0','0','0','0','3310','0','0','0','Thorfin','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70128','0','0','0','0','0','7538','0','0','0','Alenndaar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70129','0','0','0','0','0','10245','0','0','0','Dargh','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70130','0','0','0','0','0','15520','0','0','0','Sallina','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70131','0','0','0','0','0','16681','0','0','0','Hannovia','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70132','0','0','0','0','0','16222','0','0','0','Keilnei','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70133','0','0','0','0','0','16778','0','0','0','Tana','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70134','0','0','0','0','0','16816','0','0','0','Oninath','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70135','0','0','0','0','0','16802','0','0','0','Zandine','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70136','0','0','0','0','0','17434','0','0','0','Deremiis','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70137','0','0','0','0','0','16860','0','0','0','Acteon','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70138','0','0','0','0','0','17511','0','0','0','Vord','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70139','0','0','0','0','0','17488','0','0','0','Killac','Hunter bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+-- 70140 - 70150 reserved for hunters
+('70151','0','0','0','0','0','3351','0','0','0','Jorik','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70152','0','0','0','0','0','3407','0','0','0','Solm','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70153','0','0','0','0','0','1297','0','0','0','Keryn','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70154','0','0','0','0','0','1507','0','0','0','Osborne','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70155','0','0','0','0','0','3436','0','0','0','Hogral','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70156','0','0','0','0','0','5146','0','0','0','Ian','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70157','0','0','0','0','0','1580','0','0','0','David','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70158','0','0','0','0','0','2130','0','0','0','Marion','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70159','0','0','0','0','0','1886','0','0','0','Rwag','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70160','0','0','0','0','0','3749','0','0','0','Kaplak','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70161','0','0','0','0','0','1327','0','0','0','Gest','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70162','0','0','0','0','0','1328','0','0','0','Ormok','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70163','0','0','0','0','0','4360','0','0','0','Shenthul','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70164','0','0','0','0','0','1725','0','0','0','Frahun','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70165','0','0','0','0','0','1704','0','0','0','Jannok','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70166','0','0','0','0','0','2231','0','0','0','Syurna','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70167','0','0','0','0','0','2252','0','0','0','Erion','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70168','0','0','0','0','0','2243','0','0','0','Anishar','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70169','0','0','0','0','0','2659','0','0','0','Carolyn','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70170','0','0','0','0','0','2639','0','0','0','Miles','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70171','0','0','0','0','0','2631','0','0','0','Gregory','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70172','0','0','0','0','0','3101','0','0','0','Hulfdan','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70173','0','0','0','0','0','3100','0','0','0','Ormyr','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70174','0','0','0','0','0','3113','0','0','0','Fenthwick','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70175','0','0','0','0','0','5528','0','0','0','Fahrad','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70176','0','0','0','0','0','13171','0','0','0','Tony','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70177','0','0','0','0','0','15519','0','0','0','Kariel','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70178','0','0','0','0','0','16689','0','0','0','Tannaria','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70179','0','0','0','0','0','16767','0','0','0','Zelanis','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70180','0','0','0','0','0','16798','0','0','0','Elara','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70181','0','0','0','0','0','16818','0','0','0','Nerisen','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+-- 70182 - 70200 reserved for rogues
+('70201','0','0','0','0','0','3344','0','0','0','Anetta','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70202','0','0','0','0','0','1495','0','0','0','Laurena','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70203','0','0','0','0','0','1295','0','0','0','Josetta','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70204','0','0','0','0','0','3401','0','0','0','Branstock','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70205','0','0','0','0','0','3429','0','0','0','Maxan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70206','0','0','0','0','0','1579','0','0','0','Duesten','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70207','0','0','0','0','0','1602','0','0','0','Beryl','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70208','0','0','0','0','0','2139','0','0','0','Miles','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70209','0','0','0','0','0','2138','0','0','0','Malakai','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70210','0','0','0','0','0','2137','0','0','0','Cobb','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70211','0','0','0','0','0','1733','0','0','0','Shanda','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70212','0','0','0','0','0','1708','0','0','0','Laurna','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70213','0','0','0','0','0','1897','0','0','0','Tai\'jin','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70214','0','0','0','0','0','4068','0','0','0','Ken\'jai','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70215','0','0','0','0','0','2200','0','0','0','Astarii','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70216','0','0','0','0','0','2201','0','0','0','Jandria','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70217','0','0','0','0','0','2202','0','0','0','Lariia','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70218','0','0','0','0','0','2626','0','0','0','Lankester','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70219','0','0','0','0','0','2618','0','0','0','Lazarus','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70220','0','0','0','0','0','3086','0','0','0','Theodrus','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70221','0','0','0','0','0','3066','0','0','0','Braenna','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70222','0','0','0','0','0','3085','0','0','0','Toldren','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70223','0','0','0','0','0','3282','0','0','0','Benjamin','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70224','0','0','0','0','0','3283','0','0','0','Joshua','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70225','0','0','0','0','0','4690','0','0','0','Zayus','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70226','0','0','0','0','0','10473','0','0','0','X\'yera','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70227','0','0','0','0','0','4711','0','0','0','Ur\'kyo','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70228','0','0','0','0','0','11044','0','0','0','Nara','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70229','0','0','0','0','0','11048','0','0','0','Alathea','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70230','0','0','0','0','0','11053','0','0','0','Rohan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70231','0','0','0','0','0','15518','0','0','0','Arena','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70232','0','0','0','0','0','16707','0','0','0','Ponaris','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70233','0','0','0','0','0','16225','0','0','0','Zalduun','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70234','0','0','0','0','0','16788','0','0','0','Aldrae','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70235','0','0','0','0','0','16817','0','0','0','Lotheolan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70236','0','0','0','0','0','16795','0','0','0','Belestra','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70237','0','0','0','0','0','17247','0','0','0','Caedmos','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70238','0','0','0','0','0','17232','0','0','0','Guvan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70239','0','0','0','0','0','17249','0','0','0','Izmir','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70240','0','0','0','0','0','17248','0','0','0','Fallat','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+-- 70241 - 70250 reserved for priests
+('70251','0','0','0','0','0','4552','0','0','0','Haromm','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70252','0','0','0','0','0','2123','0','0','0','Siln','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70253','0','0','0','0','0','2102','0','0','0','Tigor','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70254','0','0','0','0','0','2082','0','0','0','Beram','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70255','0','0','0','0','0','10180','0','0','0','Meela','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70256','0','0','0','0','0','3816','0','0','0','Narm','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70257','0','0','0','0','0','1878','0','0','0','Shikrik','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70258','0','0','0','0','0','3746','0','0','0','Swart','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70259','0','0','0','0','0','1360','0','0','0','Kardris','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70260','0','0','0','0','0','4231','0','0','0','Sian\'tsu','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70261','0','0','0','0','0','13341','0','0','0','Sagorne','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70262','0','0','0','0','0','17598','0','0','0','Firmanvaar','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70263','0','0','0','0','0','17600','0','0','0','Nobundo','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70264','0','0','0','0','0','17599','0','0','0','Tuluun','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70265','0','0','0','0','0','16914','0','0','0','Sulaa','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70266','0','0','0','0','0','17792','0','0','0','Hobahken','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70267','0','0','0','0','0','19598','0','0','0','Umbrua','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70268','0','0','0','0','0','21265','0','0','0','Javad','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- 70269 - 70300 reserved for shamans
+('70301','0','0','0','0','0','5001','0','0','0','Khelden','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70302','0','0','0','0','0','1294','0','0','0','Zaldimar','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70303','0','0','0','0','0','1484','0','0','0','Maginor','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70304','0','0','0','0','0','10216','0','0','0','Marryk','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70305','0','0','0','0','0','10215','0','0','0','Magis','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70306','0','0','0','0','0','1592','0','0','0','Isabella','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70307','0','0','0','0','0','1600','0','0','0','Cain','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70308','0','0','0','0','0','2134','0','0','0','Shymm','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70309','0','0','0','0','0','6058','0','0','0','Ursyn','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70310','0','0','0','0','0','2135','0','0','0','Thurston','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70311','0','0','0','0','0','2644','0','0','0','Pierce','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70312','0','0','0','0','0','2657','0','0','0','Anastasia','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70313','0','0','0','0','0','3108','0','0','0','Bink','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70314','0','0','0','0','0','10214','0','0','0','Juli','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70315','0','0','0','0','0','3109','0','0','0','Nittlebur','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70316','0','0','0','0','0','3292','0','0','0','Jennea','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70317','0','0','0','0','0','10171','0','0','0','Un\'Thuwa','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70318','0','0','0','0','0','4524','0','0','0','Pephredo','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70319','0','0','0','0','0','4522','0','0','0','Enyo','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70320','0','0','0','0','0','4526','0','0','0','Mai\'ah','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70321','0','0','0','0','0','4523','0','0','0','Deino','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70322','0','0','0','0','0','6060','0','0','0','Uthel\'nay','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70323','0','0','0','0','0','6072','0','0','0','Dink','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70324','0','0','0','0','0','15522','0','0','0','Julia','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70325','0','0','0','0','0','16680','0','0','0','Garridel','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70326','0','0','0','0','0','16223','0','0','0','Valaatu','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70327','0','0','0','0','0','16781','0','0','0','Zaedana','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70328','0','0','0','0','0','16824','0','0','0','Quithas','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70329','0','0','0','0','0','16809','0','0','0','Inethven','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70330','0','0','0','0','0','16777','0','0','0','Narinth','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70331','0','0','0','0','0','17242','0','0','0','Edirah','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70332','0','0','0','0','0','16856','0','0','0','Valustraa','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70333','0','0','0','0','0','17233','0','0','0','Semid','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70334','0','0','0','0','0','17243','0','0','0','Harnan','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70335','0','0','0','0','0','17241','0','0','0','Bati','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70336','0','0','0','0','0','11466','0','0','0','Derek','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+-- 70337 - 70350 reserved for mages
+('70351','0','0','0','0','0','3345','0','0','0','Drusilla','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70352','0','0','0','0','0','1930','0','0','0','Alamar','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70353','0','0','0','0','0','1469','0','0','0','Demisette','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70354','0','0','0','0','0','3271','0','0','0','Maximillian','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70355','0','0','0','0','0','4567','0','0','0','Kartosh','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70356','0','0','0','0','0','1581','0','0','0','Maximillion','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70357','0','0','0','0','0','1604','0','0','0','Rupert','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70358','0','0','0','0','0','1884','0','0','0','Nartok','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70359','0','0','0','0','0','3745','0','0','0','Dhugru','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70360','0','0','0','0','0','1324','0','0','0','Grol\'dar','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70361','0','0','0','0','0','1325','0','0','0','Mirket','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70362','0','0','0','0','0','1326','0','0','0','Zevrost','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70363','0','0','0','0','0','2675','0','0','0','Kaal','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70364','0','0','0','0','0','2637','0','0','0','Luther','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70365','0','0','0','0','0','2646','0','0','0','Richard','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70366','0','0','0','0','0','3115','0','0','0','Thistleheart','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70367','0','0','0','0','0','3116','0','0','0','Briarthorn','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70368','0','0','0','0','0','3122','0','0','0','Alexander','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70369','0','0','0','0','0','3291','0','0','0','Ursula','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70370','0','0','0','0','0','3286','0','0','0','Sandahl','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70371','0','0','0','0','0','3607','0','0','0','Gimrizz','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70372','0','0','0','0','0','15524','0','0','0','Teli\'Larien','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70373','0','0','0','0','0','16700','0','0','0','Celoenus','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70374','0','0','0','0','0','16787','0','0','0','Alamma','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70375','0','0','0','0','0','16800','0','0','0','Talionia','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70376','0','0','0','0','0','16831','0','0','0','Zanien','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70377','0','0','0','0','0','21604','0','0','0','Babagaya','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+-- 70378 - 70400 reserved for warlocks
+('70401','0','0','0','0','0','2106','0','0','0','Turak','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70402','0','0','0','0','0','2121','0','0','0','Sheal','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70403','0','0','0','0','0','2115','0','0','0','Kym','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70404','0','0','0','0','0','3819','0','0','0','Gart','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70405','0','0','0','0','0','10734','0','0','0','Gennia','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70406','0','0','0','0','0','1732','0','0','0','Mardant','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70407','0','0','0','0','0','1706','0','0','0','Kal','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70408','0','0','0','0','0','2261','0','0','0','Mathrengyl','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70409','0','0','0','0','0','2250','0','0','0','Denatharion','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70410','0','0','0','0','0','2255','0','0','0','Fylerian','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70411','0','0','0','0','0','3300','0','0','0','Sheldras','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70412','0','0','0','0','0','3301','0','0','0','Theridran','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70413','0','0','0','0','0','3302','0','0','0','Maldryn','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70414','0','0','0','0','0','7357','0','0','0','Jannos','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70415','0','0','0','0','0','10738','0','0','0','Golhine','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70416','0','0','0','0','0','12053','0','0','0','Loganaar','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70417','0','0','0','0','0','16739','0','0','0','Harene','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70418','0','0','0','0','0','16858','0','0','0','Shalannius','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+-- 70419 - 70450 reserved for druids
+('70451','0','0','0','0','0','24935','0','0','0','Siouxsie','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70452','0','0','0','0','0','26939','0','0','0','Imhadria','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70453','0','0','0','0','0','26854','0','0','0','Vaelen','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70454','0','0','0','0','0','28039','0','0','0','Mynx','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70455','0','0','0','0','0','26688','0','0','0','Lankral','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70456','0','0','0','0','0','26195','0','0','0','Sliver','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70457','0','0','0','0','0','27402','0','0','0','Vereth','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70458','0','0','0','0','0','27189','0','0','0','Arly','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70459','0','0','0','0','0','26217','0','0','0','Setaal','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70460','0','0','0','0','0','26222','0','0','0','Uzo','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70461','0','0','0','0','0','28842','0','0','0','Illyrie','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70462','0','0','0','0','0','28837','0','0','0','Crok','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70463','0','0','0','0','0','28840','0','0','0','Zor\'be','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70464','0','0','0','0','0','25512','0','0','0','Datura','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70465','0','0','0','0','0','25500','0','0','0','Stefan','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+-- 70466 - 70500 reserved for deathknights
+('70501','0','0','0','0','0','4449','0','0','0','Imp',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70502','0','0','0','0','0','1132','0','0','0','Voidwalker',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70503','0','0','0','0','0','4162','0','0','0','Succubus',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70504','0','0','0','0','0','850','0','0','0','Felhunter',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70505','0','0','0','0','0','14255','0','0','0','Felguard',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70506','0','0','0','0','0','368','0','0','0','Spider',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70507','0','0','0','0','0','4312','0','0','0','Serpent',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70508','0','0','0','0','0','16724','0','0','0','Bird of Prey',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70509','0','0','0','0','0','8808','0','0','0','Bat',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70510','0','0','0','0','0','17562','0','0','0','Wind Serpent',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70511','0','0','0','0','0','20308','0','0','0','Ravager',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70512','0','0','0','0','0','17545','0','0','0','Dragonhawk',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70513','0','0','0','0','0','19405','0','0','0','Nether Ray',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70514','0','0','0','0','0','17753','0','0','0','Sporebat',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70515','0','0','0','0','0','15590','0','0','0','Carrion Bird',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70516','0','0','0','0','0','11319','0','0','0','Raptor',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70517','0','0','0','0','0','741','0','0','0','Wolf',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70518','0','0','0','0','0','1220','0','0','0','Tallstrider',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70519','0','0','0','0','0','321','0','0','0','Cat',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70520','0','0','0','0','0','2714','0','0','0','Hyena',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70521','0','0','0','0','0','29113','0','0','0','Wasp',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70522','0','0','0','0','0','17798','0','0','0','Teromoth',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70523','0','0','0','0','0','20790','0','0','0','Scorpid',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70524','0','0','0','0','0','1244','0','0','0','Turtle',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70525','0','0','0','0','0','809','0','0','0','Gorilla',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70526','0','0','0','0','0','706','0','0','0','Bear',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70527','0','0','0','0','0','381','0','0','0','Boar',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70528','0','0','0','0','0','1938','0','0','0','Crab',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70529','0','0','0','0','0','1250','0','0','0','Crocolisk',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70530','0','0','0','0','0','19998','0','0','0','Warp Stalker',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70531','0','0','0','0','0','11087','0','0','0','Silithid',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70532','0','0','0','0','0','10810','0','0','0','Chimaera',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70533','0','0','0','0','0','29673','0','0','0','Spirit Beast',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70534','0','0','0','0','0','12168','0','0','0','Core Hound',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70535','0','0','0','0','0','5239','0','0','0','Devilsaur',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70536','0','0','0','0','0','26279','0','0','0','Rhino',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70537','0','0','0','0','0','13212','0','0','0','Worm',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70538','0','0','0','0','0','24994','24993','24992','24995','Risen Ghoul',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','deathknight_pet_bot','-1'),
+-- 70539 - 70541 reserved for dk pets
+('70542','0','0','0','0','0','19110','0','0','0','Shadowfiend',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','5','1500','1500','2','0','0','0','0','10','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','priest_pet_bot','-1'),
+('70543','0','0','0','0','0','21114','0','0','0','Spirit Wolf',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','1500','1500','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','shaman_pet_bot','-1'),
+('70544','0','0','0','0','0','525','0','0','0','Water Elemental',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','4','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','mage_pet_bot','-1'),
+('70545','0','0','0','0','0','18922','0','0','0','Treant',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','4','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','druid_pet_bot','-1'),
+-- 70546 - 70550 reserved for pets
+('70551','0','0','0','0','0','17659','0','0','0','Gorkramato','Blademaster Bot','','0','81','81','2','35','1','1.1','1.1','1','4','0','2200','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157560','blademaster_bot','-1'),
+('70552','0','0','0','0','0','17659','0','0','0','Mirror Image (Blademaster)','Blademaster bot','','0','81','81','2','35','1','1.1','1.1','1','4','0','2200','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157560','blademaster_bot','-1'),
+('70553','0','0','0','0','0','15343','0','0','0','Osis','Obsidian Destroyer Bot','','0','83','83','2','35','1','1.1','1.1','0.7','2','0','1200','1200','8','0','0','0','0','10','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','sphynx_bot','-1'),
+('70554','0','0','0','0','0','15343','0','0','0','Amot','Obsidian Destroyer Bot','','0','83','83','2','35','1','1.1','1.1','0.7','2','0','1200','1200','8','0','0','0','0','10','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','sphynx_bot','-1'),
+('70555','0','0','0','0','0','6769','0','0','0','Detrae','Archmage Bot','','0','81','81','2','35','1','1.1','1.1','1','4','0','1420','1420','8','0','16432','0','0','7','2048','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','archmage_bot','-1'),
+('70556','0','0','0','0','0','5561','0','0','0','Water Elemental',NULL,'','0','81','81','2','35','0','1.2','1.3','1','0','0','1500','1500','1','0','0','0','0','4','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','archmage_pet_bot','-1'),
+('70557','0','0','0','0','0','348','0','0','0','Neroth','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70558','0','0','0','0','0','348','0','0','0','Fearoth','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70559','0','0','0','0','0','348','0','0','0','Zalamon','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70560','0','0','0','0','0','348','0','0','0','Lotthicus','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70561','0','0','0','0','0','348','0','0','0','Ramarot','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70562','0','0','0','0','0','169','0','0','0','Infernal',NULL,'','0','83','83','2','35','0','1.2','1.3','1.5','0','2','1350','1350','1','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','dreadlord_pet_bot','-1'),
+('70563','0','0','0','0','0','15511','0','0','0','Eanor','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70564','0','0','0','0','0','15511','0','0','0','Narsen','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70565','0','0','0','0','0','15511','0','0','0','Caelnor','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70566','0','0','0','0','0','15511','0','0','0','Daenste','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70567','0','0','0','0','0','15511','0','0','0','Neshdar','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70568','0','0','0','0','0','30072','0','0','0','Mara','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70569','0','0','0','0','0','30072','0','0','0','Tani','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70570','0','0','0','0','0','30072','0','0','0','Eva','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70571','0','0','0','0','0','30072','0','0','0','Darise','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70572','0','0','0','0','0','30072','0','0','0','Lyra','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70573','0','0','0','0','0','30363','0','0','0','Dark Minion',NULL,'','0','83','83','2','35','0','1.1','1.1','1','0','0','2000','2000','1','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_pet_bot','-1'),
+('70574','0','0','0','0','0','30363','0','0','0','Dark Minion',NULL,'','0','83','83','2','35','0','1.1','1.1','1','1','0','2000','2000','1','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_pet_bot','-1');
+-- 70575 - 71000 reserved for custom stuff
+
+-- GOSSIPS --
+delete from `npc_text` where ID between @BOT_START and @BOT_END;
+insert into `npc_text` (`ID`,`text0_0`,`VerifiedBuild`)
+values
+('70001','I live only to serve the master.','-1'),
+('70002','You need something?','-1'),
+('70003','Mortals... usually I kill wretches like you at sight.','-1'),
+('70004','<You see what is supposed to be an obsidian destroyer. This one looks different though, damaged and faded, and does not react to your presence. You recall the Scourge have been using their own versions of those at some point in the past. How the hell did it end up here? After further examination you notice an opening on creature\'s back.>','-1'),
+('70005','<Obsidian Destroyer stares at you and makes a low growling sound.>','-1'),
+('70006','Are you surprised, mortal? As a lesser nathrezim I have to resort to seeking out allies. You look like you could amuse me at least.','-1'),
+('70007','What is it now, mortal?','-1'),
+('70008','Can you just leave me be? <sigh>','-1'),
+('70009','Now what?','-1'),
+-- 70010 - 70100 reserved for standard/greet gossips
+('70101','|cffff3300Blademaster|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An elite swordsman, former member of Burning Blade clan, now an elite fighter within the Horde\".$B$BMain attribute: Agility.$B$BNetherwalk (Windwalk). Allows Blademaster to become invisible, and move faster for a set amount of time. When the Blademaster attacks a unit to break invisibility, he will deal bonus damage.$B$BMirror Image. Confuses the enemy by creating illusions of the Blademaster and dispelling all magic from the Blademaster.$B$BCritical Strike (passive). Gives a 15% chance to deal critical x2(x3,x4) times normal damage on his attacks.$B$BBladestorm (NIY). Grants immunity to magic and deals damage to all surrounding enemies.$B$B','-1'),
+('70102','|cff9900ccObsidian Destroyer|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An obsidian winged monstrocity with insatiable hunger for magic\".$B$BHigh armor, very high resistances, partially immune to magic, loses mana over time and doesn\'t benefit from passive mana regeneration effects, mail/plate armor, dual-wielding wands, deals spellshadow damage, no physical attack, cannot attack enemies not in front while moving, spell power bonus: 50% attack power + 200% intellect + wands damage.$B$BDevour Magic. Dispels up to 2 magic effects from enemies, up to 2 magic effects and up to 2 curses from allies and damaging summoned units in 20 yards area. Every dispelled effect restores 20% mana and 5% health, 7 seconds cooldown.$B$BShadow Blast. Empowered attack that deals increased splash damage.$B$BDrain Mana. Drains all mana (limited by caster\'s mana pool) from a random friendly unit.$B$BReplenish Mana. Energizes surrounding party and raid members within 25 yards for 2% of their maximum mana nullifying caster\'s mana, affects up to 10 targets, 3 seconds cooldown.$B$BRegenerating Aura. Heals surrounding party and raid members within 25 yards for 3% of their maximum health nullifying caster\'s mana, affects up to 10 targets, 3 seconds cooldown.$B$BShadow Armor (passive). Restores mana equal to a percentage of damage taken.$B$B','-1'),
+('70103','|cff0000ddArchmage|r$b|cffdd6600-=Warcraft III tribute=-|r$B$BSpell damage taken reduced by 35%, partially immune to control effects, cloth armor, deals spellsfire/spellfrost damage, no physical attack, spell power bonus: 100% intellect. Main attribute: Intellect.$B$BBlizzard. Your typical blizzard, just a little more powerful, 6 seconds cooldown.$B$BSummon Water Elemental. Summons a water elemental to attack archmage\'s enemies for 1 min, 20 seconds cooldown.$B$BBrilliance Aura. Increases maximum mana by 10% and greatly increases mana regeneration of party and raid members within 40 yards.$B$BMass Teleport. NIY.','-1'),
+('70104','|cff9900ccDreadlord|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"Incredibly powerful demon who wields power of darkness and mental domination\".$B$BHigh armor, high resistances, partially immune to control effects, damage taken speeds up spells recharge, plate armor, deals melee/spellshadow damage, bonus damage against incapacitated targets, spell power bonus: 200% strength. Main attribute: Strength.$B$BCarrion Swarm. Sends a horde of bats combined with chaotic magic to damage enemies in a very large frontal cone, cannot crit, 10 seconds cooldown.$B$BSleep. Puts the enemy target to sleep for 60 seconds and allows next physical attack on that target to bypass armor, direct damage caused will awaken the target, 6 seconds cooldown.$B$BVampiric Aura. Increases physical critical damage by 5% and heals party and raid members within 40 yards for a percentage (100% for Dreadlord and 25% for everyone else) of damage done by melee physical attacks and Carrion Swarm, no threat.$B$BSummon Infernal Servant. Calls an infernal down from the sky dealing damage and stunning enemy units, infernal is very resistant to magic and lasts 180 seconds, 180 seconds cooldown.','-1'),
+('70105','|cff0000ddSpell Breaker|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An elven warrior trained to disrupt and contort magical energies\".$B$BSpell damage taken reduced by 75%, partially immune to control effects, armor penalty -30%, mail/plate armor, deals melee/arcane damage, spell power bonus: 200% strength. Main attribute: Strength.$B$BSteal Magic (Spellsteal). Steals a benefical spell from an enemy and applies it to a nearby ally or removes a negative spell from an ally and applies it to a nearby enemy, affects magic and curse effects, 3 seconds cooldown.$B$BFeedback (passive). Successful melee attacks burn target\'s mana equal to damage caused (increased by spellpower) dealing arcane damage. If target is drained, Spell Breaker\'s melee attacks will do triple damage with increased critical strike chance','-1'),
+('70106','|cff9900ccDark Ranger|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"A former ranger of Quel\'thalas forcibly raised from the dead\".$B$BSpell damage taken reduced by 35%, undead, partially immune to control effects, leather/cloth armor, deals physical/spellshadow damage, stick to shadows and generates no threat, spell power bonus: 50% intellect. Main attribute: Agility.$B$BSilence. Silences an enemy and up to 4 nearby targets for 8 seconds, 15 seconds cooldown.$B$BBlack Arrow. Fires a cursed arrow dealing 150% weapon damage and additional spellshadow damage over time. If affected target dies from Dark Ranger\'s damage, Dark Minion will spawn from the corpse (maximum 5 Minions, 80 seconds duration, only works on humanoids, beasts and dragonkin). Deals five times more damage if target is under 20% health.$B$BDrain Life. Drains health from an enemy every second for 5 seconds, healing Dark Ranger for 200% of the drained amount.','-1');
+-- 70107 - 70200 reserved for custom class descriptions
+
+-- OUTFITS --
+-- Npc Dress mod by Rochet2
+CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+    `entry` INT(10) UNSIGNED NOT NULL,
+    `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+    `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+    `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    PRIMARY KEY  (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+-- End Npc Dress mod
+
+replace into `creature_template_outfits` (`entry`, `race`, `gender`, `skin`, `face`, `hair`, `haircolor`, `facialhair`, `head`, `shoulders`, `body`, `chest`, `waist`, `legs`, `feet`, `wrists`, `hands`, `back`, `tabard`)
+values
+('70551','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'), -- Blademaster
+('70552','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'); -- Mirror Image (Blademaster)
+
+-- Customize section
+
+SET @CLASS_WARRIOR          = 1;
+SET @CLASS_PALADIN          = 2;
+SET @CLASS_HUNTER           = 3;
+SET @CLASS_ROGUE            = 4;
+SET @CLASS_PRIEST           = 5;
+SET @CLASS_DK               = 6;
+SET @CLASS_SHAMAN           = 7;
+SET @CLASS_MAGE             = 8;
+SET @CLASS_WARLOCK          = 9;
+SET @CLASS_DRUID            = 11;
+SET @CLASS_BM               = 12;
+SET @CLASS_SPHYNX           = 13;
+SET @CLASS_ARCHMAGE         = 14;
+SET @CLASS_DREADLORD        = 15;
+SET @CLASS_SPELLBREAKER     = 16;
+SET @CLASS_DARK_RANGER      = 17;
+
+-- Add flags_extra
+
+SET @EX_NO_PARRY_HASTEN     = 8; -- 0x00000008 - CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN
+SET @EX_NO_BLOCK            = 16; -- 0x00000010 - CREATURE_FLAG_EXTRA_NO_BLOCK
+SET @EX_NO_CRUSH            = 32; -- 0x00000020 - CREATURE_FLAG_EXTRA_NO_CRUSH
+SET @EX_NO_XP               = 64; -- 0x00000040 - CREATURE_FLAG_EXTRA_NO_XP_AT_KILL
+SET @EX_DIMINISH            = 1048576; -- 0x00100000 - CREATURE_FLAG_EXTRA_ALL_DIMINISH
+SET @EX_NPCBOT              = 67108864; -- 0x04000000 - CREATURE_FLAG_EXTRA_NPCBOT - custom flag
+SET @EX_NPCBOT_PET          = 134217728; -- 0x08000000 - CREATURE_FLAG_EXTRA_NPCBOT_PET - custom flag
+SET @FLAGS_EX               = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT;
+SET @FLAGS_EXN              = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT | @EX_NO_PARRY_HASTEN;
+SET @FLAGS_EX_PET           = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT_PET;
+SET @FLAGS_EX_PET_BLOCK     = @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT_PET;
+
+-- Add unit_flags
+-- SET @U_PVP_ATTACKABLE       = 8; -- 0x00000008 - UNIT_FLAG_PVP_ATTACKABLE
+SET @FLAGS_U                = 0;
+SET @FLAGS_U_PET            = 0;
+
+-- Add unit_flags2
+SET @U2_MIRROR_IMAGE        = 16; -- 0x00000010 - UNIT_FLAG2_MIRROR_IMAGE - 22.06.19
+SET @U2_INSTANT_APPEAR_MODEL= 32; -- 0x00000020 - UNIT_FLAG2_INSTANTLY_APPEAR_MODEL - 29.05.19
+SET @U2_ENEMY_INTERRACT     = 16384; -- 0x00004000 - UNIT_FLAG2_ALLOW_ENEMY_INTERACT
+-- SET @U2_DISABLE_TURN        = 32768; -- 0x00008000 - UNIT_FLAG2_DISABLE_TURN
+SET @FLAGS_U2               = @U2_MIRROR_IMAGE | @U2_INSTANT_APPEAR_MODEL | @U2_ENEMY_INTERRACT;
+SET @FLAGS_U2_NM            = @U2_INSTANT_APPEAR_MODEL | @U2_ENEMY_INTERRACT;
+SET @FLAGS_U2_PET           = 0;
+
+-- Add type_flags
+SET @CT_CAN_ASSIST          = 4096; -- 0x00001000 - CREATURE_TYPE_FLAG_CAN_ASSIST - 26.10.19
+SET @FLAGS_CT               = @CT_CAN_ASSIST;
+
+-- general
+UPDATE `creature_template` SET type_flags:=`type_flags`|@FLAGS_CT WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3300, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DK);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2200, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DRUID);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2800, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_HUNTER);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3800, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_MAGE);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2300, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_PALADIN);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3600, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_PRIEST);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=1600, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_ROGUE);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2600, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SHAMAN);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3500, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_WARLOCK);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3400, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_WARRIOR);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, BaseAttackTime:=1940, RangeAttackTime:=1940, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EXN,unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_BM);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, BaseAttackTime:=1350, RangeAttackTime:=1350, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1,scale:=0.7,HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SPHYNX);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, BaseAttackTime:=1420, RangeAttackTime:=1420, dynamicflags:=0, speed_walk:=1.1, speed_run:=2.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_ARCHMAGE);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, BaseAttackTime:=2600, RangeAttackTime:=2600, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1,scale:=1.2,HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DREADLORD);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, BaseAttackTime:=1900, RangeAttackTime:=1900, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1,scale:=1.1,HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SPELLBREAKER);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=82, maxlevel:=82, BaseAttackTime:=2000, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DARK_RANGER);
+
+-- pets
+SET @PET_START              = 70501;
+SET @PET_END                = 70550;
+SET @PET_WATER_ELEMENTAL    = 70556;
+SET @PET_INFERNAL           = 70562;
+SET @PET_DARK_MINION        = 70573;
+SET @PET_DARK_MINION_ELITE  = 70574;
+
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=1.0, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry` BETWEEN @PET_START and @PET_END;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=1.3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_WATER_ELEMENTAL;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=1.5, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_INFERNAL;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=0.8, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET_BLOCK, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_DARK_MINION;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=0.9, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET_BLOCK, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_DARK_MINION_ELITE;
diff --git a/sql/Bots/4_world_generate_bot_equips.sql b/sql/Bots/4_world_generate_bot_equips.sql
new file mode 100644
index 0000000..9503ab6
--- /dev/null
+++ b/sql/Bots/4_world_generate_bot_equips.sql
@@ -0,0 +1,159 @@
+/*!50003 DROP PROCEDURE IF EXISTS `sp__generate_npcbot_equips`*/;
+
+DELIMITER ;;
+
+/*!50003 CREATE*/
+/*!50003 PROCEDURE `sp__generate_npcbot_equips`()
+BEGIN
+
+DECLARE CLASS_WARRIOR INT DEFAULT 1;
+DECLARE CLASS_PALADIN INT DEFAULT 2;
+DECLARE CLASS_HUNTER INT DEFAULT 3;
+DECLARE CLASS_ROGUE INT DEFAULT 4;
+DECLARE CLASS_PRIEST INT DEFAULT 5;
+DECLARE CLASS_DEATH_KNIGHT INT DEFAULT 6;
+DECLARE CLASS_SHAMAN INT DEFAULT 7;
+DECLARE CLASS_MAGE INT DEFAULT 8;
+DECLARE CLASS_WARLOCK INT DEFAULT 9;
+DECLARE CLASS_DRUID INT DEFAULT 11;
+DECLARE CLASS_BLADEMASTER INT DEFAULT 12;
+DECLARE CLASS_SPHYNX INT DEFAULT 13;
+DECLARE CLASS_ARCHMAGE INT DEFAULT 14;
+DECLARE CLASS_DREADLORD INT DEFAULT 15;
+DECLARE CLASS_SPELL_BREAKER INT DEFAULT 16;
+DECLARE CLASS_DARK_RANGER INT DEFAULT 17;
+
+DECLARE RACE_HUMAN INT DEFAULT 1;
+DECLARE RACE_ORC INT DEFAULT 2;
+DECLARE RACE_DWARF INT DEFAULT 3;
+DECLARE RACE_NELF INT DEFAULT 4;
+DECLARE RACE_UNDEAD INT DEFAULT 5;
+DECLARE RACE_TAUREN INT DEFAULT 6;
+DECLARE RACE_GNOME INT DEFAULT 7;
+DECLARE RACE_TROLL INT DEFAULT 8;
+DECLARE RACE_BELF INT DEFAULT 10;
+DECLARE RACE_DRAENEI INT DEFAULT 11;
+
+DECLARE NPCBOT_ENTRY_BEGIN INT DEFAULT 70001;
+DECLARE NPCBOT_ENTRY_END INT DEFAULT 71000;
+
+DECLARE NPCBOT_ENTRY_PET_DARK_MINION INT DEFAULT 70573;
+DECLARE NPCBOT_ENTRY_PET_DARK_MINION_ELITE INT DEFAULT 70574;
+
+DECLARE cur_pos INT DEFAULT 0;
+DECLARE myclass INT;
+DECLARE myrace INT;
+DECLARE item1 INT DEFAULT 0;
+DECLARE item2 INT DEFAULT 0;
+DECLARE item3 INT DEFAULT 0;
+
+DELETE FROM `creature_equip_template` WHERE `CreatureID` BETWEEN NPCBOT_ENTRY_BEGIN AND NPCBOT_ENTRY_END;
+
+SET cur_pos = NPCBOT_ENTRY_BEGIN;
+WHILE cur_pos < NPCBOT_ENTRY_END DO
+    SET myclass = (SELECT `class` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+    SET myrace = (SELECT `race` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+
+    IF myclass != 0 AND myrace != 0 THEN
+
+        IF myclass = CLASS_WARRIOR THEN
+            IF myrace = RACE_TAUREN THEN
+                SET item1 = 2361; -- hammer
+            ELSEIF myrace IN(RACE_DWARF,RACE_ORC) THEN
+                SET item1 = 2483; -- axe
+            ELSEIF TRUE THEN
+                SET item1 = 2497; -- sword
+            END IF;
+        ELSEIF myclass = CLASS_PALADIN THEN
+            SET item1 = 2488; -- gladius
+            SET item3 = 0;
+            IF myrace = RACE_BELF THEN
+                SET item2 = 20841; -- sunstrider shield
+            ELSE
+                SET item2 = 7188;  -- stormwind guard shield
+            END IF;
+        ELSEIF myclass = CLASS_HUNTER THEN
+            SET item1 = 12282;
+            SET item2 = 0;
+            SET item3 = 2506;
+        ELSEIF myclass = CLASS_ROGUE THEN
+            SET item3 = 25873;
+            IF (cur_pos % 2) = 1 THEN
+                SET item1 = 2092;
+                SET item2 = 3296; -- daggers
+            ELSE
+                SET item1 = 2131;
+                SET item2 = 2484; -- swords
+            END IF;
+        ELSEIF myclass = CLASS_PRIEST THEN
+            SET item1 = 1388; -- short staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DEATH_KNIGHT THEN
+            SET item1 = 38633; -- dk axe
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_SHAMAN THEN
+            SET item1 = 15903; -- claw
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_MAGE THEN
+            SET item1 = 2132; -- staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_WARLOCK THEN
+            SET item1 = 3661; -- staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DRUID THEN
+            SET item1 = 3327; -- staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_BLADEMASTER THEN
+            SET item1 = 24044; -- blademaster polearm
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_SPHYNX THEN
+            SET item1 = 5208; -- smoldering wand
+            SET item2 = 5208;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_ARCHMAGE THEN
+            SET item1 = 25917; -- white staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DREADLORD THEN
+            SET item1 = 0;
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_SPELL_BREAKER THEN
+            SET item1 = 0;
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DARK_RANGER THEN
+            SET item1 = 20849; -- arcane forged shortsword (1.7 dps)
+            SET item2 = 0;
+            SET item3 = 34529; -- vengeful gladiator's longbow
+        END IF;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    ELSEIF cur_pos = NPCBOT_ENTRY_PET_DARK_MINION OR cur_pos = NPCBOT_ENTRY_PET_DARK_MINION_ELITE THEN
+        SET item1 = 3935;
+        SET item2 = 15648;
+        SET item3 = 0;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    END IF;
+
+    SET cur_pos = cur_pos + 1;
+
+END WHILE;
+
+END */;;
+
+DELIMITER ;
+
+CALL `sp__generate_npcbot_equips`();
+
+DROP PROCEDURE IF EXISTS `trinity`.`sp__generate_npcbot_equips`;
diff --git a/sql/Bots/5_world_botgiver.sql b/sql/Bots/5_world_botgiver.sql
new file mode 100644
index 0000000..71bf344
--- /dev/null
+++ b/sql/Bots/5_world_botgiver.sql
@@ -0,0 +1,18 @@
+DELETE FROM `creature_template` WHERE `entry` = 70000;
+INSERT INTO `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,
+`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,
+`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`type`,`type_flags`,`lootid`,
+`pickpocketloot`,`skinloot`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,
+`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,
+`mechanic_immune_mask`,`spell_school_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`)
+VALUES
+('70000','0','0','0','0','0','27541','0','0','0','Lagretta','Bots for hire','','0','83','83','2','35','1','1.4','1.14286','0.7','4','0','0','0','1','1','1','33088','2048','0','0','0','0','0','0','0','0','0','0','0','','0','1','4.8','1','1','1','1','0','0','1','0','0','0','script_bot_giver','-1');
+
+DELETE FROM `npc_text` WHERE `ID` BETWEEN 70201 AND 70204;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70201','There are always dudes ready to kill for money.','-1'),
+('70202','Mercenaries are always in demand. Here is what available right now.','-1'),
+('70203','Mercenaries are always in demand. Here is what available right now.','-1'),
+('70204','Seems like there is nobody available right now, check again later.','-1');
diff --git a/sql/Bots/characters_bots.sql b/sql/Bots/characters_bots.sql
new file mode 100644
index 0000000..f590d45
--- /dev/null
+++ b/sql/Bots/characters_bots.sql
@@ -0,0 +1,26 @@
+DROP TABLE IF EXISTS `characters_npcbot`;
+CREATE TABLE `characters_npcbot` (
+  `entry` int(10) unsigned NOT NULL COMMENT 'creature_template.entry',
+  `owner` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'characters.guid (lowguid)',
+  `roles` smallint(5) unsigned NOT NULL COMMENT 'bitmask: tank(1),dps(2),heal(4),ranged(8)',
+  `faction` int(10) unsigned NOT NULL DEFAULT '35',
+  `equipMhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipOhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipRhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHead` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipShoulders` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipChest` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWaist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipLegs` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFeet` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWrist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHands` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBack` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBody` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipNeck` int(10) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/updates/characters/characters_npcbot_2020_05_15_NPCBots_4.7.8a-4.7.27a.sql b/sql/Bots/updates/characters/characters_npcbot_2020_05_15_NPCBots_4.7.8a-4.7.27a.sql
new file mode 100644
index 0000000..ab44f65
--- /dev/null
+++ b/sql/Bots/updates/characters/characters_npcbot_2020_05_15_NPCBots_4.7.8a-4.7.27a.sql
@@ -0,0 +1 @@
+ALTER TABLE `characters_npcbot` ADD `spec` tinyint(3) unsigned NOT NULL DEFAULT '1' AFTER `roles`;
diff --git a/sql/Bots/updates/characters/characters_npcbot_2020_06_21_43fceb98.sql b/sql/Bots/updates/characters/characters_npcbot_2020_06_21_43fceb98.sql
new file mode 100644
index 0000000..368e5a9
--- /dev/null
+++ b/sql/Bots/updates/characters/characters_npcbot_2020_06_21_43fceb98.sql
@@ -0,0 +1,172 @@
+DROP TEMPORARY TABLE IF EXISTS `npcbot_extras_temp`;
+
+CREATE TEMPORARY TABLE `npcbot_extras_temp` (
+  `entry` MEDIUMINT(8) UNSIGNED NOT NULL,
+  `class` TINYINT(3) UNSIGNED NOT NULL DEFAULT '1',
+  PRIMARY KEY (`entry`)
+) ENGINE=INNODB DEFAULT CHARSET=utf8;
+
+INSERT INTO `npcbot_extras_temp` (`entry`,`class`) VALUES
+('70001','1'),('70002','1'),('70003','1'),('70004','1'),('70005','1'),
+('70006','1'),('70007','1'),('70008','1'),('70009','1'),('70010','1'),
+('70011','1'),('70012','1'),('70013','1'),('70014','1'),('70015','1'),
+('70016','1'),('70017','1'),('70018','1'),('70019','1'),('70020','1'),
+('70021','1'),('70022','1'),('70023','1'),('70024','1'),('70025','1'),
+('70026','1'),('70027','1'),('70028','1'),('70029','1'),('70030','1'),
+('70031','1'),('70032','1'),('70033','1'),('70034','1'),('70035','1'),
+('70036','1'),('70037','1'),('70038','1'),('70051','2'),('70052','2'),
+('70053','2'),('70054','2'),('70055','2'),('70056','2'),('70057','2'),
+('70058','2'),('70059','2'),('70060','2'),('70061','2'),('70062','2'),
+('70063','2'),('70064','2'),('70065','2'),('70066','2'),('70067','2'),
+('70068','2'),('70069','2'),('70070','2'),('70071','2'),('70072','2'),
+('70073','2'),('70074','2'),('70101','3'),('70102','3'),('70103','3'),
+('70104','3'),('70105','3'),('70106','3'),('70107','3'),('70108','3'),
+('70109','3'),('70110','3'),('70111','3'),('70112','3'),('70113','3'),
+('70114','3'),('70115','3'),('70116','3'),('70117','3'),('70118','3'),
+('70119','3'),('70120','3'),('70121','3'),('70122','3'),('70123','3'),
+('70124','3'),('70125','3'),('70126','3'),('70127','3'),('70128','3'),
+('70129','3'),('70130','3'),('70131','3'),('70132','3'),('70133','3'),
+('70134','3'),('70135','3'),('70136','3'),('70137','3'),('70138','3'),
+('70139','3'),('70151','4'),('70152','4'),('70153','4'),('70154','4'),
+('70155','4'),('70156','4'),('70157','4'),('70158','4'),('70159','4'),
+('70160','4'),('70161','4'),('70162','4'),('70163','4'),('70164','4'),
+('70165','4'),('70166','4'),('70167','4'),('70168','4'),('70169','4'),
+('70170','4'),('70171','4'),('70172','4'),('70173','4'),('70174','4'),
+('70175','4'),('70176','4'),('70177','4'),('70178','4'),('70179','4'),
+('70180','4'),('70181','4'),('70201','5'),('70202','5'),('70203','5'),
+('70204','5'),('70205','5'),('70206','5'),('70207','5'),('70208','5'),
+('70209','5'),('70210','5'),('70211','5'),('70212','5'),('70213','5'),
+('70214','5'),('70215','5'),('70216','5'),('70217','5'),('70218','5'),
+('70219','5'),('70220','5'),('70221','5'),('70222','5'),('70223','5'),
+('70224','5'),('70225','5'),('70226','5'),('70227','5'),('70228','5'),
+('70229','5'),('70230','5'),('70231','5'),('70232','5'),('70233','5'),
+('70234','5'),('70235','5'),('70236','5'),('70237','5'),('70238','5'),
+('70239','5'),('70240','5'),('70251','7'),('70252','7'),('70253','7'),
+('70254','7'),('70255','7'),('70256','7'),('70257','7'),('70258','7'),
+('70259','7'),('70260','7'),('70261','7'),('70265','7'),('70267','7'),
+('70268','7'),('70301','8'),('70302','8'),('70303','8'),('70304','8'),
+('70305','8'),('70306','8'),('70307','8'),('70308','8'),('70309','8'),
+('70310','8'),('70311','8'),('70312','8'),('70313','8'),('70314','8'),
+('70315','8'),('70316','8'),('70317','8'),('70318','8'),('70319','8'),
+('70320','8'),('70321','8'),('70322','8'),('70323','8'),('70324','8'),
+('70325','8'),('70326','8'),('70327','8'),('70328','8'),('70329','8'),
+('70330','8'),('70331','8'),('70332','8'),('70333','8'),('70334','8'),
+('70335','8'),('70336','8'),('70351','9'),('70352','9'),('70353','9'),
+('70354','9'),('70355','9'),('70356','9'),('70357','9'),('70358','9'),
+('70359','9'),('70360','9'),('70361','9'),('70362','9'),('70363','9'),
+('70364','9'),('70365','9'),('70366','9'),('70367','9'),('70368','9'),
+('70369','9'),('70370','9'),('70371','9'),('70372','9'),('70373','9'),
+('70374','9'),('70375','9'),('70376','9'),('70377','9'),('70401','11'),
+('70402','11'),('70403','11'),('70404','11'),('70405','11'),('70406','11'),
+('70407','11'),('70408','11'),('70409','11'),('70410','11'),('70411','11'),
+('70412','11'),('70413','11'),('70414','11'),('70415','11'),('70416','11'),
+('70417','11'),('70418','11'),('70451','6'),('70452','6'),('70453','6'),
+('70454','6'),('70455','6'),('70456','6'),('70457','6'),('70458','6'),
+('70459','6'),('70460','6'),('70461','6'),('70462','6'),('70463','6'),
+('70464','6'),('70465','6'),('70501','0'),('70502','0'),('70503','0'),
+('70504','0'),('70505','0'),('70506','0'),('70507','0'),('70508','0'),
+('70509','0'),('70510','0'),('70511','0'),('70512','0'),('70513','0'),
+('70514','0'),('70515','0'),('70516','0'),('70517','0'),('70518','0'),
+('70519','0'),('70520','0'),('70521','0'),('70522','0'),('70523','0'),
+('70524','0'),('70525','0'),('70526','0'),('70527','0'),('70528','0'),
+('70529','0'),('70530','0'),('70531','0'),('70532','0'),('70533','0'),
+('70534','0'),('70535','0'),('70536','0'),('70537','0'),('70538','0'),
+('70542','0'),('70543','0'),('70544','0'),('70545','0'),('70551','12'),
+('70552','12'),('70553','13'),('70554','13'),('70555','14'),('70556','0'),
+('70557','15'),('70558','15'),('70559','15'),('70560','15'),('70561','15'),
+('70562','0'),('70563','16'),('70564','16'),('70565','16'),('70566','16'),
+('70567','16'),('70568','17'),('70569','17'),('70570','17'),('70571','17'),
+('70572','17'),('70573','0'),('70574','0');
+
+/*!50003 DROP PROCEDURE IF EXISTS `sp__update_specs_2020_06_21`*/;
+
+DELIMITER ;;
+
+/*!50003 CREATE*/
+/*!50003 PROCEDURE `sp__update_specs_2020_06_21`()
+BEGIN
+
+DECLARE CLASS_WARRIOR INT DEFAULT 1;
+DECLARE CLASS_PALADIN INT DEFAULT 2;
+DECLARE CLASS_HUNTER INT DEFAULT 3;
+DECLARE CLASS_ROGUE INT DEFAULT 4;
+DECLARE CLASS_PRIEST INT DEFAULT 5;
+DECLARE CLASS_DEATH_KNIGHT INT DEFAULT 6;
+DECLARE CLASS_SHAMAN INT DEFAULT 7;
+DECLARE CLASS_MAGE INT DEFAULT 8;
+DECLARE CLASS_WARLOCK INT DEFAULT 9;
+DECLARE CLASS_DRUID INT DEFAULT 11;
+DECLARE CLASS_BLADEMASTER INT DEFAULT 12;
+DECLARE CLASS_SPHYNX INT DEFAULT 13;
+DECLARE CLASS_ARCHMAGE INT DEFAULT 14;
+DECLARE CLASS_DREADLORD INT DEFAULT 15;
+DECLARE CLASS_SPELL_BREAKER INT DEFAULT 16;
+DECLARE CLASS_DARK_RANGER INT DEFAULT 17;
+
+DECLARE SPEC_START_WARRIOR INT DEFAULT 1;
+DECLARE SPEC_START_PALADIN INT DEFAULT 4;
+DECLARE SPEC_START_HUNTER INT DEFAULT 7;
+DECLARE SPEC_START_ROGUE INT DEFAULT 10;
+DECLARE SPEC_START_PRIEST INT DEFAULT 13;
+DECLARE SPEC_START_DEATH_KNIGHT INT DEFAULT 16;
+DECLARE SPEC_START_SHAMAN INT DEFAULT 19;
+DECLARE SPEC_START_MAGE INT DEFAULT 22;
+DECLARE SPEC_START_WARLOCK INT DEFAULT 25;
+DECLARE SPEC_START_DRUID INT DEFAULT 28;
+DECLARE SPEC_DEFAULT INT DEFAULT 31;
+
+DECLARE NPCBOT_ENTRY_BEGIN INT DEFAULT 70001;
+DECLARE NPCBOT_ENTRY_END INT DEFAULT 71000;
+
+DECLARE cur_pos INT;
+DECLARE myclass INT;
+DECLARE myspec INT;
+
+SET cur_pos = NPCBOT_ENTRY_BEGIN;
+WHILE cur_pos < NPCBOT_ENTRY_END DO
+    SET myclass = (SELECT `class` FROM `npcbot_extras_temp` WHERE `entry` = cur_pos);
+    SET myspec = (SELECT `spec` FROM `characters_npcbot` WHERE `entry` = cur_pos);
+
+    IF myclass != 0 AND myspec != 0 AND myspec < 4 THEN
+
+        IF myclass = CLASS_WARRIOR THEN
+            SET myspec = myspec + SPEC_START_WARRIOR - 1;
+        ELSEIF myclass = CLASS_PALADIN THEN
+            SET myspec = myspec + SPEC_START_PALADIN - 1;
+        ELSEIF myclass = CLASS_HUNTER THEN
+            SET myspec = myspec + SPEC_START_HUNTER - 1;
+        ELSEIF myclass = CLASS_ROGUE THEN
+            SET myspec = myspec + SPEC_START_ROGUE - 1;
+        ELSEIF myclass = CLASS_PRIEST THEN
+            SET myspec = myspec + SPEC_START_PRIEST - 1;
+        ELSEIF myclass = CLASS_DEATH_KNIGHT THEN
+            SET myspec = myspec + SPEC_START_DEATH_KNIGHT - 1;
+        ELSEIF myclass = CLASS_SHAMAN THEN
+            SET myspec = myspec + SPEC_START_SHAMAN - 1;
+        ELSEIF myclass = CLASS_MAGE THEN
+            SET myspec = myspec + SPEC_START_MAGE - 1;
+        ELSEIF myclass = CLASS_WARLOCK THEN
+            SET myspec = myspec + SPEC_START_WARLOCK - 1;
+        ELSEIF myclass = CLASS_DRUID THEN
+            SET myspec = myspec + SPEC_START_DRUID - 1;
+        ELSE
+            SET myspec = SPEC_DEFAULT;
+        END IF;
+
+        UPDATE `characters_npcbot` SET `spec` = myspec WHERE `entry` = cur_pos;
+
+    END IF;
+
+    SET cur_pos = cur_pos + 1;
+
+END WHILE;
+
+DROP TEMPORARY TABLE IF EXISTS `npcbot_extras_temp`;
+
+END*/;;
+
+DELIMITER ;
+
+CALL `sp__update_specs_2020_06_21`();
+
+DROP PROCEDURE IF EXISTS `sp__update_specs_2020_06_21`;
diff --git a/sql/Bots/updates/world/creature_template_npcbot_extras_2020_07_08.sql b/sql/Bots/updates/world/creature_template_npcbot_extras_2020_07_08.sql
new file mode 100644
index 0000000..2e67192
--- /dev/null
+++ b/sql/Bots/updates/world/creature_template_npcbot_extras_2020_07_08.sql
@@ -0,0 +1,2 @@
+-- Zandine race fix
+UPDATE `creature_template_npcbot_extras` SET `race`='10' WHERE (`entry`='70135');
diff --git a/src/common/Utilities/EventProcessor.h b/src/common/Utilities/EventProcessor.h
index 2bf6821..0b8261e 100644
--- a/src/common/Utilities/EventProcessor.h
+++ b/src/common/Utilities/EventProcessor.h
@@ -57,6 +57,7 @@ class TC_COMMON_API BasicEvent
 
         // Aborts the event at the next update tick
         void ScheduleAbort();
+        bool IsActive() const { return m_abortState == AbortState::STATE_RUNNING; }
 
     private:
         void SetAborted();
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.cpp b/src/server/database/Database/Implementation/CharacterDatabase.cpp
index 78643ee..6145a01 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/database/Database/Implementation/CharacterDatabase.cpp
@@ -594,6 +594,22 @@ void CharacterDatabaseConnection::DoPrepareStatements()
 
     // DeserterTracker
     PrepareStatement(CHAR_INS_DESERTER_TRACK, "INSERT INTO battleground_deserters (guid, type, datetime) VALUES (?, ?, NOW())", CONNECTION_ASYNC);
+
+    // NPCBots
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER, "UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER_ALL, "UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE characters_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE, "SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+        "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+        "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+        "WHERE cn.entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE characters_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO characters_npcbot (entry, roles, spec, faction) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_FACTION, "UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_SPEC, "UPDATE characters_npcbot SET spec = ? WHERE entry = ?", CONNECTION_ASYNC);
+    // End NPCBots
 }
 
 CharacterDatabaseConnection::CharacterDatabaseConnection(MySQLConnectionInfo& connInfo) : MySQLConnection(connInfo)
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.h b/src/server/database/Database/Implementation/CharacterDatabase.h
index 7404a61..e0eafba 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.h
+++ b/src/server/database/Database/Implementation/CharacterDatabase.h
@@ -510,6 +510,18 @@ enum CharacterDatabaseStatements : uint32
 
     CHAR_INS_DESERTER_TRACK,
 
+    // NPCBot
+    CHAR_UPD_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER_ALL,
+    CHAR_UPD_NPCBOT_ROLES,
+    CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_DEL_NPCBOT,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_FACTION,
+    CHAR_UPD_NPCBOT_SPEC,
+    // End NPCBot
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/game/AI/NpcBots/bot_Events.h b/src/server/game/AI/NpcBots/bot_Events.h
new file mode 100644
index 0000000..35a9695
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_Events.h
@@ -0,0 +1,53 @@
+#ifndef _BOT_EVENTS_H
+#define _BOT_EVENTS_H
+
+#include "EventProcessor.h"
+
+/*
+Name: bot_Events
+%Complete: ???
+Comment: Custom event types for NPCBot system by Trickerer (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/events
+
+Notes:
+All events must be executed through botAI
+*/
+
+//Teleport home: near or far, only used for free bots
+class TeleportHomeEvent : public BasicEvent
+{
+    friend class bot_ai;
+    protected:
+        TeleportHomeEvent(bot_ai* ai) : _ai(ai) {}
+        ~TeleportHomeEvent() {}
+
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->TeleportHome();
+            return true;
+        }
+
+    private:
+        bot_ai* _ai;
+};
+//Delayed teleport finish: adds bot back to world on new location
+class TeleportFinishEvent : public BasicEvent
+{
+    friend class bot_ai;
+    friend class BotMgr;
+    protected:
+        TeleportFinishEvent(bot_ai* ai) : _ai(ai) {}
+        ~TeleportFinishEvent() {}
+
+        //Execute is always called while creature is out of world so ai is never deleted
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->FinishTeleport();
+            return true;
+        }
+
+    private:
+        bot_ai* _ai;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..c3368f7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,1175 @@
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Corpse.h"
+#include "Group.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "SpellMgr.h"
+#include "bot_ai.h"
+/*
+Name: bot_GridNotifiers
+%Complete: 99+
+Comment: Custom grid notifiers for Bot system by Trickerer (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+extern bool _botPvP;
+
+class ImmunityShieldDispelTargetCheck
+{
+    public:
+        explicit ImmunityShieldDispelTargetCheck(Unit const* unit, float dist, bot_ai const* m_ai) :
+        me(unit), range(dist), ai(m_ai) { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (!_botPvP && !free && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, range))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (!u->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+                return false;
+
+            if (!u->IsWithinLOSInMap(me))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float range;
+        bot_ai const* ai;
+        bool free;
+        ImmunityShieldDispelTargetCheck(ImmunityShieldDispelTargetCheck const&);
+};
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed)
+        { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (u == me)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer() && !u->IsInCombat())
+                    return false;
+            }
+            else
+            {
+                if (!u->IsWithinLOSInMap(me))
+                    return false;
+            }
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        bool free;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = nullptr) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->IsInCombat() &&
+                u->InSamePhase(me) &&
+                u->IsWithinDistInMap(me, m_range) &&
+                u->isTargetableForAttack() &&
+                //!ai->InDuel(u) &&
+                (ai->IsInBotParty(u->GetVictim()) || me->GetVictim() == u))
+            {
+                if (checksteal)
+                {
+                    if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449), me))
+                        return false; //immune to steal
+                }
+                else if (ai->GetBotClass() == BOT_CLASS_SHAMAN)
+                {
+                    if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(370), me))
+                        return false; //immune to purge
+                }
+                //else if (ai->GetBotClass() == BOT_CLASS_PRIEST)
+                //{
+                //    if (me->GetLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527), me))
+                //        return false; //immune to dispel magic
+                //}
+
+                Unit::AuraApplicationMap const &AurApps = u->GetAppliedAuras();
+                SpellInfo const* Info;
+                uint32 id;
+                for (Unit::AuraApplicationMap::const_iterator itr = AurApps.begin(); itr != AurApps.end(); ++itr)
+                {
+                    Info = itr->second->GetBase()->GetSpellInfo();
+                    if (itr->second->IsPositive() && Info->Dispel == DISPEL_MAGIC &&
+                        !(Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) &&
+                        !(checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)))
+                    {
+                        id = Info->Id;
+                        if (id != 20050 && id != 20052 && id != 20053 && //Vengeance
+                            id != 50447 && id != 50448 && id != 50449) //Bloody Vengeance
+                            return true;
+                    }
+                }
+
+                //Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                //SpellInfo const* Info;
+                //uint32 id;
+                //for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                //{
+                //    Aura* aura = itr->second;
+                //    Info = aura->GetSpellInfo();
+                //    if (Info->Dispel != DISPEL_MAGIC) continue;
+                //    id = Info->Id;
+                //    if (id == 20050 || id == 20052 || id == 20053 || //Vengeance
+                //        id == 50447 || id == 50448 || id == 50449) //Bloody Vengeance
+                //        continue;
+                //    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                //    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                //    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                //    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                //    if (aurApp && aurApp->IsPositive())
+                //        return true;
+                //}
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(ObjectGuid casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (!checker->IsWithinDistInMap(u, m_range))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            //else if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            //else if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            else if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+            else if (needhostile == 4 && !(u->GetTypeId() == TYPEID_PLAYER && u->IsFriendlyTo(checker))) return false;
+
+            //if (u->HasAura(spell, caster)
+            //    return true;
+
+            Unit::AuraApplicationMap const &Auras = u->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+            {
+                AuraApplication const* auraApp = itr->second;
+                if (itr->first == spell)
+                    if (caster == 0 || auraApp->GetBase()->GetCasterGUID() == caster)
+                        return true;
+            }
+            return false;
+        }
+    private:
+        ObjectGuid const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->GetVictim() || u == me->GetVictim())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || me->GetVictim()->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->IsFrozen() ||
+                u->IsRooted() ||
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE) ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118), me))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514), me))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->IsFeared())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER)
+                return false;
+            if (u->IsTotem())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            //Unit::GetDiminishing() should be const but it isn't
+            if (const_cast<Unit*>(u)->GetDiminishing(DIMINISHING_FEAR) > DIMINISHING_LEVEL_3)
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782), me))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513), me))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (me->ToCreature()->GetBotClass() != BOT_CLASS_DREADLORD && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER && me->GetTarget() == u->GetGUID())//auto shot
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_DRUID &&
+                !(u->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN && me->GetDistance(u) < 10)//prevent break due to AOE damage
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066), me))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210), me))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386), me))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991), me))//scatter shot
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(2094), me))//blind
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                u->GetCreatureType() == CREATURE_TYPE_HUMANOID &&
+                (u->GetVictim() || u->IsControlledByPlayer()) &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(6358), me))//seduction
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_DREADLORD &&
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(SPELL_SLEEP), me))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist, bot_ai const* ai, uint32 spell, bool unattacked) :
+        me(unit), m_range(dist), m_ai(ai), m_spellId(spell), _unattacked(unattacked) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (_unattacked && !u->getAttackers().empty())
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PRIEST &&
+                !(u->GetCreatureType() == CREATURE_TYPE_UNDEAD && !u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON &&
+                u->GetCreatureType() != CREATURE_TYPE_ELEMENTAL)
+                return false;
+            if (u->GetVictim() && !m_ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId), me))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bot_ai const* m_ai;
+        uint32 m_spellId;
+        bool _unattacked;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, float dist, bot_ai const* ai, uint32 spell = 0) :
+        me(unit), m_range(dist), m_ai(ai), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == me->GetVictim())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->IsFrozen() || u->IsRooted())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetVictim() && !m_ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE)/*hex*/ ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4)/*repentance*/ ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PRIEST, 0x40000000)/*shackle undead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId), me))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bot_ai const* m_ai;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, uint32 spell = 0, uint8 minHpPct = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_spell(spell), m_minHpPct(minHpPct) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->GetTarget() && !u->IsInCombat())
+                return false;
+            if (u->IsTotem())
+                return false;
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u->HealthBelowPct(m_minHpPct))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCast(false,false,true))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (u->GetReactionTo(me) >= REP_FRIENDLY)
+                return false;
+            if (m_spell)
+            {
+                if ((m_spell == 5782 || //fear (warlock)
+                    m_spell == 64044 || //fear (priest)
+                    m_spell == SPELL_SLEEP) &&
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                    return false;
+                if (m_spell == 10326 && //turn evil
+                    !(u->GetCreatureType() == CREATURE_TYPE_UNDEAD ||
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON))
+                    return false;
+                if (m_spell == 20066 && //repentance
+                    !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (m_spell == 2637 && //hibernate
+                    !(u->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN))
+                    return false;
+                if (m_spell == 9484 && //shackle undead (priest)
+                    u->GetCreatureType() != CREATURE_TYPE_UNDEAD)
+                    return false;
+
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(m_spell);
+                if (u->IsImmunedToSpell(spellInfo, me))
+                    return false;
+
+                if (!CastInterruptionCheck(u, spellInfo))
+                    return false;
+            }
+
+            return true;
+        }
+
+        static bool CastInterruptionCheck(Unit const* u, SpellInfo const* spellInfo)
+        {
+            if (spellInfo->HasEffect(SPELL_EFFECT_INTERRUPT_CAST) && spellInfo->GetFirstRankSpell()->Id != 853) //hammer of justice
+            {
+                if (u->GetTypeId() == TYPEID_UNIT &&
+                    (u->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << (MECHANIC_INTERRUPT - 1))))
+                    return false;
+
+                Spell* curSpell;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    curSpell = u->GetCurrentSpell(i);
+                    if (!curSpell)
+                        continue;
+
+                    //copied conditions from Spell::EffectInterruptCast
+                    if (!((curSpell->getState() == SPELL_STATE_CASTING ||
+                        (curSpell->getState() == SPELL_STATE_PREPARING && curSpell->GetCastTime() > 0.0f)) &&
+                        curSpell->GetSpellInfo()->PreventionType == SPELL_PREVENTION_TYPE_SILENCE &&
+                        ((i == CURRENT_GENERIC_SPELL && curSpell->GetSpellInfo()->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) ||
+                        (i == CURRENT_CHANNELED_SPELL && curSpell->GetSpellInfo()->ChannelInterruptFlags & CHANNEL_INTERRUPT_FLAG_INTERRUPT))))
+                        return false;
+                }
+            }
+            bool silenceSpell = false;
+            for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+            {
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOD_SILENCE)
+                {
+                    silenceSpell = true;
+                    break;
+                }
+            }
+            if (silenceSpell)
+            {
+                if (u->GetTypeId() == TYPEID_UNIT &&
+                    (u->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << (MECHANIC_SILENCE - 1))))
+                    return false;
+
+                Spell* curSpell;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    curSpell = u->GetCurrentSpell(i);
+                    if (curSpell && curSpell->GetSpellInfo()->PreventionType != SPELL_PREVENTION_TYPE_SILENCE)
+                        return false;
+                }
+            }
+
+            return true; //do not check players and non-interrupt non-silence spells
+        }
+
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        uint32 m_spell;
+        uint8 m_minHpPct;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                ai->IsInBotParty(u->GetVictim()) &&
+                u->GetReactionTo(me) <= REP_NEUTRAL)
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801), me)) return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai, uint8 CCoption, WorldObject const* source) :
+        me(unit), max_range(maxdist), ai(m_ai), m_CCoption(CCoption), _source(source)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me || u == _source)
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(_source))
+                return false;
+            if ((m_CCoption & 1) && u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if ((m_CCoption & 2) && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_CRITTER)
+                return false;
+            if (!_source->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        uint8 m_CCoption;
+        bool free;
+        WorldObject const* _source;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+class NearbyHostileUnitInConeCheck
+{
+    public:
+        explicit NearbyHostileUnitInConeCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) :
+        me(unit), max_range(maxdist), ai(m_ai), cone(M_PI/2)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+            //    return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!me->HasInArc(cone, u))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        float cone;
+        bool free;
+        NearbyHostileUnitInConeCheck(NearbyHostileUnitInConeCheck const&);
+};
+
+class NearbyFriendlyUnitCheck
+{
+    public:
+        explicit NearbyFriendlyUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (!u->IsInCombat())
+            //    return false;
+            if (!u->IsAlive())
+                return false;
+            if (u->HasUnitState(UNIT_STATE_ISOLATED))
+                return false;
+            //if (u->IsTotem() || u->IsSummon())
+            //    return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!ai->IsInBotParty(u))
+                return false;
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (!me->IsValidAssistTarget(u))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyFriendlyUnitCheck(NearbyFriendlyUnitCheck const&);
+};
+
+class FarTauntUnitCheck
+{
+    public:
+        explicit FarTauntUnitCheck(Unit const* unit, float maxdist, bool ally, bot_ai const* m_ai) :
+        me(unit), max_range(maxdist), targetAlly(ally), ai(m_ai)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (!u->GetVictim() || u->GetVictim() == me)
+                return false;
+            if (!u->CanHaveThreatList())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_MOD_TAUNT))
+                return false;
+            if (ai->IsTank(u->GetVictim()))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARRIOR && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(355), me))
+                return false; //taunt
+            else if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(62124), me))
+                return false; //HoR
+            else if (me->ToCreature()->GetBotClass() == BOT_CLASS_DRUID && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(6795), me))
+                return false; //Growl
+
+            if (free && (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack()))
+                return false;
+
+            if (me->GetDistance(targetAlly ? u->GetVictim() : u) > max_range)
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bool targetAlly;
+        bot_ai const* ai;
+        bool free;
+        FarTauntUnitCheck(FarTauntUnitCheck const&);
+};
+
+class ManaDrainUnitCheck
+{
+    public:
+        explicit ManaDrainUnitCheck(Unit const* unit, float maxdist) : me(unit), max_range(maxdist)
+        { maxPool = me->GetMaxPower(POWER_MANA) * 3 / 2; }
+        bool operator()(Unit const* u)
+        {
+            if (u == me)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetTypeId() == TYPEID_PLAYER && !u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            //if (u->IsControlledByPlayer())
+            //    return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (u->GetPowerType() != POWER_MANA)
+                return false;
+            if (u->GetMaxPower(POWER_MANA) < maxPool)
+                return false;
+            if (u->GetPower(POWER_MANA)*10/(u->GetMaxPower(POWER_MANA)/10) < 15)
+                return false;
+            if (!me->HasInArc(M_PI*0.5f, u))
+                return false;
+            if (me->GetDistance(u) > max_range)
+                return false;
+
+            maxPool = u->GetMaxPower(POWER_MANA);
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        uint32 maxPool;
+        ManaDrainUnitCheck(ManaDrainUnitCheck const&);
+};
+
+class NearbyRezTargetCheck
+{
+    public:
+        explicit NearbyRezTargetCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(WorldObject const* u) const
+        {
+            if (u == me)
+                return false;
+            if (u->GetTypeId() != TYPEID_PLAYER && u->GetTypeId() != TYPEID_CORPSE)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (Player const* p = u->ToPlayer())
+            {
+                if (p->IsAlive())
+                    return false;
+                if (p->IsResurrectRequested())
+                    return false;
+                if (!ai->IsInBotParty(p))
+                    return false;
+            }
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (urand(0,100) > 20)
+                return false;
+            if (u->GetTypeId() == TYPEID_CORPSE && !ObjectAccessor::FindPlayer(u->ToCorpse()->GetOwnerGUID()))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyRezTargetCheck(NearbyRezTargetCheck const&);
+};
+
+class NearestLockedGameObjectInRangeCheck
+{
+public:
+    NearestLockedGameObjectInRangeCheck(WorldObject const* unit, float range) : _unit(unit), _range(range) { }
+    bool operator()(GameObject* go)
+    {
+        if (go->GetGOInfo()->GetLockId() &&
+            !go->HasFlag(GAMEOBJECT_FLAGS, GO_FLAG_IN_USE) &&
+            //go->getLootState() == GO_READY &&
+            _unit->IsWithinDistInMap(go, _range))
+        {
+            _range = _unit->GetExactDist(go);
+            return true;
+        }
+        return false;
+    }
+private:
+    WorldObject const* _unit;
+    float _range;
+
+    NearestLockedGameObjectInRangeCheck(NearestLockedGameObjectInRangeCheck const&);
+};
+
+//Professions
+class NearbyObjectBySkillCheck
+{
+public:
+    NearbyObjectBySkillCheck(WorldObject const* checker, float const range, uint16 skillMask) :
+      _checker(checker), _range(range), _skillMask(skillMask) { ASSERT(_checker->GetTypeId() == TYPEID_PLAYER); }
+
+    bool operator()(WorldObject const* ob)
+    {
+        if (!_checker->IsWithinDistInMap(ob, _range))
+            return false;
+
+        if (GameObject const* go = ob->ToGameObject())
+        {
+            if (/*go->getLootState() == GO_READY && */go->isSpawned() && go->GetGOInfo()->GetLockId() &&
+                go->IsLootAllowedFor(_checker->ToPlayer()) && _checker->CanSeeOrDetect(go) && _checker->ToPlayer()->HaveAtClient(ob))
+            {
+                if (LockEntry const* lockInfo = sLockStore.LookupEntry(go->GetGOInfo()->GetLockId()))
+                {
+                    for (uint8 i = 0; i != MAX_LOCK_CASE; ++i)
+                    {
+                        if (lockInfo->Type[i] == LOCK_KEY_SKILL &&
+                            CheckSkill(SkillByLockType(LockType(lockInfo->Index[i]))) &&
+                            lockInfo->Skill[i] <= MaxSkillForLevel(_checker->ToUnit()->GetLevel()))
+                            return true;
+                    }
+                }
+            }
+        }
+        else if (Creature const* cre = ob->ToCreature())
+        {
+            if (cre->IsVisible() && cre->getDeathState() == CORPSE && cre->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && cre->loot.isLooted() &&
+                CheckSkill(cre->GetCreatureTemplate()->GetRequiredLootSkill()))
+            {
+                if (int32(cre->GetLevel() < 20 ? (cre->GetLevel() - 10) * 10 : cre->GetLevel() * 5) <= int32(MaxSkillForLevel(_checker->ToUnit()->GetLevel())))
+                    return true;
+            }
+        }
+        return false;
+    }
+private:
+    WorldObject const* _checker;
+    float const _range;
+    uint16 const _skillMask;
+
+    inline bool CheckSkill(SkillType const skill) const
+    {
+        switch (skill)
+        {
+            case SKILL_MINING:
+                return (_skillMask & BOT_ROLE_GATHERING_MINING);
+            case SKILL_HERBALISM:
+                return (_skillMask & BOT_ROLE_GATHERING_HERBALISM);
+            case SKILL_SKINNING:
+                return (_skillMask & BOT_ROLE_GATHERING_SKINNING);
+            case SKILL_ENGINEERING:
+                return (_skillMask & BOT_ROLE_GATHERING_ENGINEERING);
+            default:
+                return false;
+        }
+    }
+
+    inline uint32 MaxSkillForLevel(uint8 const level) const
+    {
+        return
+            level <= 20 ? 150 :
+            level <= 40 ? 225 :
+            level <= 60 ? 300 :
+            level <= 70 ? 375 : 450;
+
+        //return level <= 60 ? level * 5 : 300 + (((level - 60) * 15) / 2);
+    }
+
+    NearbyObjectBySkillCheck(NearbyObjectBySkillCheck const&);
+};
+
+namespace BOTAI_PRED
+{
+    class HealTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->IsSummon() || target->IsTotem() || (target->GetHealthPct() > 90 && target->GetMaxHealth() - target->GetHealth() < 500);
+            }
+    };
+    class BuffTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->IsSummon() || target->IsTotem();
+            }
+    };
+    class DrainTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->IsTotem() || target->GetPowerType() != POWER_MANA || target->GetPower(POWER_MANA) < 1000;
+            }
+    };
+    //class SelfExclude
+    //{
+    //    public:
+    //        SelfExclude(Unit const* self) { _self = self; }
+    //        bool operator()(Unit const* target)
+    //        {
+    //            return target == _self;
+    //        }
+    //    private:
+    //        Unit const* _self;
+    //};
+
+    class AuraedTargetExclude
+    {
+        public:
+            AuraedTargetExclude(uint32 spellId) : _spellId(spellId) {}
+            bool operator()(Unit const* target)
+            {
+                return target->GetAuraApplicationOfRankedSpell(_spellId);
+            }
+        private:
+            uint32 _spellId;
+    };
+
+    class AuraedTargetExcludeByCaster
+    {
+        public:
+            AuraedTargetExcludeByCaster(uint32 spellId, ObjectGuid caster) : _spellId(spellId), _caster(caster) {}
+            bool operator()(Unit const* target)
+            {
+                return target->GetAuraApplicationOfRankedSpell(_spellId, _caster);
+            }
+        private:
+            uint32 _spellId;
+            ObjectGuid _caster;
+    };
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..8cc83e9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,12935 @@
+#include "bot_ai.h"
+//#include "botcommon.h"
+#include "bot_Events.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "bpet_ai.h"
+#include "Bag.h"
+#include "CellImpl.h"
+#include "CharacterCache.h"
+#include "Chat.h"
+#include "GameEventMgr.h"
+#include "GridNotifiersImpl.h"
+#include "Item.h"
+#include "LFG.h"
+#include "LFGMgr.h"
+#include "Mail.h"
+#include "MapManager.h"
+#include "MotionMaster.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Trickerer (https://github.com/trickerer/Trinity-Bots; onlysuffering@gmail.com)
+Version 4.7.27a
+Original idea: https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+dk pets (garg, aod, rdw)
+'Go there and do stuff' scenarios
+Encounter Scenarios
+Notes:
+Methods may have null arg1 (Unit*):
+DamageTaken(Unit*, ), JustDied(Unit*, ), OwnerAttackedBy(Unit*, ), HealReceived(Unit*, )
+Possibly others
+*/
+#define MAX_AMMO_LEVEL 13
+uint8 const AmmoDPSForLevel[MAX_AMMO_LEVEL][2] =
+{
+    {  1,  1 },
+    {  5,  2 },
+    { 10,  3 },
+    { 15,  4 },
+    { 25,  7 },
+    { 30,  8 },
+    { 37, 12 },
+    { 44, 15 },
+    { 52, 17 },
+    { 57, 26 },
+    { 62, 43 },
+    { 72, 67 },
+    { 80, 91 }
+};
+#define MAX_POTION_SPELLS 8
+#define MAX_FEAST_SPELLS 11
+uint32 const ManaPotionSpells[MAX_POTION_SPELLS][2] =
+{
+    {  5,   437 },
+    { 14,   438 },
+    { 22,  2023 },
+    { 31, 11903 },
+    { 41, 17530 },
+    { 49, 17531 },
+    { 55, 28499 },
+    { 70, 43186 }
+};
+uint32 const HealingPotionSpells[MAX_POTION_SPELLS][2] =
+{
+    {  1,   439 },
+    {  3,   440 },
+    { 12,   441 },
+    { 21,  2024 },
+    { 35,  4042 },
+    { 45, 17534 },
+    { 55, 28495 },
+    { 70, 43185 }
+};
+uint32 const DrinkSpells[MAX_FEAST_SPELLS][2] =
+{
+    {  1,   430 },
+    {  5,   431 },
+    { 15,   432 },
+    { 25,  1133 },
+    { 35,  1135 },
+    { 45,  1137 },
+    { 60, 34291 },
+    { 65, 27089 },
+    { 70, 43182 },
+    { 75, 43183 },
+    { 80, 57073 }
+};
+uint32 const EatSpells[MAX_FEAST_SPELLS][2] =
+{
+    {  1,   433 },
+    {  5,   434 },
+    { 15,   435 },
+    { 25,  1127 },
+    { 35,  1129 },
+    { 45,  1131 },
+    { 55, 27094 },
+    { 65, 35270 },
+    { 70, 43180 }, //req 65 but
+    { 75, 45548 },
+    { 80, 45548 }
+};
+uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+#define BOT_SPECS_COUNT 31
+const char* BotTalentSpecStrings[BOT_SPECS_COUNT] =
+{
+    "Arms",
+    "Fury",
+    "Protection",
+    "Holy",
+    "Protection",
+    "Retribution",
+    "Beast Mastery",
+    "Marksmanship",
+    "Survival",
+    "Assassination",
+    "Combat",
+    "Subtlety",
+    "Discipline",
+    "Holy",
+    "Shadow",
+    "Blood",
+    "Frost",
+    "Unholy",
+    "Elemental",
+    "Enhancement",
+    "Restoration",
+    "Arcane",
+    "Fire",
+    "Frost",
+    "Affliction",
+    "Demonology",
+    "Destruction",
+    "Balance",
+    "Feral Combat",
+    "Restoration",
+    "Unknown"
+};
+
+void ApplyBotPercentModFloatVar(float &var, float val, bool apply)
+{
+    var *= (apply ? ((100.f + val) / 100.f) : (100.f / (100.f + val)));
+}
+
+static uint16 __rand; //calculated for each bot separately once every updateAI tick
+
+static std::set<uint32> BotCustomSpells;
+static bool SPELLS_DEFINED = false;
+
+bot_ai::bot_ai(Creature* creature) : CreatureAI(creature)
+{
+    //moved
+    _potionTimer = 0;
+    _classinfo = new PlayerClassLevelInfo();
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        _equips[i] = nullptr;
+
+    _reviveTimer = 0;
+    _powersTimer = 0;
+    _chaseTimer = 0;
+
+    _jumpCount = 0;
+    _evadeCount = 0;
+
+    _lastTargetGuid = ObjectGuid::Empty;
+
+    if (BotMgr::DisplayEquipment() == false)
+    {
+        (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 &= ~(UNIT_FLAG2_MIRROR_IMAGE);
+        me->SetFlag(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+    }
+
+    checkMasterTimer = urand(5000, 15000);
+    feast_health = false;
+    feast_mana = false;
+    spawned = false;
+    firstspawn = true;
+    _evadeMode = false;
+    _atHome = true;
+    _roleMask = 0;
+    haste = 0;
+    hit = 0.f;
+    parry = 0.f;
+    dodge = 0.f;
+    block = 0.f;
+    crit = 0.f;
+    dmg_taken_phy = 1.f;
+    dmg_taken_mag = 1.f;
+    armor_pen = 0.f;
+    expertise = 0;
+    spellpower = 0;
+    spellpen = 0;
+    defense = 0;
+    blockvalue = 1;
+    regenTimer = 0;
+    m_botSpellInfo = nullptr;
+    waitTimer = 0;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _energyFraction = 0.f;
+    _updateTimerMedium = 0;
+    _updateTimerEx1 = urand(12000, 15000);
+    checkAurasTimer = 0;
+    roleTimer = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = ObjectGuid::Empty;
+
+    _deathsCount = 0;
+    _killsCount = 0;
+    _pvpKillsCount = 0;
+    _playerKillsCount = 0;
+
+    for (uint8 i = 0; i != 6; ++i)
+        resistbonus[i] = 0;
+
+    botPet = nullptr;
+    canUpdate = true;
+
+    teleHomeEvent = nullptr;
+    teleFinishEvent = nullptr;
+
+    _ownerGuid = 0;
+
+    ResetBotAI(BOTAI_RESET_INIT);
+
+    BotDataMgr::RegisterBot(me);
+}
+bot_ai::~bot_ai()
+{
+    while (!_spells.empty())
+    {
+        BotSpellMap::iterator itr = _spells.begin();
+        delete itr->second;
+        _spells.erase(itr);
+    }
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        if (_equips[i])
+            delete _equips[i];
+
+    delete _classinfo;
+
+    BotDataMgr::UnregisterBot(me);
+}
+
+uint16 bot_ai::Rand() const
+{
+    return __rand;
+}
+//0-178
+void bot_ai::GenerateRand() const
+{
+    __rand = urand(0, IAmFree() ? 100 : 100 + (master->GetNpcBotsCount() - 1) * 2);
+}
+
+void bot_ai::BotSay(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->Say(text, LANG_UNIVERSAL, target);
+}
+void bot_ai::BotWhisper(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    Player* playerTarget = const_cast<Player*>(target);
+
+    me->Whisper(text, LANG_UNIVERSAL, playerTarget);
+}
+void bot_ai::BotYell(char const* text, Player const* /*target*/) const
+{
+    //if (!target && master->GetTypeId() == TYPEID_PLAYER)
+    //    target = master;
+    //if (!target)
+    //    return;
+
+    me->Yell(text, LANG_UNIVERSAL);
+}
+
+bool bot_ai::SetBotOwner(Player* newowner)
+{
+    ASSERT(newowner && "Trying to set NULL owner!!!");
+    ASSERT(newowner->GetGUID().IsPlayer() && "Trying to set a non-player as owner!!!");
+    //ASSERT(master->GetGUID() == me->GetGUID());
+    //ASSERT(IAmFree());
+
+    //have master already
+    if (master->GetGUID() != me->GetGUID())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): bot %s (id: %u) has master %s while trying to set to %s...",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+    if (!IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): minion bot %s (id: %u) IS NOT FREE (has master %s) while trying to set to %s",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+
+    BotMgr* mgr = newowner->GetBotMgr();
+    if (!mgr)
+        mgr = new BotMgr(newowner);
+
+    bool takeMoney = (_ownerGuid != newowner->GetGUID().GetCounter());
+    if (mgr->AddBot(me, takeMoney) & BOT_ADD_FATAL)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): player %s (%u) can't add bot %s (FATAL), removing...",
+        //    master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str());
+        //failed to add bot
+        //if (_ownerGuid)
+        //{
+        //    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //    //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        //    stmt->setUInt32(0, uint32(0));
+        //    stmt->setUInt32(1, me->GetEntry());
+        //    CharacterDatabase.Execute(stmt);
+        //}
+
+        if (_ownerGuid)
+        {
+            TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): %s's master %s (guid: %u) is found but bot failed to set owner (fatal)! Unbinding bot temporarily (until server restart)...",
+                me->GetName().c_str(), newowner->GetName().c_str(), newowner->GetGUID().GetCounter());
+            //_ownerGuid = 0;
+
+            SetBotCommandState(BOT_COMMAND_FULLSTOP); //prevent all actions
+            me->SetStandState(UNIT_STAND_STATE_SLEEP);
+            return false;
+        }
+
+        checkMasterTimer = 30000;
+        ResetBotAI(BOTAI_RESET_LOST);
+        return false;
+    }
+
+    spawned = false;
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 &= ~(UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+
+    //recursive
+    if (master->GetGUID() == newowner->GetGUID())
+        return true;
+
+    master = newowner;
+    _ownerGuid = newowner->GetGUID().GetCounter();
+
+    ASSERT(me->IsInWorld());
+    AbortTeleport();
+    return true;
+}
+
+void bot_ai::ResetBotAI(uint8 resetType)
+{
+    //ASSERT(me->IsInWorld());
+
+    m_botCommandState = BOT_COMMAND_FOLLOW;
+
+    master = reinterpret_cast<Player*>(me);
+    if (resetType & BOTAI_RESET_MASK_ABANDON_MASTER)
+        _ownerGuid = 0;
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 |= (UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+
+    //me->IsAIEnabled = true;
+    canUpdate = true;
+
+    if (spawned)
+        ReturnHome();
+
+    if (!me->IsInWorld())
+    {
+        AbortTeleport();
+
+        //if no master - will teleport to spawn position
+        //otherwise - will teleport to master
+        teleHomeEvent = new TeleportHomeEvent(this);
+        Events.AddEvent(teleHomeEvent, Events.CalculateTime(std::chrono::milliseconds(0))); //make sure event will be deleted
+        if (teleHomeEvent->IsActive())
+            teleHomeEvent->ScheduleAbort(); //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+    }
+    else
+    {
+        _atHome = false;
+        spawned = false;
+    }
+}
+
+bool bot_ai::_checkImmunities(Unit const* target, SpellInfo const* spellInfo) const
+{
+    return target && spellInfo && !target->IsImmunedToDamage(spellInfo);
+}
+
+SpellCastResult bot_ai::CheckBotCast(Unit const* victim, uint32 spellId) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->IsGameMaster())
+        return SPELL_FAILED_BAD_TARGETS;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (me->IsMounted() && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED))
+        return SPELL_FAILED_NOT_MOUNTED;
+
+    if (int32(me->GetPower(Powers(spellInfo->PowerType))) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_NO_POWER;
+
+    if (!IsSpellReady(spellInfo->GetFirstRankSpell()->Id, lastdiff, false))
+        return SPELL_FAILED_NOT_READY;
+
+    //if (victim->isType(TYPEMASK_UNIT) && InDuel(victim))
+    //    return SPELL_FAILED_BAD_TARGETS;
+
+    //scaling aura
+    if (victim->isType(TYPEMASK_UNIT) && victim != me &&
+        !spellInfo->IsPassive() && spellInfo->SpellLevel && !spellInfo->IsChanneled() &&
+        (victim->GetLevel() + 10) < int32(spellInfo->GetFirstRankSpell()->SpellLevel))
+    {
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA && spellInfo->IsPositiveEffect(i))
+            {
+                //TC_LOG_ERROR("scripts", "CheckBotCast(): deny cast of %s by %s on low-level target %s (lvl %u)",
+                //    spellInfo->SpellName[0], me->GetName().c_str(), victim->GetName().c_str(), victim->GetLevel());
+                return SPELL_FAILED_LOWLEVEL;
+            }
+        }
+    }
+
+    //disarmed
+    if (spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON)
+    {
+        if (spellInfo->EquippedItemInventoryTypeMask != 0)
+        {
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1<<INVTYPE_WEAPONMAINHAND)) &&
+                !me->CanUseAttackType(BASE_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1<<INVTYPE_WEAPONOFFHAND)) &&
+                !me->CanUseAttackType(OFF_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & ((1<<INVTYPE_RANGED)|(1<<INVTYPE_RANGEDRIGHT)|(1<<INVTYPE_THROWN))) &&
+                !me->CanUseAttackType(RANGED_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+        else if (!me->CanUseAttackType(BASE_ATTACK))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+    }
+
+    //immunities
+    if (victim->isType(TYPEMASK_UNIT))
+    {
+        if (spellInfo->HasEffect(SPELL_EFFECT_HEAL) || spellInfo->HasAura(SPELL_AURA_PERIODIC_HEAL))
+        {
+            //banish or something
+            Unit::AuraEffectList const& healPctEffects = victim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_PCT);
+            if (!healPctEffects.empty())
+            {
+                int32 castTime = spellInfo->CastTimeEntry ? spellInfo->CastTimeEntry->Base : 0;
+                if (castTime)
+                    ApplyClassSpellCastTimeMods(spellInfo, castTime);
+                for (Unit::AuraEffectList::const_iterator itr = healPctEffects.begin(); itr != healPctEffects.end(); ++itr)
+                    if ((*itr)->GetAmount() <= -100 && (!castTime || (*itr)->GetBase()->GetDuration() >= castTime))
+                        return SPELL_FAILED_BAD_TARGETS;
+            }
+        }
+        else if (//spells that ignore immunities
+            spellId != 64382 && //shattering throw
+            spellId != 32375 && //mass dispel
+            !_checkImmunities(victim, spellInfo))
+            return SPELL_FAILED_BAD_TARGETS;
+    }
+
+    switch (_botclass)
+    {
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_WARRIOR: //BladeStorm
+        case BOT_CLASS_BM: //BladeStorm PLACEHOLDER
+        case BOT_CLASS_ROGUE: //Killing Spree
+            if (me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "CheckBotCast(): Unknown bot class %u", _botclass);
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered)
+{
+    return doCast(victim, spellId, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags)
+{
+    if (spellId == 0) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+    if (IsCasting()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    //select aura level
+    if (victim->isType(TYPEMASK_UNIT))
+        if (SpellInfo const* actualSpellInfo = m_botSpellInfo->GetAuraRankForLevel(victim->GetLevel()))
+            m_botSpellInfo = actualSpellInfo;
+
+    if (victim->isType(TYPEMASK_UNIT) && (flags & TRIGGERED_FULL_MASK) != TRIGGERED_FULL_MASK &&
+        !(m_botSpellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS) &&
+        !IsInBotParty(victim) && !me->IsWithinLOSInMap(victim))
+        return false;
+
+    //check wrong spell interruption attempts
+    if (/*victim->isType(TYPEMASK_UNIT) && */!CastingUnitCheck::CastInterruptionCheck(victim, m_botSpellInfo))
+        return false;
+
+    //for debug only
+    if (victim->isType(TYPEMASK_UNIT) && !victim->IsAlive() &&
+        !(m_botSpellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_RESURRECT) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_RESURRECT_NEW) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_SELF_RESURRECT))
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::doCast(): %s (bot class %u) tried to cast spell %u on a dead target %s",
+            me->GetName().c_str(), _botclass, spellId, victim->GetName().c_str());
+        //return false;
+    }
+
+    if (me->isMoving() &&
+        ((m_botSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT)
+        //autorepeat spells missing SPELL_INTERRUPT_FLAG_MOVEMENT
+        || spellId == SHOOT_WAND
+        //channeled spells missing SPELL_INTERRUPT_FLAG_MOVEMENT
+        //Mind Flay (Rank 8)
+        || spellId == 48155) &&
+        !(m_botSpellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING) && !m_botSpellInfo->IsAutoRepeatRangedSpell() &&
+        !(flags & TRIGGERED_FULL_MASK) && (m_botSpellInfo->IsChanneled() || m_botSpellInfo->CalcCastTime()))
+    {
+        if (JumpingOrFalling())
+            return false;
+        if (!m_botSpellInfo->HasEffect(SPELL_EFFECT_HEAL) && Rand() > (IAmFree() ? 80 : 50))
+            return false;
+
+        //if (m_botSpellInfo->IsChanneled())
+        //    TC_LOG_ERROR("entities.player", "bot_ai::doCast(): spell %u interrupts movement", spellId);
+        me->BotStopMovement();
+    }
+
+    if ((!victim->isType(TYPEMASK_UNIT) || IsInBotParty(victim)) && !victim->IsWithinLOSInMap(me) &&
+        !HasBotCommandState(BOT_COMMAND_STAY))
+    {
+        if (!IAmFree())
+        {
+            if (me->GetDistance(victim) > 10.f)
+            {
+                Position pos = victim->GetPosition();
+                //victim->GetPosition(&pos);
+                me->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            }
+            else
+                me->Relocate(victim);
+        }
+        else
+            return false;
+    }
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            if (!const_cast<bot_ai*>(this)->removeShapeshiftForm())
+                return false;
+    }
+
+    //CHECKS PASSED, NOW DO IT
+
+    if (me->GetStandState() == UNIT_STAND_STATE_SIT && !(m_botSpellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING))
+    {
+        if (!doMana && (me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+            UpdateMana();
+
+        feast_health = false;
+        feast_mana = false;
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+
+    //debug
+    //TC_LOG_ERROR("entities.player", "CheckBotCast(): %s (%u) by %s on %s", m_botSpellInfo->SpellName[0], spellId, me->GetName().c_str(), victim->GetName().c_str());
+
+    bool triggered = (flags & TRIGGERED_CAST_DIRECTLY);
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags);
+    spell->prepare(targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        return false;
+    }
+
+    if (triggered)
+        return true;
+    if (m_botSpellInfo->IsPassive() || m_botSpellInfo->IsCooldownStartedOnEvent())
+        return true;
+    if (!m_botSpellInfo->StartRecoveryCategory || !m_botSpellInfo->StartRecoveryTime)
+        return true;
+
+    float gcd = float(m_botSpellInfo->StartRecoveryTime);
+
+    ApplyBotSpellGlobalCooldownMods(m_botSpellInfo, gcd);
+    //Apply haste to cooldown
+    if (haste && m_botSpellInfo->StartRecoveryCategory == 133 && m_botSpellInfo->StartRecoveryTime == 1500 &&
+        m_botSpellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE && m_botSpellInfo->DmgClass != SPELL_DAMAGE_CLASS_RANGED &&
+        !(m_botSpellInfo->Attributes & (SPELL_ATTR0_REQ_AMMO|SPELL_ATTR0_ABILITY)))
+        ApplyBotPercentModFloatVar(gcd, float(haste), false);
+
+    //if cast time is lower than 1.5 sec it also reduces gcd but only if not instant
+    if (m_botSpellInfo->CastTimeEntry)
+    {
+        if (int32 castTime = m_botSpellInfo->CastTimeEntry->Base)
+        {
+            if (castTime > 0)
+            {
+                ApplyClassSpellCastTimeMods(m_botSpellInfo, castTime);
+                if (castTime < gcd)
+                    gcd = castTime;
+            }
+        }
+    }
+
+    GC_Timer = uint32(gcd);
+    //global cd cannot be less than 1000 ms
+    GC_Timer = std::max<uint32>(GC_Timer, 1000);
+    //global cd cannot be greater than 1500 ms
+    GC_Timer = std::min<uint32>(GC_Timer, 1500);
+
+    return true;
+}
+//Follow point calculation
+void bot_ai::_calculatePos(Position& pos) const
+{
+    ASSERT(!IAmFree());
+
+    uint8 followdist = master->GetBotMgr()->GetBotFollowDist();
+    float mydist, angle;
+
+    if (HasRole(BOT_ROLE_TANK) && !IsTank(master))
+    {
+        uint8 tanks = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_TANK, me);
+        angle = M_PI / 6.0f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / tanks) * (slot - (slot % 2)); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        mydist = 3.5f;
+    }
+    else if (HasRole(BOT_ROLE_RANGED))
+    {
+        uint8 rangeds = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_RANGED);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_RANGED, me);
+        angle = M_PI / 3.5f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / rangeds) * (slot - (slot % 2)); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        angle += M_PI; //behind
+        mydist = 1.0f;
+    }
+    else if (HasRole(BOT_ROLE_DPS))
+    {
+        uint8 dpss = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_DPS);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_DPS, me);
+        angle = M_PI / 7.5f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / dpss) * (slot); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        angle += ((slot % 4) < 2) ? (M_PI/2.f) : -(M_PI/2.f); //sides
+        mydist = 2.0f;
+    }
+    else
+    {
+        angle = (me->GetEntry() % 2) ? (M_PI/2.f) : -(M_PI/2.f);
+        mydist = 0.5f;
+    }
+
+    mydist += std::max<float>(int8(followdist) - 30, 5) / 7.f; //1.f-10.f
+    mydist = std::max<float>(mydist - 2.f, 0.0f); //get bots closer
+    angle += master->GetOrientation();
+
+    float x(0),y(0),z(master->GetPositionZ());
+    float size = me->GetCombatReach()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        //master->GetNearPoint(me, x, y, z, mydist, angle);
+        master->GetNearPoint2D(nullptr, x, y, mydist+size, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+        }
+        else
+            over = true;
+    }
+
+    //plan ahead
+    uint32 movFlags = master->m_movementInfo.GetMovementFlags();
+    if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & MOVEMENTFLAG_FALLING_FAR))
+    {
+        float const aheadDist = std::max<float>(followdist * 0.08, 6.f);
+        x += aheadDist * std::cos(master->GetOrientation());
+        y += aheadDist * std::sin(master->GetOrientation());
+    }
+    if (!me->CanFly())
+        me->UpdateGroundPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.5f; //prevent going underground
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //         TTT
+    //      m       m
+    //     m    M    m
+    //      m       m
+    //        rrrrr
+    //
+    //M - master
+    //T - bot tank (ROLE_TANK)
+    //r - ranged (ROLE_RANGED)
+    //m - melee (ROLE_DPS)
+}
+// Movement set
+// Uses MovePoint() for following instead of MoveFollow()
+// This helps bots overcome a bug with fanthom walls on grid borders blocking pathing
+void bot_ai::SetBotCommandState(uint8 st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    if ((st & BOT_COMMAND_FOLLOW) && !IsChanneling() &&
+        ((!me->isMoving() && !IsCasting() && master->IsAlive() && !Feasting()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 10) return;
+        if (!newpos)
+            _calculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->GetStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        if (IsShootingWand())
+            me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+        RemoveBotCommandState(BOT_COMMAND_STAY | BOT_COMMAND_FULLSTOP | BOT_COMMAND_ATTACK | BOT_COMMAND_COMBATRESET);
+    }
+    else if (st & BOT_COMMAND_FULLSTOP)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_STAY | BOT_COMMAND_ATTACK);
+        me->AttackStop();
+        me->InterruptNonMeleeSpells(true);
+        if (me->isMoving())
+            me->BotStopMovement();
+    }
+    else if (st & BOT_COMMAND_STAY)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_FULLSTOP);
+        if (me->isMoving())
+            me->BotStopMovement();
+    }
+    else if (st & BOT_COMMAND_ATTACK)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW);
+    }
+    else if (st & BOT_COMMAND_COMBATRESET)
+    {
+        RemoveBotCommandState(BOT_COMMAND_ATTACK);
+    }
+    m_botCommandState |= st;
+}
+
+void bot_ai::RemoveBotCommandState(uint8 st)
+{
+    m_botCommandState &= ~st;
+}
+// Buffs And Heal (really)
+// Priority as follows: 1) heal players 2) buff players 3) heal bots 4) buff bots
+// Priority adjustments to be considered
+void bot_ai::BuffAndHealGroup(uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        //heals
+        //if (HealTarget(me, diff))
+        //    return;
+        //if (botPet)
+        //{
+        //    if (botPet->IsAlive())
+        //    {
+        //        if (HealTarget(botPet, diff))
+        //            return;
+        //    }
+        //}
+
+        bool omniHostile = (me->GetFaction() == 14 || me->HasAura(BERSERK));
+
+        //if (!omniHostile && HasRole(BOT_ROLE_HEAL))
+        //{
+        //    std::list<Unit*> targets1;
+        //    GetNearbyFriendlyTargetsList(targets1, 38);
+        //    targets1.remove_if(BOTAI_PRED::HealTargetExclude());
+        //    if (!targets1.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets1), diff))
+        //        return;
+        //}
+
+        //buffs
+        if (BuffTarget(me, diff))
+            return;
+
+        if (!omniHostile)
+        {
+            std::list<Unit*> targets2;
+            GetNearbyFriendlyTargetsList(targets2, 30);
+            targets2.remove_if(BOTAI_PRED::BuffTargetExclude());
+            for (std::list<Unit*>::const_iterator itr = targets2.begin(); itr != targets2.end(); ++itr)
+                if (urand(1,100) <= 30 && BuffTarget(*itr, diff))
+                    return;
+        }
+
+        return;
+    }
+
+    BotMap const* map;
+    Group const* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        //heals
+        map = master->GetBotMgr()->GetBotMap();
+        if (HasRole(BOT_ROLE_HEAL))
+        {
+            std::list<Unit*> targets3;
+            if (master->IsAlive() && !master->HasUnitState(UNIT_STATE_ISOLATED) && GetHealthPCT(master) < 95 && me->GetDistance(master) < 40)
+                targets3.push_back(master);
+            //if (Unit* veh = master->GetVehicleBase())
+            //    if (veh->GetTypeId() == TYPEID_UNIT)
+            //        if (veh->ToCreature()->GetCreatureTemplate()->type != CREATURE_TYPE_MECHANICAL)
+            //            targets3.push_back(veh);
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Unit* u = itr->second;
+                if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                    u->ToCreature()->IsTempBot() || me->GetDistance(u) > 40 ||
+                    (GetHealthPCT(u) > 95 && !IsTank(u))))
+                    targets3.push_back(u);
+
+                u = itr->second->GetBotsPet();
+
+                if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 40 || GetHealthPCT(u) > 95))
+                    targets3.push_back(u);
+            }
+            for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                    u->IsTotem() || u->GetEntry() == SHAMAN_EARTH_ELEMENTAL || me->GetDistance(u) > 40 ||
+                    (GetHealthPCT(u) > 95 && !IsTank(u)))
+                    continue;
+
+                targets3.push_back(u);
+            }
+
+            if (!targets3.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets3), diff))
+                return;
+        }
+        //buffs
+        std::list<Unit*> targets4;
+        if (master->IsAlive() && me->GetDistance(master) < 30)
+            targets4.push_back(master);
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Unit* u = itr->second;
+            if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                u->IsTotem() || me->GetDistance(u) > 30))
+                targets4.push_back(u);
+
+            //u = itr->second->GetBotsPet();
+
+            //if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 30))
+            //    targets4.push_back(u);
+        }
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                u->IsTotem() || me->GetDistance(u) > 30) continue;
+
+            targets4.push_back(u);
+        }
+
+        if (!targets4.empty() && BuffTarget(Trinity::Containers::SelectRandomContainerElement(targets4), diff))
+            return;
+
+        return;
+    }
+    bool Bots = false;
+    //heals
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        std::list<Unit*> targets5;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots)
+                Bots = true;
+            if (!tPlayer->IsAlive() || tPlayer->HasUnitState(UNIT_STATE_ISOLATED)) continue;
+            if (me->GetDistance(tPlayer) > 40) continue;
+            if (GetHealthPCT(tPlayer) < 95 || IsTank(tPlayer))
+                targets5.push_back(tPlayer);
+        }
+        if (Bots)
+        {
+            for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* tPlayer = itr->GetSource();
+                if (tPlayer == nullptr) continue;
+                if (me->GetMap() != tPlayer->FindMap()) continue;
+
+                if (tPlayer->HaveBot())
+                {
+                    map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Unit* u = itr->second;
+                        if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                            u->ToCreature()->IsTempBot() || me->GetDistance(u) > 40 ||
+                            (GetHealthPCT(u) > 95 && !IsTank(u))))
+                            targets5.push_back(u);
+
+                        u = itr->second->GetBotsPet();
+
+                        if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 40 || GetHealthPCT(u) > 95))
+                            targets5.push_back(u);
+                    }
+                }
+                for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                {
+                    Unit* u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                        u->IsTotem() || u->GetEntry() == SHAMAN_EARTH_ELEMENTAL || me->GetDistance(u) > 40 ||
+                        (GetHealthPCT(u) > 95 && !IsTank(u)))
+                        continue;
+
+                    targets5.push_back(u);
+                }
+            }
+        }
+
+        //check if we have pointed heal target
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = pGroup->GetTargetIcons()[i])
+                {
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsAlive() && !unit->HasUnitState(UNIT_STATE_ISOLATED) && me->GetMap() == unit->FindMap() && me->GetDistance(unit) < 40 &&
+                            GetHealthPCT(unit) < 95 && master->GetVictim() != unit && !IsInBotParty(unit->GetVictim()) &&
+                            unit->GetEntry() != SHAMAN_EARTH_ELEMENTAL &&
+                            !(unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            targets5.push_back(unit);
+                        }
+                    }
+                }
+            }
+        }
+        if (!targets5.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets5), diff))
+            return;
+    }
+    //buffs
+    std::list<Unit*> targets6;
+    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == nullptr) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!Bots)
+            Bots = true;
+        if (!tPlayer->IsAlive() || tPlayer->HasUnitState(UNIT_STATE_ISOLATED)) continue;
+        if (me->GetDistance(tPlayer) > 30) continue;
+        targets6.push_back(tPlayer);
+    }
+    if (Bots)
+    {
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player const* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    Unit* u = itr->second;
+                    if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                        u->IsTotem() || me->GetDistance(u) > 30))
+                        targets6.push_back(u);
+
+                    //u = itr->second->GetBotsPet();
+
+                    //if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 30))
+                    //    targets6.push_back(u);
+                }
+            }
+            for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                    u->IsTotem() || me->GetDistance(u) > 30) continue;
+
+                targets6.push_back(u);
+            }
+        }
+    }
+
+    if (!targets6.empty() && BuffTarget(Trinity::Containers::SelectRandomContainerElement(targets6), diff))
+        return;
+}
+// Attempt to resurrect dead players and bots
+// Target is either bot, player or player corpse
+// no need to check global cooldown
+void bot_ai::RezGroup(uint32 REZZ)
+{
+    if (!REZZ || Rand() > 10)
+        return;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(REZZ);
+    ASSERT(spellInfo);
+    if (int32(me->GetPower(Powers(spellInfo->PowerType))) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return;
+
+    //TC_LOG_ERROR("entities.player", "RezGroup by %s", me->GetName().c_str());
+
+    if (IAmFree())
+    {
+        if (me->GetFaction() == 14 || me->HasAura(BERSERK))
+            return;
+
+        WorldObject* playerOrCorpse = GetNearbyRezTarget();
+        if (!playerOrCorpse)
+            return;
+
+        if (!playerOrCorpse->IsWithinLOSInMap(me))
+            me->Relocate(*playerOrCorpse);
+
+        Unit* target = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToUnit() : (Unit*)playerOrCorpse->ToCorpse();
+        if (doCast(target, REZZ)) //rezzing it
+        {
+            if (Player const* player = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToPlayer() : ObjectAccessor::FindPlayer(playerOrCorpse->ToCorpse()->GetOwnerGUID()))
+                BotWhisper("Rezzing You", player);
+        }
+
+        return;
+    }
+
+    Group const* group = master->GetGroup();
+    if (!group)
+    {
+        if (master->IsAlive() || master->IsResurrectRequested())
+            return;
+
+        Unit* target = master;
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30 && !HasBotCommandState(BOT_COMMAND_STAY))
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            return;
+        }
+        else if (me->GetDistance(target) < 15 && !target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+            BotWhisper("Rezzing You");
+
+        return;
+    }
+
+    bool Bots = false;
+    Player* player;
+    Unit* target;
+    for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+    {
+        player = itr->GetSource();
+        target = player;
+        if (!player || player->FindMap() != me->GetMap()) continue;
+        if (!Bots && player->HaveBot())
+            Bots = true;
+        if (player->IsAlive() || player->IsResurrectRequested()) continue;
+        if (player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)player->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (target->GetTypeId() != player->GetTypeId() && me->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30 && !HasBotCommandState(BOT_COMMAND_STAY))
+        {
+            if (player == master)
+            {
+                me->GetMotionMaster()->MovePoint(me->GetMapId(), *target);
+                return;
+            }
+            continue;
+        }
+        else if (me->GetDistance(target) < 15 && !target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            BotWhisper("Rezzing You", player);
+            if (player != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += player->GetName();
+                BotWhisper(rezstr.c_str());
+            }
+            return;
+        }
+    }
+
+    if (!Bots)
+        return;
+
+    std::list<Unit*> targets;
+    BotMap const* map;
+    for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+    {
+        player = itr->GetSource();
+        if (!player || player->FindMap() != me->GetMap() || !player->HaveBot()) continue;
+
+        map = player->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            target = itr->second;
+            if (!target || !target->IsInWorld() || target->IsAlive()) continue;
+            if (itr->second->GetBotAI()->GetReviveTimer() < 15000) continue;
+            if (me->GetDistance(target) < 30 && target->IsWithinLOSInMap(me))
+                targets.push_back(target);
+        }
+    }
+
+    //TC_LOG_ERROR("entities.unit", "RezGroup: %s found %u targets", me->GetName().c_str(), uint32(targets.size()));
+
+    if (targets.empty())
+        return;
+
+    target = targets.size() < 2 ? targets.front() : Trinity::Containers::SelectRandomContainerElement(targets);
+
+    if (doCast(target, REZZ))
+    {
+        Player const* targetOwner = target->ToCreature()->GetBotOwner();
+        if (targetOwner != master)
+        {
+            std::string rezstr1 = "Rezzing ";
+            rezstr1 += target->GetName();
+            rezstr1 += " (your bot)";
+
+            std::string rezstr2 = "Rezzing ";
+            rezstr2 += target->GetName();
+            rezstr2 += " (";
+            rezstr2 += targetOwner->GetName();
+            rezstr2 += "'s bot)";
+
+            BotWhisper(rezstr1.c_str(), targetOwner);
+            BotWhisper(rezstr2.c_str());
+        }
+        else
+        {
+            std::string rezstr3 = "Rezzing ";
+            rezstr3 += target->GetName();
+            BotWhisper(rezstr3.c_str());
+        }
+        return;
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_ai::CureGroup(uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell) return;
+    if (GC_Timer > diff) return;
+    if (me->IsMounted())
+    if (IsTank() && me->GetVictim() && me->GetMap()->IsRaid()) return;
+    if (IsCasting()) return;
+
+    if (IAmFree())
+    {
+        std::list<Unit*> cureTargets;
+
+        if (_canCureTarget(me, cureSpell))
+            cureTargets.push_back(me);
+        if (botPet && _canCureTarget(botPet, cureSpell))
+            cureTargets.push_back(botPet);
+
+        if (!(me->GetFaction() == 14 || me->HasAura(BERSERK)))
+        {
+            std::list<Unit*> targets1;
+            GetNearbyFriendlyTargetsList(targets1, 38);
+            for (std::list<Unit*>::const_iterator itr = targets1.begin(); itr != targets1.end(); ++itr)
+                if (_canCureTarget(*itr, cureSpell))
+                    cureTargets.push_back(*itr);
+        }
+
+        if (!cureTargets.empty())
+        {
+            if (doCast(Trinity::Containers::SelectRandomContainerElement(cureTargets), cureSpell))
+                return;
+        }
+
+        return;
+    }
+
+    if (!master->GetMap()->IsRaid() && Rand() > 35)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    std::list<Unit*> targets;
+    Group const* pGroup = master->GetGroup();
+    BotMap const* map;
+    Unit* u;
+    if (!pGroup)
+    {
+        if (_canCureTarget(master, cureSpell))
+            targets.push_back(master);
+
+        map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            u = itr->second;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (_canCureTarget(tPlayer, cureSpell))
+                targets.push_back(tPlayer);
+        }
+        if (!Bots) return;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                    if (_canCureTarget(u, cureSpell))
+                        targets.push_back(u);
+                }
+            }
+
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+                if (_canCureTarget(u, cureSpell))
+                    targets.push_back(u);
+            }
+        }
+    }
+
+    if (!targets.empty())
+    {
+        if (doCast(Trinity::Containers::SelectRandomContainerElement(targets), cureSpell))
+            return;
+    }
+}
+
+// determines if unit has something to cure
+bool bot_ai::_canCureTarget(Unit const* target, uint32 cureSpell) const
+{
+    if (me->GetLevel() < 10 || target->GetLevel() < 10) return false;
+    if (target->HasUnitState(UNIT_STATE_ISOLATED)) return false;
+    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsTempBot()) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    if (me->GetDistance(target) > CalcSpellMaxRange(cureSpell, false))
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    //SpellBreaker addins
+    if (cureSpell == SPELL_STEAL_MAGIC)
+        dispelMask |= (1<<DISPEL_MAGIC) | (1<<DISPEL_CURSE);
+
+    if (dispelMask == 0)
+        return false;
+
+    std::list<Aura const*> dispel_list;
+    _getBotDispellableAuraList(target, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_ai::_getBotDispellableAuraList(Unit const* target, uint32 dispelMask, std::list<Aura const*> &dispelList) const
+{
+    //Unholy Blight prevents diseases from being dispelled
+    if ((dispelMask & (1<<DISPEL_DISEASE)) &&
+        target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0))
+        dispelMask &= ~(1<<DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura const* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(me))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (HasRole(BOT_ROLE_HEAL) && aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            if (((aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount()) > 0)
+                dispelList.push_back(aura);
+        }
+    }
+}
+//protected
+// Quick check if current target has school immunities to prevent cast attempts spam
+// CheckBotCast()->_checkImmunities()
+// Only called after opponent is validated in CheckAttackTarget()->_getTarget()
+bool bot_ai::CanAffectVictim(uint32 schoolMask) const
+{
+    if (schoolMask == SPELL_SCHOOL_MASK_NONE)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::CanDamageVictim(): schoolMask is not present (class = %u)", _botclass);
+        return false;
+    }
+
+    Unit::AuraEffectList const& schoolImmunityAurasList = opponent->GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY);
+    if (!schoolImmunityAurasList.empty())
+    {
+        uint32 finalMask = 0;
+        for (Unit::AuraEffectList::const_iterator itr = schoolImmunityAurasList.begin(); itr != schoolImmunityAurasList.end(); ++itr)
+        {
+            finalMask |= ((*itr)->GetMiscValue() & schoolMask);
+            if (finalMask == schoolMask)
+                return false;
+        }
+    }
+
+    return true;
+}
+// Check if can cast some spell out of main rotation to use up target's spell reflection charges
+// Supposed to check instant non-damaging spells but these checks are not performed (Shaman, Priest)
+bool bot_ai::CanRemoveReflectSpells(Unit const* target, uint32 spellId) const
+{
+    if (!target || !spellId)
+        return false;
+
+    if (!target->HasAuraType(SPELL_AURA_REFLECT_SPELLS) && !target->HasAuraType(SPELL_AURA_REFLECT_SPELLS_SCHOOL))
+        return false;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return false;
+
+    if (!spellInfo->IsPositive() && spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+        !(spellInfo->Attributes & SPELL_ATTR0_ABILITY) && !(spellInfo->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+        !(spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
+    {
+        //bool directDamage = false;
+        //for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        //{
+        //    if (spellInfo->Effects[i].TargetA.GetTarget() == TARGET_UNIT_TARGET_ENEMY)
+        //    {
+        //        if (spellInfo->Effects[i].IsEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_PERIODIC_DAMAGE) ||
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_PERIODIC_LEECH) ||
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_MOD_SPEED_SLOW_ALL) ||//Icy Touch
+        //            spellInfo->Effects[i].IsAura(SPELL_AURA_HASTE_SPELLS))//Slow
+        //        {
+        //            directDamage = true;
+        //            break;
+        //        }
+        //    }
+        //}
+        //if (directDamage)
+        //{
+            Unit::AuraEffectList const& reflectAuras1 = target->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS);
+            for (Unit::AuraEffectList::const_iterator itr = reflectAuras1.begin(); itr != reflectAuras1.end(); ++itr)
+            {
+                //All existing SPELL_AURA_REFLECT_SPELLS spells have at least amount 50
+                if ((*itr)->GetBase()->IsUsingCharges() &&
+                    (*itr)->GetBase()->GetCharges() <= target->getAttackers().size() * ((*itr)->GetBase()->GetDuration() / 1000) / 4)
+                    return true;
+            }
+
+            Unit::AuraEffectList const& reflectAuras2 = target->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
+            for (Unit::AuraEffectList::const_iterator itr = reflectAuras2.begin(); itr != reflectAuras2.end(); ++itr)
+            {
+                if ((*itr)->GetBase()->IsUsingCharges() &&
+                    (*itr)->GetAmount() >= 50 && ((*itr)->GetMiscValue() & spellInfo->GetSchoolMask()) &&
+                    (*itr)->GetBase()->GetCharges() <= ((*itr)->GetBase()->GetDuration() / 1000) / 4)
+                    return true;
+            }
+        //}
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player const* player, Unit const* unit) const
+{
+    //if (player->GetSession()->GetSecurity() == SEC_PLAYER) return;
+    if (!player->IsGameMaster() && (IAmFree() || !IsInBotParty(player))) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    botstring.setf(std::ios_base::fixed);
+    uint32 const bot_pet_player_class = unit->GetTypeId() == TYPEID_PLAYER ? unit->GetClass() : unit->ToCreature()->GetBotAI()->GetBotClass();
+    botstring << "ListAuras for" << unit->GetName().c_str() << "(class: " << uint32(bot_pet_player_class) << "), ";
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->IsNPCBot())
+    {
+        bot_ai const* ai = unit->ToCreature()->GetBotAI();
+        botstring << "master: ";
+        Player const* owner = ai->GetBotOwner();
+        botstring << (owner != unit ? owner->GetName() : "none");
+    }
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        botstring << "\n" << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        botstring << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell()))
+            rank = talentcost;
+        else if (learnSpellInfo && (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell()))
+            rank = spellInfo->GetRank();
+        else if (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            botstring << " Rank " << rank;
+        if (talentcost > 0)
+            botstring << " [talent]";
+        if (spellInfo->IsPassive())
+            botstring << " [passive]";
+        if ((spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) ||
+            (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+            botstring << " [hidden]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            botstring << " [known]";
+        else if (unit == me && GetSpell(spellInfo->GetFirstRankSpell()->Id))
+            botstring << " [ability]";
+    }
+    botstring.precision(1);
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        //ch.PSendSysMessage("base %s: %.1f", mystat.c_str(), unit->GetCreateStat(Stats(i));
+        float totalstat = unit->GetTotalStatValue(Stats(i));
+        //ch.PSendSysMessage("base total %s: %.1f", mystat.c_str(), totalstat);
+        if (unit == me)
+        {
+            int8 t = -1;
+            switch (i)
+            {
+                case STAT_STRENGTH:     t = BOT_STAT_MOD_STRENGTH;  break;
+                case STAT_AGILITY:      t = BOT_STAT_MOD_AGILITY;   break;
+                case STAT_STAMINA:      t = BOT_STAT_MOD_STAMINA;   break;
+                case STAT_INTELLECT:    t = BOT_STAT_MOD_INTELLECT; break;
+                case STAT_SPIRIT:       t = BOT_STAT_MOD_SPIRIT;    break;
+                default:                                            break;
+            }
+
+            if (t >= BOT_STAT_MOD_MANA)
+                totalstat = GetTotalBotStat(t);
+        }
+        botstring << "\ntotal" << mystat << ": " << float(totalstat);
+    }
+    botstring.precision(2);
+    botstring << "\nMelee AP: " << int32(unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    botstring << "\nRanged AP: " << int32(unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    botstring << "\narmor: " << uint32(unit->GetArmor());
+    botstring << "\ncrit: " << float(unit->GetUnitCriticalChanceDone(BASE_ATTACK));
+    botstring << "\ndefense: " << uint32(unit->GetDefenseSkillValue());
+    botstring << "\nmiss : " << float(unit->GetUnitMissChance());
+    botstring << "\ndodge: " << float(unit->GetUnitDodgeChance(BASE_ATTACK, me));
+    botstring << "\nparry: " << float(unit->GetUnitParryChance(BASE_ATTACK, me));
+    botstring << "\nblock: " << float(unit->GetUnitBlockChance(BASE_ATTACK, me));
+    botstring << "\nblock value: " << uint32(unit->GetShieldBlockValue());
+    botstring << "\nDamage taken melee: " << float(dmg_taken_phy * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    botstring << "\nDamage taken spell: " << float(dmg_taken_mag * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+
+    WeaponAttackType type = BASE_ATTACK;
+    float attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+    botstring << "\nDamage range mainhand: min: " << int32(unit->GetFloatValue(UNIT_FIELD_MINDAMAGE)) << ", max: " << int32(unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    botstring << "\nDamage mult mainhand: " << float(unit->GetPctModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetPctModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    botstring << "\nAttack time mainhand: " << float(attSpeed)
+        << " (" << float(((unit->GetFloatValue(UNIT_FIELD_MINDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2) / attSpeed) << " DPS)";
+    if (unit->haveOffhandWeapon())
+    {
+        type = OFF_ATTACK;
+        attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        botstring << "\nDamage range offhand: min: " << int32(unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE)) << ", max: " << int32(unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+        botstring << "\nDamage mult offhand: " << float(unit->GetPctModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetPctModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+        botstring << "\nAttack time offhand: " << float(attSpeed)
+            << " (" << float(((unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE)) / 2) / attSpeed) << " DPS)";
+    }
+    if (unit != me ||
+        (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) &&
+        _botclass != BOT_CLASS_PALADIN &&
+        _botclass != BOT_CLASS_DEATH_KNIGHT &&
+        _botclass != BOT_CLASS_DRUID &&
+        _botclass != BOT_CLASS_SHAMAN))
+    {
+        type = RANGED_ATTACK;
+        attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        botstring << "\nDamage range ranged: min: " << int32(unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE)) << ", max: " << int32(unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+        botstring << "\nDamage mult ranged: " << float(unit->GetPctModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetPctModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+        botstring << "\nAttack time ranged: " << float(attSpeed)
+            << " (" << float(((unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE)) / 2) / attSpeed)
+            << " (" << float(unit->GetTypeId() == TYPEID_PLAYER ? unit->ToPlayer()->GetAmmoDPS() : unit->ToCreature()->GetCreatureAmmoDPS()) << " from ammo) DPS)";
+    }
+    botstring << "\nbase hp: " << int32(unit->GetCreateHealth());
+    botstring << "\ntotal hp: " << int32(unit->GetMaxHealth());
+    botstring << "\nbase mana: " << int32(unit->GetCreateMana());
+    botstring << "\ntotal mana: " << int32(unit->GetMaxPower(POWER_MANA));
+    if (unit->GetMaxPower(POWER_MANA) > 1 && unit->GetPowerType() != POWER_MANA)
+        botstring << "\ncur mana: " << int32(unit->GetPower(POWER_MANA));
+
+    if (unit == me)
+    {
+        botstring << "\nspell power: " << int32(me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+        botstring << "\nhealth regen_5 bonus: " << int32(_getTotalBotStat(BOT_STAT_MOD_HEALTH_REGEN));
+        if (me->GetMaxPower(POWER_MANA) > 1)
+        {
+            botstring << "\nmana regen_5 casting: " << float((_botclass == BOT_CLASS_SPHYNX ? -1.f : 1.f) * me->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 5.0f);
+            botstring << "\nmana regen_5 no cast: " << float((_botclass == BOT_CLASS_SPHYNX ? -1.f : 1.f) * me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 5.0f);
+        }
+        botstring << "\nhaste: " << (haste >= 0 ? "+" : "-") << float(haste) << " pct";
+        botstring << "\nhit: +" << float (hit) << " pct";
+        botstring << "\nexpertise: " << int32(expertise) << " (-" << float(float(expertise) * 0.25f) << " pct)";
+        botstring << "\narmor penetration: " << float(me->GetCreatureArmorPenetrationCoef()) << " pct";
+        botstring << "\nspell penetration: " << uint32(spellpen);
+
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            uint32 curresist = me->GetResistance(SpellSchools(i)) + resistbonus[i-1];
+
+            const char* resist = nullptr;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            botstring << "\nResistance " << resist << ": " << uint32(curresist);
+        }
+        botstring << "\nBotCommandStates:";
+        if (HasBotCommandState(BOT_COMMAND_FOLLOW))
+            botstring << " Follow";
+        if (HasBotCommandState(BOT_COMMAND_ATTACK))
+            botstring << " Attack";
+        if (HasBotCommandState(BOT_COMMAND_STAY))
+            botstring << " Stay";
+        if (HasBotCommandState(BOT_COMMAND_COMBATRESET))
+            botstring << " Reset";
+        if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+            botstring << " FullStop";
+        if (!IAmFree())
+            botstring << "\nFollow distance: " << uint32(master->GetBotMgr()->GetBotFollowDist());
+
+        if (_botclass < BOT_CLASS_EX_START)
+            botstring << "\nSpec: " << uint32(_spec);
+
+        //botstring << "\nBoot timer: %i", _bootTimer);
+        botstring << "\nBot roles mask main: " << uint32(_roleMask & BOT_ROLE_MASK_MAIN);
+        botstring << "\nBot roles mask gathering: " << uint32(_roleMask & BOT_ROLE_MASK_GATHERING);
+
+        botstring << "\nPvP kills: " << uint32(_pvpKillsCount) << ", players: " << uint32(_playerKillsCount) << ", total: " << uint32(_killsCount);
+        botstring << "\nDied " << uint32(_deathsCount) << " times";
+
+        //debug
+        //for (uint32 i = 0; i != 148; ++i)
+        //{
+        //    float val = me->GetFloatValue(i);
+        //    ch.PSendSysMessage("Float value at %u: %.9f", i, val);
+        //}
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint16 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+    }
+
+    ch.SendSysMessage(botstring.str().c_str());
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_ai::SetStats(bool force)
+{
+    if (IsTempBot() && !force)
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = std::min<uint8>(master->GetLevel(), 80);
+
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    shouldUpdateStats = false;
+    /*TC_LOG_ERROR("entities.player", "*etStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    switch (me->GetCreatureTemplate()->rank) //TODO: conditions
+    {
+        case CREATURE_ELITE_RARE:       mylevel += 1;   break;
+        case CREATURE_ELITE_ELITE:      mylevel += 2;   break;
+        case CREATURE_ELITE_RAREELITE:  mylevel += 3;   break;
+        default:                                        break;
+    }
+    mylevel = std::min<uint8>(mylevel, 83);
+
+    //Do not remove this code
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+    else if (_botclass == BOT_CLASS_SPHYNX)
+        mylevel = std::max<uint8>(mylevel, 60);
+    else if (_botclass == BOT_CLASS_ARCHMAGE)
+        mylevel = std::max<uint8>(mylevel, 20);
+    else if (_botclass == BOT_CLASS_DREADLORD)
+        mylevel = std::max<uint8>(mylevel, 60);
+    else if (_botclass == BOT_CLASS_SPELLBREAKER)
+        mylevel = std::max<uint8>(mylevel, 20);
+    else if (_botclass == BOT_CLASS_DARK_RANGER)
+        mylevel = std::max<uint8>(mylevel, 40);
+
+    //LEVEL
+    if (me->GetLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //reinit spells/passives/other
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells(); //this must stay before class passives
+        ApplyClassPassives();
+        InitHeals();
+    }
+
+    //INIT STATS
+    //get base class stats, we'll need all this later
+    sObjectMgr->GetPlayerClassLevelInfo(GetPlayerClass(), std::min<uint8>(mylevel, 80), _classinfo);
+
+    if (force)
+    {
+        PlayerLevelInfo info;
+        sObjectMgr->GetPlayerLevelInfo(GetPlayerRace(), GetPlayerClass(), std::min<uint8>(mylevel, 80), &info);
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+            me->SetCreateStat(Stats(i), info.stats[i]);
+    }
+
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_WARLOCK:
+        case DRUID_BEAR_FORM:
+        case DRUID_CAT_FORM:
+        case DRUID_MOONKIN_FORM:
+        case DRUID_TREE_FORM:
+        case DRUID_TRAVEL_FORM:
+        case DRUID_AQUATIC_FORM:
+        //case DRUID_FLIGHT_FORM:
+        case BOT_CLASS_BM:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+            break;
+
+        default:
+            TC_LOG_ERROR("entities.player", "minion_ai: *etStats():Init - unknown bot class %u, real class: %u, _botclass: %u", myclass, GetPlayerClass(), _botclass);
+            break;
+    }
+
+    float value;
+    float tempval;
+    float ap_mod = 1.0f, armor_mod = 1.0f;
+
+    //DAMAGE PHYSICAL
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        float weap_damage_base_min = _getBotStat(i, BOT_STAT_MOD_DAMAGE_MIN);
+        float weap_damage_base_max = _getBotStat(i, BOT_STAT_MOD_DAMAGE_MAX);
+        me->SetBaseWeaponDamage(WeaponAttackType(BASE_ATTACK + i), MINDAMAGE, std::max<float>(weap_damage_base_min, 1.f));
+        me->SetBaseWeaponDamage(WeaponAttackType(BASE_ATTACK + i), MAXDAMAGE, std::max<float>(weap_damage_base_max, 1.f));
+    }
+
+    //Update Attack Time on main hand for shapeshifters
+    //do not add me->GetShapeshiftForm() check here, need to change attack time after shapeshift removal too
+    if (_botclass == BOT_CLASS_DRUID && RespectEquipsAttackTime())
+    {
+        uint32 delay;
+        SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(me->GetShapeshiftForm());
+        if (!ssEntry || !ssEntry->CombatRoundTime)
+            delay = _equips[BOT_SLOT_MAINHAND] ? _equips[BOT_SLOT_MAINHAND]->GetTemplate()->Delay : me->GetCreatureTemplate()->BaseAttackTime;
+        else
+            delay = ssEntry->CombatRoundTime;
+
+        me->SetAttackTime(BASE_ATTACK, delay);
+    }
+
+    float atpower = float(me->GetLevel() * (/*IAmFree() ? 100 : */3)); //+8000/+240(legit) base ap at 80
+    atpower += _getTotalBotStat(BOT_STAT_MOD_ATTACK_POWER);
+
+    float strmult, agimult;
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_DRUID:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_SHAMAN:
+            strmult = 1.f; agimult = 1.f; break;
+        case BOT_CLASS_HUNTER:
+            strmult = 0.5f; agimult = 1.f;break; //until attack power is separated
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+            strmult = 1.f; agimult = 0.f; break;
+        case DRUID_CAT_FORM:
+            strmult = 2.f; agimult = 1.f; break;
+        case DRUID_BEAR_FORM:
+        case DRUID_MOONKIN_FORM:
+        case DRUID_TREE_FORM:
+        case DRUID_TRAVEL_FORM:
+        case DRUID_AQUATIC_FORM:
+        //case DRUID_FLIGHT_FORM:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_BM:
+            strmult = 0.f; agimult = 9.f; break;
+        case BOT_CLASS_SPHYNX:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_ARCHMAGE:
+            strmult = 0.f; agimult = 0.f; break;
+        case BOT_CLASS_DREADLORD:
+            strmult = 8.f; agimult = 0.f; break;
+        case BOT_CLASS_SPELLBREAKER:
+            strmult = 5.f; agimult = 0.f; break;
+        case BOT_CLASS_DARK_RANGER:
+            strmult = 0.f; agimult = 5.f; break;
+        default:
+            TC_LOG_ERROR("entities.player", "_MeleeDamageUpdate(): NIY myclass %u!", uint32(myclass));
+            strmult = 0.f; agimult = 0.f; break;
+    }
+
+    atpower += (strmult != 0x0) ? strmult * _getTotalBotStat(BOT_STAT_MOD_STRENGTH) : 0.f;
+    atpower += (agimult != 0x0) ? agimult * _getTotalBotStat(BOT_STAT_MOD_AGILITY) : 0.f;
+
+    //hunter Expose Weakness checked
+    Unit::AuraEffectList const& mAPbyStat = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT);
+    for (Unit::AuraEffectList::const_iterator i = mAPbyStat.begin(); i != mAPbyStat.end(); ++i)
+        atpower += CalculatePct(me->GetStat(Stats((*i)->GetMiscValue())), (*i)->GetAmount());
+
+    atpower += me->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+
+    //Unit::AuraEffectList const& mAPbyArmor = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+    //for (Unit::AuraEffectList::const_iterator iter = mAPbyArmor.begin(); iter != mAPbyArmor.end(); ++iter)
+    //    atpower += int32(me->GetArmor() / (*iter)->GetAmount());
+
+    //Handle mods
+    if (_botclass == BOT_CLASS_DRUID)
+    {
+        //Heart of the Wild part 3
+        if (mylevel >= 35 && myclass == DRUID_CAT_FORM && _spec == BOT_SPEC_DRUID_FERAL)
+            ap_mod *= 1.1f;
+        //Protector of the Pack part 2
+        if (mylevel >= 45 && myclass == DRUID_BEAR_FORM && _spec == BOT_SPEC_DRUID_FERAL)
+            ap_mod *= 1.06f;
+    }
+    if (_botclass == BOT_CLASS_ROGUE)
+    {
+        //Deadliness
+        if (mylevel >= 35 && _spec == BOT_SPEC_ROGUE_SUBTLETY)
+            ap_mod *= 1.1f;
+        //Savage Combat
+        if (mylevel >= 50 && _spec == BOT_SPEC_ROGUE_COMBAT)
+            ap_mod *= 1.04f;
+    }
+    //from stats mods
+    if (myclass == DRUID_BEAR_FORM || myclass == DRUID_CAT_FORM)
+    {
+        atpower += _getTotalBotStat(BOT_STAT_MOD_FERAL_ATTACK_POWER);
+        //Predatory Strikes
+        if (me->GetLevel() >= 25)
+        {
+            uint8 slot = BOT_SLOT_MAINHAND;
+            atpower += 1.5f * me->GetLevel();
+            atpower += 0.2f * (
+                _getBotStat(slot, BOT_STAT_MOD_FERAL_ATTACK_POWER)
+                + _getBotStat(slot, BOT_STAT_MOD_ATTACK_POWER)
+                //+ _getBotStat(slot, BOT_STAT_MOD_RANGED_ATTACK_POWER)
+                );
+        }
+    }
+    if (_botclass == BOT_CLASS_HUNTER)
+    {
+        //Careful Aim
+        if (me->GetLevel() >= 15)
+            atpower += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        //Hunter vs. Wild
+        if (me->GetLevel() >= 30 && _spec == BOT_SPEC_HUNTER_SURVIVAL)
+            atpower += 0.3f * _getTotalBotStat(BOT_STAT_MOD_STAMINA);
+    }
+    if (_botclass == BOT_CLASS_SHAMAN)
+    {
+        //Mental Dexterity
+        if (me->GetLevel() >= 30 && _spec == BOT_SPEC_SHAMAN_ENHANCEMENT)
+            atpower += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+    }
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+    {
+        atpower += 2.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        if (me->GetLevel() >= 60)
+            ap_mod *= 1.15f;
+    }
+
+    atpower *= ap_mod;
+    me->SetStatFlatModifier(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+
+    me->UpdateAttackPowerAndDamage();
+    if (_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_PRIEST || _botclass == BOT_CLASS_WARLOCK ||
+        _botclass == BOT_CLASS_DARK_RANGER)
+    {
+        atpower += _getTotalBotStat(BOT_STAT_MOD_RANGED_ATTACK_POWER) * ap_mod;
+        me->SetStatFlatModifier(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+
+    //ARMOR
+    //value = IAmFree() ? 0 : me->GetLevel() * 10; //0/800 at 80
+    value = 2.f * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+    value += _getTotalBotStat(BOT_STAT_MOD_ARMOR);
+
+    if (mylevel >= 10)
+    {
+        //Toughness
+        if (mylevel >= 20 && (_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PALADIN || _botclass == BOT_CLASS_DEATH_KNIGHT))
+            armor_mod += 0.1f;
+        //Frost Presence
+        if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+            armor_mod += 0.6f;
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Thick Hide
+            if (mylevel >= 15)
+                armor_mod += 0.1f;
+            //Survival of the Fittest
+            if (myclass == DRUID_BEAR_FORM && _spec == BOT_SPEC_DRUID_FERAL)
+                armor_mod += 0.33f + (me->GetShapeshiftForm() == FORM_BEAR ? 1.8 : 3.7f);
+            //Moonkin Form innate
+            else if (myclass == DRUID_MOONKIN_FORM && _spec == BOT_SPEC_DRUID_BALANCE)
+                armor_mod += 3.7f;
+            //Improved Tree Form
+            else if (myclass == DRUID_TREE_FORM && _spec == BOT_SPEC_DRUID_RESTORATION)
+                armor_mod += 2.0f;
+            //Improved Barkskin
+            //else if (myclass == DRUID_TRAVEL_FORM || GetBotStance() == BOT_STANCE_NONE)
+            //    armor_mod += 1.6f;
+        }
+        if (_botclass == BOT_CLASS_HUNTER)
+        {
+            //Thick Hide
+            if (mylevel >= 15)
+                armor_mod += 0.1f;
+        }
+        if (_botclass == BOT_CLASS_MAGE)
+        {
+            //Arcane Fortitude
+            if (mylevel >= 15)
+                value += 1.5f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_SPHYNX)
+        {
+            value += 5.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            armor_mod += 0.5f;
+        }
+        if (_botclass == BOT_CLASS_ARCHMAGE)
+        {
+            value += 5.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_DREADLORD)
+        {
+            armor_mod += 0.5f;
+        }
+        if (_botclass == BOT_CLASS_SPELLBREAKER)
+        {
+            armor_mod += -0.3f; // reduce armor so cannot really tank
+        }
+    }
+
+    value *= armor_mod;
+    me->SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor(); //buffs will be processed here
+
+    //RESISTANCES
+    //Do not store resistance bonuses directly lest we want calcs screwed up
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = IAmFree() ? 0 : mylevel;
+        value += _getTotalBotStat(BOT_STAT_MOD_RESIST_HOLY + (i - 1));
+
+        //res bonuses
+        if (_botclass == BOT_CLASS_SPHYNX)
+            value += mylevel * 5; //total 498 at 83
+        if (_botclass == BOT_CLASS_DREADLORD)
+            value += mylevel * 3; //total 332 at 83
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+            value += mylevel * 2; //total 249 at 83
+
+        resistbonus[i-1] = int32(value);
+        //me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    value = 1.0f;
+    tempval = 1.0f;
+
+    //class-specified
+    //Protector of the Pack part 1
+    if (myclass == DRUID_BEAR_FORM && mylevel >= 45)
+    {
+        value -= 0.12f;
+        tempval -= 0.12f;
+    }
+    //Deadened Nerves
+    if (_botclass == BOT_CLASS_ROGUE && mylevel >= 45 && _spec == BOT_SPEC_ROGUE_ASSASINATION)
+    {
+        value -= 0.06f;
+        tempval -= 0.06f;
+    }
+    //Survival Instincts
+    if (_botclass == BOT_CLASS_HUNTER && mylevel >= 15)
+    {
+        value -= 0.04f;
+        tempval -= 0.04f;
+    }
+    //Spell Warding
+    if (_botclass == BOT_CLASS_PRIEST && mylevel >= 15)
+        tempval -= 0.1f;
+    //Elemental Warding
+    if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 15)
+    {
+        value -= 0.06f;
+        tempval -= 0.06f;
+    }
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+    {
+        //Magic Suppression (everything)
+        if (mylevel >= 60 && _spec == BOT_SPEC_DK_UNHOLY)
+            tempval -= 0.06f;
+        //Improved Frost Presence
+        if (mylevel >= 61 && GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE && _spec == BOT_SPEC_DK_FROST)
+        {
+            value -= 0.02f;
+            tempval -= 0.02f;
+        }
+    }
+    if (_botclass == BOT_CLASS_WARLOCK)
+    {
+        //Molten Skin
+        if (mylevel >= 15)
+        {
+            value -= 0.06f;
+            tempval -= 0.06f;
+        }
+        //Master Demonologist part 2, Master Demonologist part 4
+        if (mylevel >= 35 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY && botPet && botPet->IsAlive())
+        {
+            if (GetAIMiscValue(BOTAI_MISC_PET_TYPE) == BOT_PET_VOIDWALKER)
+                value -= 0.1f;
+            else if (GetAIMiscValue(BOTAI_MISC_PET_TYPE) == BOT_PET_FELHUNTER)
+                tempval -= 0.1f;
+        }
+    }
+    //Frozen Core (everything), Prismatic Cloak part 1
+    if (_botclass == BOT_CLASS_MAGE)
+    {
+        if (mylevel >= 30 && _spec == BOT_SPEC_MAGE_FROST)
+            tempval -= 0.06f;
+        else if (mylevel >= 35 && _spec == BOT_SPEC_MAGE_ARCANE)
+        {
+            value -= 0.06f;
+            tempval -= 0.06f;
+        }
+    }
+    if (_botclass == BOT_CLASS_SPHYNX)
+    {
+        value -= 0.33f;
+        tempval -= 0.33f;
+    }
+    if (_botclass == BOT_CLASS_ARCHMAGE)
+    {
+        value -= 0.1f;
+        tempval -= 0.35f;
+    }
+    if (_botclass == BOT_CLASS_DREADLORD)
+    {
+        value -= 0.15f;
+        tempval -= 0.2f;
+    }
+    if (_botclass == BOT_CLASS_SPELLBREAKER)
+    {
+        value -= 0.2f;
+        tempval -= 0.75f;
+    }
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+    {
+        tempval -= 0.35f;
+    }
+
+    dmg_taken_phy = value;
+    dmg_taken_mag = tempval;
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        //unapply old haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    value =  IAmFree() ? std::max<int32>(int32(mylevel) - 50, 0) : 0; // +30%/+0% haste at 80
+
+    //25.5 HR = 1% haste at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_HASTE_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HASTE_MELEE) | (1 << CR_HASTE_RANGED) | (1 << CR_HASTE_SPELL));
+
+    if (_botclass == BOT_CLASS_WARLOCK)
+    {
+        //Spellstone: just emulate the rating bonus
+        uint8 ratingBonus;
+        if      (mylevel >= 78) ratingBonus = 60;
+        else if (mylevel >= 72) ratingBonus = 50;
+        else if (mylevel >= 66) ratingBonus = 40;
+        else if (mylevel >= 60) ratingBonus = 30;
+        else if (mylevel >= 48) ratingBonus = 20;
+        else if (mylevel >= 36) ratingBonus = 10;
+        else                    ratingBonus = 0;
+
+        //Master Conjuror
+        if (mylevel >= 30 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+            ratingBonus *= 4;
+
+        tempval += (float)ratingBonus;
+    }
+
+    value += tempval * ((_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_DARK_RANGER) ?
+        _getRatingMultiplier(CR_HASTE_RANGED) :
+        std::max<float>(_getRatingMultiplier(CR_HASTE_MELEE), _getRatingMultiplier(CR_HASTE_SPELL)));
+
+    //class-specific
+    if (_botclass == BOT_CLASS_HUNTER)
+    {
+        value += 15.f; //innate ranged haste bonus 15% for hunters (still applies to all haste types)
+        //Serpent's Swiftness
+        if (mylevel >= 45 && _spec == BOT_SPEC_HUNTER_BEASTMASTERY)
+            value += 20.f;
+    }
+    if (_botclass == BOT_CLASS_ROGUE)
+    {
+        //Lightning Reflexes part 2
+        if (mylevel >= 25 && _spec == BOT_SPEC_ROGUE_COMBAT)
+            value += 10.f;
+    }
+    if (_botclass == BOT_CLASS_PRIEST)
+    {
+        //Enlightenment part 2
+        if (mylevel >= 35 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+            value += 6.f;
+    }
+    if (_botclass == BOT_CLASS_MAGE)
+    {
+        //Netherwind Presence
+        if (mylevel >= 55 && _spec == BOT_SPEC_MAGE_ARCANE)
+            value += 6.f;
+    }
+    if (_botclass == BOT_CLASS_BM)
+    {
+        //Blademaster haste
+        value += 70.f;
+    }
+    if (_botclass == BOT_CLASS_DREADLORD)
+    {
+        //Dreadlord haste
+        value += 70.f;
+    }
+
+    haste = int32(value);
+
+    if (haste)
+    {
+        //apply new haste (using truncated value - gonna need it for unapply on next SetStats)
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    if (CanMiss())
+    {
+        value = IAmFree() ? mylevel / 8 : 0; // +10%/+0% at 80
+        //32.5 HR = 1% hit at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_HIT_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HIT_MELEE) | (1 << CR_HIT_RANGED) | (1 << CR_HIT_SPELL));
+        value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_HIT_MELEE), _getRatingMultiplier(CR_HIT_SPELL)));
+
+        //class-specific
+        //Precision
+        if (_botclass == BOT_CLASS_ROGUE && mylevel >= 15)
+            value += 5.f;
+        //Enlightened Judgements part 2,3
+        if (_botclass == BOT_CLASS_PALADIN && _spec == BOT_SPEC_PALADIN_HOLY && mylevel >= 55)
+            value += 4.f;
+        //Virulence part 1, Nerves of Cold Steel part 1
+        if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+            value += 3.f;
+        //Dual Wield Specialization
+        if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 40 && me->haveOffhandWeapon())
+            value += 6.f;
+        //Precision
+        if (_botclass == BOT_CLASS_WARRIOR && mylevel >= 30 && _spec == BOT_SPEC_WARRIOR_FURY)
+            value += 3.f;
+        //Focused Aim
+        if (_botclass == BOT_CLASS_HUNTER && mylevel >= 10)
+            value += 3.f;
+        //Shadow Focus part 1
+        if (_botclass == BOT_CLASS_PRIEST && mylevel >= 15)
+            value += 3.f;
+        //Arcane Focus part 1, Precision part 2
+        if (_botclass == BOT_CLASS_MAGE && mylevel >= 10)
+            value += mylevel >= 15 ? 6.f : 3.f;
+        //Suppression
+        if (_botclass == BOT_CLASS_WARLOCK && mylevel >= 10)
+            value += 3.f;
+
+        hit = value;
+    }
+    else
+        hit = 100.0f;
+
+    //ARMOR PENETRATION
+    value = IAmFree() ? 5 + mylevel / 4 : 0; // 25%/0% at 80
+    //? APR = 1% armor ignored at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_ARMOR_PENETRATION_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_ARMOR_PENETRATION));
+    value += tempval * _getRatingMultiplier(CR_ARMOR_PENETRATION);
+
+    //class-specific
+    //Blood Gorged
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT && mylevel >= 64 && _spec == BOT_SPEC_DK_BLOOD)
+        value += 10.f;
+
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+        value += 50.f;
+
+    armor_pen = value;
+
+    //EXPERTISE
+    value = IAmFree() ? mylevel / 2 : 0; // -10%/-0% at 80
+    //~8.0 ER = 1 expertise at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_EXPERTISE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_EXPERTISE));
+    value += tempval * _getRatingMultiplier(CR_EXPERTISE);
+
+    //class-specific
+    //Weapon Expertise
+    if (mylevel >= 35 && _botclass == BOT_CLASS_ROGUE && _spec == BOT_SPEC_ROGUE_COMBAT)
+        value += 10.f;
+    //Combat Expertise
+    if (mylevel >= 45 && _botclass == BOT_CLASS_PALADIN && _spec == BOT_SPEC_PALADIN_PROTECTION)
+        value += 6.f;
+    if (_botclass == BOT_CLASS_WARRIOR)
+    {
+        //Vitality: 6, Strength of Arms: 4
+        if (mylevel >= 45 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+            value += 10.f;
+        else if (mylevel >= 40 && _spec == BOT_SPEC_WARRIOR_ARMS)
+            value += 4.f;
+    }
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+    {
+        //Tundra Stalker, Rage of Rivendare: 5
+        //Veteral of the Third War part 3: 6
+        if (mylevel >= 64 && _spec == BOT_SPEC_DK_FROST)
+            value += 5.f;
+        else if (mylevel >= 64 && _spec == BOT_SPEC_DK_UNHOLY)
+            value += 5.f;
+        else if (mylevel >= 59 && _spec == BOT_SPEC_DK_BLOOD)
+            value += 6.f;
+    }
+    if (_botclass == BOT_CLASS_DREADLORD)
+    {
+        value += 40.f;
+    }
+
+    expertise = value;
+
+    //CRIT
+    if (CanCrit())
+    {
+        value = IAmFree() ? mylevel / 4 : 0; // +20%/+0% at 80
+        tempval = value;
+
+        GtChanceToMeleeCritBaseEntry const* critBaseMelee  = sGtChanceToMeleeCritBaseStore.LookupEntry(GetPlayerClass()-1);
+        GtChanceToMeleeCritEntry const* critRatioMelee = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1);
+        if (critBaseMelee && critRatioMelee)
+            value += (critBaseMelee->Data + _getTotalBotStat(BOT_STAT_MOD_AGILITY) * critRatioMelee->Data) * 100.0f;
+
+        //crit from intellect
+        GtChanceToSpellCritBaseEntry const* critBaseSpell  = sGtChanceToSpellCritBaseStore.LookupEntry(GetPlayerClass()-1);
+        GtChanceToSpellCritEntry const* critRatioSpell = sGtChanceToSpellCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1);
+        if (critBaseSpell && critRatioSpell)
+            tempval += (critBaseSpell->Data + _getTotalBotStat(BOT_STAT_MOD_INTELLECT) * critRatioSpell->Data) * 100.f;
+
+        value = std::max<float>(value, tempval);
+
+        //45 CR = 1% crit at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_CRIT_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_CRIT_MELEE) | (1 << CR_CRIT_RANGED) | (1 << CR_CRIT_SPELL));
+
+        //Molten Armor: 35% spirit to crit rating (+40% double-glyphed + 15% T9P2 bonus)
+        if (_botclass == BOT_CLASS_MAGE && me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RATING_FROM_STAT, SPELLFAMILY_MAGE, 0x40000))
+            tempval += _getTotalBotStat(BOT_STAT_MOD_SPIRIT) * (mylevel >= 80 ? 0.9f : mylevel >= 70 ? 0.75f : 0.55f);
+        //Firestone: just emulate the rating bonus
+        if (_botclass == BOT_CLASS_WARLOCK)
+        {
+            uint8 ratingBonus;
+            if      (mylevel >= 80) ratingBonus = 49;
+            else if (mylevel >= 74) ratingBonus = 42;
+            else if (mylevel >= 66) ratingBonus = 35;
+            else if (mylevel >= 56) ratingBonus = 28;
+            else if (mylevel >= 46) ratingBonus = 21;
+            else if (mylevel >= 36) ratingBonus = 14;
+            else if (mylevel >= 28) ratingBonus = 7;
+            else                    ratingBonus = 0;
+
+            //Master Conjuror
+            if (mylevel >= 30 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                ratingBonus *= 4;
+
+            tempval += (float)ratingBonus;
+        }
+
+        value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_CRIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_CRIT_MELEE), _getRatingMultiplier(CR_CRIT_SPELL)));
+
+        //common crit talents
+        if (mylevel >= 10 &&
+            (_botclass != BOT_CLASS_MAGE && _botclass != BOT_CLASS_PRIEST &&
+            _botclass != BOT_CLASS_DRUID && _botclass != BOT_CLASS_WARLOCK))
+            value += 5.f;
+
+        //class-specific
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Sharpened Claws
+            if (mylevel >= 20 && (myclass == DRUID_CAT_FORM || myclass == DRUID_BEAR_FORM))
+                value += 6.f;
+        }
+        if (_botclass == BOT_CLASS_ROGUE)
+        {
+            //Close Quarters Combat
+            if (mylevel >= 20)
+            {
+                if (Item const* mainhand = _equips[BOT_SLOT_MAINHAND])
+                {
+                    if (mainhand->GetTemplate()->Class == ITEM_CLASS_WEAPON &&
+                        (mainhand->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                        mainhand->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
+                        value += 5.f;
+                }
+            }
+        }
+        if (_botclass == BOT_CLASS_PALADIN)
+        {
+            //Sanctity of Battle part 1
+            if (mylevel >= 25 && _spec == BOT_SPEC_PALADIN_RETRIBUTION)
+                value += 3.f;
+            //Combat Expertise
+            if (mylevel >= 45 && _spec == BOT_SPEC_PALADIN_PROTECTION)
+                value += 6.f;
+        }
+        if (_botclass == BOT_CLASS_HUNTER)
+        {
+            //Killer Instinct
+            if (mylevel >= 30 && _spec == BOT_SPEC_HUNTER_BEASTMASTERY)
+                value += 3.f;
+            //Master Marksman
+            if (mylevel >= 45 && _spec == BOT_SPEC_HUNTER_MARKSMANSHIP)
+                value += 5.f;
+        }
+        if (_botclass == BOT_CLASS_PRIEST)
+        {
+            //Focused Will part 1
+            if (mylevel >= 40 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+                value += 3.f;
+        }
+        if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+        {
+            //Annihilation part 1
+            if (mylevel >= 57)
+                value += 3.f;
+        }
+        if (_botclass == BOT_CLASS_WARLOCK)
+        {
+            //Backlash
+            if (mylevel >= 30)
+                value += 3.f;
+            //Demonic Tactics part 1, part 2 (me)
+            if (mylevel >= 45 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                value += 10.f;
+        }
+        if (_botclass == BOT_CLASS_MAGE)
+        {
+            //Arcane Instability part 2
+            if (mylevel >= 35 && _spec == BOT_SPEC_MAGE_ARCANE)
+                value += 3.f;
+        }
+        if (_botclass == BOT_CLASS_DREADLORD)
+        {
+            value = value * 2.f;
+        }
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+        {
+            value += 20.f;
+        }
+
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            crit = std::min<float>(value, BotMgr::GetBotStatLimitCrit());
+        else
+            crit = value;
+
+        if (crit < 0.0f)
+            crit = 0.0f;
+    }
+    else
+        crit = 0.0f;
+
+    //DEFENSE
+    value = 0.f;
+    tempval = _getTotalBotStat(BOT_STAT_MOD_DEFENSE_SKILL_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+    value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL);
+    value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE);
+    defense = mylevel * 5 + uint32(value); //truncate
+
+    float defbonus = defense - mylevel * 5; //difference
+
+    //PARRY
+    if (CanParry())
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : 0); // +10%/+0% at 80
+
+        if (mylevel >= 10)
+        {
+            //67 PR = 1% parry at 80
+            float tempval = _getTotalBotStat(BOT_STAT_MOD_PARRY_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_PARRY));
+
+            //Forceful Deflection: 25% of strength goes to parry rating
+            if (_botclass == BOT_CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+                tempval += _getTotalBotStat(BOT_STAT_MOD_STRENGTH) * 0.25f;
+
+            value += tempval * _getRatingMultiplier(CR_PARRY);
+            //125 DR = 1% block/parry/dodge at 80
+            value += defbonus * 0.04f;
+        }
+
+        //Deflection (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_PALADIN) && mylevel >= 10)
+            value += 5.0f;
+        if (_botclass == BOT_CLASS_HUNTER && mylevel >= 20)
+            value += 3.f;
+
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            parry = std::min<float>(value, BotMgr::GetBotStatLimitParry());
+        else
+            parry = value;
+
+        if (parry < 0.0f)
+            parry = 0.0f;
+    }
+    else
+        parry = 0.0f;
+
+    //DODGE
+    if (CanDodge())
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : 0); // +10%/+0% at 80
+
+        if (GtChanceToMeleeCritEntry  const* dodgeRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += _getTotalBotStat(BOT_STAT_MOD_AGILITY) * dodgeRatio->Data * 100.0f;
+
+        if (mylevel >= 10)
+        {
+            //53 DR = 1% dodge at 80
+            float tempval = _getTotalBotStat(BOT_STAT_MOD_DODGE_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DODGE));
+            value += tempval * _getRatingMultiplier(CR_DODGE);
+            //125 DR = 1% block/parry/dodge at 80
+            value += defbonus * 0.04f;
+        }
+
+        //evasion, anticipation (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_PALADIN ||
+            _botclass == BOT_CLASS_DEATH_KNIGHT || _botclass == BOT_CLASS_SHAMAN) && mylevel >= 15)
+            value += 5.0f;
+
+        //class-specific
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Feral Swiftness
+            if (mylevel >= 20 && (myclass == DRUID_CAT_FORM || myclass == DRUID_BEAR_FORM))
+                value += 4.f;
+        }
+
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+        {
+            //base dodge 30%
+            value += 30.f;
+        }
+
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            dodge = std::min<float>(value, BotMgr::GetBotStatLimitDodge());
+        else
+            dodge = value;
+
+        if (dodge < 0.0f)
+            dodge = 0.0f;
+    }
+    else
+        dodge = 0.0f;
+
+    //BLOCK
+    if (IsBlockingClass(_botclass))
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 4 : 0); // +20%/+0% at 80
+
+        //16.5 BR = 1% block at 80
+        float tempval = _getTotalBotStat(BOT_STAT_MOD_BLOCK_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_BLOCK));
+        value += tempval * _getRatingMultiplier(CR_BLOCK);
+        //125 DR = 1% block/parry/dodge at 80
+        value += defbonus * 0.04f;
+
+        //base block chance is capped at 75%
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            block = std::min<float>(value, BotMgr::GetBotStatLimitBlock());
+        else
+            block = std::min<float>(value, 75.0f);
+
+        if (block < 0.0f)
+            block = 0.0f;
+
+        //Spellbreaker wears tall shield so should always block
+        if (_botclass == BOT_CLASS_SPELLBREAKER)
+            block += 90.f;
+
+        //BLOCK VALUE
+        //2 str = 1 block value
+        value = 0.5f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH) - 10.f;
+        value += _getTotalBotStat(BOT_STAT_MOD_BLOCK_VALUE);
+
+        //Shield Mastery part 1
+        if (_botclass == BOT_CLASS_WARRIOR && mylevel >= 20 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+            value *= 1.3f;
+        //Redoubt handled in passives
+        //if (mylevel >= 45 && _botclass == BOT_CLASS_PALADIN)
+        //    value *= 1.3f;
+
+        blockvalue = std::max<float>(int32(value), 1.f);
+    }
+    //else
+    //{
+    //    block = 0.0f;
+    //    blockvalue = 0;
+    //}
+
+    //MANA
+    _OnManaUpdate();
+
+    if (IsCastingClass(_botclass))
+    {
+        //SPELL PENETRATION
+        value = IAmFree() ? mylevel : 0; // 80/0 at 80
+        //~1 SPPR = 1 spell penetration
+        value += _getTotalBotStat(BOT_STAT_MOD_SPELL_PENETRATION);
+        spellpen = uint32(value);
+
+        //SPELL POWER
+        value = /*IAmFree() ? std::max<int32>((int8(mylevel) - 30) * 40, 0) : */0; // +2000/+0 spp at 80
+        value += _getTotalBotStat(BOT_STAT_MOD_SPELL_POWER);
+
+        //class-specified mods
+        if (_botclass == BOT_CLASS_PALADIN && mylevel >= 50)
+        {
+            //Touched by the Light - 60% of strength to spell power
+            if (_spec == BOT_SPEC_PALADIN_PROTECTION)
+                value += 0.6f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+            //Sheath of Light - 30% attack power to spell power
+            if (_spec == BOT_SPEC_PALADIN_RETRIBUTION)
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Holy Guidance - 20% Intellect to spell power
+            if (_spec == BOT_SPEC_PALADIN_HOLY)
+                value += 0.2f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_PRIEST && mylevel >= 30)
+        {
+            float totalSpi = _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            //Spiritual Guidance - 25% Spirit to spell power
+            if (_spec == BOT_SPEC_PRIEST_HOLY)
+                value += 0.25f * totalSpi;
+            //Twisted Faith - 20% Spirit to spell power
+            else if (mylevel >= 55 && _spec == BOT_SPEC_PRIEST_SHADOW)
+                value += 0.2f * totalSpi;
+            //Shadowy Insight (Glyph of Shadow)
+            if (mylevel >= 30 &&
+                me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_GENERIC, 1499, 0))
+                value += 0.3f * totalSpi;
+        }
+        if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 50 && _spec == BOT_SPEC_SHAMAN_ENHANCEMENT)
+        {
+            //Mental Quickness - 30% attack power to spell power (only enhancement)
+            value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+        }
+        if (_botclass == BOT_CLASS_DRUID && mylevel >= 30)
+        {
+            //Nurturing Instinct - 70% Agility to spell power
+            value += 0.7f * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+            //Lunar Guidance - 12% Intellect to spell power
+            value += 0.12f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            //Improved Moonkin Form - 30% Spirit to spell power
+            if (mylevel >= 40 && myclass == DRUID_MOONKIN_FORM)
+                value += 0.3f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            //Improved Tree (of Life) Form - 15% Spirit to spell power
+            if (mylevel >= 50 && myclass == DRUID_TREE_FORM)
+                value += 0.15f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+        }
+        if (_botclass == BOT_CLASS_MAGE && mylevel >= 45 && _spec == BOT_SPEC_MAGE_ARCANE)
+        {
+            //Mind Mastery - 15% Intellect to spell power
+            value += 0.15f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_WARLOCK)
+        {
+            if (me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 0x0, 0x20000000, 0x0))
+            {
+                //Fel Armor + Demonic Aegis - 39% Spirit to spell power
+                value += 0.39f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            }
+            //Demonic Knowledge
+            if (botPet && botPet->IsAlive() && mylevel >= 40 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                value += 0.12f * botPet->GetStat(STAT_STAMINA) + botPet->GetStat(STAT_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_SPHYNX)
+        {
+            //bonus from attack power (for tank) or intellect (ranged)
+            value += 2.0f *_getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            value += 0.5f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //from wands
+            for (uint8 i = BOT_SLOT_MAINHAND; i <= BOT_SLOT_OFFHAND; ++i)
+                if (ItemTemplate const* proto = _equips[i] ? _equips[i]->GetTemplate() : nullptr)
+                    value += proto->getDPS() * 1.35f;
+        }
+        if (_botclass == BOT_CLASS_ARCHMAGE)
+        {
+            //bonus from intellect
+            value += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_DREADLORD)
+        {
+            //bonus from strength
+            value += 2.f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+        }
+        if (_botclass == BOT_CLASS_SPELLBREAKER)
+        {
+            //bonus from strength
+            value += 2.f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+        }
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+        {
+            //bonus from intellect
+            value += 0.5f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+
+        spellpower = uint32(value);
+    }
+    //else
+    //{
+    //    spellpower = 0;
+    //}
+
+    //if init or levelup
+    if (force)
+    {
+        me->SetFullHealth();
+        if (_botclass != BOT_CLASS_SPHYNX)
+            me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    if (botPet)
+        botPet->GetBotPetAI()->SetShouldUpdateStats();
+}
+
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                break;
+            }
+            SetBotCommandState(BOT_COMMAND_STAY);
+            //BotWhisper("Standing Still.", player);
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                break;
+            }
+            if (me->IsNonMeleeSpellCast(true))
+                me->InterruptNonMeleeSpells(true);
+            SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+            //BotWhisper("Following!", player);
+            break;
+        case TEXT_EMOTE_TICKLE:
+        {
+            if (master != player)
+                break;
+
+            if ((me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED) || me->HasUnitState(UNIT_STATE_STUNNED)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_STUN))
+            {
+                me->ClearUnitState(UNIT_STATE_STUNNED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+            }
+            if ((me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED) || me->HasUnitState(UNIT_STATE_CONFUSED)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_CONFUSE))
+            {
+                me->ClearUnitState(UNIT_STATE_CONFUSED);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
+            }
+            if ((me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING) || me->HasUnitState(UNIT_STATE_FLEEING)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_FEAR))
+            {
+                me->ClearUnitState(UNIT_STATE_FLEEING);
+                me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_FLEEING);
+            }
+            std::ostringstream msg;
+            msg << "%s (bot) pulls "
+                << (me->GetGender() == GENDER_MALE ? "himself" : me->GetGender() == GENDER_FEMALE ? "herself" : "itself")
+                << " together.";
+            me->TextEmote(msg.str().c_str());
+            break;
+        }
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == master || unit == me || unit == botPet) return true;
+
+    if (IAmFree())
+    {
+        if (me->GetFaction() == 14 || unit->GetFaction() == 14)
+            return false;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) ||
+            unit->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return false;
+
+        return
+            (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->IsPet() || unit->ToCreature()->IsNPCBotOrPet()) &&
+            (unit->GetFaction() == me->GetFaction() ||
+            (me->GetReactionTo(unit) >= REP_FRIENDLY && unit->GetReactionTo(me) >= REP_FRIENDLY));
+    }
+
+    //cheap check
+    if (Group const* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if ((BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i]) &&
+               !((BotMgr::GetTankTargetIconFlags() | BotMgr::GetDPSTargetIconFlags()) & GroupIconsFlags[i]))
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                    if (guid == unit->GetGUID())
+                        return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        ObjectGuid ownerGuid = unit->GetOwnerGUID();
+        //controlled by master
+        if (ownerGuid == master->GetGUID())
+            return true;
+        //npcbot/npcbot's pet case
+        if (cre->GetBotOwner() == master)
+            return true;
+        if (ownerGuid && master->GetBotMgr()->GetBot(ownerGuid))
+            return true;
+        //controlled by group member
+        //pets, minions, guardians etc.
+        //bot pets too
+        if (ownerGuid)
+            if (Group const* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/removes/reapplies aura stacks
+void bot_ai::RefreshAura(uint32 spellId, int8 count, Unit* target) const
+{
+    if (count < 0 || count > 1)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): count is out of bounds (%i) for bot %s (botclass: %u, entry: %u)",
+            int32(count), me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return;
+    }
+
+    if (!spellId)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): spellId is 0 for bot %s (botclass: %u, entry: %u)",
+            me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return;
+    }
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return;
+    }
+
+    if (!target)
+        target = me;
+
+    target->RemoveAurasDueToSpell(spellId);
+
+    //for (int8 i = 0; i < count; ++i)
+    if (count)
+        target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+}
+
+bool bot_ai::CanBotAttack(Unit const* target, int8 byspell) const
+{
+    if (!target)
+        return false;
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return false;
+    if (!BotMgr::IsPvPEnabled() && !IAmFree() && target->IsControlledByPlayer())
+        return false;
+    if (me->GetFaction() == 35 && IAmFree() && target->GetTypeId() == TYPEID_UNIT && target->GetVictim() != me)
+        return false;
+    if ((target->GetFaction() == 35 || target->GetFaction() == me->GetFaction()) && me->GetFaction() != 14)
+        return false;
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+
+    SpellSchoolMask mainMask;
+    if (!byspell)
+        mainMask = SPELL_SCHOOL_MASK_NORMAL;
+    else
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_PRIEST:      mainMask = SPELL_SCHOOL_MASK_SHADOW;                                                                break;
+            case BOT_CLASS_SHAMAN:      mainMask = Rand() > 50 && me->GetLevel() >= 70 ? SPELL_SCHOOL_MASK_FIRE : SPELL_SCHOOL_MASK_NATURE; break;
+            case BOT_CLASS_MAGE:        mainMask = Rand() > 50 ? SPELL_SCHOOL_MASK_FIRE : SPELL_SCHOOL_MASK_FROST;                          break;
+            case BOT_CLASS_WARLOCK:     mainMask = Rand() > 50 ? SPELL_SCHOOL_MASK_SHADOW : SPELL_SCHOOL_MASK_FIRE;                         break;
+            case BOT_CLASS_DRUID:       mainMask = Rand() > 50 ? SPELL_SCHOOL_MASK_ARCANE : SPELL_SCHOOL_MASK_NATURE;                       break;
+            case BOT_CLASS_SPHYNX:      mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_ARCHMAGE:    mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_DREADLORD:   mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_SPELLBREAKER:mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_DARK_RANGER: mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            default:                    mainMask = SPELL_SCHOOL_MASK_NORMAL;                                                                break;
+        }
+    }
+
+    return
+       (target->IsAlive() && target->IsVisible() && me->IsValidAttackTarget(target) &&
+        target->isTargetableForAttack() && !IsInBotParty(target) &&
+       ((me->CanSeeOrDetect(target) && target->InSamePhase(me)) || CanSeeEveryone()) &&
+       (!master->IsAlive() || target->IsControlledByPlayer() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        (target->IsHostileTo(master) || target->IsHostileTo(me) ||//if master is controlled
+        (target->GetReactionTo(me) < REP_FRIENDLY && (master->IsInCombat() || target->IsInCombat()))) &&
+        (byspell == -1 || !target->IsTotem()) &&
+        (byspell == -1 || !mainMask || !target->IsImmunedToDamage(mainMask)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//All code above 'x = _getTarget() call must not dereference opponent since it can be invalid
+Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //if (_evadeMode) //IAmFree() case only
+    //    return nullptr;
+
+    Unit* mytar = me->GetVictim();
+
+    //check if no need to change target
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s", me->GetName().c_str());
+
+    if (mytar && me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+        return mytar;
+
+    Group const* gr = !IAmFree() ? master->GetGroup() : NULL;
+
+    if (gr && IsTank())
+    {
+        Unit* tankTar = NULL;
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (BotMgr::GetTankTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid && mytar->GetVictim() == me)
+                    {
+                        //TC_LOG_ERROR("entities.unit", "_getTarget: %s continues %s", me->GetName().c_str(), mytar->GetName().c_str());
+                        return mytar;
+                    }
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack() && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: %s found new tanking icon target %s", me->GetName().c_str(), unit->GetName().c_str());
+                            Unit* tempTar = tankTar ? tankTar : unit;
+                            tankTar = unit;
+                            Unit* tVic = unit->GetVictim();
+                            if (!tVic || (tVic != me && tVic->GetVictim() == unit && IsTank(tVic) && IsInBotParty(tVic)))
+                            {
+                                //TC_LOG_ERROR("entities.unit", "_getTarget: %s skipped %s (%s)", me->GetName().c_str(), unit->GetName().c_str(), tVic->GetName().c_str());
+                                tankTar = tempTar;
+                                continue;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (tankTar)
+        {
+            //TC_LOG_ERROR("entities.unit", "_getTarget: %s returning %s", me->GetName().c_str(), tankTar->GetName().c_str());
+            return tankTar;
+        }
+    }
+    if (gr)
+    {
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (BotMgr::GetDPSTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid)
+                        return mytar;
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack() && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: found dps icon target %s", unit->GetName().c_str());
+                            return unit;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    Unit* u = master->GetVictim();
+//Disabled due to a bug:
+//when spell cast is finished target is immideately put in combat which makes bots attack immediately
+//caster must be put in combat at spell launch
+//but target must be put in combat at spell hit
+/*
+    if (!u && !IAmFree() && master->IsInCombat() && Rand() < 15)
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+        {
+            if (Spell const* spell = master->GetCurrentSpell(CurrentSpellTypes(i)))
+            {
+                //if (spell->getState() == SPELL_STATE_FINISHED)
+                //    continue;
+
+                if (mytar && spell->m_targets.GetUnitTargetGUID() == mytar->GetGUID())
+                {
+                    u = mytar;
+                    break;
+                }
+
+                //direct damaging spells
+                if (!spell->GetSpellInfo()->IsPositive() &&
+                    (spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_WEAPON_DAMAGE) ||
+                    spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+                    spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL)))
+                {
+                    Unit* victim = ObjectAccessor::GetUnit(*me, spell->m_targets.GetUnitTargetGUID());
+                    if (victim && victim->IsInCombat())
+                    {
+                        u = victim;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+*/
+    if (u && u == mytar && !IAmFree() && u->GetTypeId() == TYPEID_PLAYER && CanBotAttack(u, byspell))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if ((!u || IAmFree()) && master->IsAlive() && (me->GetDistance(master) > foldist ||
+        (IAmFree() && mytar && me->GetDistance(mytar) > followdist) ||
+        (mytar && master->GetDistance(mytar) > followdist / 2 && !mytar->IsWithinLOSInMap(me)) ||
+        (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away or not in LoS", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return nullptr;
+    }
+
+    if (u && !IAmFree() && (master->IsInCombat() || u->IsInCombat())/* && !InDuel(u)*/ && !IsInBotParty(u) && (BotMgr::IsPvPEnabled() || !u->IsControlledByPlayer()))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && CanBotAttack(mytar, byspell) &&/* !InDuel(mytar) &&*/
+        !(mytar->GetVictim() != nullptr && IsTank() && IsTank(mytar->GetVictim())))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && !HasBotCommandState(BOT_COMMAND_MASK_UNCHASE))
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return nullptr; //do not bother
+
+    //check group
+    if (!IAmFree())
+    {
+        if (!gr)
+        {
+            Creature const* bot;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                bot = itr->second;
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                if (IsTank() && IsTank(bot)) continue;
+                u = bot->GetVictim();
+                if (u && (bot->IsInCombat() || u->IsInCombat()) &&
+                    (!master->IsAlive() || master->GetDistance(u) < foldist) &&
+                    CanBotAttack(u, byspell))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+        else
+        {
+            Player const* pl;
+            Creature const* bot;
+            for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+            {
+                pl = ref->GetSource();
+                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                if (IsTank() && IsTank(pl)) continue;
+                u = pl->GetVictim();
+                if (u && pl != master &&
+                    (pl->IsInCombat() || u->IsInCombat()) &&
+                    (!master->IsAlive() || master->GetDistance(u) < foldist) &&
+                    CanBotAttack(u, byspell))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                if (!pl->HaveBot()) continue;
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    bot = it->second;
+                    if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                    if (!bot->IsInWorld()) continue;
+                    if (me->GetMap() != bot->FindMap()) continue;
+                    if (IsTank() && IsTank(bot)) continue;
+                    u = bot->GetVictim();
+                    if (u && (bot->IsInCombat() || u->IsInCombat()) &&
+                        (!master->IsAlive() || master->GetDistance(u) < foldist) &&
+                        CanBotAttack(u, byspell))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                        return u;
+                    }
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = nullptr;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            Cell::VisitAllObjects(master, searcher, maxdist);
+            //me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+        reset = true;
+
+    //Allow free bots to ignore temp invulnerabilities if no other target is present
+    if (IAmFree() && t == nullptr)
+        t = mytar;
+
+    //if (t)
+    //    TC_LOG_ERROR("entities.player", "bot %s has found new target %s", me->GetName().c_str(), t->GetName().c_str());
+
+    return t;
+}
+//'CanAttack' function
+//Only called in class ai UpdateAI function
+bool bot_ai::CheckAttackTarget()
+{
+    if (IsDuringTeleport()/* || _evadeMode*/)
+    {
+        //me->AttackStop(); //already in CombatStop()
+        me->CombatStop(true);
+        return false;
+    }
+
+    if (IAmFree() && Feasting())
+        return false;
+
+    bool ranged = HasRole(BOT_ROLE_RANGED);
+    bool byspell = false;
+    bool reset = false;
+
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            switch (GetBotStance())
+            {
+                case DRUID_CAT_FORM:
+                case DRUID_BEAR_FORM:
+                    break;
+                case DRUID_TREE_FORM:
+                case DRUID_TRAVEL_FORM:
+                case DRUID_AQUATIC_FORM:
+                //case DRUID_FLIGHT_FORM:
+                    ranged = true;
+                    break;
+                case DRUID_MOONKIN_FORM:
+                    byspell = true;
+                    break;
+                case BOT_STANCE_NONE:
+                    byspell = ranged && HasRole(BOT_ROLE_DPS);
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "bot_ai::CheckAttackTarget(): druid has NYI bot stance %u", uint32(GetBotStance()));
+                    break;
+            }
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            byspell = ranged && HasRole(BOT_ROLE_DPS);
+            break;
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+            byspell = HasRole(BOT_ROLE_DPS);
+            break;
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_BM:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown bot class %u", _botclass);
+            return false;
+    }
+
+    opponent = _getTarget(byspell, ranged, reset);
+
+    if (!opponent)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s lost target", me->GetName().c_str());
+        if (me->GetVictim() || me->IsInCombat()/* || !me->GetThreatManager().isThreatListEmpty()*/)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s Evades", me->GetName().c_str());
+            if (me->GetVictim())
+                me->AttackStop();
+            else if (me->IsInCombat())
+                Evade();
+        }
+
+        return false;
+    }
+
+    //boss engage phase // CanHaveThreatList checks for typeid == UNIT
+    if (!IsTank() && opponent != me->GetVictim() && opponent->GetVictim() && opponent->CanHaveThreatList() &&
+        opponent->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS && me->GetMap()->IsRaid())
+    {
+        uint32 threat = uint32(opponent->ToCreature()->GetThreatManager().GetThreat(opponent->GetVictim()));
+        if (threat < std::min<uint32>(50000, opponent->GetVictim()->GetMaxHealth() / 2))
+            return false;
+    }
+
+    if (reset)
+        SetBotCommandState(BOT_COMMAND_COMBATRESET);//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+
+    return true;
+}
+//POSITION
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    /*if (IAmFree())
+        origRange = sWorld->GetMaxVisibleDistanceOnContinents();
+    else */if (!master->IsAlive())
+        origRange = sWorld->GetMaxVisibleDistanceOnContinents();
+    else if (me->HasAuraType(SPELL_AURA_MOUNTED))
+        origRange *= 0.2f;
+    else if (ranged)
+        origRange *= 1.25f;
+
+    return origRange;
+}
+//Ranged attack position
+void bot_ai::CalculateAttackPos(Unit const* target, Position& pos) const
+{
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    uint8 rangeMode = IAmFree() ? uint8(BOT_ATTACK_RANGE_LONG) : master->GetBotMgr()->GetBotAttackRangeMode();
+    uint8 exactRange = rangeMode != BOT_ATTACK_RANGE_EXACT || IAmFree() ? 255 : master->GetBotMgr()->GetBotExactAttackRange();
+    float x(0),y(0),z(0),
+        dist = (rangeMode == BOT_ATTACK_RANGE_EXACT) ? exactRange :
+        followdist >= 40 ? followdist :
+        _botclass == BOT_CLASS_HUNTER ?
+        8 + urand(followdist/2, followdist/2 + 5) :/*23-33 at 40, 18-28 at 30*/
+        5 + urand(followdist/3, followdist/3 + 5)/*18-23 at 40, 15-20 at 30*/,
+        angle = target->GetAbsoluteAngle(me);
+    bool boss = target->GetTypeId() == TYPEID_UNIT &&
+        (target->ToCreature()->isWorldBoss() || target->ToCreature()->IsDungeonBoss() || target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS);
+    //most ranged classes have some sort of 20yd spell
+    if (rangeMode != BOT_ATTACK_RANGE_EXACT)
+        dist = std::min<float>(dist, GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG) - 4.f);
+    if (target->HasInArc(M_PI/2, me) && (target->m_movementInfo.GetMovementFlags() & MOVEMENTFLAG_FORWARD))
+        dist = std::min<float>(dist + 10, 30);
+
+    float clockwise = (me->GetEntry() % 2) ? 1.f : -1.f;
+    float angleDelta1 = ((IsTank(master) && !IsTank(me)) ? frand(M_PI*0.40f, M_PI*0.60f) : frand(0.0f, M_PI*0.15f)) * clockwise;
+    float angleDelta2 = frand(0.0f, M_PI*0.08f) * clockwise;
+    if (boss && IsTank())
+        angle += M_PI*(IsMelee() ? 0.5f : 0.33f);
+
+    for (uint8 i = 0; i < 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, dist, Position::NormalizeOrientation(angle));
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 38.f ? 38.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (!toofaraway && !outoflos)
+            break;
+
+        if (toofaraway)
+        {
+            angle = target->GetAbsoluteAngle(master);
+            if (i >= 3)
+                angle += angleDelta1;
+            if (i >= 1 && i <= 3)
+                dist = std::max<float>(0.f, dist - 5.f);
+        }
+        if (outoflos)
+        {
+            if (rangeMode != BOT_ATTACK_RANGE_EXACT)
+                dist *= i >= 3 ? 0.1f : 0.33f;
+            if (i >= 4 && IAmFree())
+                angle += angleDelta2;
+        }
+    }
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (HasBotCommandState(BOT_COMMAND_STAY))
+        return;
+    if (CCed(me, true) || JumpingOrFalling())
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || (me->isMoving()/* && Rand() > 50*/)) && !force)
+        return;
+    if (IsCasting())
+        return;
+    if (IsShootingWand() && newtarget->GetVictim() == me)
+        return;
+    if (UpdateImpossibleChase(newtarget))
+        return;
+
+    if (!IAmFree() && master->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+        master->GetBotMgr()->GetBotExactAttackRange() == 0)
+    {
+        attackpos.m_positionX = newtarget->GetPositionX() - frand(0.5f, 1.5f) * std::cos(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionY = newtarget->GetPositionY() - frand(0.5f, 1.5f) * std::sin(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionZ = newtarget->GetPositionZ();
+        if (me->GetExactDist2d(&attackpos) > 3.5f)
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+        return;
+    }
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    if (HasRole(BOT_ROLE_RANGED))
+    {
+        //do not allow constant runaway from player
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3))
+            return;
+
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetExactDist2d(&attackpos) > 4.f || !me->IsWithinLOSInMap(newtarget))
+        {
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+            if (!me->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                me->SetInFront(newtarget);
+        }
+    }
+    else if (!JumpingOrFalling() && ((!me->HasUnitState(UNIT_STATE_CHASE) && !me->isMoving()) || (!me->HasUnitState(UNIT_STATE_CHASE_MOVE) && me->GetDistance(newtarget) > 1.5f)))
+        me->GetMotionMaster()->MoveChase(newtarget);
+
+    if (newtarget != me->GetVictim())
+    {
+        if (!me->Attack(newtarget, !HasRole(BOT_ROLE_RANGED)))
+            me->SetInFront(newtarget);
+    }
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS) && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !me->HasAuraType(SPELL_AURA_MOD_INVISIBILITY) &&
+            !IsShootingWand())
+            DoMeleeAttackIfReady();
+    }
+}
+
+void bot_ai::MoveBehind(Unit const* target) const
+{
+    if (HasBotCommandState(BOT_COMMAND_MASK_UNMOVING)) return;
+    if (HasRole(BOT_ROLE_RANGED) || (IsTank() && target->GetVictim() == me) || CCed(me, true)) return;
+    if (JumpingOrFalling()) return;
+    if (((_botclass == BOT_CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM) ?
+        target->GetVictim() != me || CCed(target) || target->GetTypeId() == TYPEID_PLAYER :
+        target->GetVictim() != me && !CCed(target))      &&
+        target->IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target->HasInArc(M_PI, me))
+    {
+        float x(0),y(0),z(0);
+        target->GetNearPoint(me, x, y, z, me->GetCombatReach(), target->GetAbsoluteAngle(me) + M_PI);
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+        const_cast<bot_ai*>(this)->waitTimer = 500;
+    }
+}
+//MOUNT SUPPORT
+void bot_ai::_updateMountedState()
+{
+    if (IAmFree())
+        return;
+    //if (GetBotCommandState() != COMMAND_FOLLOW)
+    //    return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted() && (_botclass != BOT_CLASS_ARCHMAGE || aura);
+
+    //allow dismount
+    if (!CanMount() && !aura && !mounted)
+        return;
+
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->Movement.Flight = CreatureFlightMovementType::None;
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        me->Dismount();
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING|MOVEMENTFLAG_FALLING_FAR|MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW);
+        me->BotStopMovement();
+        return;
+    }
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+        return;
+
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
+            else
+                mount = mounts.front()->GetId();
+        }
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+            //me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);
+
+            //if (!GetSpell(mount))
+            //    InitSpellMap(mount, true); //learn
+
+            me->BotStopMovement();
+            if (_botclass == BOT_CLASS_DRUID && me->GetShapeshiftForm() != FORM_NONE)
+                const_cast<bot_ai*>(this)->removeShapeshiftForm();
+            if (doCast(me, mount))
+            { }
+
+            //RemoveSpell(mount);
+        }
+    }
+}
+//STANDSTATE
+void bot_ai::_updateStandState() const
+{
+    if (IAmFree())
+    {
+        if (CanSit())
+        {
+            if (_atHome && !_evadeMode && !me->IsInCombat() && !me->isMoving() &&
+                me->IsStandState() && Rand() < 15)
+            {
+                uint16 mapid;
+                Position pos;
+                GetHomePosition(mapid, &pos);
+                if (me->GetExactDist(&pos) < 5 && me->GetOrientation() == pos.GetOrientation())
+                {
+                    if (_botclass == BOT_CLASS_DRUID && me->GetShapeshiftForm() != FORM_NONE)
+                        const_cast<bot_ai*>(this)->removeShapeshiftForm();
+
+                    me->SetStandState(UNIT_STAND_STATE_SIT);
+                }
+            }
+        }
+        else if (me->IsSitState() && !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+
+        return;
+    }
+
+    if ((master->GetStandState() == UNIT_STAND_STATE_STAND || !CanSit()) &&
+        me->GetStandState() == UNIT_STAND_STATE_SIT &&
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if (CanSit() && !me->IsInCombat() && !me->isMoving() &&
+        (master->GetStandState() == UNIT_STAND_STATE_SIT || (me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED)) &&
+        me->GetStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+}
+//RATIONS
+void bot_ai::_updateRations()
+{
+    bool noFeast = me->IsInCombat() || (BotMgr::IsFoodInterruptedByMovement() && me->isMoving()) || me->GetVictim() || CCed(me);
+
+    //check
+    if (IAmFree() || !master->IsSitState())
+    {
+        if (feast_mana)
+        {
+            if (noFeast || me->IsStandState() || me->GetMaxPower(POWER_MANA) <= 1 || me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA))
+            {
+                std::list<uint32> spellIds;
+                Unit::AuraApplicationMap const& aurApps = me->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::const_iterator ci = aurApps.begin(); ci != aurApps.end(); ++ci)
+                    if (ci->second->GetBase()->GetSpellInfo()->GetSpellSpecific() == SPELL_SPECIFIC_DRINK &&
+                        !ci->second->GetBase()->GetSpellInfo()->HasAura(SPELL_AURA_PERIODIC_TRIGGER_SPELL)) //skip buffing food
+                        spellIds.push_back(ci->first);
+                for (std::list<uint32>::const_iterator cit = spellIds.begin(); cit != spellIds.end(); ++cit)
+                    me->RemoveAurasDueToSpell(*cit);
+                feast_mana = false;
+                UpdateMana();
+            }
+        }
+        if (feast_health)
+        {
+            if (noFeast || me->IsStandState() || me->GetHealth() >= me->GetMaxHealth())
+            {
+                std::list<uint32> spellIds;
+                Unit::AuraApplicationMap const& aurApps = me->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::const_iterator ci = aurApps.begin(); ci != aurApps.end(); ++ci)
+                    if (ci->second->GetBase()->GetSpellInfo()->GetSpellSpecific() == SPELL_SPECIFIC_FOOD &&
+                        !ci->second->GetBase()->GetSpellInfo()->HasAura(SPELL_AURA_PERIODIC_TRIGGER_SPELL)) //skip buffing food
+                        spellIds.push_back(ci->first);
+                for (std::list<uint32>::const_iterator cit = spellIds.begin(); cit != spellIds.end(); ++cit)
+                    me->RemoveAurasDueToSpell(*cit);
+                feast_health = false;
+            }
+        }
+    }
+
+    if (noFeast)
+        return;
+
+    //drink
+    if (!feast_mana && me->GetMaxPower(POWER_MANA) > 1 && !me->HasAuraType(SPELL_AURA_MOUNTED) && !me->isMoving() && CanDrink() &&
+        !me->IsInCombat() && !IsCasting() && GetManaPCT(me) < 75 && urand(0, 100) < 20)
+    {
+        //me->SetStandState(UNIT_STAND_STATE_SIT);
+        CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+        me->CastSpell(me, GetRation(true), args);
+    }
+
+    //eat
+    if (!feast_health && !me->HasAuraType(SPELL_AURA_MOUNTED) && !me->isMoving() && CanEat() &&
+        !me->IsInCombat() && !IsCasting() && GetHealthPCT(me) < 80 && urand(0, 100) < 20)
+    {
+        //me->SetStandState(UNIT_STAND_STATE_SIT);
+        CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+        me->CastSpell(me, GetRation(false), args);
+    }
+}
+//Health and Powers regeneration
+//Rage regen is handled inside class AI UpdateAI()
+void bot_ai::Regenerate()
+{
+    regenTimer += lastdiff;
+
+    //every tick
+    if (me->GetPowerType() == POWER_ENERGY)
+        RegenerateEnergy();
+
+    if (regenTimer >= REGEN_CD)
+    {
+        regenTimer -= REGEN_CD;
+        // Regen Health
+        int32 baseRegen = int32(_getTotalBotStat(BOT_STAT_MOD_HEALTH_REGEN));
+        if ((!me->IsInCombat() || me->IsPolymorphed() || CanRegenInCombat() || baseRegen > 0 ||
+            me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) || me->HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT)) &&
+            me->GetHealth() < me->GetMaxHealth())
+        {
+            int32 add = me->IsInCombat() ? 0 : IAmFree() && !me->GetVictim() ? me->GetMaxHealth() / 32 : 5 + me->GetCreateHealth() / 256;
+            if (baseRegen > 0)
+                add += std::max<int32>(baseRegen / 5, 1);
+
+            //cannot eat
+            if (_botclass == BOT_CLASS_SPHYNX)
+                add += me->GetMaxHealth() / 100; //1%
+
+            if (me->IsPolymorphed())
+                add += me->GetMaxHealth() / 6;
+            else if (!me->IsInCombat() || me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+            {
+                if (!me->IsInCombat())
+                {
+                    Unit::AuraEffectList const& mModHealthRegenPct = me->GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
+                    for (Unit::AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
+                        AddPct(add, (*i)->GetAmount());
+
+                    add += me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * REGEN_CD / 5000;
+                }
+                else if (me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+                    ApplyPct(add, me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));
+            }
+
+            add += me->GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
+
+            if (add < 0)
+                add = 0;
+
+            me->ModifyHealth(add);
+        }
+
+        // Regen Mana
+        if (me->GetMaxPower(POWER_MANA) > 1 &&
+            (me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) || _botclass == BOT_CLASS_SPHYNX))
+        {
+            float addvalue;
+            if (me->IsUnderLastManaUseEffect())
+                addvalue = me->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER);
+            else
+                addvalue = me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+
+            addvalue *= sWorld->getRate(RATE_POWER_MANA) * REGEN_CD * 0.001f; //regenTimer threshold / 1000
+
+            if (addvalue < 0.0f)
+                addvalue = 0.0f;
+
+            if (_botclass == BOT_CLASS_SPHYNX)
+                addvalue *= -1.f;
+
+            me->ModifyPower(POWER_MANA, int32(addvalue));
+        }
+    }
+}
+
+void bot_ai::RegenerateEnergy()
+{
+    uint32 curValue = me->GetPower(POWER_ENERGY);
+    uint32 maxValue = me->GetMaxPower(POWER_ENERGY);
+
+    if (curValue < maxValue)
+    {
+        float addvalue = 0.01f * lastdiff * sWorld->getRate(RATE_POWER_ENERGY); //10 per sec
+        Unit::AuraEffectList const& ModPowerRegenPCTAuras = me->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
+        for (Unit::AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
+            if (Powers((*i)->GetMiscValue()) == POWER_ENERGY)
+                AddPct(addvalue, (*i)->GetAmount());
+
+        //not present in db
+        //addvalue += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_ENERGY) * lastdiff / 5000;
+        //me->ModifyPower(POWER_ENERGY, int32(addvalue));
+
+        addvalue += _energyFraction;
+
+        if (addvalue == 0x0) //only if world rate for enegy is 0
+            return;
+
+        uint32 integerValue = uint32(fabs(addvalue));
+
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            _energyFraction = 0.f;
+        }
+        else
+            _energyFraction = addvalue - float(integerValue);
+
+        if (curValue == maxValue || regenTimer >= REGEN_CD)
+            me->SetPower(POWER_ENERGY, curValue);
+        else
+            me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_ENERGY, curValue);
+    }
+}
+
+bool bot_ai::Feasting() const
+{
+    if (!(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        return false;
+
+    return
+        me->IsSitState() &&
+        (me->HasAuraType(SPELL_AURA_MOD_REGEN)       || me->HasAuraType(SPELL_AURA_OBS_MOD_HEALTH) ||
+         me->HasAuraType(SPELL_AURA_MOD_POWER_REGEN) || me->HasAuraType(SPELL_AURA_OBS_MOD_POWER));
+}
+uint32 bot_ai::GetRation(bool drink) const
+{
+    for (int8 i = MAX_FEAST_SPELLS - 1; i >= 0; --i)
+        if (me->GetLevel() >= (drink ? DrinkSpells[i][0] : EatSpells[i][0]))
+            return (drink ? DrinkSpells[i][1] : EatSpells[i][1]);
+
+    return (drink ? DrinkSpells[0][1] : EatSpells[0][1]);
+}
+
+void bot_ai::DrinkPotion(bool mana)
+{
+    if (IsCasting())
+        return;
+
+    me->CastSpell(me, GetPotion(mana));
+}
+bool bot_ai::IsPotionReady() const
+{
+    return _potionTimer <= lastdiff;
+}
+uint32 bot_ai::GetPotion(bool mana) const
+{
+    for (int8 i = MAX_POTION_SPELLS - 1; i >= 0; --i)
+        if (me->GetLevel() >= (mana ? ManaPotionSpells[i][0] : HealingPotionSpells[i][0]))
+            return (mana ? ManaPotionSpells[i][1] : HealingPotionSpells[i][1]);
+
+    return (mana ? ManaPotionSpells[0][1] : HealingPotionSpells[0][1]);
+}
+bool bot_ai::IsPotionSpell(uint32 spellId) const
+{
+    return spellId == GetPotion(true) || spellId == GetPotion(false);
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+//Deprecated after 4c26c85
+//bool bot_ai::InDuel(Unit const* target) const
+//{
+//    if (!target) return false;
+//    bool isbot = target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot();
+//    Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner()->ToPlayer() : nullptr;
+//    if (!player)
+//    {
+//        if (!target->IsControlledByPlayer())
+//            return false;
+//        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+//    }
+//
+//    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+//}
+////////////////
+//GRID SEARCHERS
+////////////////
+//Finds player or it's corpse for resurrection returned as WorldObject*
+WorldObject* bot_ai::GetNearbyRezTarget(float dist) const
+{
+    std::list<WorldObject*> list;
+
+    NearbyRezTargetCheck check(me, dist, this);
+    Trinity::WorldObjectListSearcher <NearbyRezTargetCheck> searcher(me, list, check);
+    Cell::VisitWorldObjects(me, searcher, dist);
+
+    if (list.empty())
+        return nullptr;
+    if (list.size() == 1)
+        return *list.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(list);
+}
+//Finds target for warrior's Shattering Throw
+Unit* bot_ai::FindImmunityShieldDispelTarget(float dist) const
+{
+    //not checking range
+    if (me->GetVictim() && me->GetVictim()->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+        return me->GetVictim();
+
+    Unit* unit = nullptr;
+
+    ImmunityShieldDispelTargetCheck check(me, dist, this);
+    Trinity::UnitSearcher <ImmunityShieldDispelTargetCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+//Used to find target for priest's dispels, mage's spellsteal and shaman's purge
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    std::list<Unit*> unitList;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitListSearcher <HostileDispelTargetCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+// DEPRECATED our party players (hostile = 1)
+// DEPRECATED our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any friendly player (hostile = 4)
+//    any target in range  (hostile = any other value)
+Unit* bot_ai::FindAffectedTarget(uint32 spellId, ObjectGuid caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return nullptr;
+    if ((hostile == 2 || hostile == 1)/* && IAmFree()*/)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::FindAffectedTarget(): hostile = %u Setting to ALL...", hostile);
+        hostile = 255;
+    }
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    Unit* unit = nullptr;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitSearcher <AffectedTargetCheck> searcher(master, unit, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_ai::FindPolyTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    PolyUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <PolyUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for direct fear (warlock, hunter)
+Unit* bot_ai::FindFearTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <FearUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for CC spells with MECHANIC_STUN
+Unit* bot_ai::FindStunTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <StunUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for priest's shackles
+Unit* bot_ai::FindUndeadCCTarget(float dist, uint32 spellId, bool unattacked) const
+{
+    if (!spellId)
+        return nullptr;
+
+    std::list<Unit*> unitList;
+
+    UndeadCCUnitCheck check(me, dist, this, spellId, unattacked);
+    Trinity::UnitListSearcher <UndeadCCUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    if (!spellId)
+        return nullptr;
+
+    std::list<Unit*> unitList;
+
+    RootUnitCheck check(me, dist, this, spellId);
+    Trinity::UnitListSearcher <RootUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds casting target (neutral or enemy)
+//Can be used to get silence/interruption/reflect/grounding check
+Unit* bot_ai::FindCastingTarget(float maxdist, float mindist, uint32 spellId, uint8 minHpPct) const
+{
+    std::list<Unit*> unitList;
+
+    CastingUnitCheck check(me, mindist, maxdist, spellId, minHpPct);
+    Trinity::UnitListSearcher <CastingUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+// Returns target for dest AOE spell (blizzard, hurricane, etc.) based on crowd size, movement state and direction
+Unit* bot_ai::FindAOETarget(float dist) const
+{
+    std::list<Unit*> unitList;
+    GetNearbyTargetsList(unitList, dist, 0);
+
+    if (unitList.size() < 3)
+        return nullptr;
+
+    Unit* unit = nullptr;
+    float mydist = dist;
+    for (std::list<Unit*>::const_iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+    {
+        if ((*itr)->isMoving() && (*itr)->GetVictim() &&
+            ((*itr)->GetDistance2d((*itr)->GetVictim()->GetPositionX(), (*itr)->GetVictim()->GetPositionY()) > 7.5f ||
+            !(*itr)->HasInArc(M_PI*0.75f, (*itr)->GetVictim())))
+            continue;
+
+        if (!unit && (*itr)->GetVictim() && (*itr)->GetDistance((*itr)->GetVictim()) < dist * 0.334f)
+        {
+            unit = *itr;
+            continue;
+        }
+        if (!unit)
+        {
+            float destDist = me->GetDistance((*itr)->GetPositionX(), (*itr)->GetPositionY(), (*itr)->GetPositionZ());
+            if (destDist < mydist)
+            {
+                mydist = destDist;
+                unit = *itr;
+            }
+        }
+        if (unit)
+        {
+            uint8 count = 0;
+            for (std::list<Unit*>::const_iterator it = unitList.begin(); it != unitList.end(); ++it)
+            {
+                if (*it != unit && (*it)->GetDistance2d(unit->GetPositionX(), unit->GetPositionY()) < 5.f)
+                {
+                    if (++count > 2)
+                    {
+                        if (me->GetDistance(*it) < me->GetDistance(unit) && unit->HasInArc(M_PI/2, me))
+                            unit = *it;
+                        break;
+                    }
+                }
+            }
+            if (count > 2)
+                break;
+
+            unit = nullptr;
+        }
+    }
+
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, etc.
+Unit* bot_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return nullptr;
+
+    if (me->GetDistance(To) > dist)
+        return nullptr;
+
+    Unit* unit = nullptr;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitSearcher <SecondEnemyCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+// Finds secondary target for AoE spells like Mind Sear (not damaging primary target)
+Unit* bot_ai::FindSplashTarget(float dist, Unit* To, float splashdist, uint8 minTargets) const
+{
+    if (!To || minTargets < 1)
+        return nullptr;
+
+    if (me->GetDistance(To) > dist)
+        return nullptr;
+
+    std::list<Unit*> unitList;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitListSearcher <SecondEnemyCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (uint8(unitList.size()) < minTargets)
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for hunter's Tranquilizing Shot (has dispellable magic or enrage effect)
+Unit* bot_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    Unit* unit = nullptr;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitSearcher <TranquilTargetCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    return unit;
+}
+//Find target to cast taunt on
+//In case of paladin's Righetoous Defense returns IsInBotParty() unit
+Unit* bot_ai::FindDistantTauntTarget(float maxdist, bool ally) const
+{
+    std::list<Unit*> unitList;
+
+    FarTauntUnitCheck check(me, maxdist, ally, this);
+    Trinity::UnitListSearcher <FarTauntUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+
+    Unit* unit = unitList.size() == 1 ? *unitList.begin() : Trinity::Containers::SelectRandomContainerElement(unitList);
+    return ally ? unit->GetVictim() : unit;
+}
+//Finds target for Warlock's Mana Drain
+//Returns nearby CCed unit with most mana
+Unit* bot_ai::FindDrainTarget(float maxdist) const
+{
+    Unit* unit = nullptr;
+
+    ManaDrainUnitCheck check(me, maxdist);
+    Trinity::UnitLastSearcher <ManaDrainUnitCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    return unit;
+}
+//Finds all targets within given range
+//used for finding targets for spells which need reasonable amount of targets (ex. Death Knight AOE spells)
+//CCoption:= mask
+//1 - not CCed
+//2 - has no periodic damage auras (can be safely CCed)
+void bot_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, uint8 CCoption, WorldObject const* source) const
+{
+    if (!source)
+        source = me;
+
+    NearbyHostileUnitCheck check(me, maxdist, this, CCoption, source);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+}
+//Find all targets within given range in cone in front of caster; angle is PI/2 (TC confirmed)
+//used by mage Dragon's Breath and Cone of Cold spells
+//also Swipe (Bear) and Swipe (Cat)
+void bot_ai::GetNearbyTargetsInConeList(std::list<Unit*> &targets, float maxdist) const
+{
+    NearbyHostileUnitInConeCheck check(me, maxdist, this);
+    Trinity::UnitListSearcher <NearbyHostileUnitInConeCheck> searcher(me, targets, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+}
+//Finds all friendly targets within given range
+//used for finding targets to heal/buff for uncontrolled bots
+void bot_ai::GetNearbyFriendlyTargetsList(std::list<Unit*> &targets, float maxdist) const
+{
+    NearbyFriendlyUnitCheck check(me, maxdist, this);
+    Trinity::UnitListSearcher <NearbyFriendlyUnitCheck> searcher(me, targets, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spellId of max rank allowed for given caster
+//If you want bot to use this spell through doCast() go InitSpellMap(uint32) instead
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->GetLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, puts spell of max rank allowed for given caster in spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->GetLevel();
+    uint32 spellId = forceadd ? basespell : 0;
+
+    while (info != nullptr && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotSpell* newSpell = _spells[basespell];
+    if (!newSpell)
+    {
+        newSpell = new BotSpell();
+        _spells[basespell] = newSpell;
+    }
+
+    newSpell->spellId = spellId;
+}
+//Using first-rank spell as source, return current spell id
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() && (itr->second->enabled == true || IAmFree()) ? itr->second->spellId : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() ? itr->second->cooldown : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD) const
+{
+    if (checkGCD && GC_Timer > diff)
+        return false;
+
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr == _spells.end() ? true :
+        ((itr->second->enabled == true || IAmFree()) && itr->second->spellId != 0 && itr->second->cooldown <= diff);
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    if (itr != _spells.end())
+    {
+        itr->second->cooldown = msCooldown;
+        return;
+    }
+    else if (!msCooldown)
+        return;
+
+    InitSpellMap(basespell, true, false);
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->first == spellInfo->Id && itr->second->cooldown >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (info && itr->first == spellInfo->Id && info->GetCategory() != category)
+        {
+            TC_LOG_ERROR("scripts", "Warning: SetSpellCategoryCooldown: %s (%u) has baseId %u but category %u, not %u!",
+                info->SpellName[0], info->Id, itr->first, info->GetCategory(), category);
+        }
+        if (info && (info->GetCategory() == category || itr->first == spellInfo->Id) && itr->second->cooldown < msCooldown)
+            itr->second->cooldown = msCooldown;
+    }
+}
+//Handles spell cooldowns for spell with IsCooldownStartedOnEvent() == true
+void bot_ai::ReleaseSpellCooldown(uint32 basespell)
+{
+    SpellInfo const* baseInfo = sSpellMgr->GetSpellInfo(basespell);
+
+    if (!baseInfo->IsCooldownStartedOnEvent())
+    {
+        TC_LOG_ERROR("spells", "bot_ai::ReleaseSpellCooldown is called for wrong spell %u!", basespell);
+        return;
+    }
+
+    uint32 rec = baseInfo->RecoveryTime;
+    uint32 catrec = baseInfo->CategoryRecoveryTime;
+
+    ApplyBotSpellCooldownMods(baseInfo, rec);
+    ApplyBotSpellCategoryCooldownMods(baseInfo, catrec);
+
+    SetSpellCooldown(baseInfo->Id, rec > 0 ? rec : 0);
+    SetSpellCategoryCooldown(baseInfo, catrec > 0 && !(baseInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS) ? catrec : 0);
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpell* newSpell;
+    BotSpellMap::iterator itr = _spells.find(basespell);
+    if (itr == _spells.end())
+    {
+        newSpell = new BotSpell();
+        _spells[basespell] = newSpell;
+    }
+    else
+        newSpell = itr->second;
+
+    newSpell->spellId = 0;
+    newSpell->cooldown = 0;
+}
+//
+//void bot_ai::RemoveAllSpells()
+//{
+//    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+//        itr->second->spellId = 0;
+//}
+//See CommonTimers(uint32)
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        if (itr->second->cooldown >= diff)
+            itr->second->cooldown -= diff;
+        else if (itr->second->cooldown > 0)
+            itr->second->cooldown = 0;
+    }
+}
+uint32 bot_ai::RaceSpellForClass(uint8 myrace, uint8 myclass)
+{
+    switch (myrace)
+    {
+        case RACE_ORC:
+            switch (myclass)
+            {
+                case BOT_CLASS_WARLOCK:
+                    return RACIAL_BLOOD_FURY_WARLOCK;
+                case BOT_CLASS_SHAMAN:
+                    return RACIAL_BLOOD_FURY_SHAMAN;
+                default:
+                    return RACIAL_BLOOD_FURY_OTHERS;
+            }
+            break;
+        case RACE_BLOODELF:
+            switch (myclass)
+            {
+                case BOT_CLASS_DEATH_KNIGHT:
+                    return RACIAL_ARCANE_TORRENT_DEATHKNIGHT;
+                case BOT_CLASS_ROGUE:
+                    return RACIAL_ARCANE_TORRENT_ROGUE;
+                default:
+                    return RACIAL_ARCANE_TORRENT_OTHERS;
+            }
+            break;
+        case RACE_DRAENEI:
+            switch (myclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    return RACIAL_GIFT_OF_NAARU_WARRIOR;
+                case BOT_CLASS_PALADIN:
+                    return RACIAL_GIFT_OF_NAARU_PALADIN;
+                case BOT_CLASS_HUNTER:
+                    return RACIAL_GIFT_OF_NAARU_HUNTER;
+                case BOT_CLASS_PRIEST:
+                    return RACIAL_GIFT_OF_NAARU_PRIEST;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    return RACIAL_GIFT_OF_NAARU_DEATHKNIGHT;
+                case BOT_CLASS_SHAMAN:
+                    return RACIAL_GIFT_OF_NAARU_SHAMAN;
+                case BOT_CLASS_MAGE:
+                    return RACIAL_GIFT_OF_NAARU_MAGE;
+                default:
+                    TC_LOG_ERROR("entities.player", "RaceSpellForClass(): unknows race:class combo %u, %u", uint32(myrace), uint32(myclass));
+                    return 0;
+            }
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "RaceSpellForClass(): unknows race:class combo %u, %u", uint32(myrace), uint32(myclass));
+            return 0;
+    }
+}
+//Health magement for minions
+//Including health calcs, set
+void bot_ai::_OnHealthUpdate() const
+{
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->GetLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    bool fullhp = me->GetHealth() == me->GetMaxHealth();
+    float pct = fullhp ? 100.f : me->GetHealthPct(); // needs for regeneration
+    uint32 m_basehp = _classinfo->basehealth;
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+
+    float stamValue = _getTotalBotStat(BOT_STAT_MOD_STAMINA);
+
+    stamValue -= std::min<float>(me->GetCreateStat(STAT_STAMINA), 20.f); //not a mistake
+    stamValue = std::max<float>(stamValue, 0.f);
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    float hp_add = stamValue * 10.f + 20; //20 is not a mistake;
+    //hp_add += IAmFree() ? mylevel * 375.f : 0; //+30000/+0 hp at 80
+    hp_add += _getTotalBotStat(BOT_STAT_MOD_HEALTH);
+    //TC_LOG_ERROR("entities.player", "health to add after stam mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + int32(hp_add); //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+
+    //hp bonuses
+    uint8 bonuspct = 0;
+    //Endurance Training
+    if (_botclass == BOT_CLASS_HUNTER && mylevel >= 10)
+        bonuspct += 5;
+    //Fel Vitality
+    if (_botclass == BOT_CLASS_WARLOCK && mylevel >= 15)
+        bonuspct += 3;
+    //Sphynx bonus (some equip slots unavailable)
+    if (_botclass == BOT_CLASS_SPHYNX)
+        bonuspct += 50;
+    //Dreadlord's vitality
+    if (_botclass == BOT_CLASS_DREADLORD)
+        bonuspct += 20;
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+
+    //m_totalhp = float(uint32(m_totalhp) - (uint32(m_totalhp) % 10));
+    me->SetStatFlatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth(); //will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(fullhp ? me->GetMaxHealth() : uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana management for minions
+//Including calcs and set
+void bot_ai::_OnManaUpdate() const
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->GetLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    bool fullmana = me->GetPower(POWER_MANA) == me->GetMaxPower(POWER_MANA);
+    float pct = fullmana ? 100.f : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana;
+    if (_botclass == BOT_CLASS_BM)
+        m_basemana = BASE_MANA_1_BM + (BASE_MANA_10_BM - BASE_MANA_1_BM) * (mylevel/81.f);
+    if (_botclass == BOT_CLASS_SPHYNX)
+        m_basemana = BASE_MANA_SPHYNX;
+    if (_botclass == BOT_CLASS_ARCHMAGE)
+        m_basemana = BASE_MANA_1_ARCHMAGE + (BASE_MANA_10_ARCHMAGE - BASE_MANA_1_ARCHMAGE) * ((mylevel - 20)/81.f);
+    if (_botclass == BOT_CLASS_DREADLORD)
+        m_basemana = BASE_MANA_1_DREADLORD + (BASE_MANA_10_DREADLORD - BASE_MANA_1_DREADLORD) * ((mylevel - 60)/83.f);
+    if (_botclass == BOT_CLASS_SPELLBREAKER)
+        m_basemana = BASE_MANA_SPELLBREAKER;
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+        m_basemana = BASE_MANA_1_DARK_RANGER + (BASE_MANA_10_DARK_RANGER - BASE_MANA_1_DARK_RANGER) * ((mylevel - 40)/82.f);
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+
+    me->SetCreateMana(uint32(m_basemana));
+
+    float intValue = _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+
+    intValue -= std::min<float>(me->GetCreateStat(STAT_INTELLECT), 20.f); //not a mistake
+    intValue = std::max<float>(intValue, 0.f);
+
+    float intMult = _botclass < BOT_CLASS_EX_START ? 15.f : IsHeroExClass(_botclass) ? 5.f : 1.5f;
+
+    m_basemana = intValue * intMult + 20.f; //20.f is not a mistake
+    //m_basemana += IAmFree() ? mylevel * 50.f : 0; //+4000/+0 mana at 80
+    m_basemana += _getTotalBotStat(BOT_STAT_MOD_MANA);
+
+    //mana bonuses
+    uint8 bonuspct = 0;
+    //Fel Vitality
+    if (_botclass == BOT_CLASS_WARLOCK && mylevel >= 15)
+        bonuspct += 3;
+    if (bonuspct)
+        m_basemana = (m_basemana * (100 + bonuspct)) / 100;
+
+    //m_basemana = float(uint32(m_basemana) - (uint32(m_basemana) % 5));
+    me->SetStatFlatModifier(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, fullmana ? me->GetMaxPower(POWER_MANA) :
+        uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+
+    _OnManaRegenUpdate();
+}
+//Mana regen for minions
+void bot_ai::_OnManaRegenUpdate() const
+{
+    //regen_normal
+    uint8 mylevel = me->GetLevel();
+    float value = IAmFree() ? mylevel/2 : 0; //200/0 mp5 at 80
+
+    float power_regen_mp5;
+    int32 modManaRegenInterrupt;
+    if (_botclass < BOT_CLASS_EX_START)
+    {
+        // Mana regen from spirit and intellect
+        float spiregen = 0.001f;
+        if (GtRegenMPPerSptEntry const* moreRatio = sGtRegenMPPerSptStore.LookupEntry((_botclass-1)*GT_MAX_LEVEL + mylevel-1))
+            spiregen = moreRatio->Data * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+
+        // PCT bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT aura on spirit base regen
+        value += sqrt(_getTotalBotStat(BOT_STAT_MOD_INTELLECT)) * spiregen * me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+        // regen from SPELL_AURA_MOD_POWER_REGEN aura (per second)
+        power_regen_mp5 = 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+        if (IAmFree())
+            power_regen_mp5 += float(mylevel);
+        // bonus from SPELL_AURA_MOD_MANA_REGEN_FROM_STAT aura
+        Unit::AuraEffectList const& regenAura = me->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+            power_regen_mp5 += me->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() * 0.002f; //per second
+
+        //bot also receive bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT for mp5 regen
+        power_regen_mp5 *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+
+        // Set regen rate in cast state apply only on spirit based regen
+        modManaRegenInterrupt = std::min<int32>(100, me->GetTotalAuraModifier(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT));
+    }
+    else
+    {
+        modManaRegenInterrupt = 100;
+        power_regen_mp5 = 0.0f;
+
+        if (IsHeroExClass(_botclass))
+        {
+            float basemana;
+            if (_botclass == BOT_CLASS_BM)
+                basemana = BASE_MANA_1_BM;
+            else if (_botclass == BOT_CLASS_ARCHMAGE)
+                basemana = BASE_MANA_1_ARCHMAGE;
+            else if (_botclass == BOT_CLASS_DREADLORD)
+                basemana = BASE_MANA_1_DREADLORD;
+            else if (_botclass == BOT_CLASS_DARK_RANGER)
+                basemana = BASE_MANA_1_DARK_RANGER;
+            else
+                basemana = 0.f;
+
+            value = basemana * 0.0087f + 0.08f * GetTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            value += 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+            value *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+        }
+        else if (_botclass == BOT_CLASS_SPHYNX)
+        {
+            value = CalculatePct(me->GetCreateMana(), 2); //-2% basemana/sec
+        }
+        else if (_botclass == BOT_CLASS_SPELLBREAKER)
+        {
+            value = 4.f; //base 0.8/sec
+            value += 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+            value *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+        }
+        else
+            value = 0;
+
+        if (IAmFree())
+            value += float(mylevel);
+    }
+    //Unrelenting Storm, Dreamstate: 12% of intellect as mana regen always (divided by 5)
+    if ((_botclass == BOT_CLASS_SHAMAN && _spec == BOT_SPEC_SHAMAN_ELEMENTAL) ||
+        (_botclass == BOT_CLASS_DRUID && _spec == BOT_SPEC_DRUID_BALANCE))
+        power_regen_mp5 += 0.024f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+
+    me->SetStatFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER, power_regen_mp5 + CalculatePct(value, modManaRegenInterrupt));
+    me->SetStatFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER, power_regen_mp5 + value);
+}
+//Bots cannot dodge/parry from behind so try to condense enemies at front
+//opponent is always valid
+void bot_ai::AdjustTankingPosition() const
+{
+    //problem: chasing unit is constantly moving. Whoever the hell did that
+//    if (/*!IsTank() || */!me->IsInCombat() || me->isMoving() || IsCasting() ||
+//        JumpingOrFalling() || CCed(me, true) || Rand() > 10 + 20*me->GetMap()->IsDungeon())
+//        return;
+    if (/*!IsTank() || */!me->IsInCombat() || IsCasting() ||
+        JumpingOrFalling() || CCed(me, true) || Rand() > 10 + 20*me->GetMap()->IsDungeon() ||
+        HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+
+    Unit::AttackerSet const& myattackers = me->getAttackers();
+    if (myattackers.size() < 2)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition() by %s", me->GetName().c_str());
+
+    uint32 bCount = 0;
+    for (Unit::AttackerSet::const_iterator itr = myattackers.begin(); itr != myattackers.end(); ++itr)
+    {
+        if (/*!CCed(*itr) && */(*itr)->GetDistance(me) < 5 && !me->HasInArc(M_PI, *itr))
+            ++bCount;
+            //if (++bCount)
+            //    break;
+    }
+
+    if (bCount == 0)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition(): atts %u, behind %u", uint32(myattackers.size()), bCount);
+
+    //calculate new position
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float ori = CCed(opponent, true) ? me->GetOrientation() + 0.75f * M_PI : me->GetOrientation();
+    float const moveDist = -1.f * std::max<float>(opponent->GetCombatReach() * 0.6f, 3.f);
+    float moveX;
+    float moveY;
+    //bool move = false;
+    for (uint8 i = 0; i != 3; ++i)
+    {
+        if (i)
+        {
+            ori = Position::NormalizeOrientation(ori + (i+1)*(M_PI*0.5f));
+        }
+
+        //move back
+        moveX = moveDist * std::cos(ori);
+        moveY = moveDist * std::sin(ori);
+
+        if (me->IsWithinLOS(x+moveX, y+moveY, z))
+            break;
+
+        if (i == 2)
+        {
+            moveX *= 0.2f;
+            moveY *= 0.2f;
+        }
+    }
+
+    x+= moveX;
+    y+= moveY;
+
+    me->UpdateAllowedPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.75f; //prevent going underground
+
+    //if (CCed(opponent, true))
+    //    me->AttackStop();
+    //me->SetOrientation(ori);
+    //me->BotStopMovement();
+    me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z, false);
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition(): moving %s from %.2f %.2f to %.2f %.2f",
+    //    me->GetName().c_str(), me->GetPositionX(), me->GetPositionY(), x, y);
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    //uint32 const spellId = spell->Id;
+
+    if (!spell->IsPositive() && spell->GetMaxDuration() > 1000 && caster->IsControlledByPlayer() &&
+        _botclass >= BOT_CLASS_EX_START)
+    {
+        //bots of W3 classes will not be easily CCed
+        if (spell->HasAura(SPELL_AURA_MOD_STUN) || spell->HasAura(SPELL_AURA_MOD_CONFUSE) ||
+            spell->HasAura(SPELL_AURA_MOD_PACIFY) || spell->HasAura(SPELL_AURA_MOD_ROOT))
+        {
+            if (Aura* cont = me->GetAura(spell->Id, caster->GetGUID()))
+            {
+                if (AuraApplication const* aurApp = cont->GetApplicationOfTarget(me->GetGUID()))
+                {
+                    if (!aurApp->IsPositive())
+                    {
+                        int32 dur = std::max<int32>(cont->GetMaxDuration() / 3, 1000);
+                        cont->SetDuration(dur);
+                        cont->SetMaxDuration(dur);
+                    }
+                }
+            }
+        }
+    }
+
+    if (!HasBotCommandState(BOT_COMMAND_FULLSTOP))
+    {
+        if (spell->HasAura(SPELL_AURA_MOD_TAUNT) || spell->HasEffect(SPELL_EFFECT_ATTACK_ME))
+            if (caster && me->Attack(caster, !HasRole(BOT_ROLE_RANGED)))
+            {}//me->GetMotionMaster()->MoveChase(caster);
+    }
+
+    if (spell->GetSpellSpecific() == SPELL_SPECIFIC_DRINK)
+    {
+        feast_mana = true;
+        UpdateMana();
+        regenTimer = 0;
+    }
+    else if (spell->GetSpellSpecific() == SPELL_SPECIFIC_FOOD)
+    {
+        feast_health = true;
+        regenTimer = 0;
+    }
+
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 const auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            //TC_LOG_ERROR("entities.unit", "OnSpellHit: mount on %s", me->GetName().c_str());
+            UnsummonAll();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                //TC_LOG_ERROR("entities.unit", "OnSpellHit: modding flight speed");
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->Movement.Flight = CreatureFlightMovementType::CanFly;
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                if (Aura* mount = me->GetAura(spell->Id))
+                {
+                    //TC_LOG_ERROR("entities.unit", "OnSpellHit: found aura");
+                    for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
+                    {
+                        if (spell->Effects[j].ApplyAuraName != SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED &&
+                            spell->Effects[j].ApplyAuraName != SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED &&
+                            spell->Effects[j].ApplyAuraName != SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                            continue;
+                        if (AuraEffect* meff = mount->GetEffect(j))
+                        {
+                            meff->ChangeAmount(meff->GetAmount() * 3);
+                        }
+                    }
+                }
+                //me->SetSpeedRate(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                //me->SetSpeedRate(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+            }
+            else
+                me->SetSpeedRate(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.1f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE || auraname == SPELL_AURA_MOD_SKILL ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT ||
+            auraname == SPELL_AURA_MOD_RATING || auraname == SPELL_AURA_MOD_RATING_FROM_STAT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+            auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2 blood pact, commanding shout
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+            UpdateHealth();
+        else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+            UpdateMana(); //Divine Hymn - max mana increase
+
+        uint32 const effect = spell->Effects[i].Effect;
+        if (effect == SPELL_EFFECT_RESURRECT || effect == SPELL_EFFECT_RESURRECT_NEW || effect == SPELL_EFFECT_SELF_RESURRECT)
+        {
+            //resurrect effects are not handled for creatures
+            if (!me->IsAlive())
+            {
+                uint32 health = 0;
+                uint32 mana = 0;
+                int32 damage = spell->Effects[i].BasePoints;
+
+                if (effect == SPELL_EFFECT_RESURRECT_NEW)
+                {
+                    //Glyph of Rebirth: resurrect with 100% health
+                    if (spell->IsRankOf(sSpellMgr->GetSpellInfo(20484)))
+                        health = me->GetMaxHealth();
+                    else
+                        health = damage;
+                    mana = spell->Effects[i].MiscValue;
+                }
+                else if (damage < 0)
+                {
+                    health = uint32(-damage);
+                    mana = spell->Effects[i].MiscValue;
+                }
+                else
+                {
+                    health = me->CountPctFromMaxHealth(damage);
+                    if (me->GetMaxPower(POWER_MANA) > 1)
+                        mana = CalculatePct(me->GetMaxPower(POWER_MANA), damage);
+                }
+
+                BotMgr::ReviveBot(me, caster);
+
+                me->SetHealth(health);
+                if (me->GetMaxPower(POWER_MANA) > 1)
+                    me->SetPower(POWER_MANA, mana);
+            }
+        }
+        //ravasaur poison (EffectEnchantHeldItem) for mh and oh
+        if (effect == SPELL_EFFECT_ENCHANT_HELD_ITEM)
+        {
+            uint32 enchant_id = spell->Effects[i].MiscValue;
+            if (!enchant_id)
+                continue;
+
+            EnchantmentSlot slot = TEMP_ENCHANTMENT_SLOT;
+            Item* weap = _equips[BOT_SLOT_MAINHAND];
+            if (!weap || weap->GetEnchantmentId(slot))
+                weap = _equips[BOT_SLOT_OFFHAND];
+            if (!weap || weap->GetTemplate()->Class != ITEM_CLASS_WEAPON || weap->GetEnchantmentId(slot))
+                continue;
+
+            int32 duration = spell->GetDuration();
+            if (!duration)
+                duration = 10; //10 sec default
+
+            if (!IAmFree())
+                master->GetSession()->SendEnchantmentLog(me->GetGUID(), caster->GetGUID(), weap->GetEntry(), enchant_id);
+
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration * IN_MILLISECONDS);
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, 0);
+            ApplyItemBonuses(weap == _equips[BOT_SLOT_MAINHAND] ? BOT_SLOT_MAINHAND : BOT_SLOT_OFFHAND);
+        }
+    }
+
+    //TODO:
+    if (/*!(spell->AttributesEx & SPELL_ATTR1_NO_THREAT) &&
+        !(spell->AttributesEx3 & SPELL_ATTR3_NO_INITIAL_AGGRO) && !CCed(me) && */
+        !me->GetVictim() &&
+        (me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        //_atHome = false;
+        if (!me->CanSeeOrDetect(caster))
+        {
+            if (_evadeMode)
+                me->BotStopMovement();
+        }
+        else if (caster->IsInCombat() || me->IsInCombat())
+            this->OwnerAttackedBy(caster);
+        //if (_evadeMode == true && me->isMoving() && IAmFree())
+    }
+}
+//Update delay
+//Skip UpdateAI cycles for randomization of bots' reaction and performance adjustments
+bool bot_ai::Wait()
+{
+    if (waitTimer > lastdiff || !master->IsInWorld())
+        return true;
+
+    if (IAmFree())
+        waitTimer = me->IsInCombat() ? 500 : urand(750, 1250);
+    else if (!master->GetMap()->IsRaid())
+        waitTimer = std::min<uint32>(uint32(50 * (master->GetNpcBotsCount() - 1) + __rand + __rand), 500);
+    else
+        waitTimer = __rand;
+
+    waitTimer += BotMgr::GetBaseUpdateDelay();
+
+    return false;
+}
+//Spell Mod Hooks
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    //WHITE ATTACKS damage bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    //MELEE ABILITIES damage bonus (DMG_CLASS != DMG_CLASS_MAGIC)
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    //DAMAGE SPELLS damage bonus (DMG_CLASS_MAGIC)
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+void bot_ai::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    //HEALING SPELLS amount bonus
+    ApplyClassDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+    heal = (heal * BotMgr::GetBotHealingMod());
+}
+void bot_ai::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    //ALL SPELLS crit bonus + base
+    ApplyClassSpellCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+    crit_chance += crit;
+}
+void bot_ai::ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    //ALL SPELLS power cost bonus
+    ApplyClassSpellCostMods(spellInfo, cost);
+}
+void bot_ai::ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    //ALL SPELLS cast time bonus
+    ApplyClassSpellCastTimeMods(spellInfo, casttime);
+}
+void bot_ai::ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS cooldown bonus
+    ApplyClassSpellCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS category cooldown bonus
+    ApplyClassSpellCategoryCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+{
+    //ALL SPELLS global cooldown bonus
+    ApplyClassSpellGlobalCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+{
+    //ALL SPELLS radius bonus (not range)
+    ApplyClassSpellRadiusMods(spellInfo, radius);
+}
+void bot_ai::ApplyBotSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+{
+    //ALL SPELLS range bonus
+    ApplyClassSpellRangeMods(spellInfo, maxrange);
+}
+void bot_ai::ApplyBotSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+{
+    //ALL SPELLS max targets bonus
+    ApplyClassSpellMaxTargetsMods(spellInfo, targets);
+}
+void bot_ai::ApplyBotSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+{
+    //ALL CLASS PROC_TRIGGER_SPELL SPELLS chance of success bonus
+    ApplyClassSpellChanceOfSuccessMods(spellInfo, chance);
+}
+void bot_ai::ApplyBotEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const
+{
+    //ALL SPELLS SPELLMOD_EFFECT_X bonus
+    ApplyClassEffectMods(spellInfo, effIndex, value);
+}
+void bot_ai::ApplyBotEffectMods(Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value) const
+{
+    //ALL SPELLS SPELLMOD_EFFECT_X bonus (target-specific)
+    ApplyClassEffectMods(target, spellInfo, effIndex, value);
+}
+//Spell Mod Utilities
+float bot_ai::CalcSpellMaxRange(uint32 spellId, bool enemy) const
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    //ASSERT(spellInfo);
+
+    float maxRange = spellInfo->GetMaxRange(!enemy);
+    if (maxRange == 0x0)
+        return maxRange;
+
+    ApplyClassSpellRangeMods(spellInfo, maxRange);
+    return maxRange;
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello
+bool bot_ai::OnGossipHello(Player* player, uint32 /*option*/)
+{
+    if (!BotMgr::IsNpcBotModEnabled() || !BotMgr::IsClassEnabled(_botclass) ||
+        IsTempBot() || me->IsInCombat() || CCed(me) || IsCasting() || IsDuringTeleport())
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    if (me->isMoving())
+        me->BotStopMovement();
+
+    uint32 gossipTextId;
+    if (!IAmFree())
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DARKRANGER;
+        else
+            gossipTextId = GOSSIP_NORMAL_SERVE_MASTER;
+    }
+    else
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DARKRANGER;
+        else
+            gossipTextId = GOSSIP_GREET_NEED_SMTH;
+    }
+
+    bool menus = false;
+
+    if (player->IsGameMaster())
+    {
+        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Debug>", GOSSIP_SENDER_DEBUG, GOSSIP_ACTION_INFO_DEF + 1);
+        menus = true;
+    }
+
+    if (player->GetGUID().GetCounter() != _ownerGuid)
+    {
+        if (IAmFree())
+        {
+            uint32 cost = BotMgr::GetNpcBotCost(player->GetLevel(), _botclass);
+
+            int8 reason = 0;
+            if (me->HasAura(BERSERK))
+                reason = -1;
+            if (!reason && _ownerGuid)
+                reason = 1;
+            if (!reason && player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                reason = 2;
+            if (!reason && !player->HasEnoughMoney(cost))
+                reason = 3;
+
+            if (!reason && BotMgr::GetMaxClassBots() && player->HaveBot())
+            {
+                uint8 count = 0;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    if (itr->second->GetBotClass() == _botclass)
+                        ++count;
+
+                if (!reason && count >= BotMgr::GetMaxClassBots())
+                    reason = 4;
+            }
+
+            std::ostringstream message1;
+            std::ostringstream message2;
+            if (_botclass == BOT_CLASS_SPHYNX)
+            {
+                message1 << "Are you sure you want to risk drawing " << me->GetName() << "'s attention?";
+                message2 << "<Insert Coin>";
+            }
+            else if (_botclass == BOT_CLASS_DREADLORD)
+            {
+                message1 << "Do you want to entice " << me->GetName() << '?';
+                message2 << "<Try to make an offering>";
+            }
+            else
+            {
+                message1 << "Do you wish to hire " << me->GetName() << '?';
+                message2 << "<Hire bot>";
+            }
+
+            if (!reason)
+            {
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, message2.str().c_str(),
+                    GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + 0, message1.str().c_str(), cost, false);
+            }
+            else
+                AddGossipItemFor(player, GOSSIP_ICON_TAXI, message2.str().c_str(), GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + reason);
+
+            menus = true;
+        }
+    }
+
+    if (_ownerGuid)
+    {
+        Group const* gr = player->GetGroup();
+
+        if (player == master)
+        {
+            menus = true;
+
+            //general: equips, roles, distance, abilities, comsumables, group
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Manage equipment...", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Manage roles...", GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Manage formation...", GOSSIP_SENDER_FORMATION, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Manage abilities...", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+            if (_botclass < BOT_CLASS_EX_START)
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Manage talents...", GOSSIP_SENDER_SPEC, GOSSIP_ACTION_INFO_DEF + 1);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Give consumable...", GOSSIP_SENDER_USEITEM, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+
+            if (!gr)
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Create group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+                if (player->GetNpcBotsCount() > 1)
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Create group (all bots)>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+            else if (!gr->IsMember(me->GetGUID()))
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Add to group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Add all bots to group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+            else
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Remove from group>", GOSSIP_SENDER_LEAVE_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //movement toggle
+            if (HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Follow me", GOSSIP_SENDER_FOLLOWME, GOSSIP_ACTION_INFO_DEF + 1);
+            if (!HasBotCommandState(BOT_COMMAND_STAY))
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Hold your position", GOSSIP_SENDER_HOLDPOSITION, GOSSIP_ACTION_INFO_DEF + 1);
+            if (!HasBotCommandState(BOT_COMMAND_FULLSTOP))
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Stay here and don't do anything", GOSSIP_SENDER_DONOTHING, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        if (player == master || (gr && gr->IsMember(master->GetGUID())))
+        {
+            //class-specific for party: mage rations, rogue lockpicking etc.
+            //TODO: priest lightwell (manual only) maybe move into abilities
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need food", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need water", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    if (me->GetLevel() >= 70)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need a refreshment table", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                    menus = true;
+                    break;
+                }
+                case BOT_CLASS_ROGUE:
+                {
+                    //Learned at 16
+                    //Allow rogues to gain skill with bot's help
+                    if (me->GetLevel() >= 16/* && !player->HasSkill(SKILL_LOCKPICKING)*/)
+                    {
+                        std::ostringstream msg;
+                        msg << "Help me pick a lock (" << uint32(me->GetLevel() * 5) << ")";
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                        menus = true;
+                    }
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need your your healthstone", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    if (me->GetLevel() >= 68)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need a soulwell", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                    menus = true;
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+        if (player == master)
+        {
+            //class-specific for owner: poisons, enchants, etc.
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    if (me->GetLevel() >= 20)
+                    {
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need you to refresh poisons", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                        AddGossipItemFor(player, GOSSIP_ICON_TALK, "<Choose poison (Main Hand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                        Item const* oweap = _equips[BOT_SLOT_OFFHAND];
+                        if (oweap && oweap->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+                            AddGossipItemFor(player, GOSSIP_ICON_TALK, "<Choose poison (Offhand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 4);
+                    }
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    if (me->GetLevel() >= 10)
+                    {
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need you to refresh enchants", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                        AddGossipItemFor(player, GOSSIP_ICON_TALK, "<Choose enchant (Main Hand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                        Item const* oweap = _equips[BOT_SLOT_OFFHAND];
+                        if (oweap && oweap->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+                            AddGossipItemFor(player, GOSSIP_ICON_TALK, "<Choose enchant (Offhand)>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 4);
+                    }
+                    if (me->GetShapeshiftForm() != FORM_NONE)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need you to remove shapeshift", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 5);
+                    break;
+                }
+                case BOT_CLASS_DRUID:
+                {
+                    if (me->GetShapeshiftForm() != FORM_NONE)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "I need you to remove shapeshift", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    break;
+                }
+                case BOT_CLASS_HUNTER:
+                {
+                    if (me->GetLevel() >= 10)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Choose pet type>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Choose pet type>", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    break;
+                }
+                default:
+                    break;
+            }
+
+            std::ostringstream astr;
+            astr << "Are you going to abandon " << me->GetName() << "? You may regret it...";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "You are dismissed",
+                GOSSIP_SENDER_DISMISS, GOSSIP_ACTION_INFO_DEF + 1, astr.str().c_str(), 0, false);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Pull yourself together, damnit", GOSSIP_SENDER_TROUBLESHOOTING, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+    }
+
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        menus = true;
+        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Study the creature>", GOSSIP_SENDER_SCAN, GOSSIP_ACTION_INFO_DEF + 1);
+    }
+
+    if (!menus)
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+    player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_ai::OnGossipSelect(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action)
+{
+    //if (!IsInBotParty(player))
+    //{
+    //    player->PlayerTalkClass->SendCloseGossip();
+    //    return true;
+    //}
+
+    if (!BotMgr::IsNpcBotModEnabled() || me->HasUnitState(UNIT_STATE_CASTING) || CCed(me) || IsDuringTeleport())
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    uint32 gossipTextId;
+    if (!IAmFree())
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DARKRANGER;
+        else
+            gossipTextId = GOSSIP_NORMAL_SERVE_MASTER;
+    }
+    else
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DARKRANGER;
+        else
+            gossipTextId = GOSSIP_GREET_NEED_SMTH;
+    }
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            BotSay("...", player);
+            break;
+        }
+        case 1: //BACK: return to main menu
+        {
+            return bot_ai::OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_CLASS:
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+
+                    uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+                    if (option == 1 || option == 2) //food, water
+                    {
+                        //Prevent high-leveled consumables for low-level characters
+                        Unit* checker;
+                        if (player->GetLevel() < me->GetLevel())
+                            checker = player;
+                        else
+                            checker = me;
+
+                        // Conjure Refreshment rank 1
+                        uint32 food = InitSpell(checker, 42955);
+                        bool iswater = (option == 2);
+                        if (!food)
+                        {
+                            if (!iswater)// Conjure Food rank 1
+                                food = InitSpell(checker, 587);
+                            else// Conjure Water rank 1
+                                food = InitSpell(checker, 5504);
+                        }
+                        if (!food)
+                        {
+                            std::string errorstr = "I can't conjure ";
+                            errorstr += iswater ? "water" : "food";
+                            errorstr += " yet";
+                            BotWhisper(errorstr.c_str(), player);
+                            //player->PlayerTalkClass->ClearMenus();
+                            //return OnGossipHello(player, me);
+                            break;
+                        }
+                        SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                        Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+                        SpellCastTargets targets;
+                        targets.SetUnitTarget(player);
+                        SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                        if (result != SPELL_CAST_OK)
+                        {
+                            foodspell->finish(false);
+                            delete foodspell;
+                            BotWhisper("I can't do it right now", player);
+                        }
+                        else
+                        {
+                            aftercastTargetGuid = player->GetGUID();
+                            foodspell->prepare(targets);
+                            BotWhisper("Here you go...", player);
+                        }
+                        break;
+                    }
+                    else if (option == 3) //refreshment table
+                    {
+                        uint32 tableSpellId = GetSpell(43987); //Ritual of Refreshment
+                        if (!tableSpellId)
+                        {
+                            BotWhisper("Disabled", player);
+                            break;
+                        }
+                        if (!IsSpellReady(43987, GetLastDiff(), false))
+                        {
+                            BotWhisper("Not ready yet", player);
+                            break;
+                        }
+                        uint32 tableGOForSpell = (tableSpellId == 43987 ? GO_REFRESHMENT_TABLE_1 : GO_REFRESHMENT_TABLE_2);
+                        GameObjectTemplate const* goInfo = sObjectMgr->GetGameObjectTemplate(tableGOForSpell);
+                        if (!goInfo)
+                        {
+                            BotWhisper("Invalid object type", player);
+                            break;
+                        }
+                        float x,y,z;
+                        me->GetClosePoint(x, y, z, me->GetCombatReach(), 0.f, 0.f);
+                        QuaternionData rot = QuaternionData::fromEulerAnglesZYX(me->GetOrientation(), 0.f, 0.f);
+
+                        GameObject* table = new GameObject;
+                        if (!table->Create(me->GetMap()->GenerateLowGuid<HighGuid::GameObject>(), tableGOForSpell, me->GetMap(),
+                            me->GetPhaseMask(), Position(x,y,z,me->GetOrientation()), rot, 255, GO_STATE_READY))
+                        {
+                            delete table;
+                            BotWhisper("Failed to create table", player);
+                            break;
+                        }
+
+                        SetSpellCooldown(43987, 300000);
+
+                        table->SetRespawnTime(180);
+                        //table->SetOwnerGUID(master->GetGUID());
+                        master->AddGameObject(table);
+                        table->SetSpellId(tableSpellId);
+                        me->GetMap()->AddToMap(table);
+
+                        BotWhisper("Done", player);
+                        break;
+                    }
+                    break;
+                }
+                case BOT_CLASS_ROGUE:
+                {
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 1)
+                    {
+                        // Pick Lock
+                        subMenu = true;
+
+                        uint32 count = 0;
+                        uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 1; //BACK
+
+                        //1 Nearest gameobject
+                        GameObject* obj = nullptr;
+                        NearestLockedGameObjectInRangeCheck check(player, 4.f);
+                        Trinity::GameObjectLastSearcher<NearestLockedGameObjectInRangeCheck> searcher(player, obj, check);
+                        Cell::VisitAllObjects(player, searcher, 4.f);
+                        //player->VisitNearbyGridObject(4.f, searcher);
+                        if (obj)
+                        {
+                            std::ostringstream msg;
+                            msg << obj->GetGOInfo()->name << " (dist = " << player->GetExactDist(obj) << ")";
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + ++count);
+                        }
+
+                        //2 Inventory
+                        Item* item = nullptr;
+                        LockEntry const* lockInfo;
+
+                        //backpack
+                        for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                        {
+                            item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                            if (item && item->IsLocked() && item->GetTemplate()->LockID)
+                            {
+                                lockInfo = sLockStore.LookupEntry(item->GetTemplate()->LockID);
+                                if (!lockInfo)
+                                    continue;
+
+                                for (uint8 j = 0; j != MAX_LOCK_CASE; ++j)
+                                {
+                                    if (lockInfo->Type[j] == LOCK_KEY_SKILL && lockInfo->Index[j] == LOCKTYPE_PICKLOCK &&
+                                        lockInfo->Skill[j] <= uint32(15 + creature->GetLevel() * 5))
+                                    {
+                                        std::ostringstream name;
+                                        _AddItemLink(player, item, name, false);
+                                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                        //bags
+                        for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                        {
+                            if (Bag const* bag = player->GetBagByPos(i))
+                            {
+                                for (uint32 j = 0; j != bag->GetBagSize() && count <= maxcounter; j++)
+                                {
+                                    item = player->GetItemByPos(i, j);
+                                    if (item && item->IsLocked() && item->GetTemplate()->LockID)
+                                    {
+                                        lockInfo = sLockStore.LookupEntry(item->GetTemplate()->LockID);
+                                        if (!lockInfo)
+                                            continue;
+
+                                        for (uint8 j = 0; j != MAX_LOCK_CASE; ++j)
+                                        {
+                                            if (lockInfo->Type[j] == LOCK_KEY_SKILL && lockInfo->Index[j] == LOCKTYPE_PICKLOCK &&
+                                                lockInfo->Skill[j] <= uint32(15 + creature->GetLevel() * 5))
+                                            {
+                                                std::ostringstream name;
+                                                _AddItemLink(player, item, name, false);
+                                                AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                                ++count;
+                                                break;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + ++count);
+                    }
+                    else if (action == 2)
+                    {
+                        //Clear poisons (autorefresh is in class ai DoNonCombatActions
+                        RemoveItemClassEnchants();
+                    }
+                    else if (action == 3)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_MH);
+                        //Send list of available poisons on MH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_6; ++i)
+                        {
+                            uint32 possiblePoison = GetAIMiscValue(i);
+                            if (uint32 possiblePoisonMaxRank = GetSpell(possiblePoison))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possiblePoisonMaxRank);
+                                uint32 curMHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH);
+                                bool same = possiblePoison == curMHId;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + possiblePoison);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 4)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_OH);
+                        //Send list of available poisons on OH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_6; ++i)
+                        {
+                            uint32 possiblePoison = GetAIMiscValue(i);
+                            if (uint32 possiblePoisonMaxRank = GetSpell(possiblePoison))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possiblePoisonMaxRank);
+                                uint32 curOHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH);
+                                bool same = possiblePoison == curOHId;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + possiblePoison);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        //Clear enchants (autorefresh is in class ai DoNonCombatActions
+                        RemoveItemClassEnchants();
+                    }
+                    else if (action == 3)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_MH);
+                        //Send list of available enchants on MH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_5; ++i)
+                        {
+                            uint32 possibleEnchant = GetAIMiscValue(i);
+                            if (uint32 possibleEcnhantMaxRank = GetSpell(possibleEnchant))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possibleEcnhantMaxRank);
+                                uint32 curMHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH);
+                                bool same = possibleEnchant == curMHId;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + possibleEnchant);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 4)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_OH);
+                        //Send list of available enchants on OH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_5; ++i)
+                        {
+                            uint32 possibleEnchant = GetAIMiscValue(i);
+                            if (uint32 possibleEcnhantMaxRank = GetSpell(possibleEnchant))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possibleEcnhantMaxRank);
+                                uint32 curOHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH);
+                                bool same = possibleEnchant == curOHId;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, availableInfo->SpellName[0], GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + possibleEnchant);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 5)
+                    {
+                        if (me->GetShapeshiftForm() == FORM_NONE)
+                        {
+                            BotWhisper("I am not shapeshifted", player);
+                            break;
+                        }
+                        removeShapeshiftForm();
+                    }
+
+                    break;
+                }
+                case BOT_CLASS_HUNTER:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        subMenu = true;
+                        uint32 curType = GetAIMiscValue(BOTAI_MISC_PET_TYPE);
+                        for (uint32 i = BOTAI_MISC_PET_AVAILABLE_1; i <= BOTAI_MISC_PET_AVAILABLE_11; ++i)
+                        {
+                            if (uint32 possibleType = GetAIMiscValue(i))
+                            {
+                                std::string name;
+                                if (possibleType == BOT_PET_CUNNING_START)
+                                {
+                                    name = "Random (Cunning)";
+                                    possibleType = urand(BOT_PET_CUNNING_START, BOT_PET_CUNNING_END);
+                                }
+                                else if (possibleType == BOT_PET_FEROCITY_START)
+                                {
+                                    name = "Random (Ferocity)";
+                                    possibleType = urand(BOT_PET_FEROCITY_START, BOT_PET_FEROCITY_END);
+                                }
+                                else if (possibleType == BOT_PET_TENACITY_START)
+                                {
+                                    name = "Random (Tenacity)";
+                                    possibleType = urand(BOT_PET_TENACITY_START, BOT_PET_TENACITY_END);
+                                }
+                                else
+                                {
+                                    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(possibleType);
+                                    ASSERT(cinfo);
+                                    name = cinfo->Name;
+                                }
+                                bool same = possibleType == curType;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, name.c_str(), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + possibleType);
+                            }
+                        }
+                        bool noPet = curType == BOT_PET_INVALID;
+                        AddGossipItemFor(player, noPet ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "<None>", GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + BOT_PET_INVALID);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        subMenu = true;
+                        uint32 curType = GetAIMiscValue(BOTAI_MISC_PET_TYPE);
+                        for (uint32 i = BOTAI_MISC_PET_AVAILABLE_1; i <= BOTAI_MISC_PET_AVAILABLE_5; ++i)
+                        {
+                            if (uint32 possibleType = GetAIMiscValue(i))
+                            {
+                                CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(possibleType);
+                                ASSERT(cinfo);
+                                bool same = possibleType == curType;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, cinfo->Name.c_str(), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + possibleType);
+                            }
+                        }
+                        bool noPet = curType == BOT_PET_INVALID;
+                        AddGossipItemFor(player, noPet ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "<None>", GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + BOT_PET_INVALID);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Auto>", GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 1)
+                    {
+                        if (GetAIMiscValue(6201) == 0)
+                        {
+                            BotWhisper("I don't have a healthstone", player);
+                            break;
+                        }
+
+                        //Prevent high-leveled healthstone for low-level characters
+                        Unit* checker;
+                        if (player->GetLevel() < me->GetLevel())
+                            checker = player;
+                        else
+                            checker = me;
+
+                        static uint32 HealthStones[8] = { 19005,19007,19009,19011,19013,22105,36891,36894 };
+                        uint32 spellId = InitSpell(me, 6201); //Create Healthstone Rank 1
+                        SpellInfo const* spellInfo = spellId ? sSpellMgr->GetSpellInfo(spellId) : nullptr;
+                        if (!spellInfo)
+                        {
+                            BotWhisper("I can't create healthstones yet!", player);
+                            break;
+                        }
+
+                        int8 i = spellInfo->GetRank() - 1;
+                        for (; i != 0; --i)
+                            if (ItemTemplate const* stone = sObjectMgr->GetItemTemplate(HealthStones[i]))
+                                if (stone->RequiredLevel <= checker->GetLevel())
+                                    break;
+
+                        //at least rank 1 (even if player is level 1)
+                        ItemPosCountVec dest;
+                        InventoryResult msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, HealthStones[i], 1);
+                        if (msg != EQUIP_ERR_OK)
+                        {
+                            player->SendEquipError(msg, nullptr, nullptr, HealthStones[i]);
+                            break;
+                        }
+                        Item* item = player->StoreNewItem(dest, HealthStones[i], true, 0);
+                        if (!item)
+                        {
+                            player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
+                            break;
+                        }
+
+                        //remove healthstone
+                        SetAIMiscValue(6201, 0);
+
+                        player->SendNewItem(item, 1, true, false, true);
+                    }
+                    else if (action == 3) //soulwell
+                    {
+                        uint32 wellSpellId = GetSpell(29893); //Ritual of Souls
+                        if (!wellSpellId)
+                        {
+                            BotWhisper("Disabled", player);
+                            break;
+                        }
+                        if (!IsSpellReady(29893, GetLastDiff(), false))
+                        {
+                            BotWhisper("Not ready yet", player);
+                            break;
+                        }
+                        uint32 wellGOForSpell = (wellSpellId == 29893 ? GO_SOULWELL_1 : GO_SOULWELL_2);
+                        GameObjectTemplate const* goInfo = sObjectMgr->GetGameObjectTemplate(wellGOForSpell);
+                        if (!goInfo)
+                        {
+                            BotWhisper("Invalid object type", player);
+                            break;
+                        }
+                        float x,y,z;
+                        me->GetClosePoint(x, y, z, me->GetCombatReach(), 0.f, 0.f);
+                        QuaternionData rot = QuaternionData::fromEulerAnglesZYX(me->GetOrientation(), 0.f, 0.f);
+
+                        GameObject* soulwell = new GameObject;
+                        if (!soulwell->Create(me->GetMap()->GenerateLowGuid<HighGuid::GameObject>(), wellGOForSpell, me->GetMap(),
+                            me->GetPhaseMask(), Position(x,y,z,me->GetOrientation()), rot, 255, GO_STATE_READY))                        {
+                            delete soulwell;
+                            BotWhisper("Failed to create soulwell", player);
+                            break;
+                        }
+
+                        SetSpellCooldown(29893, 300000);
+
+                        soulwell->SetRespawnTime(180);
+                        //soulwell->SetOwnerGUID(master->GetGUID());
+                        master->AddGameObject(soulwell);
+                        soulwell->SetSpellId(wellSpellId);
+                        me->GetMap()->AddToMap(soulwell);
+
+                        BotWhisper("Done", player);
+                        break;
+                    }
+                    break;
+                }
+                case BOT_CLASS_DRUID:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_NONE)
+                    {
+                        BotWhisper("I am not shapeshifted", player);
+                        break;
+                    }
+
+                    removeShapeshiftForm();
+                    break;
+                }
+
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_CLASS_ACTION:
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    if (!IsCasting())
+                    {
+                        // Pick Lock
+                        uint32 picklock = InitSpell(me, 1804);
+                        if (!picklock)
+                        {
+                            BotWhisper("WTF I don't have lockpicking!", player);
+                            break;
+                        }
+
+                        SpellInfo const* Info = sSpellMgr->GetSpellInfo(picklock);
+                        Spell* lockpickspell = new Spell(player, Info, TRIGGERED_NONE, me->GetGUID());
+                        SpellCastTargets targets;
+
+                        if (action == GOSSIP_ACTION_INFO_DEF + 1)
+                        {
+                            //1 Nearest gameobject
+                            GameObject* obj = nullptr;
+                            NearestLockedGameObjectInRangeCheck check(player, 4.f);
+                            Trinity::GameObjectLastSearcher<NearestLockedGameObjectInRangeCheck> searcher(player, obj, check);
+                            Cell::VisitAllObjects(player, searcher, 4.f);
+                            //player->VisitNearbyGridObject(4.f, searcher);
+                            if (obj)
+                            {
+                                targets.SetGOTarget(obj);
+                                lockpickspell->m_targets.SetGOTarget(obj); //for checkCast only
+                            }
+                        }
+                        else
+                        {
+                            //2 Inventory
+                            Item* item = nullptr;
+                            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+                            bool found = false;
+                            //backpack
+                            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                            {
+                                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                                if (item && item->GetGUID().GetCounter() == guidLow)
+                                {
+                                    targets.SetItemTarget(item);
+                                    lockpickspell->m_targets.SetItemTarget(item); //for checkCast only
+                                    found = true;
+                                    break;
+                                }
+                            }
+                            //bags
+                            if (!found)
+                            {
+                                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                                {
+                                    if (Bag const* bag = player->GetBagByPos(i))
+                                    {
+                                        for (uint32 j = 0; j != bag->GetBagSize(); j++)
+                                        {
+                                            item = player->GetItemByPos(i, j);
+                                            if (item && item->GetGUID().GetCounter() == guidLow)
+                                            {
+                                                targets.SetItemTarget(item);
+                                                lockpickspell->m_targets.SetItemTarget(item); //for checkCast only
+                                                found = true;
+                                                break;
+                                            }
+                                        }
+                                    }
+
+                                    if (found)
+                                        break;
+                                }
+                            }
+                        }
+
+                        SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : lockpickspell->CheckCast(false);
+                        if (result != SPELL_CAST_OK)
+                        {
+                            lockpickspell->finish(false);
+                            delete lockpickspell;
+                            if (result == SPELL_FAILED_LOW_CASTLEVEL)
+                                BotWhisper("My skill level in not high enough", player);
+                            else
+                                BotWhisper("Failed", player);
+                        }
+                        else
+                        {
+                            lockpickspell->prepare(targets);
+                            //BotWhisper("Here...", player);
+                        }
+                    }
+                    return OnGossipSelect(player, creature, GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    //break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_CLASS_ACTION2: //set cur MH enchant
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH, baseId);
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH, baseId);
+                    break;
+                }
+            }
+            return OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_CLASS_ACTION3: //set cur OH enchant
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH, baseId);
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH, baseId);
+                    break;
+                }
+            }
+            return OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_CLASS_ACTION4: //set pet type
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_HUNTER:
+                {
+                    uint32 petType = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_PET_TYPE, petType);
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    uint32 petType = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_PET_TYPE, petType);
+                    break;
+                }
+            }
+            return OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_MODEL_UPDATE:
+        {
+            if (Aura* trans = me->AddAura(MODEL_TRANSITION, me))
+            {
+                trans->SetDuration(500);
+                trans->SetMaxDuration(500);
+            }
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Show me your inventory", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //auto-equip
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Auto-equip...", GOSSIP_SENDER_EQUIP_AUTOEQUIP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Main hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_MAINHAND);
+            if (_canUseOffHand())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Off-hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_OFFHAND);
+            if (_canUseRanged())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Ranged...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+            if (_canUseRelic())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Relic...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+
+            //armor
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Head...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HEAD);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Shoulders...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_SHOULDERS);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Chest...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_CHEST);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Waist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WAIST);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Legs...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_LEGS);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Feet...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FEET);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Wrist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WRIST);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "Hands...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HANDS);
+
+            if (IsHumanoidClass(_botclass))
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Back...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BACK);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Shirt...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BODY);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Finger1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER1);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Finger2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER2);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Trinket1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET1);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Trinket2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET2);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Neck...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_NECK);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Unequip all", GOSSIP_SENDER_UNEQUIP_ALL, GOSSIP_ACTION_INFO_DEF + 1);
+            if (creature->GetCreatureTemplate()->unit_flags2 & UNIT_FLAG2_MIRROR_IMAGE)
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Update visual", GOSSIP_SENDER_MODEL_UPDATE, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment list for bot with no equip info!");
+
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                Item const* item = _equips[i];
+                if (!item) continue;
+                std::ostringstream msg;
+                _AddItemLink(player, item, msg/*, false*/);
+                //uncomment if needed
+                //msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                if (i <= BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+                    msg << " |cffe6cc80|h[!visual only!]|h|r";
+                BotWhisper(msg.str().c_str(), player);
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment info for bot with no equip info!");
+
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+            Item const* item = _equips[slot];
+            ASSERT(item);
+
+            std::ostringstream msg;
+            _AddItemLink(player, item, msg, false);
+
+            if (slot <= BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                msg << " |cffe6cc80|h[!visual only!]|h|r";
+
+            BotWhisper(msg.str().c_str(), player);
+
+            //break; //no break here - return to menu
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment show for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+                    if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) &&
+                        /*itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                        (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+                            if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) &&
+                                /*itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                                (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+            std::ostringstream str;
+            str << "Equipped: ";
+            if (Item const* item = _equips[slot])
+            {
+                _AddItemLink(player, item, str);
+                if (slot <= BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                    str << " |cffe6cc80|h[!visual only!]|h|r";
+
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+            }
+            else
+            {
+                str << "nothing";
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            if (_equips[slot])
+            {
+                //s2.2.1 add unequip option if have weapon (GMs only)
+                if (slot <= BOT_SLOT_RANGED)
+                {
+                    if (einfo->ItemEntry[slot] != 0)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Use your old equipment", GOSSIP_SENDER_EQUIP_RESET, action);
+                    else
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+                }
+
+                //s2.2.2 add unequip option for non-weapons
+                if (slot > BOT_SLOT_RANGED)
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+            }
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 4; //unequip, reset, current, back
+                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
+                Item const* item;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + slot, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + slot, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip DEPRECATED
+        {
+            if (!_unequip(action - GOSSIP_ACTION_INFO_DEF))
+            {} //BotWhisper("Impossible...", player);
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP_ALL:
+        {
+            bool suc = true;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    suc = false;
+                    //std::ostringstream estr;
+                    //estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i) << ")!";
+                    //BotWhisper(estr.str().c_str(), player);
+                }
+            }
+
+            if (suc)
+                me->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+
+            break;
+        }
+        //autoequips change s5b: AtoEquip item
+        //base is GOSSIP_SENDER_EQUIP_AUTOEQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY:      //12 - 1 body
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1:   //13 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2:   //14 - 2 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1:  //15 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2:  //16 - 2 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK:      //17 - 1 neck
+        {
+            Item* item = nullptr;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUID().GetCounter() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag const* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUID().GetCounter() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP, item)){}
+
+            [[fallthrough]];
+            //break; //no break: update list
+        }
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP:
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send auto-equip for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //1: build list
+            //1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    bool canEquip = false;
+
+                    for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+                    {
+                        if (_canEquip(pItem->GetTemplate(), k))
+                        {
+                            canEquip = true;
+                            break;
+                        }
+                    }
+
+                    if (canEquip &&/* itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                        (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+
+                            bool canEquip = false;
+
+                            for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(pItem->GetTemplate(), k))
+                                {
+                                    canEquip = true;
+                                    break;
+                                }
+                            }
+
+                            if (canEquip &&/* itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                                (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //2: add gossips
+
+            if (itemList.empty())
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 1; // back
+                Item const* item;
+                //add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            uint8 k = 0;
+                            for (; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(item->GetTemplate(), k))
+                                {
+                                    //workaround for double slots
+                                    //if first slot is occupied and second slot is vacant use second slot
+                                    if (k == BOT_SLOT_FINGER1 || k == BOT_SLOT_TRINKET1)
+                                        if (_equips[k] != nullptr && _canEquip(item->GetTemplate(), k + 1))
+                                            ++k;
+                                    break;
+                                }
+                            }
+
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    uint8 k = 0;
+                                    for (; k != BOT_INVENTORY_SIZE; ++k)
+                                    {
+                                        if (_canEquip(item->GetTemplate(), k))
+                                        {
+                                            //workaround for double slots
+                                            //if first slot is occupied and second slot is vacant use second slot
+                                            if (k == BOT_SLOT_FINGER1 || k == BOT_SLOT_TRINKET1)
+                                                if (_equips[k] != nullptr && _canEquip(item->GetTemplate(), k + 1))
+                                                    ++k;
+                                            break;
+                                        }
+                                    }
+
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (_resetEquipment(action - GOSSIP_ACTION_INFO_DEF)){}
+            break;
+        }
+        //equips change s4b: Equip item
+        //base is GOSSIP_SENDER_EQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //12 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //13 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //15 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //17 - 1 neck
+        {
+            Item* item = nullptr;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUID().GetCounter() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag const* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUID().GetCounter() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP, item)){}
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_MAIN_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            [[fallthrough]];
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_MAIN: //ROLES 1: list
+        {
+            subMenu = true;
+
+            if (IsHumanoidClass(_botclass))
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Gathering...", GOSSIP_SENDER_ROLES_GATHERING, GOSSIP_ACTION_INFO_DEF + 1);
+
+            uint16 role = BOT_ROLE_TANK;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & BOT_ROLE_MASK_MAIN)) //hidden
+                    continue;
+                if (role == BOT_ROLE_HEAL && !IsHealingClass(_botclass))
+                    continue;
+
+                AddGossipItemFor(player, GetRoleIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_MAIN_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_GATHERING_TOGGLE:
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            [[fallthrough]];
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_GATHERING:
+        {
+            subMenu = true;
+
+            uint16 role = BOT_ROLE_GATHERING_MINING;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & BOT_ROLE_MASK_GATHERING)) //hidden
+                    continue;
+
+                AddGossipItemFor(player, GetRoleIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_GATHERING_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+                //if (CheckBotCast(me, basespell, me->GetBotClass()) == SPELL_CAST_OK)
+                    if (IsSpellReady(basespell, lastdiff, true))
+                        doCast(player, GetSpell(basespell));
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF;
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            if (HasAbilitiesSpecifics())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Abilities status...", GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+            if (HasAblitiesAllowedList())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Manage allowed abilities...", GOSSIP_SENDER_ABILITIES_USAGE_LIST, GOSSIP_ACTION_INFO_DEF + 2);
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = itr->first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, lastdiff, false)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                name << "Use ";
+                _AddSpellLink(player, spellInfo, name);
+                AddGossipItemFor(player, GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Update", sender, action);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST:
+        {
+            subMenu = true;
+
+            std::list<std::string> specList;
+            FillAbilitiesSpecifics(specList);
+            for (std::list<std::string>::const_iterator itr = specList.begin(); itr != specList.end(); ++itr)
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, *itr, GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE:
+        {
+            uint32 basespell = action - GOSSIP_ACTION_INFO_DEF;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                if (itr->first == basespell)
+                {
+                    itr->second->enabled = !itr->second->enabled;
+                    break;
+                }
+            }
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST:
+        {
+            subMenu = true;
+
+            uint32 counter = 0;
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = itr->first; //always valid
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                bool skip = false;
+                if (itr->second->spellId == 0) //not init'ed
+                    skip = true;
+                else if (spellInfo->SpellFamilyName == SPELLFAMILY_GENERIC) //not a class spell
+                    skip = true;
+                //spells innate for a class and cannot be disabled
+                else if (basespell == 2457 || basespell == 71 || basespell == 2458)//warrior stances
+                    skip = true;
+                else if (basespell == 48266 || basespell == 48263 || basespell == 48265)//DK stances
+                    skip = true;
+
+                if (skip)
+                    continue;
+
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+                //DEBUG
+                //name << " (" << basespell << ") " << itr->second->spellId;
+                uint8 icon = itr->second->enabled ? BOT_ICON_ON : BOT_ICON_OFF;
+                AddGossipItemFor(player, icon, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE, GOSSIP_ACTION_INFO_DEF + basespell);
+                if (++counter >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                    break;
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_SPEC_SET:
+        {
+            uint8 newSpec = action - GOSSIP_ACTION_INFO_DEF;
+
+            if (newSpec != _spec && newSpec >= BOT_SPEC_BEGIN && newSpec <= BOT_SPEC_END)
+            {
+                _newspec = newSpec;
+                me->CastSpell(me, ACTIVATE_SPEC, false);
+                std::ostringstream specMsg;
+                specMsg << "changing my spec to " << BotTalentSpecStrings[_newspec-1];
+                BotWhisper(specMsg.str().c_str());
+                break;
+            }
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_SPEC:
+        {
+            subMenu = true;
+
+            uint8 specIndex;
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:         specIndex = BOT_SPEC_WARRIOR_ARMS;          break;
+                case BOT_CLASS_PALADIN:         specIndex = BOT_SPEC_PALADIN_HOLY;          break;
+                case BOT_CLASS_HUNTER:          specIndex = BOT_SPEC_HUNTER_BEASTMASTERY;   break;
+                case BOT_CLASS_ROGUE:           specIndex = BOT_SPEC_ROGUE_ASSASINATION;    break;
+                case BOT_CLASS_PRIEST:          specIndex = BOT_SPEC_PRIEST_DISCIPLINE;     break;
+                case BOT_CLASS_DEATH_KNIGHT:    specIndex = BOT_SPEC_DK_BLOOD;              break;
+                case BOT_CLASS_SHAMAN:          specIndex = BOT_SPEC_SHAMAN_ELEMENTAL;      break;
+                case BOT_CLASS_MAGE:            specIndex = BOT_SPEC_MAGE_ARCANE;           break;
+                case BOT_CLASS_WARLOCK:         specIndex = BOT_SPEC_WARLOCK_AFFLICTION;    break;
+                case BOT_CLASS_DRUID:           specIndex = BOT_SPEC_DRUID_BALANCE;         break;
+                default:
+                    TC_LOG_ERROR("entities.unit", "bot_ai:GOSSIP_SENDER_SPEC called for class %u with no specs!", uint32(_botclass));
+                    return true;
+            }
+
+            for (uint8 i = specIndex; i < specIndex + 3; ++i)
+            {
+                uint8 icon = (_spec == i) ? BOT_ICON_ON : BOT_ICON_OFF;
+                std::string specName = BotTalentSpecStrings[i-1];
+                AddGossipItemFor(player, icon, specName.c_str(), GOSSIP_SENDER_SPEC_SET, GOSSIP_ACTION_INFO_DEF + i);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_USEITEM_USE:
+        {
+            if (uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF)
+            {
+                Item const* item = nullptr;
+                bool found = false;
+                for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                {
+                    item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                    if (item && item->GetGUID().GetCounter() == guidLow)
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if (!found)
+                {
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == guidLow)
+                                {
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+                }
+
+                if (found)
+                {
+                    ItemTemplate const* proto = item->GetTemplate();
+                    if (proto->Spells[0].SpellId == 483 || proto->Spells[0].SpellId == 55884)
+                        break;
+
+                    // cast item spell
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(me);
+                    _castBotItemUseSpell(item, targets);
+                }
+            }
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF;
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_USEITEM:
+        {
+            subMenu = true;
+
+            uint32 counter = 0;
+            uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 2; //update, back
+            Item const* item;
+            ItemTemplate const* proto;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                //if (item && item->IsSoulBound()) continue;
+                proto = item ? item->GetTemplate() : nullptr;
+                if (proto && proto->Class == ITEM_CLASS_CONSUMABLE &&
+                    (proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                    proto->SubClass == ITEM_SUBCLASS_FLASK || proto->SubClass == ITEM_SUBCLASS_FOOD ||
+                    proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                    proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) &&
+                    (proto->AllowableClass & (1<<(_botclass-1))) &&
+                    proto->RequiredSkill == 0 &&
+                    proto->RequiredSpell == 0 &&
+                    me->GetLevel() >= proto->RequiredLevel)
+                {
+                    std::ostringstream name;
+                    _AddItemLink(player, item, name);
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_USEITEM_USE, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                    ++counter; //no need to check max counter here
+                }
+            }
+
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize() && counter < maxcounter; j++)
+                    {
+                        item = player->GetItemByPos(i, j);
+                        //if (item && item->IsSoulBound()) continue;
+                        proto = item ? item->GetTemplate() : nullptr;
+                        if (proto && proto->Class == ITEM_CLASS_CONSUMABLE &&
+                            //proto->Spells[0].SpellCategory != SPELL_CATEGORY_FOOD && proto->Spells[0].SpellCategory != SPELL_CATEGORY_DRINK
+                            (proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                            proto->SubClass == ITEM_SUBCLASS_FLASK || proto->SubClass == ITEM_SUBCLASS_FOOD ||
+                            proto->SubClass == ITEM_SUBCLASS_POTION || proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                            proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) &&
+                            (proto->AllowableClass & (1<<(_botclass-1))) &&
+                            proto->RequiredSkill == 0 &&
+                            proto->RequiredSpell == 0 &&
+                            me->GetLevel() >= proto->RequiredLevel)
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_USEITEM_USE, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                        }
+                    }
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Update", sender, action);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_HIRE:
+        {
+            int32 reason = action - GOSSIP_ACTION_INFO_DEF;
+            if (!reason)
+            {
+                if (_ownerGuid)
+                {
+                    //std::ostringstream ostr;
+                    //std::string name;
+                    //ostr << "Go away. I serve my master ";
+                    //if (sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                    //    ostr << name;
+                    //else
+                    //    ostr << "unknown (" << _ownerGuid << ')';
+                    //BotWhisper(ostr.str().c_str(), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until owner dismisses %s", me->GetName().c_str(), (me->GetGender() == GENDER_MALE ? "him" : "her"));
+                    break;
+                }
+
+                if (_botclass == BOT_CLASS_DEATH_KNIGHT && player->GetLevel() < 55)
+                {
+                    BotWhisper("Go away, weakling", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 55", me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_SPHYNX && player->GetLevel() < 60)
+                {
+                    std::string msg1 = me->GetName() + " is not convinced by " + player->GetName() + "'s actions";
+                    me->TextEmote(msg1.c_str());
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 60", me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_ARCHMAGE && player->GetLevel() < 20)
+                {
+                    BotWhisper("I am not going to waste my time on just anything", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 20", me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_DREADLORD && player->GetLevel() < 60)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 60", me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_SPELLBREAKER && player->GetLevel() < 20)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 20", me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_DARK_RANGER && player->GetLevel() < 40)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until you are level 40", me->GetName().c_str());
+                    break;
+                }
+
+                if (SetBotOwner(player))
+                {
+                    if (_botclass == BOT_CLASS_SPHYNX)
+                    {
+                        std::string msg1 = me->GetName() + " makes a grinding sound and begins to follow " + player->GetName();
+                        me->TextEmote(msg1.c_str());
+                    }
+                    else
+                        BotWhisper("I am ready", player);
+                }
+                else
+                    BotSay("...", player);
+            }
+            else if (reason == -1)
+            {
+                me->SetFaction(14);
+                if (botPet)
+                    botPet->SetFaction(14);
+                BotYell("Die!", player);
+                me->Attack(player, true);
+                break;
+            }
+            else
+            {
+                ChatHandler ch(player->GetSession());
+                switch (reason)
+                {
+                    case 1: //has owner
+                    {
+                        std::ostringstream ostr;
+                        std::string name;
+                        ostr << "Go away. I serve my master ";
+                        if (sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                            ostr << name;
+                        else
+                            ostr << "unknown (" << _ownerGuid << ')';
+                        BotWhisper(ostr.str().c_str(), player);
+                        ch.PSendSysMessage("%s will not join you until owner dismisses %s", me->GetName().c_str(), (me->GetGender() == GENDER_MALE ? "him" : "her"));
+                        break;
+                    }
+                    case 2: //max npcbots exceed
+                        ch.PSendSysMessage("You exceed max npcbots (%u)", BotMgr::GetMaxNpcBots());
+                        BotSay("...", player);
+                        break;
+                    case 3: //not enough money
+                    {
+                        std::string str = "You don't have enough money (";
+                        str += BotMgr::GetNpcBotCostStr(player->GetLevel(), _botclass);
+                        str += ")!";
+                        ch.SendSysMessage(str.c_str());
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+                        BotSay("...", player);
+                        break;
+                    }
+                    case 4: //class bots exceed
+                    {
+                        uint8 count = 0;
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                            if (itr->second->GetBotClass() == GetBotClass())
+                                ++count;
+
+                        ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, BotMgr::GetMaxClassBots());
+                        BotSay("...", player);
+                        break;
+                    }
+                    default:
+                        break;
+                }
+            }
+            break;
+        }
+        case GOSSIP_SENDER_DISMISS:
+        {
+            BotMgr* mgr = player->GetBotMgr();
+            ASSERT(mgr);
+
+            //send items to owner -- Unequip all
+            bool abort = false;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i) << ")! Cannot dismiss bot!";
+                    ChatHandler ch(player->GetSession());
+                    ch.SendSysMessage(estr.str().c_str());
+                    abort = true;
+                    break;
+                }
+            }
+
+            if (abort)
+                break;
+
+            mgr->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+            if (Aura* bers = me->AddAura(BERSERK, me))
+            {
+                uint32 dur = 5 * MINUTE * IN_MILLISECONDS;
+                bers->SetDuration(dur);
+                bers->SetMaxDuration(dur);
+            }
+            //if (urand(1,100) <= 25)
+            //{
+            //    me->SetFaction(14);
+            //    if (Creature* pet = GetBotsPet())
+            //        pet->SetFaction(14);
+            //    BotSay("Fool...", player);
+            //    me->Attack(player, true);
+            //}
+            //else
+                BotSay("...", player);
+
+            break;
+        }
+        case GOSSIP_SENDER_JOIN_GROUP:
+        {
+            uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+            switch (option)
+            {
+                case 1: //single bot
+                    player->GetBotMgr()->AddBotToGroup(me);
+                    break;
+                case 2: //all bots
+                {
+                    BotMap const* bmap = player->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator citr = bmap->begin(); citr != bmap->end(); ++citr)
+                    {
+                        if (!citr->second)
+                            continue;
+                        player->GetBotMgr()->AddBotToGroup(citr->second);
+                    }
+                    break;
+                }
+            }
+            break;
+        }
+        case GOSSIP_SENDER_LEAVE_GROUP:
+        {
+            player->GetBotMgr()->RemoveBotFromGroup(me);
+            break;
+        }
+        case GOSSIP_SENDER_HOLDPOSITION:
+        {
+            SetBotCommandState(BOT_COMMAND_STAY);
+            //BotWhisper("Standing still");
+            break;
+        }
+        case GOSSIP_SENDER_DONOTHING:
+        {
+            SetBotCommandState(BOT_COMMAND_FULLSTOP);
+            //BotWhisper("As you wish");
+            break;
+        }
+        case GOSSIP_SENDER_FOLLOWME:
+        {
+            SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+            //BotWhisper("Following");
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION:
+        {
+            subMenu = true;
+            std::ostringstream diststr;
+            diststr << "Follow distance (current: " << uint32(master->GetBotMgr()->GetBotFollowDist()) << ')';
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, diststr.str(),
+                GOSSIP_SENDER_FORMATION_FOLLOW_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 1, "", 0, true);
+
+            if (HasRole(BOT_ROLE_RANGED))
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, "Attack distance...", GOSSIP_SENDER_FORMATION_ATTACK, GOSSIP_ACTION_INFO_DEF + 2);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 3);
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET:
+        {
+            uint32 choice = action - GOSSIP_ACTION_INFO_DEF;
+            if (choice == 1) //short
+            {
+                player->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_SHORT);
+            }
+            else if (choice == 2) //long
+            {
+                player->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_LONG);
+            }
+
+            [[fallthrough]];
+            //break; //return to menu
+        }
+        case GOSSIP_SENDER_FORMATION_ATTACK:
+        {
+            subMenu = true;
+
+            uint8 mode = master->GetBotMgr()->GetBotAttackRangeMode();
+            AddGossipItemFor(player, mode == BOT_ATTACK_RANGE_SHORT ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "Short range attacks", GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, mode == BOT_ATTACK_RANGE_LONG ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, "Long range attacks", GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 2);
+
+            std::ostringstream diststr;
+            if (mode == BOT_ATTACK_RANGE_EXACT)
+                diststr << "Exact (current: " << uint32(master->GetBotMgr()->GetBotExactAttackRange()) << ')';
+            else
+                diststr << "Exact (0-50)";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, mode == BOT_ATTACK_RANGE_EXACT ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT,
+                diststr.str(), GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 3, "", 0, true);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 4);
+            break;
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING_AURA:
+        {
+            uint32 spellId = action - GOSSIP_ACTION_INFO_DEF;
+            Unit::AuraMap const& auras = me->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+            {
+                if (itr->first != spellId)
+                    continue;
+
+                SpellInfo const* info = itr->second->GetSpellInfo();
+                if (info->IsChanneled())
+                    if (Spell const* curSpell = me->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+                        if (curSpell->m_spellInfo->Id == spellId)
+                            me->InterruptSpell(CURRENT_CHANNELED_SPELL);
+
+                //Debug
+                //std::ostringstream msg;
+                //msg << "Removing ";
+                //_AddSpellLink(player, info, msg);
+                //msg << " by ";
+                //ObjectGuid casterGuid = itr->second->GetCasterGUID();
+                //Unit* caster = casterGuid ? ObjectAccessor::GetUnit(*me, casterGuid) : nullptr;
+                //if (caster)
+                //{
+                //    if (casterGuid == me->GetGUID())
+                //        msg << "me";
+                //    else
+                //        msg << caster->GetName();
+                //}
+                //else
+                //    msg << "Unknown unit";
+                //BotWhisper(msg.str().c_str());
+
+                me->RemoveOwnedAura(spellId, ObjectGuid::Empty, 0, AURA_REMOVE_BY_CANCEL);
+                break;
+            }
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF + 2; //return to the list and update
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING_FIX:
+        {
+            uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+            switch (option)
+            {
+                //MOVED TO RECEIVEEMOTE
+                //case 1: //Bot is not mounting, not following while player is mounted
+                //{
+                //    //Reason: creature can sometimes retain UNIT_FLAG_X and UNIT_STATE_X
+                //    //rare occasion, even for bots, you can still talk to them so yeah, stange
+                //    if (me->HasUnitState(UNIT_STATE_STUNNED) && !me->HasAuraType(SPELL_AURA_MOD_STUN))
+                //    {
+                //        me->ClearUnitState(UNIT_STATE_STUNNED);
+                //        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_STUNNED);
+                //    }
+                //    if (me->HasUnitState(UNIT_STATE_CONFUSED) && !me->HasAuraType(SPELL_AURA_MOD_CONFUSE))
+                //    {
+                //        me->ClearUnitState(UNIT_STATE_CONFUSED);
+                //        me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_CONFUSED);
+                //    }
+                //    break;
+                //}
+                case 2: //Remove a visible buff
+                {
+                    subMenu = true;
+                    uint32 count = 0;
+                    Unit::AuraMap const& auras = me->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        SpellInfo const* info = itr->second->GetSpellInfo();
+                        //spells we cannot remove
+                        //1 passive, negative spells, hidden, locked, shapeshift spells (no hook for that)
+                        if (info->IsPassive() || !info->IsPositive())
+                            continue;
+                        if ((info->Attributes & (SPELL_ATTR0_CANT_CANCEL | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) ||
+                            (info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+                            continue;
+                        if (info->HasAura(SPELL_AURA_MOD_SHAPESHIFT))
+                            continue;
+                        //2 custom list
+                        //2.1 Leader of the Pack AOE (supposed to be passive)
+                        if (info->Id == 24932)
+                            continue;
+                        //2.2 Tree of Life AOE (supposed to be passive)
+                        if (info->Id == 34123)
+                            continue;
+                        //2.3 Moonkin Aura AOE (supposed to be passive)
+                        if (info->Id == 24907)
+                            continue;
+                        //2.4 Blood Pact AOE (supposed to be passive)
+                        if (info->GetFirstRankSpell()->Id == 6307)
+                            continue;
+                        //2.5 Fel Intelligence AOE (supposed to be passive)
+                        if (info->GetFirstRankSpell()->Id == 54424)
+                            continue;
+
+                        std::ostringstream msg;
+                        _AddSpellLink(player, info, msg);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_TROUBLESHOOTING_AURA, GOSSIP_ACTION_INFO_DEF + itr->first);
+
+                        if (++count >= BOT_GOSSIP_MAX_ITEMS - 2) //update, back
+                            break;
+                    }
+
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Update", sender, action);
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    break;
+                }
+                case 3: //Fix Powers
+                {
+                    InitPowers();
+                    break;
+                }
+                default:
+                    //BotWhisper("Unknown action in GOSSIP_SENDER_TROUBLESHOOTING_FIX", player);
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING:
+        {
+            subMenu = true;
+            //AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Fix not mounting/following", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Remove buff...", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 2);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Fix your power type", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 3);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 4);
+            break;
+        }
+        case GOSSIP_SENDER_DEBUG_ACTION:
+        {
+            //!!! player != owner !!!
+            bool close = true;
+            switch (action - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 1: //reset owner
+                    if (!IAmFree())
+                        master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+                    else
+                    {
+                        uint32 newOwner = 0;
+                        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+                        ResetBotAI(BOTAI_RESET_DISMISS);
+                    }
+                    break;
+                case 2: //reset stats
+                    spawned = false;
+                    DefaultInit();
+                    break;
+                case 3: //list stats
+                    close = false;
+                    ReceiveEmote(player, TEXT_EMOTE_BONK);
+                    break;
+                case 4: //list roles
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Roles:", me->GetName().c_str());
+                    for (uint16 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+                    {
+                        if (_roleMask & i)
+                        {
+                            switch (i)
+                            {
+                                case BOT_ROLE_TANK:
+                                    ch.SendSysMessage("BOT_ROLE_TANK");
+                                    break;
+                                case BOT_ROLE_DPS:
+                                    ch.SendSysMessage("BOT_ROLE_DPS");
+                                    break;
+                                case BOT_ROLE_HEAL:
+                                    ch.SendSysMessage("BOT_ROLE_HEAL");
+                                    break;
+                                //case BOT_ROLE_MELEE:
+                                //    ch.SendSysMessage("BOT_ROLE_MELEE");
+                                //    break;
+                                case BOT_ROLE_RANGED:
+                                    ch.SendSysMessage("BOT_ROLE_RANGED");
+                                    break;
+                                case BOT_ROLE_PARTY:
+                                    ch.SendSysMessage("BOT_ROLE_PARTY");
+                                    break;
+                                default:
+                                    ch.PSendSysMessage("BOT_ROLE_%u",i);
+                                    break;
+                            }
+                        }
+                    }
+                    break;
+                }
+                case 5: //list spells
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Spells:", me->GetName().c_str());
+                    uint32 counter = 0;
+                    SpellInfo const* spellInfo;
+                    BotSpellMap const& myspells = GetSpellMap();
+                    for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                    {
+                        //if (itr->second->spellId == 0)
+                        //    continue;
+
+                        ++counter;
+                        std::ostringstream sstr;
+                        spellInfo = sSpellMgr->GetSpellInfo(itr->first); //always valid
+                        _AddSpellLink(player, spellInfo, sstr);
+                        sstr << " id: " <<  itr->second->spellId << ", base: " << itr->first
+                            << ", cd: " << itr->second->cooldown << ", base: " << std::max<uint32>(spellInfo->RecoveryTime, spellInfo->CategoryRecoveryTime);
+                        if (itr->second->enabled == false)
+                            sstr << " (disabled)";
+                        ch.PSendSysMessage("%u) %s", counter, sstr.str().c_str());
+                    }
+                    break;
+                }
+                case 6: //reload config
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+
+                    TC_LOG_INFO("misc", "Re-Loading config settings...");
+                    sWorld->LoadConfigSettings(true);
+                    sMapMgr->InitializeVisibilityDistanceInfo();
+                    ch.SendGlobalGMSysMessage("World config settings reloaded.");
+                    BotMgr::ReloadConfig();
+                    ch.SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+
+                    break;
+                }
+                default:
+                    close = false;
+                    break;
+            }
+
+            if (close)
+                break;
+
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_DEBUG:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            std::ostringstream ostr;
+            std::string name;
+            ostr << "Bot: " << me->GetName()
+                << " (Id: " << me->GetEntry()
+                << ", guidlow: " << me->GetGUID().GetCounter()
+                << ", spec: " << uint32(_spec) << '(' << BotTalentSpecStrings[_spec-1] << ')'
+                << ", faction: " << me->GetFaction()
+                << "). owner: ";
+            if (_ownerGuid && sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                ostr << name << " (" << _ownerGuid << ')';
+            else
+                ostr << "none";
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, ostr.str().c_str(), GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 0);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Reset Owner>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Reset Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 2);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<List Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 3);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<List Roles>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 4);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<List Spells>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 5);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Reload Config>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 6);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+            break;
+        }
+        case GOSSIP_SENDER_SCAN:
+        {
+            subMenu = true;
+
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    gossipTextId = GOSSIP_CLASSDESC_BM;
+                    break;
+                case BOT_CLASS_SPHYNX:
+                    gossipTextId = GOSSIP_CLASSDESC_SPHYNX;
+                    break;
+                case BOT_CLASS_ARCHMAGE:
+                    gossipTextId = GOSSIP_CLASSDESC_ARCHMAGE;
+                    break;
+                case BOT_CLASS_DREADLORD:
+                    gossipTextId = GOSSIP_CLASSDESC_DREADLORD;
+                    break;
+                case BOT_CLASS_SPELLBREAKER:
+                    gossipTextId = GOSSIP_CLASSDESC_SPELLBREAKER;
+                    break;
+                case BOT_CLASS_DARK_RANGER:
+                    gossipTextId = GOSSIP_CLASSDESC_DARKRANGER;
+                    break;
+                default:
+                    break;
+            }
+
+            //AddGossipItemFor(player, GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->PlayerTalkClass->SendCloseGossip();
+
+    return true;
+}
+
+//GossipSelectCode
+bool bot_ai::OnGossipSelectCode(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action, char const* code)
+{
+    if (!*code)
+        return true;
+
+    if (!BotMgr::IsNpcBotModEnabled() || me->HasUnitState(UNIT_STATE_CASTING) || CCed(me) || IsDuringTeleport())
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    uint32 gossipTextId;
+    if (player->GetGUID().GetCounter() == _ownerGuid || !IAmFree())
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DARKRANGER;
+        else
+            gossipTextId = GOSSIP_NORMAL_SERVE_MASTER;
+    }
+    else
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DARKRANGER;
+        else
+            gossipTextId = GOSSIP_GREET_NEED_SMTH;
+    }
+
+    player->PlayerTalkClass->ClearMenus();
+
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case GOSSIP_SENDER_FORMATION_FOLLOW_DISTANCE_SET:
+        {
+            char* dist = strtok((char*)code, "");
+            uint8 distance = (uint8)std::min<int32>(std::max<int32>(atoi(dist), 0), 100);
+
+            player->GetBotMgr()->SetBotFollowDist(distance);
+
+            player->PlayerTalkClass->SendCloseGossip();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION, action);
+        }
+        case GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET:
+        {
+            uint32 choice = action - GOSSIP_ACTION_INFO_DEF;
+            if (choice == 3) //exact
+            {
+                char* dist = strtok((char*)code, "");
+                uint8 distance = (uint8)std::min<int32>(std::max<int32>(atoi(dist), 0), 50);
+
+                player->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_EXACT, distance);
+            }
+
+            player->PlayerTalkClass->SendCloseGossip();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION_ATTACK, action);
+        }
+        default:
+            break;
+    }
+
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->PlayerTalkClass->SendCloseGossip();
+
+    return true;
+}
+//PvP trinket for minions
+void bot_ai::BreakCC(uint32 diff)
+{
+    if (_botclass < BOT_CLASS_EX_START && me->GetLevel() >= 60 && IsSpellReady(PVPTRINKET, diff, false) &&
+        CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()) && Rand() < 20)
+    {
+        if (doCast(me, PVPTRINKET))
+            return;
+    }
+
+    uint8 myrace = me->GetRace();
+
+    //Racial 6) Every Man for Himself
+    if (myrace == RACE_HUMAN && IsSpellReady(RACIAL_EVERY_MAN_FOR_HIMSELF, diff, false) && CCed(me, true) &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && Rand() < 40 && !IsCasting() &&
+        (me->GetLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)))
+    {
+        if (doCast(me, RACIAL_EVERY_MAN_FOR_HIMSELF))
+            return;
+    }
+    //Racial 5) Forsaken (Will of the Forsaken)
+    if (myrace == RACE_UNDEAD_PLAYER && IsSpellReady(RACIAL_WILL_OF_THE_FORSAKEN, diff, false) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && CCed(me) &&
+        Rand() < 10 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting() &&
+        (me->GetLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)) &&
+        me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+    {
+        if (doCast(me, RACIAL_WILL_OF_THE_FORSAKEN))
+            return;
+    }
+    //Racial 7) Escape Artist
+    if (me->GetRace() == RACE_GNOME && IsSpellReady(RACIAL_ESCAPE_ARTIST, diff, false) && CCed(me, true) &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && Rand() < 40 && !IsCasting() &&
+        (me->GetLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)) &&
+        me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+    {
+        if (doCast(me, RACIAL_ESCAPE_ARTIST))
+            return;
+    }
+}
+//Racial abilities
+void bot_ai::CheckRacials(uint32 diff)
+{
+    //At this point checked CCed and pots
+    uint8 myrace = me->GetRace();
+    //Racial 1) Tauren (War Stomp)
+    if (myrace == RACE_TAUREN && IsSpellReady(RACIAL_WARSTOMP, diff, false) &&
+        (!IsTank() || me->GetShapeshiftForm() == FORM_NONE) &&
+        Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        Unit const* u = me->SelectNearestTarget(7);
+        if (u && u->IsInCombat() && !CCed(u) && u->isTargetableForAttack() && IsInBotParty(u->GetVictim()) && me->IsWithinLOSInMap(u))
+        {
+            if (doCast(me, RACIAL_WARSTOMP))
+                return;
+        }
+    }
+    //Racial 2) Orc (Blood Fury)
+    if (myrace == RACE_ORC)
+    {
+        uint32 bloodFury = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(bloodFury, diff, false) && me->GetVictim() && GetHealthPCT(me) > 35 && !CCed(me, true) &&
+            (me->GetVictim()->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1) &&
+            Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+        {
+            if (doCast(me, bloodFury))
+                return;
+        }
+    }
+    //Racial 3) Dwarf (Stoneform)
+    if (myrace == RACE_DWARF && IsSpellReady(RACIAL_STONEFORM, diff, false) && GetHealthPCT(me) < 80 &&
+        Rand() < 10 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        //Unholy Blight prevents diseases from being dispelled
+        uint32 const dispelMask = me->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0) ?
+            (1<<DISPEL_POISON) : (1<<DISPEL_DISEASE)|(1<<DISPEL_POISON);
+        uint8 count = 0;
+        Unit::AuraMap const& auras = me->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            Aura const* aura = itr->second;
+
+            if (aura->IsPassive())
+                continue;
+
+            AuraApplication const* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+            if (!aurApp)
+                continue;
+            if (aurApp->IsPositive())
+                continue;
+
+            if ((aura->GetSpellInfo()->GetDispelMask() & dispelMask) ||
+                aura->GetSpellInfo()->Mechanic == MECHANIC_BLEED)
+                if (++count > 1)
+                    break;
+        }
+
+        if (count > 1 - 1*(me->IsInCombat()) && doCast(me, RACIAL_STONEFORM))
+            return;
+    }
+    //Racial 4) Night Elf (Shadowmeld)
+    if (myrace == RACE_NIGHTELF && IsSpellReady(RACIAL_SHADOWMELD, diff, false) && !me->IsInCombat() && me->GetVictim() &&
+        me->GetVictim()->GetTypeId() == TYPEID_PLAYER && Rand() < 50 &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        if (Spell const* spell = me->GetVictim()->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+        {
+            if (spell->m_targets.GetUnitTarget() == me && spell->GetTimer() < 500 &&
+                spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                if (doCast(me, RACIAL_SHADOWMELD))
+                    return;
+        }
+    }
+    //Racial 8) Troll (Berserking)
+    if (myrace == RACE_TROLL && IsSpellReady(RACIAL_BERSERKING, diff, false) && me->GetVictim() &&
+        GetHealthPCT(me) > 35 && !CCed(me, true) &&
+        (me->GetVictim()->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1) &&
+        Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        if (doCast(me, RACIAL_BERSERKING))
+            return;
+    }
+    //Racial 9) Blood Elf (Arcane Torrent)
+    if (myrace == RACE_BLOODELF)
+    {
+        uint32 arcaneTorrent = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(arcaneTorrent, diff, false) && !IsCasting() && !Feasting())
+        {
+            Unit const* victim = me->GetVictim();
+            if (victim && victim->IsNonMeleeSpellCast(false, false, true) &&
+                (me->GetVictim()->GetHealth() > me->GetHealth() / 4 || me->getAttackers().size() > 1) &&
+                me->GetDistance(victim) < 7 && Rand() < 30 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            {
+                if (Spell const* spell = victim->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (IsInBotParty(spell->m_targets.GetUnitTarget()) && spell->GetTimer() < 1000)
+                        if (doCast(me, arcaneTorrent))
+                            return;
+                }
+            }
+            else if (GetManaPCT(me) < 25)
+                if (doCast(me, arcaneTorrent))
+                    return;
+        }
+    }
+    //Racial 10) Draenei (Gift of The Naaru) - self only
+    if (myrace == RACE_DRAENEI)
+    {
+        uint32 giftOfNaaru = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(giftOfNaaru, diff, false) && (me->IsInCombat() || !me->getAttackers().empty()) &&
+            GetHealthPCT(me) < 60 - 10*me->HasAuraType(SPELL_AURA_PERIODIC_HEAL) &&
+            Rand() < 50 && !IsCasting())
+        {
+            if (doCast(me, giftOfNaaru))
+                return;
+        }
+    }
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return;
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+    else if (!IsMelee() && opponent)
+        return;
+    //if (InDuel(attacker))
+    //    return;
+
+    bool byspell = false;
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            byspell = GetBotStance() == BOT_STANCE_NONE || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+            byspell = true;
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "minion_ai: OnOwnerDamagedBy() - unknown bot class %u", uint8(_botclass));
+            break;
+    }
+
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    SetBotCommandState(BOT_COMMAND_COMBATRESET); //reset AttackStart()
+    me->Attack(attacker, !HasRole(BOT_ROLE_RANGED));
+}
+//////////
+//EQUIPS//
+//////////
+bool bot_ai::_canUseOffHand() const
+{
+    //bm can on only equip in main hand
+    if (_botclass == BOT_CLASS_BM)
+        return false;
+    //sphynx can grab anything
+    if (_botclass == BOT_CLASS_SPHYNX)
+        return true;
+    //dreadlord can on only equip in main hand
+    if (_botclass == BOT_CLASS_DREADLORD)
+        return false;
+
+    //warrior can wield any offhand with titan's grip
+    if (_botclass == BOT_CLASS_WARRIOR && me->GetLevel() >= 60 && _spec == BOT_SPEC_WARRIOR_FURY)
+        return true;
+
+    ItemTemplate const* protoMH = _equips[BOT_SLOT_MAINHAND] ? _equips[BOT_SLOT_MAINHAND]->GetTemplate() : nullptr;
+
+    //no mainhand weapon OR
+    //mainhand is an one-hand weapon
+    if (!protoMH)
+        return true;
+
+    if (protoMH->Class == ITEM_CLASS_WEAPON &&
+        (protoMH->InventoryType == INVTYPE_WEAPON || protoMH->InventoryType == INVTYPE_WEAPONMAINHAND) &&
+        (protoMH->SubClass == ITEM_SUBCLASS_WEAPON_AXE || protoMH->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+        protoMH->SubClass == ITEM_SUBCLASS_WEAPON_FIST || protoMH->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+        protoMH->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+        return true;
+
+    //NO
+    return false;
+}
+
+bool bot_ai::_canUseRanged() const
+{
+    return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PRIEST ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK ||
+        _botclass == BOT_CLASS_DARK_RANGER);
+}
+
+bool bot_ai::_canUseRelic() const
+{
+    return (_botclass == BOT_CLASS_PALADIN || _botclass == BOT_CLASS_SHAMAN ||
+        _botclass == BOT_CLASS_DRUID || _botclass == BOT_CLASS_DEATH_KNIGHT);
+}
+
+bool bot_ai::_canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel) const
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    if (Item const* oldItem = _equips[slot])
+    {
+        ItemTemplate const* oldProto = oldItem->GetTemplate();
+        //prevent reequipping same items
+        if (item->ItemId == oldProto->ItemId && !oldItem->GetItemRandomPropertyId())
+            return false;
+        //prevent equipping worse items (only standard or not)
+        if (!ignoreItemLevel)
+            if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != oldProto->ItemId)
+                if (IAmFree() || !master->IsGameMaster())
+                    if (oldProto->ItemLevel > item->ItemLevel)
+                        return false;
+    }
+
+    if (slot == BOT_SLOT_OFFHAND && !_canUseOffHand())
+        return false;
+
+    //level requirements
+    if (me->GetLevel() < item->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (_botclass < BOT_CLASS_EX_START && !(item->AllowableClass & (1<<(_botclass-1))))
+        return false;
+
+    //skip race requirements
+
+    //inventory related conditions
+    if (item->Class == ITEM_CLASS_WEAPON)
+    {
+        switch (slot)
+        {
+            case BOT_SLOT_MAINHAND:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                        if (item->SubClass != ITEM_SUBCLASS_WEAPON_POLEARM &&
+                            item->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                            item->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2)
+                            return false;
+                        break;
+                    case BOT_CLASS_ARCHMAGE:
+                        if (item->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                            return false;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case BOT_SLOT_OFFHAND:
+                if (item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || item->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_ROGUE:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_HUNTER:
+                        if (me->GetLevel() < 20)
+                            return false;
+                        break;
+                    case BOT_CLASS_SHAMAN:
+                        if (me->GetLevel() < 40 || _spec != BOT_SPEC_SHAMAN_ENHANCEMENT)
+                            return false;
+                        break;
+                    case BOT_CLASS_SPHYNX:
+                        break;
+                    case BOT_CLASS_DARK_RANGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_SLOT_RANGED:
+                if (!_canUseRanged())
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (item->InventoryType)
+        {
+            case INVTYPE_WEAPONMAINHAND:
+                if (slot != BOT_SLOT_MAINHAND)
+                    return false;
+                break;
+            case INVTYPE_WEAPONOFFHAND:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_2HWEAPON:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                        switch (slot)
+                        {
+                            case BOT_SLOT_OFFHAND:
+                                if (me->GetLevel() < 60)
+                                    return false;
+                                break;
+                            case BOT_SLOT_RANGED:
+                                return false;
+                            default:
+                                break;
+                        }
+                        break;
+                    case BOT_CLASS_SPHYNX:
+                        break;
+                    default:
+                        if (slot != BOT_SLOT_MAINHAND)
+                            return false;
+                        break;
+                }
+                break;
+            case INVTYPE_WEAPON:
+                if (slot != BOT_SLOT_MAINHAND && slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_THROWN:
+            case INVTYPE_RANGED:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            case INVTYPE_RANGEDRIGHT:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        if (slot != BOT_SLOT_MAINHAND && slot != BOT_SLOT_OFFHAND)
+                            return false;
+                        break;
+                    default:
+                        if (slot != BOT_SLOT_RANGED)
+                            return false;
+                        break;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                    //case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_DEATH_KNIGHT:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_HUNTER:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    //case ITEM_SUBCLASS_WEAPON_MACE:
+                    //case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    //case ITEM_SUBCLASS_WEAPON_THROWN: //hunters can use thrown but bots can't, also pointless
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_ROGUE:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_PRIEST:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DRUID:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SHAMAN:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_BM:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SPHYNX:
+                switch (item->SubClass)
+                {
+                    //case ITEM_SUBCLASS_WEAPON_MACE:
+                    //case ITEM_SUBCLASS_WEAPON_MACE2:
+                    //case ITEM_SUBCLASS_WEAPON_SWORD:
+                    //case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    //case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_ARCHMAGE:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DREADLORD:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SPELLBREAKER:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DARK_RANGER:
+                switch (item->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        return true;
+    }
+    else if (item->Class == ITEM_CLASS_ARMOR/* || item->Class == ITEM_CLASS_QUEST*/)
+    {
+        switch (item->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;;
+                }
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;;
+                }
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;;
+                }
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;;
+                }
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;;
+                }
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;;
+                }
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (item->SubClass)
+        {
+            case ITEM_SUBCLASS_ARMOR_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPELLBREAKER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_SHAMAN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_PLATE:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SPHYNX:
+                    case BOT_CLASS_DREADLORD:
+                    case BOT_CLASS_SPELLBREAKER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        if (me->GetLevel() >= 40 || item->Quality == ITEM_QUALITY_HEIRLOOM)
+                            break;
+                        return false;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_MAIL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SPHYNX:
+                    case BOT_CLASS_SPELLBREAKER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        break;
+                    case BOT_CLASS_SHAMAN:
+                    case BOT_CLASS_HUNTER:
+                        if (me->GetLevel() >= 40 || item->Quality == ITEM_QUALITY_HEIRLOOM)
+                            break;
+                        return false;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_LEATHER:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DARK_RANGER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SHAMAN:
+                    case BOT_CLASS_HUNTER:
+                    case BOT_CLASS_ROGUE:
+                    case BOT_CLASS_DRUID:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_CLOTH:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    case BOT_CLASS_DREADLORD:
+                    case BOT_CLASS_SPELLBREAKER:
+                        if (item->InventoryType != INVTYPE_CLOAK)
+                            return false;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_MISC:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_LIBRAM:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_PALADIN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_IDOL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DRUID:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_TOTEM:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SHAMAN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_SIGIL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+bool bot_ai::_unequip(uint8 slot)
+{
+    ASSERT(!IAmFree());
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to unequip item for bot with no equip info!");
+
+    Item* item = _equips[slot];
+    if (!item)
+        return true; //already unequipped
+
+    uint32 itemId = item->GetEntry();
+
+    RemoveItemBonuses(slot);
+    ApplyItemSetBonuses(item, false);
+
+    //hand old weapon to master
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+    {
+        ItemPosCountVec dest;
+        uint32 no_space = 0;
+        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+        if (msg != EQUIP_ERR_OK)
+        {
+            std::ostringstream istr, iistr;
+            istr << "Cannot unequip ";
+            _AddItemLink(master, item, iistr, false);
+            istr << iistr.str() << " for some stupid reason! Sending through mail";
+            ChatHandler ch(master->GetSession());
+            ch.SendSysMessage(istr.str().c_str());
+
+            //MailHnadler::HandleSendMail()
+            item->SetOwnerGUID(master->GetGUID());
+
+            CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+            item->SaveToDB(trans);
+            MailDraft(iistr.str(), "").AddItem(item).SendMailTo(trans, MailReceiver(master), MailSender(me));
+            CharacterDatabase.CommitTransaction(trans);
+
+            //master->SendEquipError(msg, nullptr, nullptr, itemId);
+            //return false;
+        }
+        else
+        {
+            Item* pItem = master->StoreItem(dest, item, true);
+            master->SendNewItem(pItem, 1, true, false, false);
+        }
+    }
+    else
+    {
+        //slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == itemId
+        //we have our standard weapon which we should get rid of
+        //item->SetState(ITEM_REMOVED, master); //delete Item object
+        delete item; //!Invalidated!
+        //item = nullptr; //already in "_updateEquips(slot, nullptr);"
+    }
+
+    if (slot <= BOT_SLOT_RANGED && CanChangeEquip(slot)) //weapons
+    {
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), BASE_ATTACK_TIME); //without weapon
+    }
+
+    _updateEquips(slot, nullptr);
+
+    //offhand check
+    if (slot == BOT_SLOT_OFFHAND)
+    {
+        if (me->CanDualWield())
+            me->SetCanDualWield(false);
+        if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+    }
+
+    return true;
+}
+
+bool bot_ai::_equip(uint8 slot, Item* newItem)
+{
+    ASSERT(!IAmFree());
+    ASSERT(newItem);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to equip item for bot with no equip info!");
+
+    ItemTemplate const* proto = newItem->GetTemplate();
+
+    if (newItem->GetState() == ITEM_REMOVED)
+    {
+        TC_LOG_ERROR("entities.player",
+            "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) which has state ITEM_REMOVED!",
+            master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUID().GetCounter());
+        return false;
+    }
+
+    uint32 newItemId = newItem->GetEntry();
+
+    if (Item const* oldItem = _equips[slot])
+    {
+        //same id
+        if (oldItem->GetEntry() == newItemId && !newItem->GetItemRandomPropertyId())
+            return false;
+    }
+
+    if (!_unequip(slot))
+    {
+        //BotWhisper("You have no space for my current item", master);
+        return false;
+    }
+
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+    {
+        //cheating
+        if (newItem->GetOwnerGUID() != master->GetGUID() || !master->HasItemCount(newItemId, 1))
+        {
+            //std::ostringstream msg;
+            //msg << "Cannot find ";
+            //_AddItemLink(master, newItem, msg, false);
+            //msg << " (id: " << uint32(newItemId) << ")!";
+            //BotWhisper(msg.str().c_str());
+
+            TC_LOG_ERROR("entities.player",
+                "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) but either does not have this item or does not own it",
+                master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUID().GetCounter());
+            return false;
+        }
+
+        master->MoveItemFromInventory(newItem->GetBagSlot(), newItem->GetSlot(), true);
+        //Item is removed from inventory table in _updateEquips(slot, newItem);
+        newItem->SetOwnerGUID(ObjectGuid::Empty); //needed to prevent some logs to be sent to master, restored at unequip
+    }
+
+    if (slot <= BOT_SLOT_RANGED)
+    {
+        if (CanChangeEquip(slot))
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, newItemId);
+        uint32 delay =
+            /*einfo->ItemEntry[slot] != newItemId || */RespectEquipsAttackTime() || slot == BOT_SLOT_OFFHAND ? proto->Delay :
+            slot == BOT_SLOT_RANGED ? me->GetCreatureTemplate()->RangeAttackTime : me->GetCreatureTemplate()->BaseAttackTime;
+        //attack time will be updated in SetStats() -> OnMeleeDamageUpdate()
+        if (!me->IsInFeralForm())
+            me->SetAttackTime(WeaponAttackType(slot), delay); //set attack speed
+    }
+
+    _updateEquips(slot, newItem);
+
+    //only for non-standard items
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+        ApplyItemBonuses(slot);
+    ApplyItemSetBonuses(newItem, true);
+
+    if (slot == BOT_SLOT_OFFHAND)
+    {
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            if (!me->CanDualWield())
+                me->SetCanDualWield(true);
+        }
+        else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else if (slot == BOT_SLOT_MAINHAND)
+    {
+        if (proto->InventoryType == INVTYPE_2HWEAPON && !(_botclass == BOT_CLASS_WARRIOR && me->GetLevel() >= 60 && _spec == BOT_SPEC_WARRIOR_FURY))
+        {
+            //if have incompatible offhand unequip it
+            if (_equips[BOT_SLOT_OFFHAND] != nullptr)
+                _unequip(BOT_SLOT_OFFHAND);
+        }
+        else if (_equips[BOT_SLOT_OFFHAND] == nullptr && einfo->ItemEntry[BOT_SLOT_OFFHAND])
+            _resetEquipment(BOT_SLOT_OFFHAND);
+    }
+
+    //send info to class ai
+    if (proto->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot == BOT_SLOT_MAINHAND)
+        {
+            SetAIMiscValue(BOTAI_MISC_DAGGER_MAINHAND, proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER);
+            SetAIMiscValue(BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH, newItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+            SetAIMiscValue(BOTAI_MISC_WEAPON_SPEC, proto->SubClass);
+        }
+        if (slot == BOT_SLOT_OFFHAND)
+        {
+            SetAIMiscValue(BOTAI_MISC_DAGGER_OFFHAND, proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER);
+            SetAIMiscValue(BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH, newItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+        }
+    }
+
+    return true;
+}
+
+void bot_ai::_updateEquips(uint8 slot, Item* item)
+{
+    _equips[slot] = item;
+    BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_EQUIPS, _equips);
+}
+//Called from gossip menu only (applies only to weapons)
+bool bot_ai::_resetEquipment(uint8 slot)
+{
+    ASSERT(!IAmFree());
+    ASSERT(slot <= BOT_SLOT_RANGED);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to reset equipment for bot with no equip info!");
+
+    uint32 itemId = einfo->ItemEntry[slot];
+    if (!itemId)
+        return _unequip(slot);
+    else if (Item const* oldItem = _equips[slot])
+        if (oldItem->GetEntry() == itemId)
+            return true;
+
+    if (slot == BOT_SLOT_MAINHAND && !(_botclass == BOT_CLASS_WARRIOR && me->GetLevel() >= 60 && _spec == BOT_SPEC_WARRIOR_FURY))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+            {
+                if (!_unequip(BOT_SLOT_OFFHAND))
+                    return false;
+            }
+        }
+    }
+
+    //we have our standard weapon itemId which we should use to create new item
+    Item* stItem = Item::CreateItem(itemId, 1, nullptr);
+    ASSERT(stItem && "Failed to create standard Item for bot!");
+
+    if (!_equip(slot, stItem))
+    {
+        TC_LOG_ERROR("entities.player", "minion_ai::_resetEquipment(): player %s (guidLow: %u) failed to reset equipment for bot %s (id: %u) in slot %u",
+            master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str(), me->GetEntry(), slot);
+        return false;
+    }
+    return true;
+}
+
+void bot_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : nullptr;
+
+    uint32 ssd_level = me->GetLevel();
+    if (ssd && ssd_level > ssd->Maxlevel)
+        ssd_level = ssd->Maxlevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : nullptr;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatID[i] < 0)
+                continue;
+            statType = ssd->StatID[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Bonus[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    _stats[slot][BOT_STAT_MOD_RESIST_HOLY] += proto->HolyRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_FIRE] += proto->FireRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_NATURE] += proto->NatureRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_FROST] += proto->FrostRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_SHADOW] += proto->ShadowRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_ARCANE] += proto->ArcaneRes;
+
+    _stats[slot][BOT_STAT_MOD_ARMOR] += proto->Armor;
+    _stats[slot][BOT_STAT_MOD_BLOCK_VALUE] += proto->Block;
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    if (item->GetEntry() != einfo->ItemEntry[slot])
+    {
+        if (ssv)
+        {
+            float average = ssv->getDPSMod(proto->ScalingStatValue) * proto->Delay / 1000.0f;
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += 0.7f * average;
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += 1.3f * average;
+        }
+        else
+        {
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += proto->Damage[0].DamageMin + proto->Damage[1].DamageMin;
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MAX] += proto->Damage[0].DamageMax + proto->Damage[1].DamageMax;
+        }
+
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            int32 dpsMod = 0;
+            int32 feral_bonus = 0;
+
+            if (ssv)
+            {
+                dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+                feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+            }
+
+            feral_bonus += proto->getFeralBonus(dpsMod);
+            if (feral_bonus)
+                _stats[slot][BOT_STAT_MOD_FERAL_ATTACK_POWER] += feral_bonus;
+                //ApplyFeralAPBonus(feral_bonus, apply);
+        }
+    }
+
+    ApplyItemEnchantments(item, slot);
+    ApplyItemEquipSpells(item, true);
+
+    shouldUpdateStats = true;
+}
+
+void bot_ai::RemoveItemBonuses(uint8 slot)
+{
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    RemoveItemEnchantments(item); //remove spells
+    ApplyItemEquipSpells(item, false);
+
+    shouldUpdateStats = true;
+}
+
+void bot_ai::ApplyItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        ApplyItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_ai::ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (pEnchant->MinLevel > me->GetLevel())
+        return;
+
+    uint32 enchant_display_type;
+    uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->Effect[s];
+        enchant_amount = pEnchant->EffectPointsMin[s];
+        enchant_spell_id = pEnchant->EffectArg[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += enchant_amount;
+                _stats[slot][BOT_STAT_MOD_DAMAGE_MAX] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                {
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->Enchantment[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    CastSpellExtraArgs args(item);
+                    if (basepoints)
+                    {
+                        args.AddSpellBP0(basepoints);
+                    }
+                    me->CastSpell(me, enchant_spell_id, args);
+                }
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand)
+                    {
+                        for (uint8 k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand->Enchantment[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+                _stats[slot][BOT_STAT_MOD_RESISTANCE_START + enchant_spell_id] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+            {
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand_suffix)
+                    {
+                        for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand_suffix->Enchantment[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand_suffix->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                switch (enchant_spell_id)
+                {
+                    case ITEM_MOD_MANA:
+                    case ITEM_MOD_HEALTH:
+                    case ITEM_MOD_AGILITY:
+                    case ITEM_MOD_STRENGTH:
+                    case ITEM_MOD_INTELLECT:
+                    case ITEM_MOD_SPIRIT:
+                    case ITEM_MOD_STAMINA:
+                    case ITEM_MOD_DEFENSE_SKILL_RATING:
+                    case ITEM_MOD_DODGE_RATING:
+                    case ITEM_MOD_PARRY_RATING:
+                    case ITEM_MOD_BLOCK_RATING:
+                    case ITEM_MOD_HIT_MELEE_RATING:
+                    case ITEM_MOD_HIT_RANGED_RATING:
+                    case ITEM_MOD_HIT_SPELL_RATING:
+                    case ITEM_MOD_CRIT_MELEE_RATING:
+                    case ITEM_MOD_CRIT_RANGED_RATING:
+                    case ITEM_MOD_CRIT_SPELL_RATING:
+                    case ITEM_MOD_HASTE_MELEE_RATING:
+                    case ITEM_MOD_HASTE_RANGED_RATING:
+                    case ITEM_MOD_HASTE_SPELL_RATING:
+                    case ITEM_MOD_HIT_RATING:
+                    case ITEM_MOD_CRIT_RATING:
+                    case ITEM_MOD_HASTE_RATING:
+                    case ITEM_MOD_RESILIENCE_RATING:
+                    case ITEM_MOD_EXPERTISE_RATING:
+                    case ITEM_MOD_ATTACK_POWER:
+                    case ITEM_MOD_RANGED_ATTACK_POWER:
+                    case ITEM_MOD_MANA_REGENERATION:
+                    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                    case ITEM_MOD_SPELL_POWER:
+                    case ITEM_MOD_HEALTH_REGEN:
+                    case ITEM_MOD_SPELL_PENETRATION:
+                    case ITEM_MOD_BLOCK_VALUE:
+                    case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+                    case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                        _stats[slot][enchant_spell_id] += enchant_amount;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_ai::RemoveItemEnchantments(Item const* item)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        RemoveItemEnchantment(item, EnchantmentSlot(i));
+}
+
+void bot_ai::RemoveItemEnchantment(Item const* item, EnchantmentSlot eslot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    ////skip level reqs
+    //if (pEnchant->MinLevel > me->GetLevel())
+    //    return;
+
+    uint32 enchant_display_type;
+    //uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->Effect[s];
+        //enchant_amount = pEnchant->EffectPointsMin[s];
+        enchant_spell_id = pEnchant->EffectArg[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                    me->RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_ai::RemoveItemClassEnchants()
+{
+    uint8 eslot = TEMP_ENCHANTMENT_SLOT;
+    for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_SLOT_RANGED; ++k)
+    {
+        if (!GetAIMiscValue(k == BOT_SLOT_MAINHAND ? BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH : BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH))
+            continue;
+
+        Item* weap = _equips[k];
+        if (!weap || !weap->GetEnchantmentId(EnchantmentSlot(eslot)))
+            continue;
+
+        RemoveItemEnchantment(weap, EnchantmentSlot(eslot));
+
+        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + eslot*MAX_ENCHANTMENT_OFFSET + i, 0);
+    }
+}
+
+void bot_ai::ApplyItemEquipSpells(Item* item, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+
+        if (!spellData.SpellId)
+            continue;
+
+        // wrong triggering type
+        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
+            continue;
+
+        // check if it is valid spell
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        //ApplyEquipSpell(spellproto, item, apply);
+
+        //if (apply)
+        //    me->AddAura(spellInfo->Id, me);
+        //else
+        //    me->RemoveAura(spellInfo->Id);
+
+        CastSpellExtraArgs args(item);
+        if (apply)
+            me->CastSpell(me, spellInfo->Id, args);
+        else
+            me->RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
+    }
+}
+
+void bot_ai::ApplyItemEquipEnchantmentSpells(Item* item)
+{
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        if (!enchant_id)
+            continue;
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+        if (pEnchant->MinLevel > me->GetLevel())
+            continue;
+
+        uint32 enchant_display_type;
+        //uint32 enchant_amount;
+        uint32 enchant_spell_id;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            enchant_display_type = pEnchant->Effect[s];
+            //enchant_amount = pEnchant->EffectPointsMin[s];
+            enchant_spell_id = pEnchant->EffectArg[s];
+
+            switch (enchant_display_type)
+            {
+                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                {
+                    if (!enchant_spell_id)
+                        break;
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->Enchantment[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    CastSpellExtraArgs args(item);
+                    if (basepoints)
+                    {
+                        args.AddSpellBP0(basepoints);
+                    }
+                    me->CastSpell(me, enchant_spell_id, args);
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+    }
+}
+
+void bot_ai::ApplyItemSetBonuses(Item* item, bool apply)
+{
+    if (item) //(un)equip, NOT from loops
+    {
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            return;
+
+        uint32 setId = proto->ItemSet;
+        if (!setId)
+            return;
+
+        ItemSetEntry const* itemSet = sItemSetStore.LookupEntry(setId);
+        if (!itemSet)
+            return;
+
+        uint8 setItemCount = 0;
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            if (_equips[i] && _equips[i]->GetTemplate()->ItemSet == setId)
+                ++setItemCount; //same at equip and unequip
+
+        for (uint8 i = 0; i != MAX_ITEM_SET_SPELLS; ++i)
+        {
+            if (!itemSet->SetSpellID[i])
+                continue;
+            if (itemSet->SetThreshold[i] != setItemCount)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itemSet->SetSpellID[i]);
+            if (!spellInfo)
+                continue;
+
+            //TC_LOG_ERROR("entities.player", "ApplyItemSetBonusesB: %s's %s, %s (%u), %s (%u), icount %u",
+            //    me->GetName().c_str(), apply ? "apply" : "remove", itemSet->name[0], setId, spellInfo->SpellName[0], spellInfo->Id, uint32(setItemCount));
+
+            if (apply)
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(me, spellInfo->Id, args);
+            }
+            else
+                me->RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
+        }
+        return;
+    }
+
+    //no item means all (init, reset, reset (lvl change))
+    std::list<uint32> itemSets;
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        uint32 setId = proto->ItemSet;
+        if (!setId)
+            continue;
+
+        ItemSetEntry const* itemSet = sItemSetStore.LookupEntry(setId);
+        if (!itemSet)
+            continue;
+
+        itemSets.push_back(setId);
+    }
+
+    itemSets.sort();
+    itemSets.unique();
+    for (std::list<uint32>::const_iterator itr = itemSets.begin(); itr != itemSets.end(); ++itr)
+    {
+        ItemSetEntry const* itemSet = sItemSetStore.LookupEntry(*itr);
+        uint8 setItemCount = 0;
+        for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+            if (_equips[k] && _equips[k]->GetTemplate()->ItemSet == *itr)
+                ++setItemCount;
+
+        for (uint8 j = 0; j != MAX_ITEM_SET_SPELLS; ++j)
+        {
+            if (!itemSet->SetSpellID[j])
+                continue;
+            if (itemSet->SetThreshold[j] > setItemCount)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itemSet->SetSpellID[j]);
+            if (!spellInfo)
+                continue;
+
+            //TC_LOG_ERROR("entities.player", "ApplyItemSetBonusesB (all): %s's %s, %s (%u), %s (%u), c %u, req %u",
+            //    me->GetName().c_str(), apply ? "apply" : "remove", itemSet->name[0], *itr, spellInfo->SpellName[0], spellInfo->Id, uint32(setItemCount), itemSet->SetThreshold[j]);
+
+            if (apply)
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(me, spellInfo->Id, args);
+            }
+            else
+                me->RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
+        }
+    }
+}
+
+void bot_ai::ApplyItemsSpells()
+{
+    for (uint8 slot = BOT_SLOT_MAINHAND; slot != BOT_INVENTORY_SIZE; ++slot)
+    {
+        if (Item* item = _equips[slot])
+        {
+            ApplyItemEquipSpells(item, true); //item template spells
+            ApplyItemEquipEnchantmentSpells(item); //item enchants
+        }
+    }
+
+    ApplyItemSetBonuses(nullptr, true); //item set bonuses
+}
+
+inline float bot_ai::_getBotStat(uint8 slot, uint8 stat) const
+{
+    return float(static_cast<BotStat>(_stats[slot])[stat]);
+}
+
+inline float bot_ai::_getTotalBotStat(uint8 stat) const
+{
+    int32 value = 0;
+    for (uint8 slot = BOT_SLOT_MAINHAND; slot != BOT_INVENTORY_SIZE; ++slot)
+        value += static_cast<BotStat>(_stats[slot])[stat];
+
+    uint8 lvl = me->GetLevel();
+    float fval = float(value);
+
+    switch (stat)
+    {
+        case BOT_STAT_MOD_STRENGTH:
+            fval += me->GetTotalStatValue(STAT_STRENGTH);
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    //Vitality, Strength of Arms
+                    if (lvl >= 45 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+                        fval *= 1.06f;
+                    if (lvl >= 40 && _spec == BOT_SPEC_WARRIOR_ARMS)
+                        fval *= 1.04f;
+                    //Improved Berserker Stance part 1 (all stances)
+                    if (lvl >= 45 && _spec == BOT_SPEC_WARRIOR_FURY/* && GetBotStance() == WARRIOR_BERSERKER_STANCE*/)
+                        fval *= 1.2f;
+                    break;
+                case BOT_CLASS_PALADIN:
+                    //Divine Strength
+                    if (lvl >= 10)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    //Ravenous Dead part 1
+                    //Endless Winter part 1
+                    //Veteran of the Third War part 1
+                    //Abomination's might part 2
+                    if (lvl >= 56)
+                        fval *= 1.03f;
+                    if (lvl >= 58)
+                        fval *= 1.04f;
+                    if (lvl >= 59 && _spec == BOT_SPEC_DK_BLOOD)
+                        fval *= 1.06f;
+                    if (lvl >= 60 && _spec == BOT_SPEC_DK_BLOOD)
+                        fval *= 1.02f;
+                    //Frost Presence passive / Improved Frost Presence
+                    if (lvl >= 61 && GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE && _spec == BOT_SPEC_DK_FROST)
+                        fval *= 1.08f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_AGILITY:
+            fval += me->GetTotalStatValue(STAT_AGILITY);
+            switch (_botclass)
+            {
+                case BOT_CLASS_HUNTER:
+                    //Combat Experience, Lightning Reflexes
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_MARKSMANSHIP)
+                        fval *= 1.04f;
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_SURVIVAL)
+                        fval *= 1.15f;
+                    //Hunting Party
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_SURVIVAL)
+                        fval *= 1.03f;
+                    break;
+                case BOT_CLASS_ROGUE:
+                    //Sinister Calling
+                    if (lvl >= 45 && _spec == BOT_SPEC_ROGUE_SUBTLETY)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_STAMINA:
+            fval += me->GetTotalStatValue(STAT_STAMINA);
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    //Vitality, Strength of Arms
+                    if (lvl >= 45 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+                        fval *= 1.09f;
+                    if (lvl >= 40 && _spec == BOT_SPEC_WARRIOR_ARMS)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_PALADIN:
+                    //Combat Expertise, Sacred Duty
+                    if (lvl >= 45 && _spec == BOT_SPEC_PALADIN_PROTECTION)
+                        fval *= 1.06f;
+                    if (lvl >= 35 && _spec == BOT_SPEC_PALADIN_PROTECTION)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_HUNTER:
+                    //Survivalist
+                    if (lvl >= 20)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_ROGUE:
+                    //Lightning Reflexes part 2
+                    if (lvl >= 25 && _spec == BOT_SPEC_ROGUE_COMBAT)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_PRIEST:
+                    //Improved Power Word: Shield
+                    if (lvl >= 15)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    //Veteran of the Third War part 2
+                    if (lvl >= 59 && _spec == BOT_SPEC_DK_BLOOD)
+                        fval *= 1.03f;
+                    break;
+                case BOT_CLASS_WARLOCK:
+                    //Demonic Embrace: 10% stam bonus
+                    if (lvl >= 10)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    if (GetBotStance() == DRUID_BEAR_FORM)
+                    {
+                        //Bear form: stamina bonus base 25%
+                        //Heart of the Wild: 10% stam bonus for bear
+                        fval *= 1.25f;
+                        if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                            fval *= 1.1f;
+                    }
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.06f;
+                    if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_INTELLECT:
+            fval += me->GetTotalStatValue(STAT_INTELLECT);
+            switch (_botclass)
+            {
+                case BOT_CLASS_PALADIN:
+                    //Divine Intellect
+                    if (lvl >= 15)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_HUNTER:
+                    //Combat Experience
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_MARKSMANSHIP)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_MAGE:
+                    //Arcane Mind
+                    if (lvl >= 30 && _spec == BOT_SPEC_MAGE_ARCANE)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_PRIEST:
+                    //Mental Strength
+                    if (lvl >= 30 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_SHAMAN:
+                    //Ancestral Knowledge
+                    if (lvl >= 10)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    //Furor (Moonkin Form)
+                    if (GetBotStance() == DRUID_MOONKIN_FORM)
+                        fval *= 1.1f;
+                    //Heart of the Wild: ferals only (tanks included)
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.2f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_SPIRIT:
+            fval += me->GetTotalStatValue(STAT_SPIRIT);
+            switch (_botclass)
+            {
+                case BOT_CLASS_PRIEST:
+                    //Spirit of Redemption part 1
+                    if (lvl >= 30 && _spec == BOT_SPEC_PRIEST_HOLY)
+                        fval *= 1.05f;
+                    //Enlightenment part 1
+                    if (lvl >= 35 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+                        fval *= 1.06f;
+                    break;
+                case BOT_CLASS_MAGE:
+                    //Student of the Mind
+                    if (lvl >= 20)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    //Living Spirit
+                    if (lvl >= 40 && _spec == BOT_SPEC_DRUID_RESTORATION)
+                        fval *= 1.15f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+    }
+
+    return fval;
+}
+
+inline float bot_ai::_getRatingMultiplier(CombatRating cr) const
+{
+    GtCombatRatingsEntry const* Rating = sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL + (me->GetLevel()-1));
+    GtOCTClassCombatRatingScalarEntry const* classRating = sGtOCTClassCombatRatingScalarStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_RATING + cr + 1);
+    if (!Rating || !classRating)
+        return 1.0f;
+
+    return classRating->Data / Rating->Data;
+}
+
+char const* bot_ai::_getNameForSlot(uint8 slot) const
+{
+    switch (slot)
+    {
+        case BOT_SLOT_MAINHAND:
+            return "Main Hand Weapon";
+        case BOT_SLOT_OFFHAND:
+            return "Offhand Weapon";
+        case BOT_SLOT_RANGED:
+            return "Ranged Weapon";
+        case BOT_SLOT_HEAD:
+            return "Head";
+        case BOT_SLOT_SHOULDERS:
+            return "Shoulders";
+        case BOT_SLOT_CHEST:
+            return "Chest";
+        case BOT_SLOT_WAIST:
+            return "Waist";
+        case BOT_SLOT_LEGS:
+            return "Legs";
+        case BOT_SLOT_FEET:
+            return "Feet";
+        case BOT_SLOT_WRIST:
+            return "Wrist";
+        case BOT_SLOT_HANDS:
+            return "Hands";
+        case BOT_SLOT_BACK:
+            return "Back";
+        case BOT_SLOT_BODY:
+            return "Body";
+        case BOT_SLOT_FINGER1:
+            return "Finger1";
+        case BOT_SLOT_FINGER2:
+            return "Finger2";
+        case BOT_SLOT_TRINKET1:
+            return "Trinket1";
+        case BOT_SLOT_TRINKET2:
+            return "Trinket2";
+        case BOT_SLOT_NECK:
+            return "Neck";
+        default:
+            return "Unknown";
+    }
+}
+
+//!Copied from Player::CastItemUseSpell
+void bot_ai::_castBotItemUseSpell(Item const* item, SpellCastTargets const& targets/*, uint8 cast_count, uint32 glyphIndex*/)
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    // use triggered flag only for items with many spell casts and for not first cast
+    uint8 count = 0;
+
+    // item spells casted at use
+    SpellInfo const* spellInfo;
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+        if (!spellData.SpellId || spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+            continue;
+
+        spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        Spell* spell = new Spell(me, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+        //spell->m_CastItem = item; // DO NOT TAKE ITEM
+        //spell->m_cast_count = cast_count;                   // set count of casts
+        //spell->m_glyphIndex = glyphIndex;                   // glyph index
+        spell->prepare(targets);
+        ++count;
+    }
+
+    // Item enchantments spells casted at use
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->Effect[s] != ITEM_ENCHANTMENT_TYPE_USE_SPELL)
+                continue;
+
+            spellInfo = sSpellMgr->GetSpellInfo(pEnchant->EffectArg[s]);
+            if (!spellInfo)
+                continue;
+
+            Spell* spell = new Spell(me, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+            //spell->m_CastItem = item; // DO NOT TAKE ITEM
+            //spell->m_cast_count = cast_count;               // set count of casts
+            //spell->m_glyphIndex = glyphIndex;               // glyph index
+            spell->prepare(targets);
+            ++count;
+        }
+    }
+}
+
+Item* bot_ai::GetEquipsByGuid(ObjectGuid itemGuid) const
+{
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        if (Item* item = _equips[i])
+            if (item->GetGUID() == itemGuid)
+                return item;
+    }
+
+    return nullptr;
+}
+
+/////////
+//ROLES//
+/////////
+uint8 bot_ai::GetRoleIcon(uint16 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+char const* bot_ai::GetRoleString(uint16 role) const
+{
+    switch (role)
+    {
+        //case BOT_ROLE_NONE:
+        //    return "???";
+        case BOT_ROLE_TANK:
+            return "Tanking";
+        case BOT_ROLE_DPS:
+            return "DPS";
+        case BOT_ROLE_HEAL:
+            return "Heal";
+        case BOT_ROLE_RANGED:
+            return "Ranged";
+        case BOT_ROLE_GATHERING_MINING:
+            return "Miner";
+        case BOT_ROLE_GATHERING_HERBALISM:
+            return "Herbalist";
+        case BOT_ROLE_GATHERING_SKINNING:
+            return "Skinner";
+        case BOT_ROLE_GATHERING_ENGINEERING:
+            return "Engineer";
+        default:
+        {
+            std::ostringstream str;
+            str << "role " << uint32(role);
+            return str.str().c_str();
+        }
+    }
+}
+
+void bot_ai::ToggleRole(uint16 role, bool force)
+{
+    if (!force && roleTimer > lastdiff)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
+
+    BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_ROLES, &_roleMask);
+
+    //Update passives
+    shouldUpdateStats = true;
+}
+
+bool bot_ai::IsTank(Unit const* unit) const
+{
+    if (!unit || unit == me)
+        return HasRole(BOT_ROLE_TANK);
+
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    //Maybe use highest hp? TODO: a way to find multiple tanks
+    if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            /*//player role in lfg group
+            if (gr->isLFGGroup())
+            {
+                if (sLFGMgr->GetRoles(unit->GetGUID()) & lfg::PLAYER_ROLE_TANK)
+                    return true;
+            }
+            //raid group Main Tank (/mt)
+            else */if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINTANK;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool bot_ai::CCed(Unit const* target, bool root)
+{
+    return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && (target->HasUnitState(UNIT_STATE_ROOT) || target->IsFrozen() || target->IsRooted())) : true;
+}
+//AI initialization common
+//Called at ai reset, level change (spawned = true)
+void bot_ai::DefaultInit()
+{
+    //only once
+    if (spawned) return;
+    spawned = true;
+
+    if (!firstspawn)
+    {
+        me->RemoveAllAuras();
+        RemoveItemClassEnchants(); //clear rogue poisons / shaman ecnhants
+        ApplyItemsSpells(); //restore item equip spells
+    }
+
+    //bot needs to be either directly controlled by player of have pvp flag to be a valid assist target (buffs, heals, etc.)
+    me->SetPvP(master->IsPvP());
+    me->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+    if (sWorld->IsFFAPvPRealm())
+        me->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+    else if (IAmFree())
+        me->SetByteFlag(UNIT_FIELD_BYTES_2, 1, 0);
+
+    if (firstspawn)
+        InitRace();
+
+    InitSpec();
+    InitRoles();
+    SetStats(true); // Class passives included
+
+    if (!IsTempBot())
+        ApplyRacials();
+
+    if (firstspawn)
+    {
+        firstspawn = false;
+        ASSERT(!me->GetBotAI());
+        ASSERT(!me->GetBotPetAI());
+        me->SetBotAI(this);
+
+        if (!IsTempBot())
+        {
+            InitFaction();
+            InitOwner();
+            InitEquips();
+        }
+    }
+}
+
+void bot_ai::ApplyRacials()
+{
+    uint8 myrace = me->GetRace();
+    switch (myrace)
+    {
+        case RACE_HUMAN:
+            RefreshAura(20598); //Human Spirit
+            RefreshAura(20864); //Mace Specialization
+            RefreshAura(20597); //Sword Specialization
+            //RefreshAura(58985); //Perception pointless
+            if (firstspawn)
+                InitSpellMap(RACIAL_EVERY_MAN_FOR_HIMSELF, true, false);
+            break;
+        case RACE_ORC:
+            RefreshAura(20573); //Hardiness
+            RefreshAura(20574); //Axe Specialization
+            //Blood Fury
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        case RACE_DWARF:
+            RefreshAura(20595); //Gun Specialization
+            RefreshAura(59224); //Mace Specialization
+            RefreshAura(20596); //Frost Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_STONEFORM, true, false);
+            break;
+        case RACE_NIGHTELF:
+            RefreshAura(20583); //Nature Resistance
+            RefreshAura(20582); //Quickness
+            InitSpellMap(RACIAL_SHADOWMELD, true, false);
+            break;
+        case RACE_UNDEAD_PLAYER:
+            RefreshAura(20579); //Shadow Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_WILL_OF_THE_FORSAKEN, true, false);
+            //cannibalize is skipped
+            break;
+        case RACE_TAUREN:
+            RefreshAura(20550); //Endurance
+            RefreshAura(20551); //Nature Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_WARSTOMP, true, false);
+            break;
+        case RACE_GNOME:
+            RefreshAura(20552); //Arcane Resistance
+            RefreshAura(20591); //Expansive Mind
+            if (firstspawn)
+                InitSpellMap(RACIAL_ESCAPE_ARTIST, true, false);
+            break;
+        case RACE_TROLL:
+            RefreshAura(20557); //Beast Slaying
+            RefreshAura(20558); //Thrown Specialization
+            RefreshAura(26290); //Bow Specialization
+            RefreshAura(58943); //Da Voodoo Shuffle
+            RefreshAura(20555); //Regeneration
+            if (firstspawn)
+                InitSpellMap(RACIAL_BERSERKING, true, false);
+            break;
+        case RACE_BLOODELF:
+            RefreshAura(822); //Magic Resistance
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        case RACE_DRAENEI:
+            RefreshAura(6562); //Heroic Presence (28878 is not present)
+            RefreshAura(20579); //Shadow Resistance (universal since creatures do not lose cast time on damage anyways)
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "bot_ai::ApplyRacePassives(): unknown race %u for bot %s (%u)", uint32(me->GetRace()), me->GetName().c_str(), me->GetEntry());
+            return;
+    }
+}
+
+void bot_ai::InitFaction()
+{
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData && "bot_ai::InitFaction(): data not found!");
+
+    uint32 faction = npcBotData->faction;
+
+    //if (faction == 14)
+    //    faction = 35;
+
+    me->SetFaction(faction);
+    if (botPet)
+        botPet->SetFaction(faction);
+    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->faction = faction;
+}
+
+void bot_ai::InitRace()
+{
+    NpcBotExtras const* npcBotExtras = BotDataMgr::SelectNpcBotExtras(me->GetEntry());
+    ASSERT(npcBotExtras && "bot_ai::InitRace: extra data not found!");
+
+    me->SetByteValue(UNIT_FIELD_BYTES_0, 0, npcBotExtras->race); //set race
+}
+
+void bot_ai::InitOwner()
+{
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData && "bot_ai::InitOwner(): data not found!");
+
+    _ownerGuid = npcBotData->owner;
+}
+
+void bot_ai::InitRoles()
+{
+    if (IsTempBot())
+    {
+        _roleMask = BOT_ROLE_DPS;
+        return;
+    }
+    else if (IAmFree())
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+        {
+            if (_botclass != BOT_CLASS_DRUID || _spec == BOT_SPEC_DRUID_BALANCE)
+                _roleMask |= BOT_ROLE_RANGED;
+        }
+        //if (IsHealingClass(_botclass))
+        //    _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData && "bot_ai::InitRoles(): data not found!");
+
+    _roleMask = npcBotData->roles;
+}
+
+void bot_ai::InitSpec()
+{
+    uint8 spec;
+    if (_botclass >= BOT_CLASS_EX_START)
+        spec = BOT_SPEC_DEFAULT;
+    else if (IAmFree())
+    {
+        std::vector<uint8> specs;
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR: //arms, fury
+                specs.push_back(BOT_SPEC_WARRIOR_ARMS);
+                specs.push_back(BOT_SPEC_WARRIOR_FURY);
+                break;
+            case BOT_CLASS_PALADIN: //retri
+                specs.push_back(BOT_SPEC_PALADIN_RETRIBUTION);
+                break;
+            case BOT_CLASS_HUNTER: //any
+                specs.push_back(BOT_SPEC_HUNTER_BEASTMASTERY);
+                specs.push_back(BOT_SPEC_HUNTER_MARKSMANSHIP);
+                specs.push_back(BOT_SPEC_HUNTER_SURVIVAL);
+                break;
+            case BOT_CLASS_ROGUE: //any
+                specs.push_back(BOT_SPEC_ROGUE_ASSASINATION);
+                specs.push_back(BOT_SPEC_ROGUE_COMBAT);
+                specs.push_back(BOT_SPEC_ROGUE_SUBTLETY);
+                break;
+            case BOT_CLASS_PRIEST: //shadow
+                specs.push_back(BOT_SPEC_PRIEST_SHADOW);
+                break;
+            case BOT_CLASS_DEATH_KNIGHT: //any
+                specs.push_back(BOT_SPEC_DK_BLOOD);
+                specs.push_back(BOT_SPEC_DK_FROST);
+                specs.push_back(BOT_SPEC_DK_UNHOLY);
+                break;
+            case BOT_CLASS_SHAMAN: //elem, enh
+                specs.push_back(BOT_SPEC_SHAMAN_ELEMENTAL);
+                specs.push_back(BOT_SPEC_SHAMAN_ENHANCEMENT);
+                break;
+            case BOT_CLASS_MAGE: //fire, frost
+                specs.push_back(BOT_SPEC_MAGE_FIRE);
+                specs.push_back(BOT_SPEC_MAGE_FROST);
+                break;
+            case BOT_CLASS_WARLOCK: //affli, destr
+                specs.push_back(BOT_SPEC_WARLOCK_AFFLICTION);
+                specs.push_back(BOT_SPEC_WARLOCK_DESTRUCTION);
+                break;
+            case BOT_CLASS_DRUID: //balance, feral
+                specs.push_back(BOT_SPEC_DRUID_BALANCE);
+                specs.push_back(BOT_SPEC_DRUID_FERAL);
+                break;
+            default:
+                break;
+        }
+
+        if (specs.size() == 1)
+            spec = specs.front();
+        else if (specs.size() <= 3)
+        {
+            uint32 rand = urand(1,100);
+            if (specs.size() == 2)
+                spec = rand <= 50 ? specs[0] : specs[1];
+            else
+                spec = rand <= 33 ? specs[0] : rand <= 67 ? specs[1] : specs[2];
+        }
+        else
+            ASSERT(false && "bot_ai::InitSpec(): FIXME more than 3 specs to choose from!");
+    }
+    else
+    {
+        NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+        ASSERT(npcBotData && "bot_ai::InitSpec(): data not found!");
+
+        spec = npcBotData->spec;
+    }
+
+    //TC_LOG_ERROR("entities.unit", "bot_ai::InitSpec(): bot %u class %u spec: %u", me->GetEntry(), uint32(_botclass), uint32(spec));
+
+    if (spec < BOT_SPEC_BEGIN || spec > BOT_SPEC_END)
+    {
+        TC_LOG_ERROR("entities.unit", "bot_ai::InitSpec(): spec (%u) is out of range for bot %u! Falling to default (1)...",
+            uint32(spec), me->GetEntry());
+
+        spec = BOT_SPEC_DEFAULT;
+    }
+
+    SetSpec(spec, false);
+}
+
+void bot_ai::SetSpec(uint8 spec, bool activate)
+{
+    ASSERT(spec >= BOT_SPEC_BEGIN && spec <= BOT_SPEC_END);
+
+    _spec = spec;
+
+    if (activate)
+    {
+        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_SPEC, &spec);
+
+        UnsummonAll();
+        removeShapeshiftForm();
+        //from DefaultInit
+        me->RemoveAllAuras();
+        //RemoveItemClassEnchants();
+        ApplyItemsSpells();
+        ApplyRacials();
+        //from SetStats
+        //InitPowers();
+        InitSpells();
+        ApplyClassPassives();
+        InitHeals();
+
+        me->SetPower(POWER_MANA, 0);
+        me->SetPower(POWER_RAGE, 0);
+        me->SetPower(POWER_ENERGY, 0);
+    }
+}
+
+void bot_ai::InitEquips()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to spawn bot with no equip info!");
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData && "bot_ai::InitEquips(): data not found!");
+
+    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+    //                    0                   1         2            3           4         5                6                    7              8             9        10       11            12             13
+    //SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+    //  "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+    //  "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+    //  "WHERE cn.entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+
+    Field* fields2;
+    uint32 itemId;
+    uint32 itemGuidLow;
+    Item* item;
+
+    if (!iiresult) //blank bot - fill with standard items
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            itemId = einfo->ItemEntry[i];
+            if (!itemId)
+                continue;
+
+            item = Item::CreateItem(itemId, 1, nullptr);
+            ASSERT(item && "Failed to init standard Item for bot!");
+            _equips[i] = item;
+        }
+    }
+    else
+    {
+        do
+        {
+            fields2 = iiresult->Fetch();
+            itemGuidLow = fields2[11].GetUInt32();
+            itemId = fields2[12].GetUInt32();
+            item = new Item;
+            ASSERT(item->LoadFromDB(itemGuidLow, ObjectGuid::Empty, fields2, itemId));
+            //gonna find where to store our new item
+            bool found = false;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (npcBotData->equips[i] == itemGuidLow && !_equips[i])
+                {
+                    _equips[i] = item;
+                    found = true;
+                    break;
+                }
+            }
+            ASSERT(found);
+            //ItemTemplate const* proto = item->GetTemplate();
+            //TC_LOG_ERROR("entities.player", "minion_ai::InitEquips(): bot %s (id: %u): found item: for slot %u: %s (id: %u, guidLow: %u)",
+            //    me->GetName().c_str(), me->GetEntry(), i, proto->Name1.c_str(), itemId, itemGuidLow);
+
+        } while (iiresult->NextRow());
+    }
+
+    //visualize
+    for (uint8 i = BOT_SLOT_MAINHAND; i <= BOT_SLOT_RANGED; ++i)
+    {
+        if (CanChangeEquip(i) && _equips[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, _equips[i]->GetEntry());
+        else if (einfo->ItemEntry[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+    }
+
+    //apply weapons' parameters
+    if (Item const* MH = _equips[BOT_SLOT_MAINHAND])
+    {
+        itemId = MH->GetEntry();
+        if (einfo->ItemEntry[0] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (RespectEquipsAttackTime())
+                    me->SetAttackTime(BASE_ATTACK, proto->Delay);
+                ApplyItemBonuses(BOT_SLOT_MAINHAND);
+            }
+        }
+    }
+    if (Item const* OH = _equips[BOT_SLOT_OFFHAND])
+    {
+        itemId = OH->GetEntry();
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (einfo->ItemEntry[1] != itemId)
+                ApplyItemBonuses(BOT_SLOT_OFFHAND);
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (RespectEquipsAttackTime())
+                    me->SetAttackTime(OFF_ATTACK, proto->Delay);
+                me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+    }
+    if (Item const* RH = _equips[BOT_SLOT_RANGED])
+    {
+        itemId = RH->GetEntry();
+        if (einfo->ItemEntry[2] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON)
+                    if (RespectEquipsAttackTime())
+                        me->SetAttackTime(RANGED_ATTACK, proto->Delay);
+
+                ApplyItemBonuses(BOT_SLOT_RANGED);
+            }
+        }
+    }
+
+    for (uint8 i = BOT_SLOT_RANGED + 1; i != BOT_INVENTORY_SIZE; ++i)
+        ApplyItemBonuses(i);
+
+    ApplyItemSetBonuses(nullptr, true);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        if (_equips[i] == nullptr && einfo->ItemEntry[i] != 0)
+        {
+            if (i == BOT_SLOT_OFFHAND && !_canUseOffHand())
+                continue;
+
+            //if bot has no equips but equip template then use those
+            item = Item::CreateItem(einfo->ItemEntry[i], 1, nullptr);
+            ASSERT(item && "Failed to init standard Item for bot point 2!");
+            _equips[i] = item;
+
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+            if (i == BOT_SLOT_OFFHAND)
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                {
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        me->SetAttackTime(OFF_ATTACK, _botclass == BOT_CLASS_ROGUE ? 1400 : 1800);
+                        me->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void bot_ai::FindMaster()
+{
+    //totally free
+    if (!_ownerGuid)
+        return;
+    if (!_atHome || _evadeMode)
+        return;
+
+    //delay
+    if (checkMasterTimer > lastdiff)
+        return;
+
+    checkMasterTimer = urand(1000, 3000);
+
+    //already have master
+    if (!IAmFree())
+        return;
+    if (IsDuringTeleport())
+        return;
+
+    if (Player* player = ObjectAccessor::FindPlayerByLowGUID(_ownerGuid))
+    {
+        //prevent bot being screwed up because of wrong flags
+        if (player->IsGameMaster() || player->GetSession()->isLogingOut() || player->GetSession()->PlayerLogout())
+            return;
+
+        if (!SetBotOwner(player))
+            return; //fail
+
+        //if (!IsTempBot())
+        //    BotWhisper("Hey...", master);
+    }
+}
+
+bool bot_ai::IAmFree() const
+{
+    if (!_ownerGuid)
+        return true;
+    if (_ownerGuid != master->GetGUID().GetRawValue())
+        return true;
+    //if (!me->HasUnitTypeMask(UNIT_MASK_MINION))
+    //    return true;
+
+    return false;
+    //return (!_ownerGuid || _ownerGuid != master->GetGUID() || !me->HasUnitTypeMask(UNIT_MASK_MINION));
+    //        //has owner   and   //owner is found          and        //bound to owner
+}
+
+//UTILITIES
+//Unused
+void bot_ai::_AddItemTemplateLink(Player const* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ':';
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+// |TInterface\\Icons\\INV_<iconName>:<iconSize>|t|color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:suffix_factor:reporter_level|h[name]|h|r
+// |TInterface\\Icons\\INV_Misc_Staff_01:16|t|cffa335ee|Hitem:812:0:0:0:0:0:0:0:70|h[Glowing Brightwood Staff]|h|r
+void bot_ai::_AddItemLink(Player const* forPlayer, Item const* item, std::ostringstream &str, bool addIcon) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+    //ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    //uint32 bpoints = 0;
+    std::string name = proto->Name1;
+    std::string suffix = "";
+
+    //icon
+    if (addIcon)
+    {
+        ItemDisplayInfoEntry const* itemDisplayEntry = sItemDisplayInfoStore.LookupEntry(item->GetTemplate()->DisplayInfoID);
+        if (itemDisplayEntry)
+            str << "|TInterface\\Icons\\" << itemDisplayEntry->InventoryIcon << ":16|t";
+    }
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ':';
+
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ':';
+    //gems 3
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_ITEM_PROTO_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 0: g1 = eId;   break;
+            case 1: g2 = eId;   break;
+            case 2: g3 = eId;   break;
+        }
+    }
+    str << g1 << ':' << g2 << ':' << g3 << ':';
+    //always zero
+    str << 0 << ':';
+    //random property
+    str << item->GetItemRandomPropertyId() << ':';
+    str << item->GetItemSuffixFactor() << ':';
+
+    //reporter level
+    str << me->GetLevel();
+
+    //name
+    _LocalizeItem(forPlayer, name, suffix, item);
+
+    str << "|h[" << name;
+    if (suffix.length() > 0)
+        str << ' ' << suffix;
+    str <<"]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::_AddItemLink(): %s", str.str().c_str());
+}
+//Unused
+void bot_ai::_AddQuestLink(Player const* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+//Unsused
+void bot_ai::_AddWeaponSkillLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+//|cff71d5ff|Hspell:21563|h[Command]|h|r
+void bot_ai::_AddSpellLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color/* = true*/) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|c";
+
+    if (color)
+    {
+        switch (GetFirstSchoolInMask(spellInfo->GetSchoolMask()))
+        {
+            case SPELL_SCHOOL_NORMAL:       str << "ffffff00"; break; //YELLOW
+            case SPELL_SCHOOL_HOLY:         str << "ffffe680"; break; //LIGHT YELLOW
+            case SPELL_SCHOOL_FIRE:         str << "ffff8000"; break; //ORANGE
+            case SPELL_SCHOOL_NATURE:       str << "ff4dff4d"; break; //GREEN
+            case SPELL_SCHOOL_FROST:        str << "ff80ffff"; break; //LIGHT BLUE
+            case SPELL_SCHOOL_SHADOW:       str << "ff8080ff"; break; //DARK BLUE
+            case SPELL_SCHOOL_ARCANE:       str << "ffff80ff"; break; //LIGHT PURPLE
+            default:                        str << "ffffffff"; break; //UNK WHITE
+        }
+    }
+    else
+        str << "ffffffff"; //default white
+
+    str << "|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+//Unused
+void bot_ai::_AddProfessionLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUID().GetCounter() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->DisplayName[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player const* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeItem(Player const* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(item->GetEntry());
+    if (loc > 0 && itemInfo && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+
+    int32 randomPropId = item->GetItemRandomPropertyId();
+    //TC_LOG_ERROR("entities.player", "bot_ai::_LocalizeItem(): randomPropId = %i", randomPropId);
+    if (!randomPropId)
+        return;
+
+    if (randomPropId > 0)
+    {
+        if (ItemRandomPropertiesEntry const* item_rand = sItemRandomPropertiesStore.LookupEntry(randomPropId))
+        {
+            std::array<char const*, 16> const& suffs = item_rand->Name;
+            //if (suffs)
+            {
+                //for (uint8 i = 0; i != MAX_LOCALES; ++i)
+                //    TC_LOG_ERROR("entities.player", "bot_ai::_LocalizeItem(): rand prop suffix for loc %u = %s", i, suffs[i]);
+                suffix = suffs[loc];
+            }
+        }
+    }
+    else
+    {
+        if (ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(-randomPropId))
+        {
+            std::array<char const*, 16> const& suffs = item_rand->Name;
+            //if (suffs)
+            {
+                //for (uint8 i = 0; i != MAX_LOCALES; ++i)
+                //    TC_LOG_ERROR("entities.player", "bot_ai::_LocalizeItem(): rand suff suffix for loc %u = %s", i, suffs[i]);
+                suffix = suffs[loc];
+            }
+        }
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player const* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player const* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player const* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+void bot_ai::BotJump(Position const* pos)
+{
+    ++_jumpCount;
+
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(*pos, me->GetExactDist2d(pos->m_positionX, pos->m_positionY), 10.0f);
+
+    //float dx = pos->m_positionX - me->m_positionX;
+    //float dy = pos->m_positionY - me->m_positionY;
+    //float fdx = fabs(dx); float fdy = fabs(dy);
+    //float divider = fdx > 400 || fdy > 400 ? 5.0f : fdx > 200 || fdy > 200 ? 3.0f : fdx > 100 || fdy > 100 ? 2.0f : 1.5f;
+    //dx = dx / divider + me->m_positionX;
+    //dy = dy / divider + me->m_positionY;
+    //float z = me->GetMap()->GetHeight(dx, dy, std::max<float>(me->m_positionZ, pos->m_positionZ));
+
+    //if (z > INVALID_HEIGHT)
+    //    me->GetMotionMaster()->MoveJump(dx, dy, z, me->GetExactDist2d(dx, dy), 10.0f);
+}
+
+bool bot_ai::UpdateImpossibleChase(Unit const* target)
+{
+    if (_chaseTimer > lastdiff || me->isMoving() || !IAmFree())
+        return false;
+
+    if (JumpingOrFalling())
+        return false;
+
+    if (!me->IsWithinDist(target, HasRole(BOT_ROLE_RANGED) ? 75 : 50) || (me->GetDistance(target) < (HasRole(BOT_ROLE_RANGED) ? 35 : 10)))
+    {
+        ResetChaseTimer(target);
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), *target, false);
+        return true;
+    }
+
+    if (_jumpCount >= 3)
+    {
+        me->AttackStop();
+        Evade();
+        return true;
+    }
+
+    ResetChaseTimer(target);
+    if (!HasRole(BOT_ROLE_RANGED))
+        BotJump(target);
+    return true;
+}
+
+void bot_ai::ResetChaseTimer(Position const* /*pos*/)
+{
+    _chaseTimer = 30000;//std::max<uint32>(5000, me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 400);
+    //me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 1000 / me->GetSpeed(MOVE_WALK);
+}
+
+void bot_ai::ResetChase(Position const* pos)
+{
+    if (!IAmFree())
+        return;
+
+    ResetChaseTimer(pos);
+    _jumpCount = 0;
+}
+
+void bot_ai::OnStartAttack(Unit const* u)
+{
+    AdjustTankingPosition();
+
+    if (u->GetGUID() != _lastTargetGuid)
+    {
+        ResetChase(u);
+        _lastTargetGuid = u->GetGUID();
+    }
+}
+
+bool bot_ai::StartAttack(Unit const* u, bool force)
+{
+    if (HasBotCommandState(BOT_COMMAND_ATTACK) && !force)
+        return false;
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    OnStartAttack(u);
+    return true;
+}
+
+void bot_ai::JustEnteredCombat(Unit* u)
+{
+    _atHome = false;
+
+    //clear gossip during combat. See CheckAuras() for restore
+    if (me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+        me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+
+    if (!IAmFree())
+        return;
+
+    _evadeMode = false;
+    AbortTeleport();
+
+    ResetChase(u);
+}
+//killer may be NULL
+void bot_ai::JustDied(Unit*)
+{
+    AbortTeleport();
+    KillEvents(false);
+
+    if (IsTempBot())
+    {
+        //TC_LOG_ERROR("entities.player", "Unsummoning temp bot %s (guidLow: %u), owner: %s (guidLow: %u)...",
+        //    me->GetName().c_str(), me->GetGUID().GetCounter(), master->GetName().c_str(), master->GetGUID().GetCounter());
+
+        if (!IAmFree())
+            master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_UNSUMMON);
+
+        me->AddObjectToRemoveList();
+        return;
+    }
+    else if (!IAmFree())
+    {
+        if (Group* gr = master->GetGroup())
+            if (gr->IsMember(me->GetGUID()))
+                gr->SendUpdate();
+    }
+
+    _reviveTimer = IAmFree() ? 180000 : 60000; //3min/1min
+    _atHome = false;
+    _evadeMode = false;
+    spawned = false;
+
+    ++_deathsCount;
+}
+
+void bot_ai::KilledUnit(Unit* u)
+{
+    ++_killsCount;
+    if (u->IsControlledByPlayer() || u->IsPvP())
+        ++_pvpKillsCount;
+    if (u->isType(TYPEMASK_PLAYER))
+        ++_playerKillsCount;
+}
+
+void bot_ai::MoveInLineOfSight(Unit* /*u*/)
+{
+}
+
+void bot_ai::AttackStart(Unit* /*u*/)
+{
+}
+
+void bot_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+    {
+        if (Creature* cre = victim->ToCreature())
+        {
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(master);
+
+            //controlled case is handled in Unit::DealDamage
+            if (IAmFree())
+                cre->LowerPlayerDamageReq(cre->GetHealth() < damage ?  cre->GetHealth() : damage);
+        }
+    }
+
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        ResetChase(victim);
+}
+//This function is called after Spell::SendSpellCooldown() and Spell::DoAllEffects...() call
+void bot_ai::OnBotSpellGo(Spell const* spell)
+{
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+
+    //Set cooldown
+    if (!curInfo->IsCooldownStartedOnEvent() && !curInfo->IsPassive())
+    {
+        uint32 rec = curInfo->RecoveryTime;
+        uint32 catrec = curInfo->CategoryRecoveryTime;
+
+        if (rec > 0)
+            ApplyBotSpellCooldownMods(curInfo, rec);
+        if (catrec > 0 && !(curInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
+            ApplyBotSpellCategoryCooldownMods(curInfo, catrec);
+
+        SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+        SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+    }
+
+    if (curInfo->Id == PVPTRINKET)
+        SetSpellCooldown(PVPTRINKET, 120000);
+    if (IsPotionSpell(curInfo->Id))
+        StartPotionTimer();
+    if (curInfo->Id == ACTIVATE_SPEC)
+        SetSpec(_newspec);
+
+    OnClassSpellGo(curInfo);
+}
+
+void bot_ai::OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        itr->second->cooldown += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+
+    GC_Timer = 0; //reset global cooldown since cast is canceled
+}
+
+void bot_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
+{
+    if (!target || !target->IsAlive() || target == me)
+        return;
+
+    if (!me->CanUseAttackType(attType))
+        return;
+
+    Item* item;
+    ItemTemplate const* proto;
+    int8 slot;
+    //int8 id = 1;
+    //EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        //skip standard items
+        //if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+        //    continue;
+
+        proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        // Additional check for weapons
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            // offhand item cannot proc from main hand hit etc
+            switch (attType)
+            {
+                case BASE_ATTACK:   slot = BOT_SLOT_MAINHAND;   break;
+                case OFF_ATTACK:    slot = BOT_SLOT_OFFHAND;    break;
+                case RANGED_ATTACK: slot = BOT_SLOT_RANGED;     break;
+                default:            slot = -1;                  break;
+            }
+            if (slot != i)
+                continue;
+        }
+
+        CastBotItemCombatSpell(target, attType, procVictim, procEx, item, proto);
+    }
+}
+
+void bot_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto)
+{
+    //TODO: custom spell triggers maybe?
+
+    // Can do effect if any damage done to target
+    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
+    {
+        for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = proto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            // wrong triggering type
+            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "WORLD: unknown Item spellid %i", spellData.SpellId);
+                continue;
+            }
+
+            if (me->m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+                return;
+
+            float chance = (float)spellInfo->ProcChance;
+
+            if (spellData.SpellPPMRate)
+            {
+                uint32 WeaponSpeed = me->GetAttackTime(attType);
+                chance = me->GetPPMProcChance(WeaponSpeed, spellData.SpellPPMRate, spellInfo);
+            }
+            else if (chance > 100.0f)
+                chance = me->GetWeaponProcChance();
+
+            if (roll_chance_f(chance))
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(me, spellInfo->Id, args);
+            }
+        }
+    }
+
+    // item combat enchantments
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->Effect[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                continue;
+
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+
+            if (entry && entry->HitMask)
+            {
+                // Check hit/crit/dodge/parry requirement
+                if ((entry->HitMask & procEx) == 0)
+                    continue;
+            }
+            else
+            {
+                // Can do effect if any damage done to target
+                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
+                    continue;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->EffectArg[s]);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
+                //    GetGUID().GetCounter(), GetName().c_str(), pEnchant->ID, pEnchant->EffectArg[s]);
+                continue;
+            }
+
+            float chance = pEnchant->EffectPointsMin[s] != 0 ? float(pEnchant->EffectPointsMin[s]) : me->GetWeaponProcChance();
+
+            if (entry)
+            {
+                if (entry->ProcsPerMinute)
+                {
+                    chance = me->GetPPMProcChance(proto->Delay, entry->ProcsPerMinute, spellInfo);
+                    //handle SPELLMOD_PROC_PER_MINUTE spellmods
+                    if (_botclass == BOT_CLASS_ROGUE)
+                    {
+                        //Improved Poisons
+                        if (_spec == BOT_SPEC_ROGUE_ASSASINATION && me->GetLevel() >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x2000))
+                            chance *= 1.5f;
+                    }
+                }
+                else if (entry->Chance)
+                    chance = (float)entry->Chance;
+            }
+
+            // Apply SPELLMOD_CHANCE_OF_SUCCESS spell mods
+            if (_botclass == BOT_CLASS_ROGUE)
+            {
+                //Improved Poisons
+                if (_spec == BOT_SPEC_ROGUE_ASSASINATION && me->GetLevel() >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x10000))
+                    chance += 20.f;
+            }
+
+            // Shiv has 100% chance to apply the poison
+            if (me->FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
+                chance = 100.0f;
+
+            if (roll_chance_f(chance))
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(spellInfo->IsPositive() ? me : target, spellInfo->Id, args);
+            }
+        }
+    }
+}
+//GLOBAL UPDATE
+//opponent unsafe
+bool bot_ai::GlobalUpdate(uint32 diff)
+{
+    if (BotDataMgr::AllBotsLoaded() == false)
+    {
+        //TC_LOG_ERROR("entities.unit", "GlobalUpdate: bots are not loaded!");
+        return false;
+    }
+
+    ReduceCD(diff);
+
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+
+        //send stats update for group frames
+        if (me->IsInWorld() && !IAmFree())
+        {
+            if (Group const* gr = master->GetGroup())
+            {
+                if (gr->IsMember(me->GetGUID()))
+                {
+                    WorldPacket data;
+                    BuildGrouUpdatePacket(&data);
+
+                    Player* member;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        member = itr->GetSource();
+                        if (member/* && !member->IsWithinDist(me, member->GetSightRange(), false)*/)
+                            member->GetSession()->SendPacket(&data);
+                    }
+                }
+            }
+
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != master->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+
+    //if (me->HasInvisibilityAura() || me->HasStealthAura())
+    //    return false;
+
+    //Check current cast state: interrupt casts that became pointless
+    if (me->HasUnitState(UNIT_STATE_CASTING) && urand(1,100) <= 75)
+    {
+        bool interrupt;
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+        {
+            interrupt = false;
+            Spell const* spell = me->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+            Unit const* target = spell->m_targets.GetUnitTarget();
+            if (!target)
+                continue;
+            SpellInfo const* info = spell->GetSpellInfo();
+            if (!info->CastTimeEntry)
+                continue;
+            if (info->Id == SHOOT_WAND && me->isMoving())
+            {
+                interrupt = true;
+            }
+            if (!interrupt && !info->IsPositive())
+            {
+                if (!target->IsAlive())
+                    interrupt = true;
+                else if ((info->Mechanic == MECHANIC_POLYMORPH || info->Mechanic == MECHANIC_SHACKLE ||
+                    info->Mechanic == MECHANIC_DISORIENTED || info->Mechanic == MECHANIC_SLEEP ||
+                    info->Mechanic == MECHANIC_CHARM || info->Mechanic == MECHANIC_BANISH ||
+                    info->Mechanic == MECHANIC_STUN || info->Mechanic == MECHANIC_FREEZE) &&
+                    info->GetFirstRankSpell()->Id != 710 && info->GetFirstRankSpell()->Id != SPELL_SLEEP &&
+                    !target->getAttackers().empty() && !IsCasting(target))
+                    interrupt = true; //useless control (except banish, checked inside class ai)
+                else if (target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !IsCasting(target) &&
+                    (info->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) && _botclass != BOT_CLASS_MAGE)
+                    interrupt = true; //useless control breaks immediately (skip glyphed poly)
+                else if (info->DmgClass == SPELL_DAMAGE_CLASS_MAGIC && !(info->Attributes & SPELL_ATTR0_ABILITY) &&
+                    !(info->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                    !(info->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
+                    (target->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS) > 60 ||
+                    target->GetTotalAuraModifierByMiscMask(SPELL_AURA_REFLECT_SPELLS_SCHOOL, info->GetSchoolMask()) > 60))
+                    interrupt = true; // reflect
+                else if (
+                    info->Id != 64382 && //shattering throw
+                    info->Id != 32375 && //mass dispel
+                    info->GetFirstRankSpell()->Id != 710 && //banish
+                    target->IsImmunedToSpell(info, me))
+                    interrupt = true; // immune
+                else if (i != CURRENT_CHANNELED_SPELL && //channeled targeted spells will be interrupted in Spell::update()
+                    spell->GetCastTime() < spell->GetTimer() * 3 && // >=33% cast time remains
+                    !me->IsWithinLOSInMap(target))
+                    interrupt = true; //LoS
+                else if (info->Id == 64382 && !target->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+                    interrupt = true; //Shattering Throw wasting
+            }
+            if (!interrupt && !(target == master && me->GetDistance(target) < INTERACTION_DISTANCE) &&
+                info->HasEffect(SPELL_EFFECT_HEAL) && GetHealthPCT(target) > 90)
+            {
+                bool isAreaSpell = false;
+                for (uint8 j = 0; j != 3 && isAreaSpell == false; ++j)
+                {
+                    if (info->Effects[j].IsEffect() && info->Effects[j].TargetA.GetTarget())
+                    {
+                        if (info->Effects[j].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY ||
+                            info->Effects[j].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_AREA)
+                            isAreaSpell = true;
+                        if (!isAreaSpell)
+                        {
+                            switch (info->Effects[j].TargetA.GetTarget())
+                            {
+                            case TARGET_UNIT_CASTER_AREA_PARTY:
+                            case TARGET_DEST_CHANNEL_TARGET:
+                                isAreaSpell = true;
+                                break;
+                            case TARGET_UNIT_TARGET_CHAINHEAL_ALLY:
+                                //Healing Wave falls under TARGET_UNIT_TARGET_CHAINHEAL_ALLY
+                                if (info->GetFirstRankSpell()->Id == 331)
+                                    break;
+                                isAreaSpell = true;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                }
+
+                if (isAreaSpell == false)
+                {
+                    if (!IsTank(target) || target->getAttackers().empty() ||
+                        spell->GetTimer() * 4 <= spell->GetCastTime()) //<=25% cast time remains
+                        interrupt = true;
+                }
+            }
+            if (!interrupt && (info->HasEffect(SPELL_EFFECT_RESURRECT) || info->HasEffect(SPELL_EFFECT_RESURRECT_NEW)) &&
+                (target->IsAlive() || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->IsResurrectRequested())))
+                interrupt = true;
+
+            if (interrupt)
+            {
+                me->InterruptSpell(CurrentSpellTypes(i));
+                GC_Timer = 0;
+                break;
+            }
+        }
+    }
+
+    if (_updateTimerEx1 <= diff && !IAmFree())
+    {
+        _updateTimerEx1 = urand(2000, 2500);
+
+        //Ex1-timed updates
+
+        //DEBUG
+        /*
+        Sometimes bots are affected by zone (instance) scripts
+        Good example is CoT: Battle for Mount Hyjal
+        */
+        //Faction
+        //ensure master is not controlled
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(master->GetRace());
+        uint32 fac = rEntry ? rEntry->FactionID : 0;
+        if (me->GetFaction() != master->GetFaction() && master->GetFaction() == fac)
+        {
+            //std::ostringstream msg;
+            //msg << "Something changed my faction (now " << me->GetFaction() << "), changing back to " << fac << "!";
+            //BotWhisper(msg.str().c_str());
+            me->SetFaction(fac);
+        }
+        //Visibility
+        if (!me->IsVisible() && master->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making visible...");
+            me->SetVisible(true);
+        }
+        if (me->IsVisible() && !master->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making invisible...");
+            me->SetVisible(false);
+        }
+        //Phase
+        if (me->GetPhaseMask() != master->GetPhaseMask())
+        {
+            //BotWhisper("Somehow we are not is same phase! Fixing that...");
+            me->SetPhaseMask(master->GetPhaseMask(), true);
+        }
+        //end DEBUG
+
+        //Check if moving through air
+        //if (me->IsInWorld() && !JumpingFlyingOrFalling() &&
+        //    !me->HasUnitMovementFlag((MOVEMENTFLAG_ONTRANSPORT)|(MOVEMENTFLAG_DISABLE_GRAVITY)|(MOVEMENTFLAG_ROOT)|(MOVEMENTFLAG_SWIMMING)))
+        //{
+        //    //skip case such as moving back up from abyss (movement glitches)
+        //    float x,y,z;
+        //    if (!me->GetMotionMaster()->GetDestination(x,y,z) || z < me->GetPositionZ())
+        //    {
+        //        float groundz = me->GetMap()->GetHeight(me->GetPhaseMask(), me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), true, MAX_FALL_DISTANCE);
+        //        if (groundz > INVALID_HEIGHT)
+        //        {
+        //            me->GetMotionMaster()->MoveFall();
+        //        }
+        //        else if (GetBotCommandState() != BOT_COMMAND_STAY && !me->isMoving())
+        //        {
+        //            SetBotCommandState(BOT_COMMAND_ABANDON); //reset movement after
+        //        }
+        //    }
+        //}
+
+        //Gathering
+        if (me->IsInWorld() && (_roleMask & BOT_ROLE_MASK_GATHERING) && !me->IsInCombat() && !master->IsInCombat() && !master->IsMounted() && !CCed(me) &&
+            master->GetLootGUID().IsEmpty() && !me->isMoving() && !master->isMoving() && master->IsStandState() && !Feasting() && !IsCasting() && !IsCasting(master) &&
+            !HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        {
+            //TC_LOG_ERROR("spells", "bot_ai:UpdateEx by %s, found free master, my skills: %u:", me->GetName().c_str(), uint32(_roleMask & BOT_ROLE_MASK_GATHERING));
+            std::list<WorldObject*> woList;
+            NearbyObjectBySkillCheck check(master, INTERACTION_DISTANCE - 1.0f, (_roleMask & BOT_ROLE_MASK_GATHERING));
+            Trinity::WorldObjectListSearcher<NearbyObjectBySkillCheck> searcher(me, woList, check, GRID_MAP_TYPE_MASK_CREATURE|GRID_MAP_TYPE_MASK_GAMEOBJECT);
+            Cell::VisitAllObjects(me, searcher, 20.f);
+            //me->VisitNearbyObject(20.f, searcher);
+            //TC_LOG_ERROR("spells", "bot_ai:UpdateEx: list is %s", woList.empty() ? "empty" : "not empty");
+            if (!woList.empty())
+            {
+                WorldObject* wo = Trinity::Containers::SelectRandomContainerElement(woList);
+                //TC_LOG_ERROR("spells", "bot_ai:UpdateEx: processing %s", wo->GetName().c_str());
+                if (me->GetDistance(wo) <= INTERACTION_DISTANCE * 0.5f && me->HasInArc(M_PI * 0.75f, wo))
+                {
+                    //cosmetic
+                    CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+                    me->CastSpell(wo->GetTypeId() == TYPEID_UNIT ? wo->ToUnit() : me, SPELL_COMBAT_SPECIAL_2H_ATTACK, args);
+
+                    master->SendLoot(wo->GetGUID(), LOOT_SKINNING);
+
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                        wo->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+
+                    _updateTimerEx1 = urand(1500, 2100);
+                }
+                else
+                {
+                    std::ostringstream msg;
+                    std::string name = wo->GetName();
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                    {
+                        _LocalizeCreature(master, name, wo->GetEntry());
+                        msg << name << "..."; // TODO
+                    }
+                    else
+                    {
+                        _LocalizeGameObject(master, name, wo->GetEntry());
+                        msg << name << "!";
+                    }
+                    BotWhisper(msg.str().c_str());
+
+                    if (me->GetDistance(wo) > INTERACTION_DISTANCE * 0.5f)
+                    {
+                        Position pos;
+                        wo->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, CONTACT_DISTANCE, wo->GetAbsoluteAngle(me));
+                        me->GetMotionMaster()->MovePoint(me->GetMapId(), pos, false);
+                    }
+                    else
+                    {
+                        me->SetFacingTo(me->GetAbsoluteAngle(wo));
+                        _updateTimerEx1 = urand(1500, 1800);
+                    }
+                }
+            }
+        }
+    }
+
+    if (!IsTempBot())
+        Regenerate();
+
+    //update flags
+    if (!me->IsInCombat() && !_evadeMode && _atHome)
+    {
+        if (!me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+            me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+        if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT))
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+    }
+
+    if (!me->GetVictim())
+        Evade();
+
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return false;
+
+    if (!IsTempBot())
+        _updateRations(); //safe
+
+    CheckAttackState();
+
+    if (checkAurasTimer <= lastdiff)
+    {
+        Unit* victim = me->GetVictim(); //safe
+        checkAurasTimer += uint32(__rand + __rand + (IAmFree() ? 1000 : 40 * (1 + master->GetNpcBotsCount())));
+
+        //group demand
+        if (!IAmFree() && HasRole(BOT_ROLE_PARTY) && (!master->GetGroup() || !master->GetGroup()->IsMember(me->GetGUID())))
+        {
+            //TC_LOG_ERROR("entities.player", "CheckAuras(): adding %s to group", me->GetName().c_str());
+            master->GetBotMgr()->AddBotToGroup(me);
+        }
+
+        if (!HasBotCommandState(BOT_COMMAND_MASK_UNCHASE) && victim && !CCed(me, true) &&
+            !me->isMoving() && !IsCasting() && !IsShootingWand())
+        {
+            if (!IAmFree() && master->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+                master->GetBotMgr()->GetBotExactAttackRange() == 0)
+            {
+                GetInPosition(true, victim);
+            }
+            else if (!HasRole(BOT_ROLE_RANGED))
+            {
+                if (me->GetDistance(victim) > 1.5f)
+                    GetInPosition(true, victim);
+            }
+            else
+            {
+                CalculateAttackPos(victim, attackpos);
+                if (me->GetExactDist2d(&attackpos) > 4.f || !me->IsWithinLOSInMap(victim))
+                    GetInPosition(true, victim, &attackpos);
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == master->GetPhaseMask())
+            SetStats(false);
+        else if (_powersTimer <= lastdiff && !IsTempBot())
+        {
+            _powersTimer += REGEN_CD; //do not mistake for regen, this is only for updating max health/mana
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (_atHome && Rand() < 10)
+            _atHome = false;
+    }
+
+    if (Wait())
+        return false;
+
+    FindMaster();
+
+    GenerateRand();
+    BreakCC(diff);
+
+    if (CCed(me))
+        return false;
+
+    //opponent unsafe
+    if (!opponent && !IAmFree() && !HasBotCommandState(BOT_COMMAND_STAY))
+    {
+        if (!master->IsAlive())
+        {
+            //If ghost move to corpse, else move to dead player
+            if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            {
+                Corpse const* corpse = master->GetCorpse();
+                if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) &&
+                    !IsCasting() && !IsShootingWand() && !CCed(me) && me->GetDistance(corpse) > 5)
+                    me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+            }
+            else
+            {
+                if (!HasBotCommandState(BOT_COMMAND_FOLLOW) || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                    SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+            }
+        }
+        else if (!IsCasting() && (!IsShootingWand() || Rand() < 10))
+        {
+            _calculatePos(pos);
+            float maxdist = std::max<float>(master->GetBotMgr()->GetBotFollowDist() * (master->isMoving() ? 0.02f : 0.35f), 4.f);
+            if (!me->isMoving())
+            {
+                if (me->GetExactDist(&pos) > maxdist)
+                    SetBotCommandState(BOT_COMMAND_FOLLOW, true, &pos);
+            }
+            else
+            {
+                Position destPos;
+                me->GetMotionMaster()->GetDestination(destPos.m_positionX, destPos.m_positionY, destPos.m_positionZ);
+                if (destPos.GetExactDist(&pos) > maxdist)
+                    SetBotCommandState(BOT_COMMAND_FOLLOW, true, &pos);
+            }
+        }
+    }
+    if (!IsCasting() && !IsShootingWand())
+    {
+        if ((me->IsInCombat() && !me->IsSitState()) || !CanSheath())
+        {
+            if (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_DARK_RANGER)
+            {
+                if (me->GetSheath() != SHEATH_STATE_RANGED)
+                    me->SetSheath(SHEATH_STATE_RANGED);
+            }
+            else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                me->SetSheath(SHEATH_STATE_MELEE);
+        }
+        else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+        {
+            if (me->GetSheath() == SHEATH_STATE_RANGED)
+                me->SetSheath(SHEATH_STATE_MELEE);
+            else
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+    }
+
+    _updateMountedState();
+    _updateStandState();
+
+    return true;
+}
+
+void bot_ai::CommonTimers(uint32 diff)
+{
+    Events.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (checkAurasTimer > diff)     checkAurasTimer -= diff;
+    if (waitTimer > diff)           waitTimer -= diff;
+    if (roleTimer > diff)           roleTimer -= diff;
+    if (checkMasterTimer > diff)    checkMasterTimer -= diff;
+
+    if (_powersTimer > diff)        _powersTimer -= diff;
+    if (_chaseTimer > diff)         _chaseTimer -= diff;
+
+    if (_potionTimer > diff && (_potionTimer < POTION_CD || !me->IsInCombat())) _potionTimer -= diff;
+
+    if (IAmFree())
+        UpdateReviveTimer(diff);
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+    if (_updateTimerEx1 > diff)     _updateTimerEx1 -= diff;
+}
+
+void bot_ai::UpdateReviveTimer(uint32 diff)
+{
+    if (me->IsAlive())
+        return;
+
+    if (_reviveTimer > diff)        _reviveTimer -= diff;
+    else
+    {
+        if (IAmFree())
+            BotMgr::ReviveBot(me);
+        else
+            if (_reviveTimer > 0)   _reviveTimer = 0;
+    }
+}
+
+void bot_ai::Evade()
+{
+    if (_atHome && !_evadeMode)
+        return;
+    //if (me->IsInCombat())
+    //    return;
+    if (me->GetVictim())
+        return;
+    if (IsCasting())
+        return;
+    if (CCed(me, true))
+        return;
+
+    _atHome = true;
+
+    if (!IAmFree() || IsTempBot())
+    {
+        _evadeMode = false;
+        return;
+    }
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    if (mapid != me->GetMapId() || _evadeCount >= 3 || me->GetDistance(pos) > 1000.f)
+    {
+        //TeleportHome();
+
+        if (!teleHomeEvent || !teleHomeEvent->IsActive())
+        {
+            teleHomeEvent = new TeleportHomeEvent(this);
+            Events.AddEvent(teleHomeEvent, Events.CalculateTime(std::chrono::seconds(5)));
+
+            //if bot has been removed manually and while in dungeon
+            if (mapid != me->GetMapId())
+            {
+                teleHomeEvent->ScheduleAbort();
+                teleHomeEvent->Execute(0,0);
+            }
+        }
+        _evadeMode = false;
+        return;
+    }
+
+    float dist = me->GetDistance(pos);
+    if (dist > 1.5f)
+    {
+        if (!_evadeMode)
+            ++_evadeCount;
+        else if (Rand() < 4 && fabs(me->GetPositionZ() - pos.GetPositionZ()) > 30.f && !me->HasInArc(M_PI*0.5f, &pos))
+            ++_evadeCount;
+        else if (me->isMoving() && Rand() > 10)
+            return;
+
+        _evadeMode = true;
+
+        //me->BotStopMovement();
+
+        bool farpoint = true;
+        if (dist > 50)
+        {
+            float dx = pos.m_positionX - me->m_positionX;
+            float dy = pos.m_positionY - me->m_positionY;
+            float fdx = fabs(dx); float fdy = fabs(dy);
+            float divider =
+                fdx > 900  || fdy > 900  ?  60.0f :
+                fdx > 600  || fdy > 600  ?  30.0f :
+                fdx > 400  || fdy > 400  ?  20.0f :
+                fdx > 200  || fdy > 200  ?  10.0f :
+                fdx > 100  || fdy > 100  ?   7.0f : 3.0f;
+            dx = dx / divider + me->m_positionX;
+            dy = dy / divider + me->m_positionY;
+            float z = me->GetMap()->GetHeight(dx, dy, me->m_positionZ);
+
+            if (z > INVALID_HEIGHT && fabs(me->m_positionZ - z) > 0.05f)
+            {
+                me->GetMotionMaster()->MovePoint(mapid, dx, dy, z + 0.1f, true);
+                farpoint = false;
+            }
+        }
+
+        if (farpoint)
+            me->GetMotionMaster()->MovePoint(mapid, pos);
+
+        return;
+    }
+
+    if (me->isMoving())
+        return;
+
+    _evadeMode = false;
+    _evadeCount = 0;
+
+    me->SetFacingTo(pos.GetOrientation());
+    me->SetFaction(me->GetCreatureTemplate()->faction);
+}
+//TeleportHome() ONLY CALLED THROUGH EVENTPROCESSOR
+void bot_ai::TeleportHome()
+{
+    ASSERT(teleHomeEvent);
+    //ASSERT(IAmFree());
+
+    AbortTeleport();
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    Map* map = sMapMgr->CreateBaseMap(mapid);
+    ASSERT(map && !map->Instanceable());
+    BotMgr::TeleportBot(me, map, &pos);
+
+    spawned = false;
+    _evadeCount = 0;
+}
+//FinishTeleport(uint32, float, float, float, float) ONLY CALLED THROUGH EVENTPROCESSOR
+bool bot_ai::FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/)
+{
+    ASSERT(teleFinishEvent);
+    //ASSERT(!IAmFree());
+    ASSERT(!me->IsInWorld());
+
+    AbortTeleport();
+
+    //1) Cannot teleport: master disappeared - return home
+    if (IAmFree()/* || master->GetSession()->isLogingOut()*/)
+    {
+        uint16 mapid;
+        Position pos;
+        GetHomePosition(mapid, &pos);
+
+        teleHomeEvent = new TeleportHomeEvent(this);
+        Events.AddEvent(teleHomeEvent, Events.CalculateTime(std::chrono::milliseconds(0))); //make sure event will be deleted
+        if (teleHomeEvent->IsActive())
+            teleHomeEvent->ScheduleAbort(); //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+        _evadeMode = false;
+
+        return false;
+    }
+
+    Map* map = master->FindMap();
+    //2) Cannot teleport: map not found or forbidden - delay teleport
+    if (!map || !master->IsAlive() || master->GetBotMgr()->RestrictBots(me, true))
+    {
+        //ChatHandler ch(master->GetSession());
+        //ch.PSendSysMessage("Your bot %s cannot teleport to you. Restricted bot access on this map...", me->GetName().c_str());
+        teleFinishEvent = new TeleportFinishEvent(this);
+        Events.AddEvent(teleFinishEvent, Events.CalculateTime(std::chrono::seconds(5)));
+        return false;
+    }
+
+    me->SetMap(map);
+    me->Relocate(master);
+    map->AddToMap(me);
+    me->BotStopMovement();
+    //bot->SetAI(oldAI);
+    //me->IsAIEnabled = true;
+    canUpdate = true;
+
+    //master->m_Controlled.insert(me);
+    if (me->IsAlive())
+    {
+        CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+        me->CastSpell(me, COSMETIC_TELEPORT_EFFECT, args);
+    }
+    //me->CastSpell(me, HONORLESS_TARGET, true);
+
+    //update group member online state
+    if (Group* gr = master->GetGroup())
+        if (gr->IsMember(me->GetGUID()))
+            gr->SendUpdate();
+
+    return true;
+}
+
+void bot_ai::AbortTeleport()
+{
+    if (teleHomeEvent)
+    {
+        if (teleHomeEvent->IsActive())
+            teleHomeEvent->ScheduleAbort();
+        teleHomeEvent = nullptr;
+    }
+
+    if (teleFinishEvent)
+    {
+        if (teleFinishEvent->IsActive())
+            teleFinishEvent->ScheduleAbort();
+        teleFinishEvent = nullptr;
+    }
+}
+
+void bot_ai::GetHomePosition(uint16& mapid, Position* pos) const
+{
+    CreatureData const* data = me->GetCreatureData();
+    mapid = data->mapId;
+    pos->Relocate(data->spawnPoint.GetPositionX(), data->spawnPoint.GetPositionY(), data->spawnPoint.GetPositionZ(), data->spawnPoint.GetOrientation());
+}
+
+void bot_ai::KillEvents(bool force)
+{
+    Events.KillAllEvents(force);
+}
+
+int32 bot_ai::GetBotResistanceBonus(SpellSchoolMask mask) const
+{
+    int32 resist = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        if ((mask & (1 << i)) && (resist == 0 || resist > resistbonus[i-1]))
+            resist = resistbonus[i-1];
+
+    return resist;
+}
+
+MeleeHitOutcome bot_ai::BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    if (GetNextAttackMeleeOutCome() != MELEE_HIT_CRUSHING)
+        return GetNextAttackMeleeOutCome();
+    return me->RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void bot_ai::BotJumpInPlaceInFrontOf(Position const* pos, float speedXY, float maxHeight)
+{
+    float sign = (me->GetPositionX() < pos->GetPositionX()) ? 1.f : -1.f;
+    float x = me->GetPositionX() + 0.14f * sign;
+    sign = (me->GetPositionY() < pos->GetPositionY()) ? 1.f : -1.f;
+    float y = me->GetPositionY() + 0.14f * sign;
+    float z = me->GetPositionZ() - 0.01f;
+    //float floorz = Map::GetHeight(x, y, z, true, 5.f);
+    speedXY = std::max<float>(speedXY, speedXY / me->m_modAttackSpeedPct[BASE_ATTACK]);
+
+    //me->AttackStop();
+    //me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(x, y, z, me->GetOrientation(), speedXY, maxHeight);
+}
+
+void bot_ai::BuildGrouUpdatePacket(WorldPacket* data)
+{
+    uint32 mask = GROUP_UPDATE_FULL;
+
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
+        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
+        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
+
+    uint32 byteCount = 0;
+    for (uint8 i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
+        if (mask & (1 << i))
+            byteCount += GroupUpdateLength[i];
+
+    data->Initialize(SMSG_PARTY_MEMBER_STATS, 8 + 4 + byteCount);
+    *data << me->GetGUID().WriteAsPacked();
+    *data << uint32(mask);
+
+    if (mask & GROUP_UPDATE_FLAG_STATUS)
+    {
+        uint16 playerStatus = MEMBER_STATUS_ONLINE;
+        if (me->IsPvP())
+            playerStatus |= MEMBER_STATUS_PVP;
+
+        if (!me->IsAlive())
+            playerStatus |= MEMBER_STATUS_DEAD;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            playerStatus |= MEMBER_STATUS_PVP_FFA;
+
+        *data << uint16(playerStatus);
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
+        *data << uint32(me->GetHealth());
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
+        *data << uint32(me->GetMaxHealth());
+
+    Powers powerType = me->GetPowerType();
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
+        *data << uint8(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
+        *data << uint16(me->GetPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
+        *data << uint16(me->GetMaxPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_LEVEL)
+        *data << uint16(me->GetLevel());
+
+    if (mask & GROUP_UPDATE_FLAG_ZONE)
+        *data << uint16(me->GetZoneId());
+
+    if (mask & GROUP_UPDATE_FLAG_POSITION)
+    {
+        *data << uint16(me->GetPositionX());
+        *data << uint16(me->GetPositionY());
+    }
+
+    //TODO: ...?
+    //if (mask & GROUP_UPDATE_FLAG_AURAS)
+    //{
+    //    uint64 auramask = player->GetAuraUpdateMaskForRaid();
+    //    *data << uint64(auramask);
+    //    for (uint32 i = 0; i < MAX_AURAS_GROUP_UPDATE; ++i)
+    //    {
+    //        if (auramask & (uint64(1) << i))
+    //        {
+    //            AuraApplication const* aurApp = player->GetVisibleAura(i);
+    //            *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+    //            *data << uint8(1);
+    //        }
+    //    }
+    //}
+
+    //if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    //{
+    //    if (Vehicle* veh = me->GetVehicle())
+    //        *data << uint32(veh->GetVehicleInfo()->m_seatID[me->m_movementInfo.transport.seat]);
+    //    else
+    //        *data << uint32(0);
+    //}
+}
+
+//DPS TRACKER
+uint32 bot_ai::GetDPSTaken(Unit const* u) const
+{
+    return IAmFree() ? 0 : master->GetBotMgr()->GetDPSTaken(u);
+}
+int32 bot_ai::GetHPSTaken(Unit const* u) const
+{
+    return IAmFree() ? 0 : master->GetBotMgr()->GetHPSTaken(u);
+}
+//Health per second
+int32 bot_ai::GetHPS(Unit const* u) const
+{
+    return IAmFree() ? 0 : GetHPSTaken(u) - GetDPSTaken(u);
+}
+//Health percent per second
+int32 bot_ai::GetHPPCTPS(Unit const* u) const
+{
+    return int32(GetHPS(u) * 100.f / float(u->GetMaxHealth()));
+}
+//%health unit is going to have after x ms
+//0-100
+uint8 bot_ai::GetExpectedHPPCT(Unit const* u, uint32 mseconds) const
+{
+    if (IAmFree())
+        return GetHealthPCT(u);
+
+    int32 pct = int32(GetHealthPCT(u)) + int32(GetHPPCTPS(u) * (mseconds * 0.001f));
+
+    if (pct > 100)
+        pct = 100;
+    else if (pct < 0)
+        pct = 0;
+
+    return uint8(pct);
+}
+
+//Moved from header
+uint8 bot_ai::GetBotStance() const
+{
+    return BOT_STANCE_NONE;
+}
+
+uint8 bot_ai::GetPlayerClass() const
+{
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_BM:
+                return BOT_CLASS_WARRIOR;
+            case BOT_CLASS_SPHYNX:
+                return BOT_CLASS_WARLOCK;
+            case BOT_CLASS_ARCHMAGE:
+                return BOT_CLASS_MAGE;
+            case BOT_CLASS_DREADLORD:
+                return BOT_CLASS_WARLOCK;
+            case BOT_CLASS_SPELLBREAKER:
+                return BOT_CLASS_PALADIN;
+            case BOT_CLASS_DARK_RANGER:
+                return BOT_CLASS_ROGUE;
+            default:
+                TC_LOG_ERROR("entities.unit", "GetPlayerClass: %s has unknown Ex bot class %u!", me->GetName().c_str(), _botclass);
+                return BOT_CLASS_PALADIN;
+        }
+    }
+
+    return _botclass;
+}
+uint8 bot_ai::GetPlayerRace() const
+{
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_BM:
+                return RACE_ORC;
+            case BOT_CLASS_SPHYNX:
+                return RACE_UNDEAD_PLAYER;
+            case BOT_CLASS_ARCHMAGE:
+                return RACE_HUMAN;
+            case BOT_CLASS_DREADLORD:
+                return RACE_UNDEAD_PLAYER;
+            case BOT_CLASS_SPELLBREAKER:
+                return RACE_BLOODELF;
+            case BOT_CLASS_DARK_RANGER:
+                return RACE_BLOODELF;
+            default:
+                TC_LOG_ERROR("entities.unit", "GetPlayerRace: %s has unknown Ex bot class %u!", me->GetName().c_str(), _botclass);
+                return RACE_HUMAN;
+        }
+    }
+
+    return me->GetRace();
+}
+
+uint8 bot_ai::GetBotComboPoints() const
+{
+    return uint8(GetAIMiscValue(BOTAI_MISC_COMBO_POINTS));
+}
+
+float bot_ai::GetBotAmmoDPS() const
+{
+    if (CanUseAmmo())
+    {
+        for (int8 i = MAX_AMMO_LEVEL - 1; i >= 0; --i)
+            if (me->GetLevel() >= AmmoDPSForLevel[i][0])
+                return float(AmmoDPSForLevel[i][1]);
+
+        return float(AmmoDPSForLevel[0][1]);
+    }
+
+    return 0.0f;
+}
+
+uint32 bot_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case BOT_PET_IMP:
+            return ORIGINAL_ENTRY_IMP;
+        case BOT_PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        case BOT_PET_SUCCUBUS:
+            return ORIGINAL_ENTRY_SUCCUBUS;
+        case BOT_PET_FELHUNTER:
+            return ORIGINAL_ENTRY_FELHUNTER;
+        case BOT_PET_FELGUARD:
+            return ORIGINAL_ENTRY_FELGUARD;
+        case BOT_PET_WATER_ELEMENTAL:
+            return ORIGINAL_ENTRY_WATER_ELEMENTAL;
+        case BOT_PET_GHOUL:
+            //doesn't have pet template
+            //return ORIGINAL_ENTRY_GHOUL;
+        case BOT_PET_SHADOWFIEND:
+            //return ORIGINAL_ENTRY_SHADOWFIEND;
+        case BOT_PET_SPIRIT_WOLF:
+            //return ORIGINAL_ENTRY_SPIRIT_WOLF;
+        case BOT_PET_FORCE_OF_NATURE:
+            //return ORIGINAL_ENTRY_FORCE_OF_NATURE;
+        default:
+            return ORIGINAL_ENTRY_HUNTER_PET;
+    }
+}
+
+bool bot_ai::IsPetMelee(uint32 entry)
+{
+    switch (entry)
+    {
+        case BOT_PET_IMP:
+        case BOT_PET_WATER_ELEMENTAL:
+        case BOT_PET_AWATER_ELEMENTAL:
+            return false;
+        default:
+            return true;
+    }
+}
+
+bool bot_ai::IsMeleeClass(uint8 m_class)
+{
+    return
+        (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN ||
+        m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_BM || m_class == BOT_CLASS_DREADLORD ||
+        m_class == BOT_CLASS_SPELLBREAKER);
+}
+bool bot_ai::IsTankingClass(uint8 m_class)
+{
+    return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN ||
+        m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_SPHYNX || m_class == BOT_CLASS_SPELLBREAKER);
+}
+bool bot_ai::IsBlockingClass(uint8 m_class)
+{
+    return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_SHAMAN ||
+        m_class == BOT_CLASS_SPELLBREAKER);
+}
+bool bot_ai::IsCastingClass(uint8 m_class)
+{
+    //Class can benefit from spellpower
+    return (m_class == CLASS_PALADIN || m_class == CLASS_PRIEST || m_class == CLASS_SHAMAN ||
+        m_class == CLASS_MAGE || m_class == CLASS_WARLOCK || m_class == CLASS_DRUID ||
+        m_class == BOT_CLASS_SPHYNX || m_class == BOT_CLASS_ARCHMAGE || m_class == BOT_CLASS_DREADLORD ||
+        m_class == BOT_CLASS_SPELLBREAKER || m_class == BOT_CLASS_DARK_RANGER);
+}
+bool bot_ai::IsHealingClass(uint8 m_class)
+{
+    return
+        (m_class == BOT_CLASS_PRIEST || m_class == BOT_CLASS_DRUID ||
+        m_class == BOT_CLASS_SHAMAN || m_class == BOT_CLASS_PALADIN ||
+        m_class == BOT_CLASS_SPHYNX);
+}
+bool bot_ai::IsHumanoidClass(uint8 m_class)
+{
+    return m_class != BOT_CLASS_SPHYNX;
+}
+bool bot_ai::IsHeroExClass(uint8 m_class)
+{
+    return m_class == BOT_CLASS_BM || m_class == BOT_CLASS_ARCHMAGE ||
+        m_class == BOT_CLASS_DREADLORD || m_class == BOT_CLASS_DARK_RANGER;
+}
+bool bot_ai::IsMelee() const
+{
+    return !HasRole(BOT_ROLE_RANGED) && HasRole(BOT_ROLE_DPS|BOT_ROLE_TANK);
+}
+
+bool bot_ai::IsShootingWand(Unit const* u) const
+{
+    if (!u) u = me;
+
+    Spell const* spell = u->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL);
+    return spell && spell->GetSpellInfo()->Id == SHOOT_WAND;
+}
+
+void bot_ai::StartPotionTimer()
+{
+    _potionTimer = POTION_CD;
+}
+
+bool bot_ai::CanBlock() const
+{
+    return me->CanUseAttackType(OFF_ATTACK) &&
+        (_botclass == BOT_CLASS_SPELLBREAKER || !(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK));
+}
+bool bot_ai::CanParry() const
+{
+    if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && me->CanUseAttackType(BASE_ATTACK))
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_SPHYNX:
+            case BOT_CLASS_SPELLBREAKER:
+                return true;
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_HUNTER:
+                return me->GetLevel() >= 10;
+            case BOT_CLASS_SHAMAN:
+                return me->GetLevel() >= 30;
+            case BOT_CLASS_DEATH_KNIGHT:
+                return me->GetLevel() >= 55;
+            default:
+                break;
+        }
+    }
+    return false;
+}
+bool bot_ai::CanDodge() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanCrit() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanMiss() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanSheath() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanSit() const
+{
+    return _botclass < BOT_CLASS_EX_START || _botclass == BOT_CLASS_DARK_RANGER;
+}
+bool bot_ai::CanEat() const
+{
+    return _botclass != BOT_CLASS_SPHYNX;
+}
+bool bot_ai::CanDrink() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanRegenInCombat() const
+{
+    return _botclass == BOT_CLASS_SPHYNX;
+}
+bool bot_ai::CanMount() const
+{
+    switch (_botclass)
+    {
+        case BOT_CLASS_BM:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+            return true;
+        default:
+            return _botclass < BOT_CLASS_EX_START;
+    }
+}
+bool bot_ai::CanUseAmmo() const
+{
+    if ((_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_DARK_RANGER) &&
+        _equips[BOT_SLOT_RANGED])
+    {
+        ItemTemplate const* ranged = _equips[BOT_SLOT_RANGED]->GetTemplate();
+        if (ranged->Class == ITEM_CLASS_WEAPON &&
+            (ranged->SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+            ranged->SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW ||
+            ranged->SubClass == ITEM_SUBCLASS_WEAPON_GUN))
+            return true;
+    }
+    return false;
+}
+
+bool bot_ai::RespectEquipsAttackTime() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanChangeEquip(uint8 slot) const
+{
+    return (_botclass != BOT_CLASS_BM && _botclass != BOT_CLASS_ARCHMAGE &&
+        _botclass != BOT_CLASS_DREADLORD && _botclass != BOT_CLASS_SPELLBREAKER && _botclass != BOT_CLASS_DARK_RANGER) ||
+        slot > BOT_SLOT_RANGED;
+}
+
+bool bot_ai::GossipHello(Player* player)
+{
+    return OnGossipHello(player, 0);
+}
+bool bot_ai::GossipSelect(Player* player, uint32 /*menuId*/, uint32 gossipListId)
+{
+    uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+    uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+    return OnGossipSelect(player, me, sender, action);
+}
+bool bot_ai::GossipSelectCode(Player* player, uint32 /*menuId*/, uint32 gossipListId, char const* code)
+{
+    uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+    uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+    return OnGossipSelectCode(player, me, sender, action, code);
+}
+
+bool bot_ai::IsBotCustomSpell(uint32 spellId)
+{
+    return BotCustomSpells.find(spellId) != BotCustomSpells.end();
+}
+
+void bot_ai::InitBotCustomSpells()
+{
+    if (SPELLS_DEFINED)
+    {
+        //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... fail...");
+        return;
+    }
+    //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... success...");
+    SPELLS_DEFINED = true;
+
+    //see bot_ai.h::CommonValues::CUSTOM_SPELLS
+    //all ids must be here
+
+    //BotCustomSpells.insert(SPELL_COMBAT_SPECIAL_2H_ATTACK); //exclusive
+    BotCustomSpells.insert(SPELL_TRANSPARENCY_50);//3.1
+    BotCustomSpells.insert(SPELL_NETHERWALK);//3
+    BotCustomSpells.insert(SPELL_MIRROR_IMAGE_BM);//4
+    BotCustomSpells.insert(SPELL_SHADOW_BLAST);//5
+    BotCustomSpells.insert(SPELL_SHADOW_BOLT);//6
+    //BotCustomSpells.insert(SPELL_ATTACK_MELEE_RANDOM);//7 //exclusive
+    //BotCustomSpells.insert(SHADOWFURY_VISUAL);//8 //exclusive
+    BotCustomSpells.insert(SPELL_DEVOUR_MAGIC);//9
+    BotCustomSpells.insert(SPELL_DRAIN_MANA);//10
+    BotCustomSpells.insert(SPELL_REPLENISH_MANA);//11
+    BotCustomSpells.insert(SPELL_REPLENISH_HEALTH);//12
+    BotCustomSpells.insert(SPELL_BRILLIANCE_AURA);//13
+    BotCustomSpells.insert(SPELL_FIREBALL);//14
+    BotCustomSpells.insert(SPELL_BLIZZARD);//15
+    BotCustomSpells.insert(SPELL_SUMMON_WATER_ELEMENTAL);//16
+    BotCustomSpells.insert(SPELL_WATERBOLT);//17
+    BotCustomSpells.insert(SPELL_VAMPIRIC_AURA);//18
+    //BotCustomSpells.insert(SPELL_TRIGGERED_HEAL);//19 //exclusive
+    BotCustomSpells.insert(SPELL_SLEEP);//20
+    BotCustomSpells.insert(SPELL_CARRION_SWARM);//21
+    BotCustomSpells.insert(SPELL_INFERNO);//22
+    //BotCustomSpells.insert(SPELL_INFERNO_METEOR_VISUAL);//23 //exclusive
+    //BotCustomSpells.insert(SPELL_STEAL_MAGIC);//24 //exclusive
+    BotCustomSpells.insert(SPELL_FEEDBACK);//25
+    //BotCustomSpells.insert(SPELL_BLACK_ARROW);//26 //exclusive
+    //BotCustomSpells.insert(SPELL_DRAIN_LIFE);//27 //exclusive
+    //BotCustomSpells.insert(SPELL_SILENCE);//28 //exclusive
+
+    uint32 trig;
+    SpellInfo* trigInfo;
+    uint32 spellId;
+    SpellInfo* sinfo;
+
+    //BLADEMASTER
+
+    //2) SPELL_COMBAT_SPECIAL_2H_ATTACK
+    spellId = SPELL_COMBAT_SPECIAL_2H_ATTACK; //1132
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+    sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD;
+    //2) END SPELL_COMBAT_SPECIAL_2H_ATTACK
+
+    //3) WINDWALK
+    //3.1) TRANSPARENCY
+    trig = SPELL_TRANSPARENCY_50; //44816
+    trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+    trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+    trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+    trigInfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    trigInfo->CasterAuraStateNot = 0;
+    //3.1) END TRANSPARENCY
+
+    spellId = SPELL_NETHERWALK; //31599
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 0;
+    sinfo->RecoveryTime = 5000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 75 * 5;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY);
+    sinfo->AttributesEx &= ~SPELL_ATTR1_UNK11;
+    sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_UNK1;
+    sinfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    sinfo->CasterAuraStateNot = 0;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[0].BasePoints = 100;
+    sinfo->Effects[0].RealPointsPerLevel = 2.5f;
+    sinfo->Effects[0].ValueMultiplier = 1.0f;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+    sinfo->Effects[0].Amplitude = 0;
+    sinfo->Effects[0].TriggerSpell = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[1].BasePoints = 10;
+    sinfo->Effects[1].RealPointsPerLevel = 0.5f;
+    sinfo->Effects[1].ValueMultiplier = 1.0f;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+    sinfo->Effects[1].Amplitude = 0;
+    sinfo->Effects[1].TriggerSpell = 0;
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+    sinfo->Effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+    sinfo->Effects[2].BasePoints = 0;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[2].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[2].ApplyAuraName = SPELL_AURA_NONE;
+    sinfo->Effects[2].Amplitude = 0;
+    sinfo->Effects[2].TriggerSpell = trig;
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+    //3) END WINDWALK
+
+    //4) MIRROR IMAGE (BLADEMASTER)
+    spellId = SPELL_MIRROR_IMAGE_BM; //69936
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+    sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+    sinfo->RecoveryTime = 8000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 125 * 5;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+    sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+    //sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].MiscValue = 0;
+    sinfo->Effects[0].MiscValueB = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    //4) END MIRROR IMAGE (BLADEMASTER)
+
+    //SPHYNX
+
+    //5) SHADOW BLAST (SPLASH ATTACK)
+    //TODO: balance
+    spellId = SPELL_SHADOW_BLAST; //38085
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->SpellLevel = 60;
+    sinfo->MaxLevel = 83;
+    sinfo->ManaCost = BASE_MANA_SPHYNX/16;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = nullptr;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT | TARGET_FLAG_DEST_LOCATION;
+    //sinfo->MaxAffectedTargets = 1000;
+    //sinfo->Attributes |= SPELL_ATTR0_HIDE_IN_COMBAT_LOG | SPELL_ATTR0_HIDDEN_CLIENTSIDE | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+    sinfo->Attributes &= ~(SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION);
+    //sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    sinfo->Effects[0].BasePoints = 200;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].BonusMultiplier = 0.f;
+    sinfo->Effects[0].DamageMultiplier = 1.0f;
+    sinfo->Effects[0].RealPointsPerLevel = 10.f;
+    //sinfo->Effects[0].ValueMultiplier = 1.f;
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_SCHOOL_DAMAGE;
+    sinfo->Effects[1].BasePoints = 150;
+    sinfo->Effects[1].BonusMultiplier = 2.0f;
+    sinfo->Effects[1].DamageMultiplier = 1.0f;
+    sinfo->Effects[1].DieSides = /*17*/25;
+    sinfo->Effects[1].RealPointsPerLevel = 10.f;
+    //sinfo->Effects[1].ValueMultiplier = 1.f;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_12_YARDS);
+    //5) END SHADOW BLAST (SPLASH ATTACK)
+
+    //6) SHADOW BOLT (BASE ATTACK)
+    spellId = SPELL_SHADOW_BOLT; //16408
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+    sinfo->SpellLevel = 60;
+    sinfo->MaxLevel = 83;
+    sinfo->ManaCost = 0;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = nullptr;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    //sinfo->Attributes |= SPELL_ATTR0_HIDE_IN_COMBAT_LOG | SPELL_ATTR0_HIDDEN_CLIENTSIDE | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+    //sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+    sinfo->Effects[0].BasePoints = 200;
+    sinfo->Effects[0].DieSides = /*12*/25;
+    sinfo->Effects[0].BonusMultiplier = 1.15f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 10.f;
+    //sinfo->Effects[0].ValueMultiplier = 1.f;
+    //6) END SHADOW BOLT (BASE ATTACK)
+
+    //7) ATTACK ANIMATION
+    spellId = SPELL_ATTACK_MELEE_RANDOM; //42902
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+    //7) END ATTACK ANIMATION
+
+    //8) SPLASH ANIMATION
+    spellId = SHADOWFURY_VISUAL; //48582
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 0;
+    sinfo->ManaCost = 0;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //100 yds
+    sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    sinfo->MaxAffectedTargets = 1;
+    sinfo->Stances = 0;
+    sinfo->Speed = 0.f;
+    sinfo->Attributes |= SPELL_ATTR0_CASTABLE_WHILE_DEAD | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY;
+    sinfo->AttributesEx |= SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE | SPELL_ATTR1_NO_THREAT;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD | SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+    sinfo->AttributesEx5 |= SPELL_ATTR5_USABLE_WHILE_STUNNED | SPELL_ATTR5_USABLE_WHILE_CONFUSED | SPELL_ATTR5_USABLE_WHILE_FEARED;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].BasePoints = 1;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].ValueMultiplier = 0.f;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].DamageMultiplier = 0.f;
+    sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+    //8) END SPLASH ANIMATION
+
+    //9) DEVOUR MAGIC
+    spellId = SPELL_DEVOUR_MAGIC; //17012
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->InterruptFlags = 0xF;
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 0;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->RecoveryTime = 7000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 0;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(4); //1000ms
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(5); //40 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    //sinfo->MaxAffectedTargets = 100;
+    sinfo->Attributes |= SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY;
+    sinfo->AttributesEx |= SPELL_ATTR1_NO_THREAT;
+    //sinfo->Attributes &= ~(SPELL_ATTR0_HIDE_IN_COMBAT_LOG);
+    //sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DISPEL;
+    sinfo->Effects[0].BasePoints = 2;
+    sinfo->Effects[0].MiscValue = DISPEL_MAGIC;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ALLY);
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_DISPEL;
+    sinfo->Effects[1].BasePoints = 2;
+    sinfo->Effects[1].MiscValue = DISPEL_CURSE;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ALLY);
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS);
+
+    sinfo->Effects[2].Effect = SPELL_EFFECT_DISPEL;
+    sinfo->Effects[2].BasePoints = 2;
+    sinfo->Effects[2].MiscValue = DISPEL_MAGIC;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS);
+    //9) END DEVOUR MAGIC
+
+    //10) DRAIN MANA
+    spellId = SPELL_DRAIN_MANA; //25755
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 0;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->RecoveryTime = 0;//60000;
+    //sinfo->PowerType = POWER_MANA;
+    //sinfo->ManaCost = 0;
+    //sinfo->ManaCostPercentage = 0;
+    //sinfo->ManaCostPerlevel = 0;
+    sinfo->Speed = 0.f;
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(4); //1000ms
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(5); //40 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    //sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_POWER_DRAIN;
+    sinfo->Effects[0].BasePoints = 999999;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ANY);
+
+    sinfo->Effects[1].Effect = 0;
+    //10) END DRAIN MANA
+
+    //11) REPLENISH MANA
+    spellId = SPELL_REPLENISH_MANA; //33394
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->SpellLevel = 0;
+    sinfo->RecoveryTime = 3000;
+    sinfo->CategoryEntry = nullptr;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->CastTimeEntry = nullptr;//sSpellCastTimesStore.LookupEntry(2); //250ms
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->MaxAffectedTargets = 10;
+    sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_IS_REPLENISHMENT | SPELL_ATTR0_HIDE_IN_COMBAT_LOG;
+    sinfo->AttributesEx |= SPELL_ATTR1_DRAIN_ALL_POWER/* | SPELL_ATTR1_CANT_TARGET_SELF*/;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_NO_DONE_BONUS;
+    sinfo->AttributesEx4 |= SPELL_ATTR4_NOT_CHECK_SELFCAST_POWER;
+    sinfo->AttributesEx5 |= SPELL_ATTR5_DONT_TURN_DURING_CAST;
+    sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+    sinfo->Effects[0].BasePoints = 2;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].ValueMultiplier = 0.f;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].DamageMultiplier = 0.f;
+    sinfo->Effects[0].TriggerSpell = SPELL_TRIGGERED_ENERGIZE;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_SRC_CASTER);
+    sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_SRC_AREA_ALLY);
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_25_YARDS);
+    //11) END REPLENISH MANA
+
+    //12) REPLENISH HEALTH
+    spellId = SPELL_REPLENISH_HEALTH; //34756
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->SpellLevel = 0;
+    sinfo->RecoveryTime = 3000;
+    sinfo->CategoryEntry = nullptr;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->CastTimeEntry = nullptr;//sSpellCastTimesStore.LookupEntry(2); //250ms
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->MaxAffectedTargets = 10;
+    sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_IS_REPLENISHMENT | SPELL_ATTR0_HIDE_IN_COMBAT_LOG;
+    sinfo->AttributesEx |= SPELL_ATTR1_DRAIN_ALL_POWER/* | SPELL_ATTR1_CANT_TARGET_SELF*/;
+    sinfo->AttributesEx &= ~(SPELL_ATTR1_CANT_TARGET_SELF);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_NO_DONE_BONUS;
+    sinfo->AttributesEx4 |= SPELL_ATTR4_NOT_CHECK_SELFCAST_POWER;
+    sinfo->AttributesEx5 |= SPELL_ATTR5_DONT_TURN_DURING_CAST;
+    sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+    sinfo->Effects[0].BasePoints = 3;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].ValueMultiplier = 0.f;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].DamageMultiplier = 0.f;
+    sinfo->Effects[0].TriggerSpell = SPELL_TRIGGERED_HEAL;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_SRC_CASTER);
+    sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_SRC_AREA_ALLY);
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_25_YARDS);
+    //12) END REPLENISH HEALTH
+
+    //ARCHMAGE
+
+    //13) BRILLIANCE AURA
+    spellId = SPELL_BRILLIANCE_AURA; //1234
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 0;
+    sinfo->MaxTargetLevel = 0;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //0 yds
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_PASSIVE;
+    sinfo->AttributesEx4 |= SPELL_ATTR4_UNK21; //party aura
+    sinfo->AttributesEx7 |= SPELL_ATTR7_CONSOLIDATED_RAID_BUFF;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_POWER_REGEN_PERCENT;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].BasePoints = 100;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[1].BasePoints = 10;
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+    //for stacking rule
+    /*
+    sinfo->Effects[2].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[2].ApplyAuraName = SPELL_AURA_DUMMY;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[2].BasePoints = 1;
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    */
+    //13) END BRILLIANCE AURA
+
+    //14) FIREBALL (MAIN_ATTACK)
+    //TODO: balance
+    spellId = SPELL_FIREBALL; //9488
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 20;
+    sinfo->BaseLevel = 20;
+    sinfo->MaxLevel = 81;
+    sinfo->ManaCost = 0;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = nullptr;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_FIRE | SPELL_SCHOOL_MASK_ARCANE;
+    //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    //sinfo->MaxAffectedTargets = 1000;
+    sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_ABILITY | SPELL_ATTR0_CASTABLE_WHILE_MOUNTED;
+    sinfo->Attributes &= ~(SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION);
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    sinfo->Effects[0].BasePoints = 15;
+    sinfo->Effects[0].DieSides = 9;
+    sinfo->Effects[0].BonusMultiplier = 0.5f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 15.f;
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    //14) END FIREBALL (MAIN ATTACK)
+
+    //15) BLIZZARD
+    //TODO: balance
+    spellId = SPELL_BLIZZARD; //15783
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+    sinfo->SpellLevel = 20;
+    sinfo->BaseLevel = 20;
+    sinfo->MaxLevel = 0;
+    sinfo->ManaCost = 75 * 5;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = nullptr;
+    sinfo->RecoveryTime = 6000;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+    ///sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    //sinfo->MaxAffectedTargets = 1000;
+    sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_ABILITY | SPELL_ATTR0_CASTABLE_WHILE_MOUNTED;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS | SPELL_ATTR2_UNK22;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+    sinfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+
+    sinfo->Effects[0].BasePoints = 26;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].BonusMultiplier = 1.f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 15.f;
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_13_YARDS);
+    sinfo->Effects[0].Amplitude = 1000;
+    //15) END BLIZZARD
+
+    //16) SUMMON WATER ELEMENTAL (dummy spell)
+    spellId = SPELL_SUMMON_WATER_ELEMENTAL; //35593
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+    sinfo->SpellLevel = 20;
+    sinfo->BaseLevel = 20;
+    sinfo->MaxLevel = 0;
+    sinfo->RecoveryTime = 20000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 125 * 5;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    //sinfo->Effects[0].BasePoints = 1;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    //16) END SUMMON WATER ELEMENTAL
+
+    //17) WATERBOLT (MAIN_ATTACK)
+    //TODO: balance, we only have 1 of 3 possible elementals so boost damage
+    spellId = SPELL_WATERBOLT; //72898
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_GENERIC;
+    sinfo->SpellLevel = 20;
+    sinfo->BaseLevel = 20;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->ManaCost = 0;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(5); //2000ms
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    sinfo->Effects[0].BasePoints = 25;
+    sinfo->Effects[0].DieSides = 20;
+    sinfo->Effects[0].BonusMultiplier = 1.f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 25.f;
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    //17) END WATERBOLT (MAIN ATTACK)
+
+    //DREADLORD
+
+    //18) VAMPIRIC AURA
+    spellId = SPELL_VAMPIRIC_AURA; //20810
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->ProcFlags = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+    sinfo->SpellLevel = 0;
+    sinfo->BaseLevel = 0;
+    sinfo->MaxTargetLevel = 0;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //0 yds
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_PASSIVE;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED;
+    sinfo->AttributesEx4 |= SPELL_ATTR4_UNK21; //party aura
+    sinfo->AttributesEx7 |= SPELL_ATTR7_CONSOLIDATED_RAID_BUFF;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_CRIT_DAMAGE_BONUS;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].BasePoints = 5;
+    sinfo->Effects[0].MiscValue = SPELL_SCHOOL_MASK_NORMAL;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_PROC_TRIGGER_SPELL;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[1].BasePoints = 1;
+    sinfo->Effects[1].TriggerSpell = SPELL_TRIGGERED_HEAL;
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+    //for stacking rule
+    /*
+    sinfo->Effects[2].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[2].ApplyAuraName = SPELL_AURA_DUMMY;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[2].BasePoints = 1;
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    */
+    //18) END VAMPIRIC AURA
+
+    //19) VAMPIRIC HEAL
+    spellId = SPELL_TRIGGERED_HEAL; //25155
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->Attributes &= ~(SPELL_ATTR0_NOT_SHAPESHIFT);
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_NO_THREAT;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_DISABLE_PROC | SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED | SPELL_ATTR3_NO_DONE_BONUS;
+
+    sinfo->Effects[0].BasePoints = 1;
+
+    sinfo->Effects[1].Effect = 0;
+    //19) END VAMPIRIC HEAL
+
+    //20) SLEEP
+    spellId = SPELL_SLEEP; //20663
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->InterruptFlags = 0xF;
+    sinfo->SpellLevel = 0;
+    sinfo->BaseLevel = 0;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->Dispel = DISPEL_MAGIC;
+    sinfo->Mechanic = MECHANIC_SLEEP;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+    sinfo->RecoveryTime = 6000;
+    //sinfo->StartRecoveryCategory = 133;
+    //sinfo->StartRecoveryTime = 1000;
+    sinfo->DurationEntry = sSpellDurationStore.LookupEntry(3); //60000ms
+    sinfo->ManaCost = 50 * 5;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->AuraInterruptFlags = AURA_INTERRUPT_FLAG_DIRECT_DAMAGE;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes &= ~(SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_HEARTBEAT_RESIST_CHECK);
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    //sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_STUN;
+    //sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    //sinfo->Effects[0].BasePoints = 1;
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_RESISTANCE_PCT;
+    sinfo->Effects[1].MiscValue = SPELL_SCHOOL_MASK_NORMAL;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    sinfo->Effects[1].BasePoints = -100;
+    //20) END SLEEP
+
+    //21) CARRION SWARM
+    //TODO: balance
+    spellId = SPELL_CARRION_SWARM; //34240
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+    sinfo->SpellLevel = 40;
+    sinfo->BaseLevel = 40;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->RecoveryTime = 10000;
+    sinfo->StartRecoveryCategory = 133;
+    sinfo->StartRecoveryTime = 1500;
+    sinfo->ManaCost = 110 * 5;
+    //sinfo->MaxAffectedTargets = 1000;
+    //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT/* | SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS*/;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_SCHOOL_DAMAGE;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CONE_ENEMY_104);
+    sinfo->Effects[0].BasePoints = 425;
+    sinfo->Effects[0].DieSides = 150;
+    sinfo->Effects[0].BonusMultiplier = 2.f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 37.5f; //2000 avg at 80
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+    //21) END CARRION SWARM
+
+    //22) INFERNO (dummy summon)
+    spellId = SPELL_INFERNO; //12740
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->SpellLevel = 60;
+    sinfo->BaseLevel = 60;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+    sinfo->RecoveryTime = 180000;
+    sinfo->StartRecoveryCategory = 133;
+    sinfo->StartRecoveryTime = 1500;
+    sinfo->ManaCost = 175 * 5;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    sinfo->Attributes &= ~(SPELL_ATTR0_ABILITY);
+    sinfo->AttributesEx |= /*SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE | */SPELL_ATTR1_NO_THREAT;
+    //sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+    sinfo->Effects[0].BasePoints = 1;
+    //22) END INFERNO
+
+    //23) INFERNO VISUAL (dummy summon)
+    spellId = SPELL_INFERNO_METEOR_VISUAL; //5739
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+    //23) END INFERNO VISUAL
+
+    //SPELL BREAKER
+
+    //24) STEAL MAGIC
+    spellId = SPELL_STEAL_MAGIC; //30036
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_PALADIN;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(34); //25 yds
+    sinfo->RecoveryTime = 3000;
+    sinfo->ManaCost = 75 * 5;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+    sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ANY);
+
+    sinfo->Effects[1].Effect = 0;
+    //24) END STEAL MAGIC
+
+    //25) FEEDBACK
+    spellId = SPELL_FEEDBACK; //32897
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_PALADIN;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+    sinfo->SpellLevel = 0;
+    sinfo->BaseLevel = 0;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(13); //50000 yds
+    sinfo->ManaCost = 0;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes &= ~(SPELL_ATTR0_NOT_SHAPESHIFT);
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_POWER_BURN;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    //25) END FEEDBACK
+
+    // DARK RANGER
+
+    //26) BLACK ARROW
+    //TODO: balance
+    spellId = SPELL_BLACK_ARROW; //20733
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    //sinfo->SpellFamilyFlags[0] = 0x0;
+    sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+    //sinfo->SpellFamilyFlags[2] = 0x0;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_RANGED;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_PACIFY;
+    sinfo->Dispel = DISPEL_NONE;
+    sinfo->Mechanic = MECHANIC_NONE;
+    sinfo->SpellLevel = 40;
+    sinfo->BaseLevel = 40;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //5-30 yds
+    sinfo->DurationEntry = sSpellDurationStore.LookupEntry(85); //18 sec
+    sinfo->RecoveryTime = 3000;
+    sinfo->StartRecoveryCategory = 133;
+    sinfo->StartRecoveryTime = 1500;
+    sinfo->ManaCost = 6 * 5 * 2; //need to increase cost since ability is not autocast, has cd and deals more damage
+    sinfo->MaxAffectedTargets = 1;
+    sinfo->AuraInterruptFlags = AURA_INTERRUPT_FLAG_CHANGE_MAP;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes |= SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK;
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+    sinfo->AttributesEx2 |= SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS/* | SPELL_ATTR2_CANT_CRIT*/;
+    sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_WEAPON_PERCENT_DAMAGE;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    sinfo->Effects[0].BasePoints = 150;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].BonusMultiplier = 1.f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 0.f;
+    sinfo->Effects[0].ValueMultiplier = 1.f;
+    sinfo->Effects[0].RadiusEntry = nullptr;
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_PERIODIC_DAMAGE;
+    sinfo->Effects[1].BasePoints = 100;
+    sinfo->Effects[1].DieSides = 0;
+    sinfo->Effects[1].BonusMultiplier = 2.f;
+    sinfo->Effects[1].DamageMultiplier = 1.f;
+    sinfo->Effects[1].RealPointsPerLevel = 10.f;
+    sinfo->Effects[1].ValueMultiplier = 1.f;
+    sinfo->Effects[1].RadiusEntry = nullptr;
+    sinfo->Effects[1].Amplitude = 2000;
+    //26) END BLACK ARROW
+
+    //27) DRAIN LIFE
+    //TODO: balance
+    spellId = SPELL_DRAIN_LIFE; //17238
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW;
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_SILENCE;
+    sinfo->Dispel = DISPEL_NONE;
+    sinfo->Mechanic = MECHANIC_NONE;
+    sinfo->SpellLevel = 40;
+    sinfo->BaseLevel = 40;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->CastTimeEntry = nullptr;
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(85); //18 sec
+    sinfo->RecoveryTime = 5000;
+    sinfo->StartRecoveryCategory = 133;
+    sinfo->StartRecoveryTime = 1500;
+    sinfo->ManaCost = 75 * 5;
+    sinfo->MaxAffectedTargets = 1;
+    sinfo->AuraInterruptFlags = 0x0;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+    sinfo->Attributes |= SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK;
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+    sinfo->AttributesEx3 |= SPELL_ATTR3_NO_INITIAL_AGGRO | SPELL_ATTR3_IGNORE_HIT_RESULT;
+    sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+    sinfo->AttributesEx5 |= SPELL_ATTR5_START_PERIODIC_AT_APPLY;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_PERIODIC_LEECH;
+    sinfo->Effects[0].BasePoints = 45;
+    sinfo->Effects[0].DieSides = 0;
+    sinfo->Effects[0].BonusMultiplier = 1.f;
+    sinfo->Effects[0].DamageMultiplier = 1.f;
+    sinfo->Effects[0].RealPointsPerLevel = 6.f;
+    sinfo->Effects[0].ValueMultiplier = 2.f;
+    sinfo->Effects[0].RadiusEntry = nullptr;
+    sinfo->Effects[0].Amplitude = 1000;
+    //27) END DRAIN LIFE
+
+    //28) SILENCE
+    //TODO: balance
+    spellId = SPELL_SILENCE; //29943
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+    sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+    sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+    sinfo->PreventionType = SPELL_PREVENTION_TYPE_SILENCE;
+    sinfo->Dispel = DISPEL_MAGIC;
+    sinfo->Mechanic = MECHANIC_SILENCE;
+    sinfo->SpellLevel = 60;
+    sinfo->BaseLevel = 60;
+    sinfo->MaxTargetLevel = 83;
+    sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(2); //250ms
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+    //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(85); //18 sec
+    sinfo->RecoveryTime = 15000;
+    sinfo->StartRecoveryCategory = 133;
+    sinfo->StartRecoveryTime = 1500;
+    sinfo->ManaCost = 75 * 5;
+    sinfo->MaxAffectedTargets = 5;
+    sinfo->AuraInterruptFlags = 0x0;
+    sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT | TARGET_FLAG_DEST_LOCATION;
+    sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_CANT_BE_REDIRECTED;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+    sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_SILENCE;
+    sinfo->Effects[0].BasePoints = 1;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_15_YARDS);
+    //28) END SILENCE
+
+    TC_LOG_INFO("server.loading", "Re-Loading Spell Proc conditions...");
+    sSpellMgr->LoadSpellProcs();
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..28d1c6e
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,499 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "CreatureAI.h"
+#include "botcommon.h"
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+*/
+
+struct PlayerClassLevelInfo;
+
+class TeleportHomeEvent;
+class TeleportFinishEvent;
+
+class bot_ai : public CreatureAI
+{
+    public:
+        virtual ~bot_ai();
+
+        bool canUpdate;
+
+        void InitializeAI() override { Reset(); }
+        void Reset() override { }
+
+        void JustDied(Unit*) override;
+        void KilledUnit(Unit* u) override;
+        void AttackStart(Unit* u) override;
+        void JustEnteredCombat(Unit* u) override;
+        void MoveInLineOfSight(Unit* u) override;
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override;
+        void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/) override { }
+        void ReceiveEmote(Player* player, uint32 emote) override;
+        void EnterEvadeMode(EvadeReason/* why*/ = EVADE_REASON_OTHER) override { }
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        virtual void OnBotDamageDealt(Unit* /*victim*/, uint32 /*damage*/, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* /*spellInfo*/) {}
+        virtual void OnBotDispelDealt(Unit* /*dispelled*/, uint8 /*num*/) {}
+
+        bool GossipHello(Player* player) override;
+        bool GossipSelect(Player* player, uint32 menuId, uint32 gossipListId) override;
+        bool GossipSelectCode(Player* player, uint32 menuId, uint32 gossipListId, char const* code) override;
+
+        bool OnGossipHello(Player* player, uint32 option);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code);
+
+        Creature* GetBotsPet() const { return botPet; }
+
+        void Evade();
+
+        EventProcessor* GetEvents() { return &Events; }
+        ObjectGuid::LowType GetBotOwnerGuid() const { return _ownerGuid; }
+        Player* GetBotOwner() const { return master; }
+        bool SetBotOwner(Player* newowner);
+        uint8 GetBotClass() const { return _botclass; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        virtual void UpdateDeadAI(uint32 /*diff*/) {}
+        void ReturnHome() { _atHome = false; }
+        void CommonTimers(uint32 diff);
+        void ResetBotAI(uint8 resetType);
+        void KillEvents(bool force);
+        bool CanRespawn() { return IAmFree(); }
+        void SetBotCommandState(uint8 st, bool force = false, Position* newpos = nullptr);
+        void RemoveBotCommandState(uint8 st);
+        bool HasBotCommandState(uint8 st) const { return (m_botCommandState & st); }
+        uint8 GetBotCommandState() const { return m_botCommandState; }
+        bool IsInBotParty(Unit const* unit) const;
+        bool CanBotAttack(Unit const* target, int8 byspell = 0) const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const;
+        void ApplyBotSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const;
+        void ApplyBotSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const;
+        void ApplyBotSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const;
+        void ApplyBotSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const;
+        void ApplyBotEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const;
+        void ApplyBotEffectMods(Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value) const;
+        virtual uint8 GetBotStance() const;
+        uint16 GetBotRoles() const { return _roleMask; }
+        bool HasRole(uint16 role) const { return _roleMask & role; }
+        uint8 GetRoleIcon(uint16 role) const;
+        char const* GetRoleString(uint16 role) const;
+        void ToggleRole(uint16 role, bool force);
+        bool IsTank(Unit const* unit = nullptr) const;
+        bool IAmFree() const;
+
+        static bool CCed(Unit const* target, bool root = false);
+
+        void TeleportHome();
+        bool FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/);
+
+        bool IsDuringTeleport() const { return teleFinishEvent || teleHomeEvent; }
+        void SetTeleportFinishEvent(TeleportFinishEvent* tfevent) { ASSERT(!teleFinishEvent); teleFinishEvent = tfevent; }
+        void AbortTeleport();
+
+        uint8 GetPlayerClass() const;
+        uint8 GetPlayerRace() const;
+
+        //bool IsTempBot() const { return me->GetSpawnId() == 0; }
+        bool IsTempBot() const { return me->GetEntry() == BOT_ENTRY_MIRROR_IMAGE_BM; }
+
+        void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        void UpdateHealth() { doHealth = true; }
+        void UpdateMana() { doMana = true; }
+
+        //float GetHitRating() const { return hit; }
+        int32 GetHaste() const { return haste; }
+        float GetBotParryChance() const { return parry; }
+        float GetBotDodgeChance() const { return dodge; }
+        float GetBotBlockChance() const { return block; }
+        float GetBotCritChance() const { return crit; }
+        float GetBotMissChance() const { return -hit; }
+        float GetBotDamageTakenMod(bool magic) const { return magic ? dmg_taken_mag : dmg_taken_phy; }
+        uint32 GetBotExpertise() const { return expertise; }
+        uint32 GetBotSpellPenetration() const { return spellpen; }
+        uint32 GetBotSpellPower() const { return spellpower; }
+        uint32 GetBotDefense() const { return defense; }
+        uint32 GetShieldBlockValue() const { return blockvalue; }
+        int32 GetBotResistanceBonus(SpellSchoolMask mask) const;
+        int32 GetBotResistanceBonus(uint8 school) const { return (school > SPELL_SCHOOL_NORMAL && school < MAX_SPELL_SCHOOL) ? resistbonus[school-1] : 0; }
+        bool CanBlock() const;
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+        bool CanSheath() const;
+        bool CanSit() const;
+        virtual bool CanEat() const;
+        bool CanDrink() const;
+        bool CanRegenInCombat() const;
+        bool CanMount() const;
+        bool CanUseAmmo() const;
+        bool RespectEquipsAttackTime() const;
+        bool CanChangeEquip(uint8 slot) const;
+        virtual bool CanSeeEveryone() const { return false; }
+        virtual float GetBotArmorPenetrationCoef() const { return armor_pen; }
+        virtual uint32 GetAIMiscValue(uint32 /*data*/) const { return 0; }
+        virtual void SetAIMiscValue(uint32 /*data*/, uint32 /*value*/) {}
+        uint8 GetBotComboPoints() const;
+        float GetBotAmmoDPS() const;
+
+        MeleeHitOutcome BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        float GetTotalBotStat(uint8 stat) const { return _getTotalBotStat(stat); }
+
+        Item* GetEquips(uint8 slot) const { return _equips[slot]; }
+        Item* GetEquipsByGuid(ObjectGuid itemGuid) const;
+
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx);
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto);
+        void OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        void OnBotSpellGo(Spell const* spell);
+        virtual void OnClassSpellGo(SpellInfo const* /*spell*/) {}
+
+        static void InitBotCustomSpells();
+        static bool IsBotCustomSpell(uint32 spellId);
+
+        uint32 GetReviveTimer() const { return _reviveTimer; }
+        void SetReviveTimer(uint32 newtime) { _reviveTimer = newtime; }
+        void UpdateReviveTimer(uint32 diff);
+
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+        void ReleaseSpellCooldown(uint32 basespell);
+
+        virtual void SpendRunes(SpellInfo const* /*spellInfo*/, bool /*didHit*/) {}
+
+        void ReInitFaction() { InitFaction(); }
+        void ReinitOwner() { InitOwner(); }
+        void SetSpec(uint8 spec, bool activate = true);
+        uint8 GetSpec() const { return _spec; }
+
+        static bool IsMeleeClass(uint8 m_class);
+        static bool IsTankingClass(uint8 m_class);
+        static bool IsBlockingClass(uint8 m_class);
+        static bool IsCastingClass(uint8 m_class);
+        static bool IsHealingClass(uint8 m_class);
+        static bool IsHumanoidClass(uint8 m_class);
+        static bool IsHeroExClass(uint8 m_class);
+
+        //Pet stuff
+        static uint32 GetPetOriginalEntry(uint32 entry);
+        static bool IsPetMelee(uint32 entry);
+        virtual uint8 GetPetPositionNumber(Creature const* /*summon*/) const { return 0; }
+
+        Unit* HelpFindStunTarget(float dist = 20) const { return FindStunTarget(dist); }
+        Unit* HelpFindCastingTarget(float maxdist = 10, float mindist = 0, uint32 spellId = 0, uint8 minHpPct = 0) const { return FindCastingTarget(maxdist, mindist, spellId, minHpPct); }
+        void HelpGetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, uint8 CCoption, WorldObject const* source = nullptr) const { GetNearbyTargetsList(targets, maxdist, CCoption, source); }
+
+    protected:
+        explicit bot_ai(Creature* creature);
+
+        virtual void ReduceCD(uint32 /*diff*/) {}
+        bool GlobalUpdate(uint32 diff);
+
+        virtual bool HealTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+
+        void BuffAndHealGroup(uint32 diff);
+        void RezGroup(uint32 REZZ);
+        void CureGroup(uint32 cureSpell, uint32 diff);
+        void SetStats(bool force);
+        void DefaultInit();
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        //void RemoveAllSpells();
+        void SpellTimers(uint32 diff);
+        static uint32 RaceSpellForClass(uint8 myrace, uint8 myclass);
+
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        virtual bool HasAbilitiesSpecifics() const { return false; }
+        /*virtual */bool HasAblitiesAllowedList() const { return true; }
+        virtual void FillAbilitiesSpecifics(std::list<std::string> &/*specList*/) {}
+
+        uint32 GetDPSTaken(Unit const* u) const;
+        int32 GetHPSTaken(Unit const* u) const;
+        int32 GetHPS(Unit const* u) const;
+        int32 GetHPPCTPS(Unit const* u) const;
+        uint8 GetExpectedHPPCT(Unit const* u, uint32 mseconds) const;
+
+        void RefreshAura(uint32 spellId, int8 count = 1, Unit* target = nullptr) const;
+        bool CheckAttackTarget();
+        void MoveBehind(Unit const* target) const;
+
+        void AdjustTankingPosition() const;
+        void OnStartAttack(Unit const* u);
+        bool StartAttack(Unit const* u, bool force = false);
+
+        virtual void BreakCC(uint32 diff);
+        void CheckRacials(uint32 diff);
+
+        void DrinkPotion(bool mana);
+        bool IsPotionReady() const;
+        uint32 GetPotion(bool mana) const;
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false);
+        bool doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags);
+        SpellCastResult CheckBotCast(Unit const* victim, uint32 spellId) const;
+        virtual bool removeShapeshiftForm() { return true; }
+
+        bool CanAffectVictim(uint32 schoolMask) const;
+        bool CanRemoveReflectSpells(Unit const* target, uint32 spellId) const;
+
+        bool IsMelee() const;
+
+        bool IsShootingWand(Unit const* u = nullptr) const;
+
+        bool IsChanneling(Unit const* u = nullptr) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        bool IsCasting(Unit const* u = nullptr) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true, false, false)); }
+        bool JumpingFlyingOrFalling() const { return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW); }
+        bool JumpingOrFalling() const { return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_FALLING_SLOW); }
+        bool Jumping() const { return me->HasUnitState(UNIT_STATE_JUMPING); }
+
+        float CalcSpellMaxRange(uint32 spellId, bool enemy = true) const;
+        float InitAttackRange(float origRange, bool ranged) const;
+        void CalculateAttackPos(Unit const* target, Position &pos) const;
+        void GetInPosition(bool force, Unit* newtarget, Position* pos = nullptr);
+        virtual float GetSpellAttackRange(bool longRange) const { return longRange ? 25.f : 15.f; }
+        virtual void CheckAttackState();
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+
+        //Searchers
+        WorldObject* GetNearbyRezTarget(float dist = 30) const;
+        Unit* FindImmunityShieldDispelTarget(float dist = 30) const;
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, ObjectGuid caster = ObjectGuid::Empty, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist, uint32 spellId, bool unattacked = true) const;
+        Unit* FindRootTarget(float dist, uint32 spellId) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, uint32 spellId = 0, uint8 minHpPct = 0) const;
+        Unit* FindAOETarget(float dist) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = nullptr, float splashdist = 4) const;
+        Unit* FindSplashTarget(float dist, Unit* To, float splashdist, uint8 minTargets) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        Unit* FindDistantTauntTarget(float maxdist = 30, bool ally = false) const;
+        Unit* FindDrainTarget(float maxdist = 30) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, uint8 CCoption, WorldObject const* source = nullptr) const;
+        void GetNearbyTargetsInConeList(std::list<Unit*> &targets, float maxdist = 10) const;
+        void GetNearbyFriendlyTargetsList(std::list<Unit*> &targets, float maxdist = 30) const;
+
+        //Bot specific player-like mods hooks
+        //todo remove &damage ApplyClassDamageMultiplierMelee (uint&, CalcDamageInfo&)
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& /*heal*/, SpellInfo const* /*spellInfo*/, DamageEffectType /*damagetype*/, uint32 /*stack*/) const {}
+        virtual void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const {}
+        virtual void ApplyClassSpellCostMods(SpellInfo const* /*spellInfo*/, int32& /*cost*/) const {}
+        virtual void ApplyClassSpellCastTimeMods(SpellInfo const* /*spellInfo*/, int32& /*casttime*/) const {}
+        virtual void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellCategoryCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& /*cooldown*/) const {}
+        virtual void ApplyClassSpellRadiusMods(SpellInfo const* /*spellInfo*/, float& /*radius*/) const {}
+        virtual void ApplyClassSpellRangeMods(SpellInfo const* /*spellInfo*/, float& /*maxrange*/) const {}
+        virtual void ApplyClassSpellMaxTargetsMods(SpellInfo const* /*spellInfo*/, uint32& /*targets*/) const {}
+        virtual void ApplyClassSpellChanceOfSuccessMods(SpellInfo const* /*spellInfo*/, float& /*chance*/) const {}
+        virtual void ApplyClassEffectMods(SpellInfo const* /*spellInfo*/, uint8 /*effIndex*/, float& /*value*/) const {}
+        virtual void ApplyClassEffectMods(Unit const* /*target*/, SpellInfo const* /*spellInfo*/, uint8 /*effIndex*/, float& /*value*/) const {}
+
+        virtual void InitPowers() {}
+        virtual void InitSpells() = 0;
+        virtual void ApplyClassPassives() const = 0;
+        virtual void InitHeals() {}
+
+        void Regenerate();
+        void RegenerateEnergy();
+        bool Feasting() const;
+        uint32 GetRation(bool drink) const;
+
+        bool Wait();
+        uint16 Rand() const;
+        void GenerateRand() const;
+
+        static uint32 GetLostHP(Unit const* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static uint8 GetHealthPCT(Unit const* u) { if (!u || !u->IsAlive() || u->GetMaxHealth() <= 1) return 100; return uint8(((float(u->GetHealth()))/u->GetMaxHealth()) * 100); }
+        static uint8 GetManaPCT(Unit const* u) { if (!u || !u->IsAlive() || u->GetMaxPower(POWER_MANA) <= 1) return 100; return (u->GetPower(POWER_MANA)*10/(1 + u->GetMaxPower(POWER_MANA)/10)); }
+
+        virtual MeleeHitOutcome GetNextAttackMeleeOutCome() const { return MELEE_HIT_CRUSHING; }
+
+        //event helpers
+        void BotJumpInPlaceInFrontOf(Position const* pos, float speedXY, float maxHeight);
+
+        void BuildGrouUpdatePacket(WorldPacket* data);
+
+        void BotSay(char const* text, Player const* target = nullptr) const;
+        void BotWhisper(char const* text, Player const* target = nullptr) const;
+        void BotYell(char const* text, Player const* target = nullptr) const;
+
+        void ApplyItemBonuses(uint8 slot);
+
+        Player* master;
+        Unit* opponent;
+        Creature* botPet;
+        EventProcessor Events;
+        ObjectGuid aftercastTargetGuid;
+        uint32 GC_Timer;
+
+        uint8 _botclass;
+        uint8 _spec, _newspec;
+
+    private:
+        void FindMaster();
+
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate() const;
+        void _OnManaRegenUpdate() const;
+
+        void RemoveItemBonuses(uint8 slot);
+        void RemoveItemEnchantments(Item const* item);
+        void RemoveItemEnchantment(Item const* item, EnchantmentSlot eslot);
+        void RemoveItemClassEnchants();
+        void ApplyItemEnchantments(Item* item, uint8 slot);
+        void ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEquipSpells(Item* item, bool apply);
+        void ApplyItemEquipEnchantmentSpells(Item* item);
+        void ApplyItemSetBonuses(Item* item, bool apply);
+        void ApplyItemsSpells();
+
+        bool IsPotionSpell(uint32 spellId) const;
+        void StartPotionTimer();
+
+        void BotJump(Position const* pos);
+        bool UpdateImpossibleChase(Unit const* target);
+        void ResetChaseTimer(Position const* pos);
+        void ResetChase(Position const* pos);
+
+        void ApplyRacials();
+        void InitRoles();
+        void InitSpec();
+        void InitEquips();
+        void InitOwner();
+        void InitFaction();
+        void InitRace();
+
+        bool _canCureTarget(Unit const* target, uint32 cureSpell) const;
+        void _getBotDispellableAuraList(Unit const* target, uint32 dispelMask, std::list<Aura const*> &dispelList) const;
+        void _calculatePos(Position& pos) const;
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        char const* _getNameForSlot(uint8 slot) const;
+        void _updateEquips(uint8 slot, Item* item);
+
+        bool _canUseOffHand() const;
+        bool _canUseRanged() const;
+        bool _canUseRelic() const;
+        bool _canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel = false) const;
+        bool _unequip(uint8 slot);
+        bool _equip(uint8 slot, Item* newItem);
+        bool _resetEquipment(uint8 slot);
+
+        void _castBotItemUseSpell(Item const* item, SpellCastTargets const& targets/*, uint8 cast_count = 0, uint32 glyphIndex = 0*/);
+
+        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
+        void _listAuras(Player const* player, Unit const* unit) const;
+        bool _checkImmunities(Unit const* target, SpellInfo const* spellInfo) const;
+        static float _getAttackDistance(float distance) { return distance*0.72f; }
+
+        //for moved
+        void GetHomePosition(uint16& mapid, Position* pos) const;
+
+        //utilities
+        void _AddItemTemplateLink(Player const* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player const* forPlayer, Item const* item, std::ostringstream &str, bool addIcon = true) const;
+        void _AddQuestLink(Player const* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color = true) const;
+        void _AddProfessionLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player const* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeItem(Player const* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const;
+        void _LocalizeQuest(Player const* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player const* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player const* forPlayer, std::string &gameobjectName, uint32 entry) const;
+
+        float _getBotStat(uint8 slot, uint8 stat) const;
+        float _getTotalBotStat(uint8 stat) const;
+        float _getRatingMultiplier(CombatRating cr) const;
+
+        PlayerClassLevelInfo* _classinfo;
+        SpellInfo const* m_botSpellInfo;
+        Position pos, attackpos;
+
+        uint8 m_botCommandState;
+
+        //stats
+        float hit, parry, dodge, block, crit, dmg_taken_phy, dmg_taken_mag, armor_pen;
+        uint32 expertise, spellpower, spellpen, defense, blockvalue;
+        int32 haste, resistbonus[6];
+
+        //timers
+        uint32 _reviveTimer, _powersTimer, _chaseTimer, _potionTimer;
+        uint32 lastdiff, checkAurasTimer, checkMasterTimer, roleTimer, waitTimer, regenTimer, _updateTimerMedium, _updateTimerEx1;
+
+        uint8 _jumpCount, _evadeCount;
+        uint16 _roleMask;
+        ObjectGuid::LowType _ownerGuid;
+        ObjectGuid _lastTargetGuid;
+        bool doHealth, doMana, shouldUpdateStats;
+        bool feast_health, feast_mana;
+        bool spawned;
+        bool firstspawn;
+        bool _evadeMode;
+        bool _atHome;
+
+        float _energyFraction;
+
+        //counters (this session)
+        uint16 _deathsCount;
+        uint16 _killsCount;
+        uint16 _pvpKillsCount;
+        uint16 _playerKillsCount;
+
+        TeleportHomeEvent* teleHomeEvent;
+        TeleportFinishEvent* teleFinishEvent;
+
+        struct BotSpell
+        {
+            explicit BotSpell() : cooldown(0), enabled(true) {}
+            uint32 spellId;
+            uint32 cooldown;
+            bool enabled;
+        private:
+            BotSpell(BotSpell const&);
+        };
+
+        typedef std::unordered_map<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
+        BotStat _stats[BOT_INVENTORY_SIZE];
+        Item* _equips[BOT_INVENTORY_SIZE];
+
+    protected:
+        typedef std::unordered_map<uint32 /*firstrankspellid*/, BotSpell* /*spell*/> BotSpellMap;
+        BotSpellMap const& GetSpellMap() const { return _spells; }
+
+    private:
+        BotSpellMap _spells;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_archmage_ai.cpp b/src/server/game/AI/NpcBots/bot_archmage_ai.cpp
new file mode 100644
index 0000000..6ee4c54
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_archmage_ai.cpp
@@ -0,0 +1,357 @@
+#include "bot_ai.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "TemporarySummon.h"
+/*
+Archmage NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Archmage (Warcraft III tribute)
+Abilities:
+1) Fireball: main attack, single target, no mana cost
+2) Blizzard: typical blizzard
+3) Summon Water Elemental: summons a water elemental to attack archmage's enemies
+Complete - 75%
+TODO: mass tele
+*/
+
+enum ArchmageBaseSpells
+{
+    MAIN_ATTACK_1           = SPELL_FIREBALL,
+    BLIZZARD_1              = SPELL_BLIZZARD,
+    SUMMON_WATER_ELEMENTAL_1= SPELL_SUMMON_WATER_ELEMENTAL
+};
+enum ArchmagePassives
+{
+    BRILLIANCE_AURA         = SPELL_BRILLIANCE_AURA
+};
+enum ArchmageSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+
+    SUMMON_ELEM_COST        = 125 * 5,
+
+    ARCHMAGE_MOUNTID        = 2402
+};
+
+class archmage_bot : public CreatureScript
+{
+public:
+    archmage_bot() : CreatureScript("archmage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new archmage_botAI(creature);
+    }
+
+    struct archmage_botAI : public bot_ai
+    {
+/*
+        bool GossipHello(Player* player) override
+        {
+            return OnGossipHello(player, 0);
+        }
+
+        bool GossipSelect(Player* player, uint32 sender, uint32 action) override
+        {
+            return OnGossipSelect(player, me, sender, action);
+        }
+
+        bool GossipSelectCode(Player* player, uint32 sender, uint32 action, char const* code) override
+        {
+            return OnGossipSelectCode(player, me, sender, action, code);
+        }
+*/
+        archmage_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_ARCHMAGE;
+
+            //archmage immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_BLOCK_SPELL_FAMILY, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INTERRUPT, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void AttackStart(Unit*) override { }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+
+            checkAuraTimer = 10000;
+
+            if (!me->HasAura(BRILLIANCE_AURA, me->GetGUID()))
+                RefreshAura(BRILLIANCE_AURA);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!me->IsMounted())
+                me->Mount(ARCHMAGE_MOUNTID);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            CheckAura(diff);
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < SUMMON_ELEM_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            //pet is killed or unreachable
+            if (IsSpellReady(SUMMON_WATER_ELEMENTAL_1, diff, false) && me->GetPower(POWER_MANA) >= SUMMON_ELEM_COST && !IsCasting() &&
+                (IAmFree() || master->IsInCombat()/* || !master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING)*/) &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+            {
+                me->CastSpell(me, GetSpell(SUMMON_WATER_ELEMENTAL_1), false);
+                return;
+            }
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (GC_Timer > diff)
+                return;
+
+            if (CanAffectVictim(SPELL_SCHOOL_MASK_FROST))
+            {
+                //Blizzard
+                if (IsSpellReady(BLIZZARD_1, diff) && !JumpingOrFalling() && Rand() < 50)
+                {
+                    if (Unit* blizztarget = FindAOETarget(CalcSpellMaxRange(BLIZZARD_1)))
+                    {
+                        if (doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                            return;
+                    }
+
+                    SetSpellCooldown(BLIZZARD_1, 1000); //fail
+                }
+            }
+
+            if (IsSpellReady(MAIN_ATTACK_1, diff))
+            {
+                if (doCast(opponent, GetSpell(MAIN_ATTACK_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (crit)
+                pctbonus *= 1.333f;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == BLIZZARD_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->Effects[0].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == BLIZZARD_1)
+                GC_Timer = me->GetAttackTime(BASE_ATTACK);
+
+            if (baseId == MAIN_ATTACK_1)
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+
+            if (baseId == SUMMON_WATER_ELEMENTAL_1)
+                SummonBotPet();
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_AWATER_ELEMENTAL;
+
+            Position pos;
+
+            //water elemetal 1 minute duration
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, std::chrono::minutes(IAmFree() ? 60 : 1));
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 2, me->GetOrientation());
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, SUMMON_WATER_ELEMENTAL_1);
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_AWATER_ELEMENTAL;
+                default:
+                    return 0;
+            }
+        }
+
+        void CheckAttackState() override
+        {
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            checkAuraTimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(MAIN_ATTACK_1, true, false);
+            InitSpellMap(BLIZZARD_1, true, false);
+            InitSpellMap(SUMMON_WATER_ELEMENTAL_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case BLIZZARD_1:
+                case SUMMON_WATER_ELEMENTAL_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+
+        uint32 checkAuraTimer;
+    };
+};
+
+void AddSC_archmage_bot()
+{
+    new archmage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_bm_ai.cpp b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
new file mode 100644
index 0000000..6511b3b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
@@ -0,0 +1,905 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "TemporarySummon.h"
+/*
+Blademaster NpcBot (by Trickerer onlysuffering@gmail.com)
+DISABLED: movement mechanics incompatibility
+Complete - 75%
+TODO: BLADESTORM, Convert illusions to bot_pet_ai
+*/
+
+enum BlademasterBaseSpells
+{
+    WINDWALK_1                              = SPELL_NETHERWALK,
+    MIRROR_IMAGE_1                          = SPELL_MIRROR_IMAGE_BM,
+    CRITICAL_STRIKE_1                       = SPELL_CRITICAL_STRIKE
+};
+enum BlademasterPassives
+{
+//Talents
+//other
+};
+enum BlademasterSpecial
+{
+    NPC_MIRROR_IMAGE                        = 70552,
+    TRANSPARENCY                            = SPELL_TRANSPARENCY_50,
+    BLACK_COLOR                             = SPELL_VERTEX_COLOR_BLACK,
+    STUN_FREEZE                             = SPELL_STUN_FREEZE_ANIM,
+
+    MIRROR_COST                             = 125 * 5
+};
+
+#define MAX_ILLUSION_POSITIONS 4
+#define MIRROR_IMAGE_DURATION 90000
+
+class blademaster_bot : public CreatureScript
+{
+public:
+    blademaster_bot() : CreatureScript("blademaster_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new blademaster_botAI(creature);
+    }
+
+    struct blademaster_botAI : public bot_ai
+    {
+/*
+        bool GossipHello(Player* player) override
+        {
+            return OnGossipHello(player, 0);
+        }
+
+        bool GossipSelect(Player* player, uint32 sender, uint32 action) override
+        {
+            return OnGossipSelect(player, me, sender, action);
+        }
+
+        bool GossipSelectCode(Player* player, uint32 sender, uint32 action, char const* code) override
+        {
+            return OnGossipSelectCode(player, me, sender, action, code);
+        }
+*/
+    private:
+        //DelayedMeleeDamageEvent - Blademaster
+        //deals critical damage, resets attack timer and sends fake log
+        class DelayedMeleeDamageEvent : public BasicEvent
+        {
+            public:
+                DelayedMeleeDamageEvent(Creature* bot, ObjectGuid targetGuid, bool windwalk) :
+                  _bot(bot), _targetGuid(targetGuid), _windwalk(windwalk), _dinfo(nullptr) { }
+
+                void SetDamageInfo(CalcDamageInfo* dinfo)
+                {
+                    _dinfo = dinfo;
+                }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->CriticalStrikeFinish(_targetGuid, _dinfo, _windwalk);
+
+                    if (_dinfo)
+                        delete _dinfo;
+                    return true;
+                }
+
+            private:
+                Creature* _bot;
+                ObjectGuid _targetGuid;
+                bool _windwalk;
+                CalcDamageInfo* _dinfo;
+                DelayedMeleeDamageEvent(DelayedMeleeDamageEvent const&);
+        };
+
+        class EventTerminateEvent : public BasicEvent
+        {
+            public:
+                EventTerminateEvent(Creature* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->TerminateEvent();
+                    return true;
+                }
+
+            private:
+                Creature* _bot;
+                EventTerminateEvent(EventTerminateEvent const&);
+        };
+
+        class IllusionUnsummonEvent : public BasicEvent
+        {
+            public:
+                IllusionUnsummonEvent(Creature const* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->UnsummonAll();
+
+                    return true;
+                }
+
+            private:
+                Creature const* _bot;
+                IllusionUnsummonEvent(IllusionUnsummonEvent const&);
+        };
+
+        class DelayedIllusionSummonEvent : public BasicEvent
+        {
+            public:
+                DelayedIllusionSummonEvent(Creature const* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->MirrorImageFinish();
+
+                    return true;
+                }
+
+            private:
+                Creature const* _bot;
+                DelayedIllusionSummonEvent(DelayedIllusionSummonEvent const&);
+        };
+
+        class DisappearEvent : public BasicEvent
+        {
+            public:
+                DisappearEvent(Creature* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->MirrorImageMid();
+
+                    return true;
+                }
+
+            private:
+                Creature* _bot;
+                DisappearEvent(DisappearEvent const&);
+        };
+
+        void _calcIllusionPositions()
+        {
+            float x = me->m_positionX;
+            float y = me->m_positionY;
+            float z = me->m_positionZ;
+            float o = me->GetOrientation();
+
+            //X     X
+            //   C
+            //X     X
+            //
+            //C - caster (Blademaster)
+            //X - new positions (1-3 illusions + blademaster)
+
+            float dist = 3.f; //not too far - 3 for x and y seems to be way to go
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                _illusPos[i].m_positionX = x + ((i <= 1) ? +dist : -dist); // +2+2-2-2
+                _illusPos[i].m_positionY = y + (!(i & 1) ? +dist : -dist); // +2-2+2-2
+                _illusPos[i].m_positionZ = z;
+                me->UpdateAllowedPositionZ(_illusPos[i].m_positionX, _illusPos[i].m_positionY, _illusPos[i].m_positionZ);
+                _illusPos[i].SetOrientation(o);
+            }
+        }
+
+    public:
+        blademaster_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_BM;
+            //Blademaster cannot be disarmed
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+        }
+
+        void IllusionsCheck(uint32 diff)
+        {
+            if (!me->IsAlive())
+                return;
+            if (Illusions_Check_Timer > diff)
+                return;
+
+            Illusions_Check_Timer = 250;
+
+            if (_illusionGuids.empty())
+                return;
+
+            for (std::list<ObjectGuid>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                Creature* ill = ObjectAccessor::GetCreature(*me, *itr);
+                if (!ill)
+                {
+                    TC_LOG_ERROR("entities.player", "bm_bot::IllusionsCheck(): unit %u is not found in world!", (*itr).GetCounter());
+                    continue;
+                }
+
+                ill->SetCanModifyStats(false);
+                float hpct = ill->GetHealthPct();
+                float mpct = (float(ill->GetPower(POWER_MANA)) * 100.f) / float(ill->GetMaxPower(POWER_MANA));
+
+                ill->SetMaxHealth(me->GetMaxHealth());
+                ill->SetHealth(uint32(0.5f + float(ill->GetMaxHealth()) * hpct / 100.f));
+                ill->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                ill->SetPower(POWER_MANA, uint32(0.5f + float(ill->GetMaxPower(POWER_MANA)) * mpct / 100.f));
+                ill->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                ill->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+                ill->m_modAttackSpeedPct[BASE_ATTACK] = me->m_modAttackSpeedPct[BASE_ATTACK];
+            }
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            //custom
+            if (_dmdevent)
+                return false;
+            if (IsTempBot()) //Illusion etc.
+                return false;
+
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            IllusionsCheck(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (IsPotionReady() && !IsTempBot())
+            {
+                if (me->GetPower(POWER_MANA) < MIRROR_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            //CheckRacials(diff);
+
+            CheckWindWalk(diff);
+            CheckMirrorImage(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void AttackStart(Unit*) override { }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        bool CanEat() const override { return Windwalk_Timer <= GetLastDiff() && !illusion_Fade; }
+        bool CanSeeEveryone() const override { return Windwalk_Timer > GetLastDiff(); }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (IsSpellReady(WINDWALK_1, diff) && !IsTank(me) && Rand() < 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsMelee());
+
+            MoveBehind(opponent);
+        }
+
+        void DoBMMeleeAttackIfReady()
+        {
+            //Copied from UnitAI::DoMeleeAttackIfReady() with modifications
+            //cannot attack while casting or jumping
+            if (me->HasUnitState(UNIT_STATE_CASTING) || _dmdevent)
+                return;
+
+            Unit* victim = me->GetVictim();
+            //Make sure our attack is ready and we aren't currently casting before checking distance
+            if (me->isAttackReady() && me->IsWithinMeleeRange(victim))
+            {
+                if (!CCed(me, true) && !JumpingFlyingOrFalling())
+                {
+                    //Windwalk strike
+                    if (Windwalk_Timer > GetLastDiff())
+                    {
+                        CriticalStrike(victim, true);
+                        return;
+                    }
+                    //Critical Strike: 15% to deal x2,x3, etc... damage
+                    else if (criticalStikeMult >= 2 && !CCed(me, true) && roll_chance_f(15.f))
+                    {
+                        CriticalStrike(victim);
+                        return;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+                return;
+            }
+        }
+
+        void CheckAttackState() override
+        {
+            if (me->GetVictim())
+            {
+                if (HasRole(BOT_ROLE_DPS))
+                    DoBMMeleeAttackIfReady();
+            }
+        }
+
+        void CheckWindWalk(uint32 diff)
+        {
+            if (!IsSpellReady(WINDWALK_1, diff) || Windwalk_Timer > GetLastDiff() || illusion_Fade || IsCasting() ||
+                Rand() > (10 + 20 * (me->IsInCombat() || master->IsInCombat())))
+                return;
+
+            if (!IAmFree() && master->isMoving())
+            {
+                if (me->GetDistance(master) > 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+
+                return;
+            }
+
+            if (!IsTank(me))
+            {
+                //unit to strike
+                Unit* u = IsMelee() ? me->GetVictim() : nullptr;
+
+                if ((u && u->isMoving() && me->GetDistance(u) > 18 &&
+                    (u->GetVictim() != me || u->getAttackers().size() > uint8(u->IsControlledByPlayer() ? 0 : 1))) ||
+                    me->getAttackers().size() > 2)
+                {
+                    if (doCast(me, GetSpell(WINDWALK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckMirrorImage(uint32 diff)
+        {
+            //only for controlled bot
+            //if (IAmFree())
+            //    return;
+            if (!IsSpellReady(MIRROR_IMAGE_1, diff) || !me->IsInCombat() || !illusionsCount || illusion_Fade ||
+                !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 20)
+                return;
+
+            uint8 pct = GetHealthPCT(me);
+            uint8 size = uint8(me->getAttackers().size());
+            if (!size)
+                return;
+
+            if (pct > 25 && (size > 3 || pct < (80 + size * 5)))
+                if (doCast(me, GetSpell(MIRROR_IMAGE_1)))
+                    return;
+        }
+
+        void MirrorImageStart()
+        {
+            if (!illusionsCount)
+                return;
+
+            ASSERT(!illusion_Fade);
+            illusion_Fade = true;
+
+            //OKAY
+
+            //destroy existing illusions if any
+            UnsummonAll();
+            //mirror image renders BM invulnerable for a short period of time,
+            //removing all but passive auras
+            Unit::AuraMap const auras = me->GetOwnedAuras(); //copy
+            for (Unit::AuraMap::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            {
+                Aura* aura = iter->second;
+                if (aura->GetSpellInfo()->Attributes & SPELL_ATTR0_PASSIVE)
+                    continue;
+                if (aura->GetId() == SPELL_BURNING_BLADE_BLADEMASTER)
+                    continue;
+                AuraApplication* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+                if (!aurApp)
+                    continue;
+                me->RemoveAura(aurApp, AURA_REMOVE_BY_DEFAULT);
+            }
+
+            me->BotStopMovement();
+            me->AttackStop();
+            me->HandleEmoteCommand(EMOTE_ONESHOT_NONE);
+            me->AddAura(BLACK_COLOR, me);//color
+            me->AddAura(STUN_FREEZE, me);//stop/immunity
+
+            //prepare to disappear
+            DisappearEvent* devent = new DisappearEvent(me);
+            Events.AddEvent(devent, Events.CalculateTime(std::chrono::milliseconds(300))); //immediatelly (almost)
+        }
+
+        void MirrorImageMid()
+        {
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+            {
+                me->RemoveAura(BLACK_COLOR);
+                me->RemoveAura(STUN_FREEZE);
+                illusion_Fade = false;
+                return;
+            }
+            //disappear
+            me->SetPhaseMask(0, true);
+
+            //INVISIBLE!
+            //EVENT
+            DelayedIllusionSummonEvent* disevent = new DelayedIllusionSummonEvent(me);
+            Events.AddEvent(disevent, Events.CalculateTime(std::chrono::milliseconds(1250))); //1000 ms disappear time + 250 ms buffer
+        }
+
+        void MirrorImageFinish()
+        {
+            illusion_Fade = false;
+            me->RemoveAura(BLACK_COLOR);
+            me->RemoveAura(STUN_FREEZE);
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+                return;
+
+            _calcIllusionPositions();
+
+            std::set<uint8> usedposs;
+
+            for (uint8 i = 0; i != illusionsCount; ++i)
+            {
+                Creature* illusion = me->SummonCreature(NPC_MIRROR_IMAGE, *me, TEMPSUMMON_MANUAL_DESPAWN);
+                if (!illusion)
+                    continue;
+
+                if (!IAmFree())
+                    master->GetBotMgr()->AddBot(illusion, false);
+
+                illusion->SetCreatorGUID(me->GetGUID()); //TempSummon* Map::SummonCreature()
+
+                //copy visuals
+                //illusion->SetEntry(me->GetEntry());
+                illusion->UpdateEntry(me->GetEntry());
+                illusion->SetFaction(me->GetFaction());
+                illusion->SetLevel(me->GetLevel());
+                illusion->SetDisplayId(me->GetDisplayId());
+                illusion->SetNativeDisplayId(me->GetDisplayId());
+                illusion->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0));
+
+                //copy stats
+                illusion->SetCanModifyStats(false);
+                illusion->SetMaxHealth(me->GetMaxHealth());
+                illusion->SetHealth(me->GetHealth());
+                illusion->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                illusion->SetPower(POWER_MANA, me->GetPower(POWER_MANA));
+                illusion->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                illusion->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+                illusion->m_modAttackSpeedPct[BASE_ATTACK] = me->m_modAttackSpeedPct[BASE_ATTACK];
+
+                illusion->BotStopMovement();
+                while (true)
+                {
+                    //move illusion to a random corner
+                    uint8 j = urand(0, MAX_ILLUSION_POSITIONS - 1);
+                    if (usedposs.find(j) == usedposs.end())
+                    {
+                        illusion->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[j]);
+                        //illusion->Relocate(_illusPos[j]);
+                        usedposs.insert(j);
+                        break;
+                    }
+                }
+
+                illusion->GetBotAI()->SetBotCommandState(BOT_COMMAND_COMBATRESET);
+
+                _illusionGuids.push_back(illusion->GetGUID());
+            }
+
+            SetBotCommandState(BOT_COMMAND_COMBATRESET);
+
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                if (usedposs.find(i) == usedposs.end())
+                {
+                    //me->BotStopMovement();
+                    me->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[i]);
+                    //me->Relocate(_illusPos[i]);
+                    //usedposs.insert(i);
+                    break;
+                }
+            }
+
+            uint8 counter = 0;
+            uint8 r = urand(0, uint8(_illusionGuids.size() - 1));
+            uint32 phaseMask = IAmFree() ? PHASEMASK_NORMAL : master->GetPhaseMask();
+
+            for (std::list<ObjectGuid>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (Creature* illusion = ObjectAccessor::GetCreature(*me, *itr))
+                    illusion->SetPhaseMask(phaseMask, true);
+
+                if (counter == r)
+                    me->SetPhaseMask(phaseMask, true);
+                else
+                    ++counter;
+            }
+
+            me->GetCombatManager().EndAllPvECombat();
+
+            if (me->GetPhaseMask() != phaseMask)
+                me->SetPhaseMask(phaseMask, true);
+
+            //me->setAttackTimer(BASE_ATTACK, 3000);
+            //waitTimer += 800;
+            SetSpellCooldown(MIRROR_IMAGE_1, 8000);
+
+            //EVENT
+            IllusionUnsummonEvent* unsevent = new IllusionUnsummonEvent(me);
+            Events.AddEvent(unsevent, Events.CalculateTime(std::chrono::milliseconds(MIRROR_IMAGE_DURATION)));
+        }
+
+        void CriticalStrike(Unit* target, bool windwalk = false)
+        {
+            //Okay critical strike must have jump and strike animation, doing delayed damage
+            _dmdevent = new DelayedMeleeDamageEvent(me, target->GetGUID(), windwalk);
+
+            //hack temp attack damage calc
+            float mindam = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float maxdam = me->GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+
+            if (windwalk)
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * 1.5f);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * 1.5f);
+                me->RemoveAura(GetSpell(WINDWALK_1));
+                me->RemoveAura(TRANSPARENCY);
+            }
+            else
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * criticalStikeMult);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * criticalStikeMult);
+            }
+
+            CalcDamageInfo* dinfo = new CalcDamageInfo();
+            me->CalculateMeleeDamage(target, dinfo, BASE_ATTACK);
+
+            me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam);
+            me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam);
+
+            _dmdevent->SetDamageInfo(dinfo);
+            Events.AddEvent(_dmdevent, Events.CalculateTime(std::chrono::milliseconds(250)));
+
+            BotJumpInPlaceInFrontOf(target, 0.25f, 4.1f); //jump - DO NOT CHANGE
+            me->CastSpell(target, SPELL_COMBAT_SPECIAL_2H_ATTACK, true); //strike anim
+            me->resetAttackTimer(BASE_ATTACK);
+        }
+
+        void CriticalStrikeFinish(ObjectGuid targetGuid, CalcDamageInfo* calcdinfo, bool /*windwalk*/)
+        {
+            EventTerminateEvent* etevent = new EventTerminateEvent(me);
+            Events.AddEvent(etevent, Events.CalculateTime(std::chrono::milliseconds(750)));
+
+            if (!me->IsInWorld() || !me->IsAlive() || CCed(me))
+            {
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            Unit* target = ObjectAccessor::GetUnit(*me, targetGuid);
+            if (!target || !target->IsAlive())
+            {
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            if (target->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //target became immune
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_IMMUNE);
+                target->PlayDistanceSound(SOUND_ABSORB_GET_HIT);
+                Windwalk_Timer = 0;
+                return;
+            }
+            else if (!CanSeeEveryone() && !me->CanSeeOrDetect(target, false, false))
+            {
+                //target disappeared
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_MISS/*SPELL_MISS_EVADE*/);
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            target->PlayDistanceSound(SOUND_AXE_2H_IMPACT_FLESH_CRIT);
+
+            DamageInfo dinfo(*calcdinfo, 0);
+
+            me->SendSpellNonMeleeDamageLog(target, CRITICAL_STRIKE_1,
+                dinfo.GetDamage() + dinfo.GetAbsorb() + dinfo.GetResist() + dinfo.GetBlock(),
+                SPELL_SCHOOL_MASK_NORMAL, dinfo.GetAbsorb(), dinfo.GetResist(), false, dinfo.GetBlock(), true, false);
+            CleanDamage cl(0, 0, BASE_ATTACK, MELEE_HIT_CRIT);
+            Unit::DealDamage(me, target, dinfo.GetDamage(), &cl);
+            Unit::ProcSkillsAndAuras((Unit*)me, calcdinfo->Target, calcdinfo->ProcAttacker, calcdinfo->ProcVictim, 0, 0, calcdinfo->HitInfo, nullptr, &dinfo, nullptr);
+            me->AtTargetAttacked(target, false);
+
+            me->resetAttackTimer(BASE_ATTACK);
+            Windwalk_Timer = 0;
+        }
+
+        void TerminateEvent()
+        { _dmdevent = nullptr; }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const override
+        {
+            return _dmdevent ? MELEE_HIT_NORMAL : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        float GetBotArmorPenetrationCoef() const override
+        {
+            return 80.0f + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(WINDWALK_1))
+            {
+                Windwalk_Timer = 30000; //TODO:
+                me->RemoveMovementImpairingAuras(true);
+                me->PlayDistanceSound(SOUND_FREEZE_IMPACT_WINDWALK, !IAmFree() ? master : nullptr);
+
+                uint32 dur = 30000;
+                if (Aura* aura = me->GetAura(spellId))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+                if (Aura* aura = me->GetAura(TRANSPARENCY))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+
+                if (GetHealthPCT(me) < 25 || !HasRole(BOT_ROLE_DPS))
+                    me->AttackStop();
+
+                //SpellEffectSanctuary
+                me->GetCombatManager().SuppressPvPCombat();
+                Unit::AttackerSet const& attackers = me->getAttackers();
+                for (Unit::AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+                {
+                    if (!(*itr)->CanSeeOrDetect(me))
+                        (*(itr++))->AttackStop();
+                    else
+                        ++itr;
+                }
+
+                me->m_lastSanctuaryTime = getMSTime();
+            }
+
+            if (spellId == GetSpell(MIRROR_IMAGE_1))
+            {
+                MirrorImageStart();
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Illusions deal no damage
+            if (IsTempBot())
+            {
+                //manually add threat as if damage was done
+                if (victim->GetTypeId() == TYPEID_UNIT)
+                    victim->GetThreatManager().AddThreat(me, float(damage + damage));
+
+                damage = 0;
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage) override
+        {
+            //illusions take twice as much damage
+            if (IsTempBot())
+            {
+                damage *= 2;
+                //return;
+            }
+            if (illusion_Fade)
+            {
+                damage = 0;
+                return;
+            }
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void JustDied(Unit* u) override
+        {
+            TerminateEvent();
+
+            if (IsTempBot())
+                if (me->GetCreatorGUID().IsCreature())
+                    if (Unit* bot = ObjectAccessor::GetUnit(*me, me->GetCreatorGUID()))
+                        if (bot->ToCreature()->IsNPCBot())
+                            bot->ToCreature()->OnBotDespawn(me);
+
+            bot_ai::JustDied(u);
+
+            if (!IsTempBot())
+                UnsummonAll();
+        }
+
+        void OnBotDespawn(Creature* summon) override
+        {
+            if (!summon)
+                return;
+
+            for (std::list<ObjectGuid>::iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (*itr == summon->GetGUID())
+                {
+                    _illusionGuids.erase(itr);
+                    return;
+                }
+            }
+        }
+
+        void UnsummonAll() override
+        {
+            while (!_illusionGuids.empty())
+            {
+                std::list<ObjectGuid>::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = ObjectAccessor::GetCreature(*me, *itr))
+                    illusion->AI()->JustDied(nullptr);
+                else
+                    _illusionGuids.erase(itr);
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case CRITICAL_STRIKE_1:
+                    return criticalStikeMult;
+                case MIRROR_IMAGE_1:
+                    return illusionsCount;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            _dmdevent = nullptr;
+            Windwalk_Timer = 0;
+            criticalStikeMult = 1;
+            illusionsCount = 0;
+            illusion_Fade = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (Windwalk_Timer > diff)          Windwalk_Timer -= diff;
+            if (Illusions_Check_Timer > diff)   Illusions_Check_Timer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+            me->SetMaxPower(POWER_MANA, 75);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+
+ /*Special*/lvl >= 10 ? InitSpellMap(WINDWALK_1) : RemoveSpell(WINDWALK_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(MIRROR_IMAGE_1) : RemoveSpell(MIRROR_IMAGE_1);
+
+            criticalStikeMult =
+                lvl < 10 ? 1 :
+                lvl < 30 ? 2 :
+                lvl < 50 ? 3 :
+                lvl < 82 ? 4 : 5;
+
+            illusionsCount =
+                lvl < 20 ? 0 :
+                lvl < 40 ? 1 :
+                lvl < 70 ? 2 : 3;
+        }
+
+        void ApplyClassPassives() const override
+        {
+            RefreshAura(SPELL_BURNING_BLADE_BLADEMASTER);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case WINDWALK_1:
+                case MIRROR_IMAGE_1:
+                    return true;
+                default:
+                    break;
+            }
+
+            return false;
+        }
+
+    private:
+        DelayedMeleeDamageEvent* _dmdevent;
+        std::list<ObjectGuid> _illusionGuids;
+        Position _illusPos[MAX_ILLUSION_POSITIONS];
+
+        uint32 Windwalk_Timer;
+        uint32 Illusions_Check_Timer;
+        uint8 criticalStikeMult;
+        uint8 illusionsCount;
+        bool illusion_Fade;
+    };
+};
+
+void AddSC_blademaster_bot()
+{
+    new blademaster_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp b/src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp
new file mode 100644
index 0000000..0c46633
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp
@@ -0,0 +1,589 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "TemporarySummon.h"
+/*
+Dark Ranger NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+A former ranger of Quel'thalas forcibly raised from the dead (Warcraft III tribute)
+Specifics:
+Spell damage taken reduced by 35%, partially immune to control effects, leather/cloth armor,
+deals physical/spellshadow damage, spell power bonus: 50% intellect. Main attribute: Agility
+Abilities:
+1) Silence. Silences an enemy and up to 4 nearby targets for 8 seconds, 15 seconds cooldown
+2) Black Arrow. Fires a cursed arrow dealing 150% weapon damage and additional spellshadow damage over time.
+If affected target dies from Dark Ranger\'s damage, a Dark Minion will spawn from the corpse
+(maximum 5 Minions, 80 seconds duration, only works on humanoids, beasts and dragonkin),
+skeleton level depends on level of the killed unit
+Deals five times more damage if target is under 20% health
+3) Drain Life. Drains health from an enemy every second for 5 seconds (6 ticks),
+healing Dark Ranger for 200% of the drained amount
+4) Charm NIY
+5ex) Auto Shot. A hunter auto shot ability since dark ranger is purely ranged and only uses bows.
+Complete - 75%
+TODO: Charm
+*/
+
+enum DarkRangerBaseSpells
+{
+    AUTO_SHOT_1                         = 75,
+    BLACK_ARROW_1                       = SPELL_BLACK_ARROW,
+    DRAIN_LIFE_1                        = SPELL_DRAIN_LIFE,
+    SILENCE_1                           = SPELL_SILENCE
+};
+enum DarkRangerPassives
+{
+};
+enum DarkRangerSpecial
+{
+    DRAINLIFE_COST                      = 75 * 5,
+    MAX_MINIONS                         = 5,
+
+    SPELL_SPAWN_ANIM                    = 25035,
+    SPELL_BLOODY_EXPLOSION              = 36599,
+    SPELL_THREAT_MOD                    = 31745, //Salvation
+
+    MODEL_BLOODY_BONES                  = 25538
+};
+
+class dark_ranger_bot : public CreatureScript
+{
+public:
+    dark_ranger_bot() : CreatureScript("dark_ranger_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new dark_ranger_botAI(creature);
+    }
+
+    struct dark_ranger_botAI : public bot_ai
+    {
+/*
+        bool GossipHello(Player* player) override
+        {
+            return OnGossipHello(player, 0);
+        }
+
+        bool GossipSelect(Player* player, uint32 sender, uint32 action) override
+        {
+            return OnGossipSelect(player, me, sender, action);
+        }
+
+        bool GossipSelectCode(Player* player, uint32 sender, uint32 action, char const* code) override
+        {
+            return OnGossipSelectCode(player, me, sender, action, code);
+        }
+*/
+        dark_ranger_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DARK_RANGER;
+
+            //dark ranger immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_RANGED, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void KilledUnit(Unit* u) override
+        {
+            bot_ai::KilledUnit(u);
+
+            if (u->GetGUID() == _blackArrowKillGUID)
+            {
+                //black arrow affection -> spawn skeleton (launch)
+                SummonBotPet(u);
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (Rand() > 55)
+                return;
+
+            if (IsSpellReady(SILENCE_1, diff))
+            {
+                Unit* target = FindCastingTarget(CalcSpellMaxRange(SILENCE_1), 0, SILENCE_1);
+                if (target && doCast(target, GetSpell(SILENCE_1)))
+                    return;
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            CheckDrainLife(diff);
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < DRAINLIFE_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 30)
+                    DrinkPotion(false);
+            }
+
+            if (!CheckAttackTarget())
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+
+                if (!IAmFree() && me->IsStandState() && !me->isMoving() && !master->isMoving() && !me->IsMounted() &&
+                    !me->IsInCombat() && !master->IsInCombat() && Rand() < 10 && me->GetDistance(master) < 15 &&
+                    !me->HasStealthAura() && !me->HasInvisibilityAura() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                    _minions.empty())
+                {
+                    me->CastSpell(me, RACIAL_SHADOWMELD, true);
+                }
+
+                return;
+            }
+
+            if (IsCasting())
+                return;
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            Counter(diff);
+
+            CheckBlackArrow(diff);
+
+            float dist = me->GetDistance(opponent);
+            float maxRangeLong = 30.f;
+
+            bool inpostion = !opponent->HasAuraType(SPELL_AURA_MOD_CONFUSE) || dist > maxRangeLong - 15.f;
+
+            //Auto Shot
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == AUTO_SHOT_1 && (shot->m_targets.GetUnitTarget() != opponent || !inpostion))
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (HasRole(BOT_ROLE_DPS)/* && dist > 5*/ && dist < maxRangeLong)
+            {
+                if (doCast(opponent, AUTO_SHOT_1))
+                {}
+            }
+
+            //RANGED SECTION
+            if (dist > maxRangeLong)
+                return;
+
+            //Black Arrow
+            if (IsSpellReady(BLACK_ARROW_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                (Rand() < 20 || !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x4, 0x0, me->GetGUID())))
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+        }
+
+        void CheckDrainLife(uint32 diff)
+        {
+            if (!IsSpellReady(DRAIN_LIFE_1, diff) || !HasRole(BOT_ROLE_DPS) || GetHealthPCT(me) > 70 || Rand() > 80 ||
+                IsCasting())
+                return;
+
+            Unit* target = me->GetVictim();
+            if (!target)
+                target = FindAffectedTarget(GetSpell(BLACK_ARROW_1), me->GetGUID(), 30);
+
+            if (target && doCast(target, GetSpell(DRAIN_LIFE_1)))
+                return;
+        }
+
+        void CheckBlackArrow(uint32 diff)
+        {
+            if (!IsSpellReady(BLACK_ARROW_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 30)
+                return;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsList(targets, 50, 0);
+            targets.remove_if(BOTAI_PRED::AuraedTargetExcludeByCaster(BLACK_ARROW_1, me->GetGUID()));
+            if (Unit* target = !targets.empty() ? Trinity::Containers::SelectRandomContainerElement(targets) : nullptr)
+            {
+                if (doCast(target, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f;
+            //Black Arrow on targets < 20% hp (only direct damage)
+            if (baseId == BLACK_ARROW_1 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+                pctbonus *= 5.f;
+
+            damage = int32(damage * pctbonus + flat_mod);
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f;
+            //if (crit)
+            //{
+            //    //!!!spell damage is not yet critical and will be multiplied by 1.5
+            //    //so we should put here bonus damage mult /1.5
+            //    //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+            //    if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+            //        pctbonus *= 1.16f;
+            //}
+            ////Trap Mastery part 2: 30% bonus damage for Immolation Trap, Explosive Trap and Black Arrow
+            //if (lvl >= 15 && (baseId == IMMOLATION_TRAP_AURA_1 || baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+            //    pctbonus *= 1.3f;
+            //Black Arrow on targets < 20% hp (only direct damage)
+            //if (baseId == BLACK_ARROW_1 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+            //    pctbonus *= 5.f;
+
+            damage = int32(fdamage * pctbonus + flat_mod);
+        }
+
+        void ApplyClassEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Drain Life scaling from health pool: 2%
+            if (baseId == DRAIN_LIFE_1 && effIndex == EFFECT_0)
+                value += float(me->GetMaxHealth()) * 0.02f;
+
+            value = value * pctbonus;
+        }
+
+        void ApplyClassEffectMods(Unit const* /*target*/, SpellInfo const* /*spellInfo*/, uint8 /*effIndex*/, float& value) const
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Rapid Killing: use up buff manually
+            //if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            //{
+            //    if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+            //        if (rapi->IsAffectedOnSpell(spellInfo))
+            //            me->RemoveAura(RAPID_KILLING_BUFF);
+            //}
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* /*spell*/) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (target == me)
+                return;
+
+            //uint32 baseId = spell->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+
+            //if (baseId == HUNTERS_MARK_1)
+            //{
+            //    //DarkRanger's Mark helper
+            //    if (AuraEffect* mark = target->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+            //    {
+            //        //Glyph of DarkRanger's Mark: +20% effect
+            //        //Improved DarkRanger's Mark: +30% effect
+            //        if (lvl >= 15)
+            //            mark->ChangeAmount(mark->GetAmount() + mark->GetAmount() / 2);
+            //        else if (lvl >= 10)
+            //            mark->ChangeAmount(mark->GetAmount() * 13 / 10);
+            //    }
+            //}
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* spellInfo) override
+        {
+            //black arrow affection -> spawn skeleton (mark)
+            if (damage && me->IsAlive() && victim->GetTypeId() == TYPEID_UNIT && damage >= victim->GetHealth() &&
+                (victim->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                victim->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                victim->GetCreatureType() == CREATURE_TYPE_HUMANOID) &&
+                ((spellInfo && spellInfo->GetFirstRankSpell()->Id == BLACK_ARROW_1) ||
+                victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x4, 0x0, me->GetGUID())))
+                _blackArrowKillGUID = victim->GetGUID();
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            uint8 i = 0;
+            for (Summons::const_iterator citr = _minions.begin(); citr != _minions.end(); ++citr)
+            {
+                if ((*citr)->GetGUID() == summon->GetGUID())
+                    return i;
+                ++i;
+            }
+            return 0;
+        }
+
+        void SummonBotPet(Unit* from)
+        {
+            if (_minions.size() >= MAX_MINIONS)
+            {
+                //TC_LOG_ERROR("entities.player", "bot_dranger_ai::SummonBotPet(): max minions");
+                Unit* u = nullptr;
+                //try 1: by minimal level
+                uint8 minlevel = me->GetLevel();
+                for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+                {
+                    if ((*itr)->GetLevel() < minlevel)
+                    {
+                        minlevel = (*itr)->GetLevel();
+                        u = *itr;
+                    }
+                }
+                //try 2: by minimal duration
+                if (!u)
+                {
+                    uint32 minduration = 0;
+                    for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+                    {
+                        if ((*itr)->GetAI()->GetData(BOTPETAI_MISC_DURATION) > minduration)
+                        {
+                            minduration = (*itr)->GetAI()->GetData(BOTPETAI_MISC_DURATION);
+                            u = *itr;
+                        }
+                    }
+                }
+                //if (u)
+                //    TC_LOG_ERROR("entities.player", "bot_dranger_ai::SummonBotPet(): found minion to erase(1)");
+                //try 3: last resort
+                if (!u)
+                u = *(_minions.begin());
+                //if (u)
+                //    TC_LOG_ERROR("entities.player", "bot_dranger_ai::SummonBotPet(): found minion to erase(2)");
+
+                u->ToTempSummon()->UnSummon();
+            }
+
+            //addition: change unit's modelid
+            if (!from->IsPet() && !from->IsVehicle() &&
+                !from->ToCreature()->isWorldBoss() &&
+                !from->ToCreature()->IsDungeonBoss())
+            {
+                from->CastSpell(from, SPELL_BLOODY_EXPLOSION, true);
+                from->SetDisplayId(MODEL_BLOODY_BONES);
+            }
+
+            uint32 rank = from->ToCreature()->GetCreatureTemplate()->rank;
+            uint32 entry = (rank == CREATURE_ELITE_NORMAL) ? BOT_PET_DARK_MINION : BOT_PET_DARK_MINION_ELITE;
+
+            uint8 maxLevel = std::min<uint8>(from->GetLevel(), me->GetLevel());
+
+            Position pos = from->GetPosition();
+
+            Creature* myPet = me->SummonCreature(entry, pos, TEMPSUMMON_MANUAL_DESPAWN);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(master->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, BLACK_ARROW_1);
+
+            //dark minion immunities
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            //heal
+            myPet->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_HEAL, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_HEAL_PCT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_PERIODIC_HEAL, true);
+
+            //myPet->CastSpell(myPet, SPELL_BLOODY_EXPLOSION, true);
+            myPet->CastSpell(myPet, SPELL_SPAWN_ANIM, true);
+            if (Aura* stun = myPet->AddAura(SUMMONING_DISORIENTATION, myPet))
+            {
+                stun->SetDuration(1500);
+                stun->SetMaxDuration(1500);
+            }
+
+            myPet->GetAI()->SetData(BOTPETAI_MISC_MAXLEVEL, maxLevel);
+            _minions.insert(myPet);
+        }
+
+        void UnsummonAll() override
+        {
+            while (!_minions.empty())
+                (*_minions.begin())->ToTempSummon()->UnSummon();
+            //for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+            //    (*itr)->ToTempSummon()->UnSummon();
+
+            //_minions.clear();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all darkranger bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (_minions.find(summon) != _minions.end())
+                _minions.erase(summon);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(BLACK_ARROW_1) - 5.f : 15.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_DARK_MINION;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            //for (uint8 i = 0; i != MAX_SPELL_SCHOOL; ++i)
+            //    me->m_threatModifier[1] = 0.0f;
+
+            _blackArrowKillGUID = 0;
+
+            DefaultInit();
+
+            //threat mod
+            if (Aura* threat = me->AddAura(SPELL_THREAT_MOD, me))
+                threat->GetEffect(0)->ChangeAmount(-100);
+        }
+
+        void ReduceCD(uint32 /*diff*/) override
+        {
+            //if (trapTimer > diff)                   trapTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            //uint8 lvl = me->GetLevel();
+            InitSpellMap(AUTO_SHOT_1);
+            InitSpellMap(BLACK_ARROW_1);
+            InitSpellMap(DRAIN_LIFE_1);
+            InitSpellMap(SILENCE_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+    private:
+        uint64 _blackArrowKillGUID;
+        typedef std::set<Unit*> Summons;
+        Summons _minions;
+    };
+};
+
+void AddSC_dark_ranger_bot()
+{
+    new dark_ranger_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 0000000..902028a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,2057 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Death Knight NpcBot by Trickerer onlysuffering@gmail.com
+Complete - around 85%
+Note: Rune system adapted from TC
+TODO: pet related
+Notes: raise dead / army of the dead not working off the bat, summon garg crash, dancing rune weapon crash, need ai workarounds
+*/
+
+enum DeathKnightBaseSpells
+{
+    BLOOD_STRIKE_1                      = 45902,
+    ICY_TOUCH_1                         = 45477,
+    PLAGUE_STRIKE_1                     = 45462,
+    DEATH_STRIKE_1                      = 49998,
+    OBLITERATE_1                        = 49020,
+    RUNE_STRIKE_1                       = 56815,
+    HEART_STRIKE_1                      = 55050,
+    FROST_STRIKE_1                      = 49143,
+    SCOURGE_STRIKE_1                    = 55090,
+
+    BLOOD_BOIL_1                        = 48721,
+    DEATH_AND_DECAY_1                   = 43265,
+    HOWLING_BLAST_1                     = 49184,
+
+    DEATH_COIL_1                        = 47541,
+    DEATH_GRIP_1                        = 49576,
+    PESTILENCE_1                        = 50842,
+    MIND_FREEZE_1                       = 47528,
+    STRANGULATE_1                       = 47476,
+    CHAINS_OF_ICE_1                     = 45524,
+    ICEBOUND_FORTITUDE_1                = 48792,
+    DARK_COMMAND_1                      = 56222,
+    ANTI_MAGIC_SHELL_1                  = 48707,
+    ARMY_OF_THE_DEAD_1                  = 42650,
+
+    PATH_OF_FROST_1                     = 3714,
+    HORN_OF_WINTER_1                    = 57330,
+    EMPOWER_RUNE_WEAPON_1               = 47568,
+    BLOOD_TAP_1                         = 45529,
+
+    RUNE_TAP_1                          = 48982,
+    LICHBORNE_1                         = 49039,
+    //CE
+    MARK_OF_BLOOD_1                     = 49005,
+    DEATHCHILL_1                        = 49796,
+    HYSTERIA_1                          = 49016,
+    HUNGERING_COLD_1                    = 49203,
+    ANTI_MAGIC_ZONE_1                   = 48707,
+    VAMPIRIC_BLOOD_1                    = 55233,
+    UNBREAKABLE_ARMOR_1                 = 51271,
+    BONE_SHIELD_1                       = 49222,
+
+    BLOOD_PRESENCE_1                    = 48266,
+    FROST_PRESENCE_1                    = 48263,
+    UNHOLY_PRESENCE_1                   = 48265//unused
+};
+enum DeathKnightPassives
+{
+//Talents
+    BUTCHERY                            = 49483,//rank 2
+    TOUGHNESS                           = 49789,//rank 5
+    BLADED_ARMOR                        = 49393,//rank 5
+    SCENT_OF_BLOOD                      = 49509,//rank 3
+    TWO_HANDED_WEAPON_SPECIALIZATION    = 55108,//rank 2
+    ICY_TALONS                          = 50887,//rank 5
+    ANNIHILATION                        = 51473,//rank 3
+    NECROSIS1                           = 51459,
+    NECROSIS2                           = 51462,
+    NECROSIS3                           = 51463,
+    NECROSIS4                           = 51464,
+    NECROSIS5                           = 51465,
+    SPELL_DEFLECTION                    = 49497,//rank 3
+    VENDETTA                            = 55136,//rank 3
+    KILLING_MACHINE                     = 51130,//rank 5
+    CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+    ON_A_PALE_HORSE_A                   = 51970,//rank 2
+    ON_A_PALE_HORSE_B                   = 51986,//rank 2
+    BLOOD_CAKED_BLADE1                  = 49219,
+    BLOOD_CAKED_BLADE2                  = 49627,
+    BLOOD_CAKED_BLADE3                  = 49628,
+    FRIGID_DREADPLATE                   = 51109,//rank 3
+    UNHOLY_BLIGHT                       = 49194,
+    DIRGE                               = 51206,//rank 2
+    BLOODY_VENGEANCE1                   = 48988,
+    BLOODY_VENGEANCE2                   = 49503,
+    BLOODY_VENGEANCE3                   = 49504,
+    ABOMINATIONS_MIGHT                  = 53138,//rank 2
+    IMPROVED_ICY_TALONS                 = 55610,
+    DESECRATION                         = 55667,//rank 2
+    //BLOODWORMS                          = 49543,//rank 3
+    IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+    DESOLATION                          = 66817,//rank 5
+    IMPROVED_UNHOLY_PRESENCE            = 50392,//rank 2
+    THREAT_OF_THASSARIAN                = 66192,//rank 3
+    CRYPT_FEVER                         = 49632,//rank 3
+    WILL_OF_THE_NECROPOLIS              = 52286,//rank 3
+    ACCLIMATION                         = 50152,//rank 3
+    WANDERING_PLAGUE                    = 49655,//rank 3
+    EBON_PLAGUEBRINGER                  = 51161,//rank 3
+
+//Other
+    //GLYPH_DANCING_RUNE_WEAPON           = 63330,
+    GLYPH_DISEASE                       = 63334,
+    GLYPH_CHAINS_OF_ICE                 = 58620,
+    GLYPH_UNHOLY_BLIGHT                 = 63332,
+    CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+
+    ITEM_DEATH_KNIGHT_T8_MELEE_4P       = 64736,
+    ITEM_DEATH_KNIGHT_T9_MELEE_4P       = 67118,
+
+//Special
+    FROST_FEVER                         = 59921,
+    BLOOD_PLAGUE                        = 59879,
+    RUNE_STRIKE_PASSIVE                 = 56816,//rune strike activation req aura
+    RUNIC_POWER_MASTERY                 = 49455//rank 1
+};
+enum DeathKnightSpecial
+{
+    FROST_FEVER_AURA                    = 55095,
+    BLOOD_PLAGUE_AURA                   = 55078,
+    CRYPT_FEVER_AURA                    = 50510,//rank 3
+    EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+    BLADE_BARRIER_BUFF                  = 64859,//rank 5
+    KILLING_MACHINE_BUFF                = 51124,
+    RIME_BUFF                           = 59052,//Freezing Fog
+    ITEM_DEATH_KNIGHT_T10_TANK_4P_BUFF  = 70654,//Blood Armor
+    ITEM_DEATH_KNIGHT_T10_MELEE_4P_BUFF = 70657,//Advantage
+
+    CHILBLAINS_DEBUFF                   = 50436,//Icy Clutch rank 3
+
+    BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+    //UNHOLY_BLIGHT_AURA                  = 50536,
+
+    DEATH_STRIKE_HEAL                   = 45470,
+    DEATH_COIL_HEAL                     = 47633,
+    DEATH_COIL_DAMAGE                   = 47632,
+
+    GLYPH_HEART_STRIKE_DEBUFF           = 58617, //50% move slow
+    GLYPH_RUNE_TAP_HEAL                 = 59754,
+    GLYPH_SCOURGE_STRIKE_EFFECT         = 69961
+};
+
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    int32 Cooldown;
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    struct death_knight_botAI : public bot_ai
+    {
+/*
+        bool OnGossipHello(Player* player) override
+        {
+            return OnGossipHello(player, 0);
+        }
+
+        bool OnGossipSelect(Player* player, uint32 sender, uint32 action) override
+        {
+            return OnGossipSelect(player, me, sender, action);
+        }
+
+        bool OnGossipSelectCode(Player* player, uint32 sender, uint32 action, char const* code) override
+        {
+            return OnGossipSelectCode(player, me, sender, action, code);
+        }
+*/
+        death_knight_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DEATH_KNIGHT;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            if (!HaveRunes(spellId))
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void SpendRunes(SpellInfo const* spellInfo, bool didHit) override
+        {
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src || (src->NoRuneCost() && src->NoRunicPowerGain()))
+                return;
+
+            //Freezing Fog
+            if (rimeProcTimer > GetLastDiff() && spellInfo->Id == HOWLING_BLAST_1)
+            {
+                for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                    runeCost[i] = 0;
+            }
+            else
+            {
+                for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                    runeCost[i] = src->RuneCost[i];
+            }
+
+            runeCost[RUNE_DEATH] = 0;
+
+            //debug 1
+            //std::ostringstream str;
+            //str << "Casted " << spellInfo->SpellName[0] << " cost"
+            //    << " " << runeCost[0] << " " << runeCost[1] << " " << runeCost[2] << " " << runeCost[3];
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes[i].CurrentRune;
+                if (runeCost[rune] > 0 && _runes[i].Cooldown <= 0)
+                    if (SpendRune(rune, didHit))
+                        runeCost[rune]--;
+            }
+
+            runeCost[RUNE_DEATH] = runeCost[RUNE_BLOOD] + runeCost[RUNE_UNHOLY] + runeCost[RUNE_FROST];
+
+            if (runeCost[RUNE_DEATH] > 0)
+            {
+                for (uint8 i = 0; i != MAX_RUNES && runeCost[RUNE_DEATH] > 0; ++i)
+                {
+                    if (_runes[i].CurrentRune == RUNE_DEATH && _runes[i].Cooldown <= 0)
+                        if (SpendRune(RUNE_DEATH, didHit))
+                            runeCost[RUNE_DEATH]--;
+                }
+            }
+
+            //debug 2
+            //uint32 runesLeft[NUM_RUNE_TYPES] = { 0,0,0,0 };
+            //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            //    for (uint8 j = 0; j != MAX_RUNES; ++j)
+            //        if (_runes[j].CurrentRune == i && _runes[j].Cooldown <= 0)
+            //            runesLeft[i]++;
+            //str << " left" << " " << runesLeft[0] << " " << runesLeft[1] << " " << runesLeft[2] << " " << runesLeft[3];
+            //BotWhisper(str.str().c_str());
+
+            me->ModifyPower(POWER_RUNIC_POWER, int32(src->RunicPower * runicpowerIncomeMult));
+
+            //BladeBarrier
+            if (/*src->RuneCost[RUNE_BLOOD] > 0 && */GetCooledRunesCount(RUNE_BLOOD) > 1)
+                me->CastSpell(me, BLADE_BARRIER_BUFF, true);
+
+            //Item - Death Knight T10 Melee 4P Bonus
+            if (me->GetLevel() >= 80 && GetCooledRunesCount() == MAX_RUNES)
+                me->CastSpell(me, ITEM_DEATH_KNIGHT_T10_MELEE_4P_BUFF, true);
+        }
+
+        void getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            if (me->FindCurrentSpellBySpellId(RUNE_STRIKE_1))
+                runicpower = std::max<int32>(runicpower - 200, 0);
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        uint8 GetBotStance() const override { return _presence; }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20 || IsCasting() || Feasting())
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRunes(PATH_OF_FROST_1)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK)))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || Rand() > 35)
+                return;
+
+            Unit* target = nullptr;
+
+            if (master->GetVictim() && master->IsInCombat() && IsMeleeClass(master->GetClass()) &&
+                GetHealthPCT(master) > 60 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true) &&
+                !master->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                target = master;
+
+            if (IAmFree())
+                return;
+
+            if (!target)
+            {
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* player = itr->GetSource();
+                        if (!player || player == master || player->IsBeingTeleported() ||
+                            me->GetMap() != player->FindMap())
+                            continue;
+
+                        if (IsMeleeClass(player->GetClass()) && player->GetVictim() && GetHealthPCT(player) > 60 &&
+                            me->GetDistance(player) < 30 && player->getAttackers().empty() && !CCed(player, true) &&
+                            !player->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                        {
+                            target = player;
+                            break;
+                        }
+
+                        if (!player->HaveBot())
+                            continue;
+
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (IsMeleeClass(bot->GetBotClass()) && bot->GetVictim() &&
+                                bot->GetBotAI()->HasRole(BOT_ROLE_DPS) && !bot->GetBotAI()->HasRole(BOT_ROLE_RANGED) &&
+                                GetHealthPCT(bot) > 60 && me->GetDistance(bot) < 30 && !CCed(bot, true) &&
+                                !bot->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                            {
+                                target = bot;
+                                break;
+                            }
+                        }
+
+                        if (target)
+                            break;
+                    }
+                }
+            }
+
+            if (!target && me->GetVictim() && HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED) &&
+                GetHealthPCT(me) > 60 && me->getAttackers().empty() && !CCed(me, true) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                target = me;
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Hysteria on You!", target->ToPlayer());
+                //if (target != master)
+                //{
+                //    std::string hystmsg = "Hysteria on " + (target == me ? "myself" : target->GetName()) + "!";
+                //    BotWhisper(hystmsg.c_str());
+                //}
+
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 1000); //fail
+        }
+
+        void CheckAntiMagic(uint32 diff)
+        {
+            if (!me->GetVictim() || !me->GetVictim()->HasUnitState(UNIT_STATE_CASTING) || Rand() > 40)
+                return;
+
+            Spell const* spell = me->GetVictim()->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (!spell || spell->GetTimer() >= 1000 || !spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                return;
+
+            Unit const* u = spell->m_targets.GetUnitTarget();
+            if (!u || (IAmFree() ? (u != me) : !(master->GetGroup() && master->GetGroup()->IsMember(spell->m_targets.GetObjectTargetGUID()))))
+                return;
+
+            if (u == me && IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) && runicpower >= rcost(ANTI_MAGIC_SHELL_1))
+            {
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                {
+                    getpower();
+                    return;
+                }
+            }
+
+            if (Rand() > 20)
+                return;
+
+            u = ObjectAccessor::GetUnit(*me, spell->m_targets.GetObjectTargetGUID());
+            if (u && !u->isMoving() && me->GetDistance(u) < 4 && IsSpellReady(ANTI_MAGIC_ZONE_1, diff, false) &&
+                HaveRunes(ANTI_MAGIC_ZONE_1) &&
+                !u->GetAuraEffect(SPELL_AURA_SCHOOL_ABSORB, SPELLFAMILY_DEATHKNIGHT, 0x20000, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(ANTI_MAGIC_ZONE_1)))
+                    return;
+            }
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30)
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (_presence == newpresence)
+            {
+                presencetimer = 5000;
+                return;
+            }
+
+            if (newpresence == DEATH_KNIGHT_FROST_PRESENCE && HaveRunes(FROST_PRESENCE_1))
+            {
+                if (doCast(me, FROST_PRESENCE_1))
+                    return;
+            }
+            else if (newpresence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRunes(BLOOD_PRESENCE_1))
+            {
+                if (doCast(me, BLOOD_PRESENCE_1))
+                    return;
+            }
+
+            presencetimer = 1000; //fail
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) && Rand() < 45 &&
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                    return;
+            }
+
+            bot_ai::BreakCC(diff);
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (Rand() > 35)
+                return;
+
+            if (IsSpellReady(STRANGULATE_1, diff) && me->IsInCombat() && HaveRunes(STRANGULATE_1))
+            {
+                Unit* u = FindCastingTarget(CalcSpellMaxRange(STRANGULATE_1), 0, STRANGULATE_1);
+                if (u && doCast(u, GetSpell(STRANGULATE_1)))
+                    return;
+            }
+
+            Unit* target = me->GetVictim();
+            if (IsSpellReady(MIND_FREEZE_1, diff, false) && target && me->GetDistance(target) < 5 &&
+                runicpower >= rcost(MIND_FREEZE_1) && target->IsNonMeleeSpellCast(false,false,true))
+            {
+                if (doCast(me->GetVictim(), GetSpell(MIND_FREEZE_1)))
+                    getpower();
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (me->IsAlive())
+            {
+                if (runicpowertimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (me->GetPower(POWER_RUNIC_POWER) > uint32(30.f * runicpowerLossMult))
+                            me->SetPower(POWER_RUNIC_POWER, me->GetPower(POWER_RUNIC_POWER) - uint32(30.f * runicpowerLossMult)); //-3 runic power every 2 sec
+                        else if (me->GetPower(POWER_RUNIC_POWER) > 0)
+                            me->SetPower(POWER_RUNIC_POWER, 0);
+                    }
+                    runicpowertimer = 2000;
+                }
+                if (runicpowertimer2 <= diff)
+                {
+                    if (me->IsInCombat())
+                    {
+                        if (me->GetPower(POWER_RUNIC_POWER) < me->GetMaxPower(POWER_RUNIC_POWER))
+                            me->SetPower(POWER_RUNIC_POWER, me->GetPower(POWER_RUNIC_POWER) + int32(20.f * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                        else if (me->GetPower(POWER_RUNIC_POWER) < me->GetMaxPower(POWER_RUNIC_POWER))
+                            me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                    }
+                    runicpowertimer2 = 5000;
+                }
+                getpower();
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            //pet is killed or unreachable
+            if (GC_Timer <= diff && petSummonTimer <= diff && !me->IsInCombat() && !me->IsMounted() && !me->GetVictim() && !IsCasting() && Rand() < 25 &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+                SummonBotPet();
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 40)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+            CheckPresence(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            Counter(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff) && Rand() < 25 &&
+                ((me->IsInCombat() && runicpower <= 900) ||
+                !me->GetAuraEffect(SPELL_AURA_MOD_STAT, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x40000000, 0x0)))
+            {
+                if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                    return;
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRunes(BONE_SHIELD_1) && Rand() < 25 + 65 * IsTank())
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || bone->GetDuration() < 10000)
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                        return;
+                }
+            }
+
+            CheckHysteria(diff);
+            CheckAntiMagic(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            //BLOOD TAP
+            if (IsSpellReady(BLOOD_TAP_1, diff, false) && Rand() < 65)
+            {
+                if (doCast(me, GetSpell(BLOOD_TAP_1)))
+                    getpower();
+            }
+
+            //ICEBOUND FORTITUDE
+            if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && Rand() < 50 && runicpower >= rcost(ICEBOUND_FORTITUDE_1) &&
+                GetHealthPCT(me) < std::min<uint32>(60, 35 + uint8(me->getAttackers().size()) * 5) + 20 * IsTank())
+            {
+                if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                {
+                    BotWhisper("Icebound Fortitude used!");
+                    getpower();
+                }
+            }
+
+            //SELFHEAL
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 50 && (IsTank() || Rand() < 75))
+            {
+                if (HaveRunes(VAMPIRIC_BLOOD_1) || (IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false) && doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1))))
+                {
+                    if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                    {
+                        BotWhisper("Vampiric Blood used!");
+                        return;
+                    }
+                }
+            }
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff, false) && GetHealthPCT(me) < 65 && Rand() < 50 && HaveRunes(RUNE_TAP_1))
+            {
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                    return;
+            }
+            //LICHBORNE + DEATH COIL
+            if ((me->GetCreatureType() == CREATURE_TYPE_UNDEAD || IsSpellReady(LICHBORNE_1, diff, false)) &&
+                IsSpellReady(DEATH_COIL_1, diff) && Rand() < 45 && GetHealthPCT(me) < 80 && runicpower >= rcost(DEATH_COIL_1))
+            {
+                if (me->GetCreatureType() == CREATURE_TYPE_UNDEAD || doCast(me, GetSpell(LICHBORNE_1)))
+                {
+                    if (doCast(me, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+            //END SELFHEAL
+
+            //EMPOWER RUNE WEAPON
+            if (IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false) && Rand() < 50 &&
+                GetCooledRunesCount() >= 5 && GetTotalRunesCooldown() >= (RUNE_BASE_COOLDOWN * 5) / 2)
+            {
+                if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                {
+                    //BotWhisper("ERW used!");
+                }
+            }
+
+            float dist = me->GetDistance(opponent);
+            Unit const* u = opponent->GetVictim();
+
+            //MARK OF BLOOD
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && u && Rand() < 55 && dist < 30 && HaveRunes(MARK_OF_BLOOD_1) &&
+                IsInBotParty(u) && GetHealthPCT(u) < 75 && u->GetDistance(opponent) < 10 &&
+                opponent->GetHealth() > me->GetMaxHealth() / 4 * (1 + opponent->getAttackers().size()) &&
+                (u == me || IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                !opponent->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2285, 0))
+            {
+                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
+                    return;
+            }
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && u && u != me && dist < 30 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() && Rand() < 50 &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                (IsTank() || (!IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80)) &&
+                IsInBotParty(u))
+            {
+                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
+                    return;
+            }
+            //DARK COMMAND 2 (distant)
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && u == me && IsTank() && Rand() < 30 &&
+                !(me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())))
+            {
+                if (Unit* tUnit = FindDistantTauntTarget())
+                {
+                    if (doCast(tUnit, GetSpell(DARK_COMMAND_1)))
+                    {}
+                }
+            }
+
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && opponent->GetVictim() != me) ||
+            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCast(false)) &&
+            //    Rand() < 75)
+            //{
+            //    if (doCast(opponent, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+
+            //UNBREAKABLE ARMOR
+            if (IsSpellReady(UNBREAKABLE_ARMOR_1, diff, false) && dist < 10 && HaveRunes(UNBREAKABLE_ARMOR_1) &&
+                (IsTank() || !me->getAttackers().empty() || opponent->GetMaxHealth() > me->GetMaxHealth() || Rand() < 35))
+            {
+                if (doCast(me, GetSpell(UNBREAKABLE_ARMOR_1)))
+                {}
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //CHAINS OF ICE
+            if (IsSpellReady(CHAINS_OF_ICE_1, diff) && Rand() < 65 && dist < CalcSpellMaxRange(CHAINS_OF_ICE_1) && opponent->isMoving() &&
+                !(opponent->GetTypeId() == TYPEID_UNIT && (opponent->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_SNARE-1)))) &&
+                HaveRunes(CHAINS_OF_ICE_1) && !CCed(opponent, true) && (!u || (!IsTank(u) && IsInBotParty(u))) &&
+                !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(opponent, GetSpell(CHAINS_OF_ICE_1)))
+                    return;
+            }
+
+            //HUNGERING COLD
+            if (IsSpellReady(HUNGERING_COLD_1, diff) && Rand() < 30 && runicpower >= rcost(HUNGERING_COLD_1))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 0);
+                if (targets.size() >= 3)
+                {
+                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                        return;
+                }
+            }
+
+            //Diseases in general
+            bool noDiseases = (opponent->GetTypeId() == TYPEID_UNIT && (opponent->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_INFECTED-1))));
+            AuraEffect const* blop = noDiseases ? nullptr : opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0, me->GetGUID());
+            AuraEffect const* frof = noDiseases ? nullptr : opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x4000000, 0x0, me->GetGUID());
+
+            if (CanAffectVictim(SPELL_SCHOOL_MASK_FROST|SPELL_SCHOOL_MASK_SHADOW))
+            {
+                //DISEASE SECTION
+
+                //PESTILENCE
+                if (IsSpellReady(PESTILENCE_1, diff) && blop && frof && dist < 5 && HaveRunes(PESTILENCE_1))
+                {
+                    if (blop->GetBase()->GetDuration() < 5000 || frof->GetBase()->GetDuration() < 5000)
+                    {
+                        if (doCast(opponent, GetSpell(PESTILENCE_1)))
+                            return;
+                    }
+
+                    if (Rand() < 35 + 65 * me->GetMap()->IsDungeon())
+                    {
+                        std::list<Unit*> targets;
+                        GetNearbyTargetsList(targets, 13.f, 0, opponent);
+                        uint8 count = 0;
+                        for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                        {
+                            //check existing blop and frof
+                            if (!(*itr)->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0, me->GetGUID()) ||
+                                !(*itr)->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x4000000, 0x0, me->GetGUID()))
+                                if (++count > 1)
+                                    break;
+                        }
+                        if (count > 1 && doCast(opponent, GetSpell(PESTILENCE_1)))
+                            return;
+                    }
+                }
+                //ICY TOUCH
+                if (IsSpellReady(ICY_TOUCH_1, diff) && !noDiseases && (!frof || frof->GetBase()->GetMaxDuration() < 3000) &&
+                    dist < CalcSpellMaxRange(ICY_TOUCH_1) && HaveRunes(ICY_TOUCH_1))
+                {
+                    if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
+                        return;
+                }
+                //HOWLING BLAST
+                if (IsSpellReady(HOWLING_BLAST_1, diff) && (rimeProcTimer > diff || Rand() < 70) &&
+                    (!u || opponent->IsControlledByPlayer() || rimeProcTimer > diff ||
+                    (u && u != me && IsTank(u) && u->getAttackers().size() > 2)) &&
+                    dist < CalcSpellMaxRange(HOWLING_BLAST_1) && HaveRunes(HOWLING_BLAST_1))
+                {
+                    if (u && u->getAttackers().size() > 4 &&
+                        IsSpellReady(DEATHCHILL_1, diff, false) && doCast(me, GetSpell(DEATHCHILL_1)))
+                    {/* BotWhisper("Deathchill used!"); */}
+                    if (doCast(opponent, GetSpell(HOWLING_BLAST_1)))
+                        return;
+                }
+
+                //END DISEASE SECTION
+
+                //MELEE SECTION
+
+                //FROST STRIKE
+                if (IsSpellReady(FROST_STRIKE_1, diff) && Rand() < 90 && dist < 5 &&
+                    runicpower >= rcost(FROST_STRIKE_1) &&
+                    (runicpower >= 1000 || !GetSpell(OBLITERATE_1) || !HaveRunes(OBLITERATE_1)))
+                {
+                    if (doCast(opponent, GetSpell(FROST_STRIKE_1)))
+                        return;
+                }
+                //BLOOD BOIL
+                if (IsSpellReady(BLOOD_BOIL_1, diff) && IsTank() && Rand() < 25 && HaveRunes(BLOOD_BOIL_1))
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f, 1);
+                    if (targets.size() >= 4)
+                        if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                            return;
+                }
+                //DEATH AND DECAY
+                if (IsSpellReady(DEATH_AND_DECAY_1, diff) && Rand() < (10 + 30 * IsTank()) && dist < 8 &&
+                    HaveRunes(DEATH_AND_DECAY_1))
+                {
+                    if (Unit* target = FindAOETarget(10))
+                    {
+                        if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                            return;
+                    }
+                }
+                //DEATH COIL
+                if (IsSpellReady(DEATH_COIL_1, diff) && Rand() < 50 && (dist > 6 || !GetSpell(FROST_STRIKE_1)) &&
+                    (dist < (IAmFree() ? 30 : 15)) && runicpower > 2 * rcost(DEATH_COIL_1))
+                {
+                    if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+
+            MoveBehind(opponent);
+
+            if (dist > 5)
+                return;
+
+            if (CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //PLAGUE STRIKE
+                if (IsSpellReady(PLAGUE_STRIKE_1, diff) && !noDiseases && (!blop || blop->GetBase()->GetDuration() < 3000) &&
+                    HaveRunes(PLAGUE_STRIKE_1))
+                {
+                    if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
+                        return;
+                }
+
+                //DISEASE SECTION
+
+                //DEATH STRIKE
+                if (IsSpellReady(DEATH_STRIKE_1, diff) && blop && frof && Rand() < 60 &&
+                    GetHealthPCT(me) < (80 - (10*(blop != nullptr) + 10*(frof != nullptr))) &&
+                    (!me->GetMap()->IsDungeon() || opponent->IsControlledByPlayer()) && HaveRunes(DEATH_STRIKE_1))
+                {
+                    if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
+                        return;
+                }
+                //OBLITERATE
+                if (IsSpellReady(OBLITERATE_1, diff) && (noDiseases || (blop && frof)) && HaveRunes(OBLITERATE_1))
+                {
+                    //DEATHCHILL
+                    if (IsSpellReady(DEATHCHILL_1, diff, false) && doCast(me, GetSpell(DEATHCHILL_1)))
+                    {/* BotWhisper("Deathchill used!"); */}
+                    if (doCast(opponent, GetSpell(OBLITERATE_1)))
+                        return;
+                }
+                //HEART STRIKE - splash
+                if (IsSpellReady(HEART_STRIKE_1, diff) && (noDiseases || (blop && frof)) && (IsTank() || Rand() < 40) &&
+                    HaveRunes(HEART_STRIKE_1) && FindSplashTarget())
+                {
+                    if (doCast(opponent, GetSpell(HEART_STRIKE_1)))
+                        return;
+                }
+                //BLOOD STRIKE
+                if (IsSpellReady(BLOOD_STRIKE_1, diff) && (noDiseases || (blop && frof)) && HaveRunes(BLOOD_STRIKE_1))
+                {
+                    if (doCast(opponent, GetSpell(BLOOD_STRIKE_1)))
+                        return;
+                }
+                //SCOURGE STRIKE unused
+                //if (IsSpellReady(SCOURGE_STRIKE_1, diff) && (noDiseases || (blop && frof)) && HaveRunes(SCOURGE_STRIKE_1))
+                //{
+                //    if (doCast(opponent, GetSpell(SCOURGE_STRIKE_1)))
+                //        return;
+                //}
+
+                //END DISEASE SECTION
+
+                //RUNE STRIKE tank
+                if (IsSpellReady(RUNE_STRIKE_1, diff, false) && (IsTank() || runicpower >= 800) &&
+                    me->HasAuraState(AURA_STATE_DEFENSE) && !me->GetCurrentSpell(CURRENT_MELEE_SPELL) &&
+                    runicpower >= rcost(RUNE_STRIKE_1))
+                {
+                    if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
+                        return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damageinfo.Damages[0].Damage);
+            float pctbonus = 0.0f;
+
+            //Blood Gorged part 1 (white attacks): 10% bonus damage for all attacks
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 64 && me->HasAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT))
+                pctbonus += 0.1f;
+
+            damageinfo.Damages[0].Damage = uint32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+            if (baseId == PLAGUE_STRIKE_1)
+                crit_chance += 10.f;
+            //Scourge / Oblit Crit Up (60134): 5% additional critical chance for Scourge Strike and Obliterate
+            if (lvl >= 80 && (baseId == SCOURGE_STRIKE_1 || baseId == OBLITERATE_1))
+                crit_chance += 5.f;
+
+            //Killing Machine
+            if (AuraEffect const* mach = me->GetAuraEffect(KILLING_MACHINE_BUFF, 0))
+                if (mach->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+            //Deathchill
+            if (AuraEffect const* chil = me->GetAuraEffect(DEATHCHILL_1, 0))
+                if (chil->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+
+
+            //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+            if (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1 || baseId == SCOURGE_STRIKE_1 || baseId == OBLITERATE_1)
+                crit_chance += 9.f;
+            //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+            if (baseId == PLAGUE_STRIKE_1 || baseId == SCOURGE_STRIKE_1)
+                crit_chance += 6.f;
+            //Rime (part 1): 15% additional critical chance for Icy Touch and Obliterate
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 60 && (baseId == ICY_TOUCH_1 || baseId == OBLITERATE_1))
+                crit_chance += 15.f;
+            //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 62 && baseId == DEATH_STRIKE_1)
+                crit_chance += 6.f;
+
+            //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+            if (baseId == RUNE_STRIKE_1)
+                crit_chance += 10.f;
+
+            //Item - Death Knight T8 Melee 2P Bonus: 8% additional critical chance for Death Coil and Frost Strike
+            if (lvl >= 80 &&
+                (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE ||
+                baseId == DEATH_COIL_HEAL || baseId == FROST_STRIKE_1))
+                crit_chance += 8.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 63 &&
+                    (baseId == BLOOD_BOIL_1 || baseId == BLOOD_STRIKE_1 || baseId == DEATH_STRIKE_1 || baseId == HEART_STRIKE_1))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike, Howling Blast and Obliterate
+                if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 63 &&
+                    (baseId == BLOOD_STRIKE_1 || baseId == FROST_STRIKE_1 ||
+                    baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (baseId == PLAGUE_STRIKE_1 || baseId == SCOURGE_STRIKE_1)
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Increased Blood Strike Damage (52394): 90 bonus damage for Blood Strike and Heart Strike
+            if (lvl >= 70 && (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Copy of Increased Blood Strike Damage (60825): 90 bonus damage for Blood Strike and Heart Strike
+            if (lvl >= 80 && (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Increased Scourge Strike Damage (54809): 91 bonus damage for Scourge Strike
+            if (lvl >= 80 && baseId == SCOURGE_STRIKE_1)
+                fdamage += 91.f;
+
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 57)
+            {
+                if (baseId == PLAGUE_STRIKE_1)
+                    pctbonus += 0.3f;
+                else if (baseId == SCOURGE_STRIKE_1)
+                    pctbonus += 0.2f;
+            }
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 59)
+            {
+                if (baseId == BLOOD_STRIKE_1)
+                    pctbonus += 0.15f;
+                else if (baseId == HEART_STRIKE_1)
+                    pctbonus += 0.45f;
+                else if (baseId == BLOOD_BOIL_1)
+                    pctbonus += 0.3f;
+            }
+            //Merciless Combat (melee): 12% bonus damage for Icy Touch, Howling Blast, Obliterate and Frost Strike on targets with less than 35% hp
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 60 &&
+                (baseId == ICY_TOUCH_1 || baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1 || baseId == FROST_STRIKE_1) &&
+                damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.12f;
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 62 && baseId == DEATH_STRIKE_1)
+                pctbonus += 0.3f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 62 && (baseId == BLOOD_STRIKE_1 || baseId == FROST_STRIKE_1))
+                pctbonus += 0.1f;
+            //Blood Gorged part 1 (melee): 10% bonus damage for all spells
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 64 && me->HasAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 15% damage bonus on targets affected with Frost Fever
+            if ((_spec == BOT_SPEC_DK_FROST) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_RANGED_HASTE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x0, 0x2))
+                pctbonus += 0.15f;
+            //Rage of Rivendare (melee): 10% damage bonus on targets affected with Blood Plague
+            if ((_spec == BOT_SPEC_DK_UNHOLY) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.1f;
+
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets
+            if (baseId == BLOOD_STRIKE_1 && damageinfo.target->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                pctbonus += 0.2f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (baseId == DEATH_STRIKE_1 && runicpower >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<int32>(runicpower, 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (baseId == OBLITERATE_1)
+                pctbonus += 0.25f;
+            //Glyph of Plague Strike: 20% bonus damage for Plague Strike
+            if (baseId == PLAGUE_STRIKE_1)
+                pctbonus += 0.2f;
+
+            //Item - Death Knight T8 Tank 2P Bonus
+            if (lvl >= 80 && baseId == RUNE_STRIKE_1)
+                pctbonus += 0.1f;
+            //Item - Death Knight T8 DPS Relic
+            if (lvl >= 80 && baseId == FROST_STRIKE_1)
+                fdamage += 380.f;
+            //Item - Death Knight T9 Tank 2P Bonus
+            if (lvl >= 80 && (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1))
+                pctbonus += 0.05f;
+            //Item - Death Knight T10 Melee 2P Bonus part 1
+            if (lvl >= 80 && baseId == OBLITERATE_1)
+                pctbonus += 0.1f;
+            //Item - Death Knight T10 Melee 2P Bonus part 2
+            if (lvl >= 80 && baseId == HEART_STRIKE_1)
+                pctbonus += 0.07f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Runic Focus (class passive): 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Blood Strike, Frost Strike, Howling Blast and Obliterate
+                if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 63 &&
+                    (baseId == BLOOD_STRIKE_1 || baseId == FROST_STRIKE_1 ||
+                    baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1))
+                    pctbonus += 0.45f / 1.5f;
+            }
+
+            //Improved Icy Touch part 1: 15% bonus damage for Icy Touch
+            if (baseId == ICY_TOUCH_1)
+                pctbonus += 0.15f;
+            //Black Ice: 10% bonus damage for Shadow and Frost spells
+            if (spellInfo->GetSchoolMask() & (SPELL_SCHOOL_MASK_FROST|SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Morbidity part 1: 15% damage bonus for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE)
+                pctbonus += 0.15f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike on diseased targets
+            if ((_spec == BOT_SPEC_DK_FROST) &&
+                lvl >= 59 && (baseId == ICY_TOUCH_1 || baseId == HOWLING_BLAST_1 || baseId == FROST_STRIKE_1) &&
+                IsDiseased(damageinfo.target))
+                pctbonus += 0.2f;
+            //Impurity: 20% bonus (from attack power) damage for all spells
+            if ((_spec == BOT_SPEC_DK_UNHOLY) && lvl >= 59)
+                if (SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellInfo->Id))
+                    fdamage += bonus->ap_bonus * 0.2f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast, Obliterate and Frost Strike on targets with less than 35% hp
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 60 &&
+                (baseId == ICY_TOUCH_1 || baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1 || baseId == FROST_STRIKE_1) &&
+                damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.12f;
+            //Blood Gorged part 1 (spell): 10% bonus damage for all spells
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 64 && me->HasAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT))
+                pctbonus += 0.1f;
+            //Tundra Stalker (spell): 15% damage bonus on targets affected with Frost Fever
+            if ((_spec == BOT_SPEC_DK_FROST) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_RANGED_HASTE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x0, 0x2))
+                pctbonus += 0.15f;
+            //Rage of Rivendare (spell): 10% damage bonus on targets affected with Blood Plague
+            if ((_spec == BOT_SPEC_DK_UNHOLY) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.1f;
+
+            //Glyph of Dark Death part 1: 15% damage bonus for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE)
+                pctbonus += 0.15f;
+            //Glyph of Icy Touch: 20% damage bonus for Frost Fever
+            if (baseId == FROST_FEVER || baseId == FROST_FEVER_AURA)
+                pctbonus += 0.2f;
+
+            //Item - Death Knight T8 DPS Relic
+            if (lvl >= 80 && baseId == DEATH_COIL_DAMAGE)
+                fdamage += 113.f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (baseId == ICY_TOUCH_1)
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE)
+                fdamage += 80.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //pct mods
+            //Morbidity part 2: 15% bonus healing for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_HEAL)
+                pctbonus += 0.15f;
+            //Improved Rune Tap part 1: 100% bonus healing for Rune Tap
+            if (lvl >= 58 && baseId == RUNE_TAP_1)
+                pctbonus += 1.f;
+            //Improved Death Strike (part 3): 50% bonus healing for Death Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 62 && baseId == DEATH_STRIKE_HEAL)
+                pctbonus += 0.5f;
+
+            //Glyph of Dark Death part 2: 15% bonus healing for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_HEAL)
+                pctbonus += 0.15f;
+            //Glyph of Rune Tap part 1: 10% bonus healing for Rune Tap
+            if (baseId == RUNE_TAP_1)
+                pctbonus += 0.1f;
+
+            //flat mods
+            //Improved Prayer of Mending: 100 additional heal for Prayer of Mending
+            //if (baseId == PRAYER_OF_MENDING_HEAL)
+            //    flat_mod += 100;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Endless Winter part 2 -100% Runic Power cost for Mind Freeze
+            if (lvl >= 58 && baseId == MIND_FREEZE_1)
+                pctbonus += 1.f;
+
+            //Glyph of Blood Tap: -100% Health cost for Blood Tap
+            if (baseId == BLOOD_TAP_1)
+                pctbonus += 1.f;
+
+            //flat mods
+            //Glyph of Frost Strike: -8 Runic Power cost for Frost Strike
+            if (baseId == FROST_STRIKE_1)
+                flatbonus += 80;
+            //Glyph of Hungering Cold: -40 Runic Power cost for Hungering Cold
+            if (lvl >= 60 && baseId == HUNGERING_COLD_1)
+                flatbonus += 400;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            //if (lvl >= 45 && (baseId == INNER_FOCUS_1 || baseId == POWER_INFUSION_1 || baseId == PAIN_SUPPRESSION_1))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Unholy Command: -10 sec cooldown for Dark Command
+            if (lvl >= 56 && baseId == DARK_COMMAND_1)
+                timebonus += 10000;
+            //Improved Rune Tap part 2: -30 sec cooldown for Rune Tap
+            if (lvl >= 57 && baseId == RUNE_TAP_1)
+                timebonus += 30000;
+
+            //Glyph of Strangulate: -20 sec cooldown for Strangulate
+            if (baseId == STRANGULATE_1)
+                timebonus += 20000;
+
+            //Item - Death Knight T9 Tank 2P Bonus
+            if (lvl >= 80 && (baseId == UNBREAKABLE_ARMOR_1 || baseId == VAMPIRIC_BLOOD_1 || baseId == BONE_SHIELD_1))
+                timebonus += 10000;
+            //Strangulate Cooldown Reduction: -5 sec cooldown for Strangulate
+            if (baseId == STRANGULATE_1)
+                timebonus += 5000;
+
+            //Empower Rune Weapon Cooldown Reduction For Bot: -3 min
+            if (baseId == EMPOWER_RUNE_WEAPON_1)
+                timebonus += 180000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            //if (lvl >= 45 && baseId == PENANCE_1)
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Morbidity part 2
+            if (baseId == DEATH_AND_DECAY_1)
+                timebonus += 15000;
+
+            //Item - Death Knight T9 Tank 2P Bonus
+            if (lvl >= 80 && baseId == DARK_COMMAND_1)
+                timebonus += 2000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unholy Presence
+            if (_presence == DEATH_KNIGHT_UNHOLY_PRESENCE &&
+                ((spellInfo->SpellFamilyFlags[0] & 0xFFDFFE7F) ||
+                (spellInfo->SpellFamilyFlags[0] & 0x480B11F7) ||
+                (spellInfo->SpellFamilyFlags[0] & 0x20)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Corpse Explosion
+            if (spellInfo->SpellFamilyFlags[1] & 0x20)
+                flatbonus += 5.f;
+            //Glyph of Pestilence
+            if (baseId == PESTILENCE_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Holy Reach: +20% range for Holy Spells
+            //if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x100080))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Icy Reach: +10 yd range for Icy Touch, Chains of Ice and Howling Blast
+            if (baseId == ICY_TOUCH_1 || baseId == CHAINS_OF_ICE_1 || baseId == HOWLING_BLAST_1)
+                flatbonus += 10.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Rune Tap part 2
+            if (baseId == RUNE_TAP_1)
+                me->CastSpell(me, GLYPH_RUNE_TAP_HEAL, true);
+
+            //Empower Rune Weapon: rune activation helper
+            if (baseId == EMPOWER_RUNE_WEAPON_1)
+                ActivateAllRunes();
+
+            //Improved Chains of Ice (62142): convert frost rune into death rune
+            if (lvl >= 80 && baseId == CHAINS_OF_ICE_1)
+            {
+                ConvertRune(RUNE_FROST);
+            }
+            //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+            if (lvl >= 57 && (baseId == DEATH_STRIKE_1 || baseId == OBLITERATE_1))
+            {
+                ConvertRune(RUNE_UNHOLY);
+                ConvertRune(RUNE_FROST);
+            }
+            //Reaping: Blood Strike and Pestilence convert Blood Rune to Death Rune
+            if ((_spec == BOT_SPEC_DK_UNHOLY) && lvl >= 60 && (baseId == BLOOD_STRIKE_1 || baseId == PESTILENCE_1))
+            {
+                ConvertRune(RUNE_BLOOD);
+                //Blood of the North (part 2): same effect
+                if (lvl >= 62)
+                    ConvertRune(RUNE_BLOOD);
+            }
+            //Rime: consume buff
+            if (baseId == HOWLING_BLAST_1 && rimeProcTimer > GetLastDiff() && me->HasAura(RIME_BUFF))
+                me->RemoveAurasDueToSpell(RIME_BUFF);
+            //Blood Tap
+            if (baseId == BLOOD_TAP_1)
+            {
+                ConvertRune(RUNE_BLOOD);
+
+                //Item - Death Knight T10 Tank 4P Bonus: Blood Armor (12% damage reduce)
+                if (lvl >= 80)
+                    me->CastSpell(me, ITEM_DEATH_KNIGHT_T10_TANK_4P_BUFF, true);
+            }
+
+            //stances
+            if (spellInfo->GetCategory() == 47)
+            {
+                presencetimer = 1000;
+
+                if (baseId == BLOOD_PRESENCE_1)
+                    _presence = DEATH_KNIGHT_BLOOD_PRESENCE;
+                else if (baseId == FROST_PRESENCE_1)
+                    _presence = DEATH_KNIGHT_FROST_PRESENCE;
+                else if (baseId == UNHOLY_PRESENCE_1)
+                    _presence = DEATH_KNIGHT_UNHOLY_PRESENCE;
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //consume buffs (not on spell go)
+            //Killing Machine
+            //Deathchill
+            AuraEffect const* mach = me->GetAuraEffect(KILLING_MACHINE_BUFF, 0);
+            AuraEffect const* chil = me->GetAuraEffect(DEATHCHILL_1, 0);
+            if (mach && mach->IsAffectedOnSpell(spell))
+                me->RemoveAurasDueToSpell(KILLING_MACHINE_BUFF);
+            else if (chil && chil->IsAffectedOnSpell(spell))
+                me->RemoveAurasDueToSpell(DEATHCHILL_1);
+
+            //Icy Touch tanking helper (TODO: remove this hack after threat mods implementation)
+            //emulating passive mod +600% threat generated by Icy Touch while in Frost Presence
+            if (baseId == ICY_TOUCH_1 && _presence == DEATH_KNIGHT_FROST_PRESENCE && target->CanHaveThreatList())
+            {
+                if (SpellThreatEntry const* threatEntry = sSpellMgr->GetSpellThreatEntry(spellId))
+                {
+                    int32 baseThreat = 0;
+                    if (threatEntry->apPctMod != 0x0)
+                        baseThreat += int32(threatEntry->apPctMod * me->GetTotalAttackPowerValue(BASE_ATTACK));
+                    baseThreat += threatEntry->flatMod;
+
+                    if (baseThreat)
+                        target->GetThreatManager().AddThreat(me, baseThreat * 6, spell);
+                }
+            }
+
+            //Improved Icy Touch part 2: 6% increased effect (flat)
+            if (baseId == FROST_FEVER_AURA)
+            {
+                if (Aura const* feve = target->GetAura(spellId, me->GetGUID()))
+                {
+                    if (AuraEffect* fev1 = feve->GetEffect(1))
+                        fev1->ChangeAmount(fev1->GetAmount() - 6);
+                    if (AuraEffect* fev2 = feve->GetEffect(2))
+                        fev2->ChangeAmount(fev2->GetAmount() - 6);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown
+            if ((_spec == BOT_SPEC_DK_FROST) && baseId == OBLITERATE_1 && urand(1,100) <= 15)
+            {
+                ResetSpellCooldown(HOWLING_BLAST_1);
+                me->CastSpell(me, RIME_BUFF, true);
+            }
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (8 for bot)
+            if (baseId == HORN_OF_WINTER_1)
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 480000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    target->AddAura(44755, target); //snowflakes
+            }
+            //Epidemic: 6 sec bonus duration for DK Diseases
+            if (baseId == FROST_FEVER_AURA || baseId == BLOOD_PLAGUE_AURA ||
+                baseId == CRYPT_FEVER_AURA || baseId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 6000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Chilblains: proc Icy Clutch
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 61 && baseId == FROST_FEVER_AURA)
+                me->CastSpell(target, CHILBLAINS_DEBUFF, true);
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) &&
+                (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1) && GetSpell(DEATH_COIL_1) && urand(1,100) <= 15)
+                me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+            //Glyph of Heart Strike
+            if (baseId == HEART_STRIKE_1)
+                me->CastSpell(target, GLYPH_HEART_STRIKE_DEBUFF, true);
+            //Glyph of Howling Blast
+            if (lvl >= 60 && baseId == HOWLING_BLAST_1)
+                me->CastSpell(target, FROST_FEVER_AURA, true);
+            //Glyph of Scourge Strike
+            if (baseId == SCOURGE_STRIKE_1)
+                me->CastSpell(target, GLYPH_SCOURGE_STRIKE_EFFECT, true);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint32 spellId = spell->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Rime helper (Freezing Fog)
+            if (baseId == RIME_BUFF)
+            {
+                rimeProcTimer = 15000;
+            }
+
+            //Improved Blood Presence
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 61 && baseId == BLOOD_PRESENCE_1)
+            {
+                if (AuraEffect* pres = me->GetAuraEffect(spellId, 1))
+                    pres->ChangeAmount(pres->GetAmount() + 10);
+            }
+            if (baseId == ANTI_MAGIC_SHELL_1)
+            {
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    //Glyph of Anti-Magic Shell: 2 sec increased duration
+                    uint32 dur = shell->GetDuration() + 2000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                    //Magic Suppression part 2
+                    if (AuraEffect* shab = shell->GetEffect(0))
+                        shab->ChangeAmount(shab->GetAmount() * 1.25f);
+                }
+            }
+            if (baseId == VAMPIRIC_BLOOD_1)
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* bloo = me->GetAura(spellId))
+                {
+                    uint32 dur = bloo->GetDuration() + 5000;
+                    bloo->SetDuration(dur);
+                    bloo->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == BONE_SHIELD_1)
+            {
+                //Glyph of Bone Shield: 1 bonus charge (1 for bot, 3 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+            }
+            if (baseId == ICEBOUND_FORTITUDE_1)
+            {
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    //Icebound Duration Increase: + 3 sec duration
+                    uint32 dur = fort->GetDuration() + 3000;
+
+                    //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration
+                    if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 63)
+                        dur += 6000;
+
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+
+                    if (AuraEffect* eff2 = fort->GetEffect(EFFECT_2))
+                    {
+                        //calc correct amount
+                        int32 amount = eff2->GetAmount() - (0.15f * (std::max<float>(0, GetBotDefense() - lvl*5)));
+                        //Glyph of Icebound Fortitude
+                        amount = std::min<int32>(amount, -40);
+                        //Increased Icebound Fortitude Mitigation (54803)
+                        if (lvl >= 70)
+                            amount -= 2;
+                        eff2->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (baseId == UNBREAKABLE_ARMOR_1)
+            {
+                if (AuraEffect* armo = me->GetAuraEffect(spellId, 0))
+                    armo->ChangeAmount(armo->GetAmount() + 5); //25 +20% = 30
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (_presence == DEATH_KNIGHT_FROST_PRESENCE || _presence == DEATH_KNIGHT_UNHOLY_PRESENCE)
+                {
+                    if (int32 bp0 = int32(damage / 25)) //4%
+                    {
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(bp0);
+                        me->CastSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, args);
+                    }
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* /*summon*/) const override
+        {
+            //TODO: garg, aod, drw
+            return 0;
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_GHOUL;
+
+            Position pos;
+
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_CORPSE_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, me->GetOrientation() + M_PI / 2);
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all hunter bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+            {
+                petSummonTimer = 30000;
+                botPet = nullptr;
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_GHOUL;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            petSummonTimer = 5000;
+
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+
+            rimeProcTimer = 0;
+
+            _presence = BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+
+            DefaultInit();
+            InitRunes();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (rimeProcTimer > diff)               rimeProcTimer -= diff;
+
+            if (petSummonTimer > diff)              petSummonTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, 1300);
+            //RefreshAura(RUNIC_POWER_MASTERY);
+            //if (AuraEffect* mast = me->GetAuraEffect(RUNIC_POWER_MASTERY, 0))
+            //{
+            //    //Runic Power Mastery rank 2
+            //    mast->ChangeAmount(1300);
+            //}
+
+
+            if (botPet && botPet->GetPowerType() != POWER_ENERGY)
+                botPet->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_ENERGY);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isBloo = _spec == BOT_SPEC_DK_BLOOD;
+            bool isFros = _spec == BOT_SPEC_DK_FROST;
+            bool isUnho = _spec == BOT_SPEC_DK_UNHOLY;
+
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+            InitSpellMap(BLOOD_TAP_1);
+
+  /*Talent*/lvl >= 57 ? InitSpellMap(RUNE_TAP_1) : RemoveSpell(RUNE_TAP_1);
+  /*Talent*/lvl >= 59 && isBloo ? InitSpellMap(MARK_OF_BLOOD_1) : RemoveSpell(MARK_OF_BLOOD_1);
+  /*Talent*/lvl >= 61 && isBloo ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+  /*Talent*/lvl >= 62 && isBloo ? InitSpellMap(VAMPIRIC_BLOOD_1) : RemoveSpell(VAMPIRIC_BLOOD_1);
+  /*Talent*/lvl >= 63 && isBloo ? InitSpellMap(HEART_STRIKE_1) : RemoveSpell(HEART_STRIKE_1);
+
+  /*Talent*/lvl >= 57 ? InitSpellMap(LICHBORNE_1) : RemoveSpell(LICHBORNE_1);
+  /*Talent*/lvl >= 59 && isFros ? InitSpellMap(DEATHCHILL_1) : RemoveSpell(DEATHCHILL_1);
+  /*Talent*/lvl >= 61 && isFros ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+  /*Talent*/lvl >= 62 && isFros ? InitSpellMap(UNBREAKABLE_ARMOR_1) : RemoveSpell(UNBREAKABLE_ARMOR_1);
+  /*Talent*/lvl >= 63 && isFros ? InitSpellMap(FROST_STRIKE_1) : RemoveSpell(FROST_STRIKE_1);
+  /*Talent*/lvl >= 65 && isFros ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+
+  /*Talent*/lvl >= 61 && isUnho ? InitSpellMap(ANTI_MAGIC_ZONE_1) : RemoveSpell(ANTI_MAGIC_ZONE_1);
+  /*Talent*/lvl >= 62 && isUnho ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+  /*Talent*/lvl >= 63 && isUnho ? InitSpellMap(SCOURGE_STRIKE_1) : RemoveSpell(SCOURGE_STRIKE_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            InitSpellMap(UNHOLY_PRESENCE_1, true);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isBloo = _spec == BOT_SPEC_DK_BLOOD;
+            bool isFros = _spec == BOT_SPEC_DK_FROST;
+            bool isUnho = _spec == BOT_SPEC_DK_UNHOLY;
+
+            RefreshAura(BUTCHERY, level >= 55 ? 1 : 0);
+            RefreshAura(BLADED_ARMOR, level >= 56 ? 1 : 0);
+            RefreshAura(SCENT_OF_BLOOD, level >= 56 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, level >= 56 ? 1 : 0);
+            RefreshAura(SPELL_DEFLECTION, isBloo && level >= 58 ? 1 : 0);
+            RefreshAura(VENDETTA, isBloo && level >= 58 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE3, isBloo && level >= 62 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE2, isBloo && level >= 61 && level < 62 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE1, isBloo && level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(ABOMINATIONS_MIGHT, isBloo && level >= 60 ? 1 : 0);
+            //RefreshAura(BLOODWORMS, isBloo && level >= 61 ? 1 : 0);
+            RefreshAura(IMPROVED_BLOOD_PRESENCE, isBloo && level >= 61 ? 1 : 0);
+            RefreshAura(WILL_OF_THE_NECROPOLIS, isBloo && level >= 63 ? 1 : 0);
+
+            RefreshAura(TOUGHNESS, level >= 55 ? 1 : 0);
+            RefreshAura(ICY_TALONS, level >= 57 ? 1 : 0);
+            RefreshAura(ANNIHILATION, level >= 57 ? 1 : 0);
+            RefreshAura(KILLING_MACHINE, isFros && level >= 58 ? 1 : 0);
+            RefreshAura(CHILL_OF_THE_GRAVE, isFros && level >= 58 ? 1 : 0);
+            RefreshAura(FRIGID_DREADPLATE, isFros && level >= 59 ? 1 : 0);
+            RefreshAura(IMPROVED_ICY_TALONS, isFros && level >= 60 ? 1 : 0);
+            RefreshAura(THREAT_OF_THASSARIAN, isFros && level >= 62 ? 1 : 0);
+            RefreshAura(ACCLIMATION, isFros && level >= 63 ? 1 : 0);
+
+            RefreshAura(NECROSIS5, isUnho && level >= 62 ? 1 : 0);
+            RefreshAura(NECROSIS4, isUnho && level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(NECROSIS3, isUnho && level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(NECROSIS2, isUnho && level >= 58 && level < 59 ? 1 : 0);
+            RefreshAura(NECROSIS1, isUnho && level >= 57 && level < 58 ? 1 : 0);
+            RefreshAura(ON_A_PALE_HORSE_A, isUnho && level >= 58 ? 1 : 0);
+            RefreshAura(ON_A_PALE_HORSE_B, isUnho && level >= 58 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE3, isUnho && level >= 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE2, isUnho && level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE1, isUnho && level >= 58 && level < 59 ? 1 : 0);
+            RefreshAura(UNHOLY_BLIGHT, isUnho && level >= 59 ? 1 : 0);
+            RefreshAura(DIRGE, isUnho && level >= 59 ? 1 : 0);
+            RefreshAura(DESECRATION, isUnho && level >= 60 ? 1 : 0);
+            RefreshAura(DESOLATION, isUnho && level >= 61 ? 1 : 0);
+            RefreshAura(IMPROVED_UNHOLY_PRESENCE, isUnho && level >= 61 ? 1 : 0);
+            RefreshAura(CRYPT_FEVER, isUnho && level >= 62 ? 1 : 0);
+            RefreshAura(WANDERING_PLAGUE, isUnho && level >= 63 ? 1 : 0);
+            RefreshAura(EBON_PLAGUEBRINGER, isUnho && level >= 63 ? 1 : 0);
+
+            //RefreshAura(GLYPH_DANCING_RUNE_WEAPON, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_DISEASE);
+            RefreshAura(GLYPH_CHAINS_OF_ICE);
+            RefreshAura(GLYPH_UNHOLY_BLIGHT, level >= 60 ? 1 : 0);
+
+            RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH);
+            RefreshAura(ITEM_DEATH_KNIGHT_T8_MELEE_4P, level >= 80 ? 1 : 0);
+            RefreshAura(ITEM_DEATH_KNIGHT_T9_MELEE_4P, level >= 80 ? 1 : 0);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+            RefreshAura(RUNE_STRIKE_PASSIVE);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        BotRuneInfo _runes[MAX_RUNES];
+
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2;
+        uint32 rimeProcTimer;
+/*misc*/int32 runicpower;
+/*misc*/int32 runeCost[NUM_RUNE_TYPES];
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 _presence;
+        //Pet
+        uint32 petSummonTimer;
+
+        bool HaveRunes(uint32 spellId)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            return (spellInfo && HaveRunes(spellInfo));
+        }
+
+        bool HaveRunes(SpellInfo const* spellInfo)
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src || src->NoRuneCost())
+                return true;
+
+            //Freezing Fog
+            if (rimeProcTimer > GetLastDiff() && spellInfo->Id == HOWLING_BLAST_1)
+                return true;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runeCost[i] = src->RuneCost[i];
+
+            runeCost[RUNE_DEATH] = MAX_RUNES;
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes[i].CurrentRune;
+                if (runeCost[rune] > 0 && _runes[i].Cooldown <= 0)
+                    runeCost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runeCost[i] > 0)
+                    runeCost[RUNE_DEATH] += runeCost[i];
+
+            if (runeCost[RUNE_DEATH] > MAX_RUNES)
+                return false;
+
+            return true;
+        }
+
+        bool SpendRune(uint8 runetype, bool didHit)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes[i].CurrentRune == runetype && _runes[i].Cooldown <= 0)
+                {
+                    _runes[i].CurrentRune = _runes[i].BaseRune;
+                    uint32 cooldown = didHit ? RUNE_BASE_COOLDOWN : RUNE_MISS_COOLDOWN;
+
+                    //Improved Unholy Presence
+                    if (_presence == DEATH_KNIGHT_UNHOLY_PRESENCE)
+                        cooldown -= 1000;
+
+                    _runes[i].Cooldown += cooldown;
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes[i].BaseRune == runetype && _runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint8 GetCooledRunesCount() const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint32 GetTotalRunesCooldown() const
+        {
+            uint32 totalCd = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                totalCd += std::max<int32>(_runes[i].Cooldown, 0);
+
+            return totalCd;
+        }
+
+        void ConvertRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes[i].CurrentRune == runetype)
+                {
+                    _runes[i].CurrentRune = RUNE_DEATH;
+                    return;
+                }
+            }
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                _runes[i].Cooldown = std::min<int32>(_runes[i].Cooldown, me->IsInCombat() ? -1 : 0);
+        }
+
+        void InitRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes[i].BaseRune = runeSlotTypes[i];
+                _runes[i].CurrentRune = _runes[i].BaseRune;
+                _runes[i].Cooldown = 0;
+            }
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                int32 &cd = _runes[i].Cooldown;
+                if (me->IsInCombat())
+                {
+                    //RGP
+                    if (cd != 0)
+                    {
+                        if (cd >= int32(-2500 + diff))
+                            cd -= diff;
+                        else if (cd != -2500)
+                            cd = -2500;
+                        //ensurance
+                        if (!cd)
+                            --cd;
+                    }
+                }
+                else
+                {
+                    if (cd >= int32(diff))
+                        cd -= diff;
+                    else if (cd)
+                        cd = 0;
+                }
+            }
+        }
+
+        bool IsDiseased(Unit const* unit) const
+        {
+            static const AuraType botDiseaseAuraTypes[] =
+            {
+                SPELL_AURA_PERIODIC_DAMAGE, // Frost Fever and Blood Plague
+                SPELL_AURA_LINKED,          // Crypt Fever and Ebon Plague
+                SPELL_AURA_NONE
+            };
+
+            for (AuraType const* itr = botDiseaseAuraTypes; *itr != SPELL_AURA_NONE; ++itr)
+            {
+                Unit::AuraEffectList const& disAuras = unit->GetAuraEffectsByType(*itr);
+                for (Unit::AuraEffectList::const_iterator itr = disAuras.begin(); itr != disAuras.end(); ++itr)
+                {
+                    // Get auras with disease dispel type by caster
+                    if ((*itr)->GetSpellInfo()->Dispel == DISPEL_DISEASE)
+                        return true;
+                }
+            }
+
+            return false;
+        }
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp b/src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp
new file mode 100644
index 0000000..09de3e7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp
@@ -0,0 +1,494 @@
+#include "bot_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "TemporarySummon.h"
+/*
+Dreadlord NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Incredibly powerful demon who wields power of darkness and mental domination
+Specifics:
+High armor, high resistances, partially immune to control effects, damage taken speeds up spells recharge, plate armor,
+deals melee/spellshadow damage, bonus damage to CCed units, spell power bonus: 200% strength.
+Abilities:
+1) Carrion Swarm. Sends a horde of bats combined with chaotic magic to damage enemies in frontal cone, 10 seconds cooldown.
+2) Sleep. Puts the enemy target to sleep for 60 seconds (15 seconds on players) and allows next physical attack
+on that target to bypass armor, removed by direct damage, 6 seconds cooldown.
+3) Vampiric Aura. Increases physical critical damage by 5% and heals party and raid members within 40 yards for a
+percentage (100% for Dreadlord and 25% for everyone else) of damage done by physical attacks and Carrion Swarm, no threat.
+4) Summon Infernal Servant. Calls an infernal down from the sky dealing damage and stunning enemy units, lasts 180 seconds, 180 seconds cooldown.
+Complete - 100%
+TODO:
+*/
+
+enum DreadlordBaseSpells
+{
+    CARRION_SWARM_1         = SPELL_CARRION_SWARM,
+    SLEEP_1                 = SPELL_SLEEP,
+    INFERNO_1               = SPELL_INFERNO
+};
+enum DreadlordPassives
+{
+    VAMPIRIC_AURA           = SPELL_VAMPIRIC_AURA,
+};
+enum DreadlordSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+
+    CARRION_COST            = 110 * 5,
+    SLEEP_COST              = 50 * 5,
+    INFERNAL_COST           = 175 * 5,
+
+    DAMAGE_CD_REDUCTION     = 250,//ms
+    INFERNO_SPAWN_DELAY     = 650,//ms
+
+    IMMOLATION              = 39007
+};
+
+class dreadlord_bot : public CreatureScript
+{
+public:
+    dreadlord_bot() : CreatureScript("dreadlord_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new dreadlord_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct dreadlord_botAI : public bot_ai
+    {
+    private:
+        //DelayedPetSpawnEvent - Dreadlord
+        //Impact anim, spawn, linked effects
+        class DelayedPetSpawnEvent : public BasicEvent
+        {
+            public:
+                DelayedPetSpawnEvent(Creature const* bot, Position const* pos) : _bot(bot), _pos(pos) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    ((dreadlord_botAI*)_bot->AI())->SummonBotPet(_pos);
+                    return true;
+                }
+
+            private:
+                Creature const* _bot;
+                Position const* _pos;
+                DelayedPetSpawnEvent(DelayedPetSpawnEvent const&);
+        };
+
+    public:
+        dreadlord_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DREADLORD;
+
+            //dreadlord immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+
+            checkAuraTimer = 10000;
+
+            if (!me->HasAura(VAMPIRIC_AURA, me->GetGUID()))
+                RefreshAura(VAMPIRIC_AURA);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            //if (!me->IsInCombat())
+            //    DoNonCombatActions(diff);
+
+            CheckAura(diff);
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < CARRION_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            if (IsCasting())
+                return;
+
+            if (IsSpellReady(INFERNO_1, diff) && !botPet && me->IsInCombat() &&
+                me->GetPower(POWER_MANA) >= INFERNAL_COST && Rand() < 60)
+            {
+                Unit* target = FindAOETarget(CalcSpellMaxRange(INFERNO_1));
+
+                if (target)
+                    _infernoPos = target->GetPosition();
+                else
+                    me->GetNearPoint(me, _infernoPos.m_positionX, _infernoPos.m_positionY, _infernoPos.m_positionZ, 5.f, 0.f);
+
+                me->CastSpell(_infernoPos, GetSpell(INFERNO_1), false);
+                return;
+            }
+
+            if (!CheckAttackTarget())
+                return;
+
+            CheckSleep(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            MoveBehind(opponent);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(CARRION_SWARM_1, diff) && me->GetPower(POWER_MANA) >= CARRION_COST && Rand() < 80)
+            {
+                bool cast = false;
+                if (me->HasInArc(M_PI/2, opponent) && me->GetDistance(opponent) < 25 &&
+                    (IsTank() || GetManaPCT(me) > 60 || me->getAttackers().empty() || GetHealthPCT(me) < 50 ||
+                    opponent->HasAura(SLEEP_1)))
+                {
+                    cast = true;
+                }
+
+                if (!cast)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsInConeList(targets, 25); //real radius is 30
+                    if (targets.size() > 1)
+                    {
+                        cast = true;
+                    }
+                }
+
+                if (cast && doCast(me, GetSpell(CARRION_SWARM_1)))
+                    return;
+            }
+        }
+
+        void CheckSleep(uint32 diff)
+        {
+            if (!IsSpellReady(SLEEP_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            //fleeing/casting/solo enemy
+            Unit* u = me->GetVictim();
+            if (u && IsSpellReady(CARRION_SWARM_1, diff, false) && !CCed(u) && me->GetDistance(u) < CalcSpellMaxRange(SLEEP_1) &&
+                (u->IsNonMeleeSpellCast(false,false, true) || (u->IsInCombat() && u->getAttackers().size() == 1)))
+            {
+                if (doCast(u, GetSpell(SLEEP_1)))
+                    return;
+            }
+
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(SLEEP_1), 0, SLEEP_1))
+            {
+                if (doCast(target, GetSpell(SLEEP_1)))
+                    return;
+            }
+
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(SLEEP_1)))
+            {
+                if (doCast(target, GetSpell(SLEEP_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            float pctbonus = 1.0f;
+
+            //150% damage on CCed units
+            if (CCed(damageinfo.Target))
+                pctbonus *= 1.5f;
+
+            damageinfo.Damages[0].Damage *= pctbonus;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (crit)
+                pctbonus *= 1.333f;
+
+            //double damage on CCed units
+            if (CCed(damageinfo.target))
+                pctbonus *= 2.f;
+
+            if (baseId == CARRION_SWARM_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->Effects[0].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == CARRION_SWARM_1)
+            {
+                me->resetAttackTimer();
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+            }
+
+            if (baseId == INFERNO_1)
+            {
+                me->CastSpell(_infernoPos, SPELL_INFERNO_METEOR_VISUAL, true);
+                DelayedPetSpawnEvent* spawnEvent = new DelayedPetSpawnEvent(me, &_infernoPos);
+                Events.AddEvent(spawnEvent, Events.CalculateTime(std::chrono::milliseconds(INFERNO_SPAWN_DELAY)));
+            }
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* spellInfo) override
+        {
+            //Carrion swarm heal
+            if (damage && victim != me && spellInfo && spellInfo->GetFirstRankSpell()->Id == CARRION_SWARM_1)
+            {
+                int32 basepoints0 = std::min<uint32>(damage, victim->GetHealth());
+                //TC_LOG_ERROR("entities.unit", "OnBotDamageDealt(drl): %s on %s base val %i (%s),",
+                //    me->GetName().c_str(), victim->GetName().c_str(), int32(damage), spellInfo->SpellName[0]);
+                CastSpellExtraArgs args(true);
+                args.AddSpellBP0(basepoints0);
+                me->CastSpell(me, SPELL_TRIGGERED_HEAL, args);
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage) override
+        {
+            if (damage)
+            {
+                BotSpellMap const& spells = GetSpellMap();
+                for (BotSpellMap::const_iterator itr = spells.begin(); itr != spells.end(); ++itr)
+                {
+                    //not affected if pet is alive
+                    if (botPet && itr->first == INFERNO_1)
+                        continue;
+
+                    uint32& cooldown = itr->second->cooldown;
+                    if (!cooldown)
+                        continue;
+
+                    cooldown = cooldown > DAMAGE_CD_REDUCTION ? cooldown - DAMAGE_CD_REDUCTION : 0;
+                }
+            }
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet(Position const* sPos)
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_INFERNAL;
+
+            //Position pos;
+
+            Creature* myPet = me->SummonCreature(entry, *sPos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, std::chrono::milliseconds(2000));
+            //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+            //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(master->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //immune
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, INFERNO_1);
+            //dreadlord immunities
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+
+            //myPet->SetMeleeDamageSchool(SPELL_SCHOOL_FIRE);
+
+            //infernal is immune to magic
+            //myPet->ApplySpellImmune(0, IMMUNITY_DAMAGE, SPELL_SCHOOL_MASK_MAGIC, true);
+            myPet->CastSpell(myPet, SPELL_INFERNO_EFFECT, true); //damage, stun
+            //myPet->CastSpell(myPet, SPELL_INFERNO_IMPACT_EXPLOSION, true); //visual
+            myPet->CastSpell(myPet, IMMOLATION, true);
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_INFERNAL;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            checkAuraTimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(CARRION_SWARM_1, true, false);
+            InitSpellMap(SLEEP_1, true, false);
+            InitSpellMap(INFERNO_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case CARRION_SWARM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 checkAuraTimer;
+        Position _infernoPos;
+    };
+};
+
+void AddSC_dreadlord_bot()
+{
+    new dreadlord_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..3636f90
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,2864 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Druid NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 85-90%
+TODO: Resolve remaining bugs with wrong power type after death
+TODO2: PvP behaviour revamp (again, it's like 5th time?)
+*/
+
+#define MAX_TREANTS 3
+
+enum DruidBaseSpells
+{
+    MARK_OF_THE_WILD_1                  = 1126,
+    THORNS_1                            = 467,
+    HEALING_TOUCH_1                     = 5185,
+    REGROWTH_1                          = 8936,
+    REJUVENATION_1                      = 774,
+    LIFEBLOOM_1                         = 33763,
+    NOURISH_1                           = 50464,
+    WILD_GROWTH_1                       = 48438,
+    SWIFTMEND_1                         = 18562,
+    TRANQUILITY_1                       = 740,
+    REVIVE_1                            = 50769,
+    REBIRTH_1                           = 20484,
+    BEAR_FORM_1                         = 5487,
+    SWIPE_BEAR_1                        = 779,
+    MANGLE_BEAR_1                       = 33878,
+    BASH_1                              = 5211,
+    MAUL_1                              = 6807,
+    FERAL_CHARGE_BEAR_1                 = 16979,
+    CHALLENGING_ROAR_1                  = 5209,
+    ENRAGE_1                            = 5229,
+    FRENZIED_REGENERATION_1             = 22842,
+    GROWL_1                             = 6795,
+    LACERATE_1                          = 33745,
+    SURVIVAL_INSTINCTS_1                = 61336,
+    FAERIE_FIRE_FERAL_1                 = 16857,//chains threat and damage spell regardless of bot feral form
+    BERSERK_1                           = 50334,
+    CAT_FORM_1                          = 768,
+    CLAW_1                              = 1082,
+    RAKE_1                              = 1822,
+    SHRED_1                             = 5221,
+    MANGLE_CAT_1                        = 33876,
+    RIP_1                               = 1079,
+    FEROCIOUS_BITE_1                    = 22568,
+    POUNCE_1                            = 9005,
+    RAVAGE_1                            = 6785,
+    MAIM_1                              = 22570,
+    SWIPE_CAT_1                         = 62078,
+    SAVAGE_ROAR_1                       = 52610,
+    FERAL_CHARGE_CAT_1                  = 49376,
+    COWER_1                             = 8998,
+    DASH_1                              = 1850,
+    TIGERS_FURY_1                       = 5217,
+    PROWL_1                             = 5215,
+    MOONFIRE_1                          = 8921,
+    STARFIRE_1                          = 2912,
+    WRATH_1                             = 5176,
+    HURRICANE_1                         = 16914,
+    FAERIE_FIRE_NORMAL_1                = 770,
+    INSECT_SWARM_1                      = 5570,
+    TYPHOON_1                           = 50516,
+    STARFALL_1                          = 48505,
+    MOONKIN_FORM_1                      = 24858,
+    TREE_OF_LIFE_FORM_1                 = 33891,
+    TRAVEL_FORM_1                       = 783,
+    AQUATIC_FORM_1                      = 1066,
+    //FLIGHT_FORM_1                       = 0,//niy
+    ABOLISH_POISON_1                    = 2893,//manual use only
+    CURE_POISON_1                       = 8946,
+    REMOVE_CURSE_1                      = 2782,
+    ENTANGLING_ROOTS_1                  = 339,
+    CYCLONE_1                           = 33786,
+    HIBERNATE_1                         = 2637,
+    BARKSKIN_1                          = 22812,
+    NATURES_GRASP_1                     = 16689,
+    INNERVATE_1                         = 29166,
+    NATURES_SWIFTNESS_1                 = 17116
+};
+enum DruidPassives
+{
+//Talents
+    OMEN_OF_CLARITY                     = 16864,//clearcast
+    NATURESGRACE                        = 61346,//rank 3
+    NATURAL_PERFECTION1                 = 33881,
+    NATURAL_PERFECTION2                 = 33882,
+    NATURAL_PERFECTION3                 = 33883,
+    LIVING_SEED1                        = 48496,
+    LIVING_SEED2                        = 48499,
+    LIVING_SEED3                        = 48500,
+    REVITALIZE1                         = 48539,
+    REVITALIZE2                         = 48544,
+    REVITALIZE3                         = 48545,
+    NATURALIST                          = 17073,//rank 5
+    IMPROVED_MARK_OF_THE_WILD           = 17051,//rank 2
+    FUROR                               = 17061,//rank 5
+    INTENSITY                           = 17108,//rank 3
+    LIVING_SPIRIT                       = 34153,//rank 3
+    GIFT_OF_THE_EARTHMOTHER             = 51183,//rank 5
+    ECLIPSE                             = 48525,//rank 3
+    EARTH_AND_MOON                      = 48511,//rank 3
+    SURVIVAL_OF_THE_FITTEST             = 33856,//rank 3
+    DREAMSTATE                          = 33956,//rank 3
+    BALANCE_OF_POWER                    = 33596,//rank 2
+    IMPROVED_MOONKIN_FORM               = 48396,//rank 3
+    OWLKIN_FRENZY                       = 48393,//rank 3 NOT REFRESHAURABLE
+    FERAL_SWIFTNESS                     = 24866,//rank 2 NOT REFRESHAURABLE
+    PRIMAL_PRECISION                    = 48410,//rank 2 expertise only, refund handled in Spell.cpp
+    NATURAL_REACTION                    = 57881,//rank 3 NOT REFRESHAURABLE
+    IMPROVED_LEADER_OF_THE_PACK         = 34300,//rank 2
+    PRIMAL_TENACITY                     = 33957,//rank 3
+    PREDATORY_INSTINCTS                 = 33867,//rank 3 NOT REFRESHAURABLE
+    KING_OF_THE_JUNGLE                  = 48495,//rank 3
+    PRIMAL_GORE                         = 63503,//rank 1
+//Glyphs
+    GLYPH_NOURISH                       = 62971,
+    GLYPH_SWIFTMEND                     = 54824,//no consumption
+    GLYPH_INNERVATE                     = 54832,//self regen
+    GLYPH_RAPID_REJUVENATION            = 71013,
+    GLYPH_REGROWTH                      = 54743,
+    GLYPH_REJUVENATION                  = 54754,
+    GLYPH_FRENZIED_REGENERATION         = 54810,
+    GLYPH_BARKSKIN                      = 63057,
+    GLYPH_RAKE                          = 54821,
+    GLYPH_SHRED                         = 54815,
+//other
+    T10_RESTO_P4_BONUS                  = 70664,//rejuve jump
+    T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+    T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+
+    T8_BALANCE_P4_BONUS                 = 64824,//insect swarm periodic starfire instacast trigger
+    T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+    T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+    T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+
+    T10_FERAL_P4_BONUS                  = 70726,//rake crit, enraged defense
+    T8_FERAL_P2_BONUS                   = 64752,//periodic clearcast trigger
+};
+enum DruidSpecial
+{
+    STARFALL_DAMAGE_AOE_4               = 53190,//for radius mods
+    //STARFALL_DAMAGE_DIRECT_4            = 53195,
+    STARFALL_DUMMY_AOE_4                = 53198,//for radius mods
+
+    HURRICANE_DAMAGE_1                  = 42231,
+    //TRANQUILITY_HEAL_1                  = 44203,
+    //TYPHOON_DAMAGE_1                    = 61391,
+
+    SAVAGE_ROAR_BUFF                    = 62071,//hidden buff
+    PREDATORS_SWIFTNESS_BUFF            = 69369,
+    LEADER_OF_THE_PACK_BUFF             = 24932,
+    NURTURING_INSTINCT_BUFF             = 47180,//rank 2 hidden NOT REFRESHAURABLE
+    SURVIVAL_OF_THE_FITTEST_BUFF        = 62069,//hidden buff
+    SAVAGE_DEFENSE_PASSIVE              = 62600,//class passive lvl 40
+    SAVAGE_DEFENSE_BUFF                 = 62606,
+    MASTER_SHAPESHIFTER_BEAR_BUFF       = 48418,
+    MASTER_SHAPESHIFTER_CAT_BUFF        = 48420,
+    MASTER_SHAPESHIFTER_MOONKIN_BUFF    = 48421,
+    MASTER_SHAPESHIFTER_TREE_BUFF       = 48422,
+    //NATURESGRACEBUFF                    = 16886,
+    ECLIPSE_SOLAR_BUFF                  = 48517,// from Starfire to Wrath
+    ECLIPSE_LUNAR_BUFF                  = 48518,// from Wrath to Starfire
+    ELUNES_WRATH_BUFF                   = 64823,//Starfire instacast
+    OMEN_OF_CLARITY_BUFF                = 16870,
+
+    //FERAL_CHARGE_EFFECT_BEAR_ROOT       = 45334,
+    //FERAL_CHARGE_EFFECT_CAT_DAZE        = 50259,
+    INFECTED_WOUNDS_EFFECT              = 58181,//rank 3
+    PRIMAL_FURY_EFFECT_ENERGIZE         = 16959,//5 rage
+
+    FORCE_OF_NATURE_1                   = 33831 //not casted
+};
+
+static float rageLossMult;
+
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct bot_druid_ai : public bot_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DRUID;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { removeShapeshiftForm(); UnsummonAll(); bot_ai::JustDied(u); }
+
+        uint8 GetBotStance() const override
+        {
+            return _form;
+        }
+
+        bool removeShapeshiftForm() override
+        {
+            BotStances myform = _form;
+            _form = BOT_STANCE_NONE;
+            //ShapeshiftForm form = me->GetShapeshiftForm();
+            //if (form != FORM_NONE)
+            {
+                switch (myform/*form*/)
+                {
+                    //case FORM_DIREBEAR:
+                    //case FORM_BEAR:
+                    case DRUID_BEAR_FORM:
+                        if (IsRegenActive())
+                            return false;
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_BEAR_BUFF);
+                        me->RemoveAurasDueToSpell(NATURAL_REACTION);
+                        me->RemoveAurasDueToSpell(SURVIVAL_OF_THE_FITTEST_BUFF);
+                        me->RemoveAurasDueToSpell(SAVAGE_DEFENSE_PASSIVE);
+                        break;
+                    //case FORM_CAT:
+                    case DRUID_CAT_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(FERAL_SWIFTNESS);
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_CAT_BUFF);
+                        me->RemoveAurasDueToSpell(NURTURING_INSTINCT_BUFF);
+                        me->RemoveAurasDueToSpell(PREDATORY_INSTINCTS);
+                        break;
+                    //case FORM_MOONKIN:
+                    case DRUID_MOONKIN_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(MOONKIN_FORM_1));
+                        me->RemoveAurasDueToSpell(GetSpell(OWLKIN_FRENZY));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_MOONKIN_BUFF);
+                        break;
+                    //case FORM_TREE:
+                    case DRUID_TREE_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(TREE_OF_LIFE_FORM_1));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_TREE_BUFF);
+                        break;
+                    //case FORM_TRAVEL:
+                    case DRUID_TRAVEL_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(TRAVEL_FORM_1));
+                        break;
+                    //case FORM_AQUA:
+                    case DRUID_AQUATIC_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(AQUATIC_FORM_1));
+                        break;
+                    //case FORM_FLIGHT:
+                    //case FORM_FLIGHT_EPIC:
+                    default:
+                        break;
+                }
+
+                if (me->GetPowerType() != POWER_MANA)
+                {
+                    //TC_LOG_ERROR("entities.player", "druid_bot::removeShapeshiftForm(): still has poweType %u!", uint32(me->GetPowerType()));
+                    me->SetPowerType(POWER_MANA);
+                }
+                if (me->GetShapeshiftForm() != FORM_NONE)
+                {
+                    //TC_LOG_ERROR("entities.player", "druid_bot::removeShapeshiftForm(): still speshifted into %u!", uint32(me->GetShapeshiftForm()));
+                    me->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT, me->GetGUID(), nullptr, false);
+                }
+
+                setStats(BOT_STANCE_NONE);
+            }
+            return true;
+        }
+
+        //bool IsMelee() const
+        //{
+        //    return bot_ai::IsMelee() && (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM);
+        //}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            if (_form == DRUID_BEAR_FORM && HasRole(BOT_ROLE_RANGED) && IsSpellReady(BASH_1, GetLastDiff(), false))
+                return;
+            GetInPosition(force, u);
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!gPlayer || GC_Timer > diff || IAmFree()) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            if (Rand() > 30 + 50 * (me->GetMap()->IsRaid())) return false;
+
+            Group const* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false) && !HasRole(BOT_ROLE_DPS);
+            if (!tranq && !growt) return false;
+
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = nullptr;
+            std::list<Unit*> groupUnits;
+            for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                    continue;
+                if (tPlayer->IsAlive() && me->GetDistance(tPlayer) < 40)
+                {
+                    if (growt)
+                        groupUnits.push_back(tPlayer);
+                    if (tranq && GetHealthPCT(tPlayer) < 80)
+                    {
+                        if (GetHealthPCT(tPlayer) < pct)
+                        {
+                            pct = GetHealthPCT(tPlayer);
+                            healTarget = tPlayer;
+                        }
+                        ++LHPcount;
+                        if (LHPcount > 2) break;
+                    }
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->IsAlive() && bot->GetDistance(me) < 40)
+                        {
+                            if (growt)
+                                groupUnits.push_back(bot);
+                            if (tranq && GetHealthPCT(bot) < 80)
+                            {
+                                if (GetHealthPCT(bot) < pct)
+                                {
+                                    pct = GetHealthPCT(bot);
+                                    healTarget = bot;
+                                }
+                                ++LHPcount;
+                                if (LHPcount > 2) break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+                return true;
+
+            healTarget = nullptr;
+            for (std::list<Unit*>::const_iterator i = groupUnits.begin(); i != groupUnits.end(); ++i)
+            {
+                LHPcount = 0;
+                Unit* gUnit = *i;
+
+                for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap())
+                        continue;
+                    if (tPlayer->IsAlive() && !tPlayer->isPossessed() && !tPlayer->IsCharmed() &&
+                        gUnit->GetDistance(tPlayer) < 15 && (GetLostHP(tPlayer) > 2000 || GetHealthPCT(tPlayer) < 90))
+                        ++LHPcount;
+
+                    if (tPlayer->HaveBot())
+                    {
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (bot && bot->IsInWorld() && bot->IsAlive())
+                            {
+                                if (gUnit->GetDistance(bot) < 15 && (GetLostHP(bot) > 2000 || GetHealthPCT(bot) < 90))
+                                    ++LHPcount;
+                            }
+                        }
+                    }
+
+                    if (LHPcount >= 3)
+                        break;
+                }
+
+                if (LHPcount >= 3)
+                {
+                    healTarget = gUnit;
+                    break;
+                }
+            }
+
+            if (LHPcount >= 3 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+                return true;
+
+            return false;
+        }
+
+        //Powers
+        //rage
+        void getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(MAUL_1)))
+                rage = std::max<int32>(rage - 150, 0);
+        }
+
+        //energy
+        void getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+        }
+
+        //all
+        int32 acost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        bool IsRegenActive() const
+        {
+            return me->IsAlive() && me->IsInCombat() && rage > 100 && GetHealthPCT(me) < 90 &&
+                me->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_DRUID, 0x0, 0x40000000, 0x0);
+        }
+
+        void CheckBarkskin(uint32 diff)
+        {
+            if (!me->IsAlive())
+                return;
+            //No GCD
+            if (IsSpellReady(BARKSKIN_1, diff, false) && !IsCasting() && !me->getAttackers().empty() &&
+                Rand() < (25 + 20 * me->getAttackers().size()) &&
+                GetHealthPCT(me) < (IsTank() ? 67 : 70 + 25 * me->getAttackers().size()))
+            {
+                if (doCast(me, GetSpell(BARKSKIN_1)))
+                {}
+            }
+        }
+
+        void CheckHibery(uint32 diff)
+        {
+            if (hiberyCheckTimer <= diff)
+            {
+                hibery = FindAffectedTarget(GetSpell(HIBERNATE_1), me->GetGUID());
+                hiberyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHibernate(uint32 diff)
+        {
+            if (!(_form == DRUID_MOONKIN_FORM || _form == BOT_STANCE_NONE))
+                return;
+            //Skip Tranquility, Hurricane
+            if (GC_Timer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            if (hibery == false && IsSpellReady(HIBERNATE_1, diff))
+            {
+                if (Unit* target = FindStunTarget(30))
+                {
+                    if (doCast(target, GetSpell(HIBERNATE_1)))
+                        return;
+                }
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!(_form == DRUID_MOONKIN_FORM || _form == BOT_STANCE_NONE))
+                return;
+            //Skip Tranquility, Hurricane
+            if (GC_Timer > diff || Rand() > 35 || IsChanneling() || (HasRole(BOT_ROLE_HEAL) && IsCasting()))
+                return;
+
+            if (IsSpellReady(CYCLONE_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(20, 0, CYCLONE_1))
+                {
+                    bool cast = false;
+                    for (uint8 i = CURRENT_GENERIC_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    {
+                        Spell const* spell = target->GetCurrentSpell(CurrentSpellTypes(i));
+                        if (spell && spell->GetTimer() > 1500 &&
+                            (IAmFree() ? (spell->m_targets.GetUnitTarget() == me) : (master->GetGroup() && master->GetGroup()->IsMember(spell->m_targets.GetObjectTargetGUID()))))
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                    if (cast)
+                    {
+                        me->InterruptNonMeleeSpells(false);
+                        if (doCast(target, GetSpell(CYCLONE_1)))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (me->GetPowerType() == POWER_RAGE && me->IsAlive())
+            {
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat() &&
+                        !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x00080000)
+                    /*!HasAuraName(me, ENRAGE_1)*/)
+                    {
+                        if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                }
+                getrage();
+            }
+            else if (me->GetPowerType() == POWER_ENERGY)
+                getenergy();
+
+            CheckHibery(diff);
+            CheckBarkskin(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (IsPotionReady())
+            {
+                if (me->GetPowerType() == POWER_MANA && GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 35)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (me->IsInCombat())
+                CheckBattleRez(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (HasRole(BOT_ROLE_RANGED) || !me->IsInCombat() || !me->GetVictim() ||
+                (_form != DRUID_BEAR_FORM && (_form != DRUID_CAT_FORM || !me->GetMap()->IsRaid())))
+                BuffAndHealGroup(diff);
+            if (_form != DRUID_BEAR_FORM && _form != DRUID_CAT_FORM)
+            {
+                CureGroup(GetSpell(CURE_POISON_1), diff);
+                CureGroup(GetSpell(REMOVE_CURSE_1), diff);
+            }
+
+            CheckTravelForm(diff);
+
+            if (!CheckAttackTarget())
+            {
+                if (!me->IsInCombat() && Rand() < 5 && me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+                    me->RemoveAurasDueToSpell(PROWL_1);
+                return;
+            }
+
+            CheckHibernate(diff);
+            Counter(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+
+            StartAttack(opponent, bot_ai::IsMelee());
+
+            //NOT all forms abilities (prioritized)
+            //Cat Instaheal
+            if (_form == DRUID_CAT_FORM && GC_Timer <= diff && Rand() < 60 &&
+                HasRole(BOT_ROLE_HEAL) && GetHealthPCT(me) < 45 &&
+                (me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x80000, 0x0) ||/*me->HasAura(PREDATORS_SWIFTNESS_BUFF)*/
+                (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && doCast(me, GetSpell(NATURES_SWIFTNESS_1)))))
+            {
+                //TODO maybe istant spells if clearcast?
+                //heal myself with instant
+                //Healing Touch has same reqs
+                if ((GetSpell(REGROWTH_1) && !me->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0x0, 0x0) &&
+                    doCast(me, GetSpell(REGROWTH_1))) || doCast(me, GetSpell(HEALING_TOUCH_1)))
+                {
+                    Position pos;
+                    opponent->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 15.f, opponent->GetAbsoluteAngle(me));
+                    GetInPosition(true, opponent, &pos);
+                    return;
+                }
+            }
+            //Roots
+            if (_form != DRUID_BEAR_FORM && _form != DRUID_TREE_FORM && Rand() < 35 &&
+                (HasRole(BOT_ROLE_DPS) || IAmFree()) && IsSpellReady(ENTANGLING_ROOTS_1, diff) &&
+                (_form != DRUID_CAT_FORM || IAmFree() || me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x80000, 0x0)
+                /*me->HasAura(PREDATORS_SWIFTNESS_BUFF)*/))
+                CheckRoots();
+
+            //ALL forms abilities
+            //Nature's Grasp (no shapeshift)
+            if (IsSpellReady(NATURES_GRASP_1, diff) && HasRole(BOT_ROLE_DPS) && HasRole(BOT_ROLE_RANGED) && Rand() < 70 &&
+                !me->getAttackers().empty())
+            {
+                if (doCast(me, GetSpell(NATURES_GRASP_1)))
+                    return;
+            }
+            //Survival Instincts
+            //No GCD, bear is lvl 10, SI is lvl 20
+            //Shapeshift into bear if needed
+            if (IsSpellReady(SURVIVAL_INSTINCTS_1, diff, false) && Rand() < 75 &&
+                (GetHealthPCT(me) < (30 + 20 * (me->getAttackers().size() > 1))) &&
+                (_form == DRUID_BEAR_FORM || (GC_Timer <= diff && doCast(me, GetSpell(BEAR_FORM_1)))))
+            {
+                if (doCast(me, SURVIVAL_INSTINCTS_1))
+                    BotWhisper("Survival Instincts used!");
+            }
+            //Bash
+            //Assuming Furor is present which is lvl 10
+            //Shapeshift into bear if needed
+            //bear is lvl 10, bash is lvl 14
+            //Retreat is triggered only if hit (SpellHitTarget)
+            if (IsSpellReady(BASH_1, diff) && !CCed(opponent, !opponent->IsNonMeleeSpellCast(false,false,true)) &&
+                opponent->IsWithinMeleeRange(me))
+            {
+                if (_form == DRUID_BEAR_FORM && rage >= acost(BASH_1))
+                {
+                    if (doCast(opponent, GetSpell(BASH_1)))
+                        return;
+                }
+                else if (_form != DRUID_BEAR_FORM && opponent->GetVictim() == me && Rand() < 25)
+                {
+                    if (doCast(me, GetSpell(BEAR_FORM_1)))
+                        return;
+                }
+            }
+
+            //Main mode
+            //Choose form. Mode should be selected considering bot_ai::CheckAttackTarget() positioning selection
+            //1 Tanking mode
+            if (IsTank() && GetSpell(BEAR_FORM_1))
+            {
+                if (_form == DRUID_BEAR_FORM ||
+                    (GC_Timer <= diff && doCast(me, GetSpell(BEAR_FORM_1))))
+                    doBearActions(diff);
+            }
+            //2 Melee (tanking cat impossible: cat lvl 20, bear lvl 10)
+            else if (bot_ai::IsMelee())
+            {
+                //if lvl < 20 then bot gonna just melee its targets
+                if (_form == DRUID_CAT_FORM ||
+                    (IsSpellReady(CAT_FORM_1, diff) && doCast(me, GetSpell(CAT_FORM_1))))
+                    doCatActions(diff);
+            }
+            //3 Ranged dps
+            else if (HasRole(BOT_ROLE_DPS))
+            {
+                //pure dps goes moonkin
+                if (_form == DRUID_MOONKIN_FORM ||
+                    ((!GetSpell(MOONKIN_FORM_1) || HasRole(BOT_ROLE_HEAL)) && GC_Timer <= diff && removeShapeshiftForm()) ||
+                    HasRole(BOT_ROLE_HEAL) ||
+                    (IsSpellReady(MOONKIN_FORM_1, diff) && doCast(me, GetSpell(MOONKIN_FORM_1))))
+                    doBalanceActions(diff);
+            }
+            //4 Healer
+            else if (HasRole(BOT_ROLE_HEAL))
+            {
+                //pure healer goes tree
+                if (_form == DRUID_TREE_FORM ||
+                    ((!GetSpell(TREE_OF_LIFE_FORM_1) || HasRole(BOT_ROLE_DPS)) && GC_Timer <= diff && removeShapeshiftForm()) ||
+                    HasRole(BOT_ROLE_DPS) ||
+                    (IsSpellReady(TREE_OF_LIFE_FORM_1, diff) && doCast(me, GetSpell(TREE_OF_LIFE_FORM_1))))
+                {/*do nothing*/} //not a mistake
+            }
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            //debug
+            if (me->GetPowerType() != POWER_RAGE || (me->GetShapeshiftForm() != FORM_BEAR && me->GetShapeshiftForm() != FORM_DIREBEAR))
+                return;
+
+            //Enrage
+            if (IsSpellReady(ENRAGE_1, diff, false) && me->IsInCombat() && (rage < 400 || IsTank()) && Rand() < 40)
+            {
+                if (doCast(me, GetSpell(ENRAGE_1)))
+                    getrage();
+            }
+            //Frenzied Regeneration
+            if (IsSpellReady(FRENZIED_REGENERATION_1, diff) && rage > 700 && GetHealthPCT(me) < 70 && Rand() < 40)
+            {
+                if (doCast(me, GetSpell(FRENZIED_REGENERATION_1)))
+                    return;
+            }
+
+            float dist = me->GetDistance(opponent);
+            //GROWL //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(GROWL_1, diff, false) && u && u != me && Rand() < 40 && dist < 30 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) && IsInBotParty(u) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80) || IsTank()))
+            {
+                if (doCast(opponent, GetSpell(GROWL_1)))
+                    return;
+            }
+            //GROWL 2 (distant)
+            if (IsSpellReady(GROWL_1, diff, false) && u == me && IsTank() && Rand() < 20 &&
+                !(me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())))
+            {
+                if (Unit* tUnit = FindDistantTauntTarget())
+                {
+                    if (doCast(tUnit, GetSpell(GROWL_1)))
+                        return;
+                }
+            }
+            //Challenging Roar
+            if (IsSpellReady(CHALLENGING_ROAR_1, diff) &&
+                !(u == me && me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())) &&
+                rage >= acost(CHALLENGING_ROAR_1))
+            {
+                u = opponent->GetVictim();
+                if (u && u != me && !IsTank(u) && IsInBotParty(u) && !CCed(opponent) && dist <= 10 && Rand() < 25 &&
+                    (!IsTankingClass(u->GetClass()) || IsTank()))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_ROAR_1)))
+                        return;
+                }
+                if (IsTank() && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f, 1);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(me, GetSpell(CHALLENGING_ROAR_1)))
+                        return;
+                }
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //Feral Charge
+            if (IsSpellReady(FERAL_CHARGE_BEAR_1, diff, false) && rage >= acost(FERAL_CHARGE_BEAR_1) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !CCed(opponent, true) && dist > 9 && dist < 25)
+            {
+                if (doCast(opponent, GetSpell(FERAL_CHARGE_BEAR_1)))
+                    return;
+            }
+
+            //Faerie Fire (Feral, Bear)
+            if (IsSpellReady(FAERIE_FIRE_FERAL_1, diff) && me->IsInCombat() && Rand() < 35 && dist < CalcSpellMaxRange(FAERIE_FIRE_FERAL_1) &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400))
+            {
+                if (doCast(opponent, GetSpell(FAERIE_FIRE_FERAL_1)))
+                    return;
+            }
+
+            //range check (melee) to prevent fake casts
+            if (dist > 5) return;
+
+            //Berserk (Bear)
+            if (IsSpellReady(BERSERK_1, diff) && !HasRole(BOT_ROLE_HEAL) && rage > 400 && Rand() < 40 &&
+                me->getAttackers().size() > 2)
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+
+            //BOT_ROLE_DPS is checked in Attack(uin32)
+            //if (!HasRole(BOT_ROLE_DPS)) return;
+
+            //frenzied regeneration check
+            //we don't need to spend too much rage if regening
+            bool isRegenActive = IsRegenActive();
+
+            //Mangle (Bear)
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && rage >= acost(MANGLE_BEAR_1) + 200*isRegenActive)
+            {
+                if (me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40) ||
+                    (Rand() < 30 && !opponent->GetAuraEffect(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT, SPELLFAMILY_DRUID, 2312, 1)))
+                {
+                    if (doCast(opponent, GetSpell(MANGLE_BEAR_1)))
+                        return;
+                }
+            }
+            //Swipe (Bear)
+            if (IsSpellReady(SWIPE_BEAR_1, diff) && rage >= acost(SWIPE_BEAR_1) + 200*isRegenActive &&
+                IsTank() && Rand() < 70)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 5);
+                if (targets.size() > 2)
+                    if (doCast(opponent, GetSpell(SWIPE_BEAR_1)))
+                        return;
+            }
+            //Lacerate
+            if (IsSpellReady(LACERATE_1, diff) && rage >= acost(LACERATE_1) + 200*isRegenActive &&
+                opponent->GetHealth() > me->GetMaxHealth() * 2 && Rand() < 45)
+            {
+                bool cast = rage >= 600;
+                if (!cast)
+                {
+                    AuraApplication const* lacera = opponent->GetAuraApplicationOfRankedSpell(LACERATE_1);
+                    cast = (!lacera || lacera->GetBase()->GetStackAmount() < 5 || lacera->GetBase()->GetDuration() < 6000);
+                }
+
+                if (cast && doCast(opponent, GetSpell(LACERATE_1)))
+                    return;
+            }
+
+            //skip if maul is active
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //Maul //No GCD
+            if (IsSpellReady(MAUL_1, diff, false) && rage >= acost(MAUL_1) + 200 + 200*isRegenActive)
+            {
+                if (doCast(opponent, GetSpell(MAUL_1)))
+                    return;
+            }
+        }
+
+        void doCatActions(uint32 diff)
+        {
+            //debug
+            if (me->GetPowerType() != POWER_ENERGY || me->GetShapeshiftForm() != FORM_CAT)
+                return;
+
+            //Prowl (for Cooldown handling see bot_ai::ReleaseSpellCooldown)
+            if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && Rand() < 50 && me->GetDistance(opponent) < 28)
+            {
+                if (doCast(me, GetSpell(PROWL_1)))
+                {}
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //Faerie Fire (Feral, Cat)
+            if (IsSpellReady(FAERIE_FIRE_FERAL_1, diff) && me->IsInCombat() && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                Rand() < 35 && me->GetDistance(opponent) < 30 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400))
+            {
+                if (doCast(opponent, GetSpell(FAERIE_FIRE_FERAL_1)))
+                    return;
+            }
+
+            if (!JumpingOrFalling() && !CCed(me, true))
+            {
+                //leap here
+                //Feral Charge (Cat)
+                if (IsSpellReady(FERAL_CHARGE_CAT_1, diff, false) && energy >= acost(FERAL_CHARGE_CAT_1) && !me->GetMap()->IsDungeon() &&
+                    !HasBotCommandState(BOT_COMMAND_STAY) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && Rand() < 65 &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_DRUID, 0x0, 0x0, 0x8) &&//not dashing
+                    me->GetDistance(opponent) > 10 && me->GetDistance(opponent) < 25)
+                {
+                    if (doCast(opponent, GetSpell(FERAL_CHARGE_CAT_1)))
+                        return; //no gcd but jump time
+                }
+
+                //Dash (no GCD)
+                if (IsSpellReady(DASH_1, diff, false) &&
+                    (me->HasAuraType(SPELL_AURA_MOD_STEALTH) || (me->IsInCombat() && !IsSpellReady(FERAL_CHARGE_CAT_1, diff, false))) &&
+                    Rand() < 85 && me->GetDistance(opponent) > 15)
+                {
+                    if (doCast(me, GetSpell(DASH_1)))
+                    {}
+                }
+                //Savage Roar
+                if (IsSpellReady(SAVAGE_ROAR_1, diff) && comboPoints >= 1 && (me->IsInCombat() || opponent->IsInCombat()) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && energy >= acost(SAVAGE_ROAR_1) &&
+                    !me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_DRUID, 0, 0x10000000, 0))
+                {
+                    if (doCast(opponent, GetSpell(SAVAGE_ROAR_1)))
+                        return;
+                }
+            }
+
+            MoveBehind(opponent);
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5)
+                return;
+
+            //Cower
+            if (opponent->CanHaveThreatList())
+            {
+                if (IsSpellReady(COWER_1, diff) && opponent->GetVictim() == me && energy >= acost(COWER_1) &&
+                    int32(opponent->GetThreatManager().GetThreatListSize()) > 1 &&
+                    int32(opponent->getAttackers().size()) > 1 && Rand() < 45)
+                {
+                    if (doCast(opponent, GetSpell(COWER_1)))
+                        return;
+                }
+            }
+            //Tiger's Fury (no GCD) cannot use while Berserk is active
+            if (IsSpellReady(TIGERS_FURY_1, diff, false) && opponent->GetHealth() > me->GetHealth() / 4 &&
+                (me->GetLevel() < 55 || energy <= 40) && Rand() < 40 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+            {
+                if (doCast(me, GetSpell(TIGERS_FURY_1)))
+                    getenergy();
+            }
+            //Berserk can be used After Tiger's Fury without dispelling it
+            //Berserk (Cat)
+            if (IsSpellReady(BERSERK_1, diff) && !HasRole(BOT_ROLE_HEAL) && (!me->HasAuraType(SPELL_AURA_MOD_STEALTH) || energy >= 40) && Rand() < 50 &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetHealth() + 5000 > me->GetHealth()))
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+
+            //Openers
+            if (me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            {
+                uint32 opener =
+                    GetSpell(POUNCE_1) &&
+                    !opponent->HasAuraType(SPELL_AURA_MOD_STUN) &&
+                    opponent->GetDiminishing(DIMINISHING_OPENING_STUN) < DIMINISHING_LEVEL_3 &&
+                    (opponent->GetTypeId() == TYPEID_PLAYER || (!IAmFree() && master->GetNpcBotsCount() > 1)) ? POUNCE_1 :
+                    GetSpell(RAVAGE_1) ? RAVAGE_1 :
+                    GetSpell(SHRED_1) ? SHRED_1 : 0;
+
+                //all opener spells disabled
+                if (!opener)
+                {
+                    me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                    return;
+                }
+
+                if (opener != POUNCE_1 && opponent->HasInArc(M_PI, me))
+                    return;
+
+                //We do not check combo points amount
+                if (IsSpellReady(opener, diff) && energy >= acost(opener))
+                {
+                    if (doCast(opponent, GetSpell(opener)))
+                        return;
+                }
+
+                return;
+            }
+
+            //Finishers
+            if (comboPoints > 0)
+            {
+                //Maim
+                if (IsSpellReady(MAIM_1, diff) && !CCed(opponent) && energy >= acost(MAIM_1) &&
+                    (comboPoints >= 4 || opponent->IsNonMeleeSpellCast(false,false,true)))
+                {
+                    if (doCast(opponent, GetSpell(MAIM_1)))
+                        return;
+                }
+                //Ferocious Bite
+                if (IsSpellReady(FEROCIOUS_BITE_1, diff) && (comboPoints >= 4 || opponent->GetHealth() < me->GetMaxHealth() / 4) &&
+                    energy >= acost(FEROCIOUS_BITE_1) && Rand() < (50 + comboPoints * 20))
+                {
+                    if (doCast(opponent, GetSpell(FEROCIOUS_BITE_1)))
+                        return;
+                }
+                //Rip
+                if (IsSpellReady(RIP_1, diff) && (comboPoints < 4 || !GetSpell(FEROCIOUS_BITE_1)) &&
+                    energy >= acost(RIP_1) && opponent->GetHealth() > me->GetMaxHealth() / 4 &&
+                    Rand() < (50 + 40 * (opponent->GetTypeId() == TYPEID_PLAYER && IsMeleeClass(opponent->GetClass()))) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x800000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (doCast(opponent, GetSpell(RIP_1)))
+                        return;
+                }
+            }
+
+            //Combo points generating
+            //Swipe (Cat)
+            if (IsSpellReady(SWIPE_CAT_1, diff) && me->getAttackers().empty() && energy >= acost(SWIPE_CAT_1) && Rand() < (35 + 100 * (me->GetMap()->IsDungeon())))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 5);
+                if (targets.size() > 2)
+                    if (doCast(opponent, GetSpell(SWIPE_CAT_1)))
+                        return;
+            }
+            //Shred
+            if (IsSpellReady(SHRED_1, diff) && comboPoints < 4 && energy >= acost(SHRED_1) && Rand() < 85 &&
+                !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(SHRED_1)))
+                    return;
+            }
+            //Mangle (Cat)
+            if (IsSpellReady(MANGLE_CAT_1, diff) && comboPoints < 5 && energy >= acost(MANGLE_CAT_1) &&
+                (Rand() < 35 || !opponent->GetAuraEffect(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT, SPELLFAMILY_DRUID, 2312, 1)))
+            {
+                if (doCast(opponent, GetSpell(MANGLE_CAT_1)))
+                    return;
+            }
+            //Rake
+            if (IsSpellReady(RAKE_1, diff) && comboPoints < 3 && energy >= acost(RAKE_1) && Rand() < 60 &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x1000, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(RAKE_1)))
+                    return;
+            }
+            //Claw
+            if (IsSpellReady(CLAW_1, diff) && comboPoints < 5 && Rand() < 50 && (!GetSpell(SHRED_1) || opponent->HasInArc(M_PI, me)) &&
+                energy >= acost(CLAW_1))
+            {
+                if (doCast(opponent, GetSpell(CLAW_1)))
+                    return;
+            }
+        }
+
+        void doBalanceActions(uint32 diff)
+        {
+            //debug
+            if (me->GetPowerType() != POWER_MANA)
+                return;
+
+            if (HasRole(BOT_ROLE_HEAL) && GetManaPCT(me) < 25)
+                return;
+
+            //BOT_ROLE_DPS is checked in Attack(uint32)
+
+            float dist = me->GetDistance(opponent);
+            if (dist > CalcSpellMaxRange(WRATH_1))
+                return;
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NATURE|SPELL_SCHOOL_MASK_ARCANE))
+                return;
+
+            //spell reflections
+            if (IsSpellReady(FAERIE_FIRE_NORMAL_1, diff) && CanRemoveReflectSpells(opponent, FAERIE_FIRE_NORMAL_1) &&
+                doCast(opponent, FAERIE_FIRE_NORMAL_1))
+                return;
+
+            //Starfall
+            if (IsSpellReady(STARFALL_1, diff) && Rand() < 40)
+            {
+                bool cast = (opponent->GetTypeId() == TYPEID_PLAYER || me->getAttackers().size() > 1);
+                if (!cast)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 30.f, 0);
+                    if (targets.size() > 3)
+                        cast = true;
+                }
+
+                if (cast && doCast(me, GetSpell(STARFALL_1)))
+                    return;
+
+                SetSpellCooldown(STARFALL_1, 1500); //fail
+            }
+            //Hurricane
+            if (IsSpellReady(HURRICANE_1, diff) && !JumpingOrFalling() && Rand() < 50)
+            {
+                if (Unit* target = FindAOETarget(CalcSpellMaxRange(HURRICANE_1)))
+                {
+                    if (doCast(target, GetSpell(HURRICANE_1)))
+                        return;
+                }
+                SetSpellCooldown(HURRICANE_1, 1000); //fail
+            }
+            //Typhoon
+            if (IsSpellReady(TYPHOON_1, diff) && Rand() < 75)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 25);
+                if (targets.size() > 2)
+                    if (doCast(me, GetSpell(TYPHOON_1)))
+                        return;
+
+                SetSpellCooldown(TYPHOON_1, 1000); //fail
+            }
+
+            if (IsSpellReady(FORCE_OF_NATURE_1, diff))
+            {
+                SummonBotPet(opponent);
+                SetSpellCooldown(FORCE_OF_NATURE_1, 180000);
+                return;
+            }
+
+            //Faerie Fire (non-feral): moonkin or non-shapeshifted
+            if (IsSpellReady(FAERIE_FIRE_NORMAL_1, diff) && opponent->getAttackers().size() > 2 && Rand() < 50 &&
+                dist < CalcSpellMaxRange(FAERIE_FIRE_NORMAL_1) &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400)
+                /*!HasAuraName(opponent, FAERIE_FIRE_ANY)*/)
+            {
+                if (doCast(opponent, GetSpell(FAERIE_FIRE_NORMAL_1)))
+                    return;
+            }
+
+            Unit* u = opponent->GetVictim();
+            //Insect Swarm
+            if (IsSpellReady(INSECT_SWARM_1, diff) && u && opponent->GetDistance(u) < 8 && Rand() < 30 &&
+                dist < CalcSpellMaxRange(INSECT_SWARM_1) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200000, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(opponent, INSECT_SWARM_1, me->GetGUID())*/)
+            {
+                if (doCast(opponent, GetSpell(INSECT_SWARM_1)))
+                    return;
+            }
+
+            if (IsSpellReady(MOONFIRE_1, diff) && Rand() < 60 && dist < CalcSpellMaxRange(MOONFIRE_1) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x2, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(opponent, MOONFIRE_1, me->GetGUID())*/)
+            {
+                if (doCast(opponent, GetSpell(MOONFIRE_1)))
+                    return;
+            }
+            //TODO: balance starfire/wrath frequency based on mana effeciency
+            if (IsSpellReady(STARFIRE_1, diff) && dist < CalcSpellMaxRange(STARFIRE_1))
+            {
+                AuraEffect const* eclipeLunar = me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x0, 0x4000);
+                int32 rand = 30 + 100 * (eclipeLunar && eclipeLunar->GetBase()->GetDuration() > 3000);
+
+                if (Rand() < rand && doCast(opponent, GetSpell(STARFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(WRATH_1, diff))
+            {
+                if (doCast(opponent, GetSpell(WRATH_1)))
+                    return;
+            }
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (GC_Timer <= diff && Rand() < 35 && GetManaPCT(me) > 15 &&
+                (me->IsPolymorphed() || me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                uint32 sshift;
+                switch (_form)
+                {
+                    case DRUID_BEAR_FORM:
+                        sshift = IsTank() && !me->getAttackers().empty() &&
+                            (!me->GetVictim() || me->GetDistance(me->GetVictim()) < 5) ? 0 :
+                            GetSpell(BEAR_FORM_1); break;
+                    case DRUID_CAT_FORM:     sshift = GetSpell(CAT_FORM_1);         break;
+                    case DRUID_MOONKIN_FORM: sshift = GetSpell(MOONKIN_FORM_1);     break;
+                    case DRUID_TREE_FORM:    sshift = GetSpell(TREE_OF_LIFE_FORM_1);break;
+                    //case DRUID_FLIGHT_FORM:  sshift = GetSpell(FLIGHT_FORM_1);      break;
+                    case DRUID_TRAVEL_FORM:  sshift = GetSpell(TRAVEL_FORM_1);      break;
+                    case DRUID_AQUATIC_FORM: sshift = GetSpell(AQUATIC_FORM_1);     break;
+                    case BOT_STANCE_NONE:    sshift = GetSpell(TRAVEL_FORM_1);      break;
+                    default:                 sshift = 0;                            break;
+                }
+                if (sshift && doCast(me, sshift))
+                {
+                    GetInPosition(false, nullptr);
+                    return;
+                }
+            }
+            if (IsSpellReady(BERSERK_1, diff) && Rand() < 10 && me->HasAuraWithMechanic(1<<MECHANIC_FEAR))
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 95 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * 2;
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * 2;
+            if (xppct >= 95 && hp >= 25)
+                return false;
+
+            if (IsTank() && xppct > 25)
+                return false;
+            if (hp > 50 && !IsTank(target) && (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM))
+                return false; //do not waste heal if in feral or so
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && Rand() < 80 &&
+                (me->IsInCombat() || target->IsInCombat()) &&//may just revive
+                hp <= 20 && xppct <= 0 && xphploss > _heals[HEALING_TOUCH_1] / 2 &&
+                (target->GetTypeId() == TYPEID_PLAYER || IsTank(target) || target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)))
+                {
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        return true;
+                }
+            }
+            if (IsSpellReady(NOURISH_1, diff) && xppct <= 65 && xphploss > _heals[REJUVENATION_1])
+            {
+                static uint8 minHots = 2;
+                uint8 hots = 0;
+                Unit::AuraEffectList const& effectList = target->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+                for (Unit::AuraEffectList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)
+                {
+                    AuraEffect const* eff = *itr;
+                    if (eff->GetCasterGUID() != me->GetGUID())
+                        continue;
+                    SpellInfo const* spellInfo = eff->GetSpellInfo();
+                    if (spellInfo->SpellFamilyName != SPELLFAMILY_DRUID)
+                        continue;
+                    //rejuv,regro,lifeb,wildg
+                    if (!((spellInfo->SpellFamilyFlags[0] & 0x50) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                        continue;
+                    hots += eff->GetBase()->GetStackAmount();
+                    if (hots >= minHots)
+                        break;
+                }
+                if (hots >= minHots && doCast(target, GetSpell(NOURISH_1)))
+                    return true;
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false) && !HasRole(BOT_ROLE_DPS|BOT_ROLE_TANK) && hp < 60 &&
+                (xppct <= 15 || int32(GetLostHP(target)) > _heals[REJUVENATION_1]) &&
+                //rejuv,regro
+                target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x0, 0x0, me->GetGUID())
+                /*(HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1))*/)
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                    return true;
+            }
+            //maintain HoTs
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+            if (IsSpellReady(REGROWTH_1, diff) && Rand() < 80 && (tanking || xphploss > _heals[REGROWTH_1]) &&
+                (xppct <= 45 || !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0x0, 0x0, me->GetGUID()))
+                /*!HasAuraName(target, REGROWTH_1, me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                    return true;
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) && xppct >= 40 && hp < 75 + 10 * tanking)
+            {
+                AuraEffect const* bloom = target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x0, 0x10, 0x0, me->GetGUID());
+                //Aura const* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetBase()->GetStackAmount() < 3 ||
+                    (bloom->GetBase()->GetDuration() < 2000 && !target->getAttackers().empty())) &&
+                    doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (IsSpellReady(HEALING_TOUCH_1, diff) && (xppct > 15 || !GetSpell(REGROWTH_1)) &&
+                xphploss > _heals[HEALING_TOUCH_1] &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+                return true;
+            if (IsSpellReady(REJUVENATION_1, diff) && xppct > 45 &&
+                (tanking || xphploss > _heals[REJUVENATION_1]) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x10, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(target, REJUVENATION_1, me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                    return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_DRUID, 0x40000)
+                    /*!HasAuraName(target, MARK_OF_THE_WILD_1)*/)
+                    if (doCast(target, MARK_OF_THE_WILD))
+                        return true;
+            }
+            if (uint32 THORNS = GetSpell(THORNS_1))
+            {
+                if (IsTank(target) &&
+                    !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_DAMAGE_SHIELD, SPELLFAMILY_DRUID, 0x100)
+                    /*!HasAuraName(target, THORNS_1)*/)
+                    if (doCast(target, THORNS))
+                        return true;
+            }
+
+            return false;
+        }
+
+        void CheckTravelForm(uint32 diff)
+        {
+            if (!IsSpellReady(TRAVEL_FORM_1, diff) || !HasBotCommandState(BOT_COMMAND_FOLLOW) || Rand() > 15 ||
+                me->GetShapeshiftForm() == FORM_TRAVEL || me->GetVictim() || me->IsMounted() || IAmFree() || IsCasting())
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 30))
+            {
+                if (doCast(me, GetSpell(TRAVEL_FORM_1)))
+                    return;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REVIVE_1));
+
+            if (!IAmFree() && HasBotCommandState(BOT_COMMAND_FOLLOW) && !master->IsMounted() && Rand() < 35)
+            {
+                int32 dist = int32(me->GetDistance(master));
+                if (me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+                {
+                    if (_form != DRUID_AQUATIC_FORM && dist > 30 && GetSpell(AQUATIC_FORM_1) &&
+                        doCast(me, GetSpell(AQUATIC_FORM_1)))
+                        return;
+                }
+                //if (me->HasUnitMovementFlag(MOVEMENTFLAG_FLYING))
+                //{
+                //    if (_form != DRUID_AQUATIC_FORM && dist > 30 && GetSpell(AQUATIC_FORM_1) &&
+                //        doCast(me, GetSpell(AQUATIC_FORM_1)))
+                //        return;
+                //}
+                else if (_form != DRUID_TRAVEL_FORM && dist > 30 && GetSpell(TRAVEL_FORM_1))
+                {
+                    if (doCast(me, GetSpell(TRAVEL_FORM_1)))
+                        return;
+                }
+                else if (_form == DRUID_AQUATIC_FORM)
+                    removeShapeshiftForm();
+            }
+        }
+
+        void doInnervate(uint32 diff)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 25)
+                return;
+            if (_form != BOT_STANCE_NONE && _form != DRUID_MOONKIN_FORM && _form != DRUID_TREE_FORM &&
+                (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            static uint8 minmanaval = 30;
+            Unit* iTarget = nullptr;
+
+            if (master->IsInCombat() && master->GetPowerType() == POWER_MANA &&
+                GetManaPCT(master) < minmanaval && !master->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                iTarget = master;
+            else if (me->IsInCombat() && me->GetPowerType() == POWER_MANA &&
+                GetManaPCT(me) < minmanaval && !me->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                iTarget = me;
+
+            if (!IAmFree())
+            {
+                Group const* group = master->GetGroup();
+                if (!iTarget && !group) //first check master's bots
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Creature* bot = itr->second;
+                        if (!bot || !bot->IsInCombat() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                        if (bot->GetPowerType() != POWER_MANA) continue;
+                        if (bot->GetBotClass() == BOT_CLASS_HUNTER || bot->GetBotClass() == BOT_CLASS_WARLOCK) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+                if (!iTarget && group) //cycle through player members...
+                {
+                    for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == nullptr || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || !tPlayer->IsAlive()) continue;
+                        if (tPlayer->GetPowerType() != POWER_MANA) continue;
+                        if (me->GetExactDist(tPlayer) > 30) continue;
+                        if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                        {
+                            iTarget = tPlayer;
+                            break;
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+                if (!iTarget && group) //... and their bots.
+                {
+                    for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* tPlayer = itr->GetSource();
+                        if (tPlayer == nullptr || !tPlayer->HaveBot()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInCombat() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                            if (bot->GetPowerType() != POWER_MANA) continue;
+                            if (bot->GetBotClass() == BOT_CLASS_HUNTER || bot->GetBotClass() == BOT_CLASS_WARLOCK) continue;
+                            if (me->GetExactDist(bot) > 30) continue;
+                            if (GetManaPCT(bot) < minmanaval && !bot->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                            {
+                                iTarget = bot;
+                                break;
+                            }
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+            }
+
+            if (iTarget && doCast(iTarget, INNERVATE_1))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Innervate on You!", iTarget->ToPlayer());
+                if (iTarget != master)
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    BotWhisper(msg.str().c_str());
+                }
+
+                return;
+            }
+
+            SetSpellCooldown(INNERVATE_1, 1500); //fail
+        }
+
+        void CheckRoots()
+        {
+            if (uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1))
+            {
+                if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60))
+                    return;
+                if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                    if (doCast(target, ENTANGLING_ROOTS))
+                        return;
+            }
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || IAmFree() || me->IsMounted() ||
+                IsTank() || IsCasting() || Rand() > 20) return;
+
+            Group const* gr = master->GetGroup();
+            std::list<Unit*> targets;
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->IsResurrectRequested()) return; //resurrected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30 && !HasBotCommandState(BOT_COMMAND_STAY))
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    BotWhisper("Rezzing You");
+                    return;
+                }
+            }
+            else
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    Unit* target = tPlayer;
+                    if (!tPlayer || tPlayer->IsAlive()) continue;
+                    if (tPlayer->IsResurrectRequested()) continue; //resurrected
+                    if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                        target = (Unit*)tPlayer->GetCorpse();
+                    if (!target || !target->IsInWorld()) continue;
+                    if (master->GetMap() != target->FindMap()) continue;
+                    if (me->GetDistance(target) > 100) continue;
+                    targets.push_back(target);
+                }
+            }
+
+            BotMap const* botMap = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = botMap->begin(); itr != botMap->end(); ++itr)
+            {
+                Creature* bot = itr->second;
+                if (bot && bot->IsInWorld() && !bot->IsAlive() && IsTank(bot) && me->GetDistance(bot) < 80)
+                    targets.push_back(bot);
+            }
+
+            if (Unit* targetOrCorpse = !targets.empty() ? Trinity::Containers::SelectRandomContainerElement(targets) : nullptr)
+            {
+                if (me->GetExactDist(targetOrCorpse) > 30 && !HasBotCommandState(BOT_COMMAND_STAY))
+                {
+                    me->GetMotionMaster()->MovePoint(targetOrCorpse->GetMapId(), *targetOrCorpse);
+                    return;
+                }
+                else if (!targetOrCorpse->IsWithinLOSInMap(me))
+                    me->Relocate(*targetOrCorpse);
+
+                if (doCast(targetOrCorpse, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    if (targetOrCorpse->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Rezzing You", targetOrCorpse->ToPlayer());
+                    if (targetOrCorpse != master)
+                    {
+                        std::string rezstr = "Rezzing ";
+                        rezstr += targetOrCorpse->GetName();
+                        if (targetOrCorpse->GetTypeId() == TYPEID_UNIT)
+                            rezstr += " (bot tank)";
+                        BotWhisper(rezstr.c_str());
+                    }
+                    return;
+                }
+            }
+        }
+
+        void setStats(BotStances form)
+        {
+            _form = form;
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    if (me->GetPowerType() != POWER_RAGE)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_RAGE");
+                        me->SetPowerType(POWER_RAGE);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_BEAR_BUFF, me->GetLevel() >= 20);
+                    if (_spec == BOT_SPEC_DRUID_FERAL)
+                    {
+                        RefreshAura(NATURAL_REACTION, me->GetLevel() >= 35);
+                        RefreshAura(SURVIVAL_OF_THE_FITTEST_BUFF, me->GetLevel() >= 35);
+                        RefreshAura(SAVAGE_DEFENSE_PASSIVE, me->GetLevel() >= 40);
+                    }
+                    break;
+                case DRUID_CAT_FORM:
+                    if (me->GetPowerType() != POWER_ENERGY)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_ENERGY");
+                        me->SetPowerType(POWER_ENERGY);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_CAT_BUFF, me->GetLevel() >= 20);
+                    RefreshAura(FERAL_SWIFTNESS, me->GetLevel() >= 20); //talents ignore forms for creatures so put that here
+                    if (_spec == BOT_SPEC_DRUID_FERAL)
+                    {
+                        RefreshAura(NURTURING_INSTINCT_BUFF, me->GetLevel() >= 30);
+                        RefreshAura(PREDATORY_INSTINCTS, me->GetLevel() >= 45);
+                    }
+                    break;
+                case DRUID_MOONKIN_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (moonkin)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_MOONKIN_BUFF, me->GetLevel() >= 20);
+                    RefreshAura(OWLKIN_FRENZY, me->GetLevel() >= 45);
+                    break;
+                case DRUID_TREE_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (tree)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_TREE_BUFF, me->GetLevel() >= 20);
+                    break;
+                case DRUID_TRAVEL_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (travel)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    break;
+                case DRUID_AQUATIC_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (aquatic)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    break;
+                //case DRUID_FLIGHT_FORM:
+                //    if (me->GetPowerType() != POWER_MANA)
+                //    {
+                //        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (flight)");
+                //        me->SetPowerType(POWER_MANA);
+                //    }
+                //    break;
+                case BOT_STANCE_NONE:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (deshape)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "druid_bot::setStats(): NYI form %u", uint32(form));
+                    setStats(BOT_STANCE_NONE);
+                    return;
+            }
+
+            SetShouldUpdateStats();
+            SetStats(false);
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.HitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Primal Fury (white attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 25 && _form == DRUID_BEAR_FORM)
+                    me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+                //Predatory Instincts (part 1): 10% additional crit damage bonus for melee attacks in Cat form
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 45 && _form == DRUID_CAT_FORM)
+                    pctbonus += 0.05f;
+            }
+
+            damageinfo.Damages[0].Damage *= (1.0f + pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                ////Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                //if (lvl >= 21)
+                //    pctbonus += 0.25f;
+            }
+
+            //Feral Aggression: 15% bonus damage for Ferocious Bite
+            if (lvl >= 10 && baseId == FEROCIOUS_BITE_1)
+                pctbonus += 0.15f;
+            //Feral Instinct: 30% bonus damage for Swipe (Bear)
+            if (lvl >= 15 && baseId == SWIPE_BEAR_1)
+                pctbonus += 0.3f;
+            //Savage Fury: 20% bonus damage for Claw, Rake, Mangle (Cat), Mangle (Bear) and Maul
+            if (lvl >= 15 &&
+                (baseId == CLAW_1 ||
+                baseId == RAKE_1 ||
+                baseId == MANGLE_CAT_1 ||
+                baseId == MANGLE_BEAR_1 ||
+                baseId == MAUL_1))
+                pctbonus += 0.2f;
+            //Rend and Tear: 20% bonus damage on bleeding targets for Maul and Shred
+            if ((_spec == BOT_SPEC_DRUID_FERAL) &&
+                lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) &&
+                (baseId == MAUL_1 || baseId == SHRED_1))
+                pctbonus += 0.2f;
+            //Glyph of Mangle: 10% bonus damage for Mangle (all)
+            if (lvl >= 50 && (baseId == MANGLE_BEAR_1 || baseId == MANGLE_CAT_1))
+                pctbonus += 0.1f;
+
+            //Primal Fury (yellow attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+            //Primal Fury (yellow attacks): 100% to gain 1 combo point at crit in Cat Form
+            if (_form == DRUID_BEAR_FORM && crit && lvl >= 25)
+                me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+            if (_form == DRUID_CAT_FORM &&
+                (baseId == CLAW_1 || baseId == MANGLE_CAT_1 || baseId == POUNCE_1 ||
+                baseId == RAKE_1 || baseId == RAVAGE_1 || baseId == SHRED_1))
+                const_cast<bot_druid_ai*>(this)->primalFuryProc = crit && lvl >= 25;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Nature's bounty: 25% additional critical chance for Regrowth and Nourish
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 35 && (baseId == REGROWTH_1 || baseId == NOURISH_1))
+                crit_chance += 25.f;
+            //Rend and Tear (part 2): 25% additional critical chance on bleeding targets for Ferocious Bite (handled in Unit.cpp)
+            //if (lvl >= 55 && victim->HasAuraState(AURA_STATE_BLEEDING) && baseId == FEROCIOUS_BITE_1)
+            //    crit_chance += 25.f;
+            //Improved Moonfire
+            if (lvl >= 15 && baseId == MOONFIRE_1)
+                crit_chance += 10.f;
+            //Nature's Majesty: 4% additional critical chance for Wrath, Starfire, Starfall, Nourish and Healing Touch
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x25) || (spellInfo->SpellFamilyFlags[1] & 0x2800000)))
+                crit_chance += 4.f;
+            //Eclipse (Lunar): 40% additional critical chance for Starfire
+            if (lvl >= 50 && baseId == STARFIRE_1 && me->HasAura(ECLIPSE_LUNAR_BUFF))
+                crit_chance += 40.f;
+            //Natural Perfection: 3% additional critical chance for all spells
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 40)
+                crit_chance += 3.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Vengeance: 100% additional crit damage bonus for Starfire, Starfall, Moonfire and Wrath
+                if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x7) || (spellInfo->SpellFamilyFlags[1] & 0x800000)))
+                    pctbonus += 0.333f;
+            }
+            //Genesis: 5% bonus damage for Dots
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x6002D2) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.05f;
+            //Improved Insect Swarm: SpellEffects.cpp, Unit.cpp
+            //Brambles: 75% bonus damage for Throns and Entangling Roots (Thorns are handled in Unit.cpp)
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x200))
+                pctbonus += 0.75f;
+            //Moonfury: 10% bonus damage for Starfire, Moonfire and Wrath
+            if (lvl >= 35 && (spellInfo->SpellFamilyFlags[0] & 0x7))
+                pctbonus += 0.1f;
+            //Glyph of Focus (part 1): 10% bonus damage for Starfall
+            if (lvl >= 70 && (spellInfo->SpellFamilyFlags[1] & 0x800000))
+                pctbonus += 0.1f;
+            //Wrath of Cenarius: 20%/10% Increased spellpower bonus for Starfire/Wrath
+            if ((_spec == BOT_SPEC_DRUID_BALANCE) && lvl >= 45)
+            {
+                if (baseId == STARFIRE_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+                if (baseId == WRATH_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+            //Eclipse (Solar): 40% bonus damage for Wrath
+            if (lvl >= 50 && baseId == WRATH_1 && me->HasAura(ECLIPSE_SOLAR_BUFF))
+                pctbonus += 0.4f;
+            //Gale Winds: 30% bonus damage for Hurricane and Typhoon
+            if ((_spec == BOT_SPEC_DRUID_BALANCE) &&
+                lvl >= 50 && ((spellInfo->SpellFamilyFlags[0] & 0x400000) || (spellInfo->SpellFamilyFlags[1] & 0x1000000)))
+                pctbonus += 0.3f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Genesis: 5% bonus healing for Hots
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x6002D2) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.05f;
+            //Improved Rejuvenation: 15% bonus healing for Rejuvenation
+            if (lvl >= 25 && baseId == REJUVENATION_1)
+                pctbonus += 0.15f;
+            //Improved Rejuvenation (17114,17115): 27% bonus healing for Rejuvenation
+            //if (baseId == REJUVENATION_1)
+            //    pctbonus += 0.27f;
+            //Gift of Nature: 10% bonus healing for all spells
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 30)
+                pctbonus += 0.1f;
+            //Empowered Touch: 40% bonus (from spellpower) for Healing Touch and 20% bonus (from spellpower) for Nourish
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 35)
+            {
+                if (baseId == HEALING_TOUCH_1)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+                else if (baseId == NOURISH_1)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Rejuvenation: 20% bonus healing for healing over time effects
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) &&
+                lvl >= 45 && ((spellInfo->SpellFamilyFlags[0] & 0xD0) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Clearcasting: -100% mana/rage/energy cost for any spell
+            if (AuraEffect const* eff = me->GetAuraEffect(OMEN_OF_CLARITY_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //percent mods
+            //Tree of Life Passive (5420) (activates when learned):
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) &&
+                lvl >= 50 && ((spellInfo->SpellFamilyFlags[0] & 0x50) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.5f;
+            //Glyph of the Wild:
+            if (lvl >= 15 && baseId == MARK_OF_THE_WILD_1)
+                pctbonus += 0.5f;
+            //Natural Shapeshifter:
+            if (lvl >= 15 &&
+                spellInfo->Effects[0].Effect == SPELL_EFFECT_APPLY_AURA &&
+                spellInfo->Effects[0].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
+                pctbonus += 0.3f;
+            //King of the Jungle part 3:
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0xC0000000))
+                pctbonus += 0.6f;
+            //Tranquil Spirit:
+            if (lvl >= 25 &&
+                (baseId == HEALING_TOUCH_1 || baseId == NOURISH_1 || baseId == TRANQUILITY_1))
+                pctbonus += 0.1f;
+            //Moonglow:
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x77) || (spellInfo->SpellFamilyFlags[1] & 0x2800000)))
+                pctbonus += 0.09f;
+            //Berserk part 2:
+            if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 60 && _form == DRUID_CAT_FORM &&
+                //((spellInfo->SpellFamilyFlags[0] & 0x839000) ||
+                //(spellInfo->SpellFamilyFlags[1] & 0x30000480) ||
+                //(spellInfo->SpellFamilyFlags[2] & 0x40420)) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Shredding Attacks:
+            if (lvl >= 25)
+            {
+                if (spellInfo->SpellFamilyFlags[0] & 0x8000)
+                    flatbonus += 18;
+                else if (spellInfo->SpellFamilyFlags[1] & 0x100)
+                    flatbonus += 20;
+            }
+            //Ferocity:
+            if (lvl >= 10)
+            {
+                if ((spellInfo->SpellFamilyFlags[0] & 0x800) || (spellInfo->SpellFamilyFlags[1] & 0x100040))
+                    flatbonus += 50;
+                else if ((spellInfo->SpellFamilyFlags[0] & 0x1000) ||
+                    (spellInfo->SpellFamilyFlags[1] & 0x400) ||
+                    (spellInfo->SpellFamilyFlags[2] & 0x40400))
+                    flatbonus += 5;
+            }
+            //Improved Mangle part 2:
+            if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 50 && (spellInfo->SpellFamilyFlags[1] & 0x400))
+                flatbonus += 6;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Elune's Wrath: -100% cast time for Starfire
+            AuraEffect const* elun = me->GetAuraEffect(ELUNES_WRATH_BUFF, 0);
+            //Predator's Swiftness: -100% cast time
+            AuraEffect const* pred = me->GetAuraEffect(PREDATORS_SWIFTNESS_BUFF, 0);
+            //Nature's Swiftness: -100% cast time
+            AuraEffect const* natu = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0);
+            if ((elun && elun->IsAffectedOnSpell(spellInfo)) ||
+                (pred && pred->IsAffectedOnSpell(spellInfo)) ||
+                (natu && natu->IsAffectedOnSpell(spellInfo)))
+                pctbonus += 1.0f;
+
+            //pct mods
+            //Celestial Focus: 3% haste
+            if (lvl >= 25)
+                pctbonus += 0.03f;
+
+            //flat mods
+            //Starlight Wrath: -0.5 sec cast time for Wrath and Starfire
+            if (lvl >= 10 && (baseId == WRATH_1 || baseId == STARFIRE_1))
+                timebonus += 500;
+            //Naturalist: -0.5 sec cast time for Healing Touch
+            if (lvl >= 15 && baseId == HEALING_TOUCH_1)
+                timebonus += 500;
+            //Regrowth bonus (ids:21872,46834): -0.2 x2 sec cast time for Regrowth
+            if (lvl >= 68 && baseId == REGROWTH_1)
+                timebonus += 400;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Improved Tranquility: -60% cooldown for Tanquility
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 30 && baseId == TRANQUILITY_1)
+                pctbonus += 0.6f;
+
+            //flat mods
+            //Glyph of Turn Evil: +8 sec cooldown for Turn Evil (3 sec for bots)
+            //if (lvl >= 24 && spellId == GetSpell(TURN_EVIL_1))
+            //    timebonus -= 3000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Dash: -20% cooldown for Dash
+            if (lvl >= 16 && baseId == DASH_1)
+                pctbonus += 0.2f;
+            //Berserk part 1:
+            if (lvl >= 60 && _form == DRUID_BEAR_FORM && (spellInfo->SpellFamilyFlags[1] & 0x40) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                pctbonus += 1.0f;
+
+            //flat mods
+            //Genesis Rebirth Bonus (26106): -5 min cooldown for Rebirth
+            if (baseId == REBIRTH_1)
+                timebonus += 300000;
+            //Improved Mangle part 1: -1.5 sec cooldown for Mangle (Bear)
+            if (lvl >= 50 && baseId == MANGLE_BEAR_1)
+                timebonus += 1500;
+            //Brutal Impact: -30 sec cooldown for Bash
+            if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 30 && baseId == BASH_1)
+                timebonus += 30000;
+            //Glyph of Typhoon: -3 sec cooldown for Typhoon
+            if (lvl >= 70 && baseId == TYPHOON_1)
+                timebonus += 3000;
+            //Starfall: increase cooldown for bots
+            if (baseId == STARFALL_1)
+                timebonus -= 90000; //x2
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct bonus
+            //Gift of the Earthmother part 2:
+            if (lvl >= 55 && baseId == LIFEBLOOM_1)
+                pctbonus += 0.1f;
+
+            //flat bonus
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Starfall
+            if (spellId == STARFALL_DUMMY_AOE_4)
+                flatbonus -= 10.f; //20 = 36 talented - 18 glyphed + 2 custom
+            if (spellId == STARFALL_DAMAGE_AOE_4)
+                flatbonus += 4.f; //5 nominal + 4 custom
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Nature's Reach: +20% range for Balance Spells and Faerie Fire (Feral)
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x600707) || (spellInfo->SpellFamilyFlags[1] & 0x1821220)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Curse of Exhaustion: +5 yd range for Curse of Exhaustion
+            //if (lvl >= 70 && baseId == CURSE_OF_EXHAUSTION_1)
+            //    flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Maul: + 1 target
+            if (spellInfo->SpellFamilyFlags[0] & 0x800)
+                bonusTargets += 1;
+            //Glyph of Wild Growth: + 1 target
+            if (spellInfo->SpellFamilyFlags[1] & 0x4000000)
+                bonusTargets += 1;
+            //Berserk: + 2 Mangle (Bear) targets
+            if ((spellInfo->SpellFamilyFlags[1] & 0x40) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                bonusTargets += 2;
+
+            targets = targets + bonusTargets;
+        }
+
+        void ApplyClassEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            //Improved Leader of the Pack: chance
+            if (baseId == LEADER_OF_THE_PACK_BUFF && effIndex == EFFECT_1)
+                value += 4.f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Nature's Swiftness: notify master
+            if (baseId == NATURES_SWIFTNESS_1)
+            {
+                BotWhisper("Nature's Swiftness used!");
+            }
+
+            //On next attack spells cooldown handle
+            //if (baseId == MAUL_1)
+            //    SetSpellCooldown(baseId, me->getAttackTimer(BASE_ATTACK) - 250);
+
+            //Handle clearcasting
+            //Notes: bugged with hurricane (periodic)
+            if (AuraEffect const* eff = me->GetAuraEffect(OMEN_OF_CLARITY_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo) && !spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(HURRICANE_DAMAGE_1)))
+                    me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF);
+
+            //Elune's Wrath: -100% takes priority since only Starfire
+            AuraEffect const* elun = me->GetAuraEffect(ELUNES_WRATH_BUFF, 0);
+            //Predator's Swiftness takes priority since duration
+            AuraEffect const* pred = me->GetAuraEffect(PREDATORS_SWIFTNESS_BUFF, 0);
+            //Nature's Swiftness
+            AuraEffect const* natu = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0);
+            if (elun && elun->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(ELUNES_WRATH_BUFF);
+            else if (pred && pred->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(PREDATORS_SWIFTNESS_BUFF);
+            else if (natu && natu->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (_form == DRUID_CAT_FORM)
+            {
+                //Combo point generating
+                if (baseId == CLAW_1 || baseId == MANGLE_CAT_1 || baseId == POUNCE_1 ||
+                    baseId == RAKE_1 || baseId == RAVAGE_1 || baseId == SHRED_1)
+                {
+                    comboPoints++;
+                    //debug
+                    //TC_LOG_ERROR("entities.player", "druid_bot CP GEN: %s adds 1, now %u", spell->SpellName[0], uint32(comboPoints));
+                    if (primalFuryProc)
+                    {
+                        comboPoints++;
+                        //debug
+                        //TC_LOG_ERROR("entities.player", "druid_bot CP EX: now %u", uint32(comboPoints));
+                    }
+                    if (comboPoints > 5)
+                    {
+                        comboPoints = 5;
+                        //debug
+                        //TC_LOG_ERROR("entities.player", "druid_bot CP NOR: now %u", uint32(comboPoints));
+                    }
+                }
+                //Combo point spending
+                //else if (baseId == FEROCIOUS_BITE_1 || baseId == MAIM_1 || baseId == RIP_1 || baseId == SAVAGE_ROAR_1)
+                else if (spell->NeedsComboPoints())
+                {
+                    //debug
+                    //TC_LOG_ERROR("entities.player", "druid_bot CP SPEND1: %u to 0", uint32(comboPoints));
+                    if (lvl >= 25 && comboPoints > 0)
+                    {
+                        if (urand(1,100) <= uint32(comboPoints * 20))
+                        {
+                            me->CastSpell(me, PREDATORS_SWIFTNESS_BUFF, true);
+                            //debug
+                            //TC_LOG_ERROR("entities.player", "druid_bot CP SPEND1: PS proc!");
+                        }
+                    }
+                    comboPoints = 0;
+                }
+
+                //Maim helper
+                if (baseId == MAIM_1)
+                    MoveBehind(target);
+            }
+
+            //Hibernate helper
+            if (spellId == GetSpell(HIBERNATE_1))
+            {
+                hibery = true;
+                hiberyCheckTimer = 2000;
+            }
+
+            //Bash desperate use (ranged): retreat
+            //Only if hit
+            if (baseId == BASH_1 && HasRole(BOT_ROLE_RANGED) && !HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+            {
+                //if (GC_Timer <= lastdiff && GetSpell(TRAVEL_FORM_1))
+                //    doCast(me, GetSpell(TRAVEL_FORM_1));
+                GetInPosition(true, target);
+            }
+
+            //Infected Wound: handle proc
+            if (baseId == SHRED_1 || baseId == MAUL_1 || baseId == MANGLE_BEAR_1 || baseId == MANGLE_CAT_1)
+            {
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 45)
+                {
+                    CastSpellExtraArgs args(true);
+                    args.SetOriginalCaster(me->GetGUID());
+                    target->CastSpell(target, INFECTED_WOUNDS_EFFECT, args);
+                }
+            }
+
+            //Brutal Impact: +1 sec duration for Bash and Pounce stun
+            if (baseId == BASH_1 || baseId == POUNCE_1)
+            {
+                if (Aura* stu = target->GetAura(spellId))
+                {
+                    //1 extra second on creatures
+                    uint32 dur = stu->GetDuration() + target->GetTypeId() == TYPEID_PLAYER ? 1000 : 2000;
+                    stu->SetDuration(dur);
+                    stu->SetMaxDuration(dur);
+                }
+            }
+
+            //Glyph of Starfire: Increase max duration of Moonfire and refresh
+            if (baseId == STARFIRE_1 && GetSpell(MOONFIRE_1))
+            {
+                if (lvl >= 20)
+                {
+                    if (Aura* aur = target->GetAura(GetSpell(MOONFIRE_1), me->GetGUID()))
+                    {
+                        //extra 9 sec base + 3 sec Nature's Splendor
+                        if (aur->GetMaxDuration() < spell->GetMaxDuration() + 12000)
+                        {
+                            aur->SetDuration(aur->GetDuration() + 3000);
+                            aur->SetMaxDuration(aur->GetMaxDuration() + 3000);
+                        }
+                    }
+                }
+            }
+            //Nature's Splendor: Increased duraion for
+            //Moonfire (3 sec), Rejuvenation (3 sec, let 6), Regrowth (6 sec, let 9),
+            //Insect Swarm (2 sec) and Lifebloom (2 sec)
+            if (baseId == MOONFIRE_1 || baseId == REJUVENATION_1 || baseId == REGROWTH_1 ||
+                baseId == INSECT_SWARM_1 || baseId == LIFEBLOOM_1)
+            {
+                if (lvl >= 20)
+                {
+                    if (Aura* aur = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = aur->GetDuration();
+
+                        switch (baseId)
+                        {
+                            case MOONFIRE_1:
+                                dur += 3000;
+                                break;
+                            case REJUVENATION_1:
+                                dur += 6000;
+                                break;
+                            case REGROWTH_1:
+                                dur += 9000;
+                                break;
+                            case INSECT_SWARM_1:
+                            case LIFEBLOOM_1:
+                                dur += 2000;
+                                break;
+                            default:
+                                break;
+                        }
+
+                        aur->SetDuration(dur);
+                        aur->SetMaxDuration(dur);
+                    }
+                }
+            }
+
+            if (baseId == THORNS_1)
+            {
+                //30 min duration for Thorns
+                if (Aura* thorn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 30 * MINUTE * IN_MILLISECONDS;
+                    thorn->SetDuration(dur);
+                    thorn->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == MARK_OF_THE_WILD_1)
+            {
+                //1 hour duration for Mark of the Wild
+                if (Aura* mark = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    mark->SetDuration(dur);
+                    mark->SetMaxDuration(dur);
+
+                    //Improved Mark of the Wild: +40% effect
+                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        if (AuraEffect* app = mark->GetEffect(i))
+                            app->ChangeAmount((app->GetAmount() * 14) / 10);
+                }
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Savage Roar duration
+            if (spellId == SAVAGE_ROAR_BUFF || spellId == SAVAGE_ROAR_1)
+            {
+                if (Aura* sav = me->GetAura(spellId))
+                {
+                    uint32 dur = sav->GetDuration() + 6000;
+                    sav->SetDuration(dur);
+                    sav->SetMaxDuration(dur);
+                }
+                //Glyph of Savage Roar: 3% increase (20 for bot)
+                if (spellId == SAVAGE_ROAR_BUFF)
+                {
+                    AuraEffect* sav = me->GetAuraEffect(spellId, EFFECT_0);
+                    if (sav)
+                        sav->ChangeAmount(sav->GetAmount() + 20);
+                }
+            }
+
+            //Glyph of Berserk: duration
+            if (baseId == BERSERK_1)
+            {
+                if (Aura* ber = me->GetAura(spellId))
+                {
+                    uint32 dur = ber->GetDuration() + 5000;
+                    ber->SetDuration(dur);
+                    ber->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Survival Instincts
+            if (lvl >= 20 && spellId == SURVIVAL_INSTINCTS_1)
+            {
+                AuraEffect* sur = me->GetAuraEffect(spellId, EFFECT_0);
+                if (sur)
+                    sur->ChangeAmount(sur->GetAmount() + 15);
+            }
+            //Starfall: duration
+            if (baseId == STARFALL_1)
+            {
+                if (Aura* sta = me->GetAura(spellId))
+                {
+                    uint32 dur = sta->GetDuration() * 3;
+                    sta->SetDuration(dur);
+                    sta->SetMaxDuration(dur);
+                }
+            }
+            //Predatoe's Swiftness: duration
+            if (spellId == PREDATORS_SWIFTNESS_BUFF)
+            {
+                if (Aura* swi = me->GetAura(spellId))
+                {
+                    swi->SetDuration(15000);
+                    swi->SetMaxDuration(15000);
+                }
+            }
+            //Eclipse (helper): cooldown
+            if (spellId == ECLIPSE_SOLAR_BUFF || spellId == ECLIPSE_LUNAR_BUFF)
+                SetSpellCooldown(spellId, 30000);
+            //Improved Leader of the Pack: handle SPELLMOD_EFFECT_2 MOVED to effect mods
+            /*
+            if (spellId == LEADER_OF_THE_PACK_BUFF)
+            {
+                AuraEffect* lea = me->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                if (lea)
+                    lea->ChangeAmount(lea->GetAmount() + 4);
+            }
+            */
+            //Improved Barkskin: 10% additional damage reduction
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && baseId == BARKSKIN_1)
+            {
+                AuraEffect* bar = me->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                if (bar)
+                    bar->ChangeAmount(bar->GetAmount() - 10);
+            }
+
+            //Forms helper
+            if (baseId == BEAR_FORM_1)
+                setStats(DRUID_BEAR_FORM);
+            else if (baseId == CAT_FORM_1)
+                setStats(DRUID_CAT_FORM);
+            else if (baseId == MOONKIN_FORM_1)
+                setStats(DRUID_MOONKIN_FORM);
+            else if (baseId == TREE_OF_LIFE_FORM_1)
+                setStats(DRUID_TREE_FORM);
+            else if (baseId == TRAVEL_FORM_1)
+                setStats(DRUID_TRAVEL_FORM);
+            else if (baseId == AQUATIC_FORM_1)
+                setStats(DRUID_AQUATIC_FORM);
+            //else if (baseId == FLIGHT_FORM_1)
+            //    setStats(DRUID_FLIGHT_FORM);
+
+            //Cat Form: delay prowl just a little bit
+            if (baseId == CAT_FORM_1 && GetSpell(PROWL_1) && GetSpellCooldown(PROWL_1) < 300)
+                SetSpellCooldown(PROWL_1, 300);
+
+            //Leader of the Pack helper
+            if (baseId == CAT_FORM_1 || baseId == BEAR_FORM_1)
+            {
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 40)
+                    me->CastSpell(me, LEADER_OF_THE_PACK_BUFF, true);
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(WRATH_1) : 20.f;
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                if (_treants[i] == summon->GetGUID())
+                    return i;
+
+            return 0;
+        }
+
+        void SummonBotPet(Unit* target)
+        {
+            //if (botPet)
+            //    UnsummonAll();
+
+            uint32 entry = BOT_PET_FORCE_OF_NATURE;
+
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+            {
+                //Position pos;
+
+                //30 sec duration
+                Creature* myPet = me->SummonCreature(entry, (me->GetDistance(target) < 36.f ? *target : *me), TEMPSUMMON_MANUAL_DESPAWN);
+                //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+                //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+                myPet->SetCreatorGUID(master->GetGUID());
+                myPet->SetOwnerGUID(me->GetGUID());
+                myPet->SetFaction(master->GetFaction());
+                myPet->SetControlledByPlayer(!IAmFree());
+                myPet->SetPvP(me->IsPvP());
+                myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+                myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+                myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, FORCE_OF_NATURE_1);
+                //botPet = myPet;
+
+                myPet->Attack(target, true);
+                if (!HasBotCommandState(BOT_COMMAND_STAY))
+                    myPet->GetMotionMaster()->MoveChase(target);
+            }
+        }
+
+        void JustSummoned(Creature* summon) override
+        {
+            if (summon->GetEntry() == BOT_PET_FORCE_OF_NATURE)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                {
+                    if (!_treants[i])
+                    {
+                        _treants[i] = summon->GetGUID();
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Druid_bot:JustSummoned() treants array is full");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+            if (summon->GetEntry() == BOT_PET_FORCE_OF_NATURE)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                {
+                    if (_treants[i] == summon->GetGUID())
+                    {
+                        _treants[i] = ObjectGuid::Empty;
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Druid_bot:SummonedCreatureDespawn() treant is not found in array");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void UnsummonAll() override
+        {
+            //if (botPet)
+            //    botPet->ToTempSummon()->UnSummon();
+
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+            {
+                if (_treants[i])
+                    if (Unit* tr = ObjectAccessor::GetUnit(*me, _treants[i]))
+                        tr->ToTempSummon()->UnSummon();
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_COMBO_POINTS:
+                    return comboPoints;
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_FORCE_OF_NATURE;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                _treants[i] = ObjectGuid::Empty;
+
+            //_form = BOT_STANCE_NONE;
+            rage = 0;
+            removeShapeshiftForm();
+
+            energy = 0;
+            comboPoints = 0;
+            primalFuryProc = false;
+
+            hibery = false;
+            hiberyCheckTimer = 0;
+
+            me->SetMaxPower(POWER_ENERGY, 100); //for regeneration
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (ragetimer > diff)                   ragetimer -= diff;
+
+            if (hiberyCheckTimer > diff)            hiberyCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            switch (me->GetShapeshiftForm())
+            {
+                case FORM_BEAR:
+                case FORM_DIREBEAR:
+                    me->SetPowerType(POWER_RAGE);
+                    break;
+                case FORM_CAT:
+                    me->SetPowerType(POWER_ENERGY);
+                    break;
+                default:
+                    me->SetPowerType(POWER_MANA);
+                    break;
+            }
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isBala = _spec == BOT_SPEC_DRUID_BALANCE;
+            bool isFera = _spec == BOT_SPEC_DRUID_FERAL;
+            bool isRest = _spec == BOT_SPEC_DRUID_RESTORATION;
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(MAUL_1);
+            InitSpellMap(CHALLENGING_ROAR_1);
+            InitSpellMap(ENRAGE_1);
+            InitSpellMap(FRENZIED_REGENERATION_1);
+            InitSpellMap(GROWL_1);
+            InitSpellMap(LACERATE_1);
+            InitSpellMap(SURVIVAL_INSTINCTS_1);
+            InitSpellMap(FAERIE_FIRE_FERAL_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+            InitSpellMap(POUNCE_1);
+            InitSpellMap(RAVAGE_1);
+            InitSpellMap(RIP_1);
+            InitSpellMap(FEROCIOUS_BITE_1);
+            InitSpellMap(MAIM_1);
+            InitSpellMap(SWIPE_CAT_1);
+            InitSpellMap(SAVAGE_ROAR_1);
+            InitSpellMap(TIGERS_FURY_1);
+            InitSpellMap(COWER_1);
+            InitSpellMap(DASH_1);
+  /*custom*/lvl >= 22 ? InitSpellMap(PROWL_1) : RemoveSpell(PROWL_1); //base lvl 20
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_NORMAL_1);
+            InitSpellMap(TRAVEL_FORM_1);
+            InitSpellMap(AQUATIC_FORM_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(ABOLISH_POISON_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+            InitSpellMap(CYCLONE_1);
+            InitSpellMap(HIBERNATE_1);
+            InitSpellMap(BARKSKIN_1);
+            InitSpellMap(NATURES_GRASP_1);
+            InitSpellMap(INNERVATE_1);
+
+     /*tal*/lvl >= 30 && isBala ? InitSpellMap(INSECT_SWARM_1) : RemoveSpell(INSECT_SWARM_1);
+     /*tal*/lvl >= 40 && isBala ? InitSpellMap(MOONKIN_FORM_1) : RemoveSpell(MOONKIN_FORM_1);
+     /*tal*/lvl >= 50 && isBala ? InitSpellMap(TYPHOON_1) : RemoveSpell(TYPHOON_1);
+     /*tal*/lvl >= 50 && isBala ? InitSpellMap(FORCE_OF_NATURE_1) : RemoveSpell(FORCE_OF_NATURE_1); //not casted
+     /*tal*/lvl >= 60 && isBala ? InitSpellMap(STARFALL_1) : RemoveSpell(STARFALL_1);
+
+     /*tal*/lvl >= 30 && isFera ? InitSpellMap(FERAL_CHARGE_BEAR_1) : RemoveSpell(FERAL_CHARGE_BEAR_1);
+     /*tal*/lvl >= 30 && isFera ? InitSpellMap(FERAL_CHARGE_CAT_1) : RemoveSpell(FERAL_CHARGE_CAT_1);;
+     /*tal*/lvl >= 50 && isFera ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+     /*tal*/lvl >= 50 && isFera ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+     /*tal*/lvl >= 60 && isFera ? InitSpellMap(BERSERK_1) : RemoveSpell(BERSERK_1);
+
+     /*tal*/lvl >= 30 && isRest ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+     /*tal*/lvl >= 40 && isRest ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+     /*tal*/lvl >= 50 && isRest ? InitSpellMap(TREE_OF_LIFE_FORM_1) : RemoveSpell(TREE_OF_LIFE_FORM_1);
+     /*tal*/lvl >= 60 && isRest ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isBala = _spec == BOT_SPEC_DRUID_BALANCE;
+            bool isFera = _spec == BOT_SPEC_DRUID_FERAL;
+            bool isRest = _spec == BOT_SPEC_DRUID_RESTORATION;
+
+            RefreshAura(NATURESGRACE, level >= 20 ? 1 : 0);
+            RefreshAura(DREAMSTATE, isBala && level >= 35 ? 1 : 0);
+            RefreshAura(BALANCE_OF_POWER, isBala && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_MOONKIN_FORM, isBala && level >= 40 ? 1 : 0);
+            RefreshAura(ECLIPSE, isBala && level >= 50 ? 1 : 0);
+            RefreshAura(EARTH_AND_MOON, isBala && level >= 55 ? 1 : 0);
+
+            RefreshAura(PRIMAL_PRECISION, isFera && level >= 25 ? 1 : 0);
+            RefreshAura(SURVIVAL_OF_THE_FITTEST, isFera && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_LEADER_OF_THE_PACK, isFera && level >= 40 ? 1 : 0);
+            RefreshAura(PRIMAL_TENACITY, isFera && level >= 40 ? 1 : 0);
+            RefreshAura(KING_OF_THE_JUNGLE, isFera && level >= 50 ? 1 : 0);
+            RefreshAura(PRIMAL_GORE, isFera && level >= 55 ? 1 : 0);
+
+            RefreshAura(IMPROVED_MARK_OF_THE_WILD, level >= 10 ? 1 : 0);
+            RefreshAura(FUROR, level >= 10 ? 1 : 0);
+            RefreshAura(NATURALIST, level >= 15 ? 1 : 0);
+            RefreshAura(INTENSITY, level >= 20 ? 1 : 0);
+            RefreshAura(OMEN_OF_CLARITY, level >= 20 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION3, isRest && level >= 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION2, isRest && level >= 43 && level < 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION1, isRest && level >= 41 && level < 43 ? 1 : 0);
+            RefreshAura(LIVING_SEED3, isRest && level >= 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED2, isRest && level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED1, isRest && level >= 46 && level < 48 ? 1 : 0);
+            RefreshAura(REVITALIZE3, isRest && level >= 55 ? 1 : 0);
+            RefreshAura(REVITALIZE2, isRest && level >= 53 && level < 55 ? 1 : 0);
+            RefreshAura(REVITALIZE1, isRest && level >= 51 && level < 53 ? 1 : 0);
+            RefreshAura(GIFT_OF_THE_EARTHMOTHER, isRest && level >= 55 ? 1 : 0);
+
+            RefreshAura(GLYPH_NOURISH, level >= 80 ? 1 : 0);
+            RefreshAura(GLYPH_SWIFTMEND, level >= 45 ? 1 : 0);
+            RefreshAura(GLYPH_INNERVATE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_RAPID_REJUVENATION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REGROWTH, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REJUVENATION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_FRENZIED_REGENERATION, level >= 36 ? 1 : 0);
+            RefreshAura(GLYPH_BARKSKIN, level >= 44 ? 1 : 0);
+            RefreshAura(GLYPH_RAKE, level >= 24 ? 1 : 0);
+            RefreshAura(GLYPH_SHRED, level >= 22 ? 1 : 0);
+            RefreshAura(T10_RESTO_P4_BONUS, level >= 80 ? 1 : 0);
+            RefreshAura(T9_RESTO_P4_BONUS, level >= 80 ? 1 : 0);
+            RefreshAura(T8_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T9_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T8_FERAL_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_FERAL_P4_BONUS, level >= 80 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case HURRICANE_1:
+                case INNERVATE_1:
+                case ABOLISH_POISON_1:
+                case NATURES_GRASP_1:
+                case BARKSKIN_1:
+                case BEAR_FORM_1:
+                case CAT_FORM_1:
+                case TRAVEL_FORM_1:
+                    return true;
+                case AQUATIC_FORM_1:
+                    return me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && me->IsUnderWater();
+                case TYPHOON_1:
+                case STARFALL_1:
+                case MOONKIN_FORM_1:
+                    return (GetBotRoles() & BOT_ROLE_MASK_MAIN) == (BOT_ROLE_DPS|BOT_ROLE_RANGED);
+                case TREE_OF_LIFE_FORM_1:
+                    return ((GetBotRoles() & BOT_ROLE_MASK_MAIN) & ~BOT_ROLE_RANGED) == BOT_ROLE_HEAL;
+                case SURVIVAL_INSTINCTS_1:
+                case FRENZIED_REGENERATION_1:
+                case ENRAGE_1:
+                case CHALLENGING_ROAR_1:
+                    return _form == DRUID_BEAR_FORM;
+                case TIGERS_FURY_1:
+                case DASH_1:
+                case PROWL_1:
+                    return _form == DRUID_CAT_FORM;
+                case BERSERK_1:
+                    return (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM) &&
+                        (((GetBotRoles() & BOT_ROLE_MASK_MAIN) & BOT_ROLE_TANK) || (GetBotRoles() & BOT_ROLE_MASK_MAIN) == BOT_ROLE_DPS);
+                default:
+                    return false;
+            }
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, NOURISH_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, NOURISH_1));
+                _heals[NOURISH_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[NOURISH_1] = 0;
+
+            if (InitSpell(me, REGROWTH_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, REGROWTH_1));
+                _heals[REGROWTH_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[REGROWTH_1] = 0;
+
+            if (InitSpell(me, HEALING_TOUCH_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HEALING_TOUCH_1));
+                _heals[HEALING_TOUCH_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[HEALING_TOUCH_1] = 0;
+
+            if (InitSpell(me, REJUVENATION_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, REJUVENATION_1));
+                _heals[REJUVENATION_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), DOT, 0, {});
+            }
+            else
+                _heals[REJUVENATION_1] = 0;
+        }
+
+    private:
+        //Treants
+        ObjectGuid _treants[MAX_TREANTS];
+        //Timers/other
+/*Form*/BotStances _form;
+/*Misc*/bool primalFuryProc;
+/*Misc*/uint8 comboPoints;
+/*Misc*/uint32 ragetimer;
+        bool hibery;
+        uint32 hiberyCheckTimer;
+/*Misc*/int32 rage, energy;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..02c0b8f
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,2331 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Hunter NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - around 95%
+TODO: Master's Call
+*/
+
+enum HunterBaseSpells
+{
+    AUTO_SHOT_1                         = 75,
+    ARCANE_SHOT_1                       = 3044,
+    TRANQ_SHOT_1                        = 19801,
+    BLACK_ARROW_1                       = 3674,
+    SILENCING_SHOT_1                    = 34490,
+    CHIMERA_SHOT_1                      = 53209,
+    AIMED_SHOT_1                        = 19434,
+    STEADY_SHOT_1                       = 56641,
+    EXPLOSIVE_SHOT_1                    = 53301,
+    KILL_SHOT_1                         = 53351,
+    MULTISHOT_1                         = 2643,
+    VOLLEY_1                            = 1510,
+    SCATTER_SHOT_1                      = 19503,
+    CONCUSSIVE_SHOT_1                   = 5116,
+    DISTRACTING_SHOT_1                  = 20736,
+    SERPENT_STING_1                     = 1978,
+    SCORPID_STING_1                     = 3043,
+    VIPER_STING_1                       = 3034,
+    RAPID_FIRE_1                        = 3045,
+    FLARE_1                             = 1543,
+    TRUESHOT_AURA_1                     = 19506,
+    WYVERN_STING_1                      = 19386,
+    WING_CLIP_1                         = 2974,
+    RAPTOR_STRIKE_1                     = 2973,
+    MONGOOSE_BITE_1                     = 1495,
+    COUNTERATTACK_1                     = 19306,
+    DISENGAGE_1                         = 781,
+    IMMOLATION_TRAP_1                   = 13795,
+    FREEZING_TRAP_1                     = 1499,
+    FROST_TRAP_1                        = 13809,
+    EXPLOSIVE_TRAP_1                    = 13813,
+    FREEZING_ARROW_1                    = 60192,
+    SNAKE_TRAP_1                        = 34600,//NIY
+    HUNTERS_MARK_1                      = 1130,
+    SCARE_BEAST_1                       = 1513,
+    FEIGN_DEATH_1                       = 5384,
+    READINESS_1                         = 23989,
+    DETERRENCE_1                        = 19263,
+    MISDIRECTION_1                      = 34477,
+    MEND_PET_1                          = 136,
+
+    ASPECT_OF_THE_MONKEY_1              = 13163,
+    ASPECT_OF_THE_HAWK_1                = 13165,
+    ASPECT_OF_THE_CHEETAH_1             = 5118,
+    ASPECT_OF_THE_VIPER_1               = 34074,
+    ASPECT_OF_THE_BEAST_1               = 13161,//NIY
+    ASPECT_OF_THE_PACK_1                = 13159,
+    ASPECT_OF_THE_WILD_1                = 20043,
+    ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+};
+
+enum HunterPassives
+{
+//Talents
+    SUREFOOTED                          = 24283,//rank 3
+    ENTRAPMENT                          = 19388,//rank 3
+    RAPID_KILLING                       = 34949,//rank 2
+    IMPROVED_MEND_PET                   = 19573,//rank 2
+    LOCK_AND_LOAD                       = 56344,//rank 3
+    CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+    PIERCING_SHOTS                      = 53238,//rank 3
+    EXPOSE_WEAKNESS                     = 34503,//rank 3
+    THRILL_OF_THE_HUNT                  = 34499,//rank 3
+    MASTER_MARKSMAN                     = 34489,//rank 5
+    MASTER_TACTICIAN1                   = 34506,
+    MASTER_TACTICIAN2                   = 34507,
+    MASTER_TACTICIAN3                   = 34508,
+    MASTER_TACTICIAN4                   = 34838,
+    MASTER_TACTICIAN5                   = 34839,
+    NOXIOUS_STINGS                      = 53297,//rank 3
+    WILD_QUIVER                         = 53217,//rank 3
+    SNIPER_TRAINING                     = 53304,//rank 3
+
+    GLYPH_RAPTOR_STRIKE                 = 63086,
+    GLYPH_ASPECT_OF_THE_VIPER           = 56851,
+    GLYPH_FREEZING_TRAP                 = 56845,
+    GLYPH_EXPLOSIVE_TRAP                = 63068,
+
+    HUNTER_T8_P2                        = 67150,//serpent sting crits
+    HUNTER_T10_P2                       = 70727,//autoshot 15% dmg proc
+    HUNTER_T10_P4                       = 70730 //sting 20% ap proc
+};
+
+enum HunterSpecial
+{
+    ASPECT_NONE                         = 0,
+    ASPECT_MONKEY                       = 1,
+    ASPECT_HAWK                         = 2,
+    ASPECT_CHEETAH                      = 3,
+    ASPECT_VIPER                        = 4,
+    ASPECT_BEAST                        = 5,
+    ASPECT_PACK                         = 6,
+    ASPECT_WILD                         = 7,
+    ASPECT_DRAGONHAWK                   = 8,
+
+    SPECIFIC_ASPECT_MONKEY              = 0x001,
+    SPECIFIC_ASPECT_HAWK                = 0x002,
+    SPECIFIC_ASPECT_CHEETAH             = 0x004,
+    SPECIFIC_ASPECT_VIPER               = 0x008,
+    SPECIFIC_ASPECT_BEAST               = 0x010,
+    SPECIFIC_ASPECT_PACK                = 0x020,
+    SPECIFIC_ASPECT_WILD                = 0x040,
+    SPECIFIC_ASPECT_DRAGONHAWK          = 0x080,
+    SPECIFIC_ASPECT_MY_ASPECT           = 0x100,
+    //SPECIFIC_ASPECT_ALL_AREA_AUTOUSE    = (SPECIFIC_ASPECT_PACK),
+
+    IMPROVED_CONCUSSION                 = 28445,
+    IMPROVED_WING_CLIP_NORMAL           = 47168,
+    IMPROVED_WING_CLIP_EX               = 35963,
+
+    VOLLEY_DAMAGE_1                     = 42243,//rank 1
+    //EXPLOSIVE_TRAP_DAMAGE_1             = 13812,//same as EXPLOSIVE_TRAP_AURA_1
+
+    QUICK_SHOTS_BUFF                    = 6150,
+    RAPID_KILLING_BUFF                  = 35099,//rank 2
+    LOCK_AND_LOAD_BUFF                  = 56453,//rank 3
+    SNIPER_TRAINING_BUFF                = 64420,//rank 3
+    RAPID_RECUPERATION_BUFF             = 54227,//rank 2, rapid fire, hidden
+    RAPID_RECUPERATION_BUFF2            = 58882,//rapid killing, 6 sec
+    IMPROVED_STEADY_SHOT_BUFF           = 53220,
+
+    FROST_TRAP_AURA                     = 13810,
+    FREEZING_TRAP_AURA_1                = 3355,
+    IMMOLATION_TRAP_AURA_1              = 13797,
+    EXPLOSIVE_TRAP_AURA_1               = 13812,//same as EXPLOSIVE_TRAP_DAMAGE_1
+    WYVERN_STING_DOT_AURA_1             = 24131,
+    FREEZING_ARROW_AURA                 = 60210,
+    EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA  = 53352,
+
+    ASPECT_OF_THE_DRAGONHAWK_MONKEY     = 61848, //linked, hidden
+
+    GLYPH_OF_ARCANE_SHOT_ENERGIZE       = 61389,
+    RAPID_RECUPERATION_ENERGIZE         = 58883,//rapid killing
+    RAPID_RECUPERATION_ENERGIZE_PCT_1   = 64180,//rank 1, 2%
+
+    GIFT_OF_NAARU_HUNTER                = 59543,
+
+    SPIRIT_BOND_PET                     = 24529,
+    KINDRED_SPIRITS_PET                 = 57475,
+    //INTIMIDATION_1                      = 24394,
+    BESTIAL_WRATH_1                     = 19574,
+    //BEAST_WITHIN_1                      = 34471,
+
+    GO_FOR_THE_THROAT_ENERGIZE          = 34953,
+    FRENZY_BUFF                         = 19615
+};
+//talent tiers 20-32-44-56-68-80
+
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct hunter_botAI : public bot_ai
+    {
+        hunter_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_HUNTER;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { aspectTimer = 0; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { Aspect = 0; UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAspects(uint32 diff)
+        {
+            if (aspectTimer > diff || me->IsMounted() || Feasting() || IsCasting() || Rand() > 55)
+                return;
+
+            aspectTimer = urand(5000, 10000);
+
+            if (Aspect == ASPECT_VIPER && GetManaPCT(me) < 50)
+                return;
+
+            uint32 ASPECT_OF_THE_MONKEY = GetSpell(ASPECT_OF_THE_MONKEY_1);
+            uint32 ASPECT_OF_THE_HAWK = GetSpell(ASPECT_OF_THE_HAWK_1);
+            uint32 ASPECT_OF_THE_CHEETAH = GetSpell(ASPECT_OF_THE_CHEETAH_1);
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            //uint32 ASPECT_OF_THE_BEAST = GetSpell(ASPECT_OF_THE_BEAST_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            uint32 ASPECT_OF_THE_WILD = GetSpell(ASPECT_OF_THE_WILD_1);
+            uint32 ASPECT_OF_THE_DRAGONHAWK = GetSpell(ASPECT_OF_THE_DRAGONHAWK_1);
+
+            std::map<uint32 /*baseid*/, uint32 /*curid*/> idMap;
+            uint32 mask = _getAspectsMask(idMap);
+
+            if (Aspect == ASPECT_WILD) //manual
+            {
+                if (idMap[ASPECT_OF_THE_WILD_1] != ASPECT_OF_THE_WILD)
+                    if (doCast(me, ASPECT_OF_THE_WILD))
+                        return;
+                return;
+            }
+
+            if (ASPECT_OF_THE_VIPER && GetManaPCT(me) < 20)
+            {
+                if (doCast(me, ASPECT_OF_THE_VIPER))
+                    return;
+                return;
+            }
+
+            if (IAmFree())
+            {
+                if (ASPECT_OF_THE_DRAGONHAWK && Aspect != ASPECT_DRAGONHAWK)
+                    if (doCast(me, ASPECT_OF_THE_DRAGONHAWK))
+                        return;
+                return;
+            }
+
+            //Group const* gr = master->GetGroup();
+            //choose movement aspect first
+            if (!master->GetBotMgr()->IsPartyInCombat())
+            {
+                if (!(mask & SPECIFIC_ASPECT_PACK))
+                {
+                    uint32 movFlags;
+                    if (ASPECT_OF_THE_PACK)
+                    {
+                        movFlags = master->m_movementInfo.GetMovementFlags();
+                        if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)))
+                        {
+                            if (doCast(me, ASPECT_OF_THE_PACK))
+                                return;
+                        }
+                    }
+                    if (ASPECT_OF_THE_CHEETAH && Aspect != ASPECT_CHEETAH)
+                    {
+                        movFlags = me->m_movementInfo.GetMovementFlags();
+                        if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)) &&
+                            me->GetDistance(master) > 20)
+                        {
+                            if (doCast(me, ASPECT_OF_THE_CHEETAH))
+                                return;
+                        }
+                    }
+                }
+
+                return;
+            }
+            else if (Aspect == ASPECT_PACK)
+            {
+                me->RemoveAurasDueToSpell(ASPECT_OF_THE_PACK_1, me->GetGUID());
+                Aspect = ASPECT_NONE;
+            }
+            //else if (Aspect == ASPECT_CHEETAH)
+            //{
+            //    me->RemoveAurasDueToSpell(ASPECT_OF_THE_CHEETAH_1, me->GetGUID());
+            //    Aspect = ASPECT_NONE;
+            //}
+
+            if ((Aspect == ASPECT_DRAGONHAWK && idMap[ASPECT_OF_THE_DRAGONHAWK_1] == ASPECT_OF_THE_DRAGONHAWK) ||
+                (!ASPECT_OF_THE_DRAGONHAWK && ((Aspect == ASPECT_HAWK && idMap[ASPECT_OF_THE_HAWK_1] == ASPECT_OF_THE_HAWK) ||
+                Aspect == ASPECT_MONKEY)))
+                return;
+
+            if (ASPECT_OF_THE_DRAGONHAWK &&
+                (Aspect != ASPECT_DRAGONHAWK || idMap[ASPECT_OF_THE_DRAGONHAWK_1] != ASPECT_OF_THE_DRAGONHAWK))
+            {
+                if (doCast(me, ASPECT_OF_THE_DRAGONHAWK))
+                    return;
+                return;
+            }
+            if (ASPECT_OF_THE_HAWK && (!IsTank() || (!ASPECT_OF_THE_MONKEY && !ASPECT_OF_THE_DRAGONHAWK)) &&
+                (Aspect != ASPECT_HAWK || idMap[ASPECT_OF_THE_HAWK_1] != ASPECT_OF_THE_HAWK))
+            {
+                if (doCast(me, ASPECT_OF_THE_HAWK))
+                    return;
+                return;
+            }
+            if (ASPECT_OF_THE_MONKEY && Aspect != ASPECT_MONKEY)
+            {
+                if (doCast(me, ASPECT_OF_THE_MONKEY))
+                    return;
+                return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = nullptr;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(SCATTER_SHOT_1), 0, SCATTER_SHOT_1);
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(WYVERN_STING_1), 5, WYVERN_STING_1);
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+            //if (!target && IsSpellReady(FREEZING_ARROW_1, diff))
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW_1);
+            //    if (target && doCast(target, GetSpell(FREEZING_ARROW_1)))
+            //        return;
+            //}
+            //if (!target && IsSpellReady(SCARE_BEAST_1, diff))
+            //{
+            //    target = FindCastingTarget(30, 0, SCARE_BEAST_1);
+            //    if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+            //        return;
+            //}
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(SILENCING_SHOT_1), 5, SILENCING_SHOT_1);
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+
+            if (opponent->GetVictim() == me && opponent->GetDistance(me) < 10 &&
+                !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && opponent->getAttackers().size() <= 1)
+            {
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GetInPosition(true, nullptr);
+                    return;
+                }
+            }
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(SCATTER_SHOT_1)))
+            {
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(WYVERN_STING_1)))
+            {
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with frosty traps
+            if (!IsSpellReady(FREEZING_ARROW_1, diff) || Rand() > 35)
+                return;
+
+            if (Unit* target = FindStunTarget(25))
+            {
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                    return;
+            }
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (trapTimer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            trapTimer = urand(1000, 2000);
+
+            //trap summon spell is 2yd radius
+            std::list<Unit*> targets;
+            GetNearbyTargetsInConeList(targets, 4);
+            if (targets.empty())
+                return;
+
+            //frost trap, freezing trap, freezing arrow: cat 411
+            if (IsSpellReady(FROST_TRAP_1, diff) && !IsTank())
+            {
+                //uint8 movingCount = 0;
+                //for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                //{
+                //    if ((*itr)->isMoving() || ((*itr)->GetVictim() && !IsTank((*itr)->GetVictim())))
+                //    {
+                //        if (++movingCount >= 2)
+                        //if (targets.size() > 1)
+                //        {
+                            if (doCast(me, GetSpell(FROST_TRAP_1)))
+                                return;
+                //            break;
+                //        }
+                //    }
+                //}
+            }
+            //only if taming beast (or manual)
+            if (IsSpellReady(FREEZING_TRAP_1, diff) && !HasRole(BOT_ROLE_DPS) && !IAmFree() &&
+                master->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_GENERIC, 255, 2))
+            {
+                if (doCast(me, GetSpell(FREEZING_TRAP_1)))
+                    return;
+            }
+            //black arrow, immolation trap, explosive trap: cat 1250
+            if (IsSpellReady(EXPLOSIVE_TRAP_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (targets.size() > 1)
+                {
+                    if (doCast(me, GetSpell(EXPLOSIVE_TRAP_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(IMMOLATION_TRAP_1, diff) && HasRole(BOT_ROLE_DPS) && !(*targets.begin())->IsControlledByPlayer())
+            {
+                if (targets.size() > 1)
+                {
+                    if (doCast(me, GetSpell(IMMOLATION_TRAP_1)))
+                        return;
+                }
+            }
+            //snake trap: cat 1249
+            //if (IsSpellReady(SNAKE_TRAP_1, diff) && HasRole(BOT_ROLE_DPS) && (*targets.begin())->IsControlledByPlayer())
+            //{
+            //    if (doCast(me, GetSpell(SNAKE_TRAP_1)))
+            //        return;
+            //}
+        }
+
+        void CheckMendPet(uint32 diff)
+        {
+            if (!IsSpellReady(MEND_PET_1, diff) || checkMendTimer > diff || Rand() > 75 ||
+                !botPet || !botPet->IsAlive() || GetHealthPCT(botPet) > 80 ||
+                me->GetDistance(botPet) > CalcSpellMaxRange(MEND_PET_1, false) || IsCasting())
+                return;
+
+            checkMendTimer = urand(2000, 4000);
+
+            Aura const* mend = botPet->GetAura(GetSpell(MEND_PET_1));
+            if (!mend || mend->GetDuration() < 3000)
+            {
+                if (doCast(me, GetSpell(MEND_PET_1)))
+                    return;
+            }
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 25)
+                return;
+
+            if (FindAffectedTarget(GetSpell(SCARE_BEAST_1), me->GetGUID(), 60))
+            {
+                SetSpellCooldown(SCARE_BEAST_1, 2000);
+                return;
+            }
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1)))
+                    return;
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void doDefend(uint32 diff)
+        {
+            if (IsTank() || Rand() > 55)
+                return;
+
+            bool feignReady = IsSpellReady(FEIGN_DEATH_1, diff, false);
+            bool deterReady = IsSpellReady(DETERRENCE_1, diff, false);
+            if (!feignReady && !deterReady)
+                return;
+
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                        cast = true;
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast)
+                return;
+
+            if (feignReady && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                    return;
+            }
+
+            if (deterReady)
+            {
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                    return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff) || Rand() > 20)
+                return;
+
+            //First check current target
+            if (me->GetDistance(opponent) > 5 && me->GetDistance(opponent) < CalcSpellMaxRange(TRANQ_SHOT_1) &&
+                !opponent->IsImmunedToSpell(sSpellMgr->GetSpellInfo(TRANQ_SHOT_1), me))
+            {
+                AuraApplication const* aurApp;
+                SpellInfo const* spellInfo;
+                Unit::AuraMap const &auras = opponent->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                {
+                    spellInfo = itr->second->GetSpellInfo();
+                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    aurApp = itr->second->GetApplicationOfTarget(opponent->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        if (doCast(opponent, GetSpell(TRANQ_SHOT_1)))
+                            return;
+                    }
+                }
+            }
+
+            Unit* target = FindTranquilTarget(5, CalcSpellMaxRange(TRANQ_SHOT_1));
+            if (target && doCast(target, GetSpell(TRANQ_SHOT_1)))
+                return;
+        }
+
+        void CheckMisdirect(uint32 diff)
+        {
+            if (!IsSpellReady(MISDIRECTION_1, diff) || misdirectionTimer > diff || IAmFree() ||
+                !master->GetGroup() || Rand() > 20)
+                return;
+
+            misdirectionTimer = urand(3000, 6000);
+
+            //find tank
+            //stacks
+            std::list<Unit*> tanks;
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsAlive() && player->IsInCombat() && IsTank(player) && player->GetVictim())
+                    tanks.push_back(player);
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    if (itr->second == me)
+                        continue;
+                    if (!gr->IsMember(itr->second->GetGUID()))
+                        continue;
+
+                    Unit* u = itr->second;
+                    if (u->IsInWorld() && u->IsAlive() && u->IsInCombat() && IsTank(u) &&
+                        (u->GetVictim() || !u->getAttackers().empty()))
+                        tanks.push_back(u);
+                }
+            }
+
+            if (tanks.empty())
+                return;
+
+            Unit* target = tanks.size() == 1 ? *tanks.begin() : Trinity::Containers::SelectRandomContainerElement(tanks);
+            if (doCast(target, GetSpell(MISDIRECTION_1)))
+                return;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            //pet is killed or unreachable
+            if (GC_Timer <= diff && !me->IsInCombat() && !me->IsMounted() && !me->GetVictim() && !IsCasting() && Rand() < 25 &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+                SummonBotPet();
+
+            //Scare Beast interrupt
+            Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (spell && spell->GetSpellInfo()->Id == GetSpell(SCARE_BEAST_1))
+            {
+                if (spell->m_targets.GetUnitTarget() &&
+                    spell->m_targets.GetUnitTarget()->HasAuraType(SPELL_AURA_MOD_FEAR))
+                    me->InterruptSpell(CURRENT_GENERIC_SPELL);
+            }
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 10)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (IsSpellReady(TRUESHOT_AURA_1, diff) && Rand() < 5 &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_RANGED_ATTACK_POWER_PCT, SPELLFAMILY_HUNTER, 0x0, 0x200000, 0x0, me->GetGUID()))
+            {
+                if (doCast(me, GetSpell(TRUESHOT_AURA_1)))
+                    return;
+            }
+
+            CheckMendPet(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckScare(diff);
+
+            //Deterrence check
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED) && !IsCasting())
+            {
+                if (!me->isMoving())
+                    GetInPosition(true, nullptr);
+                return;
+            }
+
+            if (!CheckAttackTarget())
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            if (IsCasting())
+                return;
+
+            CheckFlare(diff);
+            CheckReadiness(diff);
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            Counter(diff);
+            CheckTranquil(diff);
+
+            float dist = me->GetDistance(opponent);
+            float maxRangeLong = me->GetLevel() >= 10 ? 51.f : 45.f;
+            float maxRangeNormal = me->GetLevel() >= 10 ? 41.f : 35.f;
+
+            bool inposition = !opponent->HasAuraType(SPELL_AURA_MOD_CONFUSE) || dist > maxRangeNormal - 15.f;
+
+            //Auto Shot
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == AUTO_SHOT_1 && (shot->m_targets.GetUnitTarget() != opponent || !inposition))
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (HasRole(BOT_ROLE_DPS) && dist > 5 && dist < maxRangeNormal)
+            {
+                if (doCast(opponent, AUTO_SHOT_1))
+                {}
+            }
+
+            CheckScatter(diff);
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //TRAPS
+            CheckTraps(diff);
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //scatter pvp
+            if (IsSpellReady(SCATTER_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetTypeId() == TYPEID_PLAYER && dist < 10 && Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    GetInPosition(true, opponent);
+                    return;
+                }
+            }
+
+            //DISENGAGE
+            if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() && Rand() < 70 &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !me->getAttackers().empty() && me->GetDistance(*me->getAttackers().begin()) < 5 &&
+                me->HasInArc(M_PI, *me->getAttackers().begin()))
+            {
+                if (doCast(me, GetSpell(DISENGAGE_1)))
+                    return;
+            }
+
+            MoveBehind(opponent);
+
+            //MELEE SECTION
+            if (dist < 5)
+            {
+                //MONGOOSE BITE
+                if (IsSpellReady(MONGOOSE_BITE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    if (doCast(opponent, GetSpell(MONGOOSE_BITE_1)))
+                        return;
+                }
+                //COUNTERATTACK
+                if (IsSpellReady(COUNTERATTACK_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                    me->HasReactive(REACTIVE_HUNTER_PARRY) && Rand() < 90)
+                {
+                    if (doCast(opponent, GetSpell(COUNTERATTACK_1)))
+                        return;
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
+                    Rand() < 80 && !CCed(opponent, true) && !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                {
+                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
+                        return;
+                }
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 40 &&
+                    !me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                {
+                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1)))
+                        return;
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK //100 yd range so don't check it
+            if (IsSpellReady(HUNTERS_MARK_1, diff) && Rand() < 65 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400))
+            {
+                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
+                    return;
+            }
+
+            CheckMisdirect(diff);
+
+            //attack range check 1
+            if (dist > maxRangeLong)
+                return;
+
+            //KILL SHOT
+            if (IsSpellReady(KILL_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+            {
+                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
+                    return;
+            }
+
+            //attack range check 2
+            if (dist > maxRangeNormal)
+                return;
+
+            if (!inposition && me->getAttackers().empty())
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 35 &&
+                !CCed(opponent, true) && !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
+                    return;
+            }
+            //DISTRACTING SHOT
+            Unit const* u = opponent->GetVictim();
+            if (IsSpellReady(DISTRACTING_SHOT_1, diff) && u && u != me && IsTank() && !CCed(opponent) &&
+                IsInBotParty(u) && Rand() < 75 && (!IsTank(u) || (dist > 25 && GetHealthPCT(u) < 25)))
+            {
+                if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
+                    return;
+            }
+            //MULTI-SHOT shares cd with aimed shot
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
+            {
+                if (Rand() < 30 || !GetSpell(STEADY_SHOT_1) || FindSplashTarget(maxRangeNormal))
+                {
+                    if (doCast(opponent, GetSpell(MULTISHOT_1)))
+                        return;
+                }
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !JumpingOrFalling() && Rand() < 75)
+            {
+                if (Unit* target = FindAOETarget(maxRangeNormal))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                        return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 55 &&
+                (opponent->GetHealth() > me->GetMaxHealth() * (1 + opponent->getAttackers().size()) ||
+                opponent->GetTypeId() == TYPEID_PLAYER) &&
+                !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RANGED_HASTE, SPELLFAMILY_HUNTER, 0x20))
+            {
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                {}
+            }
+            //BLACK ARROW
+            //Black Arrow shares cooldown with fire traps
+            if (IsSpellReady(BLACK_ARROW_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()))
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+            //CHIMERA SHOT: no viper
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                //Serpent
+                if (opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                        return;
+                }
+                //Scorpid
+                else if (opponent->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (!opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                        (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID)))
+                    {
+                        if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                            return;
+                    }
+                }
+
+                SetSpellCooldown(CHIMERA_SHOT_1, 500); //fail
+            }
+            //STING
+            if (GetSpellCooldown(SERPENT_STING_1) <= diff && stingTimer <= diff && Rand() < 60)
+            {
+                uint32 STING = 0;
+                AuraEffect const* sting = nullptr;
+                if (!STING && GetSpell(SCORPID_STING_1) && opponent->GetTypeId() == TYPEID_UNIT &&
+                    opponent->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)
+                {
+                    sting = opponent->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0);
+                    if (!sting || sting->GetBase()->GetCasterGUID() == me->GetGUID())
+                        STING = SCORPID_STING_1;
+                }
+                //VIPER STING: pvp only
+                if (!STING && GetSpell(VIPER_STING_1) && opponent->GetTypeId() == TYPEID_PLAYER &&
+                    opponent->GetPowerType() == POWER_MANA && opponent->GetHealth() > me->GetMaxHealth()/2 &&
+                    opponent->GetMaxPower(POWER_MANA) > me->GetMaxPower(POWER_MANA))
+                {
+                    sting = opponent->GetAuraEffect(SPELL_AURA_PERIODIC_MANA_LEECH, SPELLFAMILY_HUNTER, 0x0, 0x80, 0x0, me->GetGUID());
+                    if (!sting)
+                        STING = VIPER_STING_1;
+                }
+                if (!STING && GetSpell(SERPENT_STING_1) && HasRole(BOT_ROLE_DPS) &&
+                    opponent->GetHealth() > me->GetMaxHealth()/2 * (1 + opponent->getAttackers().size()))
+                {
+                    sting = opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID());
+                    if (!sting)
+                        STING = SERPENT_STING_1;
+                }
+
+                if (sting && sting->GetBase()->GetCasterGUID() == me->GetGUID() &&
+                    sting->GetBase()->GetDuration() >= 3000)
+                {
+                    stingTimer = 3000;
+                }
+                else
+                {
+                    if (STING && doCast(opponent, GetSpell(STING)))
+                    {
+                        stingTimer = 8000;
+                        return;
+                    }
+                }
+            }
+            //EXPLOSIVE SHOT: replaces Arcane Shot at 60
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
+                    return;
+            }
+            //ARCANE SHOT: shares cd with Explosive Shot
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && !GetSpell(EXPLOSIVE_SHOT_1))
+            {
+                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
+                    return;
+            }
+            //AIMED SHOT shares cd with multishot
+            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
+                    return;
+            }
+            //STEADY SHOT
+            if (IsSpellReady(STEADY_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(STEADY_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckFlare(uint32 diff)
+        {
+            if (!IsSpellReady(FLARE_1, diff) || flareTimer > diff || me->IsMounted() || Rand() > 25)
+                return;
+
+            flareTimer = urand(2000, 4000);
+
+            Unit* attacker = me->GetVictim();
+            if (attacker)
+            {
+                if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                    attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                    attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                {
+                    if (doCast(attacker, GetSpell(FLARE_1)))
+                        return;
+                }
+            }
+
+            if (IAmFree())
+            {
+                Unit::AttackerSet const& b_attackers = me->getAttackers();
+                if (b_attackers.empty())
+                    return;
+
+                for (Unit::AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (me->GetDistance(attacker) > 15)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(me, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+
+                return;
+            }
+
+            attacker = master->GetVictim();
+            if (attacker && me->GetDistance(attacker) < 30)
+            {
+                if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                    attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                    attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                {
+                    if (doCast(attacker, GetSpell(FLARE_1)))
+                        return;
+                }
+            }
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (me->GetDistance(master) > 30)
+                    return;
+
+                Unit::AttackerSet const& m_attackers = master->getAttackers();
+                if (m_attackers.empty())
+                    return;
+
+                for (Unit::AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (master->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(urand(1,100) <= 50 ? master : attacker, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (tPlayer == nullptr) continue;
+                if (me->GetMap() != tPlayer->FindMap()) continue;
+                if (!tPlayer->IsAlive()) continue;
+                if (me->GetDistance(tPlayer) > 30) continue;
+                attacker = tPlayer->GetVictim();
+                if (attacker && me->GetDistance(attacker) < 30)
+                {
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(attacker, GetSpell(FLARE_1)))
+                            return;
+                    }
+                }
+                Unit::AttackerSet const& p_attackers = tPlayer->getAttackers();
+                if (p_attackers.empty())
+                    continue;
+
+                for (Unit::AttackerSet::const_iterator itr = p_attackers.begin(); itr != p_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (tPlayer->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(urand(1,100) <= 50 ? tPlayer : attacker, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* gPlayer = itr->GetSource();
+                if (gPlayer == nullptr) continue;
+                if (me->GetMap() != gPlayer->FindMap()) continue;
+                if (!gPlayer->HaveBot())
+                    continue;
+
+                BotMap const* map = gPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    Unit* u = itr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->IsTotem() || me->GetDistance(u) > 30)
+                        continue;
+
+                    attacker = u->GetVictim();
+                    if (attacker && me->GetDistance(attacker) < 30)
+                    {
+                        if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                            attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                            attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                        {
+                            if (doCast(attacker, GetSpell(FLARE_1)))
+                                return;
+                        }
+                    }
+                    Unit::AttackerSet const& u_attackers = u->getAttackers();
+                    if (u_attackers.empty())
+                        continue;
+
+                    for (Unit::AttackerSet::const_iterator itr = u_attackers.begin(); itr != u_attackers.end(); ++itr)
+                    {
+                        attacker = *itr;
+                        if (u->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                            continue;
+
+                        if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                            attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                            attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                        {
+                            if (doCast(urand(1,100) <= 50 ? u : attacker, GetSpell(FLARE_1)))
+                                return;
+
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckReadiness(uint32 diff)
+        {
+            if (!IsSpellReady(READINESS_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 30)
+                return;
+
+            //mainly used for rapid fire cd reset
+            bool cast = me->GetVictim() && !IsSpellReady(RAPID_FIRE_1, diff, false);
+
+            if (cast && doCast(me, GetSpell(READINESS_1)))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Explosive Shot: 4% additional critical chance for Explosive Shot
+            if (lvl >= 60 && (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA))
+                crit_chance += 4.f;
+            //Point of No Escape: 6% additional critical chance on targets affected by frosty traps
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 50)
+            {
+                if (victim->GetAuraEffect(SPELL_AURA_MOD_CRIT_CHANCE_FOR_CASTER, SPELLFAMILY_HUNTER, 0x18, 0x0, 0x0, me->GetGUID()))
+                    crit_chance += 6.f;
+            }
+            //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 50 && baseId == KILL_SHOT_1)
+                crit_chance += 15.f;
+            //Improved Steady Shot (37505): 5% additional critical chance for Steady Shot
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+                crit_chance += 5.f;
+            //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+            if (lvl >= 40 && baseId == AIMED_SHOT_1)
+                crit_chance += 10.f;
+            //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 40 && (baseId == AIMED_SHOT_1 || baseId == MULTISHOT_1))
+                crit_chance += 12.f;
+            //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+            if (lvl >= 15 && (baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1 || baseId == EXPLOSIVE_SHOT_1 ||
+                baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA))
+                crit_chance += 4.f;
+            //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+            if (lvl >= 10 && (baseId == RAPTOR_STRIKE_1 || baseId == MONGOOSE_BITE_1 || baseId == COUNTERATTACK_1))
+                crit_chance += 20.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            ////do nothing with autoshot
+            //if (baseId == AUTO_SHOT_1)
+            //    return;
+
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && baseId != AUTO_SHOT_1)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 55 &&
+                    (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1 ||
+                    baseId == KILL_SHOT_1 || baseId == CHIMERA_SHOT_1))
+                    pctbonus += 0.05f;
+            }
+
+            //Improved Tracking: 5% bonus damage versus tracked types (all for bots)
+            if (lvl >= 10)
+                pctbonus += 0.05f;
+            //Focused Fire: 2% bonus damage while pet is active
+            if (lvl >= 15 && botPet)
+                pctbonus += 0.02f;
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 35)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && baseId == ARCANE_SHOT_1)
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1))
+            {
+                if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+                    if (rapi->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.2f;
+            }
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 30 && (spellInfo->SpellFamilyFlags[0] & 0x23000))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 55 && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS, SPELLFAMILY_HUNTER, 0x400, 0x0, 0x0/*, me->GetGUID()*/))
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot, Explosive Trap, Immolation Trap and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 25 &&
+                (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA ||
+                baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == IMMOLATION_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.06f;
+            //Ferocious Inspiration part 2: 9% bonus damage for Arcane Shot and Steady Shot
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) &&
+                lvl >= 40 && (baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1))
+                pctbonus += 0.09f;
+            //Improved Steady Shot (38392): 10% bonus damage for Steady Shot
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+                pctbonus += 0.1f;
+            //Glyph of Steady Shot: 10% bonus damage for Steady Shot if affected by Serpent Sting
+            if (lvl >= 62 && baseId == STEADY_SHOT_1 && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0/*, me->GetGUID()*/))
+                pctbonus += 0.1f;
+            //The Beast Within part 1: 10% bonus damage for all abilities
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) && lvl >= 50)
+                pctbonus += 0.1f;
+            //Sniper Training part 2: 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 50 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x20000) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x8000001) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x200)))
+            {
+                if (Aura const* snip = me->GetAura(SNIPER_TRAINING_BUFF))
+                {
+                    if (snip->GetEffect(0)->IsAffectedOnSpell(spellInfo) ||
+                        snip->GetEffect(1)->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.06f;
+                }
+            }
+            //Improved Steady Shot part 1: 15% bonus damage for Steady Shot, Aimed Shot, Arcane Arrow and Chimera Shot
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 0))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.15f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //    //!!!spell damage is not yet critical and will be multiplied by 1.5
+            //    //so we should put here bonus damage mult /1.5
+            //    //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+            //    if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+            //        pctbonus += 0.16f;
+            //}
+            //Trap Mastery part 2: 30% bonus damage for Immolation Trap, Explosive Trap and Black Arrow
+            if (lvl >= 15 && (baseId == IMMOLATION_TRAP_AURA_1 || baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.3f;
+            //T.N.T: 6% bonus damage for Explosive Shot, Explosive Trap, Immolation Trap and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 25 &&
+                (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA ||
+                baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == IMMOLATION_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.06f;
+            //The Beast Within part 1: 10% bonus damage for all abilities
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) && lvl >= 50)
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flat_mod);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //100% mods
+            //Improved Hunter's Mark: -100% mana cost for Hunter's Mark
+            if (lvl >= 15 && baseId == HUNTERS_MARK_1)
+                pctbonus += 1.0f;
+            //Lock and Load: mana cost
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            }
+
+            //Improved Mend Pet: -20% mana cost for Mend Pet
+            //Improved Mend Pet (23560) part 3
+            if (lvl >= 25 && baseId == MEND_PET_1)
+                pctbonus += 0.5f;
+            //Efficiency: -15% mana cost for Stings and Shots
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 25 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x7FA00) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x88801081) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x1)))
+                pctbonus += 0.15f;
+            //Resourcefulness: -60% mana cost for Traps, melee spells and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 35 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0xDE) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x84000)))
+                pctbonus += 0.6f;
+            //Glyph of Volley: -20% mana cost for Volley
+            if (lvl >= 40 && baseId == VOLLEY_1)
+                pctbonus += 0.2f;
+            //Master Marksman: -25% mana cost for Steady Shot, Aimed Shot and Chimera Shot
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) &&
+                lvl >= 45 && (baseId == STEADY_SHOT_1 || baseId == AIMED_SHOT_1 || baseId == CHIMERA_SHOT_1))
+                pctbonus += 0.25f;
+            //Improved Steady Shot part 2: -20% mana cost for Steady Shot, Aimed Shot, Arcane Arrow and Chimera Shot
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 1))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.2f;
+            }
+
+            //flat mods
+            //!1 rage = 10 pts!
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            //if (lvl >= 10 && baseId == HEROIC_STRIKE_1)
+            //    flatbonus += 30;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Survival Tactics: -4 sec cooldown for Disengage
+            //Glyph of Disengage: -5 sec cooldown for Disengage
+            if (lvl >= 20 && baseId == DISENGAGE_1)
+                timebonus += (_spec == BOT_SPEC_HUNTER_SURVIVAL) ? 9000 : 5000;
+            //Glyph of Feign Death: -5 sec cooldown for Feign Death
+            //Improved Feign Death (24432): -2 sec cooldown for Feign Death
+            if (lvl >= 30 && baseId == FEIGN_DEATH_1)
+                timebonus += 7000;
+            //Tranquilizing Shot Cooldown reduction (61255): -2 sec cooldown for Tranquilizing Shot
+            if (lvl >= 60 && baseId == TRANQ_SHOT_1)
+                timebonus += 2000;
+            //Glyph of Deterrence: -10 sec cooldown for Deterrence
+            if (lvl >= 60 && baseId == DETERRENCE_1)
+                timebonus += 10000;
+            //Glyph of Chimera Shot: -1 sec cooldown for Chimera Shot
+            if (lvl >= 60 && baseId == CHIMERA_SHOT_1)
+                timebonus += 1000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Lock and Load: cooldown
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            }
+
+            //Rapid Killing part 1: -2 min cooldown for Rapid Fire
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && baseId == RAPID_FIRE_1)
+                timebonus += 120000;
+            //Glyph of Aimed Shot: -2 sec cooldown for Aimed Shot
+            if (baseId == AIMED_SHOT_1)
+                timebonus += 2000;
+            //Glyph of Multi-Shot: -1 sec cooldown for Multi-Shot
+            //Improved Multi-Shot (44292): -1 sec cooldown for Multi-Shot
+            if (baseId == MULTISHOT_1)
+                timebonus += 2000;
+            //Trap Cooldown (37481): -4 sec cd for Traps
+            //Trap Cooldown Reduction: -2 sec cd for Traps
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                timebonus += 6000;
+            //Resourcefulness: -6 sec cd for Traps and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 35 && (spellInfo->SpellFamilyFlags[0] & 0x80))
+                timebonus += 6000;
+            //Catlike Reflexes part 3: -30 sec cd for Kill Command
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) && lvl >= 40 && (spellInfo->SpellFamilyFlags[1] & 0x800))
+                timebonus += 30000;
+            //Glyph of Kill Shot: -6 sec cooldown for Kill Shot
+            if (lvl >= 40 && baseId == KILL_SHOT_1)
+                timebonus += 6000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Frost Trap
+            if (baseId == FROST_TRAP_AURA)
+                flatbonus += 2.f;
+            //Glyph of the Pack
+            if (baseId == ASPECT_OF_THE_PACK_1)
+                flatbonus += 15.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Improved Mend Pet (23560) part 1
+            if (lvl >= 25 && baseId == MEND_PET_1)
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Hawk Eye: +6 yd range for Ranged Abilities
+            if (lvl >= 10 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x7FA01) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x88801081) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x401)))
+                flatbonus += 6.f;
+            //Glyph of Scatter Shot
+            if (lvl >= 20 && baseId == SCATTER_SHOT_1)
+                flatbonus += 3.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+
+            //Improved Aspect of the Hawk: 10% chance
+            if (lvl >= 10 && (baseId == ASPECT_OF_THE_HAWK_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_1))
+                chance += 10.f;
+        }
+
+        void ApplyClassEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            //Improved Mend Pet (23560) part 2
+            if (baseId == MEND_PET_1 && effIndex == EFFECT_0)
+                pctbonus *= 1.1f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Rapid Killing: use up buff manually
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+                    if (rapi->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAura(RAPID_KILLING_BUFF);
+            }
+            //Glyph of Arcane Shot
+            if (baseId == ARCANE_SHOT_1)
+            {
+                Unit const* victim = me->GetVictim();
+                if (victim &&
+                    (victim->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_PERIODIC_MANA_LEECH, SPELLFAMILY_HUNTER, 0x0, 0x80, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_MOD_STUN, SPELLFAMILY_HUNTER, 0x0, 0x1000, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_HUNTER, 0x0, 0x100, 0x0, me->GetGUID())))
+                {
+                    int32 cost = spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+                    CastSpellExtraArgs args(true);
+                    args.AddSpellBP0(cost);
+                    me->CastSpell(me, GLYPH_OF_ARCANE_SHOT_ENERGIZE, args);
+                }
+            }
+            //Lock and Load: consume charge
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    lock->GetBase()->DropCharge();
+            }
+            if (baseId == READINESS_1)
+            {
+                SpellInfo const* cdInfo;
+                BotSpellMap const& myspells = GetSpellMap();
+                for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                {
+                    if (itr->first == spellInfo->Id || itr->first == BESTIAL_WRATH_1 || itr->first == GIFT_OF_NAARU_HUNTER)
+                        continue;
+                    if (itr->second->enabled && itr->second->spellId != 0 && itr->second->cooldown > 0)
+                    {
+                        cdInfo = sSpellMgr->GetSpellInfo(itr->first);
+                        if (cdInfo && cdInfo->SpellFamilyName == SPELLFAMILY_HUNTER && cdInfo->GetRecoveryTime() > 0)
+                            ResetSpellCooldown(itr->first);
+                    }
+                }
+            }
+            //Improved Steady Shot: consume buff
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 0))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(IMPROVED_STEADY_SHOT_BUFF);
+            }
+
+            //Aspect helper
+            switch (baseId)
+            {
+                case ASPECT_OF_THE_MONKEY_1:
+                    Aspect = ASPECT_MONKEY;
+                    break;
+                case ASPECT_OF_THE_HAWK_1:
+                    Aspect = ASPECT_HAWK;
+                    break;
+                case ASPECT_OF_THE_CHEETAH_1:
+                    Aspect = ASPECT_CHEETAH;
+                    break;
+                case ASPECT_OF_THE_VIPER_1:
+                    Aspect = ASPECT_VIPER;
+                    break;
+                case ASPECT_OF_THE_BEAST_1:
+                    Aspect = ASPECT_BEAST;
+                    break;
+                case ASPECT_OF_THE_PACK_1:
+                    Aspect = ASPECT_PACK;
+                    break;
+                case ASPECT_OF_THE_WILD_1:
+                    Aspect = ASPECT_WILD;
+                    break;
+                case ASPECT_OF_THE_DRAGONHAWK_1:
+                    Aspect = ASPECT_DRAGONHAWK;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (target == me)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == HUNTERS_MARK_1)
+            {
+                //Hunter's Mark helper
+                if (AuraEffect* mark = target->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                {
+                    //Glyph of Hunter's Mark: +20% effect
+                    //Improved Hunter's Mark: +30% effect
+                    if (lvl >= 15)
+                        mark->ChangeAmount(mark->GetAmount() + mark->GetAmount() / 2);
+                    else if (lvl >= 10)
+                        mark->ChangeAmount(mark->GetAmount() * 13 / 10);
+                }
+            }
+            //Improved Stings part 1: +30% damage
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 25 && (baseId == SERPENT_STING_1 || baseId == WYVERN_STING_DOT_AURA_1))
+            {
+                if (AuraEffect* stin = target->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    stin->ChangeAmount(stin->GetAmount() * 13 / 10);
+                }
+            }
+            //Improved Stings part 2: +30% effect: not working?
+            //Trap Mastery part 1
+            if (lvl >= 15 && (baseId == FROST_TRAP_AURA || baseId == FREEZING_TRAP_AURA_1))
+            {
+                if (Aura* freez = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    int32 dur = freez->GetDuration() * 13 / 10;
+                    freez->SetDuration(dur);
+                    freez->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 16 && baseId == IMMOLATION_TRAP_AURA_1)
+            {
+                if (AuraEffect* immo = target->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    //Glyph of Immolation Trap: -6 sec duration, +100% effect
+                    immo->ChangeAmount(immo->GetAmount() * 2);
+                    int32 dur = immo->GetBase()->GetDuration() - 6000;
+                    immo->GetBase()->SetDuration(dur);
+                    immo->GetBase()->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 15 && baseId == SERPENT_STING_1)
+            {
+                if (Aura* sting = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    //Glyph of Serpent Sting: +6 sec duration
+                    //Improved Serpent Sting (24467): +3 sec duration
+                    int32 dur = sting->GetDuration() + 6000;
+                    if (lvl >= 60)
+                        dur += 3000;
+                    sting->SetDuration(dur);
+                    sting->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 30 && baseId == WING_CLIP_1)
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (lvl >= 10 && baseId == CONCUSSIVE_SHOT_1)
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 50 && baseId == STEADY_SHOT_1)
+            {
+                //Improved Steady Shot: 15% chance
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(me, IMPROVED_STEADY_SHOT_BUFF, true);
+                }
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Feign Death should always clear combat on bots
+            if (baseId == FEIGN_DEATH_1 && me->GetMap()->IsDungeon())
+                me->CombatStop(false, false);
+
+            //Rapid Recuperation (Rapid Killing) hackfix: trigger 2% energize
+            if (baseId == RAPID_RECUPERATION_ENERGIZE)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_ENERGIZE_PCT_1, true);
+            }
+            //Rapid Recuperation (Rapid Fire): match duration
+            if (baseId == RAPID_RECUPERATION_BUFF && GetSpell(RAPID_FIRE_1))
+            {
+                if (Aura const* rapi = me->GetAura(GetSpell(RAPID_FIRE_1)))
+                {
+                    if (Aura* recu = me->GetAura(spell->Id))
+                    {
+                        uint32 dur = rapi->GetDuration();
+                        recu->SetDuration(dur);
+                        recu->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Rapid Recuperation (Rapid Fire)
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && baseId == RAPID_FIRE_1 && me->GetLevel() >= 45)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_BUFF, true);
+            }
+            //Rapid Recuperation (Rapid Killing)
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && baseId == RAPID_KILLING_BUFF && me->GetLevel() >= 45)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_BUFF2, true);
+            }
+            if (baseId == RAPID_FIRE_1 && lvl >= 26)
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                //Glyph of Rapid Fire: +8% haste
+                if (AuraEffect* rapi = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    rapi->ChangeAmount(rapi->GetAmount() + 8);
+
+                    uint32 dur = rapi->GetBase()->GetDuration() + 4000;
+                    rapi->GetBase()->SetDuration(dur);
+                    rapi->GetBase()->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == QUICK_SHOTS_BUFF)
+            {
+                if (AuraEffect* quic = me->GetAuraEffect(QUICK_SHOTS_BUFF, 0))
+                {
+                    //base 15% haste
+                    int32 newAmount = quic->GetAmount() + 15;
+                    //Glyph of the Hawk: +6% effect flat
+                    if (lvl >= 15)
+                        newAmount += 6;
+
+                    quic->ChangeAmount(newAmount);
+                }
+            }
+            if ((baseId == ASPECT_OF_THE_CHEETAH_1 || baseId == ASPECT_OF_THE_PACK_1) && caster == me && lvl >= 20)
+            {
+                //Pathfinding: +8% increased effect
+                if (AuraEffect* spee = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    spee->ChangeAmount(spee->GetAmount() + 8);
+                }
+            }
+            if ((baseId == ASPECT_OF_THE_MONKEY_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_MONKEY) && lvl >= 15)
+            {
+                //Improved Aspect of The Monkey: +6% dodge chance
+                if (AuraEffect* monk = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    monk->ChangeAmount(monk->GetAmount() + 6);
+                }
+            }
+            //Aspect Mastery
+            if (lvl >= 20)
+            {
+                if (baseId == ASPECT_OF_THE_VIPER_1)
+                {
+                    if (AuraEffect* vipe = me->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                    {
+                        //part 1: 10% reduced damage penalty
+                        vipe->ChangeAmount(vipe->GetAmount() + 10);
+                    }
+                }
+                if (baseId == ASPECT_OF_THE_MONKEY_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_MONKEY)
+                {
+                    if (AuraEffect* monk = me->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                    {
+                        //part 2: 5% reduced damage
+                        monk->ChangeAmount(monk->GetAmount() - 5);
+                    }
+                }
+                if (baseId == ASPECT_OF_THE_HAWK_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_1)
+                {
+                    if (AuraEffect* hawk = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                    {
+                        //part 3: 30% attack power bonus
+                        hawk->ChangeAmount(hawk->GetAmount() * 13 / 10);
+                    }
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* /*spellInfo*/) override
+        {
+            if (botPet && victim != me && victim != botPet && damage > 0 && cleanDamage && cleanDamage->hitOutCome == MELEE_HIT_CRIT &&
+                (damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE) && me->GetLevel() >= 20)
+            {
+                //Go for the Throat: energize pet
+                me->EnergizeBySpell(botPet, GO_FOR_THE_THROAT_ENERGIZE, 50, POWER_FOCUS);
+                //Frenzy hack: proc from hunter's crits
+                if (me->GetLevel() >= 35)
+                    botPet->CastSpell(botPet, FRENZY_BUFF, true);
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            if (me->GetLevel() < 10)
+                return;
+
+            if (myPetType == BOT_PET_INVALID) //disabled
+                return;
+
+            if (petSummonTimer > GetLastDiff())
+                return;
+
+            uint32 entry;
+
+            if (myPetType)
+                entry = myPetType;
+            else if (!IAmFree())
+            {
+                if ((master->GetGroup() && master->GetGroup()->isRaidGroup()) || master->GetNpcBotsCount() >= 10)
+                    entry = BOT_PET_WOLF; //raid pet
+                else if (!IsMeleeClass(master->GetClass()))
+                    entry = urand(BOT_PET_TENACITY_START, BOT_PET_TENACITY_END);
+                else if (sWorld->IsFFAPvPRealm() || sWorld->IsPvPRealm())
+                    entry = urand(BOT_PET_CUNNING_START, BOT_PET_CUNNING_END);
+                else
+                    entry = urand(BOT_PET_HUNTER_START, BOT_PET_HUNTER_END_GENERAL);
+            }
+            else
+                entry = urand(BOT_PET_HUNTER_START, BOT_PET_HUNTER_END_GENERAL);
+
+            //ensurance
+            if (entry < BOT_PET_HUNTER_START || entry > BOT_PET_HUNTER_END_EXOTIC ||
+                (entry >= BOT_PET_EXOTIC_START && _spec != BOT_SPEC_HUNTER_BEASTMASTERY))
+                entry = 0;
+
+            myPetType = entry;
+
+            //try next time
+            if (!myPetType)
+                return;
+
+            petSummonTimer = 10000;
+            ResetSpellCooldown(KINDRED_SPIRITS_PET);
+            ResetSpellCooldown(SPIRIT_BOND_PET);
+
+            Position pos;
+
+            me->CastSpell(me, CALL_PET_VISUAL, true);
+            Creature* myPet = me->SummonCreature(myPetType, *me, TEMPSUMMON_CORPSE_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, me->GetOrientation() + M_PI / 2);
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //fix scale
+            switch (myPetType)
+            {
+                case BOT_PET_RAVAGER:
+                case BOT_PET_WASP:
+                case BOT_PET_TEROMOTH:
+                case BOT_PET_SCORPID:
+                case BOT_PET_TURTLE:
+                case BOT_PET_BEAR:
+                case BOT_PET_WARPSTALKER:
+                case BOT_PET_COREHOUND:
+                    myPet->SetObjectScale(0.75f);
+                    break;
+                case BOT_PET_CHIMAERA:
+                    myPet->SetObjectScale(0.67f);
+                    break;
+                case BOT_PET_RAPTOR:
+                case BOT_PET_DEVILSAUR:
+                case BOT_PET_RHINO:
+                    myPet->SetObjectScale(0.5f);
+                    break;
+                default:
+                    break;
+            }
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all hunter bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+            {
+                petSummonTimer = 10000;
+                botPet = nullptr;
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(AUTO_SHOT_1) : 25.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return myPetType;
+                case BOTAI_MISC_PET_AVAILABLE_1:
+                    return BOT_PET_WOLF;
+                case BOTAI_MISC_PET_AVAILABLE_2:
+                    return BOT_PET_CUNNING_START;
+                case BOTAI_MISC_PET_AVAILABLE_3:
+                    return BOT_PET_FEROCITY_START;
+                case BOTAI_MISC_PET_AVAILABLE_4:
+                    return BOT_PET_TENACITY_START;
+                case BOTAI_MISC_PET_AVAILABLE_5:
+                    return me->GetLevel() >= 80 ? BOT_PET_SILITHID : 0;
+                case BOTAI_MISC_PET_AVAILABLE_6:
+                    return me->GetLevel() >= 80 ? BOT_PET_CHIMAERA : 0;
+                case BOTAI_MISC_PET_AVAILABLE_7:
+                    return me->GetLevel() >= 80 ? BOT_PET_SPIRITBEAST : 0;
+                case BOTAI_MISC_PET_AVAILABLE_8:
+                    return me->GetLevel() >= 80 ? BOT_PET_COREHOUND : 0;
+                case BOTAI_MISC_PET_AVAILABLE_9:
+                    return me->GetLevel() >= 80 ? BOT_PET_DEVILSAUR : 0;
+                case BOTAI_MISC_PET_AVAILABLE_10:
+                    return me->GetLevel() >= 80 ? BOT_PET_RHINO : 0;
+                case BOTAI_MISC_PET_AVAILABLE_11:
+                    return me->GetLevel() >= 80 ? BOT_PET_WORM : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    myPetType = value;
+                    UnsummonAll();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            myPetType = 0;
+
+            trapTimer = 0;
+            stingTimer = 0;
+            aspectTimer = 0;
+            flareTimer = 0;
+            misdirectionTimer = 0;
+            checkMendTimer = 0;
+
+            petSummonTimer = 5000;
+
+            Aspect = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (trapTimer > diff)                   trapTimer -= diff;
+            if (stingTimer > diff)                  stingTimer -= diff;
+            if (aspectTimer > diff)                 aspectTimer -= diff;
+            if (flareTimer > diff)                  flareTimer -= diff;
+            if (misdirectionTimer > diff)           misdirectionTimer -= diff;
+            if (checkMendTimer > diff)              checkMendTimer -= diff;
+
+            if (petSummonTimer > diff)              petSummonTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+
+            if (botPet && botPet->GetPowerType() != POWER_FOCUS)
+                botPet->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_FOCUS);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            //bool isBeas = _spec == BOT_SPEC_HUNTER_BEASTMASTERY;
+            bool isMark = _spec == BOT_SPEC_HUNTER_MARKSMANSHIP;
+            bool isSurv = _spec == BOT_SPEC_HUNTER_SURVIVAL;
+
+            InitSpellMap(AUTO_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+            InitSpellMap(TRANQ_SHOT_1);
+            InitSpellMap(STEADY_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SERPENT_STING_1);
+            InitSpellMap(SCORPID_STING_1);
+            InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(FLARE_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(MONGOOSE_BITE_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(IMMOLATION_TRAP_1);
+            InitSpellMap(FREEZING_TRAP_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(EXPLOSIVE_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+            InitSpellMap(DETERRENCE_1);
+            InitSpellMap(MISDIRECTION_1);
+            InitSpellMap(MEND_PET_1);
+
+            InitSpellMap(ASPECT_OF_THE_MONKEY_1);
+            InitSpellMap(ASPECT_OF_THE_HAWK_1);
+            InitSpellMap(ASPECT_OF_THE_CHEETAH_1);
+            InitSpellMap(ASPECT_OF_THE_VIPER_1);
+            //InitSpellMap(ASPECT_OF_THE_BEAST_1);
+            InitSpellMap(ASPECT_OF_THE_PACK_1);
+            InitSpellMap(ASPECT_OF_THE_WILD_1);
+            InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+
+  /*Talent*/lvl >= (isMark ? 20 : 70) ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+  /*Talent*/lvl >= 30 && isMark ? InitSpellMap(READINESS_1) : RemoveSpell(READINESS_1);
+  /*Talent*/lvl >= 40 && isMark ? InitSpellMap(TRUESHOT_AURA_1) : RemoveSpell(TRUESHOT_AURA_1);
+  /*Talent*/lvl >= 50 && isMark ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 && isMark ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+
+  /*Talent*/lvl >= (isSurv ? 20 : isMark ? 70 : 99) ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+  /*Talent*/lvl >= 30 && isSurv ? InitSpellMap(COUNTERATTACK_1) : RemoveSpell(COUNTERATTACK_1);
+  /*Talent*/lvl >= 40 && isSurv ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+  /*Talent*/lvl >= 50 && isSurv ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+  /*Talent*/lvl >= 60 && isSurv ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isBeas = _spec == BOT_SPEC_HUNTER_BEASTMASTERY;
+            bool isMark = _spec == BOT_SPEC_HUNTER_MARKSMANSHIP;
+            bool isSurv = _spec == BOT_SPEC_HUNTER_SURVIVAL;
+
+            RefreshAura(IMPROVED_MEND_PET, isBeas && level >= 25 ? 1 : 0);
+
+            RefreshAura(RAPID_KILLING, isMark && level >= 20 ? 1 : 0);
+            RefreshAura(CONCUSSIVE_BARRAGE, isMark && level >= 30 ? 1 : 0);
+            RefreshAura(PIERCING_SHOTS, isMark && level >= 40 ? 1 : 0);
+            //RefreshAura(TRUESHOT_AURA, isMark && level >= 40 ? 1 : 0);
+            RefreshAura(MASTER_MARKSMAN, isMark && level >= 45 ? 1 : 0);
+            RefreshAura(WILD_QUIVER, isMark && level >= 50 ? 1 : 0);
+
+            RefreshAura(SUREFOOTED, level >= 15 ? 1 : 0);
+            RefreshAura(ENTRAPMENT, isSurv && level >= 15 ? 1 : 0);
+            RefreshAura(LOCK_AND_LOAD, isSurv && level >= 25 ? 1 : 0);
+            RefreshAura(EXPOSE_WEAKNESS, isSurv && level >= 40 ? 1 : 0);
+            RefreshAura(THRILL_OF_THE_HUNT, isSurv && level >= 40 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN5, isSurv && level >= 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN4, isSurv && level >= 49 && level < 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN3, isSurv && level >= 48 && level < 49 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN2, isSurv && level >= 47 && level < 48 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN1, isSurv && level >= 46 && level < 47 ? 1 : 0);
+            RefreshAura(NOXIOUS_STINGS, isSurv && level >= 45 ? 1 : 0);
+            RefreshAura(SNIPER_TRAINING, isSurv && level >= 50 ? 1 : 0);
+
+            RefreshAura(GLYPH_RAPTOR_STRIKE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_ASPECT_OF_THE_VIPER, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_FREEZING_TRAP, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_EXPLOSIVE_TRAP, level >= 34 ? 1 : 0);
+
+            RefreshAura(HUNTER_T8_P2, level >= 70 ? 1 : 0);
+            RefreshAura(HUNTER_T10_P2, level >= 75 ? 1 : 0);
+            RefreshAura(HUNTER_T10_P4, level >= 80 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                //case RAPID_FIRE_1:
+                case FLARE_1:
+                case MEND_PET_1:
+                case IMMOLATION_TRAP_1:
+                case FREEZING_TRAP_1:
+                case FROST_TRAP_1:
+                case EXPLOSIVE_TRAP_1:
+                case VOLLEY_1:
+                //case ASPECT_OF_THE_MONKEY_1:
+                //case ASPECT_OF_THE_HAWK_1:
+                //case ASPECT_OF_THE_CHEETAH_1:
+                //case ASPECT_OF_THE_VIPER_1:
+                //case ASPECT_OF_THE_BEAST_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_WILD_1:
+                //case ASPECT_OF_THE_DRAGONHAWK_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList) override
+        {
+            std::ostringstream msg1;
+            msg1 << "Aspect: ";
+            switch (Aspect)
+            {
+                case ASPECT_MONKEY:
+                    msg1 << "Monkey";
+                    break;
+                case ASPECT_HAWK:
+                    msg1 << "Hawk";
+                    break;
+                case ASPECT_CHEETAH:
+                    msg1 << "Cheetah";
+                    break;
+                case ASPECT_VIPER:
+                    msg1 << "Viper";
+                    break;
+                case ASPECT_BEAST:
+                    msg1 << "Beast";
+                    break;
+                case ASPECT_PACK:
+                    msg1 << "Pack";
+                    break;
+                case ASPECT_WILD:
+                    msg1 << "Wild";
+                    break;
+                case ASPECT_DRAGONHAWK:
+                    msg1 << "Dragonhawk";
+                    break;
+               default:
+                    msg1 << "No Aspect";
+                    break;
+            }
+            specList.push_back(msg1.str());
+        }
+
+    private:
+        uint32 trapTimer, stingTimer, aspectTimer, flareTimer, misdirectionTimer, checkMendTimer;
+        uint8 Aspect;
+        //Pet
+        uint32 myPetType;
+        uint32 petSummonTimer;
+
+        //Scans target for hunter's aspects
+        //returns applied aspects mask
+        //used for finding out which aspects target lacks
+        uint32 _getAspectsMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            uint32 baseId;
+            bool isAspect;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                isAspect = true;
+                baseId = itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    //case ASPECT_OF_THE_MONKEY_1:
+                    //    mask |= SPECIFIC_ASPECT_MONKEY;
+                    //    break;
+                    case ASPECT_OF_THE_HAWK_1:
+                        mask |= SPECIFIC_ASPECT_HAWK;
+                        break;
+                    //case ASPECT_OF_THE_CHEETAH_1:
+                    //    mask |= SPECIFIC_ASPECT_CHEETAH;
+                    //    break;
+                    //case ASPECT_OF_THE_VIPER_1:
+                    //    mask |= SPECIFIC_ASPECT_VIPER;
+                    //    break;
+                    //case ASPECT_OF_THE_BEAST_1:
+                    //    mask |= SPECIFIC_ASPECT_BEAST;
+                    //    break;
+                    case ASPECT_OF_THE_PACK_1:
+                        mask |= SPECIFIC_ASPECT_PACK;
+                        break;
+                    case ASPECT_OF_THE_WILD_1:
+                        mask |= SPECIFIC_ASPECT_WILD;
+                        break;
+                    case ASPECT_OF_THE_DRAGONHAWK_1:
+                        mask |= SPECIFIC_ASPECT_DRAGONHAWK;
+                        break;
+                    default:
+                        isAspect = false; //next aura
+                        break;
+                }
+
+                if (isAspect)
+                {
+                    idMap[baseId] = itr->first;
+                    if (itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                        mask |= SPECIFIC_ASPECT_MY_ASPECT;
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..06b35f9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,1620 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Mage NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 80-90%
+TODO: arcane spec, arcane power, presence of mind, slow (pvp), mana shield, cold snap
+*/
+
+enum MageBaseSpells
+{
+    DAMPENMAGIC_1                       = 604,
+    AMPLIFYMAGIC_1                      = 1008,//manual use only
+    ARCANEINTELLECT_1                   = 1459,
+    ARCANEMISSILES_1                    = 5143,
+    POLYMORPH_1                         = 118,
+    COUNTERSPELL_1                      = 2139,
+    SPELLSTEAL_1                        = 30449,
+    EVOCATION_1                         = 12051,
+    BLINK_1                             = 1953,
+    REMOVE_CURSE_1                      = 475,
+    INVISIBILITY_1                      = 66,
+    BLAST_WAVE_1                        = 11113,
+    DRAGON_BREATH_1                     = 31661,
+    FIRE_BLAST_1                        = 2136,
+    PYROBLAST_1                         = 11366,
+    LIVING_BOMB_1                       = 44457,
+    FLAMESTRIKE_1                       = 2120,
+    COMBUSTION_1                        = 11129,
+    FROSTFIRE_BOLT_1                    = 44614,
+    FIREBALL_1                          = 133,
+    FROSTBOLT_1                         = 116,
+    FROST_NOVA_1                        = 122,
+    CONE_OF_COLD_1                      = 120,
+    BLIZZARD_1                          = 10,
+    FROST_ARMOR_1                       = 168,
+    ICE_ARMOR_1                         = 7302,
+    MOLTEN_ARMOR_1                      = 30482,
+    ICE_BARRIER_1                       = 11426,
+    ICE_BLOCK_1                         = 45438,
+    FOCUS_MAGIC_1                       = 54646,
+    SLOW_FALL_1                         = 130,
+    ICE_LANCE_1                         = 30455,
+    ICY_VEINS_1                         = 12472,
+    DEEP_FREEZE_1                       = 44572,
+    FROST_WARD_1                        = 6143,
+    FIRE_WARD_1                         = 543,
+    //Special
+    BLIZZARD_DAMAGE_1                   = 42208,
+    LIVING_BOMB_DAMAGE_1                = 44461,
+    CONJURE_MANA_GEM_1                  = 759,
+    MANA_GEM_1                          = 5405,
+    RITUAL_OF_REFRESHMENT_1             = 43987,
+
+    SUMMON_WATER_ELEMENTAL_1            = 31687
+};
+
+enum MagePassives
+{
+//Talents
+    FROSTBITE1                          = 11071,
+    FROSTBITE2                          = 12496,
+    FROSTBITE3                          = 12497,
+    ARCANE_CONCENTRATION                = 12577,//rank 5, clearcast
+    IGNITE                              = 12848,//rank 5
+    BURNING_DETERMINATION               = 54749,//rank 2
+    FROST_WARDING                       = 28332,//rank 2
+    IMPROVED_COUNTERSPELL1              = 11255,
+    IMPROVED_COUNTERSPELL2              = 12598,
+    ARCANE_MEDITATION                   = 18464,//rank 3
+    TORMENT_THE_WEAK                    = 55340,//rank 3
+    IMPACT                              = 12358,//rank 3
+    IMPROVED_BLIZZARD                   = 12488,//rank 3
+    MOLTEN_SHIELDS                      = 13043,//rank 2
+    MASTER_OF_ELEMENTS                  = 29076,//rank 3
+    SHATTER1                            = 11170,
+    SHATTER2                            = 12982,
+    SHATTER3                            = 12983,
+    ARCANE_POTENCY1                     = 31571,
+    ARCANE_POTENCY2                     = 31572,
+    BLAZING_SPEED                       = 31642,//rank 2
+    WINTERS_CHILL1                      = 11180,
+    WINTERS_CHILL2                      = 28592,
+    WINTERS_CHILL3                      = 28593,
+    ARCANE_EMPOWERMENT                  = 31583,//rank 3
+    INCANTERS_ABSORPTION1               = 44394,
+    INCANTERS_ABSORPTION2               = 44395,
+    INCANTERS_ABSORPTION3               = 44396,
+    PYROMANIAC                          = 34296,//rank 3
+    SHATTERED_BARRIER                   = 54787,//rank 2
+    //ARCTIC_WINDS                        = 31678,//rank 5
+    FINGERS_OF_FROST                    = 44545,//rank 2
+    FIRESTARTER1                        = 44442,
+    FIRESTARTER2                        = 44443,
+    HOT_STREAK                          = 44448,//rank 3
+    BRAIN_FREEZE1                       = 44546,
+    BRAIN_FREEZE2                       = 44548,
+    BRAIN_FREEZE3                       = 44549,
+
+    GLYPH_POLYMORPH                     = 56375,
+    GLYPG_REMOVE_CURSE                  = 56364,
+    GLYPH_ICY_VEINS                     = 56374,
+    GLYPH_LIVING_BOMB                   = 63091,
+    GLYPH_ICE_LANCE                     = 56377
+};
+enum MageSpecial
+{
+    ARCANE_CONCENTRATION_BUFF           = 12536,
+    IMPACT_BUFF                         = 64343,
+    FIRESTARTER_BUFF                    = 54741,
+    ARCANE_POTENCY_BUFF1                = 57529,
+    ARCANE_POTENCY_BUFF2                = 57531,
+    COMBUSTION_BUFF                     = 28682,
+    BRAIN_FREEZE_BUFF                   = 57761,
+    HOT_STREAK_BUFF                     = 48108,
+    FINGERS_OF_FROST_BUFF               = 44544,
+    IMPROVED_BLIZZARD_CHILL             = 12486,//rank 3
+    FROSTBITE_TRIGGERED                 = 12494,
+    WINTERS_CHILL_TRIGGERED             = 12579,
+    IGNITE_TRIGGERED                    = 12654,
+    //creature
+    CREATURE_ENTRY_CHROMAGGUS           = 14020
+};
+
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct mage_botAI : public bot_ai
+    {
+        mage_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void JustEnteredCombat(Unit* u) override { canFrostWard = false; canFireWard = false; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void Counter(uint32 diff)
+        {
+            //skip if evocation, blizzard
+            if (IsChanneling() || Rand() > 30)
+                return;
+
+            if (IsSpellReady(COUNTERSPELL_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(COUNTERSPELL_1), 0, COUNTERSPELL_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(DEEP_FREEZE_1, diff) && me->HasAuraType(SPELL_AURA_ABILITY_IGNORE_AURASTATE))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(DEEP_FREEZE_1), 0, DEEP_FREEZE_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(DEEP_FREEZE_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(FIRE_BLAST_1, diff) && me->HasAura(IMPACT_BUFF))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(FIRE_BLAST_1), 0, FIRE_BLAST_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(FIRE_BLAST_1)))
+                        return;
+                }
+            }
+            if (!IsCasting() && IsSpellReady(POLYMORPH_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(POLYMORPH_1), 0, POLYMORPH_1, 75))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(SPELLSTEAL_1), true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                return;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting() || Rand() > 25)
+                return;
+
+            //slow fall
+            if (GetSpell(SLOW_FALL_1) && !IAmFree())
+            {
+                Player* fPlayer = nullptr;
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        Player* pl = ref->GetSource();
+                        if (pl && pl->IsAlive() && pl->FindMap() == me->GetMap() && pl->GetDistance(me) < 30 &&
+                            pl->IsFalling() && pl->m_movementInfo.fallTime > 1000 &&
+                            !pl->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                        {
+                            fPlayer = pl;
+                            break;
+                        }
+                    }
+                }
+                else if (master->IsAlive() && master->GetDistance(me) < 30 && master->IsFalling() &&
+                    master->m_movementInfo.fallTime > 1000 && !master->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                    fPlayer = master;
+
+                if (fPlayer && doCast(fPlayer, GetSpell(SLOW_FALL_1)))
+                    return;
+            }
+
+            //ARMOR
+            uint32 MOLTENARMOR = HasRole(BOT_ROLE_DPS) ? GetSpell(MOLTEN_ARMOR_1) : GetSpell(ICE_ARMOR_1);
+            uint32 ICEARMOR = GetSpell(ICE_ARMOR_1) ? GetSpell(ICE_ARMOR_1) : GetSpell(FROST_ARMOR_1);
+            uint32 ARMOR = !MOLTENARMOR ? ICEARMOR : me->GetMap()->IsDungeon() ? MOLTENARMOR : ICEARMOR;
+            if (ARMOR && !me->HasAura(ARMOR))
+            {
+                if (doCast(me, ARMOR))
+                    return;
+            }
+
+            if (GetSpell(CONJURE_MANA_GEM_1))
+            {
+                if (manaGemCharges == 0 &&
+                    doCast(me, GetSpell(CONJURE_MANA_GEM_1)))
+                    return;
+            }
+            if (GetSpell(DAMPENMAGIC_1))
+            {
+                if (!me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELLFAMILY_MAGE, 0x2000)
+                    /*!HasAuraName(me, DAMPENMAGIC_1)*/ &&
+                    doCast(me, GetSpell(DAMPENMAGIC_1)))
+                    return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (GetSpell(ARCANEINTELLECT_1) && target->GetMaxPower(POWER_MANA) > 1 &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_MAGE, 0x400)
+                /*!HasAuraName(target, ARCANEINTELLECT_1)*/)
+            {
+                if (doCast(target, GetSpell(ARCANEINTELLECT_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            CheckPoly(diff);
+            CheckBlink(diff);
+            CheckIceBlock(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            CheckPots(diff);
+
+            CheckRacials(diff);
+
+            CheckShield(diff);
+            CureGroup(GetSpell(REMOVE_CURSE_1), diff);
+            CheckWard(diff);
+
+            CheckFocusMagic(diff);
+            BuffAndHealGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //pet
+            if ((!botPet || !botPet->IsAlive()) &&
+                IsSpellReady(SUMMON_WATER_ELEMENTAL_1, diff) && !IsCasting() && (IAmFree() || master->IsInCombat()))
+                if (doCast(me, GetSpell(SUMMON_WATER_ELEMENTAL_1)))
+                    return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            CheckPolymorph(diff);//this should go AFTER getting target
+
+            Counter(diff);
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+
+            StartAttack(opponent, IsMelee());
+
+            //mage
+            if (me->HasInvisibilityAura()) return;
+            if (!HasRole(BOT_ROLE_DPS)) return;
+
+            Unit::AttackerSet const& m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+
+            float dist = me->GetDistance(opponent);
+
+            //COMBUSTION (no GCD)
+            if (IsSpellReady(COMBUSTION_1, diff, false) && GetManaPCT(me) > 20 &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth() * 4 ||
+                m_attackers.size() > 1 || b_attackers.size() > 1) &&
+                Rand() < 45 &&
+                !me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x04000000, 0x0)
+                /*!HasAuraName(me, COMBUSTION_1)*/)
+            {
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                    return;
+            }
+            //ICY VEINS (no GCD)
+            if (IsSpellReady(ICY_VEINS_1, diff, false) && GetManaPCT(me) > 20 &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth() * 2 ||
+                (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)) &&
+                Rand() < 45)
+            {
+                if (doCast(me, GetSpell(ICY_VEINS_1)))
+                    return;
+            }
+            //DAMAGE
+            //Cheap check
+            if (GC_Timer > diff) //!ensure none spells below ignore GCD!
+                return;
+            //NOVAS
+            if ((IsSpellReady(FROST_NOVA_1, diff) || IsSpellReady(BLAST_WAVE_1, diff)) && Rand() < 85)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 8.5f, 1); //both are radius 10 yd
+                if (!targets.empty())
+                {
+                    bool oneOnOne = (*targets.begin()) == opponent;
+                    //Frost Nova
+                    if (IsSpellReady(FROST_NOVA_1, diff) && (targets.size() > 1 || oneOnOne))
+                    {
+                        if (doCast(me, GetSpell(FROST_NOVA_1)))
+                        {
+                            GetInPosition(true, opponent);
+                            return;
+                        }
+                    }
+                    //Blast Wave
+                    else if (IsSpellReady(BLAST_WAVE_1, diff) && (targets.size() > 1 || oneOnOne))
+                    {
+                        if (doCast(me, GetSpell(BLAST_WAVE_1)))
+                            return;
+                    }
+                }
+            }
+            //CONES
+            if (/*fbCasted && */(IsSpellReady(CONE_OF_COLD_1, diff) || IsSpellReady(DRAGON_BREATH_1, diff)) && Rand() < 65)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 8); //both are radius 10 yd
+                if (!targets.empty())
+                {
+                    //Cone of Cold
+                    if (IsSpellReady(CONE_OF_COLD_1, diff))
+                    {
+                        if (doCast(me, GetSpell(CONE_OF_COLD_1)))
+                            return;
+                    }
+                    //Dragon's Breath
+                    else if (IsSpellReady(DRAGON_BREATH_1, diff))
+                    {
+                        if (doCast(me, GetSpell(DRAGON_BREATH_1)))
+                            return;
+                    }
+                }
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_FROST|SPELL_SCHOOL_MASK_FIRE))
+                return;
+
+            //spell reflections: Ice Lance instant / Frostbolt Rank 1
+            if (IsSpellReady(ICE_LANCE_1, diff) && dist < CalcSpellMaxRange(ICE_LANCE_1) && CanRemoveReflectSpells(opponent, ICE_LANCE_1) &&
+                doCast(opponent, ICE_LANCE_1))
+                return;
+            else if (IsSpellReady(FROSTBOLT_1, diff) && dist < CalcSpellMaxRange(FROSTBOLT_1) && CanRemoveReflectSpells(opponent, FROSTBOLT_1) &&
+                doCast(opponent, FROSTBOLT_1))
+                return;
+
+            //Pyroblast TODO: PoM
+            if (IsSpellReady(PYROBLAST_1, diff) &&
+                dist < CalcSpellMaxRange(PYROBLAST_1) && ((opponent->IsPolymorphed() &&
+                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent)) || me->HasAura(HOT_STREAK_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(PYROBLAST_1)))
+                    return;
+            }
+            //Living Bomb
+            if (fbCasted && IsSpellReady(LIVING_BOMB_1, diff) && dist < CalcSpellMaxRange(LIVING_BOMB_1) &&
+                opponent->GetHealth() > me->GetHealth() / 2 * opponent->getAttackers().size() &&
+                Rand() < 25 && !opponent->HasAura(GetSpell(LIVING_BOMB_1), me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(LIVING_BOMB_1)))
+                    return;
+            }
+            //Fire Blast (do not waste mana in raids)
+            if (IsSpellReady(FIRE_BLAST_1, diff) && dist < CalcSpellMaxRange(FIRE_BLAST_1) &&
+                opponent->GetHealth() < me->GetMaxHealth()*4 && (fbCasted || opponent->GetHealth() < me->GetMaxHealth() / 4) &&
+                Rand() < (30 + 40*fbCasted + 80*(!opponent->IsFrozen() && !opponent->HasUnitState(UNIT_STATE_STUNNED) && me->HasAura(IMPACT_BUFF))))
+            {
+                if (doCast(opponent, GetSpell(FIRE_BLAST_1)))
+                    return;
+            }
+            //Deep Freeze (damage only)
+            if (fbCasted && IsSpellReady(DEEP_FREEZE_1, diff) && dist < CalcSpellMaxRange(DEEP_FREEZE_1) && Rand() < 30 &&
+                opponent->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(DEEP_FREEZE_1), 0, me) && (opponent->IsFrozen() || me->HasAuraType(SPELL_AURA_ABILITY_IGNORE_AURASTATE)))
+            {
+                if (doCast(opponent, GetSpell(DEEP_FREEZE_1)))
+                    return;
+            }
+            //Flamestrike (instant cast only)
+            if (/*fbCasted && */IsSpellReady(FLAMESTRIKE_1, diff) && dist < CalcSpellMaxRange(FLAMESTRIKE_1) && Rand() < 80 &&
+                me->HasAura(FIRESTARTER_BUFF))
+            {
+                if (doCast(opponent, GetSpell(FLAMESTRIKE_1)))
+                    return;
+            }
+            //Blizzard
+            if (IsSpellReady(BLIZZARD_1, diff) && !JumpingOrFalling() && Rand() < 50)
+            {
+                if (Unit* blizztarget = FindAOETarget(CalcSpellMaxRange(BLIZZARD_1)))
+                {
+                    if (doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                        return;
+                }
+
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Arcane Missiles (special condition for BWL)
+            //if (IsSpellReady(ARCANEMISSILES_1, diff) && dist < CalcSpellMaxRange(ARCANEMISSILES_1) &&
+            //    ((opponent->GetTypeId() == TYPEID_UNIT && opponent->GetEntry() == CREATURE_ENTRY_CHROMAGGUS) || (b_attackers.empty() && Rand() < 3)))
+            //{
+            //    if (doCast(opponent, GetSpell(ARCANEMISSILES_1)))
+            //        return;
+            //}
+            //Ice Lance (no cd, only GCD)
+            if (fbCasted && (!me->GetMap()->IsDungeon() || opponent->IsControlledByPlayer()) &&
+                IsSpellReady(ICE_LANCE_1, diff) && dist < CalcSpellMaxRange(ICE_LANCE_1) &&
+                (opponent->IsFrozen() || me->HasAuraType(SPELL_AURA_ABILITY_IGNORE_AURASTATE)))
+            {
+                if (doCast(opponent, GetSpell(ICE_LANCE_1)))
+                    return;
+            }
+            //Fireball or Frostfire Bolt (instant cast or combustion use up)
+            if (/*fbCasted && */IsSpellReady(FROSTFIREBOLT, diff) && dist < CalcSpellMaxRange(FROSTFIREBOLT) && Rand() < 150 &&
+                ((((CCed(opponent, true) || b_attackers.empty()) && me->HasAura(COMBUSTION_BUFF)) || me->HasAura(BRAIN_FREEZE_BUFF)) ||
+                !GetSpell(FROSTBOLT_1))) //level 1-3
+            {
+                if (doCast(opponent, GetSpell(FROSTFIREBOLT)))
+                    return;
+            }
+            //Main rotation
+            if (IsSpellReady(FROSTFIREBOLT, diff) && _spec == BOT_SPEC_MAGE_FIRE && dist < CalcSpellMaxRange(FROSTFIREBOLT))
+            {
+                if (doCast(opponent, GetSpell(FROSTFIREBOLT)))
+                    return;
+            }
+            if (IsSpellReady(FROSTBOLT_1, diff) && _spec == BOT_SPEC_MAGE_FROST && dist < CalcSpellMaxRange(FROSTBOLT_1))
+            {
+                if (doCast(opponent, GetSpell(FROSTBOLT_1)))
+                    return;
+            }
+
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == SHOOT_WAND && shot->m_targets.GetUnitTarget() != opponent)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (IsSpellReady(SHOOT_WAND, diff) && me->GetDistance(opponent) < 30 && GetEquips(BOT_SLOT_RANGED) &&
+                doCast(opponent, SHOOT_WAND))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                poly = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPolymorph(uint32 diff)
+        {
+            if (poly == false && IsSpellReady(POLYMORPH_1, diff) && !IsCasting())
+            {
+                if (Unit* target = FindPolyTarget(CalcSpellMaxRange(POLYMORPH_1)))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+            if (Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff) && GetManaPCT(me) < 15 && uint8(me->getAttackers().size()) < (shielded ? 3 : 1))
+                {
+                    if (doCast(me, GetSpell(EVOCATION_1)))
+                        return;
+                }
+                if (manaGemCharges > 0 && GetManaPCT(me) < 50 && IsSpellReady(MANA_GEM_1, diff, false))
+                {
+                    if (doCast(me, GetSpell(MANA_GEM_1)))
+                        return;
+                }
+                if (IsPotionReady() && GetManaPCT(me) < 40)
+                    DrinkPotion(true);
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (!me->IsAlive())
+                return;
+            if (HasBotCommandState(BOT_COMMAND_STAY) || me->IsMounted())
+                return;
+            if (!IsSpellReady(BLINK_1, diff) || IsCasting() || Rand() > 70)
+                return;
+
+            if (!IAmFree())
+            {
+                if (!me->IsInCombat() && me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 35) &&
+                    me->HasInArc(M_PI*0.67f, master))
+                {
+                    if (doCast(me, GetSpell(BLINK_1)))
+                        return;
+                }
+            }
+            if (me->IsInCombat() && !me->getAttackers().empty() && HasRole(BOT_ROLE_RANGED))
+            {
+                bool cast = me->HasAuraWithMechanic((1<<MECHANIC_STUN)|(1<<MECHANIC_ROOT));
+                Unit* u = nullptr;
+                if (!cast)
+                {
+                    u = me->SelectNearestTarget(7);
+                    cast = (u && u->GetVictim() == me && u->IsWithinLOSInMap(me));
+                }
+                if (!cast)
+                {
+                    u = (*me->getAttackers().begin());
+                    cast = (u && (!CCed(u, true) || me->getAttackers().size() > 1) && u->GetDistance(me) < 5.f &&
+                        u->IsWithinLOSInMap(me));
+                }
+                if (cast)
+                {
+                    if (u)
+                    {
+                        //turn away from target
+                        me->AttackStop();
+                        //me->SetFacingTo(me->GetAbsoluteAngle(u) + M_PI);
+                        me->SetOrientation(me->GetAbsoluteAngle(u) + M_PI);
+                    }
+                    if (doCast(me, GetSpell(BLINK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckFocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || IAmFree() || me->GetLevel() < 20 || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUS_MAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 3))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group const* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->GetPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                        target = master;
+                }
+                else
+                {
+                    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->IsAlive()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->GetPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    //damaging bots
+                    if (!target)
+                    {
+                        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || !cre->IsAlive() ||
+                                    cre->GetPowerType() != POWER_MANA || cre->GetBotAI()->HasRole(BOT_ROLE_TANK) ||
+                                    cre->GetBotClass() == BOT_CLASS_BM || cre->GetBotClass() == BOT_CLASS_HUNTER ||
+                                    cre->GetBotClass() == BOT_CLASS_SPELLBREAKER || cre->GetBotClass() == BOT_CLASS_DARK_RANGER)
+                                    continue;
+                                if (cre->GetBotAI()->HasRole(BOT_ROLE_DPS) && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    //any bot
+                    if (!target)
+                    {
+                        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || !cre->IsAlive() ||
+                                    cre->GetPowerType() != POWER_MANA || cre->GetBotAI()->HasRole(BOT_ROLE_TANK) ||
+                                    cre->GetBotClass() == BOT_CLASS_BM || cre->GetBotClass() == BOT_CLASS_HUNTER ||
+                                    cre->GetBotClass() == BOT_CLASS_SPELLBREAKER || cre->GetBotClass() == BOT_CLASS_DARK_RANGER)
+                                    continue;
+                                if (me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000; //fail
+        }
+
+        void CheckIceBlock(uint32 diff)
+        {
+            if (!me->IsAlive() || GC_Timer > diff || !GetSpell(ICE_BLOCK_1) || Rand() > 60 || IsTank())
+                return;
+
+            if (iceblockCheckTimer <= diff)
+            {
+                if (me->getAttackers().empty() && (!me->IsInCombat() || (GetManaPCT(me) > 45 && GetHealthPCT(me) > 80)))
+                {
+                    me->RemoveAurasDueToSpell(GetSpell(ICE_BLOCK_1));
+                    return;
+                }
+                iceblockCheckTimer = std::numeric_limits<uint32>::max();
+            }
+
+            if (!IsSpellReady(ICE_BLOCK_1, diff))
+                return;
+
+            if (me->IsInCombat() && !me->getAttackers().empty() &&
+                (CCed(me, true) || me->getAttackers().size() > 2 || GetHealthPCT(me) < 40))
+            {
+                if (doCast(me, GetSpell(ICE_BLOCK_1)))
+                    return;
+            }
+        }
+
+        void CheckShield(uint32 diff)
+        {
+            //TODO: Mana Shield
+            if (!GetSpell(ICE_BARRIER_1))
+                return;
+
+            if (shieldCheckTimer <= diff)
+            {
+                shieldCheckTimer = 1500;
+                shielded = me->HasAura(GetSpell(ICE_BARRIER_1));
+            }
+
+            if (shielded || !IsSpellReady(ICE_BARRIER_1, diff) || IsCasting())
+                return;
+
+            if ((me->IsInCombat() && me->GetMap()->Instanceable()) ||
+                !me->getAttackers().empty() || GetHealthPCT(me) < 90)
+            {
+                if (doCast(me, GetSpell(ICE_BARRIER_1)))
+                    return;
+            }
+        }
+
+        void CheckWard(uint32 diff)
+        {
+            if ((!me->IsInCombat() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                !IsSpellReady(FROST_WARD_1, diff) || IsCasting())
+                return;
+
+            uint32 FROSTWARD = canFrostWard ? GetSpell(FROST_WARD_1) : 0;
+            uint32 FIREWARD = canFireWard ? GetSpell(FIRE_WARD_1) : 0;
+
+            if (FIREWARD && doCast(me, FIREWARD))
+                return;
+
+            if (FROSTWARD && doCast(me, FROSTWARD))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Shatter
+            //SHATTER IS HANDLED IN Unit::isSpCrit()
+
+            //Arcane Potency: 15%/30% additional crit chance for All spells
+            if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                crit_chance += 30.f;
+            else if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                crit_chance += 15.f;
+
+            //Combustion: 10% additional critical chance for fire spells per stack
+            if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                    crit_chance += float(combustion->GetStackAmount() * 10);
+
+            //Incineration: 6% additional crit chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+            if (lvl >= 10 &&
+                (baseId == FIRE_BLAST_1 || /*baseId == SCORCH_1 ||
+                baseId == ARCANE_BLAST_1 || */baseId == CONE_OF_COLD_1))
+                crit_chance += 6.f;
+            //World In Flames: 6% additional critical chance for Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+            if (lvl >= 15 &&
+                (baseId == FLAMESTRIKE_1 || baseId == PYROBLAST_1 ||
+                baseId == BLAST_WAVE_1 || baseId == DRAGON_BREATH_1 ||
+                baseId == BLIZZARD_DAMAGE_1/* || spellId == ARCANEXPLOSION*/ ||
+                baseId == LIVING_BOMB_1 || baseId == LIVING_BOMB_DAMAGE_1))
+                crit_chance += 6.f;
+            //Improved Scorch part 1: 3% additional critical chance for Scorch, Fireball and Frostfire Bolt
+            if (lvl >= 20 && (/*baseId == SCORCH_1 || */baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1))
+                crit_chance += 3.f;
+            //Critical Mass: 6% additional critical chance for Fire spells
+            if ((_spec == BOT_SPEC_MAGE_FIRE) && lvl >= 30 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                crit_chance += 6.f;
+            //Winter's chill part 1: 3% additional crit chance for Frostbolt
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 35 && baseId == FROSTBOLT_1)
+                crit_chance += 3.f;
+
+            //Glyph of Frostfire Bolt part 2: 2% additional critical chance for Frostfire Bolt
+            if (/*lvl >= 75 && */baseId == FROSTFIRE_BOLT_1)
+                crit_chance += 2.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Burnout: 50% additional crit damage bonus for All spells
+                //well it's gonna be a little too much eh? skipped
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.334f;
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 55)
+                    pctbonus += 0.334f;
+                //Combustion: 50% additional crit damage bonus for Fire spells
+                if ((SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()) && me->HasAura(COMBUSTION_1))
+                    pctbonus += 0.334f;
+            }
+
+            //Spell Impact: 6% bonus damage for Arcne Explosion, Arcane Blast, Scorch, Fireball, Ice Lance and Cone of Cold
+            if (lvl >= 20 &&
+                (/*baseId == ARCANE_EXPLOSION_1 || baseId == ARCANE_BLAST_1 ||
+                baseId == SCORCH_1 || */baseId == FIREBALL_1 ||
+                baseId == ICE_LANCE_1 || baseId == CONE_OF_COLD_1))
+                pctbonus += 0.06f;
+            //Piercing Ice: 6% bonus damage for Frost spells
+            if (lvl >= 20 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.06f;
+            //Playing with Fire part 1: 3% bonus damage for all spells
+            if ((_spec == BOT_SPEC_MAGE_FIRE) && lvl >= 30)
+                pctbonus += 0.03f;
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 30 && baseId == CONE_OF_COLD_1)
+                pctbonus += 0.35f;
+            //Arcane Instability part 1: 3% bonus damage for all spells
+            if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 35)
+                pctbonus += 0.03f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if ((_spec == BOT_SPEC_MAGE_FIRE) && lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+            //Molten Fury: 12% bonus damage for All spells against target with less than 35% hp
+            if ((_spec == BOT_SPEC_MAGE_FIRE) &&
+                lvl >= 40 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.12f;
+            //Arctic Winds part 1: 5% bonus damage for Frost spells
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 40 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.05f;
+            //Empowered Fire part 1: 15% bonus damage (from spellpower) for Fireball, Frostfire Bolt and Pyroblast
+            if ((_spec == BOT_SPEC_MAGE_FIRE) &&
+                lvl >= 45 && (baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1 || baseId == PYROBLAST_1))
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Empowered Frostbolt part 1: 10% of spellpower to Frostbolt damage
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 45 && baseId == FROSTBOLT_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Chilled to the Bone part 1: 5% bonus damage for Frostbolt, Frostfire Bolt and Ice Lance
+            if ((_spec == BOT_SPEC_MAGE_FROST) &&
+                lvl >= 55 && (baseId == FROSTBOLT_1 || baseId == FROSTFIRE_BOLT_1 || baseId == ICE_LANCE_1))
+                pctbonus += 0.05f;
+
+            //Glyph of Frostfire Bolt part 1: 2% bonus damage for Frostfire Bolt
+            if (/*lvl >= 75 && */baseId == FROSTFIRE_BOLT_1)
+                pctbonus += 0.02f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Firestarter part 2: -100% mana cost for Flamestrike
+            if (baseId == FLAMESTRIKE_1)
+                if (me->HasAura(FIRESTARTER_BUFF))
+                    pctbonus += 1.0f;
+            //Brain Freeze buff: -100% mana cost for Fireball and Frostfire Bolt while active
+            //we can check spellFamilyFlags or just use ids, going easy way here
+            if (baseId == FROSTFIRE_BOLT_1 || baseId == FIREBALL_1)
+                if (me->HasAura(BRAIN_FREEZE_BUFF))
+                    pctbonus += 1.0f;
+            //Clearcasting: -100% mana cost for damaging spells
+            if (AuraEffect const* eff = me->GetAuraEffect(ARCANE_CONCENTRATION_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //pct mods
+            //Precision part 1: -3% mana cost for All spells
+            if (lvl >= 15)
+                pctbonus += 0.03f;
+            //Frost Channeling: -10% mana cost for all spells
+            if (lvl >= 25)
+                pctbonus += 0.1f;
+            //Improved Blink part 1: -50% mana cost for Blink
+            if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 30 && baseId == BLINK_1)
+                pctbonus += 0.5f;
+
+            //Glyph of Arcane Intellect: -50% mana cost for Arcane Intellect/Brilliance
+            if (lvl >= 15 && baseId == ARCANEINTELLECT_1)
+                pctbonus += 0.5f;
+            //Glyph of Blast Wave part 1: -15% mana cost for Blast Wave
+            if (lvl >= 70 && baseId == BLAST_WAVE_1)
+                pctbonus += 0.15f;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Firestarter part 1: -100% cast time for Flamestrike
+            if (baseId == FLAMESTRIKE_1)
+                if (me->HasAura(FIRESTARTER_BUFF))
+                    timebonus += casttime;
+            //Brain Freeze: -100% cast time for Fireball and Frostfire Bolt
+            //we can check spellFamilyFlags or just use ids, going easy way here
+            if (baseId == FROSTFIRE_BOLT_1 || baseId == FIREBALL_1)
+                if (me->HasAura(BRAIN_FREEZE_BUFF))
+                    timebonus += casttime;
+            //Hot Streak: -100% cast time for Pyroblast
+            if (baseId == PYROBLAST_1)
+                if (me->HasAura(HOT_STREAK_BUFF))
+                    timebonus += casttime;
+
+            //flat mods
+            //Improved Fireball: -0.5 sec cast time for Fireball (Frostfire too for bot)
+            if (lvl >= 10 && (baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1))
+                timebonus += 500;
+            //Improved Frostbolt: -0.5 sec cast time for Frostbolt
+            if (lvl >= 10 && baseId == FROSTBOLT_1)
+                timebonus += 500;
+            //Empowered Frostbolt part 2: -0.2 sec cast time for Frostbolt
+            if (lvl >= 45 && baseId == FROSTBOLT_1)
+                timebonus += 200;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Ice Floes: -20% cooldown for Frost Nova, Cone of Cold, Ice Block and Icy Veins
+            if (lvl >= 10 &&
+                (baseId == FROST_NOVA_1 || baseId == CONE_OF_COLD_1 || baseId == ICE_BLOCK_1 || baseId == ICY_VEINS_1))
+                pctbonus += 0.2f;
+            //Cold as Ice: -20% cooldown for Ice Barrier, Cold Snap and Summon Water Elemental
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 35 &&
+                (baseId == ICE_BARRIER_1/* || baseId == COLD_SNAP_1*/ || baseId == SUMMON_WATER_ELEMENTAL_1))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Improved Fire Blast: -2 sec cooldown for Fire Blast
+            if (lvl >= 10 && baseId == FIRE_BLAST_1)
+                timebonus += 2000;
+            //Arcane Flows part 2: -2 min cooldown for Evocation
+            if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 45 && baseId == EVOCATION_1)
+                timebonus += 120000;
+            //Glyph of Water Elemental: -30 sec cooldown for Summon Water Elemental
+            if (lvl >= 50 && baseId == SUMMON_WATER_ELEMENTAL_1)
+                timebonus += 30000;
+
+            ////Pyroblast (special): ensure no double pyroblast casts
+            //if (baseId == PYROBLAST_1)
+            //    timebonus -= 3000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Increased Area (AhnQ set bonus?) 23549
+            if (lvl >= 60 && (spellInfo->SpellFamilyFlags[0] & 0x1084))
+                pctbonus += 0.25f;
+            //Arctic Reach
+            if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x240))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Blink
+            if (lvl >= 20 && baseId == BLINK_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Arctic Reach: +20% range for Frost Spells
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x200A0) || (spellInfo->SpellFamilyFlags[1] & 0x100000)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Magic Attunement: +6 yd range for Arcane Spells
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0xA1006C00) || (spellInfo->SpellFamilyFlags[1] & 0x8010)))
+                flatbonus += 6.f;
+            //Flame Throwing: +6 yd range for Fire Spells
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x400017) || (spellInfo->SpellFamilyFlags[1] & 0x20000)))
+                flatbonus += 6.f;
+
+            //Glyph of Deep Freeze
+            if (lvl >= 60 && baseId == DEEP_FREEZE_1)
+                flatbonus += 10.f;
+
+            //Mage Fire Blast Range Bonus (33066): +6 yd range for Fire Blast
+            if (lvl >= 60 && baseId == FIRE_BLAST_1)
+                flatbonus += 6.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //DEBUG
+            //if (!IAmFree())
+            //{
+            //    std::ostringstream msg;
+            //    msg << "OnClassSpellGo: " << spellInfo->SpellName[0] << " (" << spellId << ")!";
+            //    BotWhisper(msg.str().c_str());
+            //}
+
+            if (baseId == SUMMON_WATER_ELEMENTAL_1)
+                SummonBotPet();
+
+            //Mana gem conjure and use
+            if (baseId == CONJURE_MANA_GEM_1)
+            {
+                //ItemTemplate const* gem = sObjectMgr->GetItemTemplate(spellInfo->Effects[0].ItemType);
+                //ASSERT(gem);
+                //manaGemCharges = uint8(abs(gem->Spells[1].SpellCharges)); //at index 1
+
+                //Do not bother with this crap
+                manaGemCharges = 3;
+            }
+            if (baseId == MANA_GEM_1)
+            {
+                //spell cd is 1 min, item cd is 2 min, correct here
+                SetSpellCooldown(MANA_GEM_1, 120000);
+                manaGemCharges -= 1;
+            }
+
+            //special cases
+            //Pyroblast (special): ensure no double pyroblast casts
+            if (baseId == PYROBLAST_1)
+                SetSpellCooldown(PYROBLAST_1, 3000);
+
+            if (baseId == ICE_BLOCK_1)
+            {
+                //Glyph of Ice Block: reset Frost Nova cd
+                ResetSpellCooldown(FROST_NOVA_1);
+                iceblockCheckTimer = 4000;
+            }
+
+            //check for minor rotation thingy (skip common triggered on-hit spells
+            /*if (spellId != FROSTBITE_TRIGGERED && spellId != WINTERS_CHILL_TRIGGERED && spellId != IGNITE_TRIGGERED &&
+                spellId != ARCANE_CONCENTRATION_BUFF && spellId != ARCANE_POTENCY_BUFF1 && spellId != ARCANE_POTENCY_BUFF2 &&
+                spellId != FIRESTARTER_BUFF && spellId != BRAIN_FREEZE_BUFF && spellId != HOT_STREAK_BUFF)*/
+                fbCasted = (baseId == FROSTBOLT_1 || baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1);
+
+            //Handle clearcasting
+            if (AuraEffect const* eff = me->GetAuraEffect(ARCANE_CONCENTRATION_BUFF, 0, me->GetGUID()))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                {
+                    //if (int32 cost = spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+                    {
+                        //me->ModifyPower(POWER_MANA, cost > 0 ? cost : 0);
+                        me->RemoveAurasDueToSpell(ARCANE_CONCENTRATION_BUFF);
+                    }
+                    //arcane potency has the same affection (damaging spells only)
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1);
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2);
+                }
+            }
+            //Firestarter
+            if (baseId == FLAMESTRIKE_1/* && me->HasAura(FIRESTARTER_BUFF)*/)
+                me->RemoveAurasDueToSpell(FIRESTARTER_BUFF);
+            //Brain Freeze (Fireball!)
+            if (baseId == FROSTFIRE_BOLT_1 || baseId == FIREBALL_1)
+                me->RemoveAurasDueToSpell(BRAIN_FREEZE_BUFF);
+            //Hot Streak
+            if (baseId == PYROBLAST_1)
+                me->RemoveAurasDueToSpell(HOT_STREAK_BUFF);
+            //TODO: Presence of mind
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (aftercastTargetGuid != ObjectGuid::Empty)
+            {
+                //only players for now
+                if (!aftercastTargetGuid.IsPlayer())
+                {
+                    aftercastTargetGuid = ObjectGuid::Empty;
+                    return;
+                }
+
+                Player* pTarget = ObjectAccessor::GetPlayer(*me, aftercastTargetGuid);
+                aftercastTargetGuid = ObjectGuid::Empty;
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, nullptr, nullptr, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, 0);
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
+                                        continue;
+                                    }
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == ARCANEINTELLECT_1)
+            {
+                if (Aura* arc = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    arc->SetDuration(dur);
+                    arc->SetMaxDuration(dur);
+                }
+            }
+
+            //Spells with chill effect
+            //chill amount by spell family mask
+            //00100000 00000000 00000000 chilled (blizzard)
+            //00000200 00000000 00000000 conecold
+            //00000020 00000000 00000000 frbolt
+            //00000000 00001000 00000008 ffbolt
+            //00100220 00001000 00000000 permafrst
+            //00100220 00001000 00000000 cttbn
+            if (spell->SpellFamilyName == SPELLFAMILY_MAGE &&
+                ((spell->SpellFamilyFlags[0] & 0x100220) || (spell->SpellFamilyFlags[1] & 0x1000)))
+            {
+                //frostbolt, cone of cold, blizzard chill, frostfire bolt
+                Aura* chill = target->GetAura(spellId, me->GetGUID());
+                if (chill)
+                {
+                    //Permafrost: chill effects duration + 3 sec
+                    if (lvl >= 15)
+                    {
+                        uint32 dur = chill->GetDuration() + 3000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                    //chill effect is at index 0
+                    AuraEffect* chillEff = chill->GetEffect(0);
+                    if (chillEff)
+                    {
+                        int32 amount = chillEff->GetAmount();
+                        if (lvl >= 15)
+                            amount -= 10; //permafrost
+                        if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 55)
+                            amount -= 10; //chilled to the bone
+                        chillEff->ChangeAmount(amount);
+                    }
+                }
+            }
+
+            //Glyph of Ice Barrier: 30% increased effect
+            if (baseId == ICE_BARRIER_1 && lvl >= 46)
+            {
+                AuraEffect* barr = me->GetAuraEffect(spellId, 0);
+                if (barr)
+                    barr->ChangeAmount(barr->GetAmount() * 1.3f);
+            }
+
+            //Custom things
+            if (baseId == POLYMORPH_1)
+            {
+                poly = true;
+                polyCheckTimer = 2000;
+            }
+
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                //if (baseId == FROSTBOLT_1 && urand(1,100) <= 10)
+                //    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            //uint32 spellId = spell->Id;
+
+            //Ward helper
+            if (!canFrostWard && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_FROST) &&
+                (spell->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) || spell->HasAura(SPELL_AURA_PERIODIC_DAMAGE)))
+                canFrostWard = true;
+            if (!canFireWard && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE) &&
+                (spell->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) || spell->HasAura(SPELL_AURA_PERIODIC_DAMAGE)))
+                canFireWard = true;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_WATER_ELEMENTAL;
+
+            Position pos;
+
+            //glyphed: permanent
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_MANUAL_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 2, me->GetOrientation());
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, SUMMON_WATER_ELEMENTAL_1);
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_WATER_ELEMENTAL;
+                default:
+                    return 0;
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(FROSTBOLT_1) : 20.f;
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            iceblockCheckTimer = 0;
+            shieldCheckTimer = 0;
+            manaGemCharges = 0;
+
+            poly = false;
+            shielded = false;
+            fbCasted = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+            if (iceblockCheckTimer > diff)          iceblockCheckTimer -= diff;
+            if (shieldCheckTimer > diff)            shieldCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            //bool isArca = _spec == BOT_SPEC_MAGE_ARCANE;
+            bool isFire = _spec == BOT_SPEC_MAGE_FIRE;
+            bool isFros = _spec == BOT_SPEC_MAGE_FROST;
+
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(AMPLIFYMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            InitSpellMap(INVISIBILITY_1);
+            InitSpellMap(FIRE_BLAST_1);
+            InitSpellMap(FLAMESTRIKE_1);
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROST_NOVA_1);
+            InitSpellMap(CONE_OF_COLD_1);
+            InitSpellMap(BLIZZARD_1);
+            InitSpellMap(FROST_ARMOR_1);
+            InitSpellMap(ICE_ARMOR_1);
+            InitSpellMap(MOLTEN_ARMOR_1);
+            InitSpellMap(ICE_BLOCK_1);
+ /*Special*/InitSpellMap(BLIZZARD_DAMAGE_1); //important
+ /*Special*/InitSpellMap(LIVING_BOMB_DAMAGE_1); //important
+            InitSpellMap(SLOW_FALL_1);
+            InitSpellMap(ICE_LANCE_1);
+            InitSpellMap(FROST_WARD_1);
+            InitSpellMap(FIRE_WARD_1);
+
+ /*Special*/InitSpellMap(CONJURE_MANA_GEM_1);
+ /*Special*/InitSpellMap(MANA_GEM_1);
+
+            InitSpellMap(RITUAL_OF_REFRESHMENT_1); //not casted
+
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUS_MAGIC_1) : RemoveSpell(FOCUS_MAGIC_1);
+
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 30 && isFire ? InitSpellMap(BLAST_WAVE_1) : RemoveSpell(BLAST_WAVE_1);
+  /*Talent*/lvl >= 40 && isFire ? InitSpellMap(DRAGON_BREATH_1) : RemoveSpell(DRAGON_BREATH_1);
+  /*Talent*/lvl >= 50 && isFire ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+  /*Talent*/lvl >= 60 && isFire ? InitSpellMap(LIVING_BOMB_1) : RemoveSpell(LIVING_BOMB_1);
+
+  /*Talent*/lvl >= 20 ? InitSpellMap(ICY_VEINS_1) : RemoveSpell(ICY_VEINS_1);
+  /*Talent*/lvl >= 40 && isFros ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+  /*Talent*/lvl >= 50 && isFros ? InitSpellMap(SUMMON_WATER_ELEMENTAL_1) : RemoveSpell(SUMMON_WATER_ELEMENTAL_1);
+  /*Talent*/lvl >= 60 && isFros ? InitSpellMap(DEEP_FREEZE_1) : RemoveSpell(DEEP_FREEZE_1);
+
+            InitSpellMap(FROSTFIRE_BOLT_1);
+            InitSpellMap(FIREBALL_1);
+            FROSTFIREBOLT = GetSpell(FROSTFIRE_BOLT_1) ? FROSTFIRE_BOLT_1 : FIREBALL_1;
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isArca = _spec == BOT_SPEC_MAGE_ARCANE;
+            bool isFire = _spec == BOT_SPEC_MAGE_FIRE;
+            bool isFros = _spec == BOT_SPEC_MAGE_FROST;
+
+            RefreshAura(ARCANE_CONCENTRATION, level >= 15 ? 1 : 0);
+            RefreshAura(ARCANE_MEDITATION, level >= 25 ? 1 : 0); //mana regen 1
+            RefreshAura(TORMENT_THE_WEAK, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL2, isArca && level >= 26 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL1, isArca && level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY2, isArca && level >= 36 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY1, isArca && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(ARCANE_EMPOWERMENT, isArca && level >= 40 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION3, isArca && level >= 42 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION2, isArca && level >= 41 && level < 42 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION1, isArca && level >= 40 && level < 41 ? 1 : 0);
+
+            RefreshAura(IGNITE, level >= 15 ? 1 : 0);
+            RefreshAura(BURNING_DETERMINATION, level >= 15 ? 1 : 0);
+            RefreshAura(IMPACT, level >= 20 ? 1 : 0);
+            RefreshAura(MOLTEN_SHIELDS, level >= 25 ? 1 : 0);
+            RefreshAura(MASTER_OF_ELEMENTS, level >= 25 ? 1 : 0);
+            RefreshAura(BLAZING_SPEED, isFire && level >= 35 ? 1 : 0);
+            RefreshAura(PYROMANIAC, isFire && level >= 40 ? 1 : 0); //mana regen 2
+            RefreshAura(FIRESTARTER2, isFire && level >= 51 ? 1 : 0);
+            RefreshAura(FIRESTARTER1, isFire && level >= 50 && level < 51 ? 1 : 0);
+            RefreshAura(HOT_STREAK, isFire && level >= 50 ? 1 : 0);
+
+            RefreshAura(FROSTBITE3, level >= 12 ? 1 : 0);
+            RefreshAura(FROSTBITE2, level >= 11 && level < 12 ? 1 : 0);
+            RefreshAura(FROSTBITE1, level >= 10 && level < 11 ? 1 : 0);
+            RefreshAura(FROST_WARDING, level >= 15 ? 1 : 0);
+            RefreshAura(IMPROVED_BLIZZARD, level >= 20 ? 1 : 0);
+            RefreshAura(SHATTER3, level >= 27 ? 1 : 0);
+            RefreshAura(SHATTER2, level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(SHATTER1, level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL3, isFros && level >= 37 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL2, isFros && level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL1, isFros && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SHATTERED_BARRIER, isFros && level >= 45 ? 1 : 0);
+            //RefreshAura(ARCTIC_WINDS, isFros && level >= 45 ? 1 : 0); //only miss chance
+            RefreshAura(FINGERS_OF_FROST, isFros && level >= 45 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE3, isFros && level >= 53 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE2, isFros && level >= 51 && level < 52 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE1, isFros && level >= 50 && level < 51 ? 1 : 0);
+
+            RefreshAura(GLYPH_POLYMORPH, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPG_REMOVE_CURSE, level >= 18 ? 1 : 0);
+            RefreshAura(GLYPH_ICY_VEINS, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_LIVING_BOMB, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_ICE_LANCE, level >= 66 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case AMPLIFYMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUS_MAGIC_1:
+                case ICE_ARMOR_1:
+                case ICE_BARRIER_1:
+                case COMBUSTION_1:
+                case ICY_VEINS_1:
+                case BLAST_WAVE_1:
+                case FLAMESTRIKE_1:
+                case FROST_NOVA_1:
+                case BLIZZARD_1:
+                case ICE_BLOCK_1:
+                case INVISIBILITY_1:
+                case SLOW_FALL_1:
+                case CONJURE_MANA_GEM_1:
+                case SUMMON_WATER_ELEMENTAL_1:
+                    return true;
+                case FROST_ARMOR_1:
+                    return !GetSpell(ICE_ARMOR_1);
+                //case MANA_GEM_1:
+                //    return manaGemCharges > 0;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 FROSTFIREBOLT;
+        //Timers
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer, iceblockCheckTimer, shieldCheckTimer;
+        //Counters
+/*exc.*/uint8 manaGemCharges;
+        //Check
+/*exc.*/bool poly, shielded, fbCasted;
+/*exc.*/bool canFrostWard, canFireWard;
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..c8f4201
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,2709 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+//#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - Around 95%
+TODO:
+*/
+
+enum PaladinBaseSpells// all orignals
+{
+    FLASH_OF_LIGHT_1                    = 19750,
+    HOLY_LIGHT_1                        = 635,
+    LAY_ON_HANDS_1                      = 633,
+    REDEMPTION_1                        = 7328,
+    HAND_OF_FREEDOM_1                   = 1044,
+    SACRED_SHIELD_1                     = 53601,
+    HOLY_SHOCK_1                        = 20473,
+    CLEANSE_1                           = 4987,
+    HAND_OF_PROTECTION_1                = 1022,
+    HAND_OF_SALVATION_1                 = 1038,
+    HAND_OF_SACRIFICE_1                 = 6940,
+    SEAL_OF_VENGEANCE_1                 = 31801,
+    SEAL_OF_CORRUPTION_1                = 53736,
+    SEAL_OF_COMMAND_1                   = 20375,
+    SEAL_OF_LIGHT_1                     = 20165,
+    SEAL_OF_RIGHTEOUSNESS_1             = 21084,
+    SEAL_OF_WISDOM_1                    = 20166,
+    SEAL_OF_JUSTICE_1                   = 20164,
+    DIVINE_SACRIFICE_1                  = 64205,
+    HAND_OF_RECKONING_1                 = 62124,
+    RIGHTEOUS_DEFENSE_1                 = 31789,
+    DIVINE_PLEA_1                       = 54428,
+    REPENTANCE_1                        = 20066,
+    TURN_EVIL_1                         = 10326,
+    CRUSADER_STRIKE_1                   = 35395,
+    JUDGEMENT_OF_LIGHT_1                = 20271,
+    JUDGEMENT_OF_WISDOM_1               = 53408,
+    JUDGEMENT_OF_JUSTICE_1              = 53407,
+    CONSECRATION_1                      = 26573,
+    HAMMER_OF_JUSTICE_1                 = 853,
+    DIVINE_STORM_1                      = 53385,
+    HAMMER_OF_WRATH_1                   = 24275,
+    EXORCISM_1                          = 879,
+    HOLY_WRATH_1                        = 2812,
+    AVENGING_WRATH_1                    = 31884,
+    RIGHTEOUS_FURY_1                    = 25780,
+    HOLY_SHIELD_1                       = 20925,
+    AVENGERS_SHIELD_1                   = 31935,
+    HAMMER_OF_THE_RIGHTEOUS_1           = 53595,
+    SHIELD_OF_RIGHTEOUSNESS_1           = 53600,
+    BLESSING_OF_MIGHT_1                 = 19740,
+    BLESSING_OF_WISDOM_1                = 19742,
+    BLESSING_OF_KINGS_1                 = 20217,
+    BLESSING_OF_SANCTUARY_1             = 20911,
+    DEVOTION_AURA_1                     = 465,
+    CONCENTRATION_AURA_1                = 19746,
+    FIRE_RESISTANCE_AURA_1              = 19891,
+    FROST_RESISTANCE_AURA_1             = 19888,
+    SHADOW_RESISTANCE_AURA_1            = 19876,
+    RETRIBUTION_AURA_1                  = 7294,
+    CRUSADER_AURA_1                     = 32223,
+
+    DIVINE_INTERVENTION_1               = 19752,
+    AURA_MASTERY_1                      = 31821,
+    DIVINE_FAVOR_1                      = 20216,
+    DIVINE_ILLUMINATION_1               = 31842,
+    BEACON_OF_LIGHT_1                   = 53563,
+
+    DIVINE_PROTECTION_1                 = 498,
+    DIVINE_SHIELD_1                     = 642,
+
+    PURIFY_1                            = 1152
+};
+enum PaladinPassives
+{
+//Talents
+    DIVINE_PURPOSE                      = 31872,
+    JUDGEMENTS_OF_THE_PURE              = 54155,
+    JUDGEMENTS_OF_THE_WISE              = 31878,
+    SACRED_CLEANSING                    = 53553,//rank 3
+    RECKONING1                          = 20177,
+    RECKONING2                          = 20179,
+    RECKONING3                          = 20181,
+    RECKONING4                          = 20180,
+    RECKONING5                          = 20182,
+    VINDICATION1                        = 9452,
+    VINDICATION2                        = 26016,
+    PURSUIT_OF_JUSTICE                  = 26023,//rank 2
+    ART_OF_WAR                          = 53488,//rank 2
+    IMPROVED_LAY_ON_HANDS               = 20235,//rank 2
+    FANATICISM                          = 31881,//rank 3
+    RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+    RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+    RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+    VENGEANCE1                          = 20049,//rank 1
+    VENGEANCE2                          = 20056,//rank 2
+    VENGEANCE3                          = 20057,//rank 3
+    SHEATH_OF_LIGHT1                    = 53501,//rank 1
+    SHEATH_OF_LIGHT2                    = 53502,//rank 2
+    SHEATH_OF_LIGHT3                    = 53503,//rank 3
+    ARDENT_DEFENDER                     = 31852,//rank 3
+    ILLUMINATION                        = 20215,//rank 5
+    INFUSION_OF_LIGHT                   = 53576,//rank 2
+    REDOUBT1                            = 20127,//rank 3
+    REDOUBT2                            = 20130,//rank 3
+    REDOUBT3                            = 20135,//rank 3
+    IMPROVED_RIGHTEOUS_FURY             = 20470,//rank 3
+    SHIELD_OF_THE_TEMPLAR               = 53711,//rank 3
+    IMPROVED_DEVOTION_AURA              = 20140,//rank 3
+    IMPROVED_CONCENTRATION_AURA         = 20256,//rank 3
+    SANCTIFIED_RETRIBUTION              = 31869,
+    SWIFT_RETRIBUTION                   = 53648,//rank 3
+    LIGHTS_GRACE                        = 31836,//rank 3
+    DIVINE_GUARDIAN                     = 53530,//rank 3
+    //COMBAT_EXPERTISE                    = 31860,//rank 3
+    CRUSADE                             = 31868,//rank 3
+    ONE_HANDED_WEAPON_SPECIALIZATION    = 20198,//rank 3
+    TWO_HANDED_WEAPON_SPECIALIZATION    = 20113,//rank 3
+    //JUDGEMENTS_OF_THE_JUST              = 53696,//rank 2
+    GUARDED_BY_THE_LIGHT                = 53585,//rank 2
+    TOUCHED_BY_THE_LIGHT                = 53592,//rank 3
+    HEART_OF_THE_CRUSADER               = 20337,//rank 3
+//Glyphs
+    GLYPH_HOLY_LIGHT                    = 54937,
+    GLYPH_SALVATION                     = 63225,
+//Innate
+    JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE  = 60091,
+//other
+    RECUCED_HOLY_LIGHT_CAST_TIME        = 37189,//not a typo
+    //CLEANSE_HEAL_PASSIVE                = 28787
+};
+
+enum PaladinSpecial
+{
+    NOAURA                              = 0,
+    DEVOTIONAURA                        = 1,
+    CONCENTRATIONAURA                   = 2,
+    FIRERESAURA                         = 3,
+    FROSTRESAURA                        = 4,
+    SHADOWRESAURA                       = 5,
+    RETRIBUTIONAURA                     = 6,
+    CRUSADERAURA                        = 7,
+
+    SPECIFIC_BLESSING_WISDOM            = 0x01,
+    SPECIFIC_BLESSING_KINGS             = 0x02,
+    SPECIFIC_BLESSING_SANCTUARY         = 0x04,
+    SPECIFIC_BLESSING_MIGHT             = 0x08,
+    SPECIFIC_BLESSING_MY_BLESSING       = 0x10,
+
+    SPECIFIC_AURA_DEVOTION              = 0x01,
+    SPECIFIC_AURA_CONCENTRATION         = 0x02,
+    SPECIFIC_AURA_FIRE_RES              = 0x04,
+    SPECIFIC_AURA_FROST_RES             = 0x08,
+    SPECIFIC_AURA_SHADOW_RES            = 0x10,
+    SPECIFIC_AURA_RETRIBUTION           = 0x20,
+    SPECIFIC_AURA_CRUSADER              = 0x40,
+    SPECIFIC_AURA_MY_AURA               = 0x80,
+    SPECIFIC_AURA_ALL_AUTOUSE           = (SPECIFIC_AURA_DEVOTION | SPECIFIC_AURA_CONCENTRATION | SPECIFIC_AURA_RETRIBUTION | \
+                                            SPECIFIC_AURA_FIRE_RES | SPECIFIC_AURA_FROST_RES | SPECIFIC_AURA_SHADOW_RES),
+
+    FLASH_OF_LIGHT_HEAL_PERIODIC        = 66922,
+
+    ENLIGHTENMENT_BUFF                  = 43837,
+    INFUSION_OF_LIGHT_BUFF              = 54149,//rank 2
+    THE_ART_OF_WAR_BUFF                 = 59578,//rank 2
+    //FORBEARANCE_AURA                    = 25771,
+
+    LIGHTS_GRACE_BUFF                   = 31834,
+
+    SEAL_OF_JUSTICE_STUN_AURA           = 20170,
+    JUDGEMENTS_OF_THE_JUST_AURA         = 68055, //melee attack speed reduce
+
+    //JUDGEMENT_OF_LIGHT_AURA             = 20185,
+    //JUDGEMENT_OF_WISDOM_AURA            = 20186,
+    //JUDGEMENT_OF_JUSTICE_AURA           = 20184,
+
+    GREATER_BLESSING_OF_MIGHT_1         = 25782,
+    GREATER_BLESSING_OF_WISDOM_1        = 25894,
+    GREATER_BLESSING_OF_KINGS_1         = 25898,
+    GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+    BATTLESHOUT_1                       = 6673,
+
+    HOLY_SHOCK_HEAL_1                   = 25914,
+    ARDENT_DEFENDER_HEAL                = 66235,
+    JUDGEMENT_OF_COMMAND_DAMAGE         = 20467,
+    SPIRITUAL_ATTUNEMENT_ENERGIZE       = 31786,
+    SACRED_SHIELD_AURA_TRIGGERED        = 58597,
+
+    AVENGING_WRATH_MARKER_SPELL         = 61987,
+    IMMUNITY_SHIELD_MARKER_SPELL        = 61988
+};
+
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct paladin_botAI : public bot_ai
+    {
+        paladin_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_PALADIN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void CheckBeacon(uint32 diff)
+        {
+            if (checkBeaconTimer > diff || !IsSpellReady(BEACON_OF_LIGHT_1, diff) || IAmFree() || !master->GetGroup() ||
+                !HasRole(BOT_ROLE_HEAL|BOT_ROLE_RANGED) || IsCasting() || Rand() > 15)
+                return;
+
+            checkBeaconTimer = urand(2000, 5000);
+
+            if (FindAffectedTarget(GetSpell(BEACON_OF_LIGHT_1), me->GetGUID(), 60, 3))
+                return;
+
+            //find tank
+            //stacks
+            std::list<Unit*> tanks;
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsAlive() && player->IsInCombat() && IsTank(player) &&
+                    (!player->getAttackers().empty() || GetHealthPCT(player) < 90) &&
+                    !player->GetAuraEffect(SPELL_AURA_PERIODIC_TRIGGER_SPELL, SPELLFAMILY_PALADIN, 0x0, 0x1000000, 0x0, me->GetGUID()))
+                    tanks.push_back(player);
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    if (itr->second == me)
+                        continue;
+                    if (!gr->IsMember(itr->second->GetGUID()))
+                        continue;
+
+                    Unit* u = itr->second;
+                    if (u->IsInWorld() && u->IsAlive() && u->IsInCombat() && IsTank(u) &&
+                        (!u->getAttackers().empty() || GetHealthPCT(u) < 90) &&
+                        !u->GetAuraEffect(SPELL_AURA_PERIODIC_TRIGGER_SPELL, SPELLFAMILY_PALADIN, 0x0, 0x1000000, 0x0, me->GetGUID()))
+                        tanks.push_back(u);
+                }
+            }
+
+            if (tanks.empty())
+                return;
+
+            Unit* target = tanks.size() == 1 ? *tanks.begin() : Trinity::Containers::SelectRandomContainerElement(tanks);
+            if (doCast(target, GetSpell(BEACON_OF_LIGHT_1)))
+                return;
+        }
+
+        void CheckSacrifice(uint32 diff)
+        {
+            if (!IsSpellReady(DIVINE_SACRIFICE_1, diff) || IAmFree() || me->IsMounted() ||
+                IsTank() || Feasting() || !CanBlock() || IsCasting() || Rand() > 25 || GetHealthPCT(me) < 50)
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (master->IsAlive() && GetHealthPCT(master) < 75 && me->GetDistance(master) < 30 && !master->getAttackers().empty() &&
+                    !master->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                {
+                    if (doCast(me, GetSpell(DIVINE_SACRIFICE_1)))
+                        return;
+                }
+            }
+            else
+            {
+                uint32 attacked = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player const* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->IsAlive() && me->GetDistance(pl) < 30 && !pl->getAttackers().empty() &&
+                        !pl->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                    {
+                        if (++attacked > 3)
+                            break;
+                    }
+
+                    if (!pl->HaveBot())
+                        continue;
+
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature const* bot = it->second;
+                        if (bot && bot->IsInWorld() && me->GetMap() == bot->FindMap() && bot->IsAlive() &&
+                            !bot->IsTempBot() && me->GetDistance(bot) < 30 && !bot->getAttackers().empty() &&
+                            !bot->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                        {
+                            if (++attacked > 3)
+                                break;
+                        }
+                    }
+                }
+
+                if (attacked > 3 && doCast(me, GetSpell(DIVINE_SACRIFICE_1)))
+                    return;
+            }
+
+            SetSpellCooldown(DIVINE_SACRIFICE_1, 1000); //fail
+        }
+
+        void CheckHandOfSacrifice(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_SACRIFICE_1, diff) || IAmFree() || me->IsMounted() ||
+                IsTank() || Feasting() || !CanBlock() || IsCasting() || Rand() > 25 || GetHealthPCT(me) < 50)
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (master->IsAlive() && me->GetDistance(master) < 30 && !master->getAttackers().empty() &&
+                    (master->getAttackers().size() > 2 || GetHealthPCT(master) < 50) &&
+                    !master->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                {
+                    if (doCast(master, GetSpell(HAND_OF_SACRIFICE_1)))
+                        return;
+                }
+            }
+            else
+            {
+                Unit* u = nullptr;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->IsAlive() && me->GetDistance(pl) < 30 && !pl->getAttackers().empty() &&
+                        (pl->getAttackers().size() > 2 || GetHealthPCT(pl) < 50) &&
+                        !pl->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                    {
+                        u = pl;
+                        break;
+                    }
+
+                    if (!pl->HaveBot())
+                        continue;
+
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot->IsAlive() && me->GetDistance(bot) < 30 && !bot->getAttackers().empty() &&
+                            (bot->getAttackers().size() > 2 || GetHealthPCT(bot) < 50) &&
+                            !bot->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                        {
+                            u = bot;
+                            break;
+                        }
+                    }
+                }
+
+                if (u && doCast(u, GetSpell(HAND_OF_SACRIFICE_1)))
+                    return;
+            }
+
+            SetSpellCooldown(HAND_OF_SACRIFICE_1, 2000); //fail
+        }
+
+        void ShieldGroup(uint32 diff)
+        {
+            if (checkShieldTimer > diff || !IsSpellReady(SACRED_SHIELD_1, diff) ||
+                me->IsMounted() || Feasting() || IsCasting() || Rand() > 50)
+                return;
+
+            checkShieldTimer = 1500;
+
+            Unit* u;
+            if (IAmFree())
+            {
+                u = me;
+                if (u->IsInCombat() && (!u->getAttackers().empty() || u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) &&
+                    !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                {
+                    if (doCast(u, GetSpell(SACRED_SHIELD_1)))
+                    {}
+                }
+
+                return;
+            }
+
+            if (IsTank())
+            {
+                if (Rand() > 15)
+                    return;
+            }
+            else if (!HasRole(BOT_ROLE_HEAL) && Rand() > 10)
+                return;
+
+            if (FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 70, 3))
+                return;
+
+            bool foundTank = false;
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                u = master;
+                if (u->IsAlive() && u->IsInCombat() && IsTank(u) && me->GetDistance(u) < 30 &&
+                    !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    foundTank = true;
+
+                if (!foundTank)
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        u = itr->second;
+                        if (u != me && IsTank())
+                            continue;
+                        if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                            u->ToCreature()->IsTempBot() || !IsTank(u) || me->GetDistance(u) > 30 ||
+                            u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                            continue;
+
+                        foundTank = true;
+                        break;
+                    }
+                }
+                if (!foundTank)
+                {
+                    for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                    {
+                        u = *itr;
+                        if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                            !IsTank(u) || me->GetDistance(u) > 30 ||
+                            u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                            continue;
+
+                        foundTank = true;
+                        break;
+                    }
+                }
+                if (!foundTank)
+                {
+                    u = master;
+                    if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                        !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                        foundTank = true;
+                }
+
+                if (foundTank && doCast(u, GetSpell(SACRED_SHIELD_1)))
+                    return;
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                    !IsTank(u) || me->GetDistance(u) > 30 ||
+                    u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    continue;
+
+                foundTank = true;
+                break;
+            }
+            if (!foundTank)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->HaveBot())
+                    {
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            u = it->second;
+                            if (u != me && IsTank())
+                                continue;
+                            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                                it->second->IsTempBot() || !IsTank(u) || me->GetDistance(u) > 30 ||
+                                u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                                continue;
+
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (!foundTank)
+                    {
+                        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                        {
+                            u = *itr;
+                            if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                                !IsTank(u) || me->GetDistance(u) > 30 ||
+                                u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                                continue;
+
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (foundTank)
+                        break;
+                }
+            }
+            if (!foundTank)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    u = itr->GetSource();
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap())
+                        continue;
+
+                    if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                        !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    {
+                        foundTank = true;
+                        break;
+                    }
+
+                    if (!u->ToPlayer()->HaveBot())
+                        continue;
+
+                    BotMap const* map = u->ToPlayer()->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        if (it->second->IsTempBot())
+                            continue;
+
+                        u = it->second;
+                        if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                            !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                        {
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (foundTank)
+                        break;
+                }
+            }
+
+            if (foundTank && doCast(u, GetSpell(SACRED_SHIELD_1)))
+                return;
+        }
+
+        void HOPGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_PROTECTION_1, diff) || IAmFree() || me->IsMounted() || Feasting() || IsCasting() ||
+                Rand() > 30)
+                return;
+
+            Unit* u;
+            Player* player = master;
+            Group const* gr = player->GetGroup();
+            if (!gr)
+            {
+                u = player;
+                if (u->IsInWorld() && me->GetMap() == u->FindMap())
+                {
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+
+                for (Unit::ControlList::const_iterator itr = player->m_Controlled.begin(); itr != player->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->isType(TYPEMASK_PLAYER) || !u->ToCreature()->IsNPCBot() || u->ToCreature()->IsTempBot() ||
+                        IsTank(u) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                    IsTank(u) || me->GetDistance(u) > 30)
+                    continue;
+                if (HOPTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        it->second->IsTempBot() || IsTank(u) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOPTarget(Unit* target, uint32 /*diff*/)
+        {
+            if (target == me ||
+                (target->GetTypeId() == TYPEID_PLAYER ? target->GetClass() == BOT_CLASS_PALADIN :
+                target->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN))
+                return false; //paladins should use their own damn bubble
+            if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 1) ||
+                target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                return false; //immune to physical (hop or smth is present)
+            if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 25))
+                return false; //forbearance
+            if (target->getAttackers().empty())
+                return false; //HOP only saves from physical, these aoe are rare and on bosses they are ultimate anyway
+
+            if (GetHealthPCT(target) < 15 + 5*(uint32)target->getAttackers().size())
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Hand of Protection on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Hand of Protection on " << target->GetName() << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                }
+                return true;
+            }
+
+            return false;
+        }
+
+        void HOFGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_FREEDOM_1, diff) || me->IsMounted() || Feasting() || IsCasting() || Rand() > 20)
+                return;
+
+            if (IAmFree())
+            {
+                HOFTarget(me, diff);
+                return;
+            }
+
+            Unit* u;
+            Player* player = master;
+            Group const* gr = player->GetGroup();
+            if (!gr)
+            {
+                u = player;
+                if (u->IsInWorld() && me->GetMap() == u->FindMap() &&
+                    HOFTarget(u, diff))
+                    return;
+
+                for (Unit::ControlList::const_iterator itr = player->m_Controlled.begin(); itr != player->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->isType(TYPEMASK_PLAYER) || (!u->IsPet() && !u->ToCreature()->IsNPCBot()) ||
+                        u->ToCreature()->IsTempBot() || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOFTarget(u, diff))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || me->GetDistance(u) > 30)
+                    continue;
+                if (HOFTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        it->second->IsTempBot() || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOFTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 /*diff*/)
+        {
+            if (target->HasAuraType(SPELL_AURA_MECHANIC_IMMUNITY))
+            {
+                if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 11) &&
+                    target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 7))
+                    return false; //immune to root and snares
+                if (me->GetLevel() >= 35 && target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 12))
+                    return false; //immune to stuns
+            }
+
+            SpellInfo const* spellInfo;
+            AuraApplication const* app;
+            Unit::AuraApplicationMap const& auras = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                app = i->second;
+                if (!app || app->IsPositive() || app->GetBase()->IsPassive() || app->GetBase()->GetDuration() < 2000)
+                    continue;
+                spellInfo = app->GetBase()->GetSpellInfo();
+                if (spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                if (spellInfo->GetAllEffectsMechanicMask() &
+                    ((1<<MECHANIC_SNARE) | (1<<MECHANIC_ROOT) | (me->GetLevel() < 35 ? 0 : (1<<MECHANIC_STUN))))
+                {
+                    uint32 dispel = spellInfo->Dispel;
+                    uint32 spell;
+                    //Hand of Freedom is level 12, Purify is 8, Cleanse is 42
+                    if (!GetSpell(CLEANSE))
+                        spell = (dispel == DISPEL_DISEASE || dispel == DISPEL_POISON) ?
+                        GetSpell(PURIFY_1) : GetSpell(HAND_OF_FREEDOM_1);
+                    else
+                        spell = (dispel == DISPEL_MAGIC || dispel == DISPEL_DISEASE || dispel == DISPEL_POISON) ?
+                        GetSpell(CLEANSE_1) : GetSpell(HAND_OF_FREEDOM_1);
+
+                    if (doCast(target, spell))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_SALVATION_1, diff) || IsCasting() || Rand() > 40)
+                return;
+
+            Unit* u;
+
+            if (me->GetLevel() >= 26 && (IAmFree() || IsTank()))
+            {
+                u = me;
+                if (u->IsInCombat() && !u->getAttackers().empty() &&
+                    GetHealthPCT(u) < std::max<int32>(80 - 5 * u->getAttackers().size(), 25))
+                    if (doCast(u, GetSpell(HAND_OF_SALVATION_1)))
+                    {}
+                return;
+            }
+
+            if (IAmFree())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                 return;
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                    IsTank(u) || (IsTankingClass(u->GetClass()) && !me->GetMap()->IsRaid()) || me->GetDistance(u) > 30)
+                    continue;
+
+                if (HOSTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() || it->second->IsTempBot() ||
+                        IsTank(u) || (IsTankingClass(u->ToCreature()->GetBotClass()) && !me->GetMap()->IsRaid()) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOSTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOSTarget(Unit* target, uint32 /*diff*/)
+        {
+            if (target->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE, SPELLFAMILY_PALADIN, 0x100))
+                return false;
+
+            Unit::AttackerSet const& t_attackers = target->getAttackers();
+            if (t_attackers.empty())
+                return false;
+
+            for (Unit::AttackerSet::const_iterator iter = t_attackers.begin(); iter != t_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                if ((*iter)->getAttackers().size() < 3) continue; //would be useless
+                if (target->GetDistance((*iter)) < 15)
+                {
+                    if (doCast(target, GetSpell(HAND_OF_SALVATION_1)))
+                        return true;
+
+                    break; //do not try more than once on the same target
+                }
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 90 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+            //try to preserve heal if Divine Plea is active
+            if (hp > 50 && me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x0, 0x1))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * 2.5f;
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * 2.5f;
+            if (xppct >= 95 && hp >= 25)
+                return false;
+
+            //Lay on Hands
+            if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && (target != me || shieldDelayTimer <= diff) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 80 && hp <= 20 && xppct <=0 &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Lay on Hands on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Lay on Hands on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                    return true;
+                }
+            }
+
+            //Holy Shock
+            if (IsSpellReady(HOLY_SHOCK_1, diff, false) && !target->IsCharmed() && !target->isPossessed() &&
+                xphploss > _heals[HOLY_SHOCK_1])
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (hp < 30 && IsSpellReady(DIVINE_FAVOR_1, diff, false) && !target->getAttackers().empty())
+                    if (doCast(me, GetSpell(DIVINE_FAVOR_1)))
+                    {}
+                if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+                    return true;
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            if (IsSpellReady(DIVINE_ILLUMINATION_1, diff, false) && GetManaPCT(me) <= 50 && Rand() < 50 + 50*tanking)
+                if (doCast(me, GetSpell(DIVINE_ILLUMINATION_1)))
+                {}
+
+            //Holy Light
+            if (IsSpellReady(HOLY_LIGHT_1, diff) && (xppct > 15 || !GetSpell(FLASH_OF_LIGHT_1)) &&
+                xphploss > _heals[HOLY_LIGHT_1])
+            {
+                //Aura Mastery
+                if (hp < 60 && _aura == CONCENTRATIONAURA && IsSpellReady(AURA_MASTERY_1, diff, false) && Rand() < 90 &&
+                    ((!me->getAttackers().empty() && (*me->getAttackers().begin())->GetTypeId() == TYPEID_PLAYER) ||
+                    me->GetMap()->Instanceable() || tanking))
+                    if (doCast(me, GetSpell(AURA_MASTERY_1)))
+                    {}
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            }
+            //Flash of Light
+            if (IsSpellReady(FLASH_OF_LIGHT_1, diff) && (tanking || xphploss > _heals[FLASH_OF_LIGHT_1]))
+            {
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_ai::JustDied(u); }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (me->GetLevel() >= 35 && IsSpellReady(HAND_OF_FREEDOM_1, diff) && Rand() < 30 && me->HasAuraWithMechanic(1<<MECHANIC_STUN))
+            {
+                if (me->IsMounted())
+                    me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                if (doCast(me, GetSpell(HAND_OF_FREEDOM_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 30)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 60)
+                    DrinkPotion(false);
+            }
+            else if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff) && Rand() < 30 &&
+                !me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+            }
+
+            CheckRacials(diff);
+
+            HOPGroup(diff);
+            CheckBeacon(diff);
+
+            if (me->GetMap()->IsRaid())
+            {
+                CureGroup(GetSpell(CLEANSE), diff);
+                BuffAndHealGroup(diff);
+                CheckHandOfSacrifice(diff);
+                ShieldGroup(diff);
+            }
+            else
+            {
+                BuffAndHealGroup(diff);
+                CheckHandOfSacrifice(diff);
+                ShieldGroup(diff);
+                CureGroup(GetSpell(CLEANSE), diff);
+            }
+
+            CheckSacrifice(diff);
+            HOFGroup(diff);
+            HOSGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckSeal(diff);
+            CheckAura(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            Repentance(diff);
+            Counter(diff);
+            TurnEvil(diff);
+
+            CheckDivineIntervention(diff);
+            if (!me->IsAlive())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REDEMPTION_1));
+        }
+
+        void CheckSeal(uint32 diff)
+        {
+            if (checkSealTimer > diff || GC_Timer > diff || me->IsMounted() ||
+                IsCasting() || Feasting() || Rand() > 30)
+                return;
+
+            checkSealTimer = 10000;
+
+            Unit const* victim = me->GetVictim();
+
+            uint32 COMMAND = GetSpell(SEAL_OF_COMMAND_1);
+            uint32 LIGHT = GetSpell(SEAL_OF_LIGHT_1);
+            uint32 RIGHT = GetSpell(SEAL_OF_RIGHTEOUSNESS_1);
+            uint32 WISDOM = GetSpell(SEAL_OF_WISDOM_1);
+            uint32 JUSTICE = GetSpell(SEAL_OF_JUSTICE_1);
+            uint32 VENGEANCE = (me->GetRaceMask() & RACEMASK_ALLIANCE) ? GetSpell(SEAL_OF_VENGEANCE_1) : GetSpell(SEAL_OF_CORRUPTION_1);
+
+            if (VENGEANCE && victim &&
+                (victim->GetMaxHealth() > me->GetMaxHealth() * (2 + victim->getAttackers().size() / 2) ||
+                victim->GetClass() == CLASS_ROGUE))
+                COMMAND = VENGEANCE;
+
+            uint32 SEAL = 0;
+
+            if (IsMelee() && GetManaPCT(me) < 20 && WISDOM)
+                SEAL = WISDOM;
+            else if (IsTank())
+            {
+                if (JUSTICE && me->getAttackers().size() > 1)
+                    JUSTICE = 0;
+                if (JUSTICE && victim)
+                {
+                    Creature const* cre = victim->ToCreature();
+                    if (cre && cre->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL &&
+                        (cre->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_STUN-1))))
+                        JUSTICE = 0;
+                }
+                SEAL = COMMAND ? COMMAND : JUSTICE ? JUSTICE : RIGHT;
+            }
+            else if (HasRole(BOT_ROLE_DPS))
+            {
+                SEAL = WISDOM && HasRole(BOT_ROLE_HEAL) ? WISDOM : COMMAND ? COMMAND : RIGHT;
+            }
+            else if (HasRole(BOT_ROLE_HEAL))
+                SEAL = WISDOM ? WISDOM : LIGHT ? LIGHT : RIGHT;
+
+            if (SEAL && !me->HasAura(SEAL))
+                if (doCast(me, SEAL))
+                    return;
+        }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting() ||
+                /*me->GetExactDist(master) > 40 || me->IsMounted() || Feasting() || */Rand() > 20)
+                return;
+
+            checkAuraTimer = urand(3000, 6000);
+
+            //7 paladins in group?
+            uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+            uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+            uint32 FIRE_RESISTANCE_AURA = GetSpell(FIRE_RESISTANCE_AURA_1);
+            uint32 FROST_RESISTANCE_AURA = GetSpell(FROST_RESISTANCE_AURA_1);
+            uint32 SHADOW_RESISTANCE_AURA = GetSpell(SHADOW_RESISTANCE_AURA_1);
+            uint32 RETRIBUTION_AURA = GetSpell(RETRIBUTION_AURA_1);
+            //uint32 CRUSADER_AURA = GetSpell(CRUSADER_AURA_1);
+
+            bool pureHealer = _spec == BOT_SPEC_PALADIN_HOLY;
+            bool isProt = _spec == BOT_SPEC_PALADIN_PROTECTION;
+
+            std::map<uint32 /*baseid*/, uint32 /*curid*/> idMap;
+            uint32 mask = _getAurasMask(idMap);
+
+            //for Aura Mastery allow every pure healer paladin to have their own C aura
+            //SPECIFIC_AURA_MY_AURA check still works so no spam
+            if (pureHealer)
+                mask &= ~SPECIFIC_AURA_CONCENTRATION;
+
+            //if (CRUSADER_AURA && !(mask & SPECIFIC_AURA_CRUSADER) &&
+            //    (master->IsMounted() || me->IsMounted()))
+            //{
+            //    if (doCast(me, CRUSADER_AURA))
+            //        return;
+            //}
+
+            //Has own aura or has all auras
+            if (mask & SPECIFIC_AURA_MY_AURA)
+                return;
+            else if ((mask & SPECIFIC_AURA_ALL_AUTOUSE) == SPECIFIC_AURA_ALL_AUTOUSE)
+                return;
+
+            //TODO: priority?
+            if (DEVOTION_AURA &&
+                (!(mask & SPECIFIC_AURA_DEVOTION) || idMap[DEVOTION_AURA_1] < DEVOTION_AURA) &&
+                (!RETRIBUTION_AURA || IsTank(master) || isProt))
+            {
+                if (doCast(me, DEVOTION_AURA))
+                    return;
+            }
+            if (CONCENTRATION_AURA && !(mask & SPECIFIC_AURA_CONCENTRATION) &&
+                (master->GetClass() == BOT_CLASS_MAGE || master->GetClass() == BOT_CLASS_PRIEST ||
+                master->GetClass() == BOT_CLASS_WARLOCK || master->GetClass() == BOT_CLASS_DRUID ||
+                (!IAmFree() && master->GetClass() == BOT_CLASS_PALADIN) || pureHealer))
+            {
+                if (doCast(me, CONCENTRATION_AURA))
+                    return;
+            }
+            if (RETRIBUTION_AURA &&
+                (!(mask & SPECIFIC_AURA_RETRIBUTION) || idMap[RETRIBUTION_AURA_1] < RETRIBUTION_AURA) &&
+                (IsMeleeClass(master->GetClass()) || IsMelee()))
+            {
+                if (doCast(me, RETRIBUTION_AURA))
+                    return;
+            }
+            if (FIRE_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_FIRE_RES) || idMap[FIRE_RESISTANCE_AURA_1] < FIRE_RESISTANCE_AURA))
+            {
+                if (doCast(me, FIRE_RESISTANCE_AURA))
+                    return;
+            }
+            if (FROST_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_FROST_RES) || idMap[FROST_RESISTANCE_AURA_1] < FROST_RESISTANCE_AURA))
+            {
+                if (doCast(me, FROST_RESISTANCE_AURA))
+                    return;
+            }
+            if (SHADOW_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_SHADOW_RES) || idMap[SHADOW_RESISTANCE_AURA_1] < SHADOW_RESISTANCE_AURA))
+            {
+                if (doCast(me, SHADOW_RESISTANCE_AURA))
+                    return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target == me)
+            {
+                if (uint32 rFury = GetSpell(RIGHTEOUS_FURY_1))
+                {
+                    if (IsTank())
+                    {
+                        if (!me->HasAura(rFury) && doCast(me, rFury))
+                            return true;
+                    }
+                    else if (me->HasAura(rFury))
+                        me->RemoveAurasDueToSpell(rFury);
+                }
+            }
+
+            uint32 mask = _getBlessingsMask(target);
+
+            //already has my blessing
+            if (mask & SPECIFIC_BLESSING_MY_BLESSING)
+                return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+
+            bool wisdom = (mask & SPECIFIC_BLESSING_WISDOM);
+            bool kings = (mask & SPECIFIC_BLESSING_KINGS);
+            bool sanctuary = (mask & SPECIFIC_BLESSING_SANCTUARY);
+            bool might = (mask & SPECIFIC_BLESSING_MIGHT);
+
+            if (IsTank(target))
+            {
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->GetMaxPower(POWER_MANA) > 1 && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+
+                return false;
+            }
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->GetClass();
+            else if (Creature* cre = target->ToCreature())
+                Class = cre->GetBotAI() ? cre->GetBotAI()->GetBotClass() : cre->GetClass();
+
+            switch (Class)
+            {
+                case BOT_CLASS_BM:
+                case BOT_CLASS_SPHYNX:
+                case BOT_CLASS_DREADLORD:
+                case BOT_CLASS_SPELLBREAKER:
+                case BOT_CLASS_DARK_RANGER:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_PRIEST:
+                case CLASS_MAGE:
+                case CLASS_WARLOCK:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                case CLASS_ROGUE:
+                case CLASS_HUNTER:
+                case CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->GetPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->GetMaxPower(POWER_MANA) > 1 && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = nullptr)
+        {
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff) && doCast(target, GetSpell(REPENTANCE_1)))
+                    return;
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                    return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff) ? FindCastingTarget(20, 0, REPENTANCE_1) : nullptr;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            if (!target && IsSpellReady(TURN_EVIL_1, diff))
+            {
+                target = FindCastingTarget(20, 0, TURN_EVIL_1);
+                if (target && doCast(target, GetSpell(TURN_EVIL_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(HOLY_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(HAMMER_OF_JUSTICE_1, diff, false))
+            {
+                target = FindCastingTarget(10, 0, HAMMER_OF_JUSTICE_1);
+                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {}
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1)))
+                return;
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                !CCed(opponent) &&
+                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
+                GetHealthPCT(me) < 90 &&
+                doCast(opponent, GetSpell(TURN_EVIL_1)))
+                return;
+        }
+
+        void CheckDivineIntervention(uint32 diff)
+        {
+            if (!IsSpellReady(DIVINE_INTERVENTION_1, diff, !IsCasting()) || IAmFree() || IsTank() ||
+                GetManaPCT(me) > 10 || Rand() > 20)
+                return;
+
+            std::list<Unit*> players;
+
+            if (master->IsAlive() && !master->getAttackers().empty() && GetHealthPCT(master) < 15 &&
+                !master->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                players.push_back(master);
+            if (Group const* gr = master->GetGroup())
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || pl == master || !pl->IsInWorld() || me->GetMap() != pl->FindMap() ||
+                        !pl->IsAlive() || pl->getAttackers().empty() || GetHealthPCT(pl) > 15 ||
+                        pl->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                        continue;
+
+                    players.push_back(pl);
+                }
+            }
+
+            if (players.empty())
+                return;
+
+            Unit* target = players.size() == 1 ? *players.begin() : Trinity::Containers::SelectRandomContainerElement(players);
+            if (doCast(target, GetSpell(DIVINE_INTERVENTION_1)))
+                return;
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            MoveBehind(opponent);
+
+            //Divine Shield
+            if (IsSpellReady(DIVINE_SHIELD_1, diff) && shieldDelayTimer <= diff && (IAmFree() || !IsTank()) &&
+                Rand() < 80 && !me->getAttackers().empty() && GetHealthPCT(me) < 25)
+            {
+                if (doCast(me, GetSpell(DIVINE_SHIELD_1)))
+                    return;
+            }
+
+            //Holy shield
+            if (IsSpellReady(HOLY_SHIELD_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && !me->getAttackers().empty() &&
+                !me->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+            {
+                if (doCast(me, GetSpell(HOLY_SHIELD_1)))
+                    return;
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_HOLY))
+                return;
+
+            float dist = me->GetDistance(opponent);
+
+            //HAMMER OF WRATH
+            if (IsSpellReady(HAMMER_OF_WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && dist < 30)
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_WRATH_1)))
+                    return;
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(HAND_OF_RECKONING_1, diff, false) && u && u != me && dist < 30 &&
+                opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !CCed(opponent) && HasRole(BOT_ROLE_DPS) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80) || IsTank()) &&
+                IsInBotParty(u) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(HAND_OF_RECKONING_1)))
+                    return;
+            }
+            //HAND OF RECKONING 2 (distant)
+            if (IsSpellReady(HAND_OF_RECKONING_1, diff, false) && u == me && IsTank() && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                !(me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())))
+            {
+                Unit* tUnit = FindDistantTauntTarget();
+                if (tUnit)
+                {
+                    if (doCast(tUnit, GetSpell(HAND_OF_RECKONING_1)))
+                        return;
+                }
+            }
+            //RIGHTEOUS DEFENSE //No GCD
+            if (IsSpellReady(RIGHTEOUS_DEFENSE_1, diff, false) && !IAmFree() && u && u != me && IsTank() &&
+                me->GetDistance(u) < 40 && opponent->GetTypeId() == TYPEID_UNIT && !opponent->IsControlledByPlayer() &&
+                !IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80 &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                IsInBotParty(u) && Rand() < 20 + 30 * u->getAttackers().size())
+            {
+                if (doCast(u, GetSpell(RIGHTEOUS_DEFENSE_1)))
+                    return;
+            }
+            //RIGHTEOUS DEFENSE 2 (distant)
+            if (IsSpellReady(RIGHTEOUS_DEFENSE_1, diff, false) && !IAmFree() && u == me && IsTank() && Rand() < 30 &&
+                !(me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())))
+            {
+                Unit* tUnit = FindDistantTauntTarget(40, true);
+                if (tUnit)
+                {
+                    if (doCast(tUnit, GetSpell(RIGHTEOUS_DEFENSE_1)))
+                        return;
+                }
+            }
+            //Divine Plea
+            if (IsSpellReady(DIVINE_PLEA_1, diff) && Rand() < 30 && GetManaPCT(me) < (IsTank() ? 90 : 7) &&
+                !me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+            }
+            //Avenging Wrath (tank - big threat, dps - big hp, heal - divine plea counter)
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && avDelayTimer <= diff &&
+                HasRole(BOT_ROLE_HEAL|BOT_ROLE_DPS) && Rand() < 35 && dist < 30 &&
+                IsTank() ? (opponent->GetTypeId() == TYPEID_UNIT && (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())) :
+                (!HasRole(BOT_ROLE_HEAL) || !HasRole(BOT_ROLE_RANGED)) ? (opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size())) :
+                (me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1) != nullptr))
+            {
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {}
+            }
+            //Avenger's shield
+            if (IsSpellReady(AVENGERS_SHIELD_1, diff) && CanBlock() &&
+                HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(AVENGERS_SHIELD_1)))
+                    return;
+            }
+            //Divine Protection tanks only
+            if (IsSpellReady(DIVINE_PROTECTION_1, diff, false) && shieldDelayTimer <= diff && IsTank() && Rand() < 80 &&
+                !me->getAttackers().empty() && GetHealthPCT(me) < 67 - 20*me->HasAuraType(SPELL_AURA_PERIODIC_HEAL))
+            {
+                if (doCast(me, GetSpell(DIVINE_PROTECTION_1)))
+                    return;
+            }
+            //Exorcism (have cast window or instant)
+            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 70 &&
+                ((IsTank() && dist > 12) || (HasRole(BOT_ROLE_RANGED) && !HasRole(BOT_ROLE_HEAL)) ||
+                me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x0, 0x2)))
+            {
+                if (doCast(opponent, GetSpell(EXORCISM_1)))
+                    return;
+            }
+            //Hammer of Justice
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) && dist < 10 && Rand() < 20 &&
+                opponent->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2 &&
+                !opponent->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(HAMMER_OF_JUSTICE_1), 0, me))
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    return;
+            }
+            //Judgement
+            if (GetSpellCooldown(JUDGEMENT_OF_LIGHT_1) <= diff && HasRole(BOT_ROLE_DPS) && Rand() < 120)
+            {
+                uint32 JUDGEMENT = 0;
+
+                if (GetSpell(JUDGEMENT_OF_JUSTICE_1) && opponent->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED) &&
+                    dist < CalcSpellMaxRange(JUDGEMENT_OF_JUSTICE_1))
+                {
+                    //has joj from someone else
+                    bool canCast = true;
+                    Unit::AuraEffectList const& notSpeedAuras = opponent->GetAuraEffectsByType(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED);
+                    for (Unit::AuraEffectList::const_iterator itr = notSpeedAuras.begin(); itr != notSpeedAuras.end(); ++itr)
+                    {
+                        if ((*itr)->GetCasterGUID() != me->GetGUID() && (*itr)->GetBase()->GetDuration() > 2000)
+                        {
+                            canCast = false;
+                            break;
+                        }
+                    }
+                    if (canCast)
+                    {
+                        //has sprint or something
+                        Unit::AuraEffectList const& speedAuras = opponent->GetAuraEffectsByType(SPELL_AURA_MOD_INCREASE_SPEED);
+                        for (Unit::AuraEffectList::const_iterator itr = speedAuras.begin(); itr != speedAuras.end(); ++itr)
+                        {
+                            if (!(*itr)->GetBase()->IsPassive() &&
+                                (*itr)->GetBase()->GetDuration() > 2000 &&
+                                (*itr)->GetAmount() >= 30)
+                            {
+                                JUDGEMENT = JUDGEMENT_OF_JUSTICE_1;
+                                break;
+                            }
+                        }
+                    }
+                }
+                if (!JUDGEMENT && GetSpell(JUDGEMENT_OF_WISDOM_1) && dist < CalcSpellMaxRange(JUDGEMENT_OF_WISDOM_1))
+                {
+                    //from 35% to 50% mana
+                    //opponent->GetAuraEffect(JUDGEMENT_OF_WISDOM_AURA, 0, me->GetGUID()
+                    AuraEffect const* wisd = opponent->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 3014, 0);
+                    uint8 myManaPct = GetManaPCT(me);
+                    if ((!wisd && myManaPct < 35) || (wisd && wisd->GetCasterGUID() == me->GetGUID() && myManaPct < 50))
+                        JUDGEMENT = JUDGEMENT_OF_WISDOM_1;
+                }
+                if (!JUDGEMENT && GetSpell(JUDGEMENT_OF_LIGHT_1) && dist < CalcSpellMaxRange(JUDGEMENT_OF_LIGHT_1))
+                {
+                    JUDGEMENT = JUDGEMENT_OF_LIGHT_1;
+                }
+
+                //Conditional spell unavailable, use any other
+                if (!JUDGEMENT)
+                {
+                    if (GetSpell(JUDGEMENT_OF_WISDOM_1))
+                        JUDGEMENT = JUDGEMENT_OF_WISDOM_1;
+                    else if (GetSpell(JUDGEMENT_OF_LIGHT_1))
+                        JUDGEMENT = JUDGEMENT_OF_LIGHT_1;
+                    else if (GetSpell(JUDGEMENT_OF_JUSTICE_1))
+                        JUDGEMENT = JUDGEMENT_OF_JUSTICE_1;
+                }
+
+                if (JUDGEMENT && doCast(opponent, GetSpell(JUDGEMENT)))
+                    return;
+            }
+            //Consecration
+            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 5 &&
+                !opponent->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                    return;
+            }
+            //Hammer of Righteous (1h only)
+            if (IsSpellReady(HAMMER_OF_THE_RIGHTEOUS_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                dist < 5 && Rand() < 80)
+            {
+                Item const* weapMH = GetEquips(BOT_SLOT_MAINHAND);
+                if (weapMH &&
+                    (weapMH->GetTemplate()->InventoryType == INVTYPE_WEAPON ||
+                    weapMH->GetTemplate()->InventoryType == INVTYPE_WEAPONMAINHAND) &&
+                    doCast(opponent, GetSpell(HAMMER_OF_THE_RIGHTEOUS_1)))
+                    return;
+            }
+            //Shield of Righteousness
+            if (IsSpellReady(SHIELD_OF_RIGHTEOUSNESS_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() &&
+                (IsTank() || IAmFree()) && dist < 5 && Rand() < 90)
+            {
+                if (doCast(opponent, GetSpell(SHIELD_OF_RIGHTEOUSNESS_1)))
+                    return;
+            }
+            //Crusader Strike (2h only)
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 5 && Rand() < 90)
+            {
+                Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+                if (mh && mh->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                    if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
+                        return;
+            }
+            //Divine Storm (2h only)
+            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 40)
+            {
+                Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+                if (mh && mh->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                    if (doCast(me, GetSpell(DIVINE_STORM_1)))
+                        return;
+            }
+            //Holy Wrath
+            if (IsSpellReady(HOLY_WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                    dist < 8.5f && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    return;
+                else
+                {
+                    if (FindUndeadCCTarget(8.5f, HOLY_WRATH_1, false) &&
+                        doCast(me, GetSpell(HOLY_WRATH_1)))
+                        return;
+                }
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Sanctified Light: 6% additional critical chance for Holy Light and Holy Shock
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 30 && (baseId == HOLY_LIGHT_1 || baseId == HOLY_SHOCK_1))
+                crit_chance += 6.f;
+            //Holy Power: 5% additional critical chance for Holy spells
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 35 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 5.f;
+            //Improved Flash of Light (id: 20251): 6% additional critical chance for Flash of Light
+            if (lvl >= 70 && baseId == FLASH_OF_LIGHT_1)
+                crit_chance += 6.f;
+            //Glyph of Flash of Light: 5% additional critical chance for Flash of Light
+            if (lvl >= 20 && baseId == FLASH_OF_LIGHT_1)
+                crit_chance += 5.f;
+            //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 45 && baseId == HAMMER_OF_WRATH_1)
+                crit_chance += 50.f;
+            //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 45 && spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+                crit_chance += 18.f;
+            //Infusion of Light
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 0))
+                    if (infu->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 20.f;
+            }
+            if (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1)
+            {
+                if (AuraEffect const* favo = me->GetAuraEffect(DIVINE_FAVOR_1, 0))
+                    if (favo->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 100.f;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 25 && baseId == EXORCISM_1)
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || baseId == CRUSADER_STRIKE_1 || baseId == DIVINE_STORM_1))
+                pctbonus += 0.1f;
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                baseId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+            //Glyph of Exorcism: 20% bonus damage for Exorcism
+            if (lvl >= 50 && baseId == EXORCISM_1)
+                pctbonus += 0.2f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+            //Improved Consecration (id: 38422): 10% bonus damage for Consecration
+            if (lvl >= 20 && spellId == GetSpell(CONSECRATION_1))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Divine Plea: 50% reduced healing for all spells
+            if (/*lvl >= 71 && */me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+                pctbonus -= 0.5f;
+
+            //Healing Light: 12% bonus healing for Holy Light, Flash of Light and Holy Shock
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 15 && (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1))
+                pctbonus += 0.12f;
+            //Glyph of Seal of Light: 5% bonus healing for all spells
+            if (lvl >= 30 && me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.05f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Benediction: -10% mana cost for Instant spells
+            if (lvl >= 10 && !spellInfo->CalcCastTime())
+                pctbonus += 0.1f;
+            //Blessed Hands: -30% mana cost for Hand spells
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x2110))
+                pctbonus += 0.3f;
+            //Holy Light Cost Reduction (id: 60148): -5% mana cost for Holy Light
+            if (lvl >= 30 && baseId == HOLY_LIGHT_1)
+                pctbonus += 0.05f;
+            //Consecration Discount (id: 37180): -15% mana cost for Consecration
+            if (lvl >= 30 && baseId == CONSECRATION_1)
+                pctbonus += 0.15f;
+            //Glyph of Seal of Wisdom: -5% mana cost for all healing spells (for bot it is all spells)
+            if (lvl >= 15 && me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x4000000, 0x0))
+                pctbonus += 0.05f;
+            //Glyph of Shield of Righteous: -80% mana cost for Shield of Righteous
+            if (lvl >= 75 && (spellInfo->SpellFamilyFlags[1] & 0x100000))
+                pctbonus += 0.8f;
+
+            //flat mods
+            //Cleanse Cost Reduced (id: 27847): -25 mana cost for Cleanse
+            if (lvl >= 40 && baseId == CLEANSE_1)
+                flatbonus += 25;
+            //Reduced Holy Light Cost (id: 37739): -34 mana cost for Holy Light
+            if (lvl >= 40 && baseId == HOLY_LIGHT_1)
+                flatbonus += 34;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Turn Evil: -100% cast time for Turn Evil
+            if (lvl >= 24 && baseId == TURN_EVIL_1)
+                timebonus += casttime;
+            if (baseId == FLASH_OF_LIGHT_1 || baseId == EXORCISM_1)
+            {
+                //The Art of War
+                AuraEffect const* arto = me->GetAuraEffect(THE_ART_OF_WAR_BUFF, 0);
+                //Infusion of Light
+                AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 1);
+                if (arto && arto->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+                else if (infu && infu->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+            }
+
+            //flat mods
+            //Improved Holy Light (id: 24457): -0.1 sec cast time for Holy Light
+            if (lvl >= 40 && baseId == HOLY_LIGHT_1)
+                timebonus += 100;
+            //Recuced Holy Light Cast Time (id: 37189): -0.5 sec cast time for Holy Light (works only for healers)
+            //Light's Grace: -0.5 sec cast time for Holy Light
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* enli = me->GetAuraEffect(ENLIGHTENMENT_BUFF, 0))
+                    if (enli->IsAffectedOnSpell(spellInfo))
+                        timebonus += 500;
+                if (AuraEffect const* grac = me->GetAuraEffect(LIGHTS_GRACE_BUFF, 0))
+                    if (grac->IsAffectedOnSpell(spellInfo))
+                        timebonus += 500;
+            }
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Improved Judgements: -2 sec cooldown for judgements
+            //Judgment Cooldown Reduction (60153): -1 sec cooldown for judgements
+            //Judgement Cooldown Reduction (61776): -1 sec cooldown for judgements
+            if (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (lvl >= 70)
+                    timebonus += 4000;
+                else if (lvl >= 60)
+                    timebonus += 3000;
+                else if (lvl >= 15)
+                    timebonus += 2000;
+            }
+            //Sacred Duty: -60 sec cooldown for Divine Shield and Divine Protection
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 35 && (baseId == DIVINE_SHIELD_1 || baseId == DIVINE_PROTECTION_1))
+                timebonus += 60000;
+            //Reduced Righteous Defense Cooldown (37181): -2 sec cooldown for Righteous Defense
+            if (lvl >= 60 && baseId == RIGHTEOUS_DEFENSE_1)
+                timebonus += 2000;
+            //Paladin T9 Tank 2P Bonus part 1: -2 sec cooldown for Hand of Reckoning
+            if (lvl >= 78 && baseId == HAND_OF_RECKONING_1)
+                timebonus += 2000;
+            //Glyph of Turn Evil: +8 sec cooldown for Turn Evil
+            if (lvl >= 24 && baseId == TURN_EVIL_1)
+                timebonus -= 8000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Purifying Power part 2: -33% cooldown for Exorcism and Holy Wrath
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 35 && (baseId == EXORCISM_1 || baseId == HOLY_WRATH_1))
+                pctbonus += 0.333f;
+            //Glyph of Avenging Wrath: -50% cooldown for Hammer of Wrath if Avenging Wrath is active
+            if (lvl >= 70 && baseId == HAMMER_OF_WRATH_1 &&
+                me->GetAuraEffect(SPELL_AURA_MOD_HEALING_DONE_PERCENT, SPELLFAMILY_PALADIN, 0x0, 0x2000, 0x0))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Improved Judgements: -2 sec cooldown for judgements
+            //Judgment Cooldown Reduction (60153): -1 sec cooldown for judgements
+            //Judgement Cooldown Reduction (61776): -1 sec cooldown for judgements
+            if (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (lvl >= 70)
+                    timebonus += 4000;
+                else if (lvl >= 60)
+                    timebonus += 3000;
+                else if (lvl >= 15)
+                    timebonus += 2000;
+            }
+            //Guardian's Favor part 1: -120 sec cooldown for Hand of Protection
+            if (lvl >= 15 && baseId == HAND_OF_PROTECTION_1)
+                timebonus += 120000;
+            //Improved Hammer of Justice: -20 sec cooldown for Hammer of Justice
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 25 && baseId == HAMMER_OF_JUSTICE_1)
+                timebonus += 20000;
+            //Judgements of the Just: -10 sec cooldown for Hammer of Justice (tanks only)
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 55 && baseId == HAMMER_OF_JUSTICE_1)
+                timebonus += 10000;
+            //Glyph of Holy Shock: -1 sec cooldown for Holy Shock
+            if (baseId == HOLY_SHOCK_1)
+                timebonus += 1000;
+            //Glyph of Consecration: +2 sec cooldown for Consecration
+            if (lvl >= 20 && baseId == CONSECRATION_1)
+                timebonus -= 2000;
+            //Glyph of Holy Wrath: -15 sec cooldown for Holy Wrath
+            if (lvl >= 50 && baseId == HOLY_WRATH_1)
+                timebonus += 15000;
+            //Improved Lay on Hands (part 2): -4 min cooldown for Lay on Hands
+            if (lvl >= 20 && baseId == LAY_ON_HANDS_1)
+                timebonus += 240000;
+            //Glyph of Lay on Hands: -5 min cooldown for Lay on Hands (only healers)
+            if (lvl >= 15 && HasRole(BOT_ROLE_HEAL) && baseId == LAY_ON_HANDS_1)
+                timebonus += 300000;
+            //Lay Hands (id: 28774): -4 min cooldown for Lay on Hands (only healers)
+            if (lvl >= 60 && HasRole(BOT_ROLE_HEAL) && baseId == LAY_ON_HANDS_1)
+                timebonus += 240000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Increased Aura Radii (23565)
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x4020048))
+                flatbonus += 10.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Enlightened Judgements: +30 yd range for Judgement of Light and Judgement of Wisdom (healers)
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 55 && (spellInfo->SpellFamilyFlags[0] & 0x800000))
+                flatbonus += 30.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Hammer of the Righteous: +1 target
+            if (spellInfo->SpellFamilyFlags[1] & 0x40000)
+                bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1)
+            {
+                if (AuraEffect const* favo = me->GetAuraEffect(DIVINE_FAVOR_1, 0))
+                    if (favo->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(DIVINE_FAVOR_1);
+            }
+
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* enli = me->GetAuraEffect(ENLIGHTENMENT_BUFF, 0))
+                    if (enli->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(ENLIGHTENMENT_BUFF);
+                if (AuraEffect const* grac = me->GetAuraEffect(LIGHTS_GRACE_BUFF, 0))
+                    if (grac->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(LIGHTS_GRACE_BUFF);
+                if (AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 0))
+                    if (infu->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(INFUSION_OF_LIGHT_BUFF);
+            }
+
+            if (baseId == EXORCISM_1 || baseId == FLASH_OF_LIGHT_1)
+            {
+                //Infusion of Light takes priority since AoW affects Exorcism too
+                AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 1);
+                //The Art of War
+                AuraEffect const* arto = me->GetAuraEffect(THE_ART_OF_WAR_BUFF, 0);
+                if (arto && arto->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(THE_ART_OF_WAR_BUFF);
+                else if (infu && infu->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(INFUSION_OF_LIGHT_BUFF);
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Beacon of Light: 30 sec increased duration
+            if (baseId == BEACON_OF_LIGHT_1)
+            {
+                Aura* beac = target->GetAura(spellId, me->GetGUID());
+                if (beac)
+                {
+                    uint32 dur = beac->GetDuration() + 30000;
+                    beac->SetDuration(dur);
+                    beac->SetMaxDuration(dur);
+                }
+            }
+            //Judgements of the Just melee attack speed reduction part 1
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 55 && spell->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                me->CastSpell(target, JUDGEMENTS_OF_THE_JUST_AURA, true);
+            }
+            //Judgements of the Just melee attack speed reduction part 2
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && spellId == JUDGEMENTS_OF_THE_JUST_AURA)
+            {
+                AuraEffect* slow = target->GetAuraEffect(JUDGEMENTS_OF_THE_JUST_AURA, 1, me->GetGUID());
+                if (slow)
+                    slow->ChangeAmount(slow->GetAmount() - 20);
+            }
+
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && spellId == SEAL_OF_JUSTICE_STUN_AURA)
+            {
+                if (lvl >= 55)
+                {
+                    //Judgements of the Just: 1 sec increased duration
+                    Aura* stun = target->GetAura(spellId, me->GetGUID());
+                    if (stun)
+                    {
+                        uint32 dur = stun->GetDuration() + 1000;
+                        stun->SetDuration(dur);
+                        stun->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == CONSECRATION_1)
+            {
+                if (lvl >= 30)
+                {
+                    //Glyph of Consecration: 2 sec increased duration
+                    Aura* cons = target->GetAura(spellId, me->GetGUID());
+                    if (cons)
+                    {
+                        uint32 dur = cons->GetDuration() + 2000;
+                        cons->SetDuration(dur);
+                        cons->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && baseId == RETRIBUTION_AURA_1)
+            {
+                if (lvl >= 30)
+                {
+                    //Sanctified Retribution: 50% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 3 / 2);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && baseId == DEVOTION_AURA_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Devotion Aura: 50% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 3 / 2);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && baseId == CONCENTRATION_AURA_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Concentration Aura: 15% increased effect (flat)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() + 15); //base = 35, bonus = 15
+                }
+            }
+            if (baseId == FLASH_OF_LIGHT_HEAL_PERIODIC)
+            {
+                if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 78 && !HasRole(BOT_ROLE_TANK | BOT_ROLE_DPS))
+                {
+                    //Paldin T9 Holy 4P Bonus: 100% increased healing from Infusion of Light (pure healers only)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 2);
+                }
+            }
+            if (baseId == BLESSING_OF_WISDOM_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Blessing of Wisdom: 20% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 6 / 5);
+                }
+            }
+            if (baseId == BLESSING_OF_MIGHT_1)
+            {
+                if (lvl >= 15)
+                {
+                    //Improved Blessing of Might: 25% increased effect
+                    if (Aura* migh = target->GetAura(spellId, me->GetGUID()))
+                        for (uint8 i = 0; i != EFFECT_2; ++i) // 2 effects
+                            if (AuraEffect* eff = migh->GetEffect(i))
+                                eff->ChangeAmount((eff->GetAmount() * 125) / 100);
+                }
+            }
+            if (baseId == HAND_OF_FREEDOM_1)
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && baseId == HAND_OF_SALVATION_1 && !IsTank(target))
+            {
+                //Blessed Hands (part 2)
+                if (AuraEffect* hos = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    hos->ChangeAmount(hos->GetAmount() * 2);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && baseId == HAND_OF_SACRIFICE_1)
+            {
+                //Blessed Hands (part 3)
+                if (AuraEffect* hos = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    hos->ChangeAmount(hos->GetAmount() + 10);
+                }
+            }
+            if (baseId == BLESSING_OF_KINGS_1 || baseId == BLESSING_OF_MIGHT_1 ||
+                baseId == BLESSING_OF_WISDOM_1 || baseId == BLESSING_OF_SANCTUARY_1)
+            {
+                //Blessings duration 1h
+                if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    bless->SetDuration(dur);
+                    bless->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == SACRED_SHIELD_AURA_TRIGGERED || baseId == SACRED_SHIELD_1)
+            {
+                //Divine Guardian (part 2): 20% increased absorb, +100% duration
+                Aura* shi = target->GetAura(spellId, me->GetGUID());
+                if (shi)
+                {
+                    uint32 dur = shi->GetDuration() * 2;
+                    shi->SetDuration(dur);
+                    shi->SetMaxDuration(dur);
+                    if (baseId == SACRED_SHIELD_AURA_TRIGGERED)
+                    {
+                        if (AuraEffect* eff = shi->GetEffect(EFFECT_0))
+                            eff->ChangeAmount(eff->GetAmount() * 6 / 5);
+                    }
+                }
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Glyph of Seal of Vengeance
+            if (baseId == SEAL_OF_VENGEANCE_1 || baseId == SEAL_OF_CORRUPTION_1)
+            {
+                AuraEffect* sea = me->GetAuraEffect(spell->Id, 1);
+                if (sea)
+                    sea->ChangeAmount(sea->GetAmount() + 10);
+            }
+
+            //Aura Helper
+            if (caster == me)
+            {
+                if (baseId == DEVOTION_AURA_1)
+                    _aura = DEVOTIONAURA;
+                if (baseId == CONCENTRATION_AURA_1)
+                    _aura = CONCENTRATIONAURA;
+                if (baseId == FIRE_RESISTANCE_AURA_1)
+                    _aura = FIRERESAURA;
+                if (baseId == FROST_RESISTANCE_AURA_1)
+                    _aura = FROSTRESAURA;
+                if (baseId == SHADOW_RESISTANCE_AURA_1)
+                    _aura = SHADOWRESAURA;
+                if (baseId == RETRIBUTION_AURA_1)
+                    _aura = RETRIBUTIONAURA;
+                if (baseId == CRUSADER_AURA_1)
+                    _aura = CRUSADERAURA;
+            }
+
+            //immunity markers
+            if (baseId == AVENGING_WRATH_MARKER_SPELL)
+                avDelayTimer = 30000;
+            if (baseId == IMMUNITY_SHIELD_MARKER_SPELL)
+                shieldDelayTimer = 30000;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        //healer may be nullptr
+        void HealReceived(Unit* healer, uint32& heal) override
+        {
+            //Spiritual Attunement (double the effect on bots)
+            if (heal && (_spec == BOT_SPEC_PALADIN_PROTECTION) && me->GetLevel() >= 40 && healer != me && GetLostHP(me))
+            {
+                if (int32 basepoints = int32(CalculatePct(std::min<int32>(heal, GetLostHP(me)), 20)))
+                {
+                    CastSpellExtraArgs args(true);
+                    args.AddSpellBP0(basepoints);
+                    me->CastSpell(me, SPIRITUAL_ATTUNEMENT_ENERGIZE, args);
+                }
+            }
+
+            //bot_ai::HealReceived(healer, heal);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(GetSpell(EXORCISM_1) ? EXORCISM_1 : JUDGEMENT_OF_LIGHT_1) : 10.f;
+        }
+
+        void Reset() override
+        {
+            checkAuraTimer = 0;
+            checkSealTimer = 0;
+            checkShieldTimer = 0;
+            checkBeaconTimer = 0;
+            avDelayTimer = 0;
+            shieldDelayTimer = 0;
+            _aura = NOAURA;
+
+            CLEANSE = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+            if (checkSealTimer > diff)              checkSealTimer -= diff;
+            if (checkShieldTimer > diff)            checkShieldTimer -= diff;
+            if (checkBeaconTimer > diff)            checkBeaconTimer -= diff;
+            if (avDelayTimer > diff)                avDelayTimer -= diff;
+            if (shieldDelayTimer > diff)            shieldDelayTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isHoly = _spec == BOT_SPEC_PALADIN_HOLY;
+            bool isProt = _spec == BOT_SPEC_PALADIN_PROTECTION;
+            bool isRetr = _spec == BOT_SPEC_PALADIN_RETRIBUTION;
+
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+            InitSpellMap(JUDGEMENT_OF_LIGHT_1);
+            InitSpellMap(JUDGEMENT_OF_WISDOM_1);
+            InitSpellMap(JUDGEMENT_OF_JUSTICE_1);
+            InitSpellMap(CONSECRATION_1);
+            InitSpellMap(HAMMER_OF_WRATH_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(RIGHTEOUS_FURY_1);
+            InitSpellMap(SHIELD_OF_RIGHTEOUSNESS_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(FIRE_RESISTANCE_AURA_1);
+            InitSpellMap(FROST_RESISTANCE_AURA_1);
+            InitSpellMap(SHADOW_RESISTANCE_AURA_1);
+            InitSpellMap(RETRIBUTION_AURA_1);
+            InitSpellMap(CRUSADER_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HAND_OF_FREEDOM_1);
+            InitSpellMap(HAND_OF_SALVATION_1);
+            InitSpellMap(HAND_OF_SACRIFICE_1);
+            InitSpellMap(HAND_OF_RECKONING_1);
+            InitSpellMap(RIGHTEOUS_DEFENSE_1);
+            //InitSpellMap(PURIFY_1);
+            //InitSpellMap(CLEANSE_1);
+            InitSpellMap(SEAL_OF_LIGHT_1);
+            InitSpellMap(SEAL_OF_RIGHTEOUSNESS_1);
+            InitSpellMap(SEAL_OF_WISDOM_1);
+            InitSpellMap(SEAL_OF_JUSTICE_1);
+            InitSpellMap((me->GetRaceMask() & RACEMASK_ALLIANCE) ? SEAL_OF_VENGEANCE_1 : SEAL_OF_CORRUPTION_1);
+            InitSpellMap(DIVINE_INTERVENTION_1);
+            InitSpellMap(DIVINE_PROTECTION_1);
+            InitSpellMap(DIVINE_SHIELD_1);
+
+  /*Talent*/lvl >= (isHoly ? 20 : 70) ? InitSpellMap(AURA_MASTERY_1) : RemoveSpell(AURA_MASTERY_1);
+  /*Talent*/lvl >= 30 && isHoly ? InitSpellMap(DIVINE_FAVOR_1) : RemoveSpell(DIVINE_FAVOR_1);
+  /*Talent*/lvl >= 40 && isHoly ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+  /*Talent*/lvl >= 50 && isHoly ? InitSpellMap(DIVINE_ILLUMINATION_1) : RemoveSpell(DIVINE_ILLUMINATION_1);
+  /*Talent*/lvl >= 60 && isHoly ? InitSpellMap(BEACON_OF_LIGHT_1) : RemoveSpell(BEACON_OF_LIGHT_1);
+
+  /*Talent*/lvl >= (isProt ? 20 : isHoly ? 70 : 99) ? InitSpellMap(DIVINE_SACRIFICE_1) : RemoveSpell(DIVINE_SACRIFICE_1);
+  /*Talent*/lvl >= 30 && isProt ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+  /*Talent*/lvl >= 40 && isProt ? InitSpellMap(HOLY_SHIELD_1) : RemoveSpell(HOLY_SHIELD_1);
+  /*Talent*/lvl >= 50 && isProt ? InitSpellMap(AVENGERS_SHIELD_1) : RemoveSpell(AVENGERS_SHIELD_1);
+  /*Talent*/lvl >= 60 && isProt ? InitSpellMap(HAMMER_OF_THE_RIGHTEOUS_1) : RemoveSpell(HAMMER_OF_THE_RIGHTEOUS_1);
+
+  /*Talent*/lvl >= 20 && isRetr ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 40 && isRetr ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+  /*Talent*/lvl >= 50 && isRetr ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+  /*Talent*/lvl >= 60 && isRetr ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+
+            CLEANSE = InitSpell(me, CLEANSE_1) ? CLEANSE_1 : PURIFY_1;
+            RemoveSpell(CLEANSE_1);
+            RemoveSpell(PURIFY_1);
+            InitSpellMap(CLEANSE);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isHoly = _spec == BOT_SPEC_PALADIN_HOLY;
+            bool isProt = _spec == BOT_SPEC_PALADIN_PROTECTION;
+            bool isRetr = _spec == BOT_SPEC_PALADIN_RETRIBUTION;
+
+            RefreshAura(ILLUMINATION, isHoly && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_LAY_ON_HANDS, isHoly && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_CONCENTRATION_AURA, isHoly && level >= 25 ? 1 : 0);
+            RefreshAura(LIGHTS_GRACE, isHoly && level >= 40 ? 1 : 0);
+            RefreshAura(SACRED_CLEANSING, isHoly && level >= 45 ? 1 : 0);
+            RefreshAura(JUDGEMENTS_OF_THE_PURE, isHoly && level >= 50 ? 1 : 0);
+            RefreshAura(INFUSION_OF_LIGHT, isHoly && level >= 55 ? 1 : 0);
+            RefreshAura(RECUCED_HOLY_LIGHT_CAST_TIME, isHoly && level >= 60 ? 1 : 0); //
+
+            RefreshAura(IMPROVED_RIGHTEOUS_FURY, isProt && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOTION_AURA, isProt && level >= 25 ? 1 : 0);
+            RefreshAura(DIVINE_GUARDIAN, isProt && level >= 25 ? 1 : 0);
+            RefreshAura(RECKONING5, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(RECKONING4, isProt && level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(RECKONING3, isProt && level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(RECKONING2, isProt && level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(RECKONING1, isProt && level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(ONE_HANDED_WEAPON_SPECIALIZATION, isProt && level >= 35 ? 1 : 0);
+            RefreshAura(ARDENT_DEFENDER, isProt && level >= 40 ? 1 : 0);
+            //RefreshAura(COMBAT_EXPERTISE, isProt && level >= 45 ? 1 : 0);
+            RefreshAura(REDOUBT3, isProt && level >= 55 ? 1 : 0);
+            RefreshAura(REDOUBT2, isProt && level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(REDOUBT1, isProt && level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(GUARDED_BY_THE_LIGHT, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(TOUCHED_BY_THE_LIGHT, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(SHIELD_OF_THE_TEMPLAR, isProt && level >= 55 ? 1 : 0);
+            //RefreshAura(JUDGEMENTS_OF_THE_JUST, isProt && level >= 55 ? 1 : 0);
+
+            RefreshAura(HEART_OF_THE_CRUSADER, isRetr && level >= 15 ? 1 : 0);
+            RefreshAura(PURSUIT_OF_JUSTICE, isRetr && level >= 20 ? 1 : 0);
+            RefreshAura(FANATICISM, isRetr && level >= 20 ? 1 : 0);
+            RefreshAura(VINDICATION2, isRetr && level >= 25 ? 1 : 0);
+            RefreshAura(VINDICATION1, isRetr && level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(CRUSADE, isRetr && level >= 25 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, isRetr && level >= 30 ? 1 : 0);
+            RefreshAura(SANCTIFIED_RETRIBUTION, isRetr && level >= 30 ? 1 : 0);
+            RefreshAura(VENGEANCE3, isRetr && level >= 40 ? 1 : 0);
+            RefreshAura(VENGEANCE2, isRetr && level >= 37 && level < 40 ? 1 : 0);
+            RefreshAura(VENGEANCE1, isRetr && level >= 35 && level < 37 ? 1 : 0);
+            RefreshAura(DIVINE_PURPOSE, isRetr && level >= 35 ? 1 : 0);
+            RefreshAura(JUDGEMENTS_OF_THE_WISE, isRetr && level >= 40 ? 1 : 0);
+            RefreshAura(ART_OF_WAR, isRetr && level >= 40 ? 1 : 0);
+            RefreshAura(SWIFT_RETRIBUTION, isRetr && level >= 50 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT3, isRetr && level >= 60 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT2, isRetr && level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT1, isRetr && level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE3, isRetr && level >= 60 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE2, isRetr && level >= 57 && level < 60 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE1, isRetr && level >= 55 && level < 57 ? 1 : 0);
+
+            RefreshAura(GLYPH_HOLY_LIGHT, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_SALVATION, level >= 26 ? 1 : 0);
+
+            RefreshAura(JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE);
+
+            //RefreshAura(CLEANSE_HEAL_PASSIVE, level >= 58 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HAND_OF_FREEDOM_1:
+                case SACRED_SHIELD_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HAND_OF_SALVATION_1:
+                case HAND_OF_SACRIFICE_1:
+                //case SEAL_OF_COMMAND_1:
+                //case SEAL_OF_LIGHT_1:
+                //case SEAL_OF_RIGHTEOUSNESS_1:
+                //case SEAL_OF_WISDOM_1:
+                //case SEAL_OF_JUSTICE_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                case HOLY_SHOCK_1:
+                    return HasRole(BOT_ROLE_HEAL);
+                case DEVOTION_AURA_1:
+                    return _aura != DEVOTIONAURA;
+                case CONCENTRATION_AURA_1:
+                    return _aura != CONCENTRATIONAURA;
+                case FIRE_RESISTANCE_AURA_1:
+                    return _aura != FIRERESAURA;
+                case FROST_RESISTANCE_AURA_1:
+                    return _aura != FROSTRESAURA;
+                case SHADOW_RESISTANCE_AURA_1:
+                    return _aura != SHADOWRESAURA;
+                case RETRIBUTION_AURA_1:
+                    return _aura != RETRIBUTIONAURA;
+                case CRUSADER_AURA_1:
+                    return _aura != CRUSADERAURA;
+                case PURIFY_1:
+                    return !GetSpell(CLEANSE_1);
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList) override
+        {
+            std::ostringstream msg1;
+            msg1 << "Aura: ";
+            switch (_aura)
+            {
+                case DEVOTIONAURA:
+                    msg1 << "Devotion Aura";
+                    break;
+                case CONCENTRATIONAURA:
+                    msg1 << "Concentration Aura";
+                    break;
+                case FIRERESAURA:
+                    msg1 << "Fire Resistance Aura";
+                    break;
+                case FROSTRESAURA:
+                    msg1 << "Frost Resistance Aura";
+                    break;
+                case SHADOWRESAURA:
+                    msg1 << "Shadow Resistance Aura";
+                    break;
+                case RETRIBUTIONAURA:
+                    msg1 << "Retribution Aura";
+                    break;
+                case CRUSADERAURA:
+                    msg1 << "Crusader Aura";
+                    break;
+                case NOAURA:
+                default:
+                    msg1 << "No Aura";
+                    break;
+            }
+            specList.push_back(msg1.str());
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, HOLY_SHOCK_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HOLY_SHOCK_HEAL_1));
+                _heals[HOLY_SHOCK_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[HOLY_SHOCK_1] = 0;
+
+            if (InitSpell(me, HOLY_LIGHT_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HOLY_LIGHT_1));
+                _heals[HOLY_LIGHT_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[HOLY_LIGHT_1] = 0;
+
+            if (InitSpell(me, FLASH_OF_LIGHT_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, FLASH_OF_LIGHT_1));
+                _heals[FLASH_OF_LIGHT_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[FLASH_OF_LIGHT_1] = 0;
+        }
+
+    private:
+        //Spells
+        uint32 CLEANSE;
+        //Timers
+/*misc*/uint32 checkAuraTimer, checkSealTimer, checkShieldTimer, checkBeaconTimer, avDelayTimer, shieldDelayTimer;
+        //Special
+/*misc*/uint8 _aura;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+
+        //uint32 _getBlessingsMask(Unit const*) const
+        //Scans target for auras which are related to paladin's blessings
+        //(even if aura is just incompatible with one)
+        //returns applied blessings mask
+        //used for finding out which blessings target lacks
+        uint32 _getBlessingsMask(Unit const* target) const
+        {
+            uint32 mask = 0;
+
+            bool blessing;
+            Unit::AuraApplicationMap const& aurapps = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                blessing = true;
+                switch (itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id)
+                {
+                    case BLESSING_OF_WISDOM_1:
+                    case GREATER_BLESSING_OF_WISDOM_1:
+                        mask |= SPECIFIC_BLESSING_WISDOM;
+                        break;
+                    case BLESSING_OF_KINGS_1:
+                    case GREATER_BLESSING_OF_KINGS_1:
+                        mask |= SPECIFIC_BLESSING_KINGS;
+                        break;
+                    case BLESSING_OF_SANCTUARY_1:
+                    case GREATER_BLESSING_OF_SANCTUARY_1:
+                        mask |= SPECIFIC_BLESSING_SANCTUARY;
+                        break;
+                    case BLESSING_OF_MIGHT_1:
+                    case GREATER_BLESSING_OF_MIGHT_1:
+                    case BATTLESHOUT_1:
+                        mask |= SPECIFIC_BLESSING_MIGHT;
+                        break;
+                    default:
+                        blessing = false; //next aura
+                        break;
+                }
+
+                if (blessing && itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                    mask |= SPECIFIC_BLESSING_MY_BLESSING;
+            }
+
+            return mask;
+        }
+        //uint32 _getAurasMask(Unit const*) const
+        //Scans target for paladin's auras
+        //returns applied auras mask
+        //used for finding out which auras target lacks
+        uint32 _getAurasMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            uint32 baseId;
+            bool isAura;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                isAura = true;
+                baseId = itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    case DEVOTION_AURA_1:
+                        mask |= SPECIFIC_AURA_DEVOTION;
+                        break;
+                    case CONCENTRATION_AURA_1:
+                        mask |= SPECIFIC_AURA_CONCENTRATION;
+                        break;
+                    case FIRE_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_FIRE_RES;
+                        break;
+                    case FROST_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_FROST_RES;
+                        break;
+                    case SHADOW_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_SHADOW_RES;
+                        break;
+                    case RETRIBUTION_AURA_1:
+                        mask |= SPECIFIC_AURA_RETRIBUTION;
+                        break;
+                    case CRUSADER_AURA_1:
+                        mask |= SPECIFIC_AURA_CRUSADER;
+                        break;
+                    default:
+                        isAura = false; //next aura
+                        break;
+                }
+
+                if (isAura)
+                {
+                    idMap[baseId] = itr->first;
+                    if (itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                        mask |= SPECIFIC_AURA_MY_AURA;
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..77c1fe5
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,2046 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Priest NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - Around 90%
+TODO: Mana Burn, Binding Heal, Lightwell
+*/
+
+enum PriestBaseSpells
+{
+    DISPEL_MAGIC_1                      = 527,
+    MASS_DISPEL_1                       = 32375,
+    CURE_DISEASE_1                      = 528,
+    ABOLISH_DISEASE_1                   = 552,
+    FEAR_WARD_1                         = 6346,
+    PAIN_SUPPRESSION_1                  = 33206,
+    PSYCHIC_SCREAM_1                    = 8122,
+    FADE_1                              = 586,
+    PSYCHIC_HORROR_1                    = 64044,
+    SILENCE_1                           = 15487,
+    PENANCE_1                           = 47540,
+    VAMPIRIC_EMBRACE_1                  = 15286,
+    DISPERSION_1                        = 47585,
+    MIND_SEAR_1                         = 48045,
+    GUARDIAN_SPIRIT_1                   = 47788,
+    SHACKLE_UNDEAD_1                    = 9484,
+    LESSER_HEAL_1                       = 2050,
+    NORMAL_HEAL_1                       = 2054,
+    GREATER_HEAL_1                      = 2060,
+    RENEW_1                             = 139,
+    FLASH_HEAL_1                        = 2061,
+    PRAYER_OF_HEALING_1                 = 596,
+    CIRCLE_OF_HEALING_1                 = 34861,
+    DIVINE_HYMN_1                       = 64843,
+    PRAYER_OF_MENDING_1                 = 33076,
+    RESURRECTION_1                      = 2006,
+    PW_SHIELD_1                         = 17,
+    INNER_FIRE_1                        = 588,
+    PW_FORTITUDE_1                      = 1243,
+    SHADOW_PROTECTION_1                 = 976,
+    DIVINE_SPIRIT_1                     = 14752,
+    HOLY_FIRE_1                         = 14914,
+    SMITE_1                             = 585,
+    SW_PAIN_1                           = 589,
+    MIND_BLAST_1                        = 8092,
+    SW_DEATH_1                          = 32379,
+    DEVOURING_PLAGUE_1                  = 2944,
+    MIND_FLAY_1                         = 15407,
+    VAMPIRIC_TOUCH_1                    = 34914,
+    SHADOWFORM_1                        = 15473,
+    INNER_FOCUS_1                       = 14751,
+    DESPERATE_PRAYER_1                  = 19236,
+    POWER_INFUSION_1                    = 10060,
+    HYMN_OF_HOPE_1                      = 64901,
+
+    LEVITATE_1                          = 1706
+};
+enum PriestPassives
+{
+//Talents
+    UNBREAKABLE_WILL                = 14791,//rank 5
+    SPIRIT_TAP                      = 15336,//rank 3
+    IMPROVED_SPIRIT_TAP             = 15338,//rank 2
+    MEDITATION                      = 14777,//rank 3
+    INSPIRATION1                    = 14892,
+    INSPIRATION2                    = 15362,
+    INSPIRATION3                    = 15363,
+    SHADOW_WEAVING1                 = 15257,
+    SHADOW_WEAVING2                 = 15331,
+    SHADOW_WEAVING3                 = 15332,
+    SURGE_OF_LIGHT                  = 33154,//rank 2
+    IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+    HOLY_CONCENTRATION              = 34860,//rank 3
+    RENEWED_HOPE                    = 57472,//rank 3
+    RAPTURE                         = 47537,//rank 3
+    BODY_AND_SOUL1                  = 64127,
+    SERENDIPITY                     = 63737,//rank 3
+    IMPROVED_SHADOWFORM             = 47570,//rank 2
+    MISERY1                         = 33191,
+    MISERY2                         = 33192,
+    MISERY3                         = 33193,
+    DIVINE_AEGIS                    = 47515,//rank 3
+    GRACE                           = 47517,//rank 2
+    EMPOWERED_RENEW1                = 63534,
+    EMPOWERED_RENEW2                = 63542,
+    EMPOWERED_RENEW3                = 63543,
+    BORROWED_TIME                   = 52800,//rank 5
+//Glyphs
+    //GLYPH_SW_PAIN                   = 55681,
+    GLYPH_PW_SHIELD                 = 55672,
+    GLYPH_DISPEL_MAGIC              = 55677,
+    GLYPH_PRAYER_OF_HEALING         = 55680,
+    GLYPH_SHADOW                    = 55689,
+//other
+    PRIEST_T10_2P_BONUS             = 70770 //33% renew
+};
+enum PriestSpecial
+{
+    SHADOW_WEAVING_BUFF             = 15258,
+    MIND_FLAY_DAMAGE                = 58381,
+    MIND_SEAR_DAMAGE_1              = 49821,
+    SW_DEATH_BACKLASH               = 32409,
+    WEAKENED_SOUL_DEBUFF            = 6788,
+    SURGE_OF_LIGHT_BUFF             = 33151,
+    SERENDIPITY_BUFF                = 63734,
+    DIVINE_HYMN_HEAL                = 64844,
+    PRAYER_OF_MENDING_AURA_1        = 41635,
+    PRAYER_OF_MENDING_HEAL          = 33110,
+    PENANCE_HEAL_1                  = 47750,
+    IMPROVED_MIND_BLAST_DEBUFF      = 48301,//Mind Trauma
+    HYMN_OF_HOPE_BUFF               = 64904,
+
+    SHADOWFIEND_1                   = 34433
+};
+
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct priest_botAI : public bot_ai
+    {
+        priest_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_PRIEST;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void CheckHymnOfHope(uint32 diff)
+        {
+            if (!IsSpellReady(HYMN_OF_HOPE_1, diff) || IAmFree() || Rand() > 45 || IsCasting() || IsTank())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                return;
+
+            uint8 LMPcount = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || me->GetMap() != player->FindMap())
+                    continue;
+                if (player->IsAlive() && player->IsInCombat() && me->GetDistance(player) < 40 &&
+                    GetManaPCT(player) < (HasRole(BOT_ROLE_HEAL) ? 10 : 50) &&
+                    !player->GetAuraEffect(SPELL_AURA_MOD_INCREASE_ENERGY, SPELLFAMILY_PRIEST, 0x0, 0x0, 0x10))
+                    if (++LMPcount > 2)
+                        break;
+
+                if (!player->HaveBot())
+                    continue;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (bot->IsInWorld() && bot->IsAlive() && bot->IsInCombat() && me->GetDistance(bot) < 40 &&
+                        GetManaPCT(bot) < (HasRole(BOT_ROLE_HEAL) ? 10 : 50) &&
+                        !bot->GetAuraEffect(SPELL_AURA_MOD_INCREASE_ENERGY, SPELLFAMILY_PRIEST, 0x0, 0x0, 0x10))
+                        if (++LMPcount > 2)
+                            break;
+                }
+                if (LMPcount > 2)
+                    break;
+            }
+            if (LMPcount > 2 && doCast(me, GetSpell(HYMN_OF_HOPE_1)))
+                return;
+        }
+
+        bool MassGroupHeal(uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (IAmFree() || !master->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 65 + 40 * me->GetMap()->IsRaid()) return false;
+
+            Group const* gr = master->GetGroup();
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player const* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (tPlayer->IsAlive() && tPlayer->IsInCombat() && me->GetDistance(tPlayer) < 48)
+                    {
+                        uint32 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            if (++LHPcount > 2)
+                                break;
+                    }
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature const* bot = it->second;
+                        if (bot && bot->IsAlive() && bot->IsInCombat() && GetHealthPCT(bot) < 60 &&
+                            GetLostHP(bot) > 4000 && me->GetDistance(bot) < 48)
+                            if (++LHPcount > 2)
+                                break;
+                    }
+                    if (LHPcount > 2)
+                        break;
+                }
+                if (LHPcount > 2 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                    return true;
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    //uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (tPlayer->IsAlive() && GetHealthPCT(tPlayer) < 65 && me->GetDistance(tPlayer) < 36)
+                        if (++LHPcount > 3)
+                            break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot->IsInWorld() && bot->IsAlive() && GetHealthPCT(bot) < 65 && me->GetDistance(bot) < 36)
+                            if (++LHPcount > 3)
+                                break;
+                    }
+                    if (LHPcount > 3)
+                        break;
+                }
+
+                if (LHPcount > 3)
+                {
+                    if (me->IsInCombat() && IsSpellReady(INNER_FOCUS_1, diff) && GetManaPCT(me) < 70 &&
+                        doCast(me, GetSpell(INNER_FOCUS_1)))
+                    {}
+                    if (doCast(me, GetSpell(PRAYER_OF_HEALING_1)))
+                        return true;
+                }
+            }
+            if (IsSpellReady(CIRCLE_OF_HEALING_1, diff))
+            {
+                Unit* castTarget = nullptr;
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (GetHealthPCT(tPlayer) < 85 && me->GetDistance(tPlayer) < 40 &&
+                        (!castTarget || castTarget->GetDistance(tPlayer) < 18))
+                    {
+                        ++LHPcount;
+                        if (GetHealthPCT(tPlayer) < lowestPCT)
+                        {
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && GetHealthPCT(bot) < 85 && me->GetDistance(bot) < 40 &&
+                            (!castTarget || castTarget->GetDistance(bot) < 18))
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            {
+                                lowestPCT = GetHealthPCT(bot);
+                                castTarget = bot;
+                            }
+                        }
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 1 && castTarget && doCast(castTarget, GetSpell(CIRCLE_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldGroup(uint32 diff)
+        {
+            if (GC_Timer > diff || IAmFree() || IsCasting()) return false;
+            if (!IsSpellReady(PW_SHIELD_1, diff)) return false;
+            if (Rand() > 65 + 100 * (me->GetMap()->IsRaid())) return false;
+
+            Group const* gr = master->GetGroup();
+            Unit* u = master;
+            if (!gr)
+            {
+                if (u->IsAlive() && !u->getAttackers().empty() && (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                    ShieldTarget(u, diff))
+                    return true;
+                BotMap const* map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && !u->getAttackers().empty() && !u->ToCreature()->IsTempBot() &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+                for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsPet() || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->IsTotem()) continue;
+                    if (u->IsAlive() && !u->getAttackers().empty() &&
+                        !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsTempBot()) &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+                return false;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                    continue;
+                u = tPlayer;
+                if (u->IsAlive() && !u->getAttackers().empty() && (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                    ShieldTarget(u, diff))
+                    return true;
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        u = itr->second;
+                        if (u->IsAlive() && !u->getAttackers().empty() && !u->ToCreature()->IsTempBot() &&
+                            (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                            ShieldTarget(u, diff))
+                            return true;
+                    }
+                }
+                for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->IsTotem()) continue;
+                    if (u->IsAlive() && !u->getAttackers().empty() &&
+                        !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsTempBot()) &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff) || IsCasting())
+                return false;
+            //if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+            //    return false;
+            if (target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_PRIEST, 0x20000000) ||
+                target->HasAuraTypeWithFamilyFlags(SPELL_AURA_SCHOOL_ABSORB, SPELLFAMILY_PRIEST, 0x1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+                return true;
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+
+        bool removeShapeshiftForm() override
+        {
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_SHADOW:
+                        me->RemoveAurasDueToSpell(SHADOWFORM_1);
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            return true;
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            //Improved Shadowform: Fade
+            if (IsSpellReady(FADE_1, diff) && me->GetShapeshiftForm() == FORM_SHADOW && me->GetLevel() >= 45 &&
+                Rand() < 35 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (doCast(me, GetSpell(FADE_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            Disperse(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoDevCheck(diff);
+            DoShackCheck(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50 && (!HasRole(BOT_ROLE_HEAL) || me->HasAuraType(SPELL_AURA_MOD_SILENCE)))
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            doDefend(diff);
+
+            if (me->GetMap()->IsRaid())
+            {
+                CureGroup(GetSpell(DISPEL_MAGIC_1), diff);
+                CureGroup(GetSpell(ABOLISH_DISEASE_1) ? GetSpell(ABOLISH_DISEASE_1) : GetSpell(CURE_DISEASE_1), diff);
+                MassGroupHeal(diff);
+                ShieldGroup(diff);
+                CheckMending(diff);
+                BuffAndHealGroup(diff);
+            }
+            else
+            {
+                MassGroupHeal(diff);
+                ShieldGroup(diff);
+                CheckMending(diff);
+                BuffAndHealGroup(diff);
+                CureGroup(GetSpell(DISPEL_MAGIC_1), diff);
+                CureGroup(GetSpell(CURE_DISEASE_1), diff);
+            }
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckSilence(diff);
+                CheckDispel(diff);
+                CheckHymnOfHope(diff);
+            }
+
+            if (me->IsInCombat())
+            {
+                CheckShackles(diff);
+                CheckPowerInfusion(diff);
+            }
+            else
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (IsSpellReady(SHADOWFORM_1, diff) && HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_HEAL))
+            {
+                if (doCast(me, SHADOWFORM_1))
+                    return;
+            }
+
+            if (!CheckAttackTarget())
+                return;
+
+            Counter(diff);
+
+            StartAttack(opponent, IsMelee());
+
+            if (GC_Timer > diff)
+                return;
+
+            //shadow skills range
+            if (me->GetDistance(opponent) > CalcSpellMaxRange(MIND_FLAY_1))
+                return;
+
+            bool canShadow = CanAffectVictim(SPELL_SCHOOL_MASK_SHADOW);
+            bool canHoly = CanAffectVictim(SPELL_SCHOOL_MASK_HOLY);
+
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff) && canShadow && Rand() < 20 &&
+                opponent->GetHealth() > me->GetMaxHealth()/8 && !CCed(opponent) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER ?
+                opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) && opponent->ToPlayer()->IsUseEquipedWeapon(true) :
+                opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && opponent->CanUseAttackType(BASE_ATTACK)))
+            {
+                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
+                    return;
+            }
+
+            //spell reflections
+            if (IsSpellReady(SW_PAIN_1, diff) && canShadow && CanRemoveReflectSpells(opponent, SW_PAIN_1) &&
+                doCast(opponent, SW_PAIN_1)) //yes, using rank 1
+                return;
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(SHADOWFIEND_1, diff) && GetManaPCT(me) < 50)
+            {
+                SummonBotPet(opponent);
+                SetSpellCooldown(SHADOWFIEND_1, 180000); // (5 - 2) min with Veiled Shadows
+                return;
+            }
+
+            if (!HasRole(BOT_ROLE_HEAL) || GetManaPCT(me) > 35 || botPet)
+            {
+                if (IsSpellReady(SW_DEATH_1, diff) && canShadow && Rand() < 90 && GetHealthPCT(me) > 50 &&
+                    (me->GetMap()->IsRaid() || GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/8) &&
+                    doCast(opponent, GetSpell(SW_DEATH_1)))
+                    return;
+                if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && canShadow && Rand() < 80 &&
+                    opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x0, 0x400, 0x0, me->GetGUID()) &&
+                    doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
+                    return;
+                if (IsSpellReady(SW_PAIN_1, diff) && canShadow && Rand() < 60 &&
+                    opponent->GetHealth() > me->GetMaxHealth()/2 * (1 + opponent->getAttackers().size()) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0x0, 0x0, me->GetGUID()))
+                {
+                    AuraEffect const* weav = me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_PRIEST, 0x0, 0x8, 0x0);
+                    if (me->GetLevel() < 60 || (weav && weav->GetBase()->GetStackAmount() >= 4))
+                        if (doCast(opponent, GetSpell(SW_PAIN_1)))
+                            return;
+                }
+                if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && canShadow && !Devcheck && Rand() < 80 &&
+                    (_spec == BOT_SPEC_PRIEST_SHADOW || opponent->IsControlledByPlayer()) &&
+                    opponent->GetHealth() > me->GetMaxHealth()/2 * (1 + opponent->getAttackers().size()) &&
+                    !(opponent->GetTypeId() == TYPEID_UNIT && (opponent->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_INFECTED-1)))) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_LEECH, SPELLFAMILY_PRIEST, 0x02000000, 0x0, 0x0, me->GetGUID()) &&
+                    doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
+                    return;
+                if (IsSpellReady(MIND_BLAST_1, diff) && canShadow &&
+                    doCast(opponent, GetSpell(MIND_BLAST_1)))
+                    return;
+                if (IsSpellReady(MIND_SEAR_1, diff) && canShadow && (!me->isMoving() || Rand() < 80) &&
+                    opponent->GetVictim() && opponent->GetVictim()->getAttackers().size() > 3)
+                {
+                    if (Unit* u = FindSplashTarget(CalcSpellMaxRange(MIND_SEAR_1), opponent, 14.f, 3)) //glyphed, cluster of 4
+                        if (doCast(u, GetSpell(MIND_SEAR_1)))
+                            return;
+                }
+                if (IsSpellReady(HOLY_FIRE_1, diff) && canHoly &&
+                    (HasRole(BOT_ROLE_HEAL) || me->GetShapeshiftForm() != FORM_SHADOW) &&
+                    doCast(opponent, GetSpell(HOLY_FIRE_1)))
+                    return;
+                if (IsSpellReady(MIND_FLAY_1, diff) && canShadow &&
+                    (!HasRole(BOT_ROLE_HEAL) || opponent->GetHealth() < me->GetMaxHealth()/2) &&
+                    doCast(opponent, GetSpell(MIND_FLAY_1)))
+                    return;
+                if (IsSpellReady(SMITE_1, diff) && canHoly && me->GetLevel() < 20 &&//MF is lvl 20, MB is lvl 10
+                    doCast(opponent, GetSpell(SMITE_1)))
+                    return;
+            }
+
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == SHOOT_WAND && shot->m_targets.GetUnitTarget() != opponent)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (IsSpellReady(SHOOT_WAND, diff) && me->GetDistance(opponent) < 30 && GetEquips(BOT_SLOT_RANGED) &&
+                doCast(opponent, SHOOT_WAND))
+                return;
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 90 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * (me->GetLevel() < 60 ? 2.5f : 2.0f);
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * (me->GetLevel() < 60 ? 2.5f : 2.0f);
+            //TC_LOG_ERROR("entities.player", "priest_bot:HealTarget(): %s's pct %u, hppctps %i, epct %i",
+            //    target->GetName().c_str(), uint32(hp), int32(hppctps), int32(xppct));
+            if (xppct >= 95 && hp >= 25)
+                return false;
+
+            //GUARDIAN SPIRIT no GCD
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && !IAmFree() && target->IsInCombat() && !target->getAttackers().empty() &&
+                (xppct <= 0 || (hp <= 50 && hppctps <= -15) ||
+                (me->GetMap()->Instanceable() && target->GetMaxHealth() > me->GetMaxHealth() << 5)) &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_PRIEST, 0x40000000))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Guardian Spirit on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                    //return true;
+                }
+            }
+
+            //PAIN SUPPRESSION
+            if (IsSpellReady(PAIN_SUPPRESSION_1, diff, false) && xppct >= 5 && hp >= 25 && hp <= 55 && hppctps <= -10 &&
+                Rand() < 80 && !target->getAttackers().empty() &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_DISPEL_RESIST, SPELLFAMILY_PRIEST, 0x80000000) &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_PRIEST, 0x40000000))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Pain Suppression on you!", target->ToPlayer());
+                    if (target != master)
+                    {
+                        std::ostringstream msg;
+                        msg << "Pain Suppression on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str());
+                    }
+                    return true;
+                }
+            }
+
+            if (target == me && IsSpellReady(DESPERATE_PRAYER_1, diff) && hp <= 50 && Rand() < 45 &&
+                int32(GetLostHP(me)) > _heals[DESPERATE_PRAYER_1])
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(DESPERATE_PRAYER_1)))
+                    return true;
+            }
+
+            if (IsCasting())
+                return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->isWorldBoss();
+
+            //Penance
+            if (IsSpellReady(PENANCE_1, diff) && !target->IsCharmed() && !target->isPossessed() && hp <= 80 &&
+                Rand() < 90 && xphploss > _heals[PENANCE_1])
+            {
+                if (doCast(target, GetSpell(PENANCE_1)))
+                    return true;
+            }
+            //Big Heal
+            if (IsSpellReady(HEAL, diff) && (xppct > 15 || !GetSpell(FLASH_HEAL_1)) && (tanking || xphploss > _heals[HEAL]))
+            {
+                if (me->IsInCombat() && IsSpellReady(INNER_FOCUS_1, diff) && GetManaPCT(me) < 70 &&
+                    doCast(me, GetSpell(INNER_FOCUS_1)))
+                {}
+                if (doCast(target, GetSpell(HEAL)))
+                    return true;
+            }
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) && (tanking || !target->getAttackers().empty() || me->GetMap()->IsDungeon()) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_PRIEST, 0x40, 0x0, 0x0, me->GetGUID())
+                /*!target->HasAura(GetSpell(RENEW_1), me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(RENEW_1)))
+                    return true;
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff) && xphploss > _heals[FLASH_HEAL_1])
+            {
+                if (doCast(target, GetSpell(FLASH_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff) override
+        {
+            if (IsSpellReady(FEAR_WARD_1, diff) && (!IAmFree() || target == me) &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, MECHANIC_FEAR) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+                return true;
+
+            if (target == me)
+            {
+                if (GetSpell(INNER_FIRE_1) &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_PRIEST, 0x2) &&
+                    doCast(me, GetSpell(INNER_FIRE_1)))
+                    return true;
+                if (HasRole(BOT_ROLE_DPS) && GetSpell(VAMPIRIC_EMBRACE_1) &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_DUMMY, SPELLFAMILY_PRIEST, 0x4) &&
+                    doCast(me, GetSpell(VAMPIRIC_EMBRACE_1)))
+                    return true;
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid())
+                return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_PRIEST, 0x8) &&
+                    doCast(target, PW_FORTITUDE))
+                    return true;
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_EXCLUSIVE, SPELLFAMILY_PRIEST, 0x100) &&
+                    doCast(target, SHADOW_PROTECTION))
+                    return true;
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if ((target->GetMaxPower(POWER_MANA) > 1) &&
+                    !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_PRIEST, 0x20) &&
+                    doCast(target, DIVINE_SPIRIT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(RESURRECTION_1));
+
+            if (GetSpell(LEVITATE_1) && !IAmFree() && Rand() < 30)
+            {
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        Player* pl = ref->GetSource();
+                        if (pl && pl->IsAlive() && pl->FindMap() == me->GetMap() && pl->GetDistance(me) < 30 &&
+                            pl->IsFalling() && pl->m_movementInfo.fallTime > 1000 &&
+                            !pl->HasAuraType(SPELL_AURA_HOVER))
+                        {
+                            if (doCast(pl, GetSpell(LEVITATE_1)))
+                                return;
+                        }
+                    }
+                }
+                else if (master->IsAlive() && master->GetDistance(me) < 30 && master->IsFalling() &&
+                    master->m_movementInfo.fallTime > 1000 && !master->HasAuraType(SPELL_AURA_HOVER))
+                {
+                    if (doCast(master, GetSpell(LEVITATE_1)))
+                        return;
+                }
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (ShackcheckTimer > diff || !IsSpellReady(SHACKLE_UNDEAD_1, diff) || Shackcheck || Rand() > 65 ||
+                (HasRole(BOT_ROLE_HEAL) && (IsCasting() || GetManaPCT(me) < 20)))
+                return;
+
+            //always glyphed so <= 0.5 sec cast time
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(SHACKLE_UNDEAD_1), 0, SHACKLE_UNDEAD_1))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(SHACKLE_UNDEAD_1)))
+                    return;
+            }
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (HasRole(BOT_ROLE_HEAL) && !HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (DispelcheckTimer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            DispelcheckTimer = urand(750, 1000);
+
+            uint32 DM = GetSpell(DISPEL_MAGIC_1);
+            uint32 MD = (_spec == BOT_SPEC_PRIEST_DISCIPLINE) ? GetSpell(MASS_DISPEL_1) : 0;
+
+            if (!DM && !MD)
+                return;
+
+            if (Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(DISPEL_MAGIC_1)))
+            {
+                uint32 dm = DM && !target->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD) ? DM : MD;
+                if (dm && doCast(target, dm))
+                    return;
+            }
+        }
+
+        void CheckMending(uint32 diff)
+        {
+            if (Mend_Timer > diff || !HasRole(BOT_ROLE_HEAL) || !IsSpellReady(PRAYER_OF_MENDING_1, diff) ||
+                IAmFree() || !master->GetGroup() || IsCasting() || Rand() > 75)
+                return;
+
+            Mend_Timer = urand(1000, 3000);
+
+            uint32 MENDING_AURA = InitSpell(me, PRAYER_OF_MENDING_AURA_1); //always valid
+            if (FindAffectedTarget(MENDING_AURA, me->GetGUID(), 70, 4))
+                return;
+
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->IsAlive() && !player->getAttackers().empty() &&
+                    IsTank(player) && GetHealthPCT(player) < 85 && me->IsWithinDistInMap(player, 40) &&
+                    !player->HasAuraType(SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE))
+                {
+                    if (doCast(player, GetSpell(PRAYER_OF_MENDING_1)))
+                        return;
+                }
+
+                if (player->HaveBot())
+                {
+                    BotMap const* map = player->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (gr->IsMember(itr->second->GetGUID()) && itr->second->IsAlive() && !itr->second->getAttackers().empty() &&
+                            IsTank(itr->second) && GetHealthPCT(player) < 85 && me->IsWithinDistInMap(itr->second, 40) &&
+                            !itr->second->HasAuraType(SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE))
+                        {
+                            if (doCast(itr->second, GetSpell(PRAYER_OF_MENDING_1)))
+                                return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (Shackle_Timer > diff || !IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            Shackle_Timer = 500;
+
+            if (FindAffectedTarget(GetSpell(SHACKLE_UNDEAD_1), me->GetGUID(), 60, 255))
+                return;
+            Unit* target = FindUndeadCCTarget(CalcSpellMaxRange(SHACKLE_UNDEAD_1), SHACKLE_UNDEAD_1);
+            if (target && doCast(target, GetSpell(SHACKLE_UNDEAD_1)))
+            {}
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 40)
+                return;
+
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(SILENCE_1), 0, SILENCE_1))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                        return;
+            }
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(PSYCHIC_HORROR_1), 0, PSYCHIC_HORROR_1))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                        return;
+            }
+        }
+
+        void CheckPowerInfusion(uint32 diff)
+        {
+            if (!IsSpellReady(POWER_INFUSION_1, diff, false) || IsCasting() || Rand() > 25)
+                return;
+
+            if (IAmFree())
+            {
+                if (me->GetVictim() && GetManaPCT(me) < 95 &&
+                    doCast(me, GetSpell(POWER_INFUSION_1)))
+                    return;
+
+                return;
+            }
+
+            Group const* gr = master->GetGroup();
+            BotMap const* map;
+            Unit* u = nullptr;
+            if (!gr)
+            {
+                u = master;
+                if (u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                    GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                    !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                    doCast(u, GetSpell(POWER_INFUSION_1)))
+                    return;
+
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->ToCreature()->GetBotAI()->HasRole(BOT_ROLE_HEAL) &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (u && u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                    GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                    !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                    doCast(u, GetSpell(POWER_INFUSION_1)))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap() || !player->HaveBot())
+                    continue;
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->ToCreature()->GetBotAI()->HasRole(BOT_ROLE_HEAL) &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap() || !player->HaveBot())
+                    continue;
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+            }
+
+            SetSpellCooldown(POWER_INFUSION_1, 1500); //fail
+        }
+
+        void doDefend(uint32 diff)
+        {
+            if (Rand() > 50) return;
+
+            Unit::AttackerSet const& m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 95 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (!(*iter)->IsAlive()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetDistance((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        if (doCast(me, GetSpell(FADE_1)))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                DevcheckTimer = 1000;
+                Devcheck = GetSpell(DEVOURING_PLAGUE_1) && FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID(), 70);
+            }
+        }
+
+        void DoShackCheck(uint32 diff)
+        {
+            if (ShackcheckTimer <= diff)
+            {
+                ShackcheckTimer = 1000;
+                Shackcheck = GetSpell(SHACKLE_UNDEAD_1) && FindAffectedTarget(GetSpell(SHACKLE_UNDEAD_1), me->GetGUID(), 70);
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!IsSpellReady(DISPERSION_1, diff) || !me->IsInCombat() || HasRole(BOT_ROLE_HEAL) || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && (me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) || !me->getAttackers().empty())) ||
+                (GetManaPCT(me) < 35 && !IsPotionReady()) ||
+                (me->getAttackers().size() > 1 && (CCed(me, true) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE))))
+            {
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                    return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 500); //fail
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Inner Focus
+            if (AuraEffect const* focu = me->GetAuraEffect(INNER_FOCUS_1, 0))
+                if (focu->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 25.f;
+
+            //Benediction (23236)
+            if (lvl >= 60 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 2.f;
+            //Increased Prayer of Healing Criticals (23550): 25% additional critical chance for Prayer of Healing
+            if (lvl >= 60 && baseId == PRAYER_OF_HEALING_1)
+                crit_chance += 25.f;
+            //Item - Priest T9 Shadow 4P Bonus (67198)
+            if (lvl >= 80 && baseId == MIND_FLAY_DAMAGE)
+                crit_chance += 5.f;
+
+            //Holy Specialization: 5% additional critical chance for Holy spells
+            if (lvl >= 10 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 5.f;
+            //Mind Melt (part 1): 4% additional critical chance for Mind Blast, Mind Flay and Mind Sear
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x802000) || (spellInfo->SpellFamilyFlags[1] & 0x80000)))
+                crit_chance += 4.f;
+            //Mind Melt (part 2): 6% additional critical chance for Vampiric Touch, Devouring Plague and SW: Pain
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x2008000) || (spellInfo->SpellFamilyFlags[1] & 0x400)))
+                crit_chance += 6.f;
+            //Improved Flash Heal (part 2): 10% additional critical chance on targets at or below 50% hp for Flash Heal
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 40 && baseId == FLASH_HEAL_1 && GetHealthPCT(victim) <= 50)
+                crit_chance += 10.f;
+            //Renewed Hope part 1: 4% additional critical chance on targets affected by Weakened Soul for Flash Heal, Greater Heal and Penance (Heal)
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) &&
+                lvl >= 45 && (baseId == FLASH_HEAL_1 || baseId == HEAL || baseId == PENANCE_HEAL_1) &&
+                victim->HasAuraTypeWithFamilyFlags(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_PRIEST, 0x20000000))
+                crit_chance += 4.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Shadow Power: 50% additional crit damage bonus for Mind Blast, Mind Flay and SW:Death
+                if (lvl >= 40 &&
+                    (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_DAMAGE || baseId == SW_DEATH_1))
+                    pctbonus += 0.333f;
+                //Shadowform crit damage increase
+                if (me->GetShapeshiftForm() == FORM_SHADOW &&
+                    (baseId == SW_PAIN_1 || baseId == DEVOURING_PLAGUE_1 || baseId == VAMPIRIC_TOUCH_1))
+                    pctbonus += 0.333f;
+            }
+            //Improved Mind Flay and Smite (37571)
+            if (lvl >= 10 && (baseId == MIND_FLAY_DAMAGE || baseId == SMITE_1))
+                pctbonus += 0.05f;
+            //Item - Priest T8 Shadow 2P Bonus (64906)
+            if (lvl >= 80 && ((baseId == DEVOURING_PLAGUE_1) || (spellInfo->SpellFamilyFlags[2] & 0x8)))
+                pctbonus += 0.15f;
+
+            //Twin Disciplines (damage part): 5% bonus damage for instant spells
+            if (lvl >= 10 && !spellInfo->CastTimeEntry)
+                pctbonus += 0.05f;
+            //Darkness: 10% bonus damage for shadow spells
+            if (lvl >= 10 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Improved Shadow Word: Pain: 6% bonus damage for Shadow Word: Pain
+            if (lvl >= 15 && baseId == SW_PAIN_1)
+                pctbonus += 0.06f;
+            //Focused Power part 1: 4% bonus damage for all spells
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 35)
+                pctbonus += 0.04f;
+            //Improved Devouring Plague part 1: 15% bonus damage Devouring Plague
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 35 && baseId == DEVOURING_PLAGUE_1)
+                pctbonus += 0.15f;
+            //Shadowform: 15% bonus damage for shadow spells (handled)
+            //if (lvl >= 40 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW) && me->GetShapeshiftForm() == FORM_SHADOW)
+            //    pctbonus += 0.15f;
+            //Misery part 3: 15% bonus damage (from spellpower) for Mind Blast, Mind Flay and Mind Sear
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 45)
+            {
+                if (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_DAMAGE || baseId == MIND_SEAR_DAMAGE_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+
+            //If target is affected BY SW: Pain
+            if (lvl >= 20 && (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_DAMAGE) && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0x0, 0x0, me->GetGUID()))
+            {
+                //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+                if (baseId == MIND_FLAY_DAMAGE)
+                    pctbonus += 0.1f;
+                //Twisted Faith (part 1): 10% bonus damage for Mind Blast and Mind Flay
+                if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 55)
+                    pctbonus += 0.1f;
+            }
+
+            //Glyph of Shadow Word: Death: 10% bonus damage for Shadow Word: Death on targets below 35% health
+            if (lvl >= 62 && baseId == SW_DEATH_1 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.1f;
+
+            //other
+            if (baseId == SW_DEATH_BACKLASH)
+            {
+                //not affected by +%talents
+                pctbonus = 1.f;
+                ////T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                //if (lvl >= 60) //buffed
+                //    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 30% reduced backlash damage
+                if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 50)
+                    pctbonus -= 0.3f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //pct mods
+            //Improved Greater Heal (38411): 5% bonus healing for Greater Heal
+            if (lvl >= 60 && baseId == HEAL)
+                pctbonus += 0.05f;
+            //Priest T9 Healing 2P: 20% bonus healing for Prayer of Mending
+            if (lvl >= 80 && baseId == PRAYER_OF_MENDING_HEAL)
+                pctbonus += 0.2f;
+
+            //Twin Disciplines (healing part): 5% bonus healing for instant spells
+            if (lvl >= 10 && !spellInfo->CastTimeEntry)
+                pctbonus += 0.05f;
+            //Improved Renew: 15% bonus healing for Renew
+            if (lvl >= 10 && baseId == RENEW_1)
+                pctbonus += 0.15f;
+            //Focused Power part 2: 4% bonus heal for all spells
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 35)
+                pctbonus += 0.04f;
+            //Spiritual Healing: 10% bonus healing for all spells
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 35)
+                pctbonus += 0.15f;
+            //Blessend Resilience part 1: 3% bonus healing for all spells
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 40)
+                pctbonus += 0.03f;
+            //Empowered Healing: 40% bonus (from spellpower) for Greater Heal and 20% bonus (from spellpower) for Flash Heal and Binding Heal
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 45)
+            {
+                if (baseId == HEAL)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+                else if (baseId == FLASH_HEAL_1/* || baseId == BINDING_HEAL_1*/)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Renew (heal bonus part): 15% bonus healing (from spellpower) for Renew
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 50 && baseId == RENEW_1)
+                flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            //Test of Faith: 12% bonus healing on targets at or below 50% health
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 50 && GetHealthPCT(victim) <= 50)
+                pctbonus += 0.12f;
+            //Divine Providence: 10% bonus healing for Circle of Healing, Binding Heal, Holy Nova, Prayer of Healing, Divine Hymn and Prayer of Mending
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 55 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x18000200) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x4) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x4)))
+                pctbonus += 0.1f;
+
+            //flat mods
+            //Improved Prayer of Mending: 100 additional heal for Prayer of Mending
+            if (baseId == PRAYER_OF_MENDING_HEAL)
+                flat_mod += 100;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Inner Focus
+            if (AuraEffect const* focu = me->GetAuraEffect(INNER_FOCUS_1, 0))
+                if (focu->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.f;
+            //Surge of Light
+            if (AuraEffect const* surg = me->GetAuraEffect(SURGE_OF_LIGHT_BUFF, 1))
+                if (surg->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.f;
+
+            //Reduced Prayer of Healing Cost (38410):
+            if (lvl >= 60 && baseId == PRAYER_OF_HEALING_1)
+                pctbonus += 0.1f;
+            //Greater Heal Cost Reduction (60155):
+            if (lvl >= 60 && baseId == HEAL)
+                pctbonus += 0.05f;
+
+            //Shadow Focus part 2
+            if (lvl >= 15 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.06f;
+            //Absolution:
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 25 && (spellInfo->SpellFamilyFlags[1] & 0x81))
+                pctbonus += 0.15f;
+            //Mental Agility:
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 25 && !spellInfo->CastTimeEntry)
+                pctbonus += 0.1f;
+            //Improved Healing:
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) &&
+                lvl >= 25 && (baseId == HEAL || baseId == DIVINE_HYMN_1 || baseId == PENANCE_HEAL_1))
+                pctbonus += 0.15f;
+            //Soul Warding part 2
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 30 && baseId == PW_SHIELD_1)
+                pctbonus += 0.15f;
+            //Healing Prayers:
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) &&
+                lvl >= 30 && (baseId == PRAYER_OF_HEALING_1 || baseId == PRAYER_OF_MENDING_1))
+                pctbonus += 0.2f;
+            //Focused Mind
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) &&
+                lvl >= 30 && (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_1 ||
+                baseId == MIND_SEAR_1/* || baseId == MIND_CONTROL_1*/))
+                pctbonus += 0.15f;
+            //Improved Flash Heal part 1
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 40 && baseId == FLASH_HEAL_1)
+                pctbonus += 0.15f;
+
+            //Glyph of Fading
+            if (lvl >= 15 && baseId == FADE_1)
+                pctbonus += 0.3f;
+            //Glyph of Fortitude
+            if (lvl >= 15 && baseId == PW_FORTITUDE_1)
+                pctbonus += 0.5f;
+            //Glyph of Flash Heal
+            if (lvl >= 20 && baseId == FLASH_HEAL_1)
+                pctbonus += 0.1f;
+            //Glyph of Mass Dispel
+            if (lvl >= 70 && baseId == MASS_DISPEL_1)
+                pctbonus += 0.35f;
+
+            //flat mods
+            //Cleanse Cost Reduced (id: 27847): -25 mana cost for Cleanse
+            //if (lvl >= 40 && spellId == GetSpell(CLEANSE_1))
+            //    flatbonus += 25;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Surge of Light
+            if (AuraEffect const* surg = me->GetAuraEffect(SURGE_OF_LIGHT_BUFF, 1))
+                if (surg->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.f;
+
+            //pct mods
+            //Serendipity: -12% per stack cast time for Prayer of Healing or Greater Heal
+            if (baseId == GREATER_HEAL_1 || baseId == PRAYER_OF_HEALING_1)
+            {
+                if (AuraEffect const* sere = me->GetAuraEffect(SERENDIPITY_BUFF, 0))
+                    if (sere->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.12f * sere->GetBase()->GetStackAmount();
+            }
+
+            //flat mods
+            //Improved Prayer of Healing (21339)
+            if (lvl >= 60 && baseId == PRAYER_OF_HEALING_1)
+                timebonus += 100;
+            //Master Healer (15027) rank 5
+            if (lvl >= 60 && baseId == HEAL)
+                timebonus += 500;
+            //Prophesy Flash Heal Bonus (21973) part 1
+            if (lvl >= 60 && baseId == FLASH_HEAL_1)
+                timebonus += 100;
+
+            //Divine Fury
+            if (lvl >= 15 && (baseId == HEAL || baseId == SMITE_1 || baseId == HOLY_FIRE_1))
+                timebonus += 500;
+            //Focused Power part 3
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 35 && baseId == MASS_DISPEL_1)
+                timebonus += 1000;
+            //Improved Mana Burn
+            //if (lvl >= 35 && baseId == MANA_BURN_1)
+            //    timebonus += 1000;
+
+            //Glyph of Scourge Imprisonment
+            if (lvl >= 20 && baseId == SHACKLE_UNDEAD_1)
+                timebonus += 1000;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) &&
+                lvl >= 45 && (baseId == INNER_FOCUS_1 || baseId == POWER_INFUSION_1 || baseId == PAIN_SUPPRESSION_1))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Veiled Shadows part 2
+            //if (lvl >= 25 && baseId == SHADOWFIEND_1)
+            //    timebonus += 120000;
+            //Glyph of Dispersion:
+            if (lvl >= 60 && baseId == DISPERSION_1)
+                timebonus += 45000;
+            //Glyph of Penance:
+            if (lvl >= 60 && baseId == PENANCE_1)
+                timebonus += 2000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 45 && baseId == PENANCE_1)
+                pctbonus += 0.2f;
+            //Divine Providence:
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 55 && baseId == PRAYER_OF_MENDING_1)
+                pctbonus += 0.3f;
+
+            //flat mods
+            //Quick Fade (18388)
+            if (lvl >= 40 && baseId == FADE_1)
+                timebonus += 2000;
+
+            //Improved Psychic Scream
+            if (lvl >= 20 && baseId == PSYCHIC_SCREAM_1)
+                timebonus += 4000;
+            //Improved Mind Blast
+            if (lvl >= 20 && baseId == MIND_BLAST_1)
+                timebonus += 2500;
+            //Veiled Shadows part 1
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 25 && baseId == FADE_1)
+                timebonus += 6000;
+            //Soul Warding part 1
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 30 && baseId == PW_SHIELD_1)
+                timebonus += 4000;
+
+            //Glyph of Fade
+            if (lvl >= 15 && baseId == FADE_1)
+                timebonus += 9000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Prophesy Flash Heal Bonus (21973) part 2
+            if (lvl >= 60 && baseId == FLASH_HEAL_1)
+                timebonus += 100;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Holy Reach
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) &&
+                lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Mind Sear
+            if (lvl >= 75 && baseId == MIND_SEAR_DAMAGE_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Shadow Reach: +20% range for Shadow Spells
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 25 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x682A004) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x300502) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x2040)))
+                pctbonus += 0.2f;
+            //Holy Reach: +20% range for Holy Spells
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x100080))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Shackle Undead: +5 yd range for Shackle Undead
+            if (lvl >= 20 && baseId == SHACKLE_UNDEAD_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Circle of Healing: + 1 target
+            if (spellInfo->SpellFamilyFlags[0] & 0x10000000)
+                bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //Surge of Light
+            //Inner Focus
+            AuraEffect const* surg = me->GetAuraEffect(SURGE_OF_LIGHT_BUFF, 1);
+            AuraEffect const* focu = me->GetAuraEffect(INNER_FOCUS_1, 0);
+            if (surg && surg->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(SURGE_OF_LIGHT_BUFF);
+            else if (focu && focu->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(INNER_FOCUS_1);
+
+            //Serendipity
+            if (AuraEffect const* sere = me->GetAuraEffect(SERENDIPITY_BUFF, 0))
+                if (sere->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(SERENDIPITY_BUFF);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Hymn of Hope: +2 sec duration
+            if (lvl >= 60 && (baseId == HYMN_OF_HOPE_1 || baseId == HYMN_OF_HOPE_BUFF))
+            {
+                if (Aura* hymn = target->GetAura(spellId))
+                {
+                    hymn->SetDuration(hymn->GetDuration() + 2000);
+                    hymn->SetDuration(hymn->GetMaxDuration() + 2000);
+                }
+            }
+            //Priest T9 Shadow 2P Bonus (67193)
+            if (lvl >= 80 && baseId == VAMPIRIC_TOUCH_1)
+            {
+                if (Aura* touc = target->GetAura(spellId))
+                {
+                    uint32 dur = touc->GetMaxDuration() + 6000;
+                    touc->SetDuration(dur);
+                    touc->SetMaxDuration(dur);
+                }
+            }
+
+            //Improved Mind Blast part 2
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 20 && baseId == MIND_BLAST_1)
+                me->CastSpell(target, IMPROVED_MIND_BLAST_DEBUFF, true);
+
+            if (lvl >= 15 && baseId == PW_FORTITUDE_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    eff->ChangeAmount(int32(eff->GetAmount() * 1.3f));
+            }
+            if (lvl >= 20 && baseId == PW_SHIELD_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    float amount = float(eff->GetAmount());
+                    //Borrowed Time: +40% of spellpower
+                    if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 55)
+                        amount += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.4f;
+                    //Improved PWSH: +15% effect
+                    eff->ChangeAmount(int32(amount * 1.15f));
+                }
+            }
+            //Weakened Soul Reduction (id: 33333): -2 sec to Weakened Soul duration
+            if (lvl >= 51 && baseId == WEAKENED_SOUL_DEBUFF)
+            {
+                if (Aura* soul = target->GetAura(spellId))
+                {
+                    uint32 dur = soul->GetMaxDuration() - 2000;
+                    soul->SetDuration(dur);
+                    soul->SetMaxDuration(dur);
+                }
+            }
+            //Pain and Suffering (part 1): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 50 && baseId == MIND_FLAY_1 && GetSpell(SW_PAIN_1))
+                if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                    pain->RefreshDuration();
+            if (baseId == FEAR_WARD_1)
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+            //buffs duration
+            if (baseId == INNER_FIRE_1 || baseId == VAMPIRIC_EMBRACE_1 || baseId == PW_FORTITUDE_1 ||
+                baseId == SHADOW_PROTECTION_1 || baseId == DIVINE_SPIRIT_1)
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+
+            //convert to effect bonus somehow, this code gonna cause constant stack
+            //if (baseId == PRAYER_OF_MENDING_AURA_1)
+            //{
+            //    //Prayer of Mending Bounce (60154): +1 charge
+            //    if (Aura* mend = target->GetAura(spellId, me->GetGUID()))
+            //    {
+            //        mend->SetCharges(mend->GetCharges() + 1);
+            //    }
+            //}
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Inner Fire + Improved Inner Fire:
+            if (lvl >= 15 && baseId == INNER_FIRE_1)
+            {
+                if (Aura* fire = me->GetAura(spellId))
+                {
+                    fire->SetCharges(fire->GetCharges() + 12);
+                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        if (AuraEffect* eff = fire->GetEffect(i))
+                            eff->ChangeAmount(int32(eff->GetAmount() * (i == 0 ? 1.45f*1.5f : 1.45f)));
+                }
+            }
+            //Improved Vampiric Embrace
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 30 && baseId == VAMPIRIC_EMBRACE_1)
+            {
+                if (AuraEffect* vamp = me->GetAuraEffect(spellId, 0))
+                    vamp->ChangeAmount(vamp->GetAmount() + 10); //67% is essentially this
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(MIND_FLAY_1) : 20.f;
+        }
+
+        void SummonBotPet(Unit* target)
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_SHADOWFIEND;
+
+            //Position pos;
+
+            //15 sec duration
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_MANUAL_DESPAWN);
+            //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+            //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, SHADOWFIEND_1);
+
+            botPet = myPet;
+
+            myPet->Attack(target, true);
+            if (!HasBotCommandState(BOT_COMMAND_STAY))
+                myPet->GetMotionMaster()->MoveChase(target);
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_SHADOWFIEND;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            Shackle_Timer = 0;
+            Mend_Timer = 0;
+
+            DispelcheckTimer = 0;
+            DevcheckTimer = 0;
+            ShackcheckTimer = 0;
+
+            Devcheck = false;
+            Shackcheck = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+            if (Mend_Timer > diff)                  Mend_Timer -= diff;
+
+            if (DispelcheckTimer > diff)            DispelcheckTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+            if (ShackcheckTimer > diff)             ShackcheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isDisc = _spec == BOT_SPEC_PRIEST_DISCIPLINE;
+            bool isHoly = _spec == BOT_SPEC_PRIEST_HOLY;
+            bool isShad = _spec == BOT_SPEC_PRIEST_SHADOW;
+
+            InitSpellMap(DISPEL_MAGIC_1);
+            InitSpellMap(MASS_DISPEL_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(ABOLISH_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+            InitSpellMap(MIND_SEAR_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            InitSpellMap(GREATER_HEAL_1);
+            InitSpellMap(NORMAL_HEAL_1);
+            InitSpellMap(LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(PRAYER_OF_MENDING_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(HOLY_FIRE_1);
+            InitSpellMap(SMITE_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+            InitSpellMap(HYMN_OF_HOPE_1);
+            InitSpellMap(LEVITATE_1);
+            InitSpellMap(SHADOWFIEND_1); //not casted
+
+  /*Talent*/lvl >= 20 && isDisc ? InitSpellMap(INNER_FOCUS_1) : RemoveSpell(INNER_FOCUS_1);
+  /*Talent*/lvl >= 40 && isDisc ? InitSpellMap(POWER_INFUSION_1) : RemoveSpell(POWER_INFUSION_1);
+  /*Talent*/lvl >= 50 && isDisc ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+  /*Talent*/lvl >= 60 && isDisc ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+
+  /*Talent*/lvl >= 20 && isHoly ? InitSpellMap(DESPERATE_PRAYER_1) : RemoveSpell(DESPERATE_PRAYER_1);
+  /*Talent*/lvl >= 50 && isHoly ? InitSpellMap(CIRCLE_OF_HEALING_1) : RemoveSpell(CIRCLE_OF_HEALING_1);
+  /*Talent*/lvl >= 60 && isHoly ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+
+  /*Talent*/lvl >= 20 && isShad ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 30 && isShad ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 30 && isShad ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 40 && isShad ? InitSpellMap(SHADOWFORM_1) : RemoveSpell(SHADOWFORM_1);
+  /*Talent*/lvl >= 50 && isShad ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+  /*Talent*/lvl >= 50 && isShad ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 60 && isShad ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+
+            HEAL = GetSpell(GREATER_HEAL_1) ? GREATER_HEAL_1 :
+                GetSpell(NORMAL_HEAL_1) ? NORMAL_HEAL_1 :
+                GetSpell(LESSER_HEAL_1) ? LESSER_HEAL_1 : 0;
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isDisc = _spec == BOT_SPEC_PRIEST_DISCIPLINE;
+            bool isHoly = _spec == BOT_SPEC_PRIEST_HOLY;
+            bool isShad = _spec == BOT_SPEC_PRIEST_SHADOW;
+
+            RefreshAura(UNBREAKABLE_WILL, level >= 10 ? 1 : 0);
+            RefreshAura(MEDITATION, level >= 20 ? 1 : 0);
+            RefreshAura(RENEWED_HOPE, isDisc && level >= 45 ? 1 : 0);
+            RefreshAura(RAPTURE, isDisc && level >= 45 ? 1 : 0);
+            RefreshAura(DIVINE_AEGIS, isDisc && level >= 50 ? 1 : 0);
+            RefreshAura(GRACE, isDisc && level >= 50 ? 1 : 0);
+            RefreshAura(BORROWED_TIME, isDisc && level >= 55 ? 1 : 0);
+
+            RefreshAura(INSPIRATION3, isHoly && level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION2, isHoly && level >= 23 && level < 25 ? 1 : 0);
+            RefreshAura(INSPIRATION1, isHoly && level >= 20 && level < 23 ? 1 : 0);
+            RefreshAura(SURGE_OF_LIGHT, isHoly && level >= 35 ? 1 : 0);
+            RefreshAura(HOLY_CONCENTRATION, isHoly && level >= 40 ? 1 : 0);
+            RefreshAura(BODY_AND_SOUL1, isHoly && level >= 45 ? 1 : 0);
+            RefreshAura(SERENDIPITY, isHoly && level >= 45 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW3, isHoly && level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW2, isHoly && level >= 53 && level < 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW1, isHoly && level >= 50 && level < 53 ? 1 : 0);
+
+            RefreshAura(SPIRIT_TAP, isShad && level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_SPIRIT_TAP, isShad && level >= 10 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING3, isShad && level >= 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING2, isShad && level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING1, isShad && level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOURING_PLAGUE, isShad && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_SHADOWFORM, isShad && level >= 45 ? 1 : 0);
+            RefreshAura(MISERY3, isShad && level >= 50 ? 1 : 0);
+            RefreshAura(MISERY2, isShad && level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(MISERY1, isShad && level >= 45 && level < 48 ? 1 : 0);
+
+            //RefreshAura(GLYPH_SW_PAIN, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_PW_SHIELD, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_DISPEL_MAGIC, level >= 18 ? 1 : 0);
+            RefreshAura(GLYPH_PRAYER_OF_HEALING, level >= 30 ? 1 : 0);
+            RefreshAura(GLYPH_SHADOW, level >= 30 ? 1 : 0);
+            RefreshAura(PRIEST_T10_2P_BONUS, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case MASS_DISPEL_1:
+                case ABOLISH_DISEASE_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case RENEW_1:
+                case PRAYER_OF_HEALING_1:
+                case CIRCLE_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PRAYER_OF_MENDING_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                case FEAR_WARD_1:
+                case FLASH_HEAL_1:
+                case GREATER_HEAL_1:
+                case LEVITATE_1:
+                    return true;
+                case NORMAL_HEAL_1:
+                    return !GetSpell(GREATER_HEAL_1);
+                case LESSER_HEAL_1:
+                    return !GetSpell(NORMAL_HEAL_1) && !GetSpell(GREATER_HEAL_1);
+                case SHADOWFORM_1:
+                    return me->GetShapeshiftForm() != FORM_SHADOW;
+                default:
+                    return false;
+            }
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, HEAL))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HEAL));
+                _heals[HEAL] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), DamageEffectType(3), 0, {});
+            }
+            else
+                _heals[HEAL] = 0;
+
+            if (InitSpell(me, FLASH_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, FLASH_HEAL_1));
+                _heals[FLASH_HEAL_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), DamageEffectType(3), 0, {});
+            }
+            else
+                _heals[FLASH_HEAL_1] = 0;
+
+            if (InitSpell(me, PENANCE_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, PENANCE_HEAL_1));
+                _heals[PENANCE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), DamageEffectType(3), 0, {});
+            }
+            else
+                _heals[PENANCE_1] = 0;
+
+            if (InitSpell(me, DESPERATE_PRAYER_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, DESPERATE_PRAYER_1));
+                _heals[DESPERATE_PRAYER_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), DamageEffectType(3), 0, {});
+            }
+            else
+                _heals[DESPERATE_PRAYER_1] = 0;
+        }
+
+    private:
+        uint32 HEAL;
+        uint32 Shackle_Timer, Mend_Timer, DispelcheckTimer, DevcheckTimer, ShackcheckTimer;
+/*Misc*/bool Devcheck, Shackcheck;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..08ee95c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,1981 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+#include "SpellMgr.h"
+/*
+Rogue NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 90%
+TODO:
+*/
+
+enum RogueBaseSpells
+{
+    KICK_1                              = 1766,
+    EXPOSE_ARMOR_1                      = 8647, //NYI
+    FEINT_1                             = 1966,
+    DISMANTLE_1                         = 51722,
+
+    BACKSTAB_1                          = 53,
+    SINISTER_STRIKE_1                   = 1752,
+    EVISCERATE_1                        = 2098,
+    RUPTURE_1                           = 1943,
+    MUTILATE_1                          = 1329,
+    HEMORRHAGE_1                        = 16511,
+    GHOSTLY_STRIKE_1                    = 14278,
+    RIPOSTE_1                           = 14251,
+    DEADLY_THROW_1                      = 26679,
+    FAN_OF_KNIVES_1                     = 51723,
+
+    SPRINT_1                            = 2983,
+    EVASION_1                           = 5277,
+    BLIND_1                             = 2094,
+    VANISH_1                            = 1856,
+    COLD_BLOOD_1                        = 14177,
+    HUNGER_FOR_BLOOD_1                  = 51662,
+    ADRENALINE_RUSH_1                   = 13750,
+    KILLING_SPREE_1                     = 51690,
+    PREPARATION_1                       = 14185,
+    PREMEDITATION_1                     = 14183,
+
+    GOUGE_1                             = 1776,
+
+    KIDNEY_SHOT_1                       = 408,
+    SLICE_DICE_1                        = 5171,
+    BLADE_FLURRY_1                      = 13877,
+    SHADOWSTEP_1                        = 36554,
+    CLOAK_OF_SHADOWS_1                  = 31224,
+    TRICKS_OF_THE_TRADE_1               = 57934,
+    SHADOW_DANCE_1                      = 51713,
+
+    STEALTH_1                           = 1784,
+    SAP_1                               = 6770, //NYI
+    GARROTE_1                           = 703,
+    CHEAP_SHOT_1                        = 1833,
+    AMBUSH_1                            = 8676,
+
+    DISTRACT_1                          = 1725, //NYI
+
+    //Poisons
+    CRIPPLING_POISON_1                  = 3408,
+    INSTANT_POISON_1                    = 8679,
+    DEADLY_POISON_1                     = 2823, //manual use only
+    WOUND_POISON_1                      = 13219,
+    MIND_NUMBING_POISON_1               = 5761, //manual use only
+    ANESTHETIC_POISON_1                 = 26785,
+
+    PICK_LOCK_1                         = 1804
+};
+
+enum RoguePassives
+{
+    //Talents
+    SEAL_FATE1                          = 14189,
+    SEAL_FATE2                          = 14190,
+    SEAL_FATE3                          = 14193,
+    SEAL_FATE4                          = 14194,
+    SEAL_FATE5                          = 14195,
+    COMBAT_POTENCY1                     = 35541,
+    COMBAT_POTENCY2                     = 35550,
+    COMBAT_POTENCY3                     = 35551,
+    COMBAT_POTENCY4                     = 35552,
+    COMBAT_POTENCY5                     = 35553,
+    QUICK_RECOVERY1                     = 31244,
+    QUICK_RECOVERY2                     = 31245,
+    //BLADE_TWISTING1                     = 31124,
+    //BLADE_TWISTING2                     = 31126,
+    DEADLY_BREW                         = 51626,//rank 2
+    IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+    VIGOR                               = 14983,
+    REMORSELESS_ATTACKS                 = 14148,//rank 2
+    FLEET_FOOTED                        = 31209,//rank 2
+    MURDER                              = 14159,//rank 2
+    OVERKILL                            = 58426,
+    FOCUSED_ATTACKS                     = 51636,//rank 3
+    MASTER_POISONER                     = 58410,//rank 3
+    DUAL_WIELD_SPECIALIZATION           = 13852,//rank 5
+    IMPROVED_KICK                       = 13867,//rank 2
+    IMPROVED_SPRINT                     = 13875,//rank 2
+    HACK_AND_SLASH                      = 13964,//rank 5
+    VITALITY                            = 61329,//rank 3
+    NERVES_OF_STEEL                     = 31131,//rank 2
+    THROWING_SPECIALIZATION             = 51679,//rank 2
+    //SAVAGE_COMBAT                       = 58413,//rank 2
+    UNFAIR_ADVANTAGE                    = 51674,//rank 2
+    SURPRISE_ATTACKS                    = 32601,
+    PREY_ON_THE_WEAK                    = 51689,//rank 5
+    MASTER_OF_DECEPTION                 = 13971,//rank 3
+    SETUP                               = 14071,//rank 3
+    INITIATIVE                          = 13980,//rank 3
+    DIRTY_DEEDS                         = 14083,//rank 2
+    MASTER_OF_SUBTLETY                  = 31223,//rank 3
+    CHEAT_DEATH                         = 31230,//rank 3
+    ENVELOPING_SHADOWS                  = 31213,//rank 3
+    TURN_THE_TABLES                     = 51629,//rank 3
+    HONOR_AMONG_THIEVES                 = 51701,//rank 3
+
+    //Other
+    VIGOR_GLADIATOR                     = 21975,
+    GLYPH_BACKSTAB                      = 56800,
+
+    ROGUE_PASSIVE_DND                   = 21184 //from playercreateinfo_spell
+};
+
+enum RogueSpecial
+{
+    MUTILATE_DAMAGE_MAINHAND_1          = 5374,
+    MUTILATE_DAMAGE_OFFHAND_1           = 27576,
+
+    //TURN_THE_TABLES_BUFF                = 52910,//'rank 3'
+    HUNGER_FOR_BLOOD_BUFF               = 63848,
+    WAYLAY_DEBUFF                       = 51693,
+    REMORSELESS_ATTACKS_BUFF            = 14149,
+    CHEATING_DEATH_BUFF                 = 45182, //hidden
+    TRICKS_OF_THE_TRADE_BUFF            = 57933,
+
+    RELENTLESS_STRIKES_EFFECT           = 14181,
+    RUTHLESSNESS_EFFECT                 = 14157,
+    SEAL_FATE_EFFECT                    = 14189,
+    SETUP_EFFECT                        = 15250,
+    INITIATIVE_EFFECT                   = 13977,
+    HONOR_AMONG_THIEVES_EFFECT          = 51699,
+
+    VANISH_TRIGGERED_1                  = 11327,
+    VANISH_TRIGGERED_2                  = 11329,
+    VANISH_TRIGGERED_3                  = 26888,
+
+    //Poisons
+    CRIPPLING_POISON_PROC_1             = 3409,
+    //INSTANT_POISON_PROC_1               = 8680,
+    DEADLY_POISON_PROC_1                = 2818,
+    WOUND_POISON_PROC_1                 = 13218,
+    MIND_NUMBING_POISON_PROC_1          = 5760,
+    //ANESTHETIC_POISON_PROC_1            = 26688,
+
+    THISTLE_TEA                         = 9512 //'Restore Energy' 1 min cd
+};
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct rogue_botAI : public bot_ai
+    {
+        rogue_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_ROGUE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+            targetPoisoned = false;
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { comboPoints = 0; bot_ai::JustDied(u); }
+
+        void getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+        }
+
+        int32 ecost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            getenergy();
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            CheckSprint(diff);
+            CheckCloakOfShadows(diff);
+            CheckVanish(diff);
+
+            if (!CheckAttackTarget())
+            {
+                if (!me->IsInCombat() && Rand() < 5 && me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_ROGUE, 0x800, 0x0, 0x0)) //vanish
+                    me->RemoveAurasDueToSpell(STEALTH_1);
+                return;
+            }
+
+            CheckBlind(diff);
+            CheckPreparation(diff);
+            CheckTricksOfTheTrade(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            float dist = me->GetDistance(opponent);
+
+            //Stealth (for Cooldown handling see bot_ai::ReleaseSpellCooldown)
+            //we don't want rogue to swith into stealth for no purpose
+            if (IsSpellReady(STEALTH_1, diff, false) && !me->IsInCombat() && !IsTank() && Rand() < 50 && dist < 28 &&
+                (!me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) || (opponent->GetTypeId() == TYPEID_PLAYER && dist < 6)) &&
+                (me->GetLevel() >= 35 || (energy >= 40 && me->GetLevel() >= 30) || dist > 8))
+            {
+                if (doCast(me, GetSpell(STEALTH_1)))
+                {}
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //TC_LOG_ERROR("entities.player", "rogue_bot: cannot attack target...");
+                return;
+            }
+
+            bool stealthed = me->HasAuraType(SPELL_AURA_MOD_STEALTH);
+            bool shadowdance = me->HasAuraType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+
+            //Hunger for Blood
+            if (IsSpellReady(HUNGER_FOR_BLOOD_1, diff) && !shadowdance && HasRole(BOT_ROLE_DPS) && Rand() < 50 && dist < 30 &&
+                opponent->HasAuraState(AURA_STATE_BLEEDING) && energy >= ecost(HUNGER_FOR_BLOOD_1) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_ROGUE, 0x0, 0x1000000, 0x0))
+            {
+                if (doCast(opponent, GetSpell(HUNGER_FOR_BLOOD_1)))
+                    return;
+            }
+            //Premeditation
+            if (IsSpellReady(PREMEDITATION_1, diff, false) && (stealthed || shadowdance) &&
+                HasRole(BOT_ROLE_DPS) && comboPoints < 4 && dist < 15 &&
+                (comboPoints == 0 || opponent->GetHealth() > me->GetMaxHealth() / 4))
+            {
+                if (doCast(opponent, GetSpell(PREMEDITATION_1)))
+                {}
+            }
+            //Kick
+            if (IsSpellReady(KICK_1, diff, false) && !stealthed && dist <= 5 && Rand() < 70 &&
+                energy >= ecost(KICK_1) && opponent->IsNonMeleeSpellCast(false,false,true))
+            {
+                if (doCast(opponent, GetSpell(KICK_1)))
+                    getenergy();
+            }
+            //Killing Spree
+            if (IsSpellReady(KILLING_SPREE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                Rand() < (70 - energy) && dist < 10 && GetHealthPCT(me) > 25 && (!CCed(opponent) || dist > 5) &&
+                (opponent->getAttackers().size() < 4 || opponent->GetMaxHealth() > me->GetMaxHealth() * 2) &&
+                (opponent->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1))
+            {
+                if (doCast(opponent, GetSpell(KILLING_SPREE_1)))
+                    return;
+            }
+             //Gouge: if opponent is trying to attack/cast on us he will always try to face us
+            if (IsSpellReady(GOUGE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) && dist <= 5 &&
+                Rand() < 30 && !CCed(opponent) && energy >= ecost(GOUGE_1) &&
+                ((energy < 55 && opponent->getAttackers().size() <= 1 && !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                opponent->IsNonMeleeSpellCast(false,false,true)) && opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(GOUGE_1)))
+                    return;
+            }
+            //Blind: in pvp only for restealth
+            if (IsSpellReady(BLIND_1, diff) && !stealthed && !shadowdance && dist <= 15 && Rand() < 30 &&
+                !CCed(opponent) && energy >= ecost(BLIND_1) &&
+                ((energy <= 30 && opponent->GetTarget() == me->GetGUID() &&
+                opponent->getAttackers().size() <= 1 &&
+                !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (opponent->GetTypeId() == TYPEID_UNIT &&
+                !IsSpellReady(KICK_1, diff) && !IsSpellReady(GOUGE_1, diff) &&
+                opponent->IsNonMeleeSpellCast(false,false,true))))
+            {
+                if (doCast(opponent, GetSpell(BLIND_1)))
+                    return;
+            }
+            //Blade Flurry
+            if (IsSpellReady(BLADE_FLURRY_1, diff) && HasRole(BOT_ROLE_DPS) && !stealthed && !shadowdance &&
+                dist <= 5 && Rand() < 50 && energy >= ecost(BLADE_FLURRY_1) && !CCed(opponent) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetHealth() > me->GetHealth() || FindSplashTarget(7, opponent)))
+            {
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                    return;
+            }
+            //Slice and Dice
+            if (IsSpellReady(SLICE_DICE_1, diff) && !shadowdance && HasRole(BOT_ROLE_DPS) && comboPoints > 0 &&
+                Rand() < 110 && energy >= ecost(SLICE_DICE_1) && dist < 10 &&
+                (me->getAttackers().size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000, 0x0, 0x0))
+            {
+                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //Dismantle
+            if (IsSpellReady(DISMANTLE_1, diff) && !stealthed && !shadowdance &&
+                opponent->GetHealth() >= me->GetHealth() / 2 && energy >= ecost(DISMANTLE_1) && dist <= 5 &&
+                !CCed(opponent) && Rand() < (30 + 90*opponent->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER ?
+                opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) && opponent->ToPlayer()->IsUseEquipedWeapon(true) :
+                opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && opponent->CanUseAttackType(BASE_ATTACK)))
+            {
+                if (doCast(opponent, GetSpell(DISMANTLE_1)))
+                    return;
+            }
+            //Shadowstep
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && !IsTank() && HasRole(BOT_ROLE_DPS) &&
+                Rand() < 50 && dist < 25 && energy >= ecost(SHADOWSTEP_1) &&
+                (opponent->GetTypeId() != TYPEID_PLAYER || dist > 12 || CCed(me, true)) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetVictim() != me) &&
+                ((!stealthed && !shadowdance) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
+                    getenergy();
+            }
+            //Sprint (no GCD)
+            if (IsSpellReady(SPRINT_1, diff, false) && !HasBotCommandState(BOT_COMMAND_STAY) &&
+                ((me->GetLevel() >= 20 && CCed(me, true) && Rand() < 35) ||
+                (Rand() < (25 + 10*stealthed + 40*shadowdance) && dist > (20 - (5*stealthed + 10*shadowdance)))) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_ROGUE, 0x40, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(SPRINT_1)))
+                {}
+            }
+            //Evasion (no GCD)
+            if (IsSpellReady(EVASION_1, diff, false) && !stealthed && Rand() < 65 && !me->getAttackers().empty() &&
+                GetHealthPCT(me) < 65 + 10 * me->getAttackers().size() &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DODGE_PERCENT, SPELLFAMILY_ROGUE, 0x20, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(EVASION_1)))
+                    return; //custom: do not skip animation
+            }
+            //Deadly Throw
+            if (IsSpellReady(DEADLY_THROW_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                comboPoints > 0 && Rand() < 55 && dist < 30 && dist > 5 && energy >= ecost(DEADLY_THROW_1) &&
+                ((_spec != BOT_SPEC_ROGUE_COMBAT) || opponent->IsNonMeleeSpellCast(false,false,true)))
+            {
+                Item const* thrown = GetEquips(BOT_SLOT_RANGED);
+                if (thrown && thrown->GetTemplate()->Class == ITEM_CLASS_WEAPON &&
+                    thrown->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_THROWN &&
+                    doCast(opponent, GetSpell(DEADLY_THROW_1)))
+                    return;
+            }
+
+            //if target is affected by gouge or blind just try to regen some energy
+            bool hasnormalstun = false;
+            int32 duration = 0;
+            //sizes of theese are typically 1, sometimes maybe 2
+            Unit::AuraEffectList const& stunAuras = opponent->GetAuraEffectsByType(SPELL_AURA_MOD_STUN);
+            for (Unit::AuraEffectList::const_iterator itr = stunAuras.begin(); itr != stunAuras.end(); ++itr)
+            {
+                if (!((*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) &&
+                    (*itr)->GetBase()->GetDuration() > 2000)
+                {
+                    hasnormalstun = true;
+                    break;
+                }
+                if ((*itr)->GetBase()->GetDuration() > duration)
+                    duration = (*itr)->GetBase()->GetDuration();
+            }
+            if (!hasnormalstun)
+            {
+                Unit::AuraEffectList const& confuseAuras = opponent->GetAuraEffectsByType(SPELL_AURA_MOD_CONFUSE);
+                for (Unit::AuraEffectList::const_iterator itr = confuseAuras.begin(); itr != confuseAuras.end(); ++itr)
+                {
+                    if (!((*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) &&
+                        (*itr)->GetBase()->GetDuration() > 2000)
+                    {
+                        hasnormalstun = true;
+                        break;
+                    }
+                    if ((*itr)->GetBase()->GetDuration() > duration)
+                        duration = (*itr)->GetBase()->GetDuration();
+                }
+            }
+
+            //Vanish (no GCD)
+            if (IsSpellReady(VANISH_1, diff, false) && !stealthed && !shadowdance && !IsTank() && Rand() < 45 && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                bool cast = false;
+                //case 1: restealth for opener
+                if (!hasnormalstun && duration < 500 && me->IsInCombat() && dist <= 5)
+                    cast = true;
+                //case 2: evade casted spell
+                if (!cast)
+                {
+                    if (Spell const* spell = opponent->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                    {
+                        if (spell->m_targets.GetUnitTarget() == me && spell->GetTimer() < 500 &&
+                            spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                            cast = true;
+                    }
+                }
+                //case 3: reset threat / evade in CheckVanish (regardless of opponent availability)
+                if (cast && doCast(me, GetSpell(VANISH_1)))
+                    return; //custom: do not skip animation
+            }
+
+            if (dist > 5)
+            {
+                //if (opponent->IsPolymorphed())
+                //    TC_LOG_ERROR("entities.player", "rogue_bot: cannot attack target (dist)...");
+                return;
+            }
+
+            MoveBehind(opponent);
+
+            if (IsSpellReady(THISTLE_TEA, diff, false) && !hasnormalstun && duration < 1000 &&
+                energy <= std::max<int32>(me->GetMaxPower(POWER_ENERGY) - 110, 10))
+            {
+                if (doCast(me, THISTLE_TEA))
+                    getenergy();
+            }
+
+            //No IsSpellReady checks for spells with no cd below
+            if (GC_Timer > diff)
+                return;
+
+            //Feint
+            if (opponent->CanHaveThreatList())
+            {
+                if (IsSpellReady(FEINT_1, diff) && !stealthed && !IsTank() && opponent->GetVictim() == me && Rand() < 35 &&
+                    energy >= ecost(FEINT_1) && int32(opponent->GetThreatManager().GetThreatListSize()) > 1 &&
+                    int32(opponent->getAttackers().size()) > 1)
+                {
+                    if (doCast(opponent, GetSpell(FEINT_1)))
+                        return;
+                }
+            }
+
+            //Adrenaline Rush
+            if (GetSpell(ADRENALINE_RUSH_1) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) && (hasnormalstun || duration < 1300) && Rand() < 40 &&
+                energy < 50 && GetHealthPCT(me) > 35 &&
+                (opponent->getAttackers().size() < 3 || opponent->GetMaxHealth() > me->GetMaxHealth() * 2) &&
+                (opponent->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1))
+            {
+                if (doCast(me, GetSpell(ADRENALINE_RUSH_1)))
+                    return;
+            }
+
+            DiminishingLevels const stunDivider = opponent->GetDiminishing(DIMINISHING_OPENING_STUN);
+
+            //Rupture: little troll with applying rupture on target without breaking gouge (creatures only, pvp - restealth)
+            if (GetSpell(RUPTURE_1) && !stealthed && !shadowdance && comboPoints > 1 && HasRole(BOT_ROLE_DPS) &&
+                (hasnormalstun || (opponent->CanHaveThreatList() && duration < 2000)) &&
+                (comboPoints < 4 || !GetSpell(KIDNEY_SHOT_1) || stunDivider > DIMINISHING_LEVEL_2) &&
+                energy >= ecost(RUPTURE_1) && opponent->GetHealth() > me->GetMaxHealth() / 4 * (1 + opponent->getAttackers().size()) &&
+                Rand() < (40 + 40 * (opponent->GetTypeId() == TYPEID_PLAYER && IsMeleeClass(opponent->GetClass()))) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100000, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(RUPTURE_1)))
+                    return;
+            }
+
+            if (!hasnormalstun && duration > 300 && uint32(energy) < me->GetMaxPower(POWER_ENERGY))
+            {
+                //TC_LOG_ERROR("entities.player", "bot_rogue: delaying attacks on gouged or blinded target...");
+                return;
+            }
+
+            //Finishers
+            if (comboPoints > 0)
+            {
+                //Kidney Shot
+                if (GetSpell(KIDNEY_SHOT_1) && !stealthed && stunDivider < DIMINISHING_LEVEL_4 &&
+                    Rand() < 80 && !CCed(opponent) &&
+                    !(opponent->GetTypeId() == TYPEID_UNIT &&
+                    (opponent->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_STUN-1)))) &&
+                    ((comboPoints >= 4 && stunDivider < DIMINISHING_LEVEL_3 &&
+                    (opponent->GetHealth() > me->GetMaxHealth() / 2 || opponent->GetTypeId() == TYPEID_PLAYER)) ||
+                    opponent->IsNonMeleeSpellCast(false,false,true)) &&
+                    energy >= ecost(KIDNEY_SHOT_1))
+                {
+                    if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
+                        return;
+                }
+                //Eviscerate
+                if (IsSpellReady(EVISCERATE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                    (comboPoints >= 4 || opponent->GetHealth() < me->GetMaxHealth() / 4) &&
+                    energy >= ecost(EVISCERATE_1) && Rand() < (70 + comboPoints * 20))
+                {
+                    //Cold Blood (no GCD)
+                    if (IsSpellReady(COLD_BLOOD_1, diff, false) && comboPoints > 3 && Rand() > 50 + 100*(comboPoints == 5))
+                        if (doCast(me, GetSpell(COLD_BLOOD_1)))
+                        {}
+                    if (doCast(opponent, GetSpell(EVISCERATE_1)))
+                        return;
+                }
+            }
+
+            //Shadow Dance: if have energy or under effect of Adrenaline Rush
+            if (IsSpellReady(SHADOW_DANCE_1, diff, false) && !stealthed && HasRole(BOT_ROLE_DPS) && Rand() < 55 &&
+                GetHealthPCT(me) > 40 && (stunDivider == DIMINISHING_LEVEL_1 || CCed(opponent)) &&
+                (energy >= 60 || (energy >= 40 && me->GetAuraEffect(SPELL_AURA_MOD_POWER_REGEN_PERCENT, SPELLFAMILY_ROGUE, 0x0, 0x80, 0x0))) &&
+                (opponent->GetTypeId() == TYPEID_PLAYER || opponent->GetHealth() > (me->GetMaxHealth() / 4) * opponent->getAttackers().size()))
+            {
+                if (doCast(me, GetSpell(SHADOW_DANCE_1)))
+                {}
+            }
+
+            //Openers
+            if (stealthed || shadowdance)
+            {
+                uint32 opener =
+                    GetSpell(CHEAP_SHOT_1) &&
+                    !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && stunDivider < DIMINISHING_LEVEL_3 &&
+                    (opponent->GetTypeId() == TYPEID_PLAYER || (!IAmFree() && master->GetNpcBotsCount() > 1)) ? CHEAP_SHOT_1 :
+                    GetSpell(GARROTE_1) && HasRole(BOT_ROLE_DPS) && opponent->GetHealth() > me->GetMaxHealth() / 4 &&
+                    !opponent->IsImmunedToSpellEffect(sSpellMgr->GetSpellInfo(GARROTE_1), 0, me) &&
+                    (!isdaggerMH || (opponent->GetTypeId() == TYPEID_PLAYER &&
+                    (opponent->GetClass() == CLASS_MAGE || opponent->GetClass() == CLASS_PRIEST || opponent->GetClass() == CLASS_WARLOCK))) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100, 0x0, 0x0, me->GetGUID()) ? GARROTE_1 :
+                    GetSpell(AMBUSH_1) && HasRole(BOT_ROLE_DPS) && isdaggerMH ? AMBUSH_1 :
+                    GetSpell(BACKSTAB_1) && HasRole(BOT_ROLE_DPS) && isdaggerMH ? BACKSTAB_1 : 0;
+
+                //all opener spells disabled/unusable
+                if (!opener)
+                {
+                    if (stealthed && HasRole(BOT_ROLE_DPS))
+                        me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                    //if (shadowdance)
+                    //    me->RemoveAurasByType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+
+                    return;
+                }
+                //openers from behind (backstab too)
+                if (opener != CHEAP_SHOT_1 && opponent->HasInArc(M_PI, me))
+                    return;
+
+                //We do not check combo points amount
+                if (energy >= ecost(opener))
+                {
+                    if (doCast(opponent, GetSpell(opener)))
+                        return;
+                }
+
+                return;
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //Fan of Knives
+            if (GetSpell(FAN_OF_KNIVES_1) && energy >= ecost(FAN_OF_KNIVES_1) &&
+                Rand() < 35
+                + 40*(me->GetAuraEffect(SPELL_AURA_MOD_POWER_REGEN_PERCENT, SPELLFAMILY_ROGUE, 0x0, 0x80, 0x0) != nullptr)
+                + 50*(me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x0, 0x0) != nullptr)
+                /*Adrenaline Rush and Blade Flurry*/)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 7.f, 1);
+                if (targets.size() > 2 && doCast(me, GetSpell(FAN_OF_KNIVES_1)))
+                    return;
+            }
+
+            //Combo points generating
+            //Riposte: only after parry
+            if (IsSpellReady(RIPOSTE_1, diff) && comboPoints < 5 && me->HasReactive(REACTIVE_DEFENSE) &&
+                energy >= ecost(RIPOSTE_1))
+            {
+                if (doCast(opponent, GetSpell(RIPOSTE_1)))
+                    return;
+            }
+            //Ghostly Strike: tank mode only
+            if (IsSpellReady(GHOSTLY_STRIKE_1, diff) && comboPoints < 5 && IsTank() && !me->getAttackers().empty() &&
+                energy >= ecost(GHOSTLY_STRIKE_1))
+            {
+                if (doCast(opponent, GetSpell(GHOSTLY_STRIKE_1)))
+                    return;
+            }
+            //Hemorrhage: does not stack from different casters
+            if (GetSpell(HEMORRHAGE_1) && !isdaggerMH && comboPoints < 5 && !IsTank() && energy >= ecost(HEMORRHAGE_1) &&
+                !opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELLFAMILY_ROGUE, 0x800000, 0x0, 0x0))
+            {
+                if (doCast(opponent, GetSpell(HEMORRHAGE_1)))
+                    return;
+            }
+            //Sinister Strike: tank mode
+            if (GetSpell(SINISTER_STRIKE_1) && comboPoints < 5 &&
+                (!isdaggerMH || IsTank() || (opponent->GetVictim() == me && energy >= 60 && opponent->HasInArc(M_PI, me)) || !GetSpell(BACKSTAB_1)) &&
+                energy >= ecost(SINISTER_STRIKE_1))
+            {
+                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //Backstab/Mutilate
+            uint32 mutistab =
+                isdaggerMH && isdaggerOH && targetPoisoned && GetSpell(MUTILATE_1) ? MUTILATE_1 :
+                isdaggerMH && GetSpell(BACKSTAB_1) ? BACKSTAB_1 : 0;
+            if (mutistab && comboPoints < 4 && energy >= ecost(mutistab) && (mutistab == MUTILATE_1 || !opponent->HasInArc(M_PI, me)))
+            {
+                if (doCast(opponent, GetSpell(mutistab)))
+                    return;
+            }
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (me->IsInCombat() && Rand() < 25)
+            {
+                bool canVanish = IsSpellReady(VANISH_1, diff, false);
+                bool canSprint = (_spec == BOT_SPEC_ROGUE_COMBAT) && me->GetLevel() >= 25 && !HasBotCommandState(BOT_COMMAND_STAY) && IsSpellReady(SPRINT_1, diff, false);
+                if ((canVanish || canSprint) && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+                {
+                    uint32 Spanish = canSprint ? SPRINT_1 : VANISH_1;
+                    if (doCast(me, GetSpell(Spanish)))
+                        return;
+                }
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Rand() > 25)
+                return;
+
+            if (mhEnchantExpireTimer > 0 && mhEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* mh = GetEquips(BOT_SLOT_MAINHAND))
+                    if (mh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            mh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+            if (ohEnchantExpireTimer > 0 && ohEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* oh = GetEquips(BOT_SLOT_OFFHAND))
+                    if (oh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            oh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+
+            // Weapon Enchants
+            if (me->isMoving())
+                return;
+            uint8 lvl = me->GetLevel();
+            if (lvl < 20)
+                return;
+
+            Item* mhWeapon = GetEquips(BOT_SLOT_MAINHAND);
+            Item* ohWeapon = GetEquips(BOT_SLOT_OFFHAND);
+            //item must be non-standard, otherwise combat spells won't be rolled anyway
+            bool mhReady = mhWeapon && !mhWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+            bool ohReady = ohWeapon && !ohWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+            if (!mhReady && !ohReady)
+                return; //no ecnhantable weapons
+
+            //OK choose the poisons
+            //MH 20+ Instant, 32+ Wound
+            //OH 20+ Crippling, 40+ Instant (deadly brew inc), 68+ Anesthetic
+            if (needChooseMHEnchant && mhReady)
+                mhEnchant = me->GetLevel() >= 32 ? WOUND_POISON_1 :
+                    me->GetLevel() >= 20 ? INSTANT_POISON_1 : 0;
+
+            if (needChooseOHEnchant && ohReady)
+                ohEnchant = me->GetLevel() >= 68 ? ANESTHETIC_POISON_1 :
+                    me->GetLevel() >= 40 ? INSTANT_POISON_1 :
+                    me->GetLevel() >= 20 ? CRIPPLING_POISON_1 : 0;
+
+            uint32 MhPoison = !mhReady ? 0 : GetSpell(mhEnchant);
+            uint32 OhPoison = !ohReady ? 0 : GetSpell(ohEnchant);
+
+            SpellInfo const* MhPoisonInfo = mhReady && MhPoison ? sSpellMgr->GetSpellInfo(MhPoison) : nullptr;
+            SpellInfo const* OhPoisonInfo = ohReady && OhPoison ? sSpellMgr->GetSpellInfo(OhPoison) : nullptr;
+
+            Item* targetWeapon = nullptr;
+            SpellInfo const* targetInfo = nullptr;
+
+            if (mhReady && MhPoison && mhWeapon->IsFitToSpellRequirements(MhPoisonInfo))
+            {
+                targetWeapon = mhWeapon;
+                targetInfo = MhPoisonInfo;
+            }
+            if (!targetWeapon && ohReady && OhPoison && ohWeapon->IsFitToSpellRequirements(OhPoisonInfo))
+            {
+                targetWeapon = ohWeapon;
+                targetInfo = OhPoisonInfo;
+            }
+            if (targetWeapon)
+            {
+                Spell* spell = new Spell(me, targetInfo, TRIGGERED_NONE);
+                SpellCastTargets targets;
+                targets.SetItemTarget(targetWeapon);
+                spell->prepare(targets);
+                return;
+            }
+        }
+
+        void CheckVanish(uint32 diff)
+        {
+            if (!IsSpellReady(VANISH_1, diff, false) || !me->IsInCombat() || me->IsMounted() || IsTank() || Rand() > 50 ||
+                me->getAttackers().empty() || me->HasAuraType(SPELL_AURA_MOD_STEALTH) ||
+                me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY) || me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return;
+
+            if (GetHealthPCT(me) < 30 + 20*me->getAttackers().size() ||
+                (!IAmFree() && GetHealthPCT(me) < 70 && master->GetNpcBotsCount() > 1))
+            {
+                //Unit* victim = me->GetVictim();
+                if (doCast(me, GetSpell(VANISH_1)))
+                    return;
+            }
+        }
+
+        void CheckCloakOfShadows(uint32 diff)
+        {
+            if (!IsSpellReady(CLOAK_OF_SHADOWS_1, diff) || !me->IsInCombat() || me->IsMounted() ||
+                Rand() > 40 + 60 * me->GetMap()->IsDungeon())
+                return;
+
+            uint32 count = 0;
+
+            //dispel debuffs
+            uint32 const dispelMask = DISPEL_ALL_MASK;
+            Unit::AuraApplicationMap const& Auras = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator iter = Auras.begin(); iter != Auras.end(); ++iter)
+            {
+                // remove all harmful spells on you...
+                SpellInfo const* spellInfo = iter->second->GetBase()->GetSpellInfo();
+                if ((spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC || (spellInfo->GetDispelMask() & dispelMask)) &&
+                    !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive())
+                {
+                    if (spellInfo->HasAura(SPELL_AURA_PERIODIC_DAMAGE) ||
+                        spellInfo->HasAura(SPELL_AURA_MOD_SPEED_SLOW_ALL) ||
+                        spellInfo->HasAura(SPELL_AURA_HASTE_SPELLS))
+                        if (++count > 1)
+                            break;
+                }
+            }
+
+            //defend from enemy cast cast
+            if (Unit const* target = FindCastingTarget(50))
+            {
+                if (Spell const* spell = target->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->GetTimer() < 1000 && !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive() &&
+                        !(spell->GetSpellInfo()->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)))
+                    {
+                        //direct spell
+                        if (spell->m_targets.GetUnitTarget() == me &&
+                            spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                            me->IsWithinLOSInMap(target))
+                        {
+                            count += 2;
+                        }
+                        //area spell
+                        if ((spell->GetSpellInfo()->Effects[0].IsEffect() &&
+                            spell->GetSpellInfo()->Effects[0].TargetB.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY) ||
+                            (spell->GetSpellInfo()->Effects[1].IsEffect() &&
+                            spell->GetSpellInfo()->Effects[1].TargetB.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY))
+                        {
+                            count += 2;
+                        }
+                    }
+                }
+            }
+
+            if (!(count > 1))
+                return;
+
+            if (doCast(me, GetSpell(CLOAK_OF_SHADOWS_1)))
+                return;
+        }
+
+        void CheckBlind(uint32 diff)
+        {
+            if (!IsSpellReady(BLIND_1, diff) || !me->IsInCombat() || me->IsMounted() || IsTank() || Rand() > 40 ||
+                me->HasAuraType(SPELL_AURA_MOD_STEALTH) || me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY) ||
+                IsSpellReady(BLADE_FLURRY_1, diff, false) || IsSpellReady(EVASION_1, diff, false) ||
+                me->GetAuraEffect(SPELL_AURA_MOD_DODGE_PERCENT, SPELLFAMILY_ROGUE, 0x20, 0x0, 0x0) ||//evasion
+                me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0))
+                return;
+
+            Unit* u = FindStunTarget(15); //improved always (base 10, improved 15)
+            if (!u)
+                u = FindCastingTarget(15, 0, BLIND_1);
+
+            if (u && doCast(u, GetSpell(BLIND_1)))
+                return;
+        }
+
+        void CheckPreparation(uint32 diff)
+        {
+            if (!IsSpellReady(PREPARATION_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 30)
+                return;
+
+            //TODO: recheck priorities
+            uint32 needFactor = 0;
+            uint32 cooldown;
+            cooldown = GetSpellCooldown(EVASION_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            cooldown = GetSpellCooldown(SPRINT_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            cooldown = GetSpellCooldown(VANISH_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            cooldown = GetSpellCooldown(COLD_BLOOD_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 1800; //1-100 x2
+            cooldown = GetSpellCooldown(SHADOWSTEP_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 200;  //1-100 x2
+            cooldown = GetSpellCooldown(BLADE_FLURRY_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            cooldown = GetSpellCooldown(DISMANTLE_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 600;  //1-100
+            //0-1300
+            //ignore Kick
+
+            if (needFactor >= 800 && doCast(me, GetSpell(PREPARATION_1)))
+                return;
+        }
+
+        void CheckTricksOfTheTrade(uint32 diff)
+        {
+            if (!IsSpellReady(TRICKS_OF_THE_TRADE_1, diff) || !me->IsInCombat() || me->IsMounted() || IAmFree() ||
+                IsTank() || Rand() > 30 || !me->GetMap()->IsDungeon() ||
+                me->HasAuraType(SPELL_AURA_MOD_STEALTH) || me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return;
+
+            Group const* group = master->GetGroup();
+            if (!group)
+                return;
+            Unit* victim = me->GetVictim();
+            if (!victim)
+                return;
+
+            Unit* target = nullptr;
+            for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || !player->IsAlive() || me->GetMap() != player->FindMap() ||
+                    me->GetDistance(player) > 20)
+                    continue;
+
+                if (IsTank(player) || player->GetVictim() == victim)
+                {
+                    if (!victim->CanHaveThreatList() ||
+                        victim->GetThreatManager().GetThreat(player) < victim->GetThreatManager().GetThreat(me) * 0.75f)
+                    {
+                        target = player;
+                        break;
+                    }
+                }
+            }
+
+            if (target)
+                if (doCast(target, GetSpell(TRICKS_OF_THE_TRADE_1)))
+                    return;
+        }
+
+        void CheckSprint(uint32 diff)
+        {
+            if (!IsSpellReady(SPRINT_1, diff, false) || !HasBotCommandState(BOT_COMMAND_FOLLOW) ||
+                me->GetVictim() || me->IsMounted() || IAmFree() || Rand() > 15)
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 40))
+            {
+                if (doCast(me, GetSpell(SPRINT_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+                return;
+
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Cold Blood
+            if (AuraEffect const* bloo = me->GetAuraEffect(COLD_BLOOD_1, 0, me->GetGUID()))
+                if (bloo->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+
+            //Puncturing Wounds:
+            if (lvl >= 15)
+            {
+                //30% additional critical chance for Backstab
+                if (baseId == BACKSTAB_1)
+                    crit_chance += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (baseId == MUTILATE_1 ||
+                    baseId == MUTILATE_DAMAGE_MAINHAND_1 || baseId == MUTILATE_DAMAGE_OFFHAND_1)
+                    crit_chance += 15.f;
+            }
+            //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+            if (lvl >= 15 && baseId == EVISCERATE_1)
+                crit_chance += 10.f;
+            //Improved Ambush: 50% additional critical chance for Ambush
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 25 && baseId == AMBUSH_1)
+                crit_chance += 50.f;
+            //Turn the Tables:
+            if (lvl >= 50 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x2600070E) || (spellInfo->SpellFamilyFlags[1] & 0x7900106)) &&
+                me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_ROGUE, 0x0, 0x200000, 0x0))
+                crit_chance += 6.f;
+            //Remorseless Attacks:
+            if (AuraEffect const* remo = me->GetAuraEffect(REMORSELESS_ATTACKS_BUFF, 0, me->GetGUID()))
+                if (remo->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 40.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 &&
+                    (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == MUTILATE_1 || baseId == RIPOSTE_1 ||
+                    baseId == GOUGE_1 || baseId == HEMORRHAGE_1 || baseId == GHOSTLY_STRIKE_1
+                    /*|| baseId == SHIV_1*/ || baseId == MUTILATE_DAMAGE_MAINHAND_1 || baseId == MUTILATE_DAMAGE_OFFHAND_1))
+                    pctbonus += 0.15f;
+            }
+
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && baseId == EVISCERATE_1)
+                pctbonus += 0.15f;
+            //Find Weakness: 6% bonus damage to all abilities
+            if ((_spec == BOT_SPEC_ROGUE_ASSASINATION) && lvl >= 45)
+                pctbonus += 0.06f;
+            //Improved Eviscerate: 20% damage bonus for Eviscerate
+            if (lvl >= 10 && baseId == EVISCERATE_1)
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (lvl >= 10 &&
+                (baseId == BACKSTAB_1 || baseId == MUTILATE_1 || baseId == MUTILATE_DAMAGE_MAINHAND_1 ||
+                baseId == MUTILATE_DAMAGE_OFFHAND_1 || baseId == GARROTE_1 || baseId == AMBUSH_1))
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) &&
+                lvl >= 25 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (baseId == RUPTURE_1 || baseId == GARROTE_1))
+                pctbonus += 0.3f;
+            //Vile Poisons: 20% damage bonus for Poisons and Envenom
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x10012000) || (spellInfo->SpellFamilyFlags[1] & 0x18)))
+                pctbonus += 0.2f;
+            //Serrated Blades part 2: 30% bonus damage for Rupture
+            if (lvl >= 20 && baseId == RUPTURE_1)
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) &&
+                lvl >= 50 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 ||
+                /*baseId == SHIV_1 || */baseId == HEMORRHAGE_1 || baseId == GOUGE_1))
+                pctbonus += 0.1f;
+            //Blade Twisting: 10% bonus damage for Sinister Strike and Backstab
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) && lvl >= 35 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1))
+                pctbonus += 0.1f;
+            //Sinister Calling: 10% bonus percentage damage for Backstab and Hemorrhage
+            //We add bonus damage pct because SpellMods are not handled
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 45 && (baseId == BACKSTAB_1 || baseId == HEMORRHAGE_1))
+                pctbonus += 0.1f;
+            //Glyph of Fan of Knives: 20% bonus damage for Fan of Knives
+            if (lvl >= 80 && baseId == FAN_OF_KNIVES_1)
+                pctbonus += 0.2f;
+
+            //Glyph of Sinister Strike: 50% chance to add 1 cp on crit
+            if (baseId == SINISTER_STRIKE_1)
+                const_cast<rogue_botAI*>(this)->glyphSSProc = crit && lvl >= 15 && urand(1,100) <= 50;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Blade Flurry: -100% cost for Blade Flurry
+            if (lvl >= 30 && baseId == BLADE_FLURRY_1)
+                pctbonus += 1.0f;
+
+            //percent mods
+            //Dirty Tricks: -50% cost for Blind and Sap
+            if (lvl >= 15 && (baseId == BLIND_1 || baseId == SAP_1))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Improved Expose Armor: -10 energy cost for Expose Armor
+            if (lvl >= 20 && baseId == EXPOSE_ARMOR_1)
+                flatbonus += 10;
+            //Improved Sinister Strike: -5 energy cost for Sinister Strike
+            if (lvl >= 10 && baseId == SINISTER_STRIKE_1)
+                flatbonus += 5;
+            //Dirty Deeds part 1: -20 energy cost for Cheap Shot and Garrote
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 30 && (baseId == CHEAP_SHOT_1 || baseId == GARROTE_1))
+                flatbonus += 20;
+            //Filthy Tricks part 2: -10 energy cost for Tricks of the Trade, Distract and Shadowstep
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) &&
+                lvl >= 50 && (baseId == TRICKS_OF_THE_TRADE_1 || baseId == DISTRACT_1 || baseId == SHADOWSTEP_1))
+                flatbonus += 10;
+            //Slaugher from the Shadows part 1: -20 energy cost for Backstab and Ambush
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 55 && (baseId == BACKSTAB_1 || baseId == AMBUSH_1))
+                flatbonus += 20;
+            //Slaugher from the Shadows part 2: -5 energy cost for Hemorrhage
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 55 && baseId == HEMORRHAGE_1)
+                flatbonus += 5;
+            //Glyph of Feint: -20 energy cost for Feint
+            if (lvl >= 16 && baseId == FEINT_1)
+                flatbonus += 20;
+            //Glyph of Gouge: -15 energy cost for Gouge
+            if (lvl >= 15 && baseId == GOUGE_1)
+                flatbonus += 15;
+            //Glyph of Mutilate: -5 energy cost for Mutilate
+            if (lvl >= 50 && baseId == MUTILATE_1)
+                flatbonus += 5;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Improved Slam: -100% cast time for Slam
+            //if (lvl >= 40 && spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+            //    timebonus += casttime;
+
+            //flat mods
+            //Glyph of Pick Lock: 100% cast time for Pick Lock (reduced for bots)
+            if (lvl >= 16 && baseId == PICK_LOCK_1)
+                timebonus += 4000;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            //if (lvl >= 40 &&
+            //    (spellId == GetSpell(BLOODRAGE_1) || spellId == GetSpell(BERSERKERRAGE_1) ||
+            //    spellId == GetSpell(RECKLESSNESS_1) || spellId == GetSpell(DEATHWISH_1)))
+            //    pctbonus += 0.33f;
+
+            //flat mods
+            //Elusiveness part 2: -60 sec cooldown for Blind
+            if (lvl >= 20 && baseId == BLIND_1)
+                timebonus += 60000;
+            //Elusiveness part 3: -30 sec cooldown for Cloak of Shadows
+            if (lvl >= 20 && baseId == CLOAK_OF_SHADOWS_1)
+                timebonus += 30000;
+            //Filthy Tricks part 1: -10 sec cooldown for Tricks of the Trade, Distract and Shadowstep
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) &&
+                lvl >= 50 && (baseId == TRICKS_OF_THE_TRADE_1 || baseId == DISTRACT_1 || baseId == SHADOWSTEP_1))
+                timebonus += 10000;
+            //Filthy Tricks part 3: -3 min cooldown for Preparation
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 50 && baseId == PREPARATION_1)
+                timebonus += 180000;
+            //Glyph of Killing Spree: -45 sec cooldown for Killing Spree
+            if (lvl >= 60 && baseId == KILLING_SPREE_1)
+                timebonus += 45000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Endurance: -1 min cooldown for Sprint and Evasion
+            if (lvl >= 20 && (baseId == SPRINT_1 || baseId == EVASION_1))
+                timebonus += 60000;
+            //Elusiveness part 1: -60 sec cooldown for Vanish
+            if (lvl >= 20 && baseId == VANISH_1)
+                timebonus += 60000;
+            //Camouflage part 2: -6 sec cooldown for Stealth
+            if (lvl >= 15 && baseId == STEALTH_1)
+                timebonus += 6000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* /*spellInfo*/, float& radius) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Glyph of Thunder Clap
+            //if (spellInfo->SpellFamilyFlags[0] & 0x80)
+            //    flatbonus += 4.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Throwing Specialization: + 4 yd range for Deadly Throw
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) && lvl >= 45 && baseId == DEADLY_THROW_1)
+                flatbonus += 4.f;
+            //Dirty Tricks: + 5 yd range for Blind and Sap
+            if (lvl >= 15 && (baseId == BLIND_1 || baseId == SAP_1))
+                flatbonus += 5.f;
+            //Glyph of Ambush: + 5 yd range for Ambush
+            if (/*lvl >= 18 && */baseId == AMBUSH_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* /*spellInfo*/, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Improved Revenge: +1 target (actually 2 in dbc)
+            //if (spellInfo->SpellFamilyFlags[0] & 0x400)
+            //    bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Thistle Tea: cooldown
+            if (baseId == THISTLE_TEA)
+                SetSpellCooldown(THISTLE_TEA, 300000); //5 min (item cd)
+
+            //Remorseless Attacks: proc consume buff
+            if (AuraEffect const* remo = me->GetAuraEffect(REMORSELESS_ATTACKS_BUFF, 0, me->GetGUID()))
+                if (remo->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(REMORSELESS_ATTACKS_BUFF);
+
+            //Relentless Strikes
+            if (spellInfo->NeedsComboPoints() && comboPoints)
+            {
+                if (lvl >= 10)
+                {
+                    if (irand(1,100) <= 20 * comboPoints)
+                    {
+                        me->CastSpell(me, RELENTLESS_STRIKES_EFFECT, true);
+                        //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: RS proc!");
+                    }
+                }
+            }
+
+            //Item enchant
+            //We don't know which item is targeted
+            //Actually it is mh, then oh
+            if (baseId == CRIPPLING_POISON_1 || baseId == INSTANT_POISON_1 || baseId == DEADLY_POISON_1 ||
+                baseId == WOUND_POISON_1 || baseId == ANESTHETIC_POISON_1 || baseId == MIND_NUMBING_POISON_1)
+            {
+                //We set duration to 2 seconds to prevent exploiting unequip mechanic
+                //to get enchanted weapons for player (for non-shaman bots it won't work)
+                uint32 slot = TEMP_ENCHANTMENT_SLOT;
+                uint32 duration = 2 * IN_MILLISECONDS;
+                uint32 charges = 0;
+                uint32 enchant_id = spellInfo->Effects[0].MiscValue;
+                //SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                Item* mh = GetEquips(BOT_SLOT_MAINHAND);
+                Item* oh = GetEquips(BOT_SLOT_OFFHAND);
+                Item* item = nullptr;
+                uint8 itemSlot = 0;
+
+                if (mh && !mh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = mh;
+                    itemSlot = BOT_SLOT_MAINHAND;
+                }
+                else if (oh && !oh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && oh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = oh;
+                    itemSlot = BOT_SLOT_OFFHAND;
+                }
+                else
+                    ASSERT(false && "rogue bot attempted to enchant his weapons but cannot find a weapon to apply it!");
+
+                if (!IAmFree())
+                    master->GetSession()->SendEnchantmentLog(me->GetGUID(), me->GetGUID(), item->GetEntry(), enchant_id);
+
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, charges);
+                ApplyItemBonuses(itemSlot); //RemoveItemBonuses inside
+                if (itemSlot == BOT_SLOT_MAINHAND)
+                    mhEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                else if (itemSlot == BOT_SLOT_OFFHAND)
+                    ohEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                //GC_Timer = 1500; //needed
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Vanish: handle stealth add
+            if (baseId == VANISH_TRIGGERED_1 || baseId == VANISH_TRIGGERED_2 || baseId == VANISH_TRIGGERED_3)
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_SHAPESHIFT, SPELLFAMILY_ROGUE, 0x400000, 0x0, 0x0))
+                {
+                    //SetSpellCooldown(STEALTH_1, 0);
+                    me->CastSpell(me, STEALTH_1, true);
+                }
+            }
+            //Cheat Death: assume resilience bonus
+            if (baseId == CHEATING_DEATH_BUFF)
+            {
+                if (AuraEffect* chea = me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_GENERIC, 2109, 0))
+                {
+                    chea->ChangeAmount(-100);
+                }
+            }
+            //Camouflage part 1: +15% speed while stealthed
+            if (baseId == STEALTH_1 && me->GetLevel() >= 15)
+            {
+                if (AuraEffect* stea = me->GetAuraEffect(spell->Id, 2))
+                {
+                    stea->ChangeAmount(stea->GetAmount() + 15);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Cold Blood: handle proc
+            if (AuraEffect const* bloo = me->GetAuraEffect(COLD_BLOOD_1, 0, me->GetGUID()))
+                if (bloo->IsAffectedOnSpell(spell))
+                    me->RemoveAurasDueToSpell(COLD_BLOOD_1);
+
+            //Combo point generating from effects
+            if (baseId == SEAL_FATE_EFFECT || baseId == RUTHLESSNESS_EFFECT ||
+                baseId == SETUP_EFFECT || baseId == INITIATIVE_EFFECT || baseId == HONOR_AMONG_THIEVES_EFFECT)
+            {
+                ++comboPoints;
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN2: %s adds 1, now %u", spell->SpellName[0], uint32(comboPoints));
+                if (comboPoints > 5)
+                {
+                    comboPoints = 5;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP NOR2: now %u", uint32(comboPoints));
+                }
+            }
+            //Combo point generating from spells
+            if (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == MUTILATE_1 ||
+                baseId == GOUGE_1 || baseId == HEMORRHAGE_1 || baseId == GHOSTLY_STRIKE_1 ||
+                baseId == RIPOSTE_1 || baseId == PREMEDITATION_1 ||
+                baseId == AMBUSH_1 || baseId == GARROTE_1 || baseId == CHEAP_SHOT_1/* || baseId == SHIV_1*/)
+            {
+                (baseId == MUTILATE_1 || baseId == PREMEDITATION_1 || baseId == CHEAP_SHOT_1) ?
+                    comboPoints += 2 : ++comboPoints;
+
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN1: %s adds %u, now %u",
+                //    spell->SpellName[0], (baseId == MUTILATE_1 || baseId == PREMEDITATION_1 || baseId == CHEAP_SHOT_1) ?
+                //    2 : 1, uint32(comboPoints));
+
+                //Glyph of Sinister Strike: handle proc
+                if (baseId == SINISTER_STRIKE_1 && glyphSSProc)
+                {
+                    ++comboPoints;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN1: glyphSS proc, now %u", uint32(comboPoints));
+                }
+
+                if (comboPoints > 5)
+                {
+                    comboPoints = 5;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP NOR1: now %u", uint32(comboPoints));
+                }
+            }
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE || spellId == EXPOSE_ARMOR || spellId == ENVENOM)
+            //some abilities like relentless strikes require combo points thus tries to proc itself
+            else if (spell->NeedsComboPoints() && comboPoints)
+            {
+                //uint32 tempCP = comboPoints;
+                comboPoints = 0;
+
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: %u to 0", tempCP);
+
+                //Relentless Strikes: moved to OnClassSpellGo (triggered even without hitting the target)
+
+                //Ruthlessness
+                if (lvl >= 15)
+                {
+                    if (urand(1,100) <= 60)
+                    {
+                        me->CastSpell(target, RUTHLESSNESS_EFFECT, true);
+                        //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: RU proc!");
+                    }
+                }
+            }
+
+            //Preparation: handle effect
+            if (baseId == PREPARATION_1)
+            {
+                //TC_LOG_ERROR("entities.player", "rogue_bot Preparation hit!");
+                if (GetSpell(EVASION_1))
+                    SetSpellCooldown(EVASION_1, 0);
+                if (GetSpell(SPRINT_1))
+                    SetSpellCooldown(SPRINT_1, 0);
+                if (GetSpell(VANISH_1))
+                    SetSpellCooldown(VANISH_1, 0);
+                if (GetSpell(COLD_BLOOD_1))
+                    SetSpellCooldown(COLD_BLOOD_1, 0);
+                if (GetSpell(SHADOWSTEP_1))
+                    SetSpellCooldown(SHADOWSTEP_1, 0);
+
+                //Glyph of Preparation
+                //if (lvl >= 30) // same level as spell itself
+                {
+                    if (GetSpell(BLADE_FLURRY_1))
+                        SetSpellCooldown(BLADE_FLURRY_1, 0);
+                    if (GetSpell(DISMANTLE_1))
+                        SetSpellCooldown(DISMANTLE_1, 0);
+                    if (GetSpell(KICK_1))
+                        SetSpellCooldown(KICK_1, 0);
+                }
+            }
+
+            //Glyph of Garrote
+            if (lvl >= 15 && baseId == GARROTE_1)
+            {
+                if (Aura* garr = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = garr->GetMaxDuration() - 3000;
+                    garr->SetDuration(dur);
+                    garr->SetMaxDuration(dur);
+                    if (AuraEffect* garrEff = garr->GetEffect(0))
+                    {
+                        garrEff->ChangeAmount(int32(garrEff->GetAmount() * 1.44f)); //not a mistake
+                    }
+                }
+            }
+            //Glyph of Deadly Throw
+            if (lvl >= 64 && baseId == DEADLY_THROW_1)
+            {
+                if (AuraEffect* thro = target->GetAuraEffect(spellId, 1, me->GetGUID()))
+                {
+                    thro->ChangeAmount(thro->GetAmount() - 20);
+                }
+            }
+            //Glyph of Hunger for Blood
+            if (lvl >= 60 && baseId == HUNGER_FOR_BLOOD_BUFF)
+            {
+                if (AuraEffect* hung = me->GetAuraEffect(spellId, 0))
+                {
+                    hung->ChangeAmount(hung->GetAmount() + 3);
+                }
+            }
+            //Glyph of Cloak of Shadows
+            if (lvl >= 66 && baseId == CLOAK_OF_SHADOWS_1)
+            {
+                if (AuraEffect* cloa = me->GetAuraEffect(spellId, 2))
+                {
+                    cloa->ChangeAmount(cloa->GetAmount() - 40);
+                }
+            }
+            //Glyph of Sprint
+            if (lvl >= 15 && baseId == SPRINT_1)
+            {
+                if (AuraEffect* spri = me->GetAuraEffect(spellId, 0))
+                {
+                    spri->ChangeAmount(spri->GetAmount() + 30);
+                }
+            }
+            //Glyph of Vanish
+            if (lvl >= 22 && baseId == VANISH_1)
+            {
+                if (AuraEffect* vani = me->GetAuraEffect(spellId, 2))
+                {
+                    vani->ChangeAmount(vani->GetAmount() + 30);
+                }
+            }
+            //Glyph of Adrenaline Rush
+            if (lvl >= 40 && baseId == ADRENALINE_RUSH_1)
+            {
+                if (Aura* rush = me->GetAura(spellId))
+                {
+                    uint32 dur = rush->GetMaxDuration() + 5000;
+                    rush->SetDuration(dur);
+                    rush->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Evasion
+            if (lvl >= 15 && baseId == EVASION_1)
+            {
+                if (Aura* evas = me->GetAura(spellId))
+                {
+                    uint32 dur = evas->GetMaxDuration() + 5000;
+                    evas->SetDuration(dur);
+                    evas->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Slice and Dice
+            //Improved Slice and Dice
+            if (lvl >= 15 && baseId == SLICE_DICE_1)
+            {
+                if (Aura* dice = me->GetAura(spellId))
+                {
+                    uint32 dur = dice->GetMaxDuration() + 3000;
+                    dur = dur + dur / 2;
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Shadow Dance: 4 sec for bots
+            if (lvl >= 60 && baseId == SHADOW_DANCE_1)
+            {
+                if (Aura* danc = me->GetAura(spellId))
+                {
+                    uint32 dur = danc->GetMaxDuration() + 4000;
+                    danc->SetDuration(dur);
+                    danc->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Rupture
+            if (lvl >= 20 && baseId == RUPTURE_1)
+            {
+                if (Aura* rupt = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rupt->GetMaxDuration() + 4000;
+                    rupt->SetDuration(dur);
+                    rupt->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Expose Armor
+            if (lvl >= 15 && baseId == EXPOSE_ARMOR_1)
+            {
+                if (Aura* expo = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = expo->GetMaxDuration() + 12000;
+                    expo->SetDuration(dur);
+                    expo->SetMaxDuration(dur);
+                }
+            }
+            //Improved Gouge: Increased duration by 1.5 sec
+            if (lvl >= 10 && baseId == GOUGE_1)
+            {
+                if (Aura* goug = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 duration = goug->GetMaxDuration() + 1500;
+                    goug->SetDuration(duration);
+                    goug->SetMaxDuration(duration);
+                }
+            }
+            //Glyph of Tricks of Trade
+            if (lvl >= 75 && baseId == TRICKS_OF_THE_TRADE_BUFF)
+            {
+                if (Aura* tric = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 duration = tric->GetMaxDuration() + 4000;
+                    tric->SetDuration(duration);
+                    tric->SetMaxDuration(duration);
+                }
+            }
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration as for 5 points
+            if ((_spec == BOT_SPEC_ROGUE_ASSASINATION) && lvl >= 55 && (baseId == EVISCERATE_1/* || baseId == ENVENOM_1*/) && GetSpell(SLICE_DICE_1))
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 duration = 21000 + 3000 + 12000; //base + glyph + improved
+                    dice->SetDuration(duration);
+                    dice->SetMaxDuration(duration);
+                }
+            }
+            //Waylay
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 45 && (baseId == BACKSTAB_1 || baseId == AMBUSH_1))
+                me->CastSpell(target, WAYLAY_DEBUFF, true);
+
+            //Stun: move behind
+            if (baseId == CHEAP_SHOT_1 || baseId == KIDNEY_SHOT_1 || baseId == GOUGE_1)
+                if (target == opponent)
+                    MoveBehind(target);
+
+            //Poison marker
+            if (baseId == CRIPPLING_POISON_1 || baseId == DEADLY_POISON_PROC_1 ||
+                baseId == WOUND_POISON_PROC_1 || baseId == MIND_NUMBING_POISON_PROC_1)
+                targetPoisoned = true;
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void CheckAttackState() override
+        {
+            if (me->GetVictim() && HasRole(BOT_ROLE_DPS) && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                (me->isAttackReady() || me->isAttackReady(OFF_ATTACK)) &&
+                (!me->GetVictim()->GetAuraEffect(SPELL_AURA_MOD_STUN, SPELLFAMILY_ROGUE, 0x8, 0x0, 0x0) &&
+                !me->GetVictim()->GetAuraEffect(SPELL_AURA_MOD_CONFUSE, SPELLFAMILY_ROGUE, 0x01000000, 0x0, 0x0)))
+                DoMeleeAttackIfReady();
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_COMBO_POINTS:
+                    return comboPoints;
+                case BOTAI_MISC_ENCHANT_IS_AUTO_MH:
+                    return needChooseMHEnchant;
+                case BOTAI_MISC_ENCHANT_IS_AUTO_OH:
+                    return needChooseOHEnchant;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    return mhEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    return ohEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    return mhEnchant;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    return ohEnchant;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_1:
+                    return GetSpell(CRIPPLING_POISON_1) ? CRIPPLING_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_2:
+                    return GetSpell(INSTANT_POISON_1) ? INSTANT_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_3:
+                    return GetSpell(MIND_NUMBING_POISON_1) ? MIND_NUMBING_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_4:
+                    return GetSpell(DEADLY_POISON_1) ? DEADLY_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_5:
+                    return GetSpell(WOUND_POISON_1) ? WOUND_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_6:
+                    return GetSpell(ANESTHETIC_POISON_1) ? ANESTHETIC_POISON_1 : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_DAGGER_MAINHAND:
+                    isdaggerMH = bool(value);
+                    break;
+                case BOTAI_MISC_DAGGER_OFFHAND:
+                    isdaggerOH = bool(value);
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    if (value)
+                        mhEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    if (value)
+                        ohEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    mhEnchant = value;
+                    needChooseMHEnchant = value ? false : true;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    ohEnchant = value;
+                    needChooseOHEnchant = value ? false : true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            energy = 0;
+            comboPoints = 0;
+            glyphSSProc = false;
+            targetPoisoned = false;
+
+            mhEnchantExpireTimer = 1;
+            ohEnchantExpireTimer = 1;
+
+            DefaultInit();
+
+            mhEnchant = 0;
+            ohEnchant = 0;
+            needChooseMHEnchant = true;
+            needChooseOHEnchant = true;
+
+            //after InitEquips
+            Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+            Item const* oh = GetEquips(BOT_SLOT_OFFHAND);
+            isdaggerMH = mh && mh->GetTemplate()->Class == ITEM_CLASS_WEAPON && mh->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER;
+            isdaggerOH = oh && oh->GetTemplate()->Class == ITEM_CLASS_WEAPON && oh->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER;
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (mhEnchantExpireTimer > diff)            mhEnchantExpireTimer -= diff;
+            if (ohEnchantExpireTimer > diff)            ohEnchantExpireTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            //Hack for power
+            me->SetPowerType(POWER_ENERGY);
+
+            if (energy)
+                me->SetPower(POWER_ENERGY, energy);
+            else
+                me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isAssa = _spec == BOT_SPEC_ROGUE_ASSASINATION;
+            bool isComb = _spec == BOT_SPEC_ROGUE_COMBAT;
+            bool isSubt = _spec == BOT_SPEC_ROGUE_SUBTLETY;
+
+            InitSpellMap(KICK_1);
+            //InitSpellMap(EXPOSE_ARMOR_1);
+            InitSpellMap(DISMANTLE_1);
+            InitSpellMap(FEINT_1);
+
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(RUPTURE_1);
+            InitSpellMap(DEADLY_THROW_1);
+            InitSpellMap(FAN_OF_KNIVES_1);
+
+            InitSpellMap(SPRINT_1);
+            InitSpellMap(EVASION_1);
+            InitSpellMap(BLIND_1);
+            InitSpellMap(VANISH_1);
+
+            InitSpellMap(GOUGE_1);
+
+            InitSpellMap(KIDNEY_SHOT_1);
+            InitSpellMap(SLICE_DICE_1);
+            InitSpellMap(CLOAK_OF_SHADOWS_1);
+            InitSpellMap(TRICKS_OF_THE_TRADE_1);
+
+            InitSpellMap(STEALTH_1);
+            //InitSpellMap(SAP_1);
+            InitSpellMap(GARROTE_1);
+            InitSpellMap(CHEAP_SHOT_1);
+            InitSpellMap(AMBUSH_1);
+
+            lvl >= 30 && isAssa ? InitSpellMap(COLD_BLOOD_1) : RemoveSpell(COLD_BLOOD_1);
+            lvl >= 50 && isAssa ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 60 && isAssa ? InitSpellMap(HUNGER_FOR_BLOOD_1) : RemoveSpell(HUNGER_FOR_BLOOD_1);
+
+            lvl >= 20 && isComb ? InitSpellMap(RIPOSTE_1) : RemoveSpell(RIPOSTE_1);
+            lvl >= 30 && isComb ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+            lvl >= 40 && isComb ? InitSpellMap(ADRENALINE_RUSH_1) : RemoveSpell(ADRENALINE_RUSH_1);
+            lvl >= 60 && isComb ? InitSpellMap(KILLING_SPREE_1) : RemoveSpell(KILLING_SPREE_1);
+
+            lvl >= 20 && isSubt ? InitSpellMap(GHOSTLY_STRIKE_1) : RemoveSpell(GHOSTLY_STRIKE_1);
+            lvl >= 30 && isSubt ? InitSpellMap(HEMORRHAGE_1) : RemoveSpell(HEMORRHAGE_1);
+            lvl >= 30 && isSubt ? InitSpellMap(PREPARATION_1) : RemoveSpell(PREPARATION_1);
+            lvl >= 40 && isSubt ? InitSpellMap(PREMEDITATION_1) : RemoveSpell(PREMEDITATION_1);
+            lvl >= 50 && isSubt ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            lvl >= 60 && isSubt ? InitSpellMap(SHADOW_DANCE_1) : RemoveSpell(SHADOW_DANCE_1);
+
+            //InitSpellMap(DISTRACT_1);
+
+            InitSpellMap(CRIPPLING_POISON_1);
+            InitSpellMap(INSTANT_POISON_1);
+            InitSpellMap(DEADLY_POISON_1);
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+            InitSpellMap(ANESTHETIC_POISON_1);
+
+            lvl >= 10 ? InitSpellMap(THISTLE_TEA) : RemoveSpell(THISTLE_TEA);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isAssa = _spec == BOT_SPEC_ROGUE_ASSASINATION;
+            bool isComb = _spec == BOT_SPEC_ROGUE_COMBAT;
+            bool isSubt = _spec == BOT_SPEC_ROGUE_SUBTLETY;
+
+            RefreshAura(REMORSELESS_ATTACKS, level >= 10 ? 1 : 0);
+            RefreshAura(VIGOR, level >= 20 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY2, isAssa && level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY1, isAssa && level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(IMPROVED_KIDNEY_SHOT, isAssa && level >= 30 ? 1 : 0);
+            RefreshAura(FLEET_FOOTED, isAssa && level >= 30 ? 1 : 0);
+            RefreshAura(SEAL_FATE5, isAssa && level >= 45 ? 1 : 0);
+            RefreshAura(SEAL_FATE4, isAssa && level >= 42 && level < 45 ? 1 : 0);
+            RefreshAura(SEAL_FATE3, isAssa && level >= 39 && level < 42 ? 1 : 0);
+            RefreshAura(SEAL_FATE2, isAssa && level >= 37 && level < 39 ? 1 : 0);
+            RefreshAura(SEAL_FATE1, isAssa && level >= 35 && level < 37 ? 1 : 0);
+            RefreshAura(MURDER, isAssa && level >= 35 ? 1 : 0);
+            RefreshAura(DEADLY_BREW, isAssa && level >= 40 ? 1 : 0);
+            RefreshAura(OVERKILL, isAssa && level >= 40 ? 1 : 0);
+            //RefreshAura(FOCUSED_ATTACKS, isAssa && level >= 45 ? 1 : 0);
+            RefreshAura(MASTER_POISONER, isAssa && level >= 50 ? 1 : 0);
+
+            RefreshAura(DUAL_WIELD_SPECIALIZATION, level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_KICK, isComb && level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_SPRINT, isComb && level >= 25 ? 1 : 0);
+            RefreshAura(HACK_AND_SLASH, isComb && level >= 30 ? 1 : 0);
+            //RefreshAura(BLADE_TWISTING1, isComb && level >= 35 ? 1 : 0);
+            RefreshAura(VITALITY, isComb && level >= 40 ? 1 : 0);
+            RefreshAura(NERVES_OF_STEEL, isComb && level >= 40 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY5, isComb && level >= 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY4, isComb && level >= 52 && level < 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY3, isComb && level >= 49 && level < 52 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY2, isComb && level >= 47 && level < 49 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY1, isComb && level >= 45 && level < 47 ? 1 : 0);
+            RefreshAura(THROWING_SPECIALIZATION, isComb && level >= 45 ? 1 : 0);
+            //RefreshAura(SAVAGE_COMBAT, isComb && level >= 50 ? 1 : 0);
+            RefreshAura(UNFAIR_ADVANTAGE, isComb && level >= 50 ? 1 : 0);
+            RefreshAura(SURPRISE_ATTACKS, isComb && level >= 50 ? 1 : 0);
+            RefreshAura(PREY_ON_THE_WEAK, isComb && level >= 55 ? 1 : 0);
+
+            RefreshAura(MASTER_OF_DECEPTION, level >= 10 ? 1 : 0);
+            RefreshAura(SETUP, isSubt && level >= 25 ? 1 : 0);
+            RefreshAura(INITIATIVE, isSubt && level >= 25 ? 1 : 0);
+            RefreshAura(DIRTY_DEEDS, isSubt && level >= 30 ? 1 : 0);
+            RefreshAura(MASTER_OF_SUBTLETY, isSubt && level >= 35 ? 1 : 0);
+            RefreshAura(CHEAT_DEATH, isSubt && level >= 40 ? 1 : 0);
+            RefreshAura(ENVELOPING_SHADOWS, isSubt && level >= 40 ? 1 : 0);
+            RefreshAura(TURN_THE_TABLES, isSubt && level >= 55 ? 1 : 0);
+            //RefreshAura(HONOR_AMONG_THIEVES, isSubt && level >= 55 ? 1 : 0);
+
+            RefreshAura(VIGOR_GLADIATOR, level >= 70 ? 1 : 0);
+
+            RefreshAura(GLYPH_BACKSTAB, level >= 15 ? 1 : 0);
+
+            RefreshAura(ROGUE_PASSIVE_DND);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case STEALTH_1:
+                case SPRINT_1:
+                case VANISH_1:
+                case BLADE_FLURRY_1:
+                case FAN_OF_KNIVES_1:
+                case TRICKS_OF_THE_TRADE_1:
+                case PREPARATION_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const override
+        {
+            float bonus = 0.0f;
+
+            //Serrated Blades part 1
+            if (me->GetLevel() >= 20)
+                bonus += 9.f;
+
+            //Mace Specialization: 15% armor penetration
+            if (me->GetLevel() >= 30)
+                if (Item const* weap = GetEquips(BOT_SLOT_MAINHAND))
+                    if (weap->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_MACE)
+                        bonus += 15.f;
+
+            return bonus + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList) override
+        {
+            std::ostringstream msg1;
+            msg1 << "Main hand: ";
+            switch (mhEnchant)
+            {
+                case CRIPPLING_POISON_1:    msg1 << "Crippling";     break;
+                case INSTANT_POISON_1:      msg1 << "Instant";       break;
+                case DEADLY_POISON_1:       msg1 << "Deadly";        break;
+                case WOUND_POISON_1:        msg1 << "Wound";         break;
+                case MIND_NUMBING_POISON_1: msg1 << "Mind-Numbing";  break;
+                case ANESTHETIC_POISON_1:   msg1 << "Anesthetic";    break;
+                default:                    msg1 << "Nothing";       break;
+            }
+            specList.push_back(msg1.str());
+
+            std::ostringstream msg2;
+            msg2 << "Offhand: ";
+            switch (ohEnchant)
+            {
+                case CRIPPLING_POISON_1:    msg2 << "Crippling";     break;
+                case INSTANT_POISON_1:      msg2 << "Instant";       break;
+                case DEADLY_POISON_1:       msg2 << "Deadly";        break;
+                case WOUND_POISON_1:        msg2 << "Wound";         break;
+                case MIND_NUMBING_POISON_1: msg2 << "Mind-Numbing";  break;
+                case ANESTHETIC_POISON_1:   msg2 << "Anesthetic";    break;
+                default:                    msg2 << "Nothing";       break;
+            }
+            specList.push_back(msg2.str());
+        }
+
+    private:
+        bool glyphSSProc;
+        bool targetPoisoned;
+        int32 energy;
+        uint8 comboPoints;
+        bool isdaggerMH, isdaggerOH;
+        uint32 mhEnchantExpireTimer, ohEnchantExpireTimer;
+        uint32 mhEnchant, ohEnchant;
+        bool needChooseMHEnchant, needChooseOHEnchant;
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..fb2301c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,2771 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+#include "SpellMgr.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - around 90%
+TODO: Elemental mastery (exclusive cd with NatSw), Lava Lash
+Problems:
+Unsummon elemental totems if Elementals are killed
+Aura application bug for bot in other subgroup, maybe caused by creatorGUID mismatch
+*/
+
+#define MAX_WOLVES 2
+
+enum ShamanBaseSpells
+{
+    HEALING_WAVE_1                      = 331,
+    CHAIN_HEAL_1                        = 1064,
+    LESSER_HEALING_WAVE_1               = 8004,
+    RIPTIDE_1                           = 61295,
+    ANCESTRAL_SPIRIT_1                  = 2008,
+    CURE_TOXINS_1                       = 526,
+    CLEANSE_SPIRIT_1                    = 51886,
+    FLAME_SHOCK_1                       = 8050,
+    EARTH_SHOCK_1                       = 8042,
+    FROST_SHOCK_1                       = 8056,
+    STORMSTRIKE_1                       = 17364,
+    LIGHTNING_BOLT_1                    = 403,
+    CHAIN_LIGHTNING_1                   = 421,
+    LAVA_BURST_1                        = 51505,
+    THUNDERSTORM_1                      = 51490,
+    LIGHTNING_SHIELD_1                  = 324,
+    EARTH_SHIELD_1                      = 974,
+    WATER_SHIELD_1                      = 52127,
+    WATER_BREATHING_1                   = 131,
+    WATER_WALKING_1                     = 546,
+    PURGE_1                             = 370,
+    WIND_SHEAR_1                        = 57994,
+    HEX_1                               = 51514,
+    BLOODLUST_1                         = 2825,
+    HEROISM_1                           = 32182,
+    SHAMANISTIC_RAGE_1                  = 30823,
+    NATURES_SWIFTNESS_1                 = 16188,//castegory = 1202
+    //ELEMENTAL_MASTERY_1                 = 16166,//castegory = 1202 NYI
+    TIDAL_FORCE_1                       = 55198,
+
+    GHOST_WOLF_1                        = 2645,
+
+    FIRE_NOVA_1                         = 1535,//shaman spell
+    EARTHBIND_TOTEM_1                   = 2484,
+    MAGMA_TOTEM_1                       = 8190,
+    SEARING_TOTEM_1                     = 3599,
+    STONECLAW_TOTEM_1                   = 5730,
+    FIRE_ELEMENTAL_TOTEM_1              = 2894,
+    EARTH_ELEMENTAL_TOTEM_1             = 2062,
+    FIRE_RESISTANCE_TOTEM_1             = 8184,
+    FROST_RESISTANCE_TOTEM_1            = 8181,
+    NATURE_RESISTANCE_TOTEM_1           = 10595,
+    FLAMETONGUE_TOTEM_1                 = 8227,
+    GROUNDING_TOTEM_1                   = 8177,
+    SENTRY_TOTEM_1                      = 6495,
+    STONESKIN_TOTEM_1                   = 8071,
+    STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+    WINDFURY_TOTEM_1                    = 8512,
+    WRATH_OF_AIR_TOTEM_1                = 3738,
+    CLEANSING_TOTEM_1                   = 8170,
+    HEALING_STREAM_TOTEM_1              = 5394,
+    MANA_SPRING_TOTEM_1                 = 5675,
+    TOTEM_OF_WRATH_1                    = 30706,
+    MANA_TIDE_TOTEM_1                   = 16190,
+    TREMOR_TOTEM_1                      = 8143,
+
+    TOTEMIC_RECALL_1                    = 36936,
+
+    REINCARNATION_1                     = 21169,
+
+    FERAL_SPIRIT_1                      = 51533, //not casted
+
+    //ROCKBITER_WEAPON_1                  = 8017, //disabled due to bonus handling method
+    FLAMETONGUE_WEAPON_1                = 8024,
+    FROSTBRAND_WEAPON_1                 = 8033,
+    WINDFURY_WEAPON_1                   = 8232,
+    EARTHLIVING_WEAPON_1                = 51730
+};
+
+enum ShamanPassives
+{
+    //Elemental
+    ELEMENTAL_FOCUS                     = 16164,//clearcast
+    ELEMENTAL_DEVASTATION1              = 30160,
+    ELEMENTAL_DEVASTATION2              = 29179,
+    ELEMENTAL_DEVASTATION3              = 29180,
+    ELEMENTAL_OATH                      = 51470,//rank 2
+    //STORM_EARTH_AND_FIRE                = 51486,//rank 3
+    //Enchancement
+    TOUGHNESS                           = 16309,//rank 5
+    FLURRY1                             = 16256,
+    FLURRY2                             = 16281,
+    FLURRY3                             = 16282,
+    FLURRY4                             = 16283,
+    FLURRY5                             = 16284,
+    WEAPON_MASTERY                      = 29086,//rank 3
+    UNLEASHED_RAGE                      = 30809,//rank 3
+    STATIC_SHOCK                        = 51527,//rank 3
+    IMPROVED_STORMSTRIKE                = 51522,//rank 2
+    MAELSTROM_WEAPON1                   = 51528,
+    MAELSTROM_WEAPON2                   = 51529,
+    MAELSTROM_WEAPON3                   = 51530,
+    MAELSTROM_WEAPON4                   = 51531,
+    MAELSTROM_WEAPON5                   = 51532,
+    EARTHEN_POWER                       = 51524,//rank 2
+    //Restoration
+    ANCESTRAL_HEALING                   = 16240,//rank 3
+    ANCESTRAL_AWAKENING                 = 51558,//rank 3
+    IMPROVED_WATER_SHIELD               = 16198,//rank 3
+    TIDAL_WAVES                         = 51566,//rank 5
+    //Special
+    GLYPH_THUNDERSTORM                  = 62132,
+    GLYPH_TOTEM_OF_WRATH                = 63280,
+    SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+};
+
+enum ShamanSpecial
+{
+    SHAMAN_FLAME_SHOCK_PASSIVE          = 75461,//flame shock damage can be critical in 3.3.5, innate
+
+    ELEMENTAL_FOCUS_BUFF                = 16246,
+    TIDAL_FORCE_BUFF                    = 55166,//Unit::HandleAuraDummy(): case 55198:
+
+    MAELSTROM_WEAPON_BUFF               = 53817,
+    TIDAL_WAVES_BUFF                    = 53390,
+    STORMSTRIKE_DAMAGE                  = 32175,
+    STORMSTRIKE_DAMAGE_OFFHAND          = 32176,
+
+    LIGHTNING_SHIELD_DAMAGE_1           = 26364,
+    EARTH_SHIELD_HEAL                   = 379,
+
+    RESURRECTION_VISUAL_SPELL           = 21074, //Test NPC Resurrection
+
+    EXHAUSTION_AURA                     = 57723,
+    SATED_AURA                          = 57724,
+
+    WINDFURY_ATTACK_MAINHAND            = 25504,
+    WINDFURY_ATTACK_OFFHAND             = 33750,
+
+    STORMEARTHANDFIRE_EARTHGRAB         = 64695,
+
+    //TOTEM_AURA_WRATH_AURA1              = 57658,//100
+    //TOTEM_AURA_WRATH_AURA2              = 57660,//120
+    //TOTEM_AURA_WRATH_AURA3              = 57662,//140
+    //TOTEM_AURA_WRATH_AURA4              = 57663,//280
+    //TOTEM_AURA_RESISTANCE_FIRE_1        = 8185,
+    //TOTEM_AURA_RESISTANCE_FROST_1       = 8182,
+    //TOTEM_AURA_RESISTANCE_NATURE_1      = 10596,
+    //TOTEM_AURA_FLAMETONGUE_1            = 52109,
+    //TOTEM_AURA_GROUNDING                = 8178,
+    //TOTEM_AURA_STONESKIN_1              = 8072,
+    //TOTEM_AURA_STRENGTH_OF_EARTH_1      = 8076,
+    //TOTEM_AURA_WINDFURY                 = 8515,
+    //TOTEM_AURA_WRATH_OF_AIR             = 2895,
+    //TOTEM_AURA_MANA_SPRING_1            = 5677
+};
+
+enum TotemSlot
+{
+    T_FIRE  = 0,//m_SummonSlot[1]
+    T_EARTH = 1,//m_SummonSlot[2]
+    T_WATER = 2,//m_SummonSlot[3]
+    T_AIR   = 3,//m_SummonSlot[4]
+};
+enum BotTotemType : uint32
+{
+    BOT_TOTEM_NONE                  = 0,
+    BOT_TOTEM_STRENGTH_OF_EARTH     = 1, //main earth totem
+    BOT_TOTEM_FLAMETONGUE           = 2, //main fire totem
+    BOT_TOTEM_WRATH                 = 3, //main fire totem
+    BOT_TOTEM_MANA_SPRING           = 4, //main water totem
+    BOT_TOTEM_WINDFURY              = 5, //main air totem
+    BOT_TOTEM_WRATH_OF_AIR          = 6, //main air totem
+    BOT_TOTEM_STONESKIN             = 7, //secondary earth totem UNUSED
+    BOT_TOTEM_HEALING_STREAM        = 8, //secondary water totem UNUSED
+    BOT_TOTEM_TREMOR                = 9, //situative earth 1
+    BOT_TOTEM_EARTHBIND             = 10, //situative earth 2
+    BOT_TOTEM_MAGMA                 = 11, //situative fire 1
+    BOT_TOTEM_MANA_TIDE             = 12, //situative water 1
+    BOT_TOTEM_CLEANSING             = 13, //situative water 2 non-raid
+    BOT_TOTEM_GROUNDING             = 14, //situative air 1
+    BOT_TOTEM_RESISTANCE_FROST      = 15, //manual fire 1
+    BOT_TOTEM_RESISTANCE_FIRE       = 16, //manual water 1
+    BOT_TOTEM_RESISTANCE_NATURE     = 17, //manual air 1
+    BOT_TOTEM_ELEMENTAL_EARTH       = 18, //manual earth 1
+    BOT_TOTEM_ELEMENTAL_FIRE        = 19, //manual fire 2
+    BOT_TOTEM_SENTRY                = 20, //UNUSED
+    BOT_TOTEM_STONECLAW             = 21, //UNUSED
+    BOT_TOTEM_SEARING               = 22, //UNUSED, annoying as hell too
+    BOT_TOTEM_END,
+
+    BOT_TOTEM_FLAG_MY_TOTEM_FIRE,
+    BOT_TOTEM_FLAG_MY_TOTEM_EARTH,
+    BOT_TOTEM_FLAG_MY_TOTEM_WATER,
+    BOT_TOTEM_FLAG_MY_TOTEM_AIR,
+
+    BOT_TOTEM_MASK_SUMMONS          = ((1<<BOT_TOTEM_ELEMENTAL_EARTH)|(1<<BOT_TOTEM_ELEMENTAL_FIRE)),
+
+    //BOT_TOTEM_MASK_MY_TOTEM         = (1<<BOT_TOTEM_NONE),
+
+    BOT_TOTEM_MASK_STRENGTH_OF_EARTH= (1<<BOT_TOTEM_STRENGTH_OF_EARTH),
+    BOT_TOTEM_MASK_FLAMETONGUE      = (1<<BOT_TOTEM_FLAMETONGUE),
+    BOT_TOTEM_MASK_WRATH            = (1<<BOT_TOTEM_WRATH),
+    BOT_TOTEM_MASK_MANA_SPRING      = (1<<BOT_TOTEM_MANA_SPRING),
+    BOT_TOTEM_MASK_WINDFURY         = (1<<BOT_TOTEM_WINDFURY),
+    BOT_TOTEM_MASK_WRATH_OF_AIR     = (1<<BOT_TOTEM_WRATH_OF_AIR),
+    //BOT_TOTEM_MASK_STONESKIN        = (1<<BOT_TOTEM_STONESKIN),
+    BOT_TOTEM_MASK_MANA_TIDE        = (1<<BOT_TOTEM_MANA_TIDE),
+    BOT_TOTEM_MASK_GROUNDING        = (1<<BOT_TOTEM_GROUNDING),
+    BOT_TOTEM_MASK_RESISTANCE_FROST = (1<<BOT_TOTEM_RESISTANCE_FROST),
+    BOT_TOTEM_MASK_RESISTANCE_FIRE  = (1<<BOT_TOTEM_RESISTANCE_FIRE),
+    BOT_TOTEM_MASK_RESISTANCE_NATURE= (1<<BOT_TOTEM_RESISTANCE_NATURE),
+
+    BOT_TOTEM_MASK_PRIMARY_FIRE     = (BOT_TOTEM_MASK_FLAMETONGUE | BOT_TOTEM_MASK_WRATH),
+
+    BOT_TOTEM_MASK_MY_TOTEM_FIRE    = (1<<BOT_TOTEM_FLAG_MY_TOTEM_FIRE),
+    BOT_TOTEM_MASK_MY_TOTEM_EARTH   = (1<<BOT_TOTEM_FLAG_MY_TOTEM_EARTH),
+    BOT_TOTEM_MASK_MY_TOTEM_WATER   = (1<<BOT_TOTEM_FLAG_MY_TOTEM_WATER),
+    BOT_TOTEM_MASK_MY_TOTEM_AIR     = (1<<BOT_TOTEM_FLAG_MY_TOTEM_AIR),
+
+    BOT_TOTEM_MASK_PRIMARY_USE      = (BOT_TOTEM_MASK_STRENGTH_OF_EARTH | BOT_TOTEM_MASK_FLAMETONGUE | \
+                                    BOT_TOTEM_MASK_WRATH | BOT_TOTEM_MASK_MANA_SPRING | \
+                                    BOT_TOTEM_WINDFURY | BOT_TOTEM_MASK_WRATH_OF_AIR),
+
+    BOT_TOTEM_MASK_MY_TOTEM_ALL     = (BOT_TOTEM_MASK_MY_TOTEM_FIRE | BOT_TOTEM_MASK_MY_TOTEM_EARTH | \
+                                    BOT_TOTEM_MASK_MY_TOTEM_WATER | BOT_TOTEM_MASK_MY_TOTEM_AIR)
+};
+
+#define MAX_TOTEMS 4
+
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct shaman_botAI : public bot_ai
+    {
+        shaman_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SHAMAN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        //only for totems
+        bool doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            if (bot_ai::doCast(victim, spellId, flags))
+            {
+                //Calls: 1.5 sec, totems: 1 sec
+                GC_Timer = (flags & TRIGGERED_CAST_DIRECTLY) ? 1500 : 1000;
+                return true;
+            }
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { TotemsCheckTimer = 0; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); removeShapeshiftForm(); bot_ai::JustDied(u); }
+
+        bool removeShapeshiftForm() override
+        {
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_GHOSTWOLF:
+                        me->RemoveAurasDueToSpell(GHOST_WOLF_1);
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            return true;
+        }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (BloodlustCheckTimer > diff || (!me->IsInCombat() && !master->IsInCombat()) ||
+                me->GetDistance(master) > 18 || Rand() > 35)
+                return;
+
+            BloodlustCheckTimer = 3000;
+
+            uint32 BLOODLUST = (me->GetRaceMask() & RACEMASK_ALLIANCE) ? HEROISM_1 : BLOODLUST_1;
+            if (!IsSpellReady(BLOODLUST, diff))
+                return;
+
+            //already rockin'
+            //if (HasAuraName(master, BLOODLUST_1) || HasAuraName(me, BLOODLUST_1))
+            if (me->GetAuraEffect(SPELL_AURA_MOD_MELEE_RANGED_HASTE, SPELLFAMILY_SHAMAN, 0x0, 0x40, 0x0) ||
+                master->GetAuraEffect(SPELL_AURA_MOD_MELEE_RANGED_HASTE, SPELLFAMILY_SHAMAN, 0x0, 0x40, 0x0))
+                return;
+
+            //environment conditions
+            Unit const* u = me->GetVictim();
+            Creature const* cre = u ? u->ToCreature() : nullptr;
+            if (!(u && (u->GetHealth() > me->GetMaxHealth() * 5 || u->GetTypeId() == TYPEID_PLAYER ||
+                (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                me->getAttackers().size() + master->getAttackers().size() > 4)))
+                return;
+
+            //BLOODLUST = GetSpell(BLOODLUST); //not ranked
+
+            uint32 sateSpell = (me->GetRaceMask() & RACEMASK_ALLIANCE) ? EXHAUSTION_AURA : SATED_AURA;
+            Unit::AuraEffectList const& dummies = me->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+            for (Unit::AuraEffectList::const_iterator itr = dummies.begin(); itr != dummies.end(); ++itr)
+            {
+                if ((*itr)->GetEffIndex() != 0) continue;
+                SpellInfo const* spellInfo = (*itr)->GetSpellInfo();
+                if (spellInfo->SpellFamilyName != SPELLFAMILY_GENERIC || spellInfo->SpellIconID != 44) continue;
+                if (spellInfo->Id == sateSpell)
+                    return; //can't cast my type of bloodlust
+            }
+
+            me->InterruptNonMeleeSpells(true);
+            if (doCast(me, BLOODLUST))
+                return;
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            if (TotemsCheckTimer > diff)
+                return;
+
+            TotemsCheckTimer = urand(1500, 2000) + (!IAmFree() ? 100 * master->GetNpcBotsCount() / 2 : 0);
+
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != ObjectGuid::Empty &&
+                    (!master->IsAlive() || master->GetDistance(_totems[i].second._pos) > _totems[i].second._effradius) &&
+                    me->GetDistance(_totems[i].second._pos) > _totems[i].second._effradius)
+                {
+                    //Check if we can use totemic recall and regain some mana
+                    if (!me->GetVictim()/* && GetManaPCT(me) < 90*/ && IsSpellReady(TOTEMIC_RECALL_1, diff))
+                    {
+                        uint8 count = 0;
+                        for (uint8 j = 0; j != MAX_TOTEMS; ++j)
+                        {
+                            if (j == i || _totems[j].first == ObjectGuid::Empty) continue;
+                            if (me->GetDistance(_totems[j].second._pos) > 20.f)
+                                ++count;
+                        }
+                        if (count > 1)
+                        {
+                            if (doCast(me, GetSpell(TOTEMIC_RECALL_1)))
+                                return;
+                        }
+                    }
+                    Unit* to = ObjectAccessor::GetUnit(*me, _totems[i].first);
+                    if (!to)
+                    {
+                        TC_LOG_ERROR("entities.player", "%s has unexpectingly lost totem in slot %u!", me->GetName().c_str(), i);
+                        _totems[i].first = ObjectGuid::Empty;
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                    //reset summon check timer;
+                    TotemTimer[i] = 0;
+                }
+            }
+            //global cooldown is not performed below, intead there is a special condition for Calls
+            if (GC_Timer > diff || me->IsMounted() || Feasting() || IsCasting() ||
+                (master->IsAlive() && me->GetDistance(master) > 15))
+                return;
+
+            bool CotE = me->GetLevel() >= 30; //Call of the Elements is at level 30;
+
+            std::map<uint32, uint32> idMap;
+            uint32 mask = _getTotemsMask(idMap);
+
+            //EARTH
+            //EARTHsituative1 : tremor
+            if (TotemTimer[T_EARTH] <= diff && me->IsInCombat() && !IAmFree() &&
+                IsSpellReady(TREMOR_TOTEM_1, diff, false) && _totems[T_EARTH].second._type != BOT_TOTEM_TREMOR)
+            {
+                //Tremor no cd, party members only
+                Group const* gr = master->GetGroup();
+                if (gr && gr->IsMember(me->GetGUID()))
+                {
+                    uint8 subgr = gr->GetMemberGroup(me->GetGUID());
+                    uint8 count = 0;
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        if (ref->getSubGroup() != subgr) continue;
+                        Player* pl = ref->GetSource();
+                        if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                        if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                        if (me->GetDistance(pl) < 20 &&
+                            pl->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+                            ++count;
+
+                        if (!pl->HaveBot()) continue;
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            if (!gr->IsMember(it->second->GetGUID()) || gr->GetMemberGroup(it->second->GetGUID()) != subgr) continue;
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() ||
+                                !bot->InSamePhase(me) || me->GetDistance(bot) > 20) continue;
+                            if (bot->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+                                ++count;
+                        }
+                    }
+
+                    if (count >= (1 + 1*((mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) != 0)))
+                    {
+                        if (doCast(me, GetSpell(TREMOR_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            if (!CotE)
+                                return;
+                    }
+                }
+                //check if casted
+                if (_totems[T_EARTH].second._type != BOT_TOTEM_TREMOR)
+                    SetSpellCooldown(TREMOR_TOTEM_1, 3000); //fail
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) && TotemTimer[T_EARTH] <= diff && me->IsInCombat())
+            {
+                //EARTHsituative2 : earthbind
+                if (GetSpell(EARTHBIND_TOTEM_1)/* && _totems[T_EARTH].second.type != BOT_TOTEM_EARTHBIND*/)
+                {
+                    //15 sec cd, nearby enemies, instant effect
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 15.f, 1);
+                    for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                    {
+                        Unit* u = *itr;
+                        bool erase = false;
+                        if (u->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || u->HasAuraType(SPELL_AURA_MOD_SPEED_SLOW_ALL))
+                            erase = true;
+                        else if (u->isMoving())
+                        {
+                            if (me->GetDistance(u) > 10.f && !u->HasInArc(M_PI/2, me))
+                                erase = true;
+                        }
+                        else if (me->GetDistance(u) > 9.f)
+                            erase = true;
+
+                        if (erase)
+                        {
+                            targets.erase(itr++);
+                            continue;
+                        }
+                        ++itr;
+                    }
+
+                    if (uint8(targets.size()) >= (1 + 2*((mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) != 0)))
+                    {
+                        if (doCast(me, GetSpell(EARTHBIND_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) && TotemTimer[T_EARTH] <= diff && me->IsInCombat())
+            {
+                //EARTHmain : strength of earth
+                uint32 SoE = GetSpell(STRENGTH_OF_EARTH_TOTEM_1); //tripple check
+                if (SoE &&
+                    (!(mask & BOT_TOTEM_MASK_STRENGTH_OF_EARTH) || idMap[STRENGTH_OF_EARTH_TOTEM_1] < SoE))
+                {
+                    //no cd
+                    if (doCast(me, SoE, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+
+                //EARTHlast : earth elemental (for mass taunt)
+                //uint32 earthElem = GetSpell(EARTH_ELEMENTAL_TOTEM_1);
+                //if (earthElem && IsSpellReady(EARTH_ELEMENTAL_TOTEM_1, diff) && !me->GetMap()->IsDungeon() &&
+                //    me->getAttackers().size() > 1)
+                //{
+                //    //no cd
+                //    if (doCast(me, earthElem, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                //        if (!CotE)
+                //            return;
+                //}
+            }
+
+            //FIRE
+            //FIREsituative1 : magma
+            if (TotemTimer[T_FIRE] <= diff && me->IsInCombat() && !IAmFree() && HasRole(BOT_ROLE_DPS) &&
+                GetSpell(MAGMA_TOTEM_1)/* && _totems[T_FIRE].second.type != BOT_TOTEM_MAGMA*/)
+            {
+                //magma no cd 8 yd, 2 sec delay before first tick
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 13.f, 1);
+                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                {
+                    Unit* u = *itr;
+                    bool erase = false;
+                    if (u->isMoving())
+                    {
+                        if (me->GetDistance(u) > 10.f && !u->HasInArc(M_PI/2, me))
+                            erase = true;
+                    }
+                    else if (me->GetDistance(u) > 7.f)
+                        erase = true;
+
+                    if (erase)
+                    {
+                        targets.erase(itr++);
+                        continue;
+                    }
+                    ++itr;
+                }
+
+                if (uint8(targets.size()) >= (3 + 3*((mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) != 0)))
+                {
+                    if (doCast(me, GetSpell(MAGMA_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) && me->IsInCombat() && TotemTimer[T_FIRE] <= diff)
+            {
+                //FIREMain : wrath or flametongue no cd
+                //aura is exclusive so check mask
+                uint32 base = TOTEM_OF_WRATH_1;
+                uint32 wrathTotem = GetSpell(TOTEM_OF_WRATH_1);
+                uint32 fMask = BOT_TOTEM_MASK_WRATH;
+                if (!wrathTotem)
+                {
+                    base = FLAMETONGUE_TOTEM_1;
+                    wrathTotem = GetSpell(FLAMETONGUE_TOTEM_1);
+                    fMask = BOT_TOTEM_MASK_FLAMETONGUE;
+                }
+                if (wrathTotem &&
+                    ((mask & BOT_TOTEM_MASK_PRIMARY_FIRE) < fMask ||
+                    ((mask & BOT_TOTEM_MASK_PRIMARY_FIRE) == fMask && idMap[base] < wrathTotem)))
+                {
+                    if (doCast(me, wrathTotem, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+
+                //FIREaddin : fire elemental
+                //uint32 fireElem = GetSpell(FIRE_ELEMENTAL_TOTEM_1);
+                //if (fireElem && IsSpellReady(FIRE_ELEMENTAL_TOTEM_1, diff) && !me->GetMap()->IsDungeon())
+                //{
+                //    if (doCast(me, fireElem, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                //        if (!CotE)
+                //            return;
+                //}
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) && me->IsInCombat() && TotemTimer[T_FIRE] <= diff)
+            {
+                //FIRElastresort : frostres (3 shamans of same level req)
+                uint32 frostRes = GetSpell(FROST_RESISTANCE_TOTEM_1);
+                if (frostRes && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_FROST) || idMap[FROST_RESISTANCE_TOTEM_1] < frostRes))
+                {
+                    if (doCast(me, frostRes, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            //WATER
+            //WATERsituative1 : manatide
+            if (TotemTimer[T_WATER] <= diff && me->IsInCombat() && !IAmFree() &&
+                IsSpellReady(MANA_TIDE_TOTEM_1, diff, false))
+            {
+                //5 min cd, party members only, instant effect +4 ticks in 12 secs
+                bool cast = false;
+                Group const* gr = master->GetGroup();
+                if (gr && gr->IsMember(me->GetGUID()))
+                {
+                    uint8 count = 0;
+                    uint8 subgr = gr->GetMemberGroup(me->GetGUID());
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        if (ref->getSubGroup() != subgr) continue;
+                        Player* pl = ref->GetSource();
+                        if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                        if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                        if (pl->IsInCombat() && pl->GetPowerType() == POWER_MANA &&
+                            GetManaPCT(pl) < 35 && me->GetDistance(pl) < 25)
+                            ++count;
+
+                        if (!pl->HaveBot()) continue;
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            if (!gr->IsMember(it->second->GetGUID()) || gr->GetMemberGroup(it->second->GetGUID()) != subgr) continue;
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() || !bot->InSamePhase(me)) continue;
+                            if (bot->IsInCombat() && bot->GetPowerType() == POWER_MANA &&
+                                GetManaPCT(bot) < 35 && me->GetDistance(bot) < 20)
+                                ++count;
+                        }
+                    }
+                    cast = (count >= (3 + 1*((mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) != 0)));
+                }
+                if (!cast)
+                {
+                    if (master->IsInCombat() && master->GetPowerType() == POWER_MANA &&
+                        GetManaPCT(master) < 35 && me->GetDistance(master) < 18)
+                        cast = true;
+                    else if (me->IsInCombat() && GetManaPCT(me) < 35)
+                        cast = true;
+                }
+
+                if (cast)
+                {
+                    if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+                //check if casted
+                if (_totems[T_WATER].second._type != BOT_TOTEM_MANA_TIDE)
+                    SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+            }
+
+            //WATERsituative2 : cleansing
+            //REMOVED CHECKS ARE TOO HEAVY
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) && TotemTimer[T_WATER] <= diff)
+            {
+                //WATERmain : manaspring
+                uint32 MSpring = GetSpell(MANA_SPRING_TOTEM_1); //tripple check
+                if (MSpring && (me->IsInCombat() || !master->isMoving()) &&
+                    (!(mask & BOT_TOTEM_MASK_MANA_SPRING) || idMap[MANA_SPRING_TOTEM_1] < MSpring))
+                {
+                    //no cd
+                    bool cast = false;
+                    if (!IAmFree())
+                    {
+                        Group const* gr = master->GetGroup();
+                        if (gr)
+                        {
+                            for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                            {
+                                Player* pl = ref->GetSource();
+                                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                                if (pl->isMoving()) continue;
+                                if (pl->GetPowerType() == POWER_MANA && GetManaPCT(pl) < 85 && me->GetDistance(pl) < 25)
+                                {
+                                    cast = true;
+                                    break;
+                                }
+
+                                if (!pl->HaveBot()) continue;
+                                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                                {
+                                    Creature* bot = it->second;
+                                    if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() || !bot->InSamePhase(me)) continue;
+                                    if (bot->GetPowerType() == POWER_MANA && GetManaPCT(bot) < 35 && me->GetDistance(bot) < 25)
+                                    {
+                                        cast = true;
+                                        break;
+                                    }
+                                }
+                                if (cast)
+                                    break;
+                            }
+                        }
+                        else if (!master->isMoving() && master->GetPowerType() == POWER_MANA && GetManaPCT(master) < 85)
+                            cast = true;
+                    }
+                    if (!me->isMoving() && GetManaPCT(me) < 95)
+                        cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, MSpring, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) && TotemTimer[T_WATER] <= diff)
+            {
+                //WATERlastresort : fireres (2-3 shamans of same level req)
+                uint32 fireRes = GetSpell(FIRE_RESISTANCE_TOTEM_1);
+                if (fireRes && TotemTimer[T_WATER] <= diff && me->IsInCombat() && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_FIRE) || idMap[FIRE_RESISTANCE_TOTEM_1] < fireRes))
+                {
+                    if (doCast(me, fireRes, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            //AIR
+            //AIRsituative1 : grounding
+            if (TotemTimer[T_AIR] <= diff && me->IsInCombat() &&/* !IAmFree() &&*/
+                IsSpellReady(GROUNDING_TOTEM_1, diff, false))
+            {
+                //grounding 15 sec cd, party members only (and bot and master of course)
+                bool cast = false;
+                Unit* u = FindCastingTarget(27); //totem must be within cast distance
+                if (u && !IsChanneling(u)) //do not waste grounding on periodic ticks
+                {
+                    Group const* gr = !IAmFree() ? master->GetGroup() : nullptr;
+                    for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    {
+                        if (Spell const* spell = u->GetCurrentSpell(i))
+                        {
+                            ObjectGuid tGuid = spell->m_targets.GetUnitTargetGUID();
+                            if (tGuid == me->GetGUID() || tGuid == master->GetGUID() ||
+                                (gr && gr->IsMember(tGuid) && gr->IsMember(me->GetGUID()) && gr->SameSubGroup(tGuid, me->GetGUID())))
+                            {
+                                Unit* t = ObjectAccessor::GetUnit(*me, tGuid);
+                                if (t && t->GetDistance(me) < 27 && !t->HasAuraType(SPELL_AURA_SPELL_MAGNET))
+                                    cast = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+                if (cast)
+                {
+                    if (doCast(me, GetSpell(GROUNDING_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRmain1 : wrathofair - if windfury is disabled or me and master both casters
+                if (!(mask & BOT_TOTEM_MASK_WRATH_OF_AIR) && GetSpell(WRATH_OF_AIR_TOTEM_1))
+                {
+                    bool cast = false;
+
+                    if (!IsMelee() && HasRole(BOT_ROLE_DPS|BOT_ROLE_HEAL) && !IsMeleeClass(master->GetClass()))
+                        cast = true;
+                    else if (!GetSpell(WINDFURY_TOTEM_1)) //disabled
+                        cast = true;
+                    else if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR))
+                        if (mask & BOT_TOTEM_MASK_WINDFURY) //already have windfury from someone else
+                            cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, GetSpell(WRATH_OF_AIR_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            //if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRmain2 : windfury
+                if (!(mask & BOT_TOTEM_MASK_WINDFURY) && GetSpell(WINDFURY_TOTEM_1))
+                {
+                    bool cast = false;
+
+                    if ((IsMelee() && HasRole(BOT_ROLE_DPS)) || (!IAmFree() && IsMeleeClass(master->GetClass())))
+                        cast = true;
+                    else if (!GetSpell(WRATH_OF_AIR_TOTEM_1)) //disabled or not available yet
+                        cast = true;
+                    else if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR))
+                        if (mask & BOT_TOTEM_MASK_WRATH_OF_AIR) //already have wrath of air from someone else
+                            cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, GetSpell(WINDFURY_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            //if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRlastresort : natureres (3-4 shamans of same level req)
+                uint32 natureRes = GetSpell(NATURE_RESISTANCE_TOTEM_1);
+                if (natureRes && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_NATURE) || idMap[NATURE_RESISTANCE_TOTEM_1] < natureRes))
+                {
+                    if (doCast(me, natureRes, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        //if (!CotE)
+                            return;
+                }
+            }
+        }
+
+        void CheckShamanisticRage(uint32 diff)
+        {
+            if (!IsSpellReady(SHAMANISTIC_RAGE_1, diff) || !me->IsInCombat() || IsCasting() || Rand() > 35)
+                return;
+
+            bool cast = false;
+            //case 1: hp pressure
+            if (GetHealthPCT(me) < (50 + 20 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) + 5 * uint32(me->getAttackers().size())))
+                cast = true;
+            //case 2: low mana (melee)
+            else if (me->GetVictim() && !CCed(me, true) && HasRole(BOT_ROLE_DPS) && IsMelee() && GetManaPCT(me) < 40)
+                cast = true;
+
+            if (cast && doCast(me, GetSpell(SHAMANISTIC_RAGE_1)))
+                return;
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff) || !me->IsAlive() || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 25)
+            {
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    return;
+            }
+
+            //case 2: AoE damage
+            //AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetDistance((*iter)) > 9) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 1)
+            {
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || (HasRole(BOT_ROLE_HEAL) && IsCasting()) || Rand() > 40)
+                return;
+
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(WIND_SHEAR_1), 0, WIND_SHEAR_1))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                    return;
+            }
+        }
+
+        void CheckShield(uint32 diff)
+        {
+            if (GC_Timer > diff || ShieldCheckTimer > diff || IsCasting() || Rand() > 15)
+                return;
+
+            ShieldCheckTimer = 2000;
+
+            //Aura const* shield = nullptr;
+            uint32 SHIELD =
+                HasRole(BOT_ROLE_TANK)   ? GetSpell(EARTH_SHIELD_1) :
+                HasRole(BOT_ROLE_HEAL)   ? GetSpell(WATER_SHIELD_1) :
+                HasRole(BOT_ROLE_DPS)    ? GetSpell(LIGHTNING_SHIELD_1) :
+                0;
+            SHIELD =
+                SHIELD ? SHIELD :
+                GetSpell(WATER_SHIELD_1) ? GetSpell(WATER_SHIELD_1) :
+                GetSpell(EARTH_SHIELD_1) ? GetSpell(EARTH_SHIELD_1) :
+                0;
+
+            if (!SHIELD && HasRole(BOT_ROLE_DPS))
+                SHIELD = GetSpell(LIGHTNING_SHIELD_1);
+
+            if (!SHIELD)
+                return;
+
+            AuraApplication const* sh = me->GetAuraApplicationOfRankedSpell(SHIELD);
+            if (!sh || sh->GetBase()->GetCharges() < 5 || sh->GetBase()->GetDuration() < 30000 ||
+                sh->GetBase()->GetSpellInfo()->GetRank() < sSpellMgr->GetSpellInfo(SHIELD)->GetRank())
+            {
+                if (doCast(me, SHIELD))
+                    return;
+            }
+        }
+
+        void UpdateDeadAI(uint32 diff) override
+        {
+            if (IsSpellReady(REINCARNATION_1, diff, false) && (IAmFree() || master->IsInCombat()) && Rand() < 20)
+                if (doCast(me, GetSpell(REINCARNATION_1)))
+                    return;
+
+            bot_ai::UpdateDeadAI(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            CheckShamanisticRage(diff);
+            CheckThunderStorm(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50 && (!HasRole(BOT_ROLE_HEAL) || me->HasAuraType(SPELL_AURA_MOD_SILENCE)))
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(diff);
+            CureGroup(CURE_TOXINS, diff);
+            CheckTotems(diff);
+            CheckShield(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckFireNova(diff);
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckGhostWolf(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            CheckHex(diff);
+            Counter(diff);
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_FIRE|SPELL_SCHOOL_MASK_NATURE))
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetDistance(opponent);
+
+            //spell reflections
+            if (IsSpellReady(EARTH_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && CanRemoveReflectSpells(opponent, EARTH_SHOCK_1) &&
+                doCast(opponent, EARTH_SHOCK_1))
+                return;
+
+            MoveBehind(opponent);
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && IsMelee() && dist <= 5 && Rand() < 120)
+            {
+                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
+                    return;
+            }
+            //SHOCKS
+            if (GetSpellCooldown(EARTH_SHOCK_1) <= diff && HasRole(BOT_ROLE_DPS) &&
+                (GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                dist < 25 && Rand() < 70)
+            {
+                if (GetSpell(FLAME_SHOCK_1))
+                {
+                    AuraEffect const* fsh = opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0x0, 0x0, me->GetGUID());
+                    if (!fsh || fsh->GetBase()->GetDuration() < 3000)
+                    {
+                        if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
+                            return;
+                    }
+                }
+
+                uint32 SHOCK = GetSpell(FROST_SHOCK_1);
+                if (!SHOCK)
+                    SHOCK = GetSpell(EARTH_SHOCK_1);
+
+                if (SHOCK)
+                {
+                    if (doCast(opponent, SHOCK))
+                        return;
+                }
+            }
+
+            //Feral Spirit
+            if (IsSpellReady(FERAL_SPIRIT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40 && dist < 5)
+            {
+                SummonBotPet(opponent);
+                SetSpellCooldown(FERAL_SPIRIT_1, 180000);
+                return;
+            }
+
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && _spec == BOT_SPEC_SHAMAN_ELEMENTAL &&
+                HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(LAVA_BURST_1) && Rand() < 60 &&
+                (me->getAttackers().empty() || dist > 10))
+            {
+                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
+                    return;
+            }
+
+            if (((MaelstromCount < 5 || MaelstromTimer == 0) && IsMelee()) ||
+                (HasRole(BOT_ROLE_HEAL) && GetManaPCT(me) < 25))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(CHAIN_LIGHTNING_1) && Rand() < 80)
+            {
+                Unit* u = FindSplashTarget(35.f, opponent, 5.f);
+                if (u && doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
+                    return;
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(LIGHTNING_BOLT_1))
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(opponent, LIGHTNING_BOLT))
+                    return;
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer > diff)
+                return;
+
+            HexyCheckTimer = 2000;
+            Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+        }
+
+        void CheckHex(uint32 /*diff*/)
+        {
+            //if (Hexy || !IsSpellReady(HEX_1, diff))
+            //    return;
+
+            //if (Unit* target = FindPolyTarget(20))
+            //{
+            //    if (doCast(target, GetSpell(HEX_1)))
+            //        return;
+            //}
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer > diff)
+                return;
+
+            EarthyCheckTimer = 1000;
+            Unit const* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 3);
+            Earthy = (u && (IsTank(u) || u == master));
+        }
+
+        void CheckGhostWolf(uint32 diff)
+        {
+            if (!IsSpellReady(GHOST_WOLF_1, diff) || !HasBotCommandState(BOT_COMMAND_FOLLOW) || Rand() > 15 ||
+                me->GetShapeshiftForm() == FORM_GHOSTWOLF || me->GetVictim() || me->IsMounted() || IAmFree())
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 30))
+            {
+                if (doCast(me, GetSpell(GHOST_WOLF_1)))
+                    return;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Rand() > 25)
+                return;
+
+            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1));
+
+            if (mhEnchantExpireTimer > 0 && mhEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* mh = GetEquips(BOT_SLOT_MAINHAND))
+                    if (mh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            mh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+            if (ohEnchantExpireTimer > 0 && ohEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* oh = GetEquips(BOT_SLOT_OFFHAND))
+                    if (oh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            oh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+
+            // Weapon Enchants
+            if (me->isMoving())
+                return;
+
+            Item* mhWeapon = GetEquips(BOT_SLOT_MAINHAND);
+            Item* ohWeapon = GetEquips(BOT_SLOT_OFFHAND);
+            //item must be non-standard, otherwise combat spells won't be rolled anyway
+            bool mhReady = mhWeapon && !mhWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+            bool ohReady = ohWeapon && !ohWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+
+            if (!mhReady && !ohReady)
+                return; //no ecnhantable weapons
+
+            //OK choose the enchants
+            //MH 1+ Rockbiter, 10+ Flametongue, 30+ Windfury/Earthliving
+            //OH 1+ Rockbiter, 10+ Flametongue, 20+ Frostbrand, 30+ Windfury/Earthliving
+            if (needChooseMHEnchant && mhReady)
+                mhEnchant = HasRole(BOT_ROLE_HEAL) ? (me->GetLevel() >= 30 ? EARTHLIVING_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    HasRole(BOT_ROLE_RANGED) ? (me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    (me->GetLevel() >= 30 ? WINDFURY_WEAPON_1 :
+                    //me->GetLevel() >= 20 ? FROSTBRAND_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/);
+
+            if (needChooseOHEnchant && ohReady) //basically only lvl 40+
+                ohEnchant = HasRole(BOT_ROLE_HEAL) ? (me->GetLevel() >= 30 ? EARTHLIVING_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    HasRole(BOT_ROLE_RANGED) ? (me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    (me->GetLevel() >= 30 ? WINDFURY_WEAPON_1 :
+                    me->GetLevel() >= 20 ? FROSTBRAND_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/);
+
+            uint32 MhEnchant = !mhReady ? 0 : GetSpell(mhEnchant);
+            uint32 OhEnchant = !ohReady ? 0 : GetSpell(ohEnchant);
+
+            SpellInfo const* MhEnchantInfo = mhReady && MhEnchant ? sSpellMgr->GetSpellInfo(MhEnchant) : nullptr;
+            SpellInfo const* OhEnchantInfo = ohReady && OhEnchant ? sSpellMgr->GetSpellInfo(OhEnchant) : nullptr;
+
+            Item* targetWeapon = nullptr;
+            SpellInfo const* targetInfo = nullptr;
+
+            if (mhReady && MhEnchant && mhWeapon->IsFitToSpellRequirements(MhEnchantInfo))
+            {
+                targetWeapon = mhWeapon;
+                targetInfo = MhEnchantInfo;
+            }
+            if (!targetWeapon && ohReady && OhEnchant && ohWeapon->IsFitToSpellRequirements(OhEnchantInfo))
+            {
+                targetWeapon = ohWeapon;
+                targetInfo = OhEnchantInfo;
+            }
+            if (targetWeapon)
+            {
+                Spell* spell = new Spell(me, targetInfo, TRIGGERED_NONE);
+                SpellCastTargets targets;
+                targets.SetItemTarget(targetWeapon);
+                spell->prepare(targets);
+                return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && IsTank(target) && (target == me || !IsTank()) &&
+                (target->IsInCombat() || !target->isMoving()) && Rand() < 35)
+            {
+                AuraEffect const* eShield = target->GetAuraEffect(SPELL_AURA_REDUCE_PUSHBACK, SPELLFAMILY_SHAMAN, 0x0, 0x400, 0x0);
+                bool cast = (!eShield || eShield->GetBase()->GetCharges() < 5 || eShield->GetBase()->GetDuration() < 30000);
+
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                    return true;
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 1000;
+                    return true;
+                }
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 1000;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff) || IsCasting())
+                return;
+
+            Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(PURGE_1));
+            if (target && doCast(target, GetSpell(PURGE_1)))
+                return;
+
+            SetSpellCooldown(PURGE_1, 500); //fail
+        }
+
+        void CheckFireNova(uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_DPS) || _totems[T_FIRE].second._type == BOT_TOTEM_NONE ||
+                !IsSpellReady(FIRE_NOVA_1, diff) || IsCasting() || Rand() > 25)
+                return;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsList(targets, 9.f, 0, ObjectAccessor::GetUnit(*me, _totems[T_FIRE].first));
+            if (targets.size() > 1 || (!targets.empty() && *(targets.begin()) == me->GetVictim()))
+            {
+                if (doCast(me, GetSpell(FIRE_NOVA_1)))
+                    return;
+            }
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            if (hp > 90 &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * 2.5f;
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * 2.5f;
+            if (xppct >= 95 && hp >= 25)
+                return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && Rand() < 80 &&
+                (me->IsInCombat() || target->IsInCombat()) &&//may just revive
+                hp <= 20 && xppct <= 0 && xphploss > _heals[HEALING_WAVE_1] / 2 &&
+                (target->GetTypeId() == TYPEID_PLAYER || IsTank(target) || target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)))
+                {
+                    if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                        return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                (xppct >= 15 || !GetSpell(LESSER_HEALING_WAVE_1)) && xphploss > _heals[HEALING_WAVE_1])
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            //Riptide stacks from different casters
+            if (IsSpellReady(RIPTIDE_1, diff) && hp <= 85 && (tanking || hps < 0 || xphploss > _heals[RIPTIDE_1]) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0x0, 0x0, 0x10, me->GetGUID())
+                /*!target->HasAura(GetSpell(RIPTIDE_1), me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(RIPTIDE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) && xppct > 35 && xphploss > _heals[CHAIN_HEAL_1] &&
+                (!tanking || Rand() < 60 || target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0x0, 0x0, 0x10, me->GetGUID())))
+            {
+                if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) && xphploss > _heals[LESSER_HEALING_WAVE_1])
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const override
+        {
+            //if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MAGIC)
+            //    return;
+
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 30 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1)))
+                crit_chance += 5.f;
+            //Tidal Mastery: 5% additional critical chance for lightning spells
+            if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & schoolMask))
+                crit_chance += 5.f;
+            //Blessing of the Eternals: 4% additional critical chance for all spells
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 45)
+                crit_chance += 4.f;
+            //Tidal Waves (Lesser Healing Wave crit)
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 1, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 25.f;
+            //Tidal Force
+            if (spellInfo->SpellFamilyFlags[0] & 0x1C0)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_FORCE_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 20.f * eff->GetBase()->GetStackAmount();
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost spells
+                if (lvl >= 21 &&
+                    (spellInfo->GetSchoolMask() & (SPELL_SCHOOL_MASK_NATURE|SPELL_SCHOOL_MASK_FIRE|SPELL_SCHOOL_MASK_FROST)))
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+            //Improved Shields (part 1): 15% bonus damage for Lightning Shield orbs
+            if (lvl >= 15 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(LIGHTNING_SHIELD_DAMAGE_1)))
+                pctbonus += 0.15f;
+            //Shamanism: +20/25% bonus from spp
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 45)
+            {
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1) || spellId == GetSpell(LIGHTNING_BOLT_1))
+                    flat_mod += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+                else if (spellId == GetSpell(LAVA_BURST_1))
+                    flat_mod += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.25f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+            //Elemental Oath (part 1): 10% bonus damage
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 45 && me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                pctbonus += 0.1f;
+            //Elemental Weapons (part 1): 40% bonus damage
+            if (lvl >= 20 && (spellId == WINDFURY_ATTACK_MAINHAND || spellId == WINDFURY_ATTACK_OFFHAND))
+                pctbonus += 0.4f;
+
+            //Totemic Recall: bots have reduced base mana so increase mana gain here
+            //if (lvl >= 30 && spellId == GetSpell(TOTEMIC_RECALL_1))
+            //    pctbonus += 0.5f;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flat_mod);
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Way: 25% bonus healing for Healing Wave
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 30 && spellId == GetSpell(HEALING_WAVE_1))
+                pctbonus += 0.25f;
+            //Purification: 10% bonus healing for all spells
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 35)
+                pctbonus += 0.1f;
+            //Nature's Blessing: 15% of Intellect to healing
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 45)
+                flat_mod += GetTotalBotStat(STAT_INTELLECT) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            //Improved Chain Heal: 20% bonus healing for Chain Heal
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 45 && spellId == GetSpell(CHAIN_HEAL_1))
+                pctbonus += 0.2f;
+            //Improved Earth Shield: 10% bonus healing for Earth Shield
+            //Glyph of Earth Shield: 20% bonus healing for Earth Shield
+            if (lvl >= 50 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += (_spec == BOT_SPEC_SHAMAN_RESTORATION) ? 0.3f : 0.2f;
+            //Improved Shields (part 3): 15% bonus healing for Earth Shield
+            if (lvl >= 15 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.15f;
+            //Tidal Waves (part 2): 20% bonus (from spellpower) for Healing Wave and 10% bonus (from spellpower) for Lesser Healing Wave
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 55)
+            {
+                if (spellId == GetSpell(HEALING_WAVE_1))
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(LESSER_HEALING_WAVE_1))
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.1f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            }
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Clearcasting: -40% mana cost
+            if (AuraEffect const* eff = me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 0.4f;
+            //Convection
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x90100003) || (spellInfo->SpellFamilyFlags[1] & 0x8001000)))
+                pctbonus += 0.1f;
+            //Shamanistic Focus
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x90100000))
+                pctbonus += 0.45f;
+            //Mental Quickness:
+            if ((_spec == BOT_SPEC_SHAMAN_ENHANCEMENT) && lvl >= 50 && !spellInfo->CalcCastTime())
+                pctbonus += 0.06f;
+            //Totemic Focus:
+            if (lvl >= 10 && (spellInfo->AttributesEx7 & SPELL_ATTR7_SUMMON_PLAYER_TOTEM))
+                pctbonus += 0.25f;
+            //Tidal Focus:
+            if (lvl >= 15 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x1C0) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x400) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x10)))
+                pctbonus += 0.05f;
+
+            //flat mods
+            //!1 rage = 10 pts!
+            ////Improved Heroic Strike: -3 rage cost for Heroic Strike
+            //if (lvl >= 10 && spellId == GetSpell(HEROIC_STRIKE_1))
+            //    flatbonus += 30;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Nature's Swiftness: -100% cast time
+            if (AuraEffect const* eff = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //pct mods
+            if (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1))
+            {
+                Aura* maelstrom = me->GetAura(MAELSTROM_WEAPON_BUFF);
+                if (maelstrom)
+                {
+                    pctbonus += 0.2f * maelstrom->GetStackAmount();
+                    const_cast<shaman_botAI*>(this)->maelUseUp = true;
+                }
+            }
+            //Tidal Waves (Healing Wave cast time)
+            if (spellInfo->SpellFamilyFlags[0] & 0x40)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.3f;
+
+            //flat mods
+            //Improved Ghost Wolf: -2 sec
+            if (lvl >= 10 && spellId == GetSpell(GHOST_WOLF_1))
+                timebonus += 2000;
+            //Improved Healing Wave: -0.5 sec
+            if (lvl >= 10 && spellId == GetSpell(HEALING_WAVE_1))
+                timebonus += 500;
+            //Lightning Mastery: -0.5 sec
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x3) || (spellInfo->SpellFamilyFlags[1] & 0x1000)))
+                timebonus += 500;
+            //Stormcaller Chain Heal Bonus (26122): -0.4 sec
+            if (lvl >= 60 && spellId == GetSpell(CHAIN_HEAL_1))
+                timebonus += 400;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Reverberation
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x90100000) || (spellInfo->SpellFamilyFlags[1] & 0x8000000)))
+                timebonus += 1000;
+            //Booming Echoes (part 1)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 45 && (spellInfo->SpellFamilyFlags[0] & 0x90000000))
+                timebonus += 2000;
+            //Storm, Earth and Fire (part 1)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x2))
+                timebonus += 2500;
+            //Improved Fire Nova (part 2)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x8000000))
+                timebonus += 4000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Improved Reincarnation + Reduced Reincarnation Cooldown: -20 min cooldown for Reincarnation
+            if (spellId == GetSpell(REINCARNATION_1))
+                timebonus += 1200000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Glyph of Shocking: -0.5 sec global cooldown for Shocks
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x90100000) || (spellInfo->SpellFamilyFlags[1] & 0x8000000)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Grim Reach: +20% range for Affliction Spells
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x8048C41A) || (spellInfo->SpellFamilyFlags[1] & 0x40713)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Elemental Reach part 1: +6 yd
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 30 && ((spellInfo->SpellFamilyFlags[0] & 0x8000003) || (spellInfo->SpellFamilyFlags[1] & 0x1000)))
+                flatbonus += 6.f;
+            //Elemental Reach part 2: +15 yd
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 30 && (spellInfo->SpellFamilyFlags[0] & 0x10000000))
+                flatbonus += 15.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Chain Heal
+            if (spellInfo->SpellFamilyFlags[0] & 0x100)
+                bonusTargets += 1;
+            //Glyph of Chain Lightning
+            if (spellInfo->SpellFamilyFlags[0] & 0x2)
+                bonusTargets += 1;
+            //Chain Healing Wave (23573)
+            if (me->GetLevel() >= 60 && spellInfo->SpellFamilyFlags[0] & 0x100)
+                bonusTargets += 2;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //reincarnation: notify master
+            if (baseId == REINCARNATION_1)
+            {
+                BotWhisper("Reincarnation used!");
+
+                //no spellHit trigger - do it here
+                SpellHit(me, spellInfo);
+                me->CastSpell(me, RESURRECTION_VISUAL_SPELL, true);
+            }
+            //manatide: notify
+            if (baseId == MANA_TIDE_TOTEM_1)
+            {
+                BotWhisper("Mana Tide used!");
+            }
+            //Nature's Swiftness: notify master
+            if (baseId == NATURES_SWIFTNESS_1)
+            {
+                BotWhisper("Nature's Swiftness used!");
+            }
+
+            //Handle Clearcasting
+            if (AuraEffect* eff = me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    eff->GetBase()->DropCharge();
+            //Handle Tidal Focus
+            //Healing Wave (cast time): if full Maelstrom than don't use up charge
+            if (MaelstromCount < 5 && (spellInfo->SpellFamilyFlags[0] & 0x40))
+                if (AuraEffect* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        eff->GetBase()->DropCharge();
+            //Lesser Healing Wave (crit)
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                if (AuraEffect* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 1, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        eff->GetBase()->DropCharge();
+
+            //Nature's Swiftness
+            if (AuraEffect const* eff = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0, me->GetGUID()))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1);
+            }
+
+            //Tidal Force: Handled in Unit::HandleDummyAuraProc(): case 55166:
+            //if (spellInfo->SpellFamilyFlags[0] & 0x1C0)
+            //    if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_FORCE_BUFF, 0, me->GetGUID()))
+            //        if (eff->IsAffectedOnSpell(spellInfo))
+            //            me->RemoveAuraFromStack(TIDAL_FORCE_BUFF);
+
+            //Shield cd
+            if (baseId == LIGHTNING_SHIELD_DAMAGE_1)
+                SetSpellCooldown(LIGHTNING_SHIELD_DAMAGE_1, 3000); //is that right? from spell_proc_event
+
+            //autouse totems
+            if (baseId == EARTHBIND_TOTEM_1 || baseId == STRENGTH_OF_EARTH_TOTEM_1)
+                TotemTimer[T_EARTH] = 5000;
+            if (baseId == TREMOR_TOTEM_1)
+                TotemTimer[T_EARTH] = 12000;
+            if (baseId == MAGMA_TOTEM_1)
+                TotemTimer[T_FIRE] = 12000;
+            if (baseId == TOTEM_OF_WRATH_1 || baseId == FLAMETONGUE_TOTEM_1)
+                TotemTimer[T_FIRE] = 5000;
+            if (baseId == FROST_RESISTANCE_TOTEM_1)
+                TotemTimer[T_FIRE] = 120000;
+            if (baseId == MANA_TIDE_TOTEM_1)
+                TotemTimer[T_WATER] = 12000;
+            if (baseId == MANA_SPRING_TOTEM_1)
+                TotemTimer[T_WATER] = 5000;
+            if (baseId == FIRE_RESISTANCE_TOTEM_1)
+                TotemTimer[T_WATER] = 120000;
+            if (baseId == GROUNDING_TOTEM_1)
+                TotemTimer[T_AIR] = me->GetLevel() >= 15 ? 13000 : 15000;
+            if (baseId == WRATH_OF_AIR_TOTEM_1 || baseId == WINDFURY_TOTEM_1)
+                TotemTimer[T_AIR] = 5000;
+            if (baseId == NATURE_RESISTANCE_TOTEM_1)
+                TotemTimer[T_AIR] = 120000;
+            //other (manual use)
+            if (baseId == STONECLAW_TOTEM_1)
+                TotemTimer[T_EARTH] = 15000;
+            if (baseId == STONESKIN_TOTEM_1)
+                TotemTimer[T_EARTH] = 300000;
+            if (baseId == EARTH_ELEMENTAL_TOTEM_1)
+                TotemTimer[T_EARTH] = 120000;
+            if (baseId == SEARING_TOTEM_1)
+                TotemTimer[T_FIRE] = 60000;
+            if (baseId == FIRE_ELEMENTAL_TOTEM_1)
+                TotemTimer[T_FIRE] = 120000;
+            if (baseId == CLEANSING_TOTEM_1)
+                TotemTimer[T_WATER] = 300000;
+            if (baseId == HEALING_STREAM_TOTEM_1)
+                TotemTimer[T_WATER] = 300000;
+
+            //Totemic Recall totems resummon helper
+            if (baseId == TOTEMIC_RECALL_1)
+            {
+                TotemsCheckTimer = GC_Timer;
+                for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                    TotemTimer[i] = 0;
+            }
+
+            if (maelUseUp)
+            {
+                if (baseId == LIGHTNING_BOLT_1 || baseId == CHAIN_LIGHTNING_1 || baseId == HEALING_WAVE_1 ||
+                    baseId == LESSER_HEALING_WAVE_1 || baseId == CHAIN_HEAL_1 || baseId == HEX_1)
+                {
+                    MaelstromCount = 0;
+                    me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF);
+                }
+            }
+
+            //Item enchant
+            //We don't know which item is targeted
+            //Actually it is mh, then oh
+            if (/*baseId == ROCKBITER_WEAPON_1 || */baseId == FLAMETONGUE_WEAPON_1 || baseId == FROSTBRAND_WEAPON_1 ||
+                baseId == WINDFURY_WEAPON_1 || baseId == EARTHLIVING_WEAPON_1)
+            {
+                //We set duration to 2 seconds to prevent exploiting unequip mechanic
+                //to get enchanted weapons for player (for non-shaman bots it won't work)
+                uint32 slot = TEMP_ENCHANTMENT_SLOT;
+                uint32 duration = 2 * IN_MILLISECONDS;
+                uint32 charges = 0;
+                uint32 enchant_id = spellInfo->Effects[0].MiscValue;
+                //SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                Item* mh = GetEquips(BOT_SLOT_MAINHAND);
+                Item* oh = GetEquips(BOT_SLOT_OFFHAND);
+                Item* item = nullptr;
+                uint8 itemSlot = 0;
+
+                if (mh && !mh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = mh;
+                    itemSlot = BOT_SLOT_MAINHAND;
+                }
+                else if (oh && !oh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && oh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = oh;
+                    itemSlot = BOT_SLOT_OFFHAND;
+                }
+                else
+                    ASSERT(false && "shaman bot attempted to enchant his weapons but cannot find a weapon to apply it!");
+
+                if (!IAmFree())
+                    master->GetSession()->SendEnchantmentLog(me->GetGUID(), me->GetGUID(), item->GetEntry(), enchant_id);
+
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, charges);
+                ApplyItemBonuses(itemSlot); //RemoveItemBonuses inside
+                if (itemSlot == BOT_SLOT_MAINHAND)
+                    mhEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                else if (itemSlot == BOT_SLOT_OFFHAND)
+                    ohEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                GC_Timer = 1500; //needed
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon helper
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura const* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                    MaelstromCount = mwb->GetStackAmount();
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == EARTH_SHIELD_1)
+                Earthy = true;
+
+            if (baseId == HEX_1)
+            {
+                Hexy = true;
+                HexyCheckTimer += 2000;
+            }
+
+            //Earthen Power part 2
+            if ((_spec == BOT_SPEC_SHAMAN_ENHANCEMENT) && me->GetLevel() >= 50 && baseId == EARTH_SHOCK_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    eff->ChangeAmount(eff->GetAmount() * 2);
+            }
+
+            //Lightning Overload
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                me->GetLevel() >= 45 && (baseId == LIGHTNING_BOLT_1 || baseId == CHAIN_LIGHTNING_1) &&
+                urand(1,100) <= 33)
+            {
+                uint32 procId = 0;
+                switch (spellId)
+                {
+                    // Lightning Bolt
+                    case   403: procId = 45284; break; // Rank  1
+                    case   529: procId = 45286; break; // Rank  2
+                    case   548: procId = 45287; break; // Rank  3
+                    case   915: procId = 45288; break; // Rank  4
+                    case   943: procId = 45289; break; // Rank  5
+                    case  6041: procId = 45290; break; // Rank  6
+                    case 10391: procId = 45291; break; // Rank  7
+                    case 10392: procId = 45292; break; // Rank  8
+                    case 15207: procId = 45293; break; // Rank  9
+                    case 15208: procId = 45294; break; // Rank 10
+                    case 25448: procId = 45295; break; // Rank 11
+                    case 25449: procId = 45296; break; // Rank 12
+                    case 49237: procId = 49239; break; // Rank 13
+                    case 49238: procId = 49240; break; // Rank 14
+                    // Chain Lightning
+                    case   421: procId = 45297; break; // Rank  1
+                    case   930: procId = 45298; break; // Rank  2
+                    case  2860: procId = 45299; break; // Rank  3
+                    case 10605: procId = 45300; break; // Rank  4
+                    case 25439: procId = 45301; break; // Rank  5
+                    case 25442: procId = 45302; break; // Rank  6
+                    case 49270: procId = 49268; break; // Rank  7
+                    case 49271: procId = 49269; break; // Rank  8
+                    default:                    break;
+                }
+
+                if (procId)
+                {
+                    if (baseId == LIGHTNING_BOLT_1)
+                        me->CastSpell(target, procId, true);
+                    if (baseId == CHAIN_LIGHTNING_1)
+                    {
+                        //Normalize chance
+                        if (urand(1,100) <= (100.f / spell->Effects[0].ChainTarget))
+                            me->CastSpell(target, procId, true);
+                    }
+                }
+            }
+
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (baseId == LIGHTNING_SHIELD_1 || baseId == EARTH_SHIELD_1 || baseId == WATER_SHIELD_1)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 6);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                if (_wolves[i] == summon->GetGUID())
+                    return i;
+
+            return 0;
+        }
+
+        void SummonBotPet(Unit* target)
+        {
+            //if (botPet)
+            //    botPet->ToTempSummon()->UnSummon();
+
+            uint32 entry = BOT_PET_SPIRIT_WOLF;
+
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+            {
+                //Position pos;
+
+                //45 sec duration
+                Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_MANUAL_DESPAWN);
+                //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+                //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+                myPet->SetCreatorGUID(master->GetGUID());
+                myPet->SetOwnerGUID(me->GetGUID());
+                myPet->SetFaction(master->GetFaction());
+                myPet->SetControlledByPlayer(!IAmFree());
+                myPet->SetPvP(me->IsPvP());
+                myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+                myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+                myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, FERAL_SPIRIT_1);
+
+                //botPet = myPet;
+
+                myPet->Attack(target, true);
+                if (!HasBotCommandState(BOT_COMMAND_STAY))
+                    myPet->GetMotionMaster()->MoveChase(target);
+            }
+        }
+
+        void JustSummoned(Creature* summon) override
+        {
+            if (summon->GetEntry() == BOT_PET_SPIRIT_WOLF)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                {
+                    if (!_wolves[i])
+                    {
+                        _wolves[i] = summon->GetGUID();
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Shaman_bot:JustSummoned() wolves array is full");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+            if (summon->GetEntry() == BOT_PET_SPIRIT_WOLF)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                {
+                    if (_wolves[i] == summon->GetGUID())
+                    {
+                        _wolves[i] = ObjectGuid::Empty;
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Shaman_bot:SummonedCreatureDespawn() wolf is not found in array");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void UnsummonAll() override
+        {
+            //if (botPet)
+            //    botPet->ToTempSummon()->UnSummon();
+
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+            {
+                if (_wolves[i])
+                    if (Unit* wo = ObjectAccessor::GetUnit(*me, _wolves[i]))
+                        wo->ToTempSummon()->UnSummon();
+            }
+
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != ObjectGuid::Empty)
+                {
+                    Unit* to = ObjectAccessor::GetUnit(*me, _totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void OnBotDespawn(Creature* summon) override
+        {
+            if (!summon)
+            {
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s received NULL", me->GetName().c_str());
+                ASSERT(false);
+                //UnsummonAll();
+                return;
+            }
+
+            TempSummon const* totem = summon->ToTempSummon();
+            if (!totem || !totem->IsTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Slot)
+            {
+                case SUMMON_SLOT_TOTEM_FIRE:    slot = T_FIRE;  break;
+                case SUMMON_SLOT_TOTEM_EARTH:   slot = T_EARTH; break;
+                case SUMMON_SLOT_TOTEM_WATER:   slot = T_WATER; break;
+                case SUMMON_SLOT_TOTEM_AIR:     slot = T_AIR;   break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s in unknown slot %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->ID);
+                    return;
+            }
+
+            if (_totems[slot].first == ObjectGuid::Empty)
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s while not having it registered!", me->GetName().c_str(), summon->GetName().c_str());
+            else if (_totems[slot].second._type == BOT_TOTEM_NONE || _totems[slot].second._type >= BOT_TOTEM_END)
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s with no type assigned!", me->GetName().c_str(), summon->GetName().c_str());
+
+            //here we reset totem category cd (not totem spell cd) if totem is destroyed
+            //TC_LOG_ERROR("entities.player", "OnBotDespawn(): %s despawned (%s : %u)", summon->GetName().c_str(), summon->IsAlive() ? "alive" : summon->isDying() ? "justdied" : "unk", (uint32)summon->getDeathState());
+            if (!summon->IsAlive()) // alive here means totem is being replaced or unsummoned through other means
+                TotemTimer[slot] = 0;
+
+            _totems[slot].first = ObjectGuid::Empty;
+            _totems[slot].second._type = BOT_TOTEM_NONE;
+            me->m_SummonSlot[slot+1] = ObjectGuid::Empty;
+        }
+
+        void OnBotSummon(Creature* summon) override
+        {
+            TempSummon const* totem = summon->ToTempSummon();
+            if (!totem || !totem->IsTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Slot)
+            {
+                case SUMMON_SLOT_TOTEM_FIRE:    slot = T_FIRE;  break;
+                case SUMMON_SLOT_TOTEM_EARTH:   slot = T_EARTH; break;
+                case SUMMON_SLOT_TOTEM_WATER:   slot = T_WATER; break;
+                case SUMMON_SLOT_TOTEM_AIR:     slot = T_AIR;   break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->ID);
+                    return;
+            }
+
+            //Unsummon current totem
+            ObjectGuid curTotemGUID = _totems[slot].first;
+            if (curTotemGUID)
+            {
+                Unit* curTotem = ObjectAccessor::GetUnit(*me, curTotemGUID);
+                if (curTotem)
+                    curTotem->ToTotem()->UnSummon();
+            }
+
+            float radius = 30.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
+                    radius = std::max<float>(entry->RadiusMax, radius);
+
+            uint32 createSpell = summon->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+            if (createSpell)
+                createSpell = sSpellMgr->GetSpellInfo(createSpell)->GetFirstRankSpell()->Id;
+            //DEBUG
+            //if (!IAmFree())
+            //{
+            //    std::ostringstream msg;
+            //    msg << "Summoned " << summon->GetName() << " by basespell: " << createSpell;
+            //    BotWhisper(msg.str().c_str());
+            //}
+            uint32 btype;
+            switch (createSpell)
+            {
+                case SEARING_TOTEM_1:           btype = BOT_TOTEM_SEARING;              break;
+                case STONECLAW_TOTEM_1:         btype = BOT_TOTEM_STONECLAW;            break;
+                case SENTRY_TOTEM_1:            btype = BOT_TOTEM_SENTRY;               break;
+                case STONESKIN_TOTEM_1:         btype = BOT_TOTEM_STONESKIN;            break;
+                case HEALING_STREAM_TOTEM_1:    btype = BOT_TOTEM_HEALING_STREAM;       break;
+                case EARTHBIND_TOTEM_1:         btype = BOT_TOTEM_EARTHBIND;            break;
+                case EARTH_ELEMENTAL_TOTEM_1:   btype = BOT_TOTEM_ELEMENTAL_EARTH;      break;
+                case FIRE_ELEMENTAL_TOTEM_1:    btype = BOT_TOTEM_ELEMENTAL_FIRE;       break;
+                case MAGMA_TOTEM_1:             btype = BOT_TOTEM_MAGMA;                break;
+                case FLAMETONGUE_TOTEM_1:       btype = BOT_TOTEM_FLAMETONGUE;          break;
+                case FROST_RESISTANCE_TOTEM_1:  btype = BOT_TOTEM_RESISTANCE_FROST;     break;
+                case FIRE_RESISTANCE_TOTEM_1:   btype = BOT_TOTEM_RESISTANCE_FIRE;      break;
+                case NATURE_RESISTANCE_TOTEM_1: btype = BOT_TOTEM_RESISTANCE_NATURE;    break;
+                case GROUNDING_TOTEM_1:         btype = BOT_TOTEM_GROUNDING;            break;
+                case STRENGTH_OF_EARTH_TOTEM_1: btype = BOT_TOTEM_STRENGTH_OF_EARTH;    break;
+                case WINDFURY_TOTEM_1:          btype = BOT_TOTEM_WINDFURY;             break;
+                case WRATH_OF_AIR_TOTEM_1:      btype = BOT_TOTEM_WRATH_OF_AIR;         break;
+                case CLEANSING_TOTEM_1:         btype = BOT_TOTEM_CLEANSING;            break;
+                case MANA_SPRING_TOTEM_1:       btype = BOT_TOTEM_MANA_SPRING;          break;
+                case MANA_TIDE_TOTEM_1:         btype = BOT_TOTEM_MANA_TIDE;            break;
+                case TREMOR_TOTEM_1:            btype = BOT_TOTEM_TREMOR;               break;
+                case TOTEM_OF_WRATH_1:          btype = BOT_TOTEM_WRATH;                break;
+                default:
+                {
+                    btype = BOT_TOTEM_NONE;
+                    if (!IAmFree())
+                    {
+                        std::ostringstream msg;
+                        msg << "Unknown totem create spell: " << createSpell << "!";
+                        BotWhisper(msg.str().c_str());
+                    }
+                    break;
+                }
+            }
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second._pos.Relocate(*summon);
+            _totems[slot].second._effradius = !((1<<btype) & BOT_TOTEM_MASK_SUMMONS) ? radius : SIZE_OF_GRIDS;
+            _totems[slot].second._type = btype;
+            me->m_SummonSlot[slot+1] = _totems[slot].first; //needed for scripts handlers
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x=%.2f, y=%.2f, z=%.2f",
+            //    summon->GetName().c_str(), slot + 1, _totems[slot].second.pos.GetPositionX(), _totems[slot].second.pos.GetPositionY(), _totems[slot].second.pos.GetPositionZ());
+
+            //TODO: gets overriden in Spell::EffectSummonType (end)
+            //Without setting creator correctly it will be impossible to use summon X elemental totems
+            summon->SetCreatorGUID(me->GetGUID());
+            summon->SetDisplayId(sObjectMgr->GetModelForTotem(SummonSlot(slot+1), Races(me->GetRace())));
+            summon->SetPvP(me->IsPvP());
+            summon->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            // totem will claim master's summon slot
+            // free it to avoid conflicts with other shaman bots and master
+            // if master is a shaman his totem will despawn
+            // fixed in summoning sequence
+            //master->m_SummonSlot[++slot] = 0;
+
+            //After summon effects which are not handled for bot totems
+            //check by btype
+
+            // Storm, Earth and Fire: Earthbind totem AoE root
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && btype == BOT_TOTEM_EARTHBIND && me->GetLevel() >= 40)
+            {
+                //master's talent will be found so do not cast earthgrab twice, instead let spell script roll the chance
+                //see spell_shaman.cpp
+                if (!master->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 3063, EFFECT_1))
+                    summon->CastSpell(summon, STORMEARTHANDFIRE_EARTHGRAB, false);
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(LIGHTNING_BOLT_1) : 20.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_ENCHANT_IS_AUTO_MH:
+                    return needChooseMHEnchant;
+                case BOTAI_MISC_ENCHANT_IS_AUTO_OH:
+                    return needChooseOHEnchant;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    return mhEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    return ohEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    return mhEnchant;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    return ohEnchant;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_1:
+                    return /*GetSpell(ROCKBITER_WEAPON_1) ? ROCKBITER_WEAPON_1 : */0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_2:
+                    return GetSpell(FLAMETONGUE_WEAPON_1) ? FLAMETONGUE_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_3:
+                    return GetSpell(FROSTBRAND_WEAPON_1) ? FROSTBRAND_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_4:
+                    return GetSpell(WINDFURY_WEAPON_1) ? WINDFURY_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_5:
+                    return GetSpell(EARTHLIVING_WEAPON_1) ? EARTHLIVING_WEAPON_1 : 0;
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_SPIRIT_WOLF;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    if (value)
+                        mhEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    if (value)
+                        ohEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    mhEnchant = value;
+                    needChooseMHEnchant = value ? false : true;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    ohEnchant = value;
+                    needChooseOHEnchant = value ? false : true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                _wolves[i] = ObjectGuid::Empty;
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                TotemTimer[i] = 0;
+
+            removeShapeshiftForm();
+
+            TotemsCheckTimer = 1500;
+
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            ShieldCheckTimer = 2000;
+            BloodlustCheckTimer = 5000;
+            MaelstromTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            maelUseUp = false;
+
+            mhEnchantExpireTimer = 1;
+            ohEnchantExpireTimer = 1;
+
+            DefaultInit();
+
+            mhEnchant = 0;
+            ohEnchant = 0;
+            needChooseMHEnchant = true;
+            needChooseOHEnchant = true;
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                if (TotemTimer[i] > diff)
+                    TotemTimer[i] -= diff;
+
+            if (TotemsCheckTimer > diff)        TotemsCheckTimer -= diff;
+
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+            if (ShieldCheckTimer > diff)        ShieldCheckTimer -= diff;
+            if (BloodlustCheckTimer > diff)     BloodlustCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount) { MaelstromCount = 0; maelUseUp = false; }
+
+            if (mhEnchantExpireTimer > diff)    mhEnchantExpireTimer -= diff;
+            if (ohEnchantExpireTimer > diff)    ohEnchantExpireTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isElem = _spec == BOT_SPEC_SHAMAN_ELEMENTAL;
+            bool isEnha = _spec == BOT_SPEC_SHAMAN_ENHANCEMENT;
+            bool isRest = _spec == BOT_SPEC_SHAMAN_RESTORATION;
+
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            InitSpellMap(CURE_TOXINS_1);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+            InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+            InitSpellMap((me->GetRaceMask() & RACEMASK_ALLIANCE) ? HEROISM_1 : BLOODLUST_1); //at least race is constant
+
+            InitSpellMap(GHOST_WOLF_1);
+
+            InitSpellMap(FIRE_NOVA_1);
+            //totems
+            InitSpellMap(EARTHBIND_TOTEM_1);
+            InitSpellMap(MAGMA_TOTEM_1);
+            //InitSpellMap(SEARING_TOTEM_1);
+            //InitSpellMap(STONECLAW_TOTEM_1);
+            InitSpellMap(FIRE_ELEMENTAL_TOTEM_1);
+            InitSpellMap(EARTH_ELEMENTAL_TOTEM_1);
+            InitSpellMap(FIRE_RESISTANCE_TOTEM_1);
+            InitSpellMap(FROST_RESISTANCE_TOTEM_1);
+            InitSpellMap(NATURE_RESISTANCE_TOTEM_1);
+            InitSpellMap(FLAMETONGUE_TOTEM_1);
+            InitSpellMap(GROUNDING_TOTEM_1);
+            //InitSpellMap(SENTRY_TOTEM_1);
+            //InitSpellMap(STONESKIN_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(WRATH_OF_AIR_TOTEM_1);
+            InitSpellMap(CLEANSING_TOTEM_1);
+            //InitSpellMap(HEALING_STREAM_TOTEM_1);
+            InitSpellMap(MANA_SPRING_TOTEM_1);
+            InitSpellMap(TREMOR_TOTEM_1);
+
+            InitSpellMap(TOTEMIC_RECALL_1);
+
+            InitSpellMap(REINCARNATION_1); //base lvl 30, 30 min cd
+
+  /*Talent*///lvl >= 40 && isElem ? InitSpellMap(ELEMENTAL_MASTERY_1) : RemoveSpell(ELEMENTAL_MASTERY_1);
+  /*Talent*/lvl >= 60 && isElem ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+
+  /*Talent*/lvl >= 40 && isEnha ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+  /*Talent*/lvl >= 50 && isEnha ? InitSpellMap(SHAMANISTIC_RAGE_1) : RemoveSpell(SHAMANISTIC_RAGE_1);
+  /*Talent*/lvl >= 60 && isEnha ? InitSpellMap(FERAL_SPIRIT_1) : RemoveSpell(FERAL_SPIRIT_1); //not casted
+
+  /*Talent*/lvl >= 20 && isRest ? InitSpellMap(TIDAL_FORCE_1) : RemoveSpell(TIDAL_FORCE_1);
+  /*Talent*/lvl >= 30 && isRest ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+  /*Talent*/lvl >= 50 && isRest ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+  /*Talent*/lvl >= 60 && isRest ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+
+  /*Talent*/lvl >= 50 && isElem ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
+
+  /*Talent*/lvl >= 40 && isRest ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
+
+            CURE_TOXINS = InitSpell(me, CLEANSE_SPIRIT_1) ? CLEANSE_SPIRIT_1 : CURE_TOXINS_1;
+            RemoveSpell(CLEANSE_SPIRIT_1);
+            RemoveSpell(CURE_TOXINS_1);
+            InitSpellMap(CURE_TOXINS);
+
+            //InitSpellMap(ROCKBITER_WEAPON_1); //lvl 1
+            InitSpellMap(FLAMETONGUE_WEAPON_1); //lvl 10
+            InitSpellMap(FROSTBRAND_WEAPON_1); //lvl 20
+            InitSpellMap(WINDFURY_WEAPON_1); //lvl 30
+            InitSpellMap(EARTHLIVING_WEAPON_1); //lvl 30
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isElem = _spec == BOT_SPEC_SHAMAN_ELEMENTAL;
+            bool isEnha = _spec == BOT_SPEC_SHAMAN_ENHANCEMENT;
+            bool isRest = _spec == BOT_SPEC_SHAMAN_RESTORATION;
+
+            RefreshAura(ELEMENTAL_DEVASTATION3, isEnha && level >= 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION2, isEnha && level >= 15 && level < 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION1, isEnha && level >= 12 && level < 15 ? 1 : 0);
+            RefreshAura(ELEMENTAL_FOCUS, isElem && level >= 20 ? 1 : 0);
+            RefreshAura(ELEMENTAL_OATH, isElem && level >= 40 ? 1 : 0);
+            //RefreshAura(STORM_EARTH_AND_FIRE, isElem && level >= 45 ? 1 : 0);
+
+            RefreshAura(TOUGHNESS, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, isEnha && level >= 29 ? 1 : 0);
+            RefreshAura(FLURRY4, isEnha && level >= 28 && level < 29 ? 1 : 0);
+            RefreshAura(FLURRY3, isEnha && level >= 27 && level < 28 ? 1 : 0);
+            RefreshAura(FLURRY2, isEnha && level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(FLURRY1, isEnha && level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WEAPON_MASTERY, isEnha && level >= 30 ? 1 : 0);
+            RefreshAura(UNLEASHED_RAGE, isEnha && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_STORMSTRIKE, isEnha && level >= 40 ? 1 : 0);
+            RefreshAura(STATIC_SHOCK, isEnha && level >= 41 ? 1 : 0);
+            RefreshAura(EARTHEN_POWER, isEnha && level >= 50 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON5, isEnha && level >= 59 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON4, isEnha && level >= 58 && level < 59 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON3, isEnha && level >= 57 && level < 58 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON2, isEnha && level >= 56 && level < 57 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON1, isEnha && level >= 55 && level < 56 ? 1 : 0);
+
+            RefreshAura(IMPROVED_WATER_SHIELD, isRest && level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_HEALING, isRest && level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_AWAKENING, isRest && level >= 50 ? 1 : 0);
+            RefreshAura(TIDAL_WAVES, isRest && level >= 55 ? 1 : 0);
+
+            RefreshAura(SHAMAN_FLAME_SHOCK_PASSIVE);
+
+            RefreshAura(SHAMAN_T10_RESTO_4P, level >= 70 ? 1 : 0);
+
+            RefreshAura(GLYPH_THUNDERSTORM, GetSpell(THUNDERSTORM_1) ? 1 : 0);
+            RefreshAura(GLYPH_TOTEM_OF_WRATH, GetSpell(TOTEM_OF_WRATH_1) ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CLEANSE_SPIRIT_1:
+                case WATER_WALKING_1:
+                case WATER_BREATHING_1:
+                case BLOODLUST_1:
+                case HEROISM_1:
+                case SHAMANISTIC_RAGE_1:
+                //case ELEMENTAL_MASTERY_1:
+                case TIDAL_FORCE_1:
+                //Totems
+                //case EARTHBIND_TOTEM_1:
+                //case MAGMA_TOTEM_1:
+                //case SEARING_TOTEM_1:
+                //case STONECLAW_TOTEM_1:
+                //case FIRE_ELEMENTAL_TOTEM_1:
+                //case EARTH_ELEMENTAL_TOTEM_1:
+                //case FIRE_RESISTANCE_TOTEM_1:
+                //case FROST_RESISTANCE_TOTEM_1:
+                //case NATURE_RESISTANCE_TOTEM_1:
+                //case FLAMETONGUE_TOTEM_1:
+                case GROUNDING_TOTEM_1:
+                //case SENTRY_TOTEM_1:
+                //case STONESKIN_TOTEM_1:
+                //case STRENGTH_OF_EARTH_TOTEM_1:
+                //case WINDFURY_TOTEM_1:
+                //case WRATH_OF_AIR_TOTEM_1:
+                case CLEANSING_TOTEM_1:
+                //case HEALING_STREAM_TOTEM_1:
+                //case MANA_SPRING_TOTEM_1:
+                //case TOTEM_OF_WRATH_1:
+                case MANA_TIDE_TOTEM_1:
+                case TREMOR_TOTEM_1:
+                case TOTEMIC_RECALL_1:
+                    return true;
+                case CURE_TOXINS_1:
+                    return !GetSpell(CLEANSE_SPIRIT_1);
+                case FIRE_NOVA_1:
+                    return _totems[T_FIRE].second._type != BOT_TOTEM_NONE;
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(std::list<std::string> &specList) override
+        {
+            std::ostringstream msg1;
+            msg1 << "Main hand: ";
+            switch (mhEnchant)
+            {
+                //case ROCKBITER_WEAPON_1:   msg1 << "Rockbiter";  break;
+                case FLAMETONGUE_WEAPON_1: msg1 << "Flametongue";break;
+                case FROSTBRAND_WEAPON_1:  msg1 << "Frostbrand"; break;
+                case WINDFURY_WEAPON_1:    msg1 << "Windfury";   break;
+                case EARTHLIVING_WEAPON_1: msg1 << "Earthliving";break;
+                default:                   msg1 << "Nothing";    break;
+            }
+            specList.push_back(msg1.str());
+
+            std::ostringstream msg2;
+            msg2 << "Offhand: ";
+            switch (ohEnchant)
+            {
+                //case ROCKBITER_WEAPON_1:   msg2 << "Rockbiter";  break;
+                case FLAMETONGUE_WEAPON_1: msg2 << "Flametongue";break;
+                case FROSTBRAND_WEAPON_1:  msg2 << "Frostbrand"; break;
+                case WINDFURY_WEAPON_1:    msg2 << "Windfury";   break;
+                case EARTHLIVING_WEAPON_1: msg2 << "Earthliving";break;
+                default:                   msg2 << "Nothing";    break;
+            }
+            specList.push_back(msg2.str());
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, HEALING_WAVE_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HEALING_WAVE_1));
+                _heals[HEALING_WAVE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[HEALING_WAVE_1] = 0;
+
+            if (InitSpell(me, LESSER_HEALING_WAVE_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, LESSER_HEALING_WAVE_1));
+                _heals[LESSER_HEALING_WAVE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[LESSER_HEALING_WAVE_1] = 0;
+
+            if (InitSpell(me, RIPTIDE_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, RIPTIDE_1));
+                _heals[RIPTIDE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[RIPTIDE_1] = 0;
+
+            if (InitSpell(me, CHAIN_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, CHAIN_HEAL_1));
+                _heals[CHAIN_HEAL_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->Effects[0].CalcValue(me), HEAL, 0, {});
+            }
+            else
+                _heals[CHAIN_HEAL_1] = 0;
+        }
+
+    private:
+        //Totem system
+        struct BotTotemParam
+        {
+            BotTotemParam() : _effradius(0.f) {}
+            uint32 _type;
+            Position _pos;
+            float _effradius;
+        };
+
+        typedef std::pair<ObjectGuid /*guid*/, BotTotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 TotemTimer[MAX_TOTEMS];
+        //Wolves
+        ObjectGuid _wolves[MAX_WOLVES];
+        //Spells
+        uint32 CURE_TOXINS;
+        //Timers
+        uint32 TotemsCheckTimer;
+        uint32 HexyCheckTimer, EarthyCheckTimer, ShieldCheckTimer, BloodlustCheckTimer, MaelstromTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy;
+        bool maelUseUp;
+        uint32 mhEnchantExpireTimer, ohEnchantExpireTimer;
+        uint32 mhEnchant, ohEnchant;
+        bool needChooseMHEnchant, needChooseOHEnchant;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+
+        uint32 _getTotemsMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            Unit* cre;
+            uint32 sumonSpell;
+            uint32 baseId;
+            bool isTotem;
+            int8 mytype;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                //from totem aura extract base spell it could be summoned by
+                if (itr->second->GetBase()->GetType() != UNIT_AURA_TYPE) continue;
+                cre = itr->second->GetBase()->GetUnitOwner();
+                //DEBUG
+                //uint32 base = cre->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+                //if (base)
+                //    baseId = sSpellMgr->GetSpellInfo(base)->GetFirstRankSpell()->Id;
+                //if (target->GetEntry() == 70025 && cre->GetGUID() != me->GetGUID())
+                //{
+                //    TC_LOG_ERROR("spells","totemMask: unit %s, %s (%u), owner %s (crSp %u, base %u), istotem %u", target->GetName().c_str(),
+                //        itr->second->GetBase()->GetSpellInfo()->SpellName[0], itr->second->GetBase()->GetId(),
+                //        cre ? cre->GetName().c_str() : "unk", base, baseId, uint32(cre->IsTotem()));
+                //}
+                sumonSpell = cre ? cre->GetUInt32Value(UNIT_CREATED_BY_SPELL) : 0;
+                if (!sumonSpell || !cre->IsTotem())
+                    continue;
+
+                isTotem = true;
+                baseId = sSpellMgr->GetSpellInfo(sumonSpell)->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    case FIRE_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_FIRE;     mytype = T_WATER;   break;
+                    case FROST_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_FROST;    mytype = T_FIRE;    break;
+                    case NATURE_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_NATURE;   mytype = T_AIR;     break;
+                    case FLAMETONGUE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_FLAMETONGUE;         mytype = T_FIRE;    break;
+                    case GROUNDING_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_GROUNDING;           mytype = T_AIR;     break;
+                    //case STONESKIN_TOTEM_1:
+                    //    mask |= BOT_TOTEM_MASK_STONESKIN;           mytype = T_EARTH;   break;
+                    case STRENGTH_OF_EARTH_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_STRENGTH_OF_EARTH;   mytype = T_EARTH;   break;
+                    case WINDFURY_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_WINDFURY;            mytype = T_AIR;     break;
+                    case WRATH_OF_AIR_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_WRATH_OF_AIR;        mytype = T_AIR;     break;
+                    case MANA_SPRING_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_MANA_SPRING;         mytype = T_WATER;   break;
+                    case TOTEM_OF_WRATH_1:
+                        mask |= BOT_TOTEM_MASK_WRATH;               mytype = T_FIRE;    break;
+                    default:
+                        isTotem = false; //next aura
+                        break;
+                }
+
+                if (isTotem)
+                {
+                    idMap[baseId] = sumonSpell;
+                    for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                    {
+                        if (itr->second->GetBase()->GetCasterGUID() == me->m_SummonSlot[i+1])
+                        {
+                            //mask |= BOT_TOTEM_MASK_MY_TOTEM;
+                            switch (mytype)
+                            {
+                                case T_FIRE:    mask |= BOT_TOTEM_MASK_MY_TOTEM_FIRE;   break;
+                                case T_EARTH:   mask |= BOT_TOTEM_MASK_MY_TOTEM_EARTH;  break;
+                                case T_WATER:   mask |= BOT_TOTEM_MASK_MY_TOTEM_WATER;  break;
+                                case T_AIR:     mask |= BOT_TOTEM_MASK_MY_TOTEM_AIR;    break;
+                                default:                                                break;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp b/src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp
new file mode 100644
index 0000000..dbfaf3a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp
@@ -0,0 +1,552 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+//#include "GridNotifiers.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+/*
+Spell Breaker NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Spellbreaker (Warcraft III tribute)
+Abilities:
+1) Steal Magic (Spellsteal). steals a benefical spell from an enemy and applies it to a nearby ally or removes a
+negative spell from an ally and applies it to a nearby enemy, affects magic and curse effects, 3 seconds cooldown.
+2) Control Magic NIY (no substitute for spell)
+3) Feedback (passive). Successful melee attacks burn target's mana equal to damage caused, dealing arcane damage
+Complete - 67%
+TODO:
+*/
+
+enum SpellbreakerBaseSpells
+{
+    SPELLSTEAL_1            = SPELL_STEAL_MAGIC
+};
+enum SpellbreakerPassives
+{
+};
+enum SpellbreakerSpecial
+{
+    SPELLSTEAL_COST         = 75 * 5,
+
+    FEEDBACK_EFFECT         = SPELL_FEEDBACK,
+
+    MH_ATTACK_VISUAL        = SPELL_ATTACK_MELEE_1H,
+    SPELLSTEAL_VISUAL       = 34396 //Zap selfcast
+};
+
+class spellbreaker_bot : public CreatureScript
+{
+public:
+    spellbreaker_bot() : CreatureScript("spellbreaker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new spellbreaker_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct spellbreaker_botAI : public bot_ai
+    {
+        spellbreaker_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SPELLBREAKER;
+
+            //spellbreaker immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { /*UnsummonAll();*/ bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < SPELLSTEAL_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            if ((me->GetVictim() || Rand() < 15) && IsSpellReady(SPELLSTEAL_1, diff))
+                CureGroup(GetSpell(SPELLSTEAL_1), diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckDispel(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsMelee());
+
+            MoveBehind(opponent);
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting())
+                return;
+
+            Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(SPELLSTEAL_1));
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                return;
+
+            SetSpellCooldown(SPELLSTEAL_1, 500); //fail
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            float pctbonus = 1.0f;
+
+            if (damageinfo.Target && damageinfo.Target->GetPowerType() == POWER_MANA && damageinfo.Target->GetMaxPower(POWER_MANA) > 1 &&
+                damageinfo.Target->GetPower(POWER_MANA) < me->GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE))
+            {
+                pctbonus *= 3.f;
+                if (_doCrit == false && urand(1,100) < 2 * GetBotCritChance())
+                    const_cast<spellbreaker_botAI*>(this)->_doCrit = true;
+            }
+            else if (_doCrit == true)
+                const_cast<spellbreaker_botAI*>(this)->_doCrit = false;
+
+            damageinfo.Damages[0].Damage *= pctbonus;
+        }
+
+        void ApplyClassEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            //Feedback scaling: 50%
+            if (baseId == FEEDBACK_EFFECT && effIndex == EFFECT_0)
+                value += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.5f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            value = value * pctbonus;
+        }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const override
+        {
+            return _doCrit ? MELEE_HIT_CRIT : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == FEEDBACK_EFFECT)
+                me->CastSpell(me, MH_ATTACK_VISUAL, true);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == SPELLSTEAL_1)
+                ProcessSpellsteal(target);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Feedback
+            if (damage && victim != me && damageType == DIRECT_DAMAGE && victim->GetPowerType() == POWER_MANA)
+            {
+                if (uint32 burned = std::min<uint32>(victim->GetPower(POWER_MANA), damage + me->GetLevel() * 2))
+                {
+                    int32 basepoints = int32(burned);
+                    //reduce amount againts ex bots
+                    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotClass() >= BOT_CLASS_EX_START)
+                        basepoints /= 10;
+
+                    CastSpellExtraArgs args(true);
+                    args.AddSpellBP0(basepoints);
+                    me->CastSpell(victim, FEEDBACK_EFFECT, args);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            _doCrit = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 /*diff*/) override
+        {
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(SPELLSTEAL_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case SPELLSTEAL_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+
+        bool _doCrit;
+
+        void ProcessSpellsteal(Unit* target)
+        {
+            DispelChargesList steal_list;
+
+            bool const isFriend = IsInBotParty(target) || target->IsFriendlyTo(me);
+            static const uint32 sbDispelMask  = (1<<DISPEL_MAGIC) | (1<<DISPEL_CURSE);
+            static const uint8 max_dispelled = 1;
+
+            //TC_LOG_ERROR("entities.unit", "ProcessSpellsteal: on %s, fr=%u", target->GetName().c_str(), uint32(isFriend));
+
+            Unit::AuraMap const& auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+            {
+                Aura* aura = itr->second;
+
+                if (aura->IsPassive() || !(aura->GetSpellInfo()->GetDispelMask() & sbDispelMask) ||
+                    (aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE))
+                    continue;
+
+                AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                if (!aurApp)
+                    continue;
+
+                //do not dispel positive auras from enemies and negative ones from friends
+                if (aurApp->IsPositive() == isFriend)
+                    continue;
+
+                int32 chance = aura->CalcDispelChance(target, !isFriend);
+                if (!chance)
+                    continue;
+                //TC_LOG_ERROR("entities.unit", "%s", aura->GetSpellInfo()->SpellName[0]);
+
+                // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+                // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+                // Polymorph instead of 1 / (5 + 1) -> 16%.
+                bool dispel_charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES);
+                uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+                if (charges > 0)
+                    steal_list.emplace_back(aura, chance, charges);
+            }
+
+            if (steal_list.empty())
+                return;
+
+            //TC_LOG_ERROR("entities.unit", "failcount...");
+
+            size_t remaining = steal_list.size();
+            uint32 failCount = 0;
+            DispelChargesList success_list;
+            success_list.reserve(max_dispelled);
+            WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+max_dispelled*4);
+            // dispel N = damage buffs (or while exist buffs for dispel)
+            for (uint8 count = 0; count < max_dispelled && remaining > 0;)
+            {
+                // Random select buff for dispel
+                DispelChargesList::iterator itr = steal_list.begin();
+                std::advance(itr, urand(0, steal_list.size() - 1));
+
+                //int32 chance = itr->RollDispel();//itr->first->CalcDispelChance(target, !isFriend);
+                // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
+                //if (!chance)
+                //{
+                //    steal_list.erase(itr);
+                //    continue;
+                //}
+                //else
+                bool chance = itr->RollDispel();
+                {
+                    if (chance/*roll_chance_i(chance)*/)
+                    {
+                        auto successItr = std::find_if(success_list.begin(), success_list.end(), [&itr](DispelableAura& dispelAura) -> bool
+                        {
+                            if (dispelAura.GetAura()->GetId() == itr->GetAura()->GetId() && dispelAura.GetAura()->GetCaster() == itr->GetAura()->GetCaster())
+                                return true;
+                            return false;
+                        });
+
+                        if (successItr == success_list.end())
+                            success_list.emplace_back(itr->GetAura(), 0, 1);
+                        else
+                            successItr->IncrementCharges();
+
+                        if (!itr->DecrementCharge())
+                        {
+                            --remaining;
+                            std::swap(*itr, steal_list[remaining]);
+                        }
+                        //success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
+                        //--itr->second;
+                        //if (itr->second <= 0)
+                        //    steal_list.erase(itr);
+                    }
+                    else
+                    {
+                        if (!failCount)
+                        {
+                            // Failed to dispell
+                            dataFail << uint64(me->GetGUID());                  // Caster GUID
+                            dataFail << uint64(target->GetGUID());              // Victim GUID
+                            dataFail << uint32(SPELLSTEAL_1);                   // dispel spell id
+                        }
+                        ++failCount;
+                        dataFail << uint32(itr->GetAura()->GetId());                // Spell Id
+                    }
+                    ++count;
+                }
+            }
+
+            if (failCount)
+                me->SendMessageToSet(&dataFail, true);
+
+            if (success_list.empty())
+                return;
+
+            //TC_LOG_ERROR("entities.unit", "logs and auras");
+
+            WorldPacket dataSuccess(SMSG_SPELLSTEALLOG, 8+8+4+1+4+max_dispelled*5);
+            dataSuccess << target->GetPackGUID();           // Victim GUID
+            dataSuccess << me->GetPackGUID();               // Caster GUID
+            dataSuccess << uint32(SPELLSTEAL_1);            // dispel spell id
+            dataSuccess << uint8(0);                        // not used
+            dataSuccess << uint32(success_list.size());     // count
+
+            Unit* randomTarget = nullptr;
+
+            std::list<Unit*> targets;
+
+            if (isFriend) //negative spell from friend to enemy
+            {
+                GetNearbyTargetsList(targets, 50, 0);
+                if (Unit* u = me->GetVictim())
+                {
+                    if (!u->GetVictim() && me->IsWithinDistInMap(u, 50) && !me->IsFriendlyTo(u) &&
+                        me->IsValidAttackTarget(u) && u->GetCreatureType() != CREATURE_TYPE_CRITTER && !u->IsTotem() &&
+                        me->CanSeeOrDetect(u))
+                        targets.push_back(u);
+                }
+                //Trinity::AnyUnfriendlyAttackableVisibleUnitInObjectRangeCheck check(me, 50.f);
+                //Trinity::UnitListSearcher<Trinity::AnyUnfriendlyAttackableVisibleUnitInObjectRangeCheck> searcher(me, targets, check);
+                //me->VisitNearbyObject(50.f, searcher);
+            }
+            else
+            {
+                GetNearbyFriendlyTargetsList(targets, 50); //not self
+                targets.push_back(me); //add self
+            }
+
+            if (!targets.empty())
+            {
+                //if target has stealed aura we should skip him if possible
+                std::list<Unit*> targetsCopy = targets;
+                targets.remove_if(BOTAI_PRED::AuraedTargetExclude(success_list.front().GetAura()->GetId()));
+
+                randomTarget = Trinity::Containers::SelectRandomContainerElement(!targets.empty() ? targets : targetsCopy);
+            }
+
+            for (DispelChargesList::iterator itr = success_list.begin(); itr != success_list.end(); ++itr)
+            {
+                dataSuccess << uint32(itr->GetAura()->GetId());          // Spell Id
+                dataSuccess << uint8(0);                    // 0 - steals !=0 transfers
+
+                if (randomTarget)
+                {
+                    //target->RemoveAurasDueToSpellBySteal(itr->first, itr->second, randomTarget);
+                    TransferAura(itr->GetAura()->GetId(), itr->GetAura()->GetCasterGUID(), target, randomTarget);
+                    randomTarget->CastSpell(randomTarget, SPELLSTEAL_VISUAL, true);
+                }
+                else
+                    target->RemoveAurasDueToSpellByDispel(itr->GetAura()->GetId(), SPELLSTEAL_1, itr->GetAura()->GetCasterGUID(), me, uint8(-1));
+            }
+
+            me->SendMessageToSet(&dataSuccess, true);
+        }
+
+        void TransferAura(uint32 spellId, ObjectGuid casterGUID, Unit* target, Unit* newTarget)
+        {
+            //Copied from Unit::RemoveAurasDueToSpellBySteal with modifications
+            Unit::AuraMapBoundsNonConst range = target->GetOwnedAuras().equal_range(spellId);
+            for (Unit::AuraMap::iterator iter = range.first; iter != range.second;)
+            {
+                Aura* aura = iter->second;
+                if (aura->GetCasterGUID() == casterGUID)
+                {
+                    int32 damage[MAX_SPELL_EFFECTS];
+                    int32 baseDamage[MAX_SPELL_EFFECTS];
+                    uint8 effMask = 0;
+                    uint8 recalculateMask = 0;
+                    Unit* caster = aura->GetCaster();
+                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                    {
+                        if (aura->GetEffect(i))
+                        {
+                            baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();
+                            damage[i] = aura->GetEffect(i)->GetAmount();
+                            effMask |= (1<<i);
+                            if (aura->GetEffect(i)->CanBeRecalculated())
+                                recalculateMask |= (1<<i);
+                        }
+                        else
+                        {
+                            baseDamage[i] = 0;
+                            damage[i] = 0;
+                        }
+                    }
+
+                    bool stealCharge = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES);
+                    // Limit max duration to 5 minutes
+                    int32 dur = std::min<int32>(int32(5 * MINUTE * IN_MILLISECONDS), aura->GetDuration());
+                    // But at least for 5 seconds
+                    dur = std::max<int32>(dur, 5 * IN_MILLISECONDS);
+
+                    if (Aura* oldAura = newTarget->GetAura(aura->GetId(), aura->GetCasterGUID()))
+                    {
+                        if (stealCharge)
+                            oldAura->ModCharges(aura->GetCharges());
+                        else
+                            oldAura->ModStackAmount(aura->GetStackAmount());
+                        oldAura->SetDuration(std::max<int32>(dur, oldAura->GetDuration()));
+                    }
+                    else
+                    {
+                        // single target state must be removed before aura creation to preserve existing single target aura
+                        if (aura->IsSingleTarget())
+                            aura->UnregisterSingleTarget();
+
+                        AuraCreateInfo createInfo(aura->GetSpellInfo(), effMask, newTarget);
+                        createInfo.SetCasterGUID(aura->GetCasterGUID());
+                        createInfo.SetBaseAmount(baseDamage);
+                        if (Aura* newAura = Aura::TryRefreshStackOrCreate(createInfo))
+                        {
+                            // created aura must not be single target aura,, so stealer won't loose it on recast
+                            if (newAura->IsSingleTarget())
+                            {
+                                newAura->UnregisterSingleTarget();
+                                aura->SetIsSingleTarget(true);
+                                caster->GetSingleCastAuras().push_back(aura);
+                            }
+                            newAura->SetLoadedState(aura->GetMaxDuration(), dur, aura->GetCharges(), aura->GetStackAmount(), recalculateMask, aura->GetCritChance(), aura->CanApplyResilience(), &damage[0]);
+                            newAura->ApplyForTargets();
+                        }
+                    }
+
+                    aura->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+                    return;
+                }
+                else
+                    ++iter;
+            }
+        }
+    };
+};
+
+void AddSC_spellbreaker_bot()
+{
+    new spellbreaker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_sphynx_ai.cpp b/src/server/game/AI/NpcBots/bot_sphynx_ai.cpp
new file mode 100644
index 0000000..b0fb64b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_sphynx_ai.cpp
@@ -0,0 +1,574 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "ScriptMgr.h"
+/*
+Obsidian Destroyer NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Obsidian winged monstrocity with unsatable hunger for magic (Warcraft III tribute)
+Specifics:
+High armor, very high resistances, partially immune to magic, negative mana regeneration (-2%/sec, cannot be changed),
+any armor, dual-wielding wands, no physical attack, spellpower = 50% attack power + 200% intellect
+Abilities:
+1) Devour Magic: dispel up to 2 magic effects from enemies, up to 2 magic effects and up to 2 curses from allies
+and damaging summoned units in 20 yards area, every dispelled effect restores 20% mana and 5% health, 7 seconds cooldown
+2) Shadow Bolt: main attack, single target, no mana cost
+3) Shadow Blast: 125 mana empowered attack, splash damage (6.25% of base mana)
+4) Shadow Armor (passive, custom): restores mana equal to a percentage of damage taken
+5) Drain Mana: leech all mana from a friendly target (up to 100% of od's max mana)
+6) Replenish Mana: restores 2% of max mana to up to 10 surrounding allies within 25yds at cost of all mana
+7) Replenish Life: restores 3% of max hp to up to 10 surrounding allies within 25yds at cost of all mana
+Complete - 100%
+TODO:
+*/
+
+enum SphynxBaseSpells
+{
+    MAIN_ATTACK_1           = SPELL_SHADOW_BOLT,
+    SPLASH_ATTACK_1         = SPELL_SHADOW_BLAST,
+    DEVOUR_MAGIC_1          = SPELL_DEVOUR_MAGIC,
+    DRAIN_MANA_1            = SPELL_DRAIN_MANA,
+
+    REPLENISH_MANA_1        = SPELL_REPLENISH_MANA,
+    REPLENISH_HEALTH_1      = SPELL_REPLENISH_HEALTH
+};
+enum SphynxPassives
+{
+};
+enum SphynxSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+    MH_OH_ATTACK_ANIM       = SPELL_ATTACK_MELEE_RANDOM,
+    SPELL_ENERGIZE          = 34424,//"Shadow Armor"
+
+    SPLASH_ATTACK_COST      = BASE_MANA_SPHYNX/16//6.25%
+};
+
+class sphynx_bot : public CreatureScript
+{
+public:
+    sphynx_bot() : CreatureScript("sphynx_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new sphynx_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct sphynx_botAI : public bot_ai
+    {
+        sphynx_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SPHYNX;
+
+            //sphynx immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_BLOCK_SPELL_FAMILY, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BLEED, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INFECTED, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INTERRUPT, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { dmgReceived = 0; DraincheckTimer = 2000; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { dmgReceived = 0; bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            CheckDevourMagic(diff);
+
+            if (IsSpellReady(DEVOUR_MAGIC_1, diff))
+                CureGroup(DEVOUR_MAGIC_1, diff);
+
+            //if (!me->IsInCombat())
+            //    DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            CheckReplenishHealth(diff);
+            CheckReplenishMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            CheckDrainMana(diff);
+
+            MoveBehind(opponent);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (GC_Timer > diff)
+                return;
+
+            if (me->GetDistance(opponent) > 20)
+                return;
+
+            if (me->isMoving() && !me->HasInArc(M_PI/2, opponent))
+                return;
+
+            if (me->GetPower(POWER_MANA) >= SPLASH_ATTACK_COST)
+            {
+                if (IsSpellReady(SPLASH_ATTACK_1, diff))
+                {
+                    if (doCast(opponent, GetSpell(SPLASH_ATTACK_1)))
+                        return;
+                }
+            }
+            else if (IsSpellReady(MAIN_ATTACK_1, diff))
+            {
+                if (doCast(opponent, GetSpell(MAIN_ATTACK_1)))
+                    return;
+            }
+        }
+
+        void CheckDevourMagic(uint32 diff)
+        {
+            if (DevourcheckTimer > diff || !IsSpellReady(DEVOUR_MAGIC_1, diff, false) || IsCasting() ||
+                (GetHealthPCT(me) > 75 && Rand() > 15 &&
+                (!HasRole(BOT_ROLE_DPS) || me->GetPower(POWER_MANA) >= SPLASH_ATTACK_COST * 6)))
+                return;
+
+            DevourcheckTimer = urand(350, 700);
+
+            Unit* target = FindHostileDispelTarget(40);
+            if (target && doCast(target, GetSpell(DEVOUR_MAGIC_1)))
+                return;
+        }
+
+        void CheckDrainMana(uint32 diff)
+        {
+            if (DraincheckTimer > diff || Rand() < 40 || IAmFree() || !HasRole(BOT_ROLE_DPS) || IsCasting() ||
+                !IsSpellReady(DRAIN_MANA_1, diff, false) || me->GetPower(POWER_MANA) >= SPLASH_ATTACK_COST)
+                return;
+
+            DraincheckTimer = urand(750, 1500);
+
+            std::list<Unit*> targets;
+            GetNearbyFriendlyTargetsList(targets, 40);
+            targets.remove_if(BOTAI_PRED::DrainTargetExclude());
+
+            if (targets.empty())
+                return;
+
+            Unit* target = Trinity::Containers::SelectRandomContainerElement(targets);
+            if (doCast(target, GetSpell(DRAIN_MANA_1)))
+                return;
+        }
+
+        void CheckReplenishHealth(uint32 diff)
+        {
+            if (ReplHealthcheckTimer > diff || !IsSpellReady(REPLENISH_HEALTH_1, diff) || IAmFree() ||
+                !HasRole(BOT_ROLE_HEAL) || IsCasting() ||
+                (HasRole(BOT_ROLE_DPS) && me->GetPower(POWER_MANA) > 0))
+                return;
+
+            ReplHealthcheckTimer = 1000;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                return;
+
+            bool haveHp = false;
+            uint8 partycombat = 0, partynocombat = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsInCombat())
+                    partycombat++;
+                else if (player->IsAlive())
+                    partynocombat++;
+
+                if (!haveHp && player->IsAlive() && me->GetDistance(player) < 15 &&
+                    GetHealthPCT(player) < 95)
+                    haveHp = true;
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (!bot->IsInWorld())
+                        continue;
+
+                    if (bot->IsInCombat())
+                        partycombat++;
+                    else if (bot->IsAlive())
+                        partynocombat++;
+
+                    if (!haveHp && bot != me && bot->IsInWorld() && bot->IsAlive() && me->GetDistance(bot) < 15 &&
+                        GetHealthPCT(bot) < 95)
+                        haveHp = true;
+                }
+            }
+
+            if (haveHp && (!me->IsInCombat() || partycombat > partynocombat) &&
+                doCast(me, GetSpell(REPLENISH_HEALTH_1)))
+                return;
+        }
+
+        void CheckReplenishMana(uint32 diff)
+        {
+            if (ReplManacheckTimer > diff || !IsSpellReady(REPLENISH_MANA_1, diff) || IAmFree() || IsCasting() ||
+                (HasRole(BOT_ROLE_DPS) && me->GetPower(POWER_MANA) > 0))
+                return;
+
+            ReplManacheckTimer = 1000;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                return;
+
+            bool haveMana = false;
+            uint8 partycombat = 0, partynocombat = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsInCombat())
+                    partycombat++;
+                else if (player->IsAlive())
+                    partynocombat++;
+
+                if (!haveMana && player->IsAlive() && me->GetDistance(player) < 15 &&
+                    GetManaPCT(player) < 95)
+                    haveMana = true;
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (!bot->IsInWorld())
+                        continue;
+
+                    if (bot->IsInCombat())
+                        partycombat++;
+                    else if (bot->IsAlive())
+                        partynocombat++;
+
+                    if (!haveMana && bot->IsInWorld() && bot->IsAlive() && me->GetDistance(bot) < 15 &&
+                        bot->GetBotClass() != BOT_CLASS_SPHYNX &&
+                        GetManaPCT(bot) < 95)
+                        haveMana = true;
+                }
+            }
+
+            if (haveMana && (!me->IsInCombat() || partycombat > partynocombat) &&
+                doCast(me, GetSpell(REPLENISH_MANA_1)))
+                return;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (crit)
+                pctbonus *= 1.333f;
+
+            if (baseId == MAIN_ATTACK_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->Effects[0].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            if (baseId == SPLASH_ATTACK_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->Effects[1].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        //void ApplyClassEffectMods(Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value) const
+        //{
+        //    uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+        //    uint8 lvl = me->getLevel();
+        //    float pctbonus = 1.0f;
+
+        //    //Drain Mana: limits
+        //    if (baseId == DRAIN_MANA_1 && target/* && effIndex == EFFECT_0*/)
+        //        value = std::min<uint32>(me->GetMaxPower(POWER_MANA), target->GetMaxPower(POWER_MANA));
+
+        //    value = value * pctbonus;
+        //}
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == SPLASH_ATTACK_1 || baseId == DEVOUR_MAGIC_1 ||
+                baseId == DRAIN_MANA_1 || baseId == REPLENISH_MANA_1 || baseId == REPLENISH_HEALTH_1)
+                GC_Timer = me->GetAttackTime(BASE_ATTACK);
+
+            if (baseId == SPLASH_ATTACK_1)
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+            else if (baseId == MAIN_ATTACK_1)
+                me->CastSpell(me, MH_OH_ATTACK_ANIM, true);
+
+            if (baseId == DEVOUR_MAGIC_1)
+            {
+                me->CastSpell(me, MH_OH_ATTACK_ANIM, true);
+
+                if (dispelsDealt > 0)
+                {
+                    //gain 20% of max mana and 5% of max health for every dispel
+                    int32 manaGain = me->GetMaxPower(POWER_MANA)/5 * dispelsDealt;
+                    uint32 healthGain = me->GetMaxHealth() / 20 * dispelsDealt;
+
+                    HealInfo hinfo(me, me, healthGain, spellInfo, spellInfo->GetSchoolMask());
+
+                    me->EnergizeBySpell(me, DEVOUR_MAGIC_1, manaGain, POWER_MANA);
+                    me->HealBySpell(hinfo);
+
+                    me->CastSpell(me, SPELL_DEVOUR_MAGIC_CASTER_IMPACT, true);
+                }
+
+                dispelsDealt = 0;
+            }
+
+            if (baseId == DRAIN_MANA_1)
+                me->CastSpell(me, MH_OH_ATTACK_ANIM, true);
+
+            if (baseId == REPLENISH_MANA_1)
+                me->SendPlaySpellVisual(425); //arcane cast omni
+            if (baseId == REPLENISH_HEALTH_1)
+                me->SendPlaySpellVisual(21); //empty cast finish anim
+
+            if (baseId == REPLENISH_MANA_1 || baseId == REPLENISH_HEALTH_1)
+                me->SetPower(POWER_MANA, 0);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            if (blastVisualTimer < GetLastDiff() && spellId == SPLASH_ATTACK_1)
+            {
+                blastVisualTimer = 500;
+                me->CastSpell(*target, SHADOWFURY_VISUAL, true);
+            }
+            //Devour Magic: damage to summons
+            if (spellId == DEVOUR_MAGIC_1 && target->IsSummon() && target->GetUInt32Value(UNIT_CREATED_BY_SPELL) &&
+                !target->IsTotem() && me->GetReactionTo(target) <= REP_NEUTRAL)
+            {
+                SpellInfo const* devInfo = sSpellMgr->GetSpellInfo(spellId);
+                uint32 damage = std::min<uint32>(target->GetMaxHealth() / 2, me->GetMaxHealth() / 5 + me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+                Unit::DealDamage(me, target, damage, nullptr, SPELL_DIRECT_DAMAGE, devInfo->GetSchoolMask(), devInfo);
+                OnBotDispelDealt(target, 1);
+            }
+
+            if (spellId == DRAIN_MANA_1)
+            {
+                me->CastSpell(target, SPELL_DEVOUR_MAGIC_BEAM, true);
+                target->SendPlaySpellVisual(419); //drain impact visual
+            }
+            if (spellId == REPLENISH_MANA_1)
+                if (target != me)
+                    target->SendPlaySpellVisual(524/*436*/); //mana gain visual//heal bigger crimson ish
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDispelDealt(Unit* dispelled, uint8 num) override
+        {
+            //cast drain visual on dispelled
+            if (me != dispelled)
+            {
+                me->CastSpell(dispelled, SPELL_DEVOUR_MAGIC_BEAM, true);
+                dispelled->SendPlaySpellVisual(357/*317*/); //purge visual
+            }
+
+            dispelsDealt += num;
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage) override
+        {
+            if (damage)
+            {
+                dmgReceived += damage / 10;
+                uint32 energizeThreshold = me->GetMaxPower(POWER_MANA) / 10;
+
+                int32 manaGain = 0;
+                while (dmgReceived >= energizeThreshold)
+                {
+                    manaGain += energizeThreshold;
+                    dmgReceived -= energizeThreshold;
+                }
+                if (manaGain)
+                    me->EnergizeBySpell(me, SPELL_ENERGIZE, manaGain, POWER_MANA);
+            }
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void CheckAttackState() override
+        {
+        }
+
+        void Reset() override
+        {
+            blastVisualTimer = 0;
+            DevourcheckTimer = 0;
+            DraincheckTimer = 0;
+            ReplManacheckTimer = 0;
+            ReplHealthcheckTimer = 0;
+
+            dmgReceived = 0;
+            dispelsDealt = 0;
+
+            DefaultInit();
+
+            me->SetPower(POWER_MANA, 0);
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (blastVisualTimer > diff)            blastVisualTimer -= diff;
+            if (DevourcheckTimer > diff)            DevourcheckTimer -= diff;
+            if (DraincheckTimer > diff)             DraincheckTimer -= diff;
+            if (ReplManacheckTimer > diff)          ReplManacheckTimer -= diff;
+            if (ReplHealthcheckTimer > diff)        ReplHealthcheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(MAIN_ATTACK_1, true, false);
+            InitSpellMap(SPLASH_ATTACK_1, true, false);
+            InitSpellMap(DEVOUR_MAGIC_1, true, false);
+            InitSpellMap(DRAIN_MANA_1, true, false);
+
+            InitSpellMap(REPLENISH_MANA_1, true, false);
+            InitSpellMap(REPLENISH_HEALTH_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case DEVOUR_MAGIC_1:
+                case DRAIN_MANA_1:
+                case REPLENISH_MANA_1:
+                case REPLENISH_HEALTH_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 blastVisualTimer;
+        uint32 DevourcheckTimer, DraincheckTimer, ReplManacheckTimer, ReplHealthcheckTimer;
+
+        uint32 dmgReceived;
+        uint8 dispelsDealt;
+    };
+};
+
+void AddSC_sphynx_bot()
+{
+    new sphynx_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..b53280d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,1950 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Warlock NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 85%
+TODO: rituals (not directly feasable), demonic circle, demonic empowerment, demonic pact, health funnel, healthstones for bots, etc...
+*/
+
+enum WarlockBaseSpells
+{
+    CURSE_OF_WEAKNESS_1                 = 702,
+    CURSE_OF_AGONY_1                    = 980,
+    CURSE_OF_TONGUES_1                  = 1714,
+    CURSE_OF_EXHAUSTION_1               = 18223,
+    CURSE_OF_THE_ELEMENTS_1             = 1490,
+    CURSE_OF_DOOM_1                     = 603,//NI
+    SHADOW_BOLT_1                       = 686,
+    IMMOLATE_1                          = 348,
+    CORRUPTION_1                        = 172,
+    SEED_OF_CORRUPTION_1                = 27243,
+    INCINERATE_1                        = 29722,
+    SEARING_PAIN_1                      = 5676,
+    SHADOWBURN_1                        = 17877,
+    CONFLAGRATE_1                       = 17962,
+    SOUL_FIRE_1                         = 6353,
+    CHAOS_BOLT_1                        = 50796,
+    RAIN_OF_FIRE_1                      = 5740,
+    HELLFIRE_1                          = 1949,
+    SHADOWFLAME_1                       = 47897,
+    SHADOWFURY_1                        = 30283,
+    HAUNT_1                             = 48181,
+    UNSTABLE_AFFLICTION_1               = 30108,//NI
+    FEAR_1                              = 5782,
+    HOWL_OF_TERROR_1                    = 5484,
+    DEATH_COIL_1                        = 6789,
+    SOULSHATTER_1                       = 29858,
+
+    DRAIN_SOUL_1                        = 1120,
+    DRAIN_MANA_1                        = 5138,
+    BANISH_1                            = 710,
+
+    DEMON_SKIN_1                        = 687,
+    DEMON_ARMOR_1                       = 706,
+    FEL_ARMOR_1                         = 28176,
+    DETECT_INVISIBILITY_1               = 132,
+    UNENDING_BREATH_1                   = 5697,
+    SHADOW_WARD_1                       = 6229,
+    LIFE_TAP_1                          = 1454,
+    DARK_PACT_1                         = 18220,
+
+    CREATE_HEALTHSTONE_1                = 6201,
+    CREATE_SOULSTONE_1                  = 693,
+
+    CHAOTIC_MIND                        = 61188, //8 sec duration, no cd
+
+    RITUAL_OF_SUMMONING_1               = 698,
+    RITUAL_OF_SOULS_1                   = 29893
+};
+enum WarlockPassives
+{
+    IMPROVED_SHADOW_BOLT                = 17803,//rank 5
+    IMPROVED_DRAIN_SOUL                 = 18372,//rank 2
+    SOUL_SIPHON                         = 17805,//rank 2
+    AFTERMATH                           = 18120,//rank 2
+    IMPROVED_FEAR                       = 53759,//rank 2
+    NIGHTFALL                           = 18095,//rank 2
+    SHADOW_EMBRACE                      = 32394,//rank 5
+    SIPHON_LIFE                         = 63108,
+    BACKLASH                            = 34939,//rank 3
+    MOLTEN_CORE                         = 47247,//rank 3
+    NETHER_PROTECTION                   = 30302,//rank 3
+    ERADICATION                         = 47197,//rank 3
+    DEMONIC_RESILIENCE                  = 30321,//rank 3
+    SOUL_LEECH                          = 30296,//rank 3
+    PYROCLASM                           = 63245,//rank 3
+    DECIMATION                          = 63158,//rank 2
+    IMPROVED_SOUL_LEECH                 = 54118,//rank 2
+    PANDEMIC                            = 58435,
+    BACKDRAFT                           = 47260,//rank 3
+    EVERLASTING_AFFLICTION              = 47205,//rank 5
+
+    //Special
+    GLYPH_CORRUPTION                    = 56218,
+    GLYPH_FEAR                          = 56244,
+    GLYPH_QUICK_DECAY                   = 70947,
+    GLYPH_CONFLAGRATE                   = 56235,
+    GLYPH_SHADOWFLAME                   = 63310
+};
+
+enum WarlockSpecial
+{
+    CHAOS_BOLT_PASSIVE                  = 58284,
+    DEMONIC_IMMOLATE_PASSIVE            = 75445,
+
+    BACKLASH_BUFF                       = 34936,
+    BACKDRAFT_BUFF                      = 54277,//rank 3
+    SHADOW_TRANCE_BUFF                  = 17941,
+    MOLTEN_CORE_BUFF                    = 71165,//rank 3
+    DECIMATION_BUFF                     = 63167,//rank 2
+    CHAOTIC_MIND_BUFF                   = 61189,// "Soul Fire!" 6 sec duration Soul Fire instant cast
+
+    SHADOW_MASTERY_DEBUFF               = 17800,// Improved Shadow Bolt talent debuff
+
+    SIPHON_LIFE_HEAL                    = 63106,
+    LIFE_TAP_ENERGIZE                   = 31818,
+
+    SEED_OF_CORRUPTION_FINAL_DAMAGE_1   = 27285,
+
+    SOULSTONE_RESURRECTION_1            = 20707,
+    SOULSTONE_RESURRECTION_2            = 20762,
+    SOULSTONE_RESURRECTION_3            = 20763,
+    SOULSTONE_RESURRECTION_4            = 20764,
+    SOULSTONE_RESURRECTION_5            = 20765,
+    SOULSTONE_RESURRECTION_6            = 27239,
+    SOULSTONE_RESURRECTION_7            = 47883,
+
+    BLOOD_PACT_1                        = 6307,
+    FEL_INTELLIGENCE_1                  = 54424,
+
+    SOUL_LINK_PET                       = 25228,//split effect lvl 20 req
+    FEL_SYNERGY_HEAL                    = 54181,
+    LIFE_TAP_ENERGIZE_PET               = 32553
+};
+
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct warlock_botAI : public bot_ai
+    {
+        static uint32 const _healthStoneSpells[8/*createHealthstoneRank*/];
+
+        warlock_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARLOCK;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void JustEnteredCombat(Unit* u) override { canShadowWard = false; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            if (GetSpell(FEL_ARMOR_1) && !IsTank())
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 0x0, 0x20000000, 0x0)
+                    /*!HasAuraName(me, FEL_ARMOR_1)*/ &&
+                    doCast(me, GetSpell(FEL_ARMOR_1)))
+                    return;
+            }
+            else if (GetSpell(DEMON_ARMOR_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x20, 0x0)
+                    /*!HasAuraName(me, DEMON_ARMOR_1)*/ &&
+                    doCast(me, GetSpell(DEMON_ARMOR_1)))
+                    return;
+            }
+            else if (!GetSpell(FEL_ARMOR_1) && !GetSpell(DEMON_ARMOR_1) && GetSpell(DEMON_SKIN_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x0, 0x10)
+                    /*!HasAuraName(me, DEMON_SKIN_1)*/ &&
+                    doCast(me, GetSpell(DEMON_SKIN_1)))
+                    return;
+            }
+
+            if (me->GetVictim())
+                return;
+
+            if (!hasHealthstone && GetSpell(CREATE_HEALTHSTONE_1))
+            {
+                if (doCast(me, GetSpell(CREATE_HEALTHSTONE_1)))
+                    return;
+            }
+
+            if (!hasSoulstone && !IAmFree() && GetSpell(CREATE_SOULSTONE_1))
+            {
+                if (doCast(me, GetSpell(CREATE_SOULSTONE_1)))
+                    return;
+            }
+
+            if (GetSpell(DETECT_INVISIBILITY_1))
+            {
+                if (master->IsAlive() && !master->HasAuraType(SPELL_AURA_MOD_INVISIBILITY_DETECT) &&
+                    doCast(master, GetSpell(DETECT_INVISIBILITY_1)))
+                    return;
+            }
+
+            //TODO: soulstone on self/bots
+            //BUG: players cannot accept this buff if they are below lvl 20 (should be 8)
+            if (!IAmFree() && hasSoulstone && soulstoneTimer <= diff && GetSpell(CREATE_SOULSTONE_1))
+            {
+                Group const* gr = master->GetGroup();
+                Unit* u = master;
+                if (!gr)
+                {
+                    if (!u->IsAlive() || u->isPossessed() || u->IsCharmed() ||
+                        me->GetDistance(u) > 30 || u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        u = nullptr;
+                }
+                else
+                {
+                    //check rezzers first
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        u = itr->GetSource();
+                        if (!u || u->GetLevel() < 20 || !u->IsAlive() || me->GetMap() != u->FindMap() ||
+                            u->isPossessed() || u->IsCharmed() || me->GetDistance(u) > 30 ||
+                            u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        {
+                            u = nullptr;
+                            continue;
+                        }
+                        if (u->GetClass() == CLASS_PRIEST || u->GetClass() == CLASS_PALADIN ||
+                            u->GetClass() == CLASS_DRUID || u->GetClass() == CLASS_SHAMAN)
+                            break;
+                    }
+                    if (!u)
+                    {
+                        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            u = itr->GetSource();
+                            if (!u || u->GetLevel() < 20 || !u->IsAlive() || me->GetMap() != u->FindMap() ||
+                                u->isPossessed() || u->IsCharmed() || me->GetDistance(u) > 30 ||
+                                u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                            {
+                                u = nullptr;
+                                continue;
+                            }
+                            break;
+                        }
+                    }
+                }
+
+                if (u)
+                {
+                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(CREATE_SOULSTONE_1);
+                    uint32 rank = spellInfo->GetRank();
+
+                    while (rank < 7 && u->GetLevel() > spellInfo->SpellLevel && spellInfo->GetNextRankSpell())
+                    {
+                        spellInfo = spellInfo->GetNextRankSpell();
+                        rank = spellInfo->GetRank();
+                    }
+
+                    uint32 spellId;
+                    switch (spellInfo->Id)
+                    {
+                        case   693: spellId = SOULSTONE_RESURRECTION_1; break; //rank 1
+                        case 20752: spellId = SOULSTONE_RESURRECTION_2; break; //rank 2
+                        case 20755: spellId = SOULSTONE_RESURRECTION_3; break; //rank 3
+                        case 20756: spellId = SOULSTONE_RESURRECTION_4; break; //rank 4
+                        case 20757: spellId = SOULSTONE_RESURRECTION_5; break; //rank 5
+                        case 27238: spellId = SOULSTONE_RESURRECTION_6; break; //rank 6
+                        case 47884: spellId = SOULSTONE_RESURRECTION_7; break; //rank 7
+                        default:
+                            TC_LOG_ERROR("entities.player", "bot_warlockAI: unknown soulstone Id %u", spellInfo->Id);
+                            spellId = SOULSTONE_RESURRECTION_1;
+                            break;
+                    }
+                    me->CastSpell(u, spellId, false);
+                }
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+            fearTimer = std::max<uint32>(fearTimer, 1000);
+        }
+
+        //uint8 Afflicted(Unit* target) const
+        //{
+        //    if (!target || target->isDead()) return 0;
+        //    bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
+        //    bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
+        //    if (imm) return 1;
+        //    if (aff) return 2;
+        //    return 0;
+        //}
+
+        void CheckFear(uint32 diff)
+        {
+            if (fearTimer > diff || GC_Timer > diff || !me->IsInCombat() || IsTank() || IsCasting())
+                return;
+
+            fearTimer = 1600;
+
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (!FEAR)
+                return;
+
+            if (FindAffectedTarget(FEAR, me->GetGUID(), 70, 255))
+                return;
+
+            Unit* feartarget = FindFearTarget(CalcSpellMaxRange(FEAR_1));
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        void CheckBanish(uint32 diff)
+        {
+            if (banishTimer > diff || GC_Timer > diff || !me->IsInCombat() || IsTank() || IsCasting() || Rand() > 50)
+                return;
+
+            banishTimer = 1600;
+
+            uint32 BANISH = GetSpell(BANISH_1);
+            if (!BANISH)
+                return;
+
+            if (FindAffectedTarget(BANISH, me->GetGUID(), 70, 255))
+                return;
+
+            Unit* banishTarget = FindUndeadCCTarget(CalcSpellMaxRange(BANISH_1), BANISH_1);
+            if (banishTarget && doCast(banishTarget, BANISH))
+                return;
+        }
+
+        void CheckUnBanish(uint32 diff)
+        {
+            if (unbanishTimer > diff || GC_Timer > diff || me->GetVictim() || IsCasting() || Rand() > 30)
+                return;
+
+            unbanishTimer = 2000;
+
+            //we check only our spell rank which is enough in 99% cases
+            uint32 BANISH = GetSpell(BANISH_1);
+            if (!BANISH)
+                return;
+
+            //looks like you cannot dispel other people's banish
+            Unit* unbanishTarget = FindAffectedTarget(BANISH, me->GetGUID(), CalcSpellMaxRange(BANISH_1));
+            if (unbanishTarget && doCast(unbanishTarget, BANISH))
+                return;
+        }
+
+        void CheckDrainMana(uint32 diff)
+        {
+            if (drainManaTimer > diff || IsPotionReady() || !IsSpellReady(DRAIN_MANA_1, diff) ||
+                !me->getAttackers().empty() || IsTank() || IsCasting() || GetManaPCT(me) > 25 || Rand() > 60)
+                return;
+
+            drainManaTimer = 1000;
+
+            //1 case: feared mana pot running around
+            Unit* drainTarget = FindDrainTarget(CalcSpellMaxRange(DRAIN_MANA_1));
+
+            if (!drainTarget)
+            {
+                Unit* u = me->GetVictim();
+                if (u && u->GetPowerType() == POWER_MANA && u->GetMaxPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) &&
+                    GetManaPCT(u) >= 15 && me->GetDistance(u) < CalcSpellMaxRange(DRAIN_MANA_1))
+                    drainTarget = u;
+            }
+
+            if (drainTarget && doCast(drainTarget, GetSpell(DRAIN_MANA_1)))
+                return;
+        }
+
+        void CheckWard(uint32 diff)
+        {
+            if (!canShadowWard || (!me->IsInCombat() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                !IsSpellReady(SHADOW_WARD_1, diff) || IsCasting())
+                return;
+
+            if (doCast(me, GetSpell(SHADOW_WARD_1)))
+                return;
+        }
+
+        void CheckSoulShatter(uint32 diff)
+        {
+            if (!IsSpellReady(SOULSHATTER_1, diff) || me->getAttackers().empty() || Rand() < 80)
+                return;
+
+            Unit* u = *(me->getAttackers().begin());
+            if (u->GetThreatManager().GetThreatListSize() < 3 || u->GetThreatManager().GetThreat(me) < 100.f)
+                return;
+
+            if (doCast(me, GetSpell(SOULSHATTER_1)))
+                return;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Rand() > 25)
+                return;
+
+            bool busyCasting = me->IsNonMeleeSpellCast(true,true,true);
+
+            //Fear
+            if (!busyCasting && IsSpellReady(FEAR_1, diff))
+            {
+                Unit* u = FindCastingTarget(CalcSpellMaxRange(FEAR_1), 0, FEAR_1);
+                if (u && doCast(u, GetSpell(FEAR_1)))
+                    return;
+            }
+            //Howl of Terror (only instant cast)
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                !busyCasting && me->GetLevel() >= 45 && IsSpellReady(HOWL_OF_TERROR_1, diff))
+            {
+                Unit* u = FindCastingTarget(8, 0, FEAR_1); //same immunity
+                if (u && doCast(u, GetSpell(HOWL_OF_TERROR_1)))
+                    return;
+            }
+            //Shadowfury
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(SHADOWFURY_1, diff))
+            {
+                if (Unit* u = FindCastingTarget(CalcSpellMaxRange(SHADOWFURY_1), 0, SHADOWFURY_1))
+                {
+                    if (busyCasting)
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(u, GetSpell(SHADOWFURY_1)))
+                        return;
+                }
+            }
+             //Death Coil
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(DEATH_COIL_1, diff))
+            {
+                if (Unit* u = FindCastingTarget(CalcSpellMaxRange(DEATH_COIL_1), 0, DEATH_COIL_1))
+                {
+                    if (busyCasting)
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+        }
+
+        void DoDefend(uint32 diff)
+        {
+            if (GC_Timer > diff || !me->IsInCombat() || Rand() > 120)
+                return;
+
+            Unit::AttackerSet const& m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            bool needFearM = !IAmFree() && !m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75);
+
+            //HOWL
+            //fear master's attackers
+            if (IsSpellReady(HOWL_OF_TERROR_1, diff))
+            {
+                if (needFearM)
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (CCed(*iter, true)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance(*iter) > 9) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(HOWL_OF_TERROR_1)))
+                        return;
+                }
+                // Defend myself
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (CCed(*iter, true)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance(*iter) > 9) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(HOWL_OF_TERROR_1)))
+                        return;
+                }
+            }
+            //COIL
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(DEATH_COIL_1, diff))
+            {
+                Unit* u = needFearM ? *(m_attackers.begin()) : nullptr;
+                if (u && u->GetMaxHealth() > master->GetMaxHealth() * 2 &&
+                    u->GetDistance(me) < 30)
+                {
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+                u = !b_attackers.empty() ? *(b_attackers.begin()) : nullptr;
+                if (u && u->GetMaxHealth() > me->GetMaxHealth() * 2 && u->GetDistance(me) < 8)
+                {
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (target->GetTypeId() != TYPEID_PLAYER) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (GetSpell(UNENDING_BREATH_1) && target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) &&
+                !target->HasAuraType(SPELL_AURA_WATER_BREATHING))
+            {
+                if (doCast(target, GetSpell(UNENDING_BREATH_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            //pet is killed or unreachable
+            if (GC_Timer <= diff && !me->IsInCombat() && !me->IsMounted() && !me->GetVictim() && !IsCasting() && Rand() < 25 &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+                SummonBotPet();
+
+            //Hellfire interrupt
+            Spell const* spell = me->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+            if (spell && spell->GetSpellInfo()->GetFirstRankSpell()->Id == HELLFIRE_1 &&
+                ((!IAmFree() && !master->GetBotMgr()->IsPartyInCombat()) || GetHealthPCT(me) < 25))
+                me->InterruptSpell(CURRENT_CHANNELED_SPELL);
+            else
+            {
+                spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+                if (spell)
+                {
+                    //Fear interrupt
+                    if (spell->GetSpellInfo()->GetFirstRankSpell()->Id == FEAR_1 && spell->m_targets.GetUnitTarget() &&
+                        spell->m_targets.GetUnitTarget()->HasAuraType(SPELL_AURA_MOD_FEAR))
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    //Banish interrupt
+                    else if (spell->GetSpellInfo()->GetFirstRankSpell()->Id == BANISH_1 && spell->m_targets.GetUnitTarget())
+                    {
+                        if (AuraEffect const* bani = spell->m_targets.GetUnitTarget()->GetAuraEffect(SPELL_AURA_SCHOOL_IMMUNITY, SPELLFAMILY_WARLOCK, 0x0, 0x8000000, 0x0))
+                        {
+                            //Already banished
+                            //check spell cast time
+                            if (bani->GetBase()->GetDuration() > bani->GetBase()->GetMaxDuration() - 1500)
+                                me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                        }
+                        else if (!spell->m_targets.GetUnitTarget()->getAttackers().empty())
+                            me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    }
+                    //Soulstone resurrection interrupt
+                    else if (spell->GetSpellInfo()->SpellVisual[0] == 99 && spell->m_targets.GetUnitTarget() &&
+                        spell->m_targets.GetUnitTarget()->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                }
+            }
+
+            if (hasHealthstone && healthstoneTimer <= diff &&
+                /*GetSpell(CREATE_HEALTHSTONE_1) && */!IsCasting() && GetHealthPCT(me) < 65)
+            {
+                uint32 healthStone = InitSpell(me, CREATE_HEALTHSTONE_1);
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(healthStone);
+                //ASSERT(spellInfo);
+                uint32 rank = spellInfo->GetRank();
+                //ASSERT(rank >= 1 && rank <= 8);
+                spellInfo = sSpellMgr->GetSpellInfo(_healthStoneSpells[rank - 1]);
+                ASSERT(spellInfo);
+                int32 healing = spellInfo->Effects[0].BasePoints;
+                //Glyph of Healthstone
+                if (me->GetLevel() >= 15)
+                    healing = int32(float(healing) * 1.3f);
+                CastSpellExtraArgs args(true);
+                args.AddSpellBP0(healing);
+                me->CastSpell(me, _healthStoneSpells[rank - 1], args);
+                healthstoneTimer = 120000; //2 min
+                hasHealthstone = false;
+                return;
+            }
+            else if (IsPotionReady() && GetHealthPCT(me) < 50)
+            {
+                DrinkPotion(false);
+            }
+
+            if (IsSpellReady(DARK_PACT_1, diff) && !IsCasting() && botPet && botPet->GetPower(POWER_MANA) >= 300 &&
+                GetManaPCT(me) < 20)
+            {
+                if (doCast(me, GetSpell(DARK_PACT_1)))
+                    return;
+            }
+            else if (IsSpellReady(LIFE_TAP_1, diff) && !IsCasting() && GetHealthPCT(me) > (me->IsInCombat() ? 30 : 15) &&
+                GetManaPCT(me) < 15 && Rand() < 50)
+            {
+                //it is possible that CheckCast will return SPELL_FAILED_NO_POWER if not enough hp
+                if (doCast(me, GetSpell(LIFE_TAP_1)))
+                    return;
+            }
+            else if (IsPotionReady() && GetManaPCT(me) < 10)
+            {
+                DrinkPotion(true);
+            }
+
+            CheckRacials(diff);
+
+            CheckSoulShatter(diff);
+            DoDefend(diff);
+            CheckFear(diff);
+            CheckWard(diff);
+
+            BuffAndHealGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            Counter(diff);
+
+            CheckBanish(diff);
+            CheckUnBanish(diff);
+
+            CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            if (GC_Timer > diff)
+                return;
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_SHADOW|SPELL_SCHOOL_MASK_FIRE))
+                return;
+
+            float dist = me->GetDistance(opponent);
+
+            //spell reflections
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < CalcSpellMaxRange(CURSE_OF_THE_ELEMENTS_1) &&
+                CanRemoveReflectSpells(opponent, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(opponent, CURSE_OF_THE_ELEMENTS_1))
+                return;
+            else if (IsSpellReady(CURSE_OF_WEAKNESS_1, diff) && dist < CalcSpellMaxRange(CURSE_OF_WEAKNESS_1) &&
+                CanRemoveReflectSpells(opponent, CURSE_OF_WEAKNESS_1) &&
+                doCast(opponent, CURSE_OF_WEAKNESS_1))
+                return;
+
+            //Offensive heal (Death Coil)
+            if (IsSpellReady(DEATH_COIL_1, diff) && HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(DEATH_COIL_1) &&
+                GetHealthPCT(me) < 35)
+            {
+                //if (me->IsNonMeleeSpellCast(true))
+                //    me->InterruptNonMeleeSpells(true);
+                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //Shadowfury
+            if (IsSpellReady(SHADOWFURY_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) && Rand() < 55)
+            {
+                if (FindSplashTarget(CalcSpellMaxRange(SHADOWFURY_1)) &&
+                    doCast(opponent, GetSpell(SHADOWFURY_1)))
+                    return;
+            }
+            //Hellfire
+            if (IsSpellReady(HELLFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && !IAmFree() && !JumpingOrFalling() &&
+                GetHealthPCT(me) > 90 && Rand() < 25)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 12.f, 0);
+                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                {
+                    Unit* u = *itr;
+                    bool erase = false;
+                    if (u->isMoving())
+                    {
+                        if (me->GetDistance(u) > 10.f && !u->HasInArc(M_PI/2, me))
+                            erase = true;
+                    }
+                    else if (me->GetDistance(u) > 9.5f)
+                        erase = true;
+
+                    if (erase)
+                    {
+                        targets.erase(itr++);
+                        continue;
+                    }
+                    ++itr;
+                }
+                if (targets.size() >= 4 && doCast(me, GetSpell(HELLFIRE_1)))
+                    return;
+            }
+            //Rain of Fire
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && HasRole(BOT_ROLE_DPS) && !JumpingOrFalling() && Rand() < 45)
+            {
+                if (Unit* raintarget = FindAOETarget(CalcSpellMaxRange(RAIN_OF_FIRE_1)))
+                {
+                    if (doCast(raintarget, GetSpell(RAIN_OF_FIRE_1)))
+                        return;
+                }
+            }
+            //Searing Pain (PvP)
+            if (longCasted && IsSpellReady(SEARING_PAIN_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetTypeId() == TYPEID_PLAYER && Rand() < 35 && dist < CalcSpellMaxRange(SEARING_PAIN_1))
+            {
+                if (doCast(opponent, GetSpell(SEARING_PAIN_1)))
+                    return;
+            }
+            //Shadowflame
+            if (longCasted && IsSpellReady(SHADOWFLAME_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 65)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 8); //radius 10 yd
+                if (!targets.empty() && doCast(me, GetSpell(SHADOWFLAME_1)))
+                    return;
+            }
+            //Curse, checking affliction range
+            if (GetSpellCooldown(CURSE_OF_WEAKNESS_1) <= diff && Rand() < 25 &&
+                dist < CalcSpellMaxRange(CURSE_OF_WEAKNESS_1) && opponent->GetHealth() > me->GetMaxHealth() / 8)
+            {
+                bool skipCurse = false;
+                uint32 CURSE = 0;
+                if (/*!skipCurse && !CURSE && */GetSpell(CURSE_OF_THE_ELEMENTS_1) && !IAmFree() &&
+                    master->GetGroup() && master->GetGroup()->GetMembersCount() > 2)
+                {
+                    AuraEffect const* elem = opponent->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x200, 0x0);
+                    if (!elem || elem->GetBase()->GetDuration() < 30000)
+                        CURSE = CURSE_OF_THE_ELEMENTS_1;
+                    else if (elem->GetCasterGUID() == me->GetGUID())
+                        skipCurse = true;
+                }
+                if (!skipCurse && !CURSE && GetSpell(CURSE_OF_TONGUES_1) && opponent->GetHealth() > me->GetMaxHealth() / 2 &&
+                    opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    AuraEffect const* tong = opponent->GetAuraEffect(SPELL_AURA_MOD_LANGUAGE, SPELLFAMILY_WARLOCK, 692, 1);
+                    if (!tong || tong->GetBase()->GetDuration() < 5000)
+                        CURSE = CURSE_OF_TONGUES_1;
+                    else if (tong->GetCasterGUID() == me->GetGUID())
+                        skipCurse = true;
+                }
+                if (!skipCurse && !CURSE && GetSpell(CURSE_OF_WEAKNESS_1) && opponent->GetMaxHealth() > me->GetMaxHealth() * 2)
+                {
+                    AuraEffect const* weak = opponent->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_WARLOCK, 0x8000, 0x0, 0x0);
+                    if (!weak || weak->GetBase()->GetDuration() < 10000)
+                        CURSE = CURSE_OF_WEAKNESS_1;
+                    else if (weak->GetCasterGUID() == me->GetGUID())
+                        skipCurse = true;
+                }
+                if (!skipCurse && !CURSE && GetSpell(CURSE_OF_AGONY_1) && HasRole(BOT_ROLE_DPS) &&
+                    opponent->GetHealth() > me->GetMaxHealth() / 2 * (1 + opponent->getAttackers().size()) &&
+                    !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x400, 0x0, 0x0, me->GetGUID()))
+                {
+                    CURSE = CURSE_OF_AGONY_1;
+                }
+                if (!skipCurse && !CURSE && GetSpell(CURSE_OF_EXHAUSTION_1) && !CCed(opponent, true) &&
+                    !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                {
+                    CURSE = CURSE_OF_EXHAUSTION_1;
+                }
+
+                if (!skipCurse && CURSE && doCast(opponent, GetSpell(CURSE)))
+                    return;
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //Chaos Bolt
+            if (IsSpellReady(CHAOS_BOLT_1, diff) && dist < CalcSpellMaxRange(CHAOS_BOLT_1))
+            {
+                if (doCast(opponent, GetSpell(CHAOS_BOLT_1)))
+                    return;
+            }
+            //Soul Fire 1
+            if (IsSpellReady(SOUL_FIRE_1, diff) && Rand() < 150 && dist < CalcSpellMaxRange(SOUL_FIRE_1) &&
+                (opponent->IsPolymorphed() || me->HasAuraTypeWithAffectMask(SPELL_AURA_NO_REAGENT_USE, sSpellMgr->GetSpellInfo(SOUL_FIRE_1))))
+            {
+                if (doCast(opponent, GetSpell(SOUL_FIRE_1)))
+                    return;
+            }
+            //Conflagrate (always glyphed, does not consume dot)
+            if (longCasted && IsSpellReady(CONFLAGRATE_1, diff) && dist < CalcSpellMaxRange(CONFLAGRATE_1) &&
+                opponent->HasAuraState(AURA_STATE_CONFLAGRATE) &&
+                opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(CONFLAGRATE_1)))
+                    return;
+            }
+            //Shadowburn
+            if (longCasted && IsSpellReady(SHADOWBURN_1, diff) && dist < CalcSpellMaxRange(SHADOWBURN_1) &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+            {
+                if (doCast(opponent, GetSpell(SHADOWBURN_1)))
+                    return;
+            }
+            //Immolate
+            if (IsSpellReady(IMMOLATE_1, diff) && Rand() < 85 && dist < CalcSpellMaxRange(IMMOLATE_1) &&
+                (GetSpell(CONFLAGRATE_1) || opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size())) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(IMMOLATE_1)))
+                    return;
+            }
+            //Haunt
+            if (IsSpellReady(HAUNT_1, diff) && opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()) &&
+                Rand() < 45 && GetHealthPCT(me) < 90 && dist < CalcSpellMaxRange(HAUNT_1) &&
+                !opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_WARLOCK, 0x0, 0x40000, 0x0, me->GetGUID()) &&
+                opponent->GetDoTsByCaster(me->GetGUID()) > 1)
+            {
+                if (doCast(opponent, GetSpell(HAUNT_1)))
+                    return;
+            }
+            //Seed of Corruption
+            if (IsSpellReady(SEED_OF_CORRUPTION_1, diff) && Rand() < 85)
+            {
+                Unit* target = FindAOETarget(CalcSpellMaxRange(SEED_OF_CORRUPTION_1));
+                if (target && !target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x10, 0x0, me->GetGUID()))
+                {
+                    if (doCast(target, GetSpell(SEED_OF_CORRUPTION_1)))
+                        return;
+                }
+
+                SetSpellCooldown(SEED_OF_CORRUPTION_1, 1000); //fail
+            }
+            //Corruption
+            if (IsSpellReady(CORRUPTION_1, diff) && Rand() < 90 && dist < CalcSpellMaxRange(CORRUPTION_1) &&
+                opponent->GetHealth() > me->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x2, 0x0, 0x0, me->GetGUID()) &&//corruption
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x10, 0x0, me->GetGUID()))//seed of corruption
+            {
+                if (doCast(opponent, GetSpell(CORRUPTION_1)))
+                    return;
+            }
+            //Drain Soul: only if can quad damage
+            if (IsSpellReady(DRAIN_SOUL_1, diff) && opponent->GetTypeId() == TYPEID_UNIT &&
+                /*!opponent->ToCreature()->isWorldBoss() && */GetHealthPCT(opponent) < 25 &&
+                opponent->GetHealth() > me->GetMaxHealth() / 4 * (1 + opponent->getAttackers().size()) &&
+                dist < CalcSpellMaxRange(DRAIN_SOUL_1) && opponent->GetDoTsByCaster(me->GetGUID()) > 1
+                //abs(int32(me->GetLevel()) - int32(opponent->GetLevel())) <= 5
+                //!opponent->HasAuraType(SPELL_AURA_CHANNEL_DEATH_ITEM)
+                )
+            {
+                if (doCast(opponent, GetSpell(DRAIN_SOUL_1)))
+                    return;
+            }
+            //Soul Fire (conditional)
+            if (IsSpellReady(SOUL_FIRE_1, diff) && Rand() < 90 && dist < CalcSpellMaxRange(SOUL_FIRE_1) &&
+                opponent->GetHealth() > me->GetMaxHealth()/8 * (1 + opponent->getAttackers().size()) && me->HasAura(BACKDRAFT_BUFF))
+            {
+                if (doCast(opponent, GetSpell(SOUL_FIRE_1)))
+                    return;
+            }
+            //Main: Shadow Bolt, Incinerate, Searing Pain (tank), checking destruction range
+            if (dist < CalcSpellMaxRange(SHADOW_BOLT_1))
+            {
+                uint32 boltinerate =
+                    IsTank() && GetSpell(SEARING_PAIN_1) ? SEARING_PAIN_1 :
+                    GetSpell(INCINERATE_1) && opponent->HasAuraState(AURA_STATE_CONFLAGRATE) &&
+                    opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0) &&
+                    opponent->GetAuraEffect(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, SPELLFAMILY_WARLOCK, 213, 0) &&
+                    (me->GetMap()->IsRaid() || !me->HasAura(SHADOW_TRANCE_BUFF)) ?
+                    INCINERATE_1 : SHADOW_BOLT_1;
+
+                if (doCast(opponent, GetSpell(boltinerate)))
+                    return;
+            }
+
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == SHOOT_WAND && shot->m_targets.GetUnitTarget() != opponent)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (IsSpellReady(SHOOT_WAND, diff) && me->GetDistance(opponent) < 30 && GetEquips(BOT_SLOT_RANGED) &&
+                doCast(opponent, SHOOT_WAND))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            //victim can be NULL
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Molten Core part 2.2: 15% additional critical chance for Soul Fire
+            if (lvl >= 35 && baseId == SOUL_FIRE_1)
+            {
+                const_cast<warlock_botAI*>(this)->moltencore = me->HasAura(MOLTEN_CORE_BUFF);
+                if (moltencore)
+                    crit_chance += 15.f;
+            }
+
+            //Devastation: 5% additional critical chance for Destruction spells
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 30 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x3E5) || (spellInfo->SpellFamilyFlags[1] & 0x8310C0)))
+                crit_chance += 5.f;
+            //Fire and Brimstone part 2: 25% additional critical chance for Conflagrate
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 55 && baseId == CONFLAGRATE_1)
+                crit_chance += 25.f;
+            //Malediction part 2: 9% additional critical chance for Corruption and Unstable Affliction
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 45 && (baseId == CORRUPTION_1 || baseId == UNSTABLE_AFFLICTION_1))
+                crit_chance += 9.f;
+            //Glyph of Shadowburn: 20% additional critical chance for Shadowburn on targets 35% hp and below
+            if (lvl >= 20 && baseId == SHADOWBURN_1 && victim && victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                crit_chance += 20.f;
+            //Improved Corruption part 2: 5% additional critical chance for Seed of Corruption
+            if (lvl >= 10 && (baseId == SEED_OF_CORRUPTION_1 || baseId == SEED_OF_CORRUPTION_FINAL_DAMAGE_1))
+                crit_chance += 5.f;
+            //Improved Searing Pain: 10% additional critical chance for Searing Pain
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 25 && baseId == SEARING_PAIN_1)
+                crit_chance += 10.f;
+
+            //Master Demonologist part 1.2 (me): 5% additional critical chance for Fire spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_IMP && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE))
+                crit_chance += 5.f;
+            //Master Demonologist part 3.2 (me): 5% additional critical chance for Shadow spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_SUCCUBUS && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                crit_chance += 5.f;
+
+            //Warlock T84P Bonus (64932): 5% additional critical chance for Shadow Bolt and Incinerate
+            if (lvl >= 80 && (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1))
+                crit_chance += 5.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f; //Special condition
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Ruin: 50% additional crit damage bonus for Destruction spells
+                if (lvl >= 20 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                    ((spellInfo->SpellFamilyFlags[0] & 0x13E5) || (spellInfo->SpellFamilyFlags[1] & 0xC310C0)))
+                    pctbonus += 0.333f;
+                //Pandemic part 2,3: crit damage for periodics and haunt
+                if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                    lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                    ((spellInfo->SpellFamilyFlags[0] & 0x2) || (spellInfo->SpellFamilyFlags[1] & 0x40100)))
+                    pctbonus += 0.333f;
+                //Glyph of Searing Pain: 20% additional crit damage bonus for Searing Pain
+                if (lvl >= 18 && baseId == SEARING_PAIN_1)
+                    pctbonus += 0.133f;
+            }
+            //Improved Shadow Bolt and Incinerate (38393): 6% bonus damage for Shadow bolt and Incinerate
+            if (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1)
+                pctbonus += 0.06f;
+            //Glyph of Incinerate: 5% bonus damage for Incinerate
+            if (baseId == INCINERATE_1)
+                pctbonus += 0.05f;
+            //Improved Immolate: 30% bonus damage for Immolate
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 30 && baseId == IMMOLATE_1)
+                pctbonus += 0.3f;
+            //EmberStorm part 1: 15% bonus damage for Fire spells
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 35 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x364) || (spellInfo->SpellFamilyFlags[1] & 0x8200C0)))
+                pctbonus += 0.15f;
+            //Fire and Brimstone part 1: 10% bonus damage for Incinerate and Chaos Bolt
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 55 && (baseId == INCINERATE_1 || baseId == CHAOS_BOLT_1) &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0, me->GetGUID()))
+                pctbonus += 0.1f;
+            //Molten Core part 1: 18% bonus damage for Incinerate and Soul Fire
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 35 && (baseId == INCINERATE_1 || baseId == SOUL_FIRE_1))
+            {
+                if (me->HasAura(MOLTEN_CORE_BUFF))
+                    pctbonus += 0.18f;
+            }
+            //Improved Corruption part 1: 10% bonus damage for Corruption
+            if (lvl >= 10 && baseId == CORRUPTION_1)
+                pctbonus += 0.1f;
+            //Corruption (28829): 12% bonus damage for Corruption
+            if (lvl >= 40 && baseId == CORRUPTION_1)
+                pctbonus += 0.12f;
+            //Malediction part 1: 3% bonus damage for All spells
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) && lvl >= 45)
+                pctbonus += 0.03f;
+            //Death's Embrace part 2: 12% bonus damage for Shadow spells on targets below 35 pct health
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 50 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT) &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x8248B) || (spellInfo->SpellFamilyFlags[1] & 0x59913)))
+                pctbonus += 0.12f;
+
+            //Empowered Corruption: 36% spellpower bonus for Corruption
+            if (lvl >= 25 && baseId == CORRUPTION_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.36f * me->CalculateDefaultCoefficient(spellInfo, DOT) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Shadow and Flame: 20% spellpower bonus for Shadow Bolt, Shadowburn, Chaos Bolt and Incineration
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 45 &&
+                (baseId == SHADOW_BOLT_1 || baseId == CHAOS_BOLT_1 || baseId == SHADOWBURN_1 || baseId == INCINERATE_1))
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Everlasting Affliction part 1: 5% spellpower bonus for Corruption and Unstable Affliction
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 55 && (baseId == CORRUPTION_1 || baseId == UNSTABLE_AFFLICTION_1))
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.05f * me->CalculateDefaultCoefficient(spellInfo, DOT) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            //Firestone/Spellstone: 1% bonus damage for all spells
+            if (lvl >= 28)
+                pctbonus += 0.01f;
+
+            //Improved Shadow Bolt part 1: 10% bonus damage for Shadow Bolt
+            if (lvl >= 10 && baseId == SHADOW_BOLT_1)
+                pctbonus += 0.1f;
+            //Improved Corruption and Immolate (Updated) (61992): 5% bonus damage for Corruption and Immolate
+            if (lvl >= 10 && (baseId == CORRUPTION_1 || baseId == IMMOLATE_1))
+                pctbonus += 0.05f;
+            //Improved Curse of Agony: 10% bonus damage for Curse of Agony
+            if (lvl >= 10 && baseId == CURSE_OF_AGONY_1)
+                pctbonus += 0.1f;
+            //Shadow Mastery: 15% bonus damage for Shadow Spells
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x80091) || spellInfo->SpellFamilyFlags[1] & 0x451910))
+                pctbonus += 0.15f;
+            //Contagion: 5% bonus damage for Curse of Agony, Corruption and Seed of Corruption
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 40 && (baseId == CORRUPTION_1 || baseId == SEED_OF_CORRUPTION_1 ||
+                baseId == SEED_OF_CORRUPTION_FINAL_DAMAGE_1 || baseId == CURSE_OF_AGONY_1))
+                pctbonus += 0.05f;
+
+            //Warlock T82P Bonus (64931): 20/10% bonus damage for Unstable Affliction and Immolate
+            if (lvl >= 80 && baseId == UNSTABLE_AFFLICTION_1)
+                pctbonus += 0.2f;
+            if (lvl >= 80 && baseId == IMMOLATE_1)
+                pctbonus += 0.1f;
+            //Warlock T94P Bonus (67231): 10% bonus damage for Immolate, Corruption and Unstable Affliction
+            if (lvl >= 80 && (baseId == IMMOLATE_1 || baseId == CORRUPTION_1 || baseId == UNSTABLE_AFFLICTION_1))
+                pctbonus += 0.2f;
+
+            //Glyph of Immolate: 10% bonus damage for Immolate
+            if (lvl >= 15 && baseId == IMMOLATE_1)
+                pctbonus += 0.1f;
+
+            //Demonic Pact part 1: 10% bonus damage for all spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) && lvl >= 55)
+                pctbonus *= 1.1f;
+            //Master Demonologist part 1.1 (me): 5% bonus damage for Fire spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_IMP && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE))
+                pctbonus *= 1.05f;
+            //Master Demonologist part 3.1 (me): 5% bonus damage for Shadow spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_SUCCUBUS && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus *= 1.05f;
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+
+            //Glyph of Siphon Life: 25% bonus healing for Siphon Life effect (50% for bots)
+            if (baseId == SIPHON_LIFE_HEAL)
+                pctbonus += 0.5f;
+            //Improved Death Coil (30052): 30% bonus healing for Death Coil
+            if (lvl >= 60 && baseId == DEATH_COIL_1)
+                pctbonus += 0.3f;
+
+            heal = heal * (1.0f + pctbonus);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Doomcaller Reduced Shadow Bolt Cost (26117): -15% mana cost for Shadow Bolt
+            if (baseId == SHADOW_BOLT_1)
+                pctbonus += 0.15f;
+            //Glyph of Shadow Bolt: -10% mana cost for Shadow Bolt
+            if (lvl >= 15 && baseId == SHADOW_BOLT_1)
+                pctbonus += 0.1f;
+            //Cataclysm: -10% mana cost for Destruction spells
+            if (lvl >= 15 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x3E5) || (spellInfo->SpellFamilyFlags[1] & 0x8310C0)))
+                pctbonus += 0.1f;
+            //Suppression: -6% mana cost for Affliction spells
+            if (lvl >= 10 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x814CC41A) || (spellInfo->SpellFamilyFlags[1] & 0x248F1B)))
+                pctbonus += 0.06f;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus));
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Backlash: -100% cast time for Shadow Bolt or Incinerate
+            if (lvl >= 15 && (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1))
+            {
+                const_cast<warlock_botAI*>(this)->backlash = me->HasAura(BACKLASH_BUFF);
+                const_cast<warlock_botAI*>(this)->shadowtrance = (baseId == SHADOW_BOLT_1 && me->HasAura(SHADOW_TRANCE_BUFF));
+                if (backlash || shadowtrance)
+                    timebonus += casttime;
+            }
+            //Improved Howl of Terror: -1.5sec (-100%) cast time for Howl of Terror
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) && lvl >= 45 && baseId == HOWL_OF_TERROR_1)
+                timebonus += casttime;
+            //Chaotic Mind (custom)
+            if (baseId == SOUL_FIRE_1)
+            {
+                const_cast<warlock_botAI*>(this)->chaoticmind = me->HasAura(CHAOTIC_MIND_BUFF);
+                if (chaoticmind)
+                    timebonus += casttime;
+            }
+
+            //pct mods
+            //BackDraft part 1: -30% cast time for Destruction spells
+            if (lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)))
+            {
+                //skip soul fire insta cast
+                const_cast<warlock_botAI*>(this)->backdraft = me->HasAura(BACKDRAFT_BUFF) && !(chaoticmind && baseId == SOUL_FIRE_1);
+                if (backdraft)
+                    pctbonus += 0.3f;
+            }
+            //Molten Core part 2.1: -30% cast time for Incinerate
+            if (lvl >= 35 && baseId == INCINERATE_1)
+            {
+                const_cast<warlock_botAI*>(this)->moltencore = me->HasAura(MOLTEN_CORE_BUFF);
+                if (moltencore)
+                    pctbonus += 0.3f;
+            }
+            //Decimation: -40% cast time for Soul Fire
+            if (baseId == SOUL_FIRE_1 && me->HasAura(DECIMATION_BUFF))
+                pctbonus += 0.4f;
+
+            //flat mods
+            //Bane: -0.5 sec cast time for Shadow Bolt, Immolate and Chaos Bolt, -2 sec cast for Soul Fire
+            if (lvl >= 10)
+            {
+                if (baseId == SHADOW_BOLT_1 || baseId == IMMOLATE_1 || baseId == CHAOS_BOLT_1)
+                    timebonus += 500;
+                else if (baseId == SOUL_FIRE_1)
+                    timebonus += 2000;
+            }
+            //EmberStorm part 2: -0.25 sec cast time for Incinerate
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 35 && baseId == INCINERATE_1)
+                timebonus += 250;
+            //Fear Cast Time Reduction (23047): -0.2 sec cast time for Fear
+            if (baseId == FEAR_1)
+                timebonus += 200;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+
+            const_cast<warlock_botAI*>(this)->instaCast = (casttime <= 500); //triggered GCD is too long
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Glyph of Chaos Bolt: -2 sec cooldown for Chaos Bolt
+            if (lvl >= 60 && baseId == CHAOS_BOLT_1)
+                timebonus += 2000;
+            //Improved Death Coil (24487): -15% cooldown for Death Coil (30 sec for bots)
+            if (baseId == DEATH_COIL_1)
+                timebonus += 30000;
+            //Glyph of Howl of Terror: -8 sec cooldown for Howl of Terror
+            if (lvl >= 45 && baseId == HOWL_OF_TERROR_1)
+                timebonus += 8000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //BackDraft: -30% global cooldown for Destruction spells
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)) &&
+                me->HasAura(BACKDRAFT_BUFF))
+                pctbonus += 0.3f;
+
+            //flat mods
+            //Amplify Curse: -0.5 sec global cooldown for Curses
+            if (lvl >= 20 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x408400) || (spellInfo->SpellFamilyFlags[1] & 0x200202) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x800)))
+                timebonus += 500.f;
+
+            //Fear Cast Time Reduction (23047): -0.2 sec global cooldown for Fear
+            if (baseId == FEAR_1)
+                timebonus += 200;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Improved Rain of Fire / Hellfire
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x60))
+                flatbonus += 2.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Grim Reach: +20% range for Affliction Spells
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x8048C41A) || (spellInfo->SpellFamilyFlags[1] & 0x40713)))
+                pctbonus += 0.2f;
+            //Destructive Reach: +20% range for Destruction Spells
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x13A5) || (spellInfo->SpellFamilyFlags[1] & 0x8210C0)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Curse of Exhaustion: +5 yd range for Curse of Exhaustion
+            if (lvl >= 70 && baseId == CURSE_OF_EXHAUSTION_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Instacast buffs handling
+            if (baseId == SHADOW_BOLT_1)
+            {
+                if (backlash)
+                    me->RemoveAurasDueToSpell(BACKLASH_BUFF);
+                else if (shadowtrance)
+                    me->RemoveAurasDueToSpell(SHADOW_TRANCE_BUFF);
+            }
+            if (baseId == INCINERATE_1)
+            {
+                if (backlash)
+                    me->RemoveAurasDueToSpell(BACKLASH_BUFF);
+            }
+            if (chaoticmind && baseId == SOUL_FIRE_1)
+                me->RemoveAurasDueToSpell(CHAOTIC_MIND_BUFF);
+
+            //Backdraft
+            if (backdraft && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)))
+            {
+                if (Aura* bd = me->GetAura(BACKDRAFT_BUFF))
+                    bd->DropCharge();
+            }
+            //Molten Core
+            if (moltencore && (baseId == INCINERATE_1 || baseId == SOUL_FIRE_1))
+            {
+                if (Aura* mc = me->GetAura(MOLTEN_CORE_BUFF))
+                    mc->DropCharge();
+            }
+            //Decimation: NOT DROPPED ON CAST
+            //if (baseId == SOUL_FIRE_1)
+            //{
+            //    if (Aura* mc = me->GetAura(DECIMATION_BUFF))
+            //        mc->DropCharge();
+            //}
+            longCasted = !instaCast &&
+                (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1 || baseId == CHAOS_BOLT_1 ||
+                baseId == SOUL_FIRE_1 || baseId == HAUNT_1 || baseId == SEARING_PAIN_1); //damaging spells
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Shadow Ward helper
+            if (!canShadowWard && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW) &&
+                (spell->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) || spell->HasAura(SPELL_AURA_PERIODIC_DAMAGE)))
+                canShadowWard = true;
+
+            //Create Healthstone trigger
+            if (baseId == CREATE_HEALTHSTONE_1)
+            {
+                hasHealthstone = true;
+            }
+            //Create Soulstone trigger
+            if (baseId == CREATE_SOULSTONE_1)
+            {
+                hasSoulstone = true;
+            }
+
+            //Glyph of Soul Link: +5% increased effect
+            if (baseId == SOUL_LINK_PET)
+            {
+                if (AuraEffect* link = me->GetAuraEffect(spellId, 0))
+                    link->ChangeAmount(link->GetAmount() + 5);
+            }
+
+            //Life Tap energize
+            if (baseId == LIFE_TAP_1)
+            {
+                //level * 3 based on in-game tooltip and spellwork (BasePoints = 2000 + Level * 4,00)
+                int32 damage = spell->Effects[0].CalcValue(me);
+                int32 manaGain = damage;
+                damage += int32(me->GetLevel() * 3);
+                manaGain += 0.5f * me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);
+
+                //Life Tap (id: 28830)
+                //damage = int32(float(damage) * 0.88f);
+                //Improved Life Tap
+                if (me->GetLevel() >= 15)
+                    manaGain = int32(float(manaGain) * 1.2f);
+
+                me->ModifyHealth(-damage);
+                CastSpellExtraArgs args(true);
+                args.AddSpellBP0(manaGain);
+                me->CastSpell(me, LIFE_TAP_ENERGIZE, args);
+
+                //Mana Feed
+                if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) && me->GetLevel() >= 35 && botPet)
+                    me->EnergizeBySpell(botPet, LIFE_TAP_ENERGIZE_PET, manaGain, POWER_MANA);
+            }
+
+            if (baseId == DEMON_ARMOR_1 || baseId == FEL_ARMOR_1)
+            {
+                if (Aura* armo = me->GetAura(spellId, me->GetGUID()))
+                {
+                    //Armors duration
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    armo->SetDuration(dur);
+                    armo->SetMaxDuration(dur);
+
+                    //Demonic Aegis
+                    if (lvl >= 20)
+                    {
+                        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                            if (AuraEffect* eff = armo->GetEffect(i))
+                                eff->ChangeAmount(eff->GetAmount() * 13 / 10);
+                    }
+                }
+            }
+            //Chaotic Mind (custom)
+            if (baseId == CHAOTIC_MIND)
+            {
+                if (Aura* mind = me->GetAura(spellId))
+                {
+                    uint32 dur = 30000; //30 sec
+                    mind->SetDuration(dur);
+                    mind->SetMaxDuration(dur);
+                }
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Soulstone resurrection trigger (not ranked)
+            if (spellId == SOULSTONE_RESURRECTION_1 || spellId == SOULSTONE_RESURRECTION_2 ||
+                spellId == SOULSTONE_RESURRECTION_3 || spellId == SOULSTONE_RESURRECTION_4 ||
+                spellId == SOULSTONE_RESURRECTION_5 || spellId == SOULSTONE_RESURRECTION_6 ||
+                spellId == SOULSTONE_RESURRECTION_7)
+            {
+                hasSoulstone = false;
+                //reduced for bot
+                //soulstoneTimer = 15 * MINUTE * IN_MILLISECONDS;
+                soulstoneTimer = 10 * MINUTE * IN_MILLISECONDS;
+            }
+
+            //Improved Imp part 3
+            if (lvl >= 10 && baseId == BLOOD_PACT_1 && botPet)
+            {
+                AuraEffect* pact = target->GetAuraEffect(spellId, 0, botPet->GetGUID());
+                if (pact)
+                    pact->ChangeAmount(pact->GetAmount() * 1.3f);
+            }
+
+            //Improved Felhunter part 3
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) && lvl >= 35 && baseId == FEL_INTELLIGENCE_1 && botPet)
+            {
+                Aura const* feli = target->GetAura(spellId, botPet->GetGUID());
+                if (feli)
+                {
+                    for (uint8 i = EFFECT_0; i != EFFECT_2; ++i)
+                    {
+                        if (AuraEffect* effi = feli->GetEffect(i))
+                            effi->ChangeAmount(effi->GetAmount() + effi->GetAmount() / 10);
+                    }
+                }
+            }
+
+            //Glyph of Unending Breath: swim speed
+            if (/*lvl >= 15 && */baseId == UNENDING_BREATH_1)
+            {
+                AuraEffect* brea = target->GetAuraEffect(spellId, 1, me->GetGUID());
+                if (brea)
+                    brea->ChangeAmount(brea->GetAmount() + 20);
+            }
+
+            //Chaotic Mind (custom)
+            if (lvl >= 60 && target != me && spell->SpellFamilyName == SPELLFAMILY_WARLOCK && !spell->IsPositive())
+            {
+                if (urand(1,100) <= 5)
+                    me->CastSpell(me, CHAOTIC_MIND, true);
+            }
+            if (baseId == IMMOLATE_1 || baseId == CORRUPTION_1)
+            {
+                if (Aura* per = target->GetAura(spellId, me->GetGUID()))
+                {
+                    //Improved Corruption and Immolate (37380): +3 sec duration for Immolate and Corruption
+                    uint32 dur = per->GetDuration() + 3000;
+                    //Molten Core: + 9 sec duration for Immolate
+                    if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 35 && baseId == IMMOLATE_1)
+                        dur += 9000;
+                    per->SetDuration(dur);
+                    per->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Death Coil: + 0.5 sec duration for Death Coil (2 sec on creatures)
+            if (baseId == DEATH_COIL_1)
+            {
+                if (Aura* dc = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = dc->GetDuration() + (target->GetTypeId() == TYPEID_PLAYER ? 500 : 2000);
+                    dc->SetDuration(dur);
+                    dc->SetMaxDuration(dur);
+                }
+            }
+            //Improved Curse of Weakness: +20% increased effect
+            if (baseId == CURSE_OF_WEAKNESS_1)
+            {
+                if (AuraEffect* weak = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    weak->ChangeAmount(weak->GetAmount() * 12 / 10);
+                }
+            }
+            //Glyph of Haunt: +3% increased effect
+            if (lvl >= 60 && baseId == HAUNT_1)
+            {
+                if (AuraEffect* haun = target->GetAuraEffect(spellId, 2, me->GetGUID()))
+                {
+                    haun->ChangeAmount(haun->GetAmount() + 3);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Fel Synergy (Life Tap)
+            if (damage && botPet && me->GetLevel() >= 10 && (damageType == SPELL_DIRECT_DAMAGE || damageType == DOT))
+            {
+                uint32 healVal = float(damage) * 0.15f;
+                if (healVal)
+                {
+                    SpellInfo const* synhealInfo = sSpellMgr->GetSpellInfo(FEL_SYNERGY_HEAL);
+                    HealInfo hinfo(me, botPet, healVal, synhealInfo, synhealInfo->GetSchoolMask());
+                    botPet->HealBySpell(hinfo);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            if (myPetType == BOT_PET_INVALID) //disabled
+                return;
+
+            if (petSummonTimer > GetLastDiff())
+                return;
+
+            uint32 entry;
+
+            if (myPetType)
+                entry = myPetType;
+            else if (!IAmFree())
+            {
+                if (me->GetLevel() >= 30 && master->GetMaxPower(POWER_MANA) > 1 &&
+                    !master->GetBotMgr()->HasBotClass(BOT_CLASS_MAGE) &&
+                    !master->GetBotMgr()->HasBotClass(BOT_CLASS_PRIEST) &&
+                    !master->GetBotMgr()->HasBotPetType(BOT_PET_FELHUNTER))
+                    entry = BOT_PET_FELHUNTER;
+                else if ((me->GetLevel() < 68 || !master->GetBotMgr()->HasBotClass(BOT_CLASS_WARRIOR)) &&
+                    !master->GetBotMgr()->HasBotPetType(BOT_PET_IMP))
+                    entry = BOT_PET_IMP;
+                else if (me->GetLevel() >= 10 && IsTank())
+                    entry = BOT_PET_VOIDWALKER;
+                else if (me->GetLevel() >= 50 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                    entry = BOT_PET_FELGUARD;
+                else if (me->GetLevel() >= 20 && !IsMeleeClass(master->GetClass()))
+                    entry = BOT_PET_SUCCUBUS;
+                else if (me->GetLevel() >= 10)
+                    entry = BOT_PET_VOIDWALKER;
+                else
+                    entry = BOT_PET_IMP;
+            }
+            else
+                entry = urand(BOT_PET_WARLOCK_START, BOT_PET_WARLOCK_END);
+
+            //ensurance
+            if ((entry == BOT_PET_VOIDWALKER && me->GetLevel() < 10) ||
+                (entry == BOT_PET_SUCCUBUS && me->GetLevel() < 20) ||
+                (entry == BOT_PET_FELHUNTER && me->GetLevel() < 30) ||
+                (entry == BOT_PET_FELGUARD && (me->GetLevel() < 50 || _spec != BOT_SPEC_WARLOCK_DEMONOLOGY)) ||
+                (entry != BOT_PET_IMP && entry != BOT_PET_VOIDWALKER && entry != BOT_PET_SUCCUBUS &&
+                entry != BOT_PET_FELHUNTER && entry != BOT_PET_FELGUARD))
+                entry = 0;
+
+            myPetType = entry;
+
+            //try next time
+            if (!myPetType)
+                return;
+
+            ResetSpellCooldown(BLOOD_PACT_1);
+            ResetSpellCooldown(FEL_INTELLIGENCE_1);
+
+            Position pos;
+
+            me->CastSpell(me, SUMMON_DEMON_VISUAL, true);
+            Creature* myPet = me->SummonCreature(myPetType, *me, TEMPSUMMON_CORPSE_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, me->GetOrientation() + M_PI / 2);
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreatorGUID(master->GetGUID());
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //fix scale and equips
+            switch (myPetType)
+            {
+                case BOT_PET_FELHUNTER:
+                    myPet->SetObjectScale(1.1f);
+                    break;
+                case BOT_PET_FELGUARD:
+                    myPet->SetObjectScale(0.75f);
+                    myPet->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, 22199);
+                    break;
+            }
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all warlock bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+            {
+                petSummonTimer = 10000;
+                botPet = nullptr;
+
+                //party aura hack removal helper
+                switch (summon->GetEntry())
+                {
+                    case BOT_PET_IMP:
+                        me->RemoveAurasDueToSpell(InitSpell(me, BLOOD_PACT_1));
+                        break;
+                    case BOT_PET_FELHUNTER:
+                        me->RemoveAurasDueToSpell(InitSpell(me, FEL_INTELLIGENCE_1));
+                        break;
+                }
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(SHADOW_BOLT_1) : 20.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case CREATE_HEALTHSTONE_1:
+                    return uint32(hasHealthstone);
+                case BOTAI_MISC_PET_TYPE:
+                    return myPetType;
+                case BOTAI_MISC_PET_AVAILABLE_1:
+                    return BOT_PET_IMP;
+                case BOTAI_MISC_PET_AVAILABLE_2:
+                    return me->GetLevel() >= 10 ? BOT_PET_VOIDWALKER : 0;
+                case BOTAI_MISC_PET_AVAILABLE_3:
+                    return me->GetLevel() >= 20 ? BOT_PET_SUCCUBUS : 0;
+                case BOTAI_MISC_PET_AVAILABLE_4:
+                    return me->GetLevel() >= 30 ? BOT_PET_FELHUNTER : 0;
+                case BOTAI_MISC_PET_AVAILABLE_5:
+                    return me->GetLevel() >= 50 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY ? BOT_PET_FELGUARD : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case CREATE_HEALTHSTONE_1:
+                    hasHealthstone = bool(value);
+                    break;
+                case BOTAI_MISC_PET_TYPE:
+                    myPetType = value;
+                    UnsummonAll();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            myPetType = 0;
+
+            fearTimer = 0;
+            banishTimer = 0;
+            unbanishTimer = 0;
+            drainManaTimer = 0;
+            healthstoneTimer = 0;
+            soulstoneTimer = 0;
+
+            petSummonTimer = 5000;
+
+            hasHealthstone = false;
+            hasSoulstone = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (fearTimer > diff)                   fearTimer -= diff;
+            if (banishTimer > diff)                 banishTimer -= diff;
+            if (unbanishTimer > diff)               unbanishTimer -= diff;
+            if (drainManaTimer > diff)              drainManaTimer -= diff;
+            if (healthstoneTimer > diff)            healthstoneTimer -= diff;
+            if (soulstoneTimer > diff)              soulstoneTimer -= diff;
+
+            if (petSummonTimer > diff)              petSummonTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+
+            if (botPet && botPet->GetPowerType() != POWER_MANA)
+                botPet->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isAffl = _spec == BOT_SPEC_WARLOCK_AFFLICTION;
+            //bool isDemo = _spec == BOT_SPEC_WARLOCK_DEMONOLOGY;
+            bool isDest = _spec == BOT_SPEC_WARLOCK_DESTRUCTION;
+
+            InitSpellMap(CURSE_OF_WEAKNESS_1);
+            InitSpellMap(CURSE_OF_AGONY_1);
+            InitSpellMap(CURSE_OF_TONGUES_1);
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            InitSpellMap(CORRUPTION_1);
+            InitSpellMap(SEED_OF_CORRUPTION_1);
+            InitSpellMap(INCINERATE_1);
+            InitSpellMap(SEARING_PAIN_1);
+            InitSpellMap(SOUL_FIRE_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+            InitSpellMap(HELLFIRE_1);
+            InitSpellMap(SHADOWFLAME_1);
+            InitSpellMap(FEAR_1);
+            InitSpellMap(HOWL_OF_TERROR_1);
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(SOULSHATTER_1);
+
+            InitSpellMap(DRAIN_SOUL_1);
+            InitSpellMap(DRAIN_MANA_1);
+            InitSpellMap(BANISH_1);
+
+            InitSpellMap(DEMON_SKIN_1);
+            InitSpellMap(DEMON_ARMOR_1);
+            InitSpellMap(FEL_ARMOR_1);
+            InitSpellMap(DETECT_INVISIBILITY_1);
+            InitSpellMap(UNENDING_BREATH_1);
+            InitSpellMap(SHADOW_WARD_1);
+            InitSpellMap(LIFE_TAP_1);
+            InitSpellMap(DARK_PACT_1);
+            InitSpellMap(CREATE_HEALTHSTONE_1);
+            InitSpellMap(CREATE_SOULSTONE_1);
+
+            InitSpellMap(RITUAL_OF_SUMMONING_1); //manual only
+            InitSpellMap(RITUAL_OF_SOULS_1); //not casted
+
+  /*Talent*/lvl >= 30 && isAffl ? InitSpellMap(CURSE_OF_EXHAUSTION_1) : RemoveSpell(CURSE_OF_EXHAUSTION_1);
+///*Talent*/lvl >= 50 && isAffl ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+  /*Talent*/lvl >= 60 && isAffl ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+
+  /*Talent*/lvl >= 20 && isDest ? InitSpellMap(SHADOWBURN_1) : RemoveSpell(SHADOWBURN_1);
+  /*Talent*/lvl >= 40 && isDest ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 50 && isDest ? InitSpellMap(SHADOWFURY_1) : RemoveSpell(SHADOWFURY_1);
+  /*Talent*/lvl >= 60 && isDest ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isAffl = _spec == BOT_SPEC_WARLOCK_AFFLICTION;
+            bool isDemo = _spec == BOT_SPEC_WARLOCK_DEMONOLOGY;
+            bool isDest = _spec == BOT_SPEC_WARLOCK_DESTRUCTION;
+
+            RefreshAura(CHAOS_BOLT_PASSIVE);
+            RefreshAura(DEMONIC_IMMOLATE_PASSIVE);
+
+            RefreshAura(IMPROVED_DRAIN_SOUL, level >= 15 ? 1 : 0);
+            RefreshAura(SOUL_SIPHON, level >= 15 ? 1 : 0);
+            RefreshAura(IMPROVED_FEAR, level >= 20 ? 1 : 0);
+            RefreshAura(NIGHTFALL, level >= 25 ? 1 : 0);
+            RefreshAura(SHADOW_EMBRACE, isAffl && level >= 30 ? 1 : 0);
+            RefreshAura(SIPHON_LIFE, isAffl && level >= 30 ? 1 : 0);
+            RefreshAura(ERADICATION, isAffl && level >= 40 ? 1 : 0);
+            RefreshAura(PANDEMIC, isAffl && level >= 50 ? 1 : 0);
+            RefreshAura(EVERLASTING_AFFLICTION, isAffl && level >= 55 ? 1 : 0);
+
+            RefreshAura(DEMONIC_RESILIENCE, isDemo && level >= 40 ? 1 : 0);
+            RefreshAura(DECIMATION, isDemo && level >= 45 ? 1 : 0);
+
+            RefreshAura(IMPROVED_SHADOW_BOLT, level >= 10 ? 1 : 0);
+            RefreshAura(AFTERMATH, level >= 15 ? 1 : 0);
+            RefreshAura(BACKLASH, level >= 30 ? 1 : 0);
+            RefreshAura(MOLTEN_CORE, isDest && level >= 35 ? 1 : 0);
+            RefreshAura(NETHER_PROTECTION, isDest && level >= 35 ? 1 : 0);
+            RefreshAura(SOUL_LEECH, isDest && level >= 40 ? 1 : 0);
+            RefreshAura(PYROCLASM, isDest && level >= 40 ? 1 : 0);
+            RefreshAura(IMPROVED_SOUL_LEECH, isDest && level >= 45 ? 1 : 0);
+            RefreshAura(BACKDRAFT, isDest && level >= 50 ? 1 : 0);
+
+            RefreshAura(GLYPH_CORRUPTION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_FEAR, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_QUICK_DECAY, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_CONFLAGRATE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_SHADOWFLAME, level >= 75 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case RAIN_OF_FIRE_1:
+                case SHADOWFLAME_1:
+                case HOWL_OF_TERROR_1:
+                case DETECT_INVISIBILITY_1:
+                case UNENDING_BREATH_1:
+                //case RITUAL_OF_SUMMONING_1:
+                case SHADOW_WARD_1:
+                case LIFE_TAP_1:
+                case DARK_PACT_1:
+                    return true;
+                //case FEL_ARMOR_1:
+                //    return true;
+                //case DEMON_ARMOR_1:
+                //    return !GetSpell(FEL_ARMOR_1);
+                //case DEMON_SKIN_1:
+                //    return !GetSpell(FEL_ARMOR_1) && !GetSpell(DEMON_ARMOR_1);
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Timers
+        uint32 fearTimer, banishTimer, unbanishTimer, drainManaTimer, healthstoneTimer, soulstoneTimer;
+        //Pet
+        uint32 myPetType;
+        uint32 petSummonTimer;
+        //Special
+        bool backlash, shadowtrance, backdraft, moltencore, chaoticmind;
+        bool canShadowWard;
+        bool longCasted, instaCast; //some sort of rotation thing
+        bool hasHealthstone, hasSoulstone;
+    };
+};
+
+//HealthstoneSpellIds (Improved Healthstone rank 2)
+uint32 const warlock_bot::warlock_botAI::_healthStoneSpells[8/*createHealthstoneRank*/] =
+{
+    23469,// Minor
+    23471,// Lesser
+    23473,//
+    23475,// Greater
+    23477,// Major
+    27237,// Master
+    47872,// Demonic
+    47877 // Fel
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..55084e1
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,2206 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "MovementDefines.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+
+#include "Formulas.h"
+/*
+Warrior NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 98%
+TODO:
+*/
+
+enum WarriorBaseSpells
+{
+    BATTLE_STANCE_1                         = 2457,
+    DEFENSIVE_STANCE_1                      = 71,
+    BERSERKER_STANCE_1                      = 2458,
+
+    INTIMIDATING_SHOUT_1                    = 5246,
+    ENRAGED_REGENERATION_1                  = 55694,
+    CHARGE_1                                = 100,
+    OVERPOWER_1                             = 7384,
+    TAUNT_1                                 = 355,
+    BLOODRAGE_1                             = 2687,
+    BERSERKER_RAGE_1                        = 18499,
+    INTERCEPT_1                             = 20252,
+    CLEAVE_1                                = 845,
+    HAMSTRING_1                             = 1715,
+    INTERVENE_1                             = 3411,
+    WHIRLWIND_1                             = 1680,
+    BLADESTORM_1                            = 46924,
+    BATTLE_SHOUT_1                          = 6673,
+    REND_1                                  = 772,
+    EXECUTE_1                               = 5308,
+    PUMMEL_1                                = 6552,
+    BLOODTHIRST_1                           = 23881,
+    MORTAL_STRIKE_1                         = 12294,
+    SLAM_1                                  = 1464,
+    SUNDER_ARMOR_1                          = 7386,
+    SWEEPING_STRIKES_1                      = 12328,
+    RECKLESSNESS_1                          = 1719,
+    RETALIATION_1                           = 20230,
+    DEATH_WISH_1                            = 12292,
+    VICTORY_RUSH_1                          = 34428,
+    THUNDER_CLAP_1                          = 6343,
+    LAST_STAND_1                            = 12975,
+    REVENGE_1                               = 6572,
+    SHIELD_BLOCK_1                          = 2565,
+    SHIELD_SLAM_1                           = 23922,
+    SPELL_REFLECTION_1                      = 23920,
+    DISARM_1                                = 676,
+    SHIELD_WALL_1                           = 871,
+    SHIELD_BASH_1                           = 72,
+    HEROIC_THROW_1                          = 57755,
+    CONCUSSION_BLOW_1                       = 12809,
+    VIGILANCE_1                             = 50720,
+    DEVASTATE_1                             = 20243,
+    MOCKING_BLOW_1                          = 694,
+    SHOCKWAVE_1                             = 46968,
+    PIERCING_HOWL_1                         = 12323,
+    HEROIC_STRIKE_1                         = 78,
+    CHALLENGING_SHOUT_1                     = 1161,
+    COMMANDING_SHOUT_1                      = 469,
+    SHATTERING_THROW_1                      = 64382,
+    DEMORALIZING_SHOUT_1                    = 1160,
+    HEROIC_FURY_1                           = 60970
+};
+enum WarriorPassives
+{
+//Talents
+    ARMORED_TO_THE_TEETH                    = 61222,//rank 3
+    SHIELD_SPECIALIZATION                   = 12727,//rank 5
+    DEEP_WOUNDS_1                           = 12834,
+    DEEP_WOUNDS_2                           = 12849,
+    DEEP_WOUNDS_3                           = 12867,
+    BLOOD_CRAZE1                            = 16487,
+    BLOOD_CRAZE2                            = 16489,
+    BLOOD_CRAZE3                            = 16492,
+    TOUGHNESS                               = 12764,//rank 5
+    TWO_HANDED_WEAPON_SPECIALIZATION        = 12712,//rank 3
+    TASTE_FOR_BLOOD1                        = 56636,
+    TASTE_FOR_BLOOD2                        = 56637,
+    TASTE_FOR_BLOOD3                        = 56638,
+    DUAL_WIELD_SPECIALIZATION               = 23588,//rank 5
+    IMPROVED_SPELL_REFLECTION               = 59089,//rank 2
+    SWORD_SPEC1                             = 12281,
+    SWORD_SPEC2                             = 12812,
+    SWORD_SPEC3                             = 12813,
+    SWORD_SPEC4                             = 12814,
+    SWORD_SPEC5                             = 12815,
+    IMPROVED_HAMSTRING                      = 23695,//rank 3
+    TRAUMA1                                 = 46854,
+    TRAUMA2                                 = 46855,
+    FLURRY1                                 = 12319,
+    FLURRY2                                 = 12971,
+    FLURRY3                                 = 12972,
+    FLURRY4                                 = 12973,
+    FLURRY5                                 = 12974,
+    ONE_HANDED_WEAPON_SPECIALIZATION        = 16542,//rank 5
+    SECOND_WIND                             = 29838,//rank 2
+    IMPROVED_DEFENSIVE_STANCE               = 29594,//rank 2
+    JUGGERNAUGHT                            = 64976,
+    FURIOUS_ATTACKS                         = 46911,//rank 2
+    SAFEGUARD                               = 46949,//rank 2
+    SUDDEN_DEATH                            = 29724,//rank 3
+    ENDLESS_RAGE                            = 29623,
+    BLOOD_FRENZY                            = 29859,
+    RAMPAGE                                 = 29801,
+    BLOODSURGE                              = 46915,//rank 3
+    WARBRINGER                              = 57499,
+    CRITICAL_BLOCK                          = 47296,//rank 3
+    WRECKING_CREW                           = 56614,//rank 5
+    DAMAGE_SHIELD                           = 58874,//rank 2
+//other
+    GLYPH_HEROIC_STRIKE                     = 58357,
+    GLYPH_REVENGE                           = 58364,
+    GLYPH_EXECUTION                         = 58367,
+    GLYPH_BLOCKING                          = 58375,
+    GLYPH_VIGILANCE                         = 63326,
+    GLYPH_DEVASTATE                         = 58388,
+
+    WARRIOR_T10_PROT_4P                     = 70844 //bloodrage absorb
+};
+enum WarriorSpecial
+{
+    STANCE_NONE                             = 0,
+    STANCE_BATTLE                           = 1,
+    STANCE_DEFENSIVE                        = 2,
+    STANCE_BERSERKER                        = 3,
+
+    TASTE_FOR_BLOOD_BUFF                    = 60503,
+    SWORD_AND_BOARD_BUFF                    = 50227,
+    BLOODSURGE_BUFF                         = 46916,//"Slam!"
+    JUGGERNAUGHT_BUFF                       = 65156,
+    GLYPH_REVENGE_BUFF                      = 58363,
+    UNRELENTING_ASSAULT_SPELL               = 64850,
+    VICTORIOUS_SPELL                        = 32216,
+    REVENGE_STUN_SPELL                      = 12798,
+    //SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+    VIGILANCE_PROC                          = 50725,
+    IMPROVED_BERSERKER_RAGE_EFFECT          = 23691,//rank 2
+    UNBRIDLED_WRATH_EFFECT                  = 12964,
+    SUNDER_ARMOR_DEBUFF                     = 58567,
+    GAG_ORDER_DEBUFF                        = 18498,//silence
+    //SUDDEN_DEATH_BUFF                       = 52437,
+    BLOODRAGE_PERIODIC_EFFECT               = 29131,
+
+    //VICTORIOUS_STATE_PASSIVE              = 32215,
+    BERSERKER_STANCE_PASSIVE                = 7381
+};
+
+static float rageIncomeMult;
+static float rageLossMult;
+
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct warrior_botAI : public bot_ai
+    {
+        warrior_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARRIOR;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        uint8 GetBotStance() const override
+        {
+            if (_inStance(1))
+                return WARRIOR_BATTLE_STANCE;
+            else if (_inStance(2))
+                return WARRIOR_DEFENSIVE_STANCE;
+            else if (_inStance(3))
+                return WARRIOR_BERSERKER_STANCE;
+
+            return BOT_STANCE_NONE;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override
+        {
+            //Victorious State spell
+            //only on targets which give xp or honor
+            if (u->GetLevel() > Trinity::XP::GetGrayLevel(me->GetLevel()))
+                me->CastSpell(me, VICTORIOUS_SPELL, true);
+
+            bot_ai::KilledUnit(u);
+        }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        //void modrage(int32 mod, bool set = false)
+        //{
+        //    if (set && mod < 0)
+        //        return;
+        //    if (mod < 0 && rage < abs(mod))
+        //    {
+        //        //debug set rage to 0
+        //        mod = 0;
+        //        set = true;
+        //        return;
+        //    }
+
+        //    if (set)
+        //        rage = mod ? mod*10 : 0;
+        //    else
+        //        rage += mod*10;
+
+        //    me->SetPower(POWER_RAGE, rage);
+        //}
+
+        void getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(CLEAVE_1)))
+                rage = std::max<int32>(rage - 200, 0);
+            else if (me->FindCurrentSpellBySpellId(GetSpell(HEROIC_STRIKE_1)))
+                rage = std::max<int32>(rage - rcost(HEROIC_STRIKE_1), 0);
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (IsSpellReady(HEROIC_FURY_1, diff) && Rand() < 55 &&
+                (CCed(me, true) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(me, GetSpell(HEROIC_FURY_1)))
+                    return;
+            }
+            if (IsSpellReady(BERSERKER_RAGE_1, diff) && Rand() < 45 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0) &&
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/
+                me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_KNOCKOUT)))
+            {
+                if (doCast(me, GetSpell(BERSERKER_RAGE_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (me->IsAlive())
+            {
+                if (ragetimer2 <= diff)
+                {
+                    ragetimer2 = 3000;
+                    //Anger Management
+                    if (me->IsInCombat() && me->GetLevel() >= 20)
+                    {
+                        if (me->GetPower(POWER_RAGE) < 990)
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) + uint32(10.f * rageIncomeMult)); //1 rage per 3 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000); //max
+                    }
+                }
+                if (ragetimer <= diff)
+                {
+                    ragetimer = 1500;
+                    if (!me->IsInCombat() &&
+                        !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_WARRIOR, 0x100))
+                    {
+                        if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0); //min
+                    }
+                }
+                getrage();
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 40)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            CheckShouts(diff);
+            CheckVigilance(diff);
+            CheckIntervene(diff);
+            CheckSpellReflect(diff);
+
+            if (me->IsInCombat())
+                CheckShatteringThrow(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget())
+            {
+                if (!me->IsInCombat() && stancetimer <= diff && Rand() < 5 && me->getAttackers().empty() && rage <= 250)
+                {
+                    uint8 mystance = 0;
+                    if (IsTank())
+                    {
+                        if (!_inStance(2))
+                            mystance = 2;
+                    }
+                    else
+                        mystance = 1;
+
+                    if (mystance)
+                        stanceChange(diff, mystance);
+                }
+                return;
+            }
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            StartAttack(opponent, IsMelee());
+
+            bool const isFury = _spec == BOT_SPEC_WARRIOR_FURY;
+            bool const isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+
+            //Keep stance in combat
+            if (stancetimer <= diff && Rand() < 10 + 15 * (me->GetPower(POWER_RAGE) <= 250))
+            {
+                uint8 mystance;
+                if (IsTank())
+                    mystance = 2;
+                else if (isFury && me->GetLevel() >= 30)
+                    mystance = 3;
+                else
+                    mystance = 1;
+
+                stanceChange(diff, mystance);
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && rage < 600 && Rand() < 20 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/)
+            {
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                    getrage();
+            }
+
+            getrage();
+
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && Rand() < 80 && GetHealthPCT(me) < 40 &&
+                rage >= rcost(ENRAGED_REGENERATION_1) && me->HasAuraWithMechanic(1<<MECHANIC_ENRAGED))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                    return;
+            }
+
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            float dist = me->GetDistance(opponent);
+
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && rage >= rcost(INTIMIDATING_SHOUT_1))
+            {
+                if (opponent->IsNonMeleeSpellCast(false, false, true) && dist < 5 &&
+                    opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD)
+                {
+                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                Unit::AttackerSet const& m_attackers = master->getAttackers();
+                Unit* fearTarget = nullptr;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->GetClass() != BOT_CLASS_DEATH_KNIGHT &&
+                    master->GetClass() != BOT_CLASS_WARRIOR &&
+                    master->GetClass() != BOT_CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for (Unit::AttackerSet::const_iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance((*iter)) < 7.5f)
+                            ++tCount;
+                        if (!fearTarget && me->GetDistance((*iter)) < 5)
+                            fearTarget = (*iter);
+                        if (fearTarget && tCount > 1)
+                            break;
+                    }
+                    if (fearTarget && tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                //Defend myself
+                if (b_attackers.size() > 1 && (!IsTank() || GetHealthPCT(me) < 50))
+                {
+                    tCount = 0;
+                    fearTarget = nullptr;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance((*iter)) < 7.5f)
+                            ++tCount;
+                        if (!fearTarget && me->GetDistance((*iter)) < 5)
+                            fearTarget = (*iter);
+                        if (fearTarget && tCount > 1)
+                            break;
+                    }
+                    if (fearTarget && tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+            }//end FEAR
+
+            //LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) &&
+                GetHealthPCT(me) < (30 + 20 * (b_attackers.size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                if (doCast(me, GetSpell(LAST_STAND_1)))
+                    return;
+            }
+
+            Unit const* u = opponent->GetVictim();
+
+            //TAUNT //No GCD
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && Rand() < 50 && dist < 30 &&
+                opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->GetClass()) && (GetHealthPCT(u) < 80 || _inStance(2))) || IsTank()) &&
+                IsInBotParty(u) &&
+                (_inStance(2) || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                if (doCast(opponent, GetSpell(TAUNT_1)))
+                    return;
+            }
+            //TAUNT 2 (distant)
+            if (IsSpellReady(TAUNT_1, diff, false) && u == me && Rand() < 35 && IsTank() &&
+                !(me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())) &&
+                (_inStance(2) || stancetimer <= diff))
+            {
+                Unit* tUnit = FindDistantTauntTarget();
+                if (tUnit && (_inStance(2) || (stancetimer <= diff && stanceChange(diff, 2))))
+                {
+                    if (doCast(tUnit, GetSpell(TAUNT_1)))
+                        return;
+                }
+            }
+            //CHARGE (warbringer)
+            if (IsSpellReady(CHARGE_1, diff, false) && !HasRole(BOT_ROLE_RANGED) && Rand() < 70 &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !(IsTank() && opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                dist > 8 && dist < CalcSpellMaxRange(CHARGE_1) &&
+                ((IsTank() && me->GetLevel() >= 50) ||
+                (!me->IsInCombat() && (_inStance(1) || (stancetimer <= diff && stanceChange(diff, 1))))))
+            {
+                if (doCast(opponent, GetSpell(CHARGE_1)))
+                    return;
+            }
+            //INTERCEPT (warbringer)
+            if (IsSpellReady(INTERCEPT_1, diff, false) && !HasRole(BOT_ROLE_RANGED) && HasRole(BOT_ROLE_DPS) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !(IsTank() && opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                //!me->HasUnitState(UNIT_STATE_CHARGING) &&
+                !(me->GetMotionMaster()->GetCurrentMovementGenerator() && me->GetMotionMaster()->GetCurrentMovementGenerator()->BaseUnitState == UNIT_STATE_CHARGING) && //not charging
+                (me->IsInCombat() || !IsSpellReady(CHARGE_1, diff, false)) &&
+                Rand() < 60 && dist > 10 && dist < 25 && !CCed(opponent) && rage >= rcost(INTERCEPT_1) &&
+                ((IsTank() && me->GetLevel() >= 50) ||
+                (!IsTank() && (_inStance(3) || (stancetimer <= diff && stanceChange(diff, 3))))))
+            {
+                if (doCast(opponent, GetSpell(INTERCEPT_1)))
+                    return;
+            }
+            //CHALLENGING SHOUT
+            if (IsSpellReady(CHALLENGING_SHOUT_1, diff) && Rand() < 40 &&
+                !(u == me && me->GetLevel() >= 40 && opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())) &&
+                rage >= rcost(CHALLENGING_SHOUT_1))
+            {
+                if (IsTank())
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f, 1);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+                if (u && u != me && !IsSpellReady(TAUNT_1, diff, false) && !IsTank(u) && !CCed(opponent) && dist < 9 &&
+                    (!IsTankingClass(u->GetClass()) || IsTank()) && IsInBotParty(u))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+            }
+
+            if (!CanAffectVictim(SPELL_SCHOOL_MASK_NORMAL))
+                return;
+
+            //BERSERKER RAGE (for rage)
+            if (IsSpellReady(BERSERKER_RAGE_1, diff) && Rand() < 15 && rage < 100/* && me->GetLevel() >= 35*/)
+            {
+                if (doCast(me, GetSpell(BERSERKER_RAGE_1)))
+                    return;
+            }
+            //MOCKING BLOW
+            if (IsSpellReady(MOCKING_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 70 && u && u != me &&
+                !IsTank(u) && dist < 5 && rage >= rcost(MOCKING_BLOW_1) &&
+                !CCed(opponent) && (!IsTankingClass(u->GetClass()) || IsTank()) && IsInBotParty(u) &&
+                (_inStance(4) || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(MOCKING_BLOW_1)))
+                    return;
+            }
+            //SHIELD SLAM
+            if (IsSpellReady(SHIELD_SLAM_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() &&
+                (_inStance(4) || stancetimer <= diff) && dist <= 5 && rage >= rcost(SHIELD_SLAM_1) &&
+                Rand() < (75 + 200*(me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_WARRIOR, 2780, 0) != nullptr)
+                /*me->HasAura(SWORD_AND_BOARD_BUFF)*/))
+            {
+                //check Shield Block
+                if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && (_inStance(2) || (IsTank() && stanceChange(diff, 2))))
+                {
+                    if (doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                    {}
+                }
+                if (_inStance(4) || stanceChange(diff, 4))
+                {
+                    if (doCast(opponent, GetSpell(SHIELD_SLAM_1)))
+                        return;
+                }
+            }
+            //SHIELD BLOCK
+            if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && CanBlock() && Rand() < 70 &&
+                (_inStance(2) || stancetimer <= diff) &&
+                ((u == me && dist < 8) || (!b_attackers.empty() && me->GetDistance2d(*(b_attackers.begin())) < 8)) &&
+                GetHealthPCT(me) < (65 + 8 * uint8(b_attackers.size())))
+            {
+                if ((_inStance(2) || stanceChange(diff, 2)) &&
+                    doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                    return;
+            }
+            //SHOCKWAVE - frontal cone
+            if (IsSpellReady(SHOCKWAVE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 8.f && !CCed(opponent) &&
+                rage >= rcost(SHOCKWAVE_1) && Rand() < (70 + 70 * opponent->IsNonMeleeSpellCast(false)) &&
+                me->HasInArc(M_PI/2, opponent) && opponent->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(SHOCKWAVE_1)))
+                    return;
+            }
+            //HEROIC THROW
+            if (IsSpellReady(HEROIC_THROW_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 &&
+                (opponent->GetTypeId() == TYPEID_UNIT || dist > 6) &&
+                Rand() < (20 - 15 * CanBlock() + 90 * opponent->IsNonMeleeSpellCast(false,false,true)))
+            {
+                if (doCast(opponent, GetSpell(HEROIC_THROW_1)))
+                    return;
+            }
+            //THUNDER CLAP
+            if (IsSpellReady(THUNDER_CLAP_1, diff) && HasRole(BOT_ROLE_DPS) && !isFury && Rand() < 40 &&
+                (_inStance(4) || stancetimer <= diff) && dist < 7.5f && rage >= rcost(THUNDER_CLAP_1) &&
+                ((IsTank() && b_attackers.size() > 1) ||
+                (opponent->GetHealth() > me->GetMaxHealth() / 2 &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_WARRIOR, 0x80)) ||
+                FindSplashTarget(7.5f, opponent, 15.f)))
+            {
+                if (_inStance(4) || (me->GetLevel() >= 20 && stanceChange(diff, 4)))
+                {
+                    if (doCast(me, GetSpell(THUNDER_CLAP_1)))
+                        return;
+                }
+            }
+            //REVENGE
+            if (IsSpellReady(REVENGE_1, diff) && HasRole(BOT_ROLE_DPS) && IsTank() && me->HasReactive(REACTIVE_DEFENSE) &&
+                Rand() < 150 && (_inStance(2) || stancetimer <= diff) && dist < 5 && rage >= rcost(REVENGE_1))
+            {
+                if (_inStance(2) || stanceChange(diff, 2))
+                {
+                    if (doCast(opponent, GetSpell(REVENGE_1)))
+                        return;
+                }
+            }
+            //CONCUSSION BLOW
+            if (IsSpellReady(CONCUSSION_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent) &&
+                dist < 5 && rage >= rcost(CONCUSSION_BLOW_1) &&
+                opponent->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2 &&
+                Rand() < (30 + 60 * opponent->IsNonMeleeSpellCast(false,false,true)))
+            {
+                if (doCast(opponent, GetSpell(CONCUSSION_BLOW_1)))
+                    return;
+            }
+
+            MoveBehind(opponent);
+
+            //SHIELD BASH - shared cd with pummel
+            if (IsSpellReady(SHIELD_BASH_1, diff, false) && CanBlock() && Rand() < 80 &&
+                (_inStance(4) || stancetimer <= diff) &&
+                dist < 5 && rage >= rcost(SHIELD_BASH_1) && opponent->IsNonMeleeSpellCast(false,false,true))
+            {
+                if ((_inStance(4) || stanceChange(diff, 4)) &&
+                    doCast(opponent, GetSpell(SHIELD_BASH_1)))
+                    return;
+            }
+            //PUMMEL - shared cd with shield bash
+            if (IsSpellReady(PUMMEL_1, diff, false) && !IsTank() && !CanBlock() && Rand() < 80 &&
+                dist < 5 && (_inStance(3) || stancetimer <= diff) &&
+                rage >= rcost(PUMMEL_1) && opponent->IsNonMeleeSpellCast(false,false,true))
+            {
+                if ((_inStance(3) || stanceChange(diff, 3)) &&
+                    doCast(opponent, GetSpell(PUMMEL_1)))
+                    return;
+            }
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && Rand() < 70 && (_inStance(5) || stancetimer <= diff) &&
+                (!GetSpell(PIERCING_HOWL_1) || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                (opponent->isMoving() || opponent->GetTypeId() == TYPEID_PLAYER) && dist < 5 && rage >= rcost(HAMSTRING_1) &&
+                !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (_inStance(5) || (me->GetLevel() >= 15 && stanceChange(diff, 5)))
+                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //PIERCING HOWL
+            if (IsSpellReady(PIERCING_HOWL_1, diff) && opponent->isMoving() && Rand() < 80 &&
+                dist < 9 && rage >= rcost(PIERCING_HOWL_1) && !opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(me, GetSpell(PIERCING_HOWL_1)))
+                    return;
+            }
+            //DISARM
+            if (IsSpellReady(DISARM_1, diff) && dist < 5 && (_inStance(2) || stancetimer <= diff) &&
+                Rand() < (35 + 55*opponent->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 8 * (1 + opponent->getAttackers().size()) &&
+                rage >= rcost(DISARM_1))
+            {
+                //check weapons
+                bool hasWeapon = true;
+                if (opponent->GetTypeId() == TYPEID_UNIT && !opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
+                    hasWeapon = false;
+                else if (Player const* pla = opponent->ToPlayer())
+                    if (!pla->GetWeaponForAttack(BASE_ATTACK) || !pla->IsUseEquipedWeapon(true))
+                        hasWeapon = false;
+
+                if (hasWeapon && (_inStance(2) || stanceChange(diff, 2)) &&
+                    doCast(opponent, GetSpell(DISARM_1)))
+                    return;
+            }
+            //DEMORALIZING SHOUT
+            if (IsSpellReady(DEMORALIZING_SHOUT_1, diff) && Rand() < 15 + 25 * IsTank() && dist < 10 &&
+                (opponent->GetClass() == CLASS_WARRIOR || opponent->GetClass() == CLASS_ROGUE ||
+                (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 8 * (1 + opponent->getAttackers().size()) &&
+                rage >= rcost(DEMORALIZING_SHOUT_1) &&
+                !opponent->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_ATTACK_POWER, SPELLFAMILY_WARRIOR, 0x20000))
+            {
+                if (doCast(me, GetSpell(DEMORALIZING_SHOUT_1)))
+                    return;
+            }
+
+            //UBERS
+            //Shield Wall
+            if (IsSpellReady(SHIELD_WALL_1, diff, false) && CanBlock() &&
+                GetHealthPCT(me) < (30 + 4 * b_attackers.size() + 20 * (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss())) &&
+                (_inStance(2) || stanceChange(diff, 2)))
+            {
+                if (doCast(me, GetSpell(SHIELD_WALL_1)))
+                    return;
+            }
+            //Retaliation
+            if (IsSpellReady(RETALIATION_1, diff) && HasRole(BOT_ROLE_DPS) && !CanBlock() && Rand() < 40 &&
+                !me->HasAuraType(SPELL_AURA_MOD_DISARM) && b_attackers.size() > 4 &&
+                (_inStance(1) || stanceChange(diff, 1)))
+            {
+                if (doCast(me, GetSpell(RETALIATION_1)))
+                    return;
+            }
+            //Recklessness
+            if (IsSpellReady(RECKLESSNESS_1, diff) && HasRole(BOT_ROLE_DPS) && !CanBlock() && !IsTank() && Rand() < 60 &&
+                GetHealthPCT(me) > 50 && (_inStance(3) || stancetimer <= diff) && b_attackers.size() < 2 &&
+                (opponent->GetHealth() > me->GetHealth()/2 * (1 + opponent->getAttackers().size()) || opponent->IsControlledByPlayer()) &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/ &&
+                (_inStance(3) || stanceChange(diff, 3)))
+            {
+                if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    return;
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATH_WISH_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 70 &&
+                dist < 15 && rage >= rcost(DEATH_WISH_1) &&
+                opponent->GetHealth() > me->GetHealth()/4 * (1 + opponent->getAttackers().size()) &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/)
+            {
+                if (doCast(me, GetSpell(DEATH_WISH_1)))
+                    return;
+            }
+
+            //VICTORY RUSH
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 70 && dist < 5 && _inStance(5) &&
+                me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_WARRIOR, 0x0, 0x40000, 0x0))
+            {
+                if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
+                    return;
+            }
+            //DEVASTATE - only with shield
+            if (IsSpellReady(DEVASTATE_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && Rand() < 100 &&
+                dist < 5 && rage >= rcost(DEVASTATE_1))
+            {
+                if (doCast(opponent, GetSpell(DEVASTATE_1)))
+                    return;
+            }
+            //SUNDER ARMOR
+            if (IsSpellReady(SUNDER_ARMOR_1, diff) && IsTank() && Rand() < 55 && opponent->GetHealth() > me->GetMaxHealth() &&
+                dist < 5 && (!HasRole(BOT_ROLE_DPS) || !GetSpell(DEVASTATE_1)) && rage >= rcost(SUNDER_ARMOR_1))
+            {
+                AuraEffect const* sunder = opponent->GetAuraEffect(SUNDER_ARMOR_DEBUFF, 0);
+                if ((!sunder || sunder->GetBase()->GetStackAmount() < 5 || sunder->GetBase()->GetDuration() < 20000) &&
+                    doCast(opponent, GetSpell(SUNDER_ARMOR_1)))
+                    return;
+            }
+            //SWEEPING STRIKES //no GCD
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 65 &&
+                (_inStance(5) || stancetimer <= diff) && rage >= rcost(SWEEPING_STRIKES_1) &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                if ((_inStance(5) || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1)))
+                    getrage();
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                opponent->GetHealth() > me->GetMaxHealth() / 4 * (1 + opponent->getAttackers().size()) &&
+                (isArms || opponent->GetClass() == CLASS_ROGUE || opponent->GetShapeshiftForm() == FORM_CAT) &&
+                dist < 5 && rage >= rcost(REND_1) && opponent->GetCreatureType() != CREATURE_TYPE_MECHANICAL &&
+                !(opponent->GetTypeId() == TYPEID_UNIT &&
+                (opponent->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_BLEED-1)))) &&
+                !opponent->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARRIOR, 0x20, 0x0, 0x0, me->GetGUID()) &&
+                (_inStance(4) || (me->GetLevel() >= 15 && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(REND_1)))
+                    return;
+            }
+            //BLOODTHIRST
+            if (IsSpellReady(BLOODTHIRST_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                dist < 5 && rage >= rcost(BLOODTHIRST_1))
+            {
+                if (doCast(opponent, GetSpell(BLOODTHIRST_1)))
+                    return;
+            }
+            //MORTAL STRIKE
+            if (IsSpellReady(MORTAL_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && !CanBlock() &&
+                dist < 5 && rage >= rcost(MORTAL_STRIKE_1))
+            {
+                if (doCast(opponent, GetSpell(MORTAL_STRIKE_1)))
+                    return;
+            }
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && (!isFury || rage < 250) &&
+                (_inStance(1) || stancetimer <= diff) && dist < 5 && rage >= rcost(OVERPOWER_1) &&
+                (me->HasReactive(REACTIVE_OVERPOWER) ||
+                me->GetAuraEffect(SPELL_AURA_ABILITY_IGNORE_AURASTATE, SPELLFAMILY_WARRIOR, 2961, 0)
+                /*me->HasAura(TASTE_FOR_BLOOD_BUFF)*/))
+            {
+                if (_inStance(1) || (me->GetLevel() >= 15 && stanceChange(diff, 1)))
+                {
+                    if (doCast(opponent, GetSpell(OVERPOWER_1)))
+                        return;
+                }
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() &&
+               dist < 10 && rage >= rcost(BLADESTORM_1) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetHealth() / 3 * (1 + opponent->getAttackers().size()) ||
+               opponent->IsControlledByPlayer()) &&
+               (Rand() < 50 || me->HasAuraTypeWithFamilyFlags(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARRIOR, 0x10)
+               /*me->HasAura(RECKLESSNESS_1)*/) &&
+               (me->GetMap()->IsDungeon() || opponent->GetMaxHealth() > me->GetMaxHealth() * 8 || CCed(opponent, true) || opponent->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                    return;
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() && Rand() < 80 &&
+                (isFury || opponent->IsControlledByPlayer() || me->GetLevel() < 60 || !me->GetMap()->IsDungeon()) &&
+                (_inStance(3) || stancetimer <= diff) && dist < 7.f &&
+                rage >= rcost(WHIRLWIND_1) && (isFury || rage >= 500 || FindSplashTarget(7.f, opponent, 15.f)))
+            {
+                if ((_inStance(3) || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                    return;
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 110 &&
+                (isFury || !me->GetMap()->IsRaid()) &&
+                (opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) ||
+                me->GetAuraEffect(SPELL_AURA_ABILITY_IGNORE_AURASTATE, SPELLFAMILY_WARRIOR, 0x0, 0x2000000, 0x0)) &&
+                dist < 5 && rage >= rcost(EXECUTE_1) &&
+                (_inStance(5) || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, GetSpell(EXECUTE_1)))
+                    return;
+            }
+            //SLAM only with improved, has SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS
+            if (IsSpellReady(SLAM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() &&
+                me->GetLevel() >= 40 && dist < 5 && rage >= rcost(SLAM_1) &&
+                ((isArms && !opponent->isMoving() && me->getAttackTimer(BASE_ATTACK) > 500) ||
+                me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_WARRIOR, 0x0, 0x1000000, 0x0))
+                /*me->HasAura(BLOODSURGE_BUFF)*/)
+            {
+                if (doCast(opponent, GetSpell(SLAM_1)))
+                    return;
+            }
+
+            //skip if already have cleave of heroic strike casted
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 70 &&
+                dist < 5 && (!IsTank() || rage >= 500) && rage >= rcost(CLEAVE_1) && FindSplashTarget())
+            {
+                if (doCast(opponent, GetSpell(CLEAVE_1)))
+                    return;
+            }
+            //HEROIC STRIKE
+            if (IsSpellReady(HEROIC_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 55 && rage >= 350 &&
+                dist < 5 && (isFury || IsTank() || rage >= 650) && rage >= rcost(HEROIC_STRIKE_1))
+            {
+                if (doCast(opponent, GetSpell(HEROIC_STRIKE_1)))
+                    return;
+            }
+        }
+
+        void CheckShouts(uint32 diff)
+        {
+            if (shoutCheckTimer > diff || GC_Timer > diff || Rand() > 35 || me->IsMounted() || IsCasting() ||
+                (rage < rcost(BATTLE_SHOUT_1) && !IsSpellReady(BLOODRAGE_1, diff, false)))
+                return;
+
+            shoutCheckTimer = urand(3000, 5000);
+
+            if (IAmFree())
+            {
+                if (GetSpell(BATTLE_SHOUT_1) &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_ATTACK_POWER, SPELLFAMILY_WARRIOR, 0x10000)
+                    /*!HasAuraName(me, BATTLE_SHOUT_1, me->GetGUID())*/)
+                {
+                    if (rage < rcost(BATTLE_SHOUT_1))
+                    {
+                        if (IsSpellReady(BLOODRAGE_1, diff, false))
+                        {
+                            if (doCast(me, GetSpell(BLOODRAGE_1)))
+                            {}
+                            else
+                                return;
+                        }
+                        else
+                            return;
+                    }
+                    if (doCast(me, GetSpell(BATTLE_SHOUT_1)))
+                        return;
+                }
+
+                return;
+            }
+
+            if (me->GetDistance(master) > 30)
+                return;
+
+            AuraApplication const* bs = me->GetAuraApplicationOfRankedSpell(BATTLE_SHOUT_1);
+            AuraApplication const* cs = me->GetAuraApplicationOfRankedSpell(COMMANDING_SHOUT_1);
+
+            bool hasBS = bs && bs->GetBase()->GetDuration() >= 30000 && bs->GetBase()->GetId() >= GetSpell(BATTLE_SHOUT_1);
+            bool hasCS = cs && cs->GetBase()->GetDuration() >= 30000 && cs->GetBase()->GetId() >= GetSpell(COMMANDING_SHOUT_1);
+
+            if (hasCS && hasBS)
+                return;
+
+            bool battleshout = !hasBS && (!cs || cs->GetBase()->GetCasterGUID() != me->GetGUID()) &&
+                (!IsTank(me) || !GetSpell(COMMANDING_SHOUT_1)) && GetSpell(BATTLE_SHOUT_1);
+            bool commandingshout = !hasCS && (!bs || bs->GetBase()->GetCasterGUID() != me->GetGUID()) &&
+                GetSpell(COMMANDING_SHOUT_1);
+
+            if (battleshout && !hasCS && !HasRole(BOT_ROLE_DPS) && GetSpell(COMMANDING_SHOUT_1))
+            {
+                battleshout = false;
+                commandingshout = true;
+            }
+
+            if (battleshout || commandingshout)
+            {
+                if (rage < rcost(BATTLE_SHOUT_1) && IsSpellReady(BLOODRAGE_1, diff, false) &&
+                    doCast(me, GetSpell(BLOODRAGE_1)))
+                    getrage();
+
+                if ((battleshout && doCast(me, GetSpell(BATTLE_SHOUT_1))) ||
+                    (commandingshout && doCast(me, GetSpell(COMMANDING_SHOUT_1))))
+                    return;
+            }
+        }
+
+        void CheckVigilance(uint32 diff)
+        {
+            if (vigiCheckTimer > diff || Rand() > 30 || !IsSpellReady(VIGILANCE_1, diff) || me->IsInCombat() ||
+                me->IsMounted() || IsCasting())
+                return;
+
+            vigiCheckTimer = urand(1000, 3000);
+            uint32 VIGILANCE = GetSpell(VIGILANCE_1);
+
+            Unit* u = vigilanceTargetGuid ? ObjectAccessor::GetUnit(*me, vigilanceTargetGuid) : nullptr;
+
+            if (u)
+            {
+                bool myVig = u->HasAura(VIGILANCE, me->GetGUID());
+                if (!IsTank() || !myVig)
+                {
+                    if (myVig)
+                        u->RemoveAura(VIGILANCE, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                    vigilanceTargetGuid = ObjectGuid::Empty;
+                }
+                return;
+            }
+            else if (vigilanceTargetGuid)
+                vigilanceTargetGuid = ObjectGuid::Empty;
+
+            if (IAmFree() || !IsTank())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (gr)
+            {
+                //tanks
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pPlayer = itr->GetSource();
+                    if (!pPlayer || !pPlayer->IsInWorld()) continue;
+                    if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                    if (pPlayer->IsAlive() && IsTankingClass(pPlayer->GetClass()) && me->GetDistance(pPlayer) < 30 &&
+                        !pPlayer->HasAura(VIGILANCE) && !pPlayer->HasAura(DAMAGE_REDUCTION))
+                    {
+                        u = pPlayer;
+                        break;
+                    }
+                }
+                if (!u)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* cre = it->second;
+                            if (!cre || cre == me || !cre->IsInWorld() || !cre->IsAlive()) continue;
+                            if (cre->GetBotAI()->HasRole(BOT_ROLE_TANK) &&
+                                me->GetDistance(cre) < 30 && !cre->HasAura(VIGILANCE) && !cre->HasAura(DAMAGE_REDUCTION))
+                            {
+                                u = cre;
+                                break;
+                            }
+                        }
+                    }
+                }
+                //any players
+                if (!u)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer == master) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->IsAlive() && me->GetDistance(pPlayer) < 30 &&
+                            !pPlayer->HasAura(VIGILANCE))
+                        {
+                            u = pPlayer;
+                            break;
+                        }
+                    }
+                }
+                //damage-dealing bots
+                if (!u)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* cre = it->second;
+                            if (!cre || cre == me || !cre->IsInWorld() || !cre->IsAlive() || cre->IsTempBot()) continue;
+                            if (cre->GetBotAI()->HasRole(BOT_ROLE_DPS) && me->GetDistance(cre) < 30 &&
+                                !cre->HasAura(VIGILANCE))
+                            {
+                                u = cre;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (!u && master->IsAlive() && me->IsWithinDistInMap(master, 30) && !master->HasAura(VIGILANCE))
+                u = master;
+
+            if (u && doCast(u, VIGILANCE))
+                return;
+        }
+
+        void CheckIntervene(uint32 diff)
+        {
+            //lvl 70 - warbringer always present
+            if (IsSpellReady(INTERVENE_1, diff, false) && !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !me->IsMounted() && rage >= rcost(INTERVENE_1) &&
+                !IAmFree() && !IsCasting() && Rand() < (IsTank() ? 40 : 80))
+            {
+                if (!me->GetVictim() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetDistance(master);
+                    if (mydist < 25 && mydist > 18)
+                    {
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                            return;
+                    }
+                }
+                Group const* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float mydist = me->GetDistance(master);
+                        if (mydist < 25 && mydist > 8)
+                        {
+                            if (doCast(master, GetSpell(INTERVENE_1)))
+                                return;
+                        }
+                    }
+                }
+                else if (!IsTank() || !me->GetVictim())
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || tPlayer->IsBeingTeleported() || tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (!tPlayer->IsAlive() || GetHealthPCT(tPlayer) > 70 ||
+                            tPlayer->HasAuraType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetDistance(tPlayer);
+                        if (dist > 25 || dist < 8) continue;
+
+                        if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                            return;
+                    }
+                    if (!Bots) return;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot() || tPlayer->IsBeingTeleported() || tPlayer->FindMap() != me->GetMap()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (bot == me || !bot->IsInWorld() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                            if (GetHealthPCT(bot) > (70 - 30 * IsTank(bot)) ||
+                                bot->HasAuraType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER)) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            dist = me->GetDistance(bot);
+                            if (dist > 25 || dist < 8) continue;
+
+                            if (doCast(bot, GetSpell(INTERVENE_1)))
+                                return;
+                        }
+                    }
+                }
+
+                SetSpellCooldown(INTERVENE_1, 500); //fail
+            }
+        }
+
+        void CheckSpellReflect(uint32 diff)
+        {
+            if (!IsSpellReady(SPELL_REFLECTION_1, diff, false) || me->IsMounted() || IsCasting() ||
+                !CanBlock() || !(_inStance(4) || stancetimer <= diff) ||
+                rage < rcost(SPELL_REFLECTION_1) || Rand() > 75)
+                return;
+
+            //use first match (covers most cases)
+            if (Unit const* target = FindCastingTarget(70))
+            {
+                if (Spell const* spell = target->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->GetTimer() < 500/*(4500 - 4000 * (target->GetTypeId() == TYPEID_PLAYER))*/ &&
+                        !spell->GetSpellInfo()->IsChanneled() &&
+                        spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                        !(spell->GetSpellInfo()->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)) &&
+                        !(spell->GetSpellInfo()->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                        !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive())
+                    {
+                        if (Unit const* u = spell->m_targets.GetUnitTarget())
+                        {
+                            if ((IAmFree() ? (u == me) : (master->GetGroup() && master->GetGroup()->IsMember(spell->m_targets.GetObjectTargetGUID()))) &&
+                                me->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS) < 100)
+                            {
+                                if ((_inStance(4) || (stancetimer <= diff && stanceChange(diff, 4))) &&
+                                    doCast(me, GetSpell(SPELL_REFLECTION_1)))
+                                    return;
+                            }
+                        }
+                    }
+                }
+            }
+
+            SetSpellCooldown(SPELL_REFLECTION_1, urand(250, 500)); //fail
+        }
+
+        void CheckShatteringThrow(uint32 diff)
+        {
+            if (!IsSpellReady(SHATTERING_THROW_1, diff) || shatterCheckTimer > diff ||
+                !(_inStance(1) || stancetimer <= diff) || rage < rcost(SHATTERING_THROW_1) ||
+                me->getAttackers().size() > 2 || Rand() > 50)
+                return;
+
+            shatterCheckTimer = urand(500, 1000);
+
+            Unit* unit = FindImmunityShieldDispelTarget();
+            if (unit && me->GetDistance(unit) < 30 && (_inStance(1) || (stancetimer <= diff && stanceChange(diff, 1))))
+                if (doCast(unit, GetSpell(SHATTERING_THROW_1)))
+                    return;
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (stancetimer > diff)
+                return false;
+
+            if (stance == 5)
+                stance = (me->GetLevel() >= 30 && !IsTank()) ? 3 : 1;
+            else if (stance == 4)
+                stance = me->GetLevel() >= 10 && IsTank() ? 2 : 1;
+
+            if (stance == 2 && me->GetLevel() < 10)
+                return false;
+            if (stance == 3 && me->GetLevel() < 30)
+                return false;
+
+            if (_inStance(stance))
+                return true;
+
+            rage = me->GetPower(POWER_RAGE);
+            switch (stance)
+            {
+                case 1:
+                    return doCast(me, BATTLE_STANCE_1);
+                case 2:
+                    return doCast(me, DEFENSIVE_STANCE_1);
+                case 3:
+                    return doCast(me, BERSERKER_STANCE_1);
+                default:
+                    return false;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            float pctbonus = 1.0f;
+
+            if (damageinfo.HitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (_spec == BOT_SPEC_WARRIOR_ARMS && me->GetLevel() >= 30)
+                    if (Item const* weap = GetEquips(uint8(damageinfo.AttackType)))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus *= 1.025f;
+            }
+
+            damageinfo.Damages[0].Damage *= pctbonus;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType attackType) const override
+        {
+            if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+                return;
+
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Recklessness: 100% additional critical chance for damaging abilities
+            if (AuraEffect const* eff = me->GetAuraEffect(RECKLESSNESS_1, EFFECT_0))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+            //Juggernaught: 25 additional critical chance for Mortal Strike and Slam
+            if (lvl >= 45 && (baseId == SLAM_1 || baseId == MORTAL_STRIKE_1))
+                if (AuraEffect const* jugg = me->GetAuraEffect(JUGGERNAUGHT_BUFF, 0))
+                    if (jugg->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 25.f;
+
+            //Poleaxe Specialization: 5% additional critical chance for all attacks
+            if (_spec == BOT_SPEC_WARRIOR_ARMS && lvl >= 30)
+                if (Item const* weap = GetEquips(uint8(attackType)))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                            crit_chance += 5.f;
+
+            //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+            if (((_spec == BOT_SPEC_WARRIOR_PROTECTION && lvl >= 15) ||
+                ((_spec == BOT_SPEC_WARRIOR_ARMS || _spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 75)) &&
+                (baseId == CLEAVE_1 || baseId == HEROIC_STRIKE_1 || baseId == THUNDER_CLAP_1))
+                crit_chance += 15.f;
+            //Improved Overpower: 50% additional critical chance for Overpower
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) && lvl >= 20 && baseId == OVERPOWER_1)
+                crit_chance += 50.f;
+            //Critical Block: 15% additional critical chance for Shield Slam
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 50 && baseId == SHIELD_SLAM_1)
+                crit_chance += 15.f;
+            //Sword and Board: 15% additional critical chance for Devastate
+            if (lvl >= 55 && baseId == DEVASTATE_1)
+                crit_chance += 15.f;
+
+            //Glypg of Victory Rush: 30% additional critical chance for Victory Rush
+            if (lvl >= 15 && baseId == VICTORY_RUSH_1)
+                crit_chance += 30.f;
+
+            //Warrior T8 Protection Bonus (id: 64933): 10% additional critical chance for Devastate (tanks only)
+            if (lvl >= 78 && baseId == DEVASTATE_1)
+                crit_chance += 10.f;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            // apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus *= 1.1f;
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 30)
+                    if (Item const* weap = GetEquips(uint8(attackType)))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus *= 1.025f;
+            }
+
+            //Improved Shield Slam (id: 38407): 10% bonus damage for Shield Slam
+            //if (lvl >= 50 && baseId == SHIELD_SLAM_1)
+            //    pctbonus *= 1.1f;
+            //Shield Slam Damage Up (id: 60173): 10% bonus damage for Shield Slam
+            //if (lvl >= 70 && baseId == SHIELD_SLAM_1)
+            //    pctbonus *= 1.1f;
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (lvl >= 10 && baseId == REND_1)
+                pctbonus *= 1.2f;
+            //Improved Thunder Clap (part 2): 30% bonus damage for Thunder Clap
+            if (lvl >= 10 && baseId == THUNDER_CLAP_1)
+                pctbonus *= 1.3f;
+            //Improved Revenge (part 1): 60% bonus damage for Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 20 && baseId == REVENGE_1)
+                pctbonus *= 1.6f;
+            //Gag Order (part 2): 10% bonus damage for Shield Slam
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 30 && baseId == SHIELD_SLAM_1)
+                pctbonus *= 1.1f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 40 && baseId == WHIRLWIND_1)
+                pctbonus *= 1.2f;
+            //Improved Mortal Strike (part 1): 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && baseId == MORTAL_STRIKE_1)
+                pctbonus *= 1.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                pctbonus *= 1.2f;
+            //Unending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 55 && (baseId == WHIRLWIND_1 || baseId == SLAM_1 || baseId == BLOODTHIRST_1))
+                pctbonus *= 1.1f;
+
+            //Glyph of Mocking Blow: 25% bonus damage for Mocking Blow
+            if (lvl >= 16 && baseId == MOCKING_BLOW_1)
+                pctbonus *= 1.25f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && baseId == MORTAL_STRIKE_1)
+                pctbonus *= 1.1f;
+
+            //Warrior T9 Protection 2P Bonus (id: 67269): 5% bonus damage for Devastate
+            if (lvl >= 77 && baseId == DEVASTATE_1)
+                pctbonus *= 1.05f;
+            //Warrior T10 Protection 2P Bonus (id: 70843): 20% bonus damage for Shield Slam and Shockwave
+            if (lvl >= 78 && (baseId == SHIELD_SLAM_1 || baseId == SHOCKWAVE_1))
+                pctbonus *= 1.2f;
+
+            //Improved Cleave: 120% increased '!bonus damage!' done by Cleave (flat mod)
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 25 && baseId == CLEAVE_1)
+            {
+                float bp = spellInfo->Effects[EFFECT_0].BasePoints; //SPELL_EFFECT_WEAPON_DAMAGE (values: 15 - 222)
+                fdamage += bp * 1.2;
+            }
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            //float pctbonus = 1.0f;
+
+            //100% mods
+            //Sword and Board: -100% rage cost for Shield Slam
+            if (baseId == SHIELD_SLAM_1 && me->HasAura(SWORD_AND_BOARD_BUFF))
+                fcost = 0;
+
+            //Glyph of Bloodrage: -100% health cost for Bloodrage
+            if (lvl >= 15 && baseId == BLOODRAGE_1)
+                fcost = 0;
+            //Glyph of Revenge: -100% rage cost for Heroic Strike
+            if (lvl >= 15 && baseId == HEROIC_STRIKE_1 && me->HasAura(GLYPH_REVENGE_BUFF))
+                fcost = 0;
+            //Glyph of Sweeping Strikes: -100% rage cost for Sweeping Strikes
+            if (lvl >= 30 && baseId == SWEEPING_STRIKES_1)
+                fcost = 0;
+
+            //flat mods
+            //Improved Hamstring (id: 24428): -2 rage cost for Hamstring
+            if (lvl >= 25 && baseId == HAMSTRING_1)
+                fcost -= 20;
+            //Bloodthirst and Mortal Strike Discount (id: 37535): -5 rage cost for Bloodthirst and Mortal Strike
+            if (lvl >= 40 && (baseId == BLOODTHIRST_1 || baseId == MORTAL_STRIKE_1))
+                fcost -= 50;
+
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            if (lvl >= 10 && baseId == HEROIC_STRIKE_1)
+                fcost -= 30;
+            //Improved Thunder Clap (part 1): -4 rage cost for Thunder Clap
+            if (lvl >= 10 && baseId == THUNDER_CLAP_1)
+                fcost -= 40;
+            //Improved Execute: -5 rage cost for Execute
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 25 && baseId == EXECUTE_1)
+                fcost -= 50;
+            //Puncture: -3 rage cost for Sunder Armor and Devastate
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 25 && (baseId == SUNDER_ARMOR_1 || baseId == DEVASTATE_1))
+                fcost -= 30;
+            //Focused Rage: -3 rage cost for all offensive abilities (using rage)
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 40 && ((spellInfo->SpellFamilyFlags[0] & 0x6E6E4EEE) || (spellInfo->SpellFamilyFlags[1] & 0x40E664)))
+                fcost -= 30;
+
+            //Glyph of Resonating Power: -5 rage cost for Thunder Clap
+            if (lvl >= 15 && baseId == THUNDER_CLAP_1)
+                fcost -= 50;
+            //Glyph of Shockwave: -3 rage cost for Shockwave
+            if (lvl >= 60 && baseId == SHOCKWAVE_1)
+                fcost -= 30;
+
+            //cost can be < 0
+            cost = int32(fcost/* * pctbonus*/);
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            //int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Bloodsurge: -100% cast time for Slam
+            if (baseId == SLAM_1 && me->HasAura(BLOODSURGE_BUFF))
+                casttime = 0;
+
+            //flat mods
+            //Improved Slam: -1.0 sec cast time for Slam
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 40 && baseId == SLAM_1)
+                casttime -= 1000;
+
+            casttime = std::max<int32>(casttime, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 40 &&
+                (baseId == BLOODRAGE_1 || baseId == BERSERKER_RAGE_1 || baseId == RECKLESSNESS_1 || baseId == DEATH_WISH_1))
+                pctbonus *= 0.67f;
+
+            //flat mods
+            //zzzOLDImproved Challenging Shout (id: 12327): -2 min cooldown for Challenging Shout (tanks only)
+            if (lvl >= 30 && IsTank() && baseId == CHALLENGING_SHOUT_1)
+                cooldown -= 120000;
+
+            //Shield Mastery (part 2): -20 sec cooldown for Shield Block
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 20 && baseId == SHIELD_BLOCK_1)
+                cooldown -= 20000;
+            //Improved Disciplines: -60 sec cooldown for Shield Wall, Retaliation and Recklessness
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 35 && (baseId == SHIELD_WALL_1 || baseId == RETALIATION_1 || baseId == RECKLESSNESS_1))
+                cooldown -= 60000;
+
+            //Glyph of Bladestorm: -15 sec cooldown for Bladestorm
+            if (lvl >= 60 && baseId == BLADESTORM_1)
+                cooldown -= 15000;
+            //Glyph of Spell Reflection: -1 sec cooldown for Spell Reflection
+            if (lvl >= 64 && baseId == SPELL_REFLECTION_1)
+                cooldown -= 1000;
+
+            cooldown = std::max<float>(cooldown * pctbonus, 0.f);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct bonuses
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            if (lvl >= 15 && baseId == CHARGE_1)
+                pctbonus *= 0.93f;
+
+            //flat bonuses
+            //Improved Disarm part 1: -20 sec cooldown for Disarm
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 25 && baseId == DISARM_1)
+                cooldown -= 20000;
+            //Improved Intercept: -10 sec cooldown for Intercept
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 30 && baseId == INTERCEPT_1)
+                cooldown -= 10000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 45 && baseId == MORTAL_STRIKE_1)
+                cooldown -= 1000;
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                cooldown -= 4000;
+
+            //Glyph of Last Stand: -1 min cooldown for Last Stand
+            if (lvl >= 20 && baseId == LAST_STAND_1)
+                cooldown -= 60000;
+            //Glyph of Whirlwind: -2 sec cooldown for Whirlwind
+            if (lvl >= 36 && baseId == WHIRLWIND_1)
+                cooldown -= 2000;
+
+            //Warrior T9 2P Bonus (id: 67269): -2 sec cooldown for Taunt (tanks only)
+            if (lvl >= 80 && IsTank() && baseId == TAUNT_1)
+                cooldown -= 2000;
+
+            cooldown = std::max<float>(cooldown * pctbonus, 0.f);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                cooldown -= 500.f;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct mods
+            //Booming Voice part 1 (doubled for bots)
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+                pctbonus *= 2.0f; //1.5f
+
+            //flat mods
+            //Glyph of Thunder Clap (doubled for tanks)
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0x80))
+                radius += IsTank() ? 4.f : 2.f;
+
+            radius = radius * pctbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct mods
+            //Holy Reach: +20% range for Holy Spells
+            //if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x100080))
+            //    pctbonus *= 1.2f;
+
+            //flat mods
+            //Glyph of Charge: +5 yd range for Charge
+            if (baseId == CHARGE_1 && lvl >= 15)
+                maxrange += 5.f;
+
+            maxrange = maxrange * pctbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            //uint32 bonusTargets = 0;
+            uint8 lvl = me->GetLevel();
+
+            //Improved Revenge: +1 target (actually 2 in dbc)
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x400))
+                targets += 1;
+
+            //Glyph of Sunder Armor: +1 target
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0x4000))
+                targets += 1;
+            //Glyph of Cleaving: +1 target
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x400000))
+            {
+                targets += 1;
+                //double for non-tanks
+                if (!IsTank())
+                    targets += 1;
+            }
+        }
+
+        void ApplyClassEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Improved Rend: 20% increased effect
+            if (baseId == REND_1 && effIndex == EFFECT_0 && lvl >= 10)
+                pctbonus *= 1.2f;
+            //Improved Bloodrage: 50% increased effect
+            if ((baseId == BLOODRAGE_1 || baseId == BLOODRAGE_PERIODIC_EFFECT) && effIndex == EFFECT_0 && lvl >= 10)
+                pctbonus *= 1.5f;
+            //Improved Charge: +10 rage generated
+            if (baseId == CHARGE_1 && effIndex == EFFECT_1 && lvl >= 15)
+                value += 100.f;
+            //Glyph of Bloodthirst: +100% healing
+            if (baseId == BLOODTHIRST_1 && effIndex == EFFECT_1 && lvl >= 40)
+                pctbonus *= 2.0f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == LAST_STAND_1)
+                BotWhisper("Last Stand used!");
+            if (baseId == SHIELD_WALL_1)
+                BotWhisper("Shield Wall used!");
+            if (baseId == ENRAGED_REGENERATION_1)
+                BotWhisper("Enraged Regeneration used!");
+
+            if (baseId == SLAM_1)
+                me->RemoveAura(BLOODSURGE_BUFF);
+            if (baseId == HEROIC_STRIKE_1)
+                me->RemoveAura(GLYPH_REVENGE_BUFF);
+            if (baseId == SHIELD_SLAM_1)
+                me->RemoveAura(SWORD_AND_BOARD_BUFF);
+            if (baseId == OVERPOWER_1 && !me->HasReactive(REACTIVE_OVERPOWER))
+                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+            if (baseId == BERSERKER_RAGE_1)
+            {
+                //Improved Berserker Rage: 20 rage bonus when used
+                if (me->GetLevel() >= 35)
+                    me->CastSpell(me, IMPROVED_BERSERKER_RAGE_EFFECT, true);
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == VIGILANCE_1)
+                vigilanceTargetGuid = target->GetGUID();
+
+            //Recklessness: handle charge drop
+            AuraEffect const* reck = me->GetAuraEffect(RECKLESSNESS_1, EFFECT_0);
+            if (reck && reck->IsAffectedOnSpell(spell))
+                reck->GetBase()->DropCharge();
+            //Juggernaught: consume buff
+            if (baseId == SLAM_1 || baseId == MORTAL_STRIKE_1)
+                if (AuraEffect const* jugg = me->GetAuraEffect(JUGGERNAUGHT_BUFF, 0))
+                    if (jugg->IsAffectedOnSpell(spell))
+                        me->RemoveAurasDueToSpell(JUGGERNAUGHT_BUFF);
+
+            if (baseId == THUNDER_CLAP_1 && lvl >= 10)
+            {
+                if (AuraEffect* clap = target->GetAuraEffect(spellId, EFFECT_1, me->GetGUID()))
+                {
+                    int32 amount = clap->GetAmount();
+                    //Improved Thunder Clap (part 3): 10% extra slow
+                    amount += (-10);
+                    //Conqueror Thunder Clap Bonus: 50% increased effect
+                    if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 60)
+                        amount = amount + amount / 2;
+
+                    clap->ChangeAmount(amount);
+                }
+            }
+            if (baseId == DEMORALIZING_SHOUT_1 && lvl >= 15)
+            {
+                if (AuraEffect* demo = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    demo->ChangeAmount(demo->GetAmount() + demo->GetAmount() * 2 / 5);
+            }
+            if (baseId == BATTLE_SHOUT_1 || baseId == COMMANDING_SHOUT_1 || baseId == DEMORALIZING_SHOUT_1)
+            {
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    //Booming Voice part 2
+                    //Buffs duration 10 min for bots
+                    uint32 dur = baseId == DEMORALIZING_SHOUT_1 ? shout->GetDuration() * 3 / 2 : 600000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+
+                    if (baseId == BATTLE_SHOUT_1 || baseId == COMMANDING_SHOUT_1)
+                    {
+                        if (lvl >= 20)
+                        {
+                            //Commanding Presence: +25% increased effect (melee AP / HP)
+                            AuraEffect* bamm = shout->GetEffect(EFFECT_0);
+                            if (bamm)
+                                bamm->ChangeAmount(bamm->GetAmount() * 5 / 4);
+                        }
+                    }
+                    else if (baseId == DEMORALIZING_SHOUT_1)
+                    {
+                        if (lvl >= 15)
+                        {
+                            //Improved Demoralization Shout: +40% effect
+                            AuraEffect* demo = shout->GetEffect(EFFECT_0);
+                            if (demo)
+                                demo->ChangeAmount(demo->GetAmount() * 7 / 5);
+                        }
+                    }
+                }
+            }
+            if (baseId == REVENGE_1)
+            {
+                //zzzOLD Revenge Stun (25% chance): skip players
+                if (lvl >= 25 && target->GetTypeId() != TYPEID_PLAYER && urand(1,100) <= 25)
+                    me->CastSpell(target, REVENGE_STUN_SPELL, true);
+            }
+            if (baseId == DISARM_1 && (_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 25)
+            {
+                //Improved Disarm part 2
+                if (AuraEffect* disa = target->GetAuraEffect(spellId, 1, me->GetGUID()))
+                    disa->ChangeAmount(disa->GetAmount() + 10);
+            }
+            if (baseId == OVERPOWER_1)
+            {
+                me->ClearReactive(REACTIVE_OVERPOWER);
+                //Unrelenting Assault (part 3): reduce spells efficiency on players
+                if (lvl >= 45 && (_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                    target->GetTypeId() == TYPEID_PLAYER && target->IsNonMeleeSpellCast(false, false, true))
+                {
+                    CastSpellExtraArgs args(true);
+                    args.SetOriginalCaster(me->GetGUID());
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, args);
+                }
+            }
+            if (baseId == REND_1 && lvl >= 15)
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == INTERVENE_1)
+            {
+                //Glyph of Intervene + 1 bonus charge
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                    vene->SetCharges(vene->GetCharges() + 1);
+            }
+            if (baseId == PIERCING_HOWL_1)
+            {
+                //Piercing Howl: 4 sec duraion increase (exclude players controlled)
+                if (!target->IsControlledByPlayer())
+                {
+                    if (Aura* howl = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = howl->GetDuration() + 4000;
+                        howl->SetDuration(dur);
+                        howl->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == SHIELD_BASH_1 && (_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 30)
+            {
+                //Gag Order part 1: silence target
+                me->CastSpell(target, GAG_ORDER_DEBUFF, true);
+            }
+            if (baseId == VICTORY_RUSH_1)
+            {
+                //Victory rush disable helper
+                me->RemoveAura(VICTORIOUS_SPELL);
+            }
+            if ((baseId == DEVASTATE_1 || baseId == REVENGE_1) &&
+                (_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 55 && urand(1,100) <= 30)
+            {
+                //Sword and Board: trigger
+                me->CastSpell(me, SWORD_AND_BOARD_BUFF, true);
+                //Sword And Board: remove Shield Slam cooldown
+                ResetSpellCooldown(SHIELD_SLAM_1);
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Stances helper
+            if (spellId == BATTLE_STANCE_1 || spellId == DEFENSIVE_STANCE_1 || spellId == BERSERKER_STANCE_1)
+            {
+                stancetimer = 1000;
+
+                //stance mastery, tactical mastery
+                uint32 temprage = 0;
+                if (lvl >= 20)
+                    temprage = rage > 250 ? 250 : rage;
+                else if (lvl >= 15)
+                    temprage = rage > 150 ? 150 : rage;
+
+                _stance =
+                    spellId == BATTLE_STANCE_1 ? STANCE_BATTLE :
+                    spellId == DEFENSIVE_STANCE_1 ? STANCE_DEFENSIVE :
+                    spellId == BERSERKER_STANCE_1 ? STANCE_BERSERKER : STANCE_NONE;
+
+                me->SetPower(POWER_RAGE, temprage);
+                //Update stength bonus from Improved Berserker Stance
+                //if (lvl >= 45)
+                //    SetStats(false);
+            }
+
+            //Iron Will: -20% duration for stuns and charms
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS || _spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 15 && !spell->IsPositive() && (spell->Mechanic == MECHANIC_STUN || spell->Mechanic == MECHANIC_CHARM))
+            {
+                if (Aura* chun = me->GetAura(spellId, caster->GetGUID()))
+                {
+                    uint32 dur = chun->GetDuration() - chun->GetDuration() / 5;
+                    chun->SetDuration(dur);
+                    chun->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Enduring Victory: +5 sec duration
+            if (lvl >= 62 && baseId == VICTORIOUS_SPELL)
+            {
+                if (Aura* vict = me->GetAura(spellId))
+                {
+                    uint32 dur = vict->GetDuration() + 5000;
+                    vict->SetDuration(dur);
+                    vict->SetMaxDuration(dur);
+                }
+            }
+            //Improved Berserker Stance part 2: threat mod
+            if (baseId == BERSERKER_STANCE_PASSIVE)
+            {
+                if (AuraEffect* pass = me->GetAuraEffect(spellId, EFFECT_2))
+                    pass->ChangeAmount(pass->GetAmount() - 10);
+            }
+            if (baseId == RETALIATION_1)
+            {
+                //Increase duration by 3 sec for bot
+                if (Aura* ret = me->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = ret->GetDuration() + 3000;
+                    ret->SetDuration(dur);
+                    ret->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == VIGILANCE_PROC) //confirmed right place
+            {
+                //Vigilance: remove Taunt cooldown
+                ResetSpellCooldown(TAUNT_1);
+            }
+            if (baseId == SHIELD_WALL_1)
+            {
+                //Shield Wall Duration (id: 60175): 3 sec increased Shield Wall duration
+                if (Aura* wall = me->GetAura(spellId))
+                {
+                    int32 dur = wall->GetDuration() + 3000;
+                    wall->SetDuration(dur);
+                    wall->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Unbridled Wrath
+            if ((_spec == BOT_SPEC_WARRIOR_FURY || _spec == BOT_SPEC_WARRIOR_ARMS) &&
+                damage && me->GetLevel() >= 15 && me->CanDualWield() &&
+                (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE))
+            {
+                if (roll_chance_f(me->GetPPMProcChance(me->GetFloatValue(UNIT_FIELD_BASEATTACKTIME+BASE_ATTACK), 15.f, nullptr)))
+                    me->CastSpell(me, UNBRIDLED_WRATH_EFFECT, true);
+            }
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 /*value*/) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_WEAPON_SPEC:
+                {
+                    //AXE and MACE specs are handled elsewhere
+                    _checkSwordSpec();
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            shoutCheckTimer = 5000;
+            shatterCheckTimer = 5000;
+            vigiCheckTimer = 5000;
+
+            vigilanceTargetGuid = ObjectGuid::Empty;
+
+            _stance = STANCE_NONE;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            rage = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+            if (shoutCheckTimer > diff)             shoutCheckTimer -= diff;
+            if (shatterCheckTimer > diff)           shatterCheckTimer -= diff;
+            if (vigiCheckTimer > diff)              vigiCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_RAGE);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+            bool isFury = _spec == BOT_SPEC_WARRIOR_FURY;
+            bool isProt = _spec == BOT_SPEC_WARRIOR_PROTECTION;
+
+            InitSpellMap(BATTLE_STANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVE_STANCE_1) : RemoveSpell(DEFENSIVE_STANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKER_STANCE_1) : RemoveSpell(BERSERKER_STANCE_1);
+
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_ARMOR_1) : RemoveSpell(SUNDER_ARMOR_1);
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKER_RAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+            InitSpellMap(BATTLE_SHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+            InitSpellMap(SLAM_1);
+            InitSpellMap(RECKLESSNESS_1);
+            InitSpellMap(RETALIATION_1);
+            InitSpellMap(VICTORY_RUSH_1);
+            InitSpellMap(THUNDER_CLAP_1);
+            InitSpellMap(REVENGE_1);
+            InitSpellMap(SHIELD_BLOCK_1);
+            InitSpellMap(SHIELD_SLAM_1);
+            InitSpellMap(SPELL_REFLECTION_1);
+            InitSpellMap(DISARM_1);
+            InitSpellMap(SHIELD_WALL_1);
+            InitSpellMap(SHIELD_BASH_1);
+            InitSpellMap(HEROIC_THROW_1);
+            InitSpellMap(MOCKING_BLOW_1);
+            InitSpellMap(HEROIC_STRIKE_1);
+            InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(COMMANDING_SHOUT_1);
+            InitSpellMap(SHATTERING_THROW_1);
+            InitSpellMap(DEMORALIZING_SHOUT_1);
+
+  /*Talent*/lvl >= 30 && isArms ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+  /*Talent*/lvl >= 40 && isArms ? InitSpellMap(MORTAL_STRIKE_1) : RemoveSpell(MORTAL_STRIKE_1);
+  /*Talent*/lvl >= 60 && isArms ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+
+  /*Talent*/lvl >= (isFury ? 20 : isArms ? 70 : 99) ? InitSpellMap(PIERCING_HOWL_1) : RemoveSpell(PIERCING_HOWL_1);
+  /*Talent*/lvl >= 30 && isFury ? InitSpellMap(DEATH_WISH_1) : RemoveSpell(DEATH_WISH_1);
+  /*Talent*/lvl >= 40 && isFury ? InitSpellMap(BLOODTHIRST_1) : RemoveSpell(BLOODTHIRST_1);
+  /*Talent*/lvl >= 50 && isFury ? InitSpellMap(HEROIC_FURY_1) : RemoveSpell(HEROIC_FURY_1);
+
+  /*Talent*/lvl >= 20 && isProt ? InitSpellMap(LAST_STAND_1) : RemoveSpell(LAST_STAND_1);
+  /*Talent*/lvl >= 30 && isProt ? InitSpellMap(CONCUSSION_BLOW_1) : RemoveSpell(CONCUSSION_BLOW_1);
+  /*Talent*/lvl >= 40 && isProt ? InitSpellMap(VIGILANCE_1) : RemoveSpell(VIGILANCE_1);
+  /*Talent*/lvl >= 50 && isProt ? InitSpellMap(DEVASTATE_1) : RemoveSpell(DEVASTATE_1);
+  /*Talent*/lvl >= 60 && isProt ? InitSpellMap(SHOCKWAVE_1) : RemoveSpell(SHOCKWAVE_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+            bool isFury = _spec == BOT_SPEC_WARRIOR_FURY;
+            bool isProt = _spec == BOT_SPEC_WARRIOR_PROTECTION;
+
+            RefreshAura(DEEP_WOUNDS_3, (isArms || isFury) && level >= 24 ? 1 : 0);
+            RefreshAura(DEEP_WOUNDS_2, (isArms || isFury) && level >= 23 && level < 24 ? 1 : 0);
+            RefreshAura(DEEP_WOUNDS_1, (isArms || isFury) && level >= 22 && level < 23 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, isArms && level >= 25 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD3, isArms && level >= 27 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD2, isArms && level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD1, isArms && level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(IMPROVED_HAMSTRING, isArms && level >= 15 ? 1 : 0);
+            RefreshAura(TRAUMA2, isArms && level >= 36 ? 1 : 0);
+            RefreshAura(TRAUMA1, isArms && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SECOND_WIND, isArms && level >= 40 ? 1 : 0);
+            RefreshAura(JUGGERNAUGHT, isArms && level >= 45 ? 1 : 0);
+            RefreshAura(SUDDEN_DEATH, isArms && level >= 50 ? 1 : 0);
+            RefreshAura(ENDLESS_RAGE, isArms && level >= 50 ? 1 : 0);
+            RefreshAura(BLOOD_FRENZY, isArms && level >= 50 ? 1 : 0);
+            RefreshAura(WRECKING_CREW, isArms && level >= 55 ? 1 : 0);
+            _checkSwordSpec();
+
+            RefreshAura(ARMORED_TO_THE_TEETH, level >= 10 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE3, (isArms || isFury) && level >= 22 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE2, (isArms || isFury) && level >= 21 && level < 22 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE1, (isArms || isFury) && level >= 20 && level < 21 ? 1 : 0);
+            RefreshAura(DUAL_WIELD_SPECIALIZATION, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, isFury && level >= 39 ? 1 : 0);
+            RefreshAura(FLURRY4, isFury && level >= 38 && level < 39 ? 1 : 0);
+            RefreshAura(FLURRY3, isFury && level >= 37 && level < 38 ? 1 : 0);
+            RefreshAura(FLURRY2, isFury && level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(FLURRY1, isFury && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(FURIOUS_ATTACKS, isFury && level >= 45 ? 1 : 0);
+            RefreshAura(RAMPAGE, isFury && level >= 50 ? 1 : 0);
+            RefreshAura(BLOODSURGE, isFury && level >= 50 ? 1 : 0);
+
+            RefreshAura(SHIELD_SPECIALIZATION, isProt && level >= 10 ? 1 : 0);
+            RefreshAura(TOUGHNESS, isProt && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_SPELL_REFLECTION, isProt && level >= 25 ? 1 : 0);
+            RefreshAura(ONE_HANDED_WEAPON_SPECIALIZATION, isProt && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_DEFENSIVE_STANCE, isProt && level >= 40 ? 1 : 0);
+            RefreshAura(SAFEGUARD, isProt && level >= 45 ? 1 : 0);
+            RefreshAura(WARBRINGER, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(CRITICAL_BLOCK, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(DAMAGE_SHIELD, isProt && level >= 55 ? 1 : 0);
+
+            RefreshAura(GLYPH_HEROIC_STRIKE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REVENGE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_EXECUTION, level >= 24 ? 1 : 0);
+            RefreshAura(GLYPH_BLOCKING, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_VIGILANCE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_DEVASTATE, level >= 50 ? 1 : 0);
+
+            RefreshAura(WARRIOR_T10_PROT_4P, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case BLOODRAGE_1:
+                case BERSERKER_RAGE_1:
+                case BATTLE_SHOUT_1:
+                case COMMANDING_SHOUT_1:
+                case DEATH_WISH_1:
+                    return true;
+                case ENRAGED_REGENERATION_1:
+                    return me->HasAuraWithMechanic(1<<MECHANIC_ENRAGED);
+                case BATTLE_STANCE_1:
+                    return !_inStance(1);
+                case DEFENSIVE_STANCE_1:
+                    return !_inStance(2);
+                case BERSERKER_STANCE_1:
+                    return !_inStance(3);
+                case SWEEPING_STRIKES_1:
+                    return _inStance(5);
+                case RETALIATION_1:
+                    return _inStance(1);
+                case RECKLESSNESS_1:
+                    return _inStance(3);
+                case SHIELD_WALL_1:
+                    return CanBlock() && _inStance(2);
+                case SHIELD_BLOCK_1:
+                    return CanBlock();
+                case LAST_STAND_1:
+                case VIGILANCE_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const override
+        {
+            float bonus = 0.0f;
+
+            if (_inStance(1))
+            {
+                bonus += 10.f;
+                //Warrior T10 4P Bonus (part 1): 6% additional armor penetration in Battle Stance
+                if (me->GetLevel() >= 75)
+                    bonus += 6.f;
+            }
+
+            //Mace Specialization: 15% armor penetration
+            if (_spec == BOT_SPEC_WARRIOR_ARMS && me->GetLevel() >= 30)
+                if (Item const* weap = GetEquips(BOT_SLOT_MAINHAND))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2)
+                            bonus += 15.f;
+
+            return bonus + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+    private:
+        bool _inStance(uint8 stance) const
+        {
+            switch (stance)
+            {
+                case 1: return _stance == STANCE_BATTLE;
+                case 2: return _stance == STANCE_DEFENSIVE;
+                case 3: return _stance == STANCE_BERSERKER;
+                case 4: return _stance == STANCE_BATTLE || _stance == STANCE_DEFENSIVE;
+                case 5: return _stance == STANCE_BATTLE || _stance == STANCE_BERSERKER;
+                default: return false;
+            }
+        }
+
+        void _checkSwordSpec() const
+        {
+            uint8 level = me->GetLevel();
+            bool isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+            Item const* mhWeap = GetEquips(BOT_SLOT_MAINHAND);
+            uint32 weaponSubClass = mhWeap ? mhWeap->GetTemplate()->SubClass : uint32(ITEM_SUBCLASS_WEAPON_WAND);
+            bool sword = (weaponSubClass == ITEM_SUBCLASS_WEAPON_SWORD || weaponSubClass == ITEM_SUBCLASS_WEAPON_SWORD2);
+            RefreshAura(SWORD_SPEC5, isArms && sword && level >= 34 ? 1 : 0);
+            RefreshAura(SWORD_SPEC4, isArms && sword && level >= 33 && level < 34 ? 1 : 0);
+            RefreshAura(SWORD_SPEC3, isArms && sword && level >= 32 && level < 33 ? 1 : 0);
+            RefreshAura(SWORD_SPEC2, isArms && sword && level >= 31 && level < 32 ? 1 : 0);
+            RefreshAura(SWORD_SPEC1, isArms && sword && level >= 30 && level < 31 ? 1 : 0);
+        }
+
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2, shoutCheckTimer, shatterCheckTimer, vigiCheckTimer;
+/*misc*/int32 rage;
+/*misc*/ObjectGuid vigilanceTargetGuid;
+/*stnc*/uint8 _stance;
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..37c3466
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,1165 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "Chat.h"
+#include "CharacterCache.h"
+#include "Language.h"
+#include "Group.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "Player.h"
+#include "RBAC.h"
+#include "ScriptMgr.h"
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npc Bot related commands by Trickerer (onlysuffering@gmail.com)
+Category: commandscripts/custom/
+*/
+//RBAC_PERM_GM_COMMANDS = 197
+//RBAC_PERM_PLAYER_COMMANDS = 199
+#define GM_COMMANDS rbac::RBACPermissions(197)
+#define PLAYER_COMMANDS rbac::RBACPermissions(199)
+
+class script_bot_commands : public CommandScript
+{
+private:
+    struct BotInfo
+    {
+        public:
+            BotInfo(uint32 Id, std::string Name, uint8 Race) : id(Id), name(Name), race(Race) {}
+            uint32 id;
+            std::string name;
+            uint8 race;
+        private:
+            BotInfo() {}
+            //BotInfo(BotInfo const&);
+    };
+    static bool sortbots(BotInfo const& p1, BotInfo const& p2)
+    {
+        return p1.id < p2.id;
+    }
+
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    std::vector<ChatCommand> GetCommands() const override
+    {
+        //static std::vector<ChatCommand> npcbotToggleCommandTable =
+        //{
+        //    { "flags",      GM_COMMANDS,            false, &HandleNpcBotToggleFlagsCommand,         "" },
+        //};
+
+        static std::vector<ChatCommand> npcbotDebugCommandTable =
+        {
+            { "raid",       GM_COMMANDS,            false, &HandleNpcBotDebugRaidCommand,           "" },
+            { "mount",      GM_COMMANDS,            false, &HandleNpcBotDebugMountCommand,          "" },
+            { "spellvisual",GM_COMMANDS,            false, &HandleNpcBotDebugSpellVisualCommand,    "" },
+            { "states",     GM_COMMANDS,            false, &HandleNpcBotDebugStatesCommand,         "" },
+        };
+
+        static std::vector<ChatCommand> npcbotSetCommandTable =
+        {
+            { "faction",    GM_COMMANDS,            false, &HandleNpcBotSetFactionCommand,          "" },
+            { "owner",      GM_COMMANDS,            false, &HandleNpcBotSetOwnerCommand,            "" },
+            { "spec",       GM_COMMANDS,            false, &HandleNpcBotSetSpecCommand,             "" },
+        };
+
+        static std::vector<ChatCommand> npcbotCommandCommandTable =
+        {
+            { "standstill", PLAYER_COMMANDS,        false, &HandleNpcBotCommandStandstillCommand,   "" },
+            { "stopfully",  PLAYER_COMMANDS,        false, &HandleNpcBotCommandStopfullyCommand,    "" },
+            { "follow",     PLAYER_COMMANDS,        false, &HandleNpcBotCommandFollowCommand,       "" },
+        };
+
+        static std::vector<ChatCommand> npcbotCommandTable =
+        {
+            //{ "debug",      GM_COMMANDS,            false, nullptr,        "", npcbotDebugCommandTable },
+            //{ "toggle",     GM_COMMANDS,            false, nullptr,       "", npcbotToggleCommandTable },
+            { "set",        GM_COMMANDS,            false, nullptr,          "", npcbotSetCommandTable },
+            { "add",        GM_COMMANDS,            false, &HandleNpcBotAddCommand,                 "" },
+            { "remove",     GM_COMMANDS,            false, &HandleNpcBotRemoveCommand,              "" },
+            { "spawn",      GM_COMMANDS,            false, &HandleNpcBotSpawnCommand,               "" },
+            { "delete",     GM_COMMANDS,            false, &HandleNpcBotDeleteCommand,              "" },
+            { "lookup",     GM_COMMANDS,            false, &HandleNpcBotLookupCommand,              "" },
+            { "revive",     GM_COMMANDS,            false, &HandleNpcBotReviveCommand,              "" },
+            { "reloadconfig",GM_COMMANDS,           true,  &HandleNpcBotReloadConfigCommand,        "" },
+            { "command",    PLAYER_COMMANDS,        false, nullptr,      "", npcbotCommandCommandTable },
+            { "info",       PLAYER_COMMANDS,        false, &HandleNpcBotInfoCommand,                "" },
+            { "hide",       PLAYER_COMMANDS,        false, &HandleNpcBotHideCommand,                "" },
+            { "unhide",     PLAYER_COMMANDS,        false, &HandleNpcBotUnhideCommand,              "" },
+            { "show",       PLAYER_COMMANDS,        false, &HandleNpcBotUnhideCommand,              "" },
+            { "recall",     PLAYER_COMMANDS,        false, &HandleNpcBotRecallCommand,              "" },
+            { "kill",       PLAYER_COMMANDS,        false, &HandleNpcBotKillCommand,                "" },
+            { "suicide",    PLAYER_COMMANDS,        false, &HandleNpcBotKillCommand,                "" },
+        };
+
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "npcbot",     PLAYER_COMMANDS,        false, nullptr,                   "", npcbotCommandTable },
+        };
+        return commandTable;
+    }
+
+    static bool HandleNpcBotDebugStatesCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Unit* target = handler->getSelectedUnit();
+        if (!target)
+        {
+            handler->SendSysMessage("No target selected");
+            return true;
+        }
+
+        uint8 const MAX_UNIT_STATES = 29;
+        std::ostringstream ostr;
+        ostr << "Listing states for " << target->GetName() << ":";
+        for (uint8 i = 0; i != MAX_UNIT_STATES; ++i)
+        {
+            if (target->HasUnitState(1 << i))
+                ostr << "\n    0x" << std::hex << (1 << i);
+        }
+
+        handler->SendSysMessage(ostr.str().c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotDebugRaidCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Group const* gr = owner->GetGroup();
+        if (!owner->HaveBot() || !gr)
+        {
+            handler->SendSysMessage(".npcbot debug raid");
+            handler->SendSysMessage("prints your raid bots info");
+            return true;
+        }
+        if (!gr->isRaidGroup())
+        {
+            handler->SendSysMessage("only usable in raid");
+            return true;
+        }
+
+        uint8 counter = 0;
+        uint8* subBots = new uint8[MAX_RAID_SUBGROUPS];
+        memset((void*)subBots, 0, (MAX_RAID_SUBGROUPS)*sizeof(uint8));
+        std::ostringstream sstr;
+        BotMap const* map = owner->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* bot = itr->second;
+            if (!bot || !gr->IsMember(itr->second->GetGUID()))
+                continue;
+
+            uint8 subGroup = gr->GetMemberGroup(itr->second->GetGUID());
+            ++subBots[subGroup];
+            sstr << uint32(++counter) << ": " << bot->GetGUID().GetCounter() << " " << bot->GetName()
+                << " subgr: " << uint32(subGroup + 1) << "\n";
+        }
+
+        for (uint8 i = 0; i != MAX_RAID_SUBGROUPS; ++i)
+            if (subBots[i] > 0)
+                sstr << uint32(subBots[i]) << " bots in subgroup " << uint32(i + 1) << "\n";
+
+        handler->SendSysMessage(sstr.str().c_str());
+        delete[] subBots;
+        return true;
+    }
+
+    static bool HandleNpcBotDebugMountCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        //float speed = 1.f;
+        uint32 num = 0;
+
+        num = atoi((char*)args);
+        if (!num)
+            return false;
+
+        Unit* target = handler->getSelectedUnit();
+        if (!target)
+        {
+            handler->SendSysMessage("No target selected");
+            return true;
+        }
+
+        target->Mount(num);
+        return true;
+    }
+
+    static bool HandleNpcBotDebugSpellVisualCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* target = owner->GetSelectedUnit();
+        if (!target)
+        {
+            handler->SendSysMessage("No target selected");
+            return true;
+        }
+
+        const std::string intStr = args;
+        uint32 kit = (uint32)atoi((char*)args);
+
+        target->SendPlaySpellVisual(kit);
+        return true;
+    }
+
+    static bool HandleNpcBotHideCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        // Hiding/unhiding bots should be allowed only out of combat
+        // Currenly bots can teleport to master in combat
+        // This creates potential for some serious trolls
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot hide");
+            handler->SendSysMessage("Removes your owned npcbots from world temporarily");
+            //handler->SendSysMessage("You have no bots!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->SetBotsHidden(true);
+        handler->SendSysMessage("Bots hidden");
+        return true;
+    }
+
+    static bool HandleNpcBotUnhideCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot unhide | show");
+            handler->SendSysMessage("Returns your temporarily hidden bots back");
+            //handler->SendSysMessage("You have no bots!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->SetBotsHidden(false);
+        handler->SendSysMessage("Bots unhidden");
+        return true;
+    }
+
+    static bool HandleNpcBotKillCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid || !owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot recall");
+            handler->SendSysMessage("Makes your npcbot just drop dead. If you select yourself ALL your bots will die");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (guid == owner->GetGUID())
+        {
+            owner->GetBotMgr()->KillAllBots();
+            return true;
+        }
+        if (Creature* bot = owner->GetBotMgr()->GetBot(guid))
+        {
+            owner->GetBotMgr()->KillBot(bot);
+            return true;
+        }
+
+        handler->SendSysMessage("You must select one of your bots or yourself");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRecallCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid || !owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot recall");
+            handler->SendSysMessage("Forces npcbots to move directly on your position. Select a npcbot you want to move or select yourself to move all bots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (guid == owner->GetGUID())
+        {
+            owner->GetBotMgr()->RecallAllBots();
+            return true;
+        }
+        if (Creature* bot = owner->GetBotMgr()->GetBot(guid))
+        {
+            owner->GetBotMgr()->RecallBot(bot);
+            return true;
+        }
+
+        handler->SendSysMessage("You must select one of your bots or yourself");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    //static bool HandleNpcBotToggleFlagsCommand(ChatHandler* handler, const char* args)
+    //{
+    //    Player* chr = handler->GetSession()->GetPlayer();
+    //    Unit* unit = chr->GetSelectedUnit();
+    //    if (!unit || unit->GetTypeId() != TYPEID_UNIT || !*args)
+    //    {
+    //        handler->SendSysMessage(".npcbot toggle flags #flag");
+    //        handler->SendSysMessage("This is a debug command");
+    //        handler->SetSentErrorMessage(true);
+    //        return false;
+    //    }
+
+    //    const std::string facStr = args;
+    //    int32 flag = (int32)atoi((char*)args);
+
+    //    uint32 setFlags = 0;
+
+    //    switch (flag)
+    //    {
+    //        case 6:
+    //            setFlags = UNIT_FLAG_UNK_6;
+    //            break;
+    //        case 14:
+    //            setFlags = UNIT_FLAG_UNK_14;
+    //            break;
+    //        case 15:
+    //            setFlags = UNIT_FLAG_UNK_15;
+    //            break;
+    //        case 16:
+    //            setFlags = UNIT_FLAG_UNK_16;
+    //            break;
+    //        default:
+    //            break;
+    //    }
+
+    //    if (!setFlags)
+    //        return false;
+
+    //    handler->PSendSysMessage("Toggling flag %u on %s", setFlags, unit->GetName().c_str());
+    //    unit->ToggleFlag(UNIT_FIELD_FLAGS, setFlags);
+    //    return true;
+    //}
+
+    static bool HandleNpcBotSetFactionCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set faction #faction");
+            handler->SendSysMessage("Sets faction for selected npcbot (saved in DB)");
+            handler->SendSysMessage("Use 'a', 'h', 'm' or 'f' as argument to set faction to alliance, horde, monsters (hostile to all) or friends (friendly to all)");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot() || !bot->IsFreeBot())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint32 factionId = 0;
+        const std::string facStr = args;
+        char const* factionChar = facStr.c_str();
+
+        if (factionChar[0] == 'a')
+            factionId = 1802; //Alliance
+        else if (factionChar[0] == 'h')
+            factionId = 1801; //Horde
+        else if (factionChar[0] == 'm')
+            factionId = 14; //Monsters
+        else if (factionChar[0] == 'f')
+            factionId = 35; //Friendly to all
+
+        if (!factionId)
+        {
+            char* pfactionid = handler->extractKeyFromLink((char*)args, "Hfaction");
+            factionId = atoi(pfactionid);
+        }
+
+        if (!sFactionTemplateStore.LookupEntry(factionId))
+        {
+            handler->PSendSysMessage(LANG_WRONG_FACTION, factionId);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_FACTION, &factionId);
+        bot->GetBotAI()->ReInitFaction();
+
+        handler->PSendSysMessage("%s's faction set to %u", bot->GetName().c_str(), factionId);
+        return true;
+    }
+
+    static bool HandleNpcBotSetOwnerCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set owner #guid | #name");
+            handler->SendSysMessage("Binds selected npcbot to new player owner using guid or name and updates owner in DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("You must select a npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("This npcbot already has owner");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* characterName_str = strtok((char*)args, " ");
+        if (!characterName_str)
+            return false;
+
+        std::string characterName = characterName_str;
+        uint32 guidlow = (uint32)atoi(characterName_str);
+
+        bool found = true;
+        if (guidlow)
+            found = sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, 0, guidlow), characterName);
+        else
+            guidlow = sCharacterCache->GetCharacterGuidByName(characterName);
+
+        if (!guidlow || !found)
+        {
+            handler->SendSysMessage("Player not found");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &guidlow);
+        bot->GetBotAI()->ReinitOwner();
+        //bot->GetBotAI()->Reset();
+
+        handler->PSendSysMessage("%s's new owner is %s (guidlow: %u)", bot->GetName().c_str(), characterName.c_str(), guidlow);
+        return true;
+    }
+
+    static bool HandleNpcBotSetSpecCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set spec #specnumber");
+            handler->SendSysMessage("Changes talent spec for selected npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("You must select a npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* specStr = strtok((char*)args, " ");
+        if (!specStr)
+            return false;
+
+        uint8 spec = (uint8)atoi(specStr);
+        if (spec < BOT_SPEC_BEGIN || spec > BOT_SPEC_END)
+        {
+            handler->SendSysMessage("Spec is out of range (1 to 3)!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->GetBotAI()->SetSpec(spec);
+
+        handler->PSendSysMessage("%s's new spec is %u", bot->GetName().c_str(), uint32(spec));
+        return true;
+    }
+
+    static bool HandleNpcBotLookupCommand(ChatHandler* handler, const char* args)
+    {
+        //this is just a modified '.lookup creature' command
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot lookup #class");
+            handler->SendSysMessage("Looks up npcbots by #class, and returns all matches with their creature ID's");
+            handler->PSendSysMessage("BOT_CLASS_WARRIOR = %u", uint32(BOT_CLASS_WARRIOR));
+            handler->PSendSysMessage("BOT_CLASS_PALADIN = %u", uint32(BOT_CLASS_PALADIN));
+            handler->PSendSysMessage("BOT_CLASS_HUNTER = %u", uint32(BOT_CLASS_HUNTER));
+            handler->PSendSysMessage("BOT_CLASS_ROGUE = %u", uint32(BOT_CLASS_ROGUE));
+            handler->PSendSysMessage("BOT_CLASS_PRIEST = %u", uint32(BOT_CLASS_PRIEST));
+            handler->PSendSysMessage("BOT_CLASS_DEATH_KNIGHT = %u", uint32(BOT_CLASS_DEATH_KNIGHT));
+            handler->PSendSysMessage("BOT_CLASS_SHAMAN = %u", uint32(BOT_CLASS_SHAMAN));
+            handler->PSendSysMessage("BOT_CLASS_MAGE = %u", uint32(BOT_CLASS_MAGE));
+            handler->PSendSysMessage("BOT_CLASS_WARLOCK = %u", uint32(BOT_CLASS_WARLOCK));
+            handler->PSendSysMessage("BOT_CLASS_DRUID = %u", uint32(BOT_CLASS_DRUID));
+            handler->PSendSysMessage("BOT_CLASS_BLADEMASTER = %u", uint32(BOT_CLASS_BM));
+            handler->PSendSysMessage("BOT_CLASS_SPHYNX = %u", uint32(BOT_CLASS_SPHYNX));
+            handler->PSendSysMessage("BOT_CLASS_ARCHMAGE = %u", uint32(BOT_CLASS_ARCHMAGE));
+            handler->PSendSysMessage("BOT_CLASS_DREADLORD = %u", uint32(BOT_CLASS_DREADLORD));
+            handler->PSendSysMessage("BOT_CLASS_SPELLBREAKER = %u", uint32(BOT_CLASS_SPELLBREAKER));
+            handler->PSendSysMessage("BOT_CLASS_DARK_RANGER = %u", uint32(BOT_CLASS_DARK_RANGER));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* classstr = strtok((char*)args, " ");
+        uint8 botclass = BOT_CLASS_NONE;
+
+        if (classstr)
+            botclass = (uint8)atoi(classstr);
+
+        if (botclass == BOT_CLASS_NONE || botclass >= BOT_CLASS_END)
+        {
+            handler->PSendSysMessage("Unknown bot class %u", uint32(botclass));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Looking for bots of class %u...", uint32(botclass));
+
+        uint8 localeIndex = handler->GetSessionDbLocaleIndex();
+        CreatureTemplateContainer const& ctc = sObjectMgr->GetCreatureTemplates();
+        typedef std::list<BotInfo> BotList;
+        BotList botlist;
+        for (CreatureTemplateContainer::const_iterator itr = ctc.begin(); itr != ctc.end(); ++itr)
+        {
+            uint32 id = itr->second.Entry;
+            if (id < BOT_ENTRY_BEGIN || id > BOT_ENTRY_END)
+                continue;
+
+            if (id == BOT_ENTRY_MIRROR_IMAGE_BM)
+                continue;
+            //Blademaster disabled
+            if (botclass == BOT_CLASS_BM)
+                continue;
+
+            //TC_LOG_ERROR("entities.unit", "NpcBotLookup: cur %u", id);
+
+            NpcBotExtras const* _botExtras = BotDataMgr::SelectNpcBotExtras(id);
+            if (!_botExtras)
+                continue;
+
+            //TC_LOG_ERROR("entities.unit", "NpcBotLookup: found extras...");
+
+            if (_botExtras->bclass != botclass)
+                continue;
+
+            //TC_LOG_ERROR("entities.unit", "NpcBotLookup: class matches...");
+
+            uint8 race = _botExtras->race;
+
+            if (CreatureLocale const* creatureLocale = sObjectMgr->GetCreatureLocale(id))
+            {
+                if (creatureLocale->Name.size() > localeIndex && !creatureLocale->Name[localeIndex].empty())
+                {
+                    botlist.push_back(BotInfo(id, creatureLocale->Name[localeIndex], race));
+                    continue;
+                }
+            }
+
+            std::string name = itr->second.Name;
+            if (name.empty())
+                continue;
+
+            //TC_LOG_ERROR("entities.unit", "NpcBotLookup: ading to list");
+
+            botlist.push_back(BotInfo(id, name, race));
+        }
+
+        if (botlist.empty())
+        {
+            handler->SendSysMessage(LANG_COMMAND_NOCREATUREFOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        botlist.sort(&script_bot_commands::sortbots);
+
+        for (BotList::const_iterator itr = botlist.begin(); itr != botlist.end(); ++itr)
+        {
+            uint32 id = itr->id;
+            char const* name = itr->name.c_str();
+            uint8 race = itr->race;
+
+            //TODO:
+            if (race >= MAX_RACES)
+                race = RACE_NONE;
+
+            char const* raceName;
+            switch (race)
+            {
+                case RACE_HUMAN:        raceName = "Human";     break;
+                case RACE_ORC:          raceName = "Orc";       break;
+                case RACE_DWARF:        raceName = "Dwarf";     break;
+                case RACE_NIGHTELF:     raceName = "Night Elf"; break;
+                case RACE_UNDEAD_PLAYER:raceName = "Forsaken";  break;
+                case RACE_TAUREN:       raceName = "Tauren";    break;
+                case RACE_GNOME:        raceName = "Gnome";     break;
+                case RACE_TROLL:        raceName = "Troll";     break;
+                case RACE_BLOODELF:     raceName = "Blood Elf"; break;
+                case RACE_DRAENEI:      raceName = "Draenei";   break;
+                case RACE_NONE:         raceName = "No Race";   break;
+                default:                raceName = "Unknown";   break;
+            }
+
+            handler->PSendSysMessage("%d - |cffffffff|Hcreature_entry:%d|h[%s]|h|r %s", id, id, name, raceName);
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot)
+        {
+            handler->SendSysMessage(".npcbot delete");
+            handler->SendSysMessage("Deletes selected npcbot spawn from world and DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("No npcbot selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player const* botowner = bot->GetBotOwner()->ToPlayer())
+            botowner->GetBotMgr()->RemoveBot(bot->GetGUID(), BOT_REMOVE_DISMISS);
+
+        uint32 id = bot->GetEntry();
+
+        NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(id);
+        ASSERT(npcBotData);
+
+        bool found = false;
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            if (npcBotData->equips[i])
+            {
+                found = true;
+                break;
+            }
+        }
+        if (found)
+        {
+            handler->PSendSysMessage("%s still has eqipment assigned. Please remove equips before deleting bot!", bot->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->GetBotAI()->canUpdate = false;
+        bot->CombatStop();
+        bot->GetBotAI()->Reset();
+        Creature::DeleteFromDB(bot->GetSpawnId());
+        bot->AddObjectToRemoveList();
+
+        BotDataMgr::UpdateNpcBotData(id, NPCBOT_UPDATE_ERASE);
+
+        handler->SendSysMessage("Npcbot successfully deleted");
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot spawn");
+            handler->SendSysMessage("Adds new npcbot spawn of given entry in world. You can shift-link the npc");
+            handler->SendSysMessage("Syntax: .npcbot spawn #entry");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        uint32 id = atoi(charID);
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!creInfo)
+        {
+            handler->PSendSysMessage("creature %u does not exist!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+            handler->PSendSysMessage("creature %u is not a npcbot!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (BotDataMgr::SelectNpcBotData(id))
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to move this bot to a new location use '.npc move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        WorldDatabasePreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (/*Transport* trans = */chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        //float x = chr->GetPositionX();
+        //float y = chr->GetPositionY();
+        //float z = chr->GetPositionZ();
+        //float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, chr->GetPhaseMaskForSpawn(), id, *chr))
+        {
+            delete creature;
+            handler->SendSysMessage("Creature is not created!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        NpcBotExtras const* _botExtras = BotDataMgr::SelectNpcBotExtras(id);
+
+        uint16 roleMask = BOT_ROLE_DPS;
+
+        uint8 m_class = _botExtras ? _botExtras->bclass : uint8(CLASS_WARRIOR);
+        if (!bot_ai::IsMeleeClass(m_class))
+            roleMask |= BOT_ROLE_RANGED;
+        if (bot_ai::IsHealingClass(m_class))
+            roleMask |= BOT_ROLE_HEAL;
+
+        uint8 spec = urand(1,3);
+        switch (m_class)
+        {
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_HUNTER:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_PRIEST:
+            case BOT_CLASS_DEATH_KNIGHT:
+            case BOT_CLASS_SHAMAN:
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+                spec += (m_class-1) * 3;
+                break;
+            case BOT_CLASS_DRUID:
+                spec += (m_class-2) * 3;
+                break;
+            default:
+                spec = uint8(BOT_SPEC_DEFAULT);
+                break;
+        }
+
+        BotDataMgr::AddNpcBotData(id, roleMask, spec, creature->GetCreatureTemplate()->faction);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetSpawnId();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            //return false;
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("Npcbot successfully spawned");
+        return true;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->SendSysMessage(".npcbot info");
+            handler->SendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master)
+        {
+            handler->SendSysMessage("No player selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (handler->HasLowerSecurity(master, ObjectGuid::Empty))
+        {
+            handler->SendSysMessage("Invalid target");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = BOT_CLASS_WARRIOR; i != BOT_CLASS_END; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                if (Creature* cre = itr->second)
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+
+            char const* bclass;
+            switch (i)
+            {
+                case BOT_CLASS_WARRIOR:         bclass = "Warriors";        break;
+                case BOT_CLASS_PALADIN:         bclass = "Paladins";        break;
+                case BOT_CLASS_MAGE:            bclass = "Mages";           break;
+                case BOT_CLASS_PRIEST:          bclass = "Priests";         break;
+                case BOT_CLASS_WARLOCK:         bclass = "Warlocks";        break;
+                case BOT_CLASS_DRUID:           bclass = "Druids";          break;
+                case BOT_CLASS_DEATH_KNIGHT:    bclass = "Death Knights";   break;
+                case BOT_CLASS_ROGUE:           bclass = "Rogues";          break;
+                case BOT_CLASS_SHAMAN:          bclass = "Shamans";         break;
+                case BOT_CLASS_HUNTER:          bclass = "Hunters";         break;
+                case BOT_CLASS_BM:              bclass = "Blademasters";    break;
+                case BOT_CLASS_SPHYNX:          bclass = "Destroyers";      break;
+                case BOT_CLASS_ARCHMAGE:        bclass = "Archmagi";        break;
+                case BOT_CLASS_DREADLORD:       bclass = "Dreadlords";      break;
+                case BOT_CLASS_SPELLBREAKER:    bclass = "Spell Breakers";  break;
+                case BOT_CLASS_DARK_RANGER:     bclass = "Dark Rangers";    break;
+                default:                        bclass = "Unknown Class";   break;
+            }
+            handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotCommandStandstillCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command standstill");
+            handler->SendSysMessage("Forces your npcbots to stop all movement and remain stationed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        Unit* target = owner->GetSelectedUnit();
+        if (target && owner->GetBotMgr()->GetBot(target->GetGUID()))
+        {
+            target->ToCreature()->GetBotAI()->SetBotCommandState(BOT_COMMAND_STAY);
+            msg = target->GetName() + "'s command state set to 'STAY'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_STAY);
+            msg = "Bots' command state set to 'STAY'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotCommandStopfullyCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command stopfully");
+            handler->SendSysMessage("Forces your npcbots to stop all activity");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        Unit* target = owner->GetSelectedUnit();
+        if (target && owner->GetBotMgr()->GetBot(target->GetGUID()))
+        {
+            target->ToCreature()->GetBotAI()->SetBotCommandState(BOT_COMMAND_FULLSTOP);
+            msg = target->GetName() + "'s command state set to 'FULLSTOP'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_FULLSTOP);
+            msg = "Bots' command state set to 'FULLSTOP'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotCommandFollowCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command follow");
+            handler->SendSysMessage("Allows npcbots to follow you again if stopped");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        Unit* target = owner->GetSelectedUnit();
+        if (target && owner->GetBotMgr()->GetBot(target->GetGUID()))
+        {
+            target->ToCreature()->GetBotAI()->SetBotCommandState(BOT_COMMAND_FOLLOW);
+            msg = target->GetName() + "'s command state set to 'FOLLOW'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_FOLLOW);
+            msg = "Bots' command state set to 'FOLLOW'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot remove");
+            handler->SendSysMessage("Frees selected npcbot from it's owner. Select player to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* master = u->ToPlayer();
+        if (master)
+        {
+            if (master->HaveBot())
+            {
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+
+                if (!master->HaveBot())
+                {
+                    handler->SendSysMessage("Npcbots were successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->SendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->SendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = u->ToCreature();
+        if (cre && cre->IsNPCBot() && !cre->IsFreeBot())
+        {
+            master = cre->GetBotOwner();
+            master->GetBotMgr()->RemoveBot(cre->GetGUID(), BOT_REMOVE_DISMISS);
+            if (master->GetBotMgr()->GetBot(cre->GetGUID()) == nullptr)
+            {
+                handler->SendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->SendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->SendSysMessage("You must select player or controlled npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot revive");
+            handler->SendSysMessage("Revives selected npcbot. If player is selected, revives all selected player's npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* master = u->ToPlayer())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("%s has no npcbots!", master->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+
+            master->GetBotMgr()->ReviveAllBots();
+            handler->SendSysMessage("Npcbots revived");
+            return true;
+        }
+        else if (Creature* bot = u->ToCreature())
+        {
+            if (bot->GetBotAI())
+            {
+                if (bot->IsAlive())
+                {
+                    handler->PSendSysMessage("%s is not dead", bot->GetName().c_str());
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+
+                BotMgr::ReviveBot(bot, (bot->GetBotOwner() == owner) ? owner->ToUnit() : bot->ToUnit());
+                handler->PSendSysMessage("%s revived", bot->GetName().c_str());
+                return true;
+            }
+        }
+
+        handler->SendSysMessage("You must select player or npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* cre = owner->GetSelectedUnit();
+
+        if (!cre || cre->GetTypeId() != TYPEID_UNIT)
+        {
+            handler->SendSysMessage(".npcbot add");
+            handler->SendSysMessage("Allows to hire selected uncontrolled bot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = cre->ToCreature();
+        if (!bot || !bot->IsNPCBot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotMgr* mgr = owner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(owner);
+
+        if (mgr->AddBot(bot, false) == BOT_ADD_SUCCESS)
+        {
+            handler->PSendSysMessage("%s is now your npcbot", bot->GetName().c_str());
+            return true;
+        }
+
+        handler->SendSysMessage("NpcBot is NOT added for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotReloadConfigCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        TC_LOG_INFO("misc", "Re-Loading config settings...");
+        sWorld->LoadConfigSettings(true);
+        sMapMgr->InitializeVisibilityDistanceInfo();
+        handler->SendGlobalGMSysMessage("World config settings reloaded.");
+        BotMgr::ReloadConfig();
+        handler->SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+        return true;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botcommon.h b/src/server/game/AI/NpcBots/botcommon.h
new file mode 100644
index 0000000..7cb6348
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommon.h
@@ -0,0 +1,649 @@
+#ifndef _BOTCOMMON_H
+#define _BOTCOMMON_H
+
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+enum BotCommonValues
+{
+//MISC
+    BOT_GIVER_ENTRY                     = 70000,
+    BOT_ENTRY_BEGIN                     = 70001,
+    BOT_ENTRY_END                       = 71000,
+    BOT_PET_ENTRY_BEGIN                 = 70501,
+    BOT_PET_ENTRY_END                   = 70550,
+    BOT_ENTRY_MIRROR_IMAGE_BM           = 70552,
+    BOT_ICON_ON                         = 9,    //GOSSIP_ICON_BATTLE,
+    BOT_ICON_OFF                        = 0,    //GOSSIP_ICON_CHAT,
+    BOT_MAX_CHASE_RANGE                 = 120,  //yds
+    //BOT_EVADE_TIME                      = 3000, //ms
+//COMMON SPELLS
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+    BERSERK                             = 46587,//68378,//900%/150%
+    MODEL_TRANSITION                    = 24753,//"Trick" cannot cast or attack
+    SUMMONING_DISORIENTATION            = 32752,
+    ACTIVATE_SPEC                       = 63645,//Activate Primary Spec
+    SHOOT_WAND                          = 5019,
+///Passives
+    DAMAGE_REDUCTION                    = 68066,//Vigilance, Blessing of Sanctuary, etc.
+///Passives for Pets
+    DAMAGEDONE_PASSIVE                  = 30147,//for custom value, Tamed Pet Passive (DND) physical at 0, magic at 1
+    DAMAGETAKEN_PASSIVE                 = 35697,//for custom value, Pet Passive (DND), single effect (aura 87 at 0)
+    SPELLDAMAGE_PASSIVE                 = 43922,//for custom value, Increase Spell Dam 473, single effect (aura 13 at 0)
+    SPELLPENETRATION_PASSIVE            = 25975,//for custom value, Spell Penetration 10, single effect (aura 123 at 0)
+    SPELLHASTE_PASSIVE                  = 44400,//for custom value, Netherwind Presence rank 1, single effect (aura 65 at 0)
+    CRITBONUS_PASSIVE                   = 35695,//for custom value, Pet Passive (DND), spell at 0, physical at 1
+///Racials
+    RACIAL_EVERY_MAN_FOR_HIMSELF        = 59752,//pvp trinket effect, instant, 2 min cd
+    RACIAL_BLOOD_FURY_WARLOCK           = 33702,//effect varies, 15 sec, 2 min cd
+    RACIAL_BLOOD_FURY_SHAMAN            = 33697,
+    RACIAL_BLOOD_FURY_OTHERS            = 20572,
+    RACIAL_STONEFORM                    = 20594,//dispell disease, poison, bleed, instant, 2 min cd
+    //RACIAL_FIND_TREASURE                = 2481,
+    RACIAL_SHADOWMELD                   = 58984,//stealth, -threat, instant, 2 min cd
+    RACIAL_WILL_OF_THE_FORSAKEN         = 7744,//dispel charm/fear/sleep, instant, 2 min cd, 45 sec category cd
+    RACIAL_WARSTOMP                     = 20549,//2sec stun, casttime 500, 8yd, 2 min cd
+    RACIAL_ESCAPE_ARTIST                = 20589,//dispel snare/root, instant, 1 min 45 sec cd
+    RACIAL_BERSERKING                   = 26297,//haste all 20%, isntant, 3 min cd
+    RACIAL_ARCANE_TORRENT_DEATHKNIGHT   = 50613,//2sec AoE silence + energize, instant, 2 min cd
+    RACIAL_ARCANE_TORRENT_ROGUE         = 25046,
+    RACIAL_ARCANE_TORRENT_OTHERS        = 28730,
+    RACIAL_GIFT_OF_NAARU_WARRIOR        = 28880,//Hot over 15 sec, instant, 2 min cd
+    RACIAL_GIFT_OF_NAARU_PALADIN        = 59542,
+    RACIAL_GIFT_OF_NAARU_HUNTER         = 59543,
+    RACIAL_GIFT_OF_NAARU_PRIEST         = 59544,
+    RACIAL_GIFT_OF_NAARU_DEATHKNIGHT    = 59545,
+    RACIAL_GIFT_OF_NAARU_SHAMAN         = 59547,
+    RACIAL_GIFT_OF_NAARU_MAGE           = 59548,
+//COMMON GAMEOBJECTS
+    GO_REFRESHMENT_TABLE_1              = 186812,//lvl 65 req70
+    GO_REFRESHMENT_TABLE_2              = 193061,//lvl 80 req80
+    GO_SOULWELL_1                       = 181621,//lvl 60 req68
+    GO_SOULWELL_2                       = 193169,//lvl 69 req80
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    REGEN_CD                            = 1000, //update hp/mana every X milliseconds
+//COMMON TIMERS
+    ITEM_ENCHANTMENT_EXPIRE_TIMER       = 1 * HOUR * IN_MILLISECONDS,
+//COMMON GOSSIPS
+    GOSSIP_NORMAL_SERVE_MASTER          = 70001,//"I live only to serve the master."
+    GOSSIP_GREET_NEED_SMTH              = 70002,//"You need something?"
+    GOSSIP_GREET_MURDER                 = 70003,//"Mortals... usually I kill wretches like you at sight"
+    GOSSIP_GREET_CUSTOM_SPHYNX          = 70004,
+    GOSSIP_NORMAL_CUSTOM_SPHYNX         = 70005,
+    GOSSIP_GREET_CUSTOM_DREADLORD       = 70006,
+    GOSSIP_NORMAL_CUSTOM_DREADLORD      = 70007,
+    GOSSIP_GREET_CUSTOM_DARKRANGER      = 70008,
+    GOSSIP_NORMAL_CUSTOM_DARKRANGER     = 70009,
+    GOSSIP_CLASSDESC_BM                 = 70101,
+    GOSSIP_CLASSDESC_SPHYNX             = 70102,
+    GOSSIP_CLASSDESC_ARCHMAGE           = 70103,
+    GOSSIP_CLASSDESC_DREADLORD          = 70104,
+    GOSSIP_CLASSDESC_SPELLBREAKER       = 70105,
+    GOSSIP_CLASSDESC_DARKRANGER         = 70106,
+    GOSSIP_BOTGIVER_GREET               = 70201,
+    GOSSIP_BOTGIVER_HIRE                = 70202,
+    GOSSIP_BOTGIVER_HIRE_CLASS          = 70203,
+    GOSSIP_BOTGIVER_HIRE_EMPTY          = 70204,
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_BOTGIVER_HIRE,
+    GOSSIP_SENDER_BOTGIVER_HIRE_CLASS,
+    GOSSIP_SENDER_BOTGIVER_HIRE_ENTRY,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_CLASS_ACTION,
+    GOSSIP_SENDER_CLASS_ACTION2,
+    GOSSIP_SENDER_CLASS_ACTION3,
+    GOSSIP_SENDER_CLASS_ACTION4,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_UNEQUIP_ALL,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN = GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND = GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES_MAIN,
+    GOSSIP_SENDER_ROLES_MAIN_TOGGLE,
+    GOSSIP_SENDER_ROLES_GATHERING,
+    GOSSIP_SENDER_ROLES_GATHERING_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+    GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST,
+    GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE,
+    GOSSIP_SENDER_SPEC,
+    GOSSIP_SENDER_SPEC_SET,
+    GOSSIP_SENDER_USEITEM,
+    GOSSIP_SENDER_USEITEM_USE,
+    GOSSIP_SENDER_HIRE,
+    GOSSIP_SENDER_DISMISS,
+    GOSSIP_SENDER_JOIN_GROUP,
+    GOSSIP_SENDER_LEAVE_GROUP,
+    GOSSIP_SENDER_FORMATION,
+    GOSSIP_SENDER_FORMATION_FOLLOW_DISTANCE_SET,
+    GOSSIP_SENDER_FORMATION_ATTACK,
+    GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET,
+    GOSSIP_SENDER_MODEL_UPDATE,
+    GOSSIP_SENDER_HOLDPOSITION,
+    GOSSIP_SENDER_DONOTHING,
+    GOSSIP_SENDER_FOLLOWME,
+    GOSSIP_SENDER_TROUBLESHOOTING,
+    GOSSIP_SENDER_TROUBLESHOOTING_FIX,
+    GOSSIP_SENDER_TROUBLESHOOTING_AURA,
+    GOSSIP_SENDER_SCAN,
+    GOSSIP_SENDER_DEBUG,
+    GOSSIP_SENDER_DEBUG_ACTION,
+//GOSSIP CONST
+    BOT_GOSSIP_MAX_ITEMS                = 32, // Client limitation 3.3.5 code confirmed
+//COMMON NPCS
+    SHAMAN_EARTH_ELEMENTAL              = 15352,
+    SHAMAN_FIRE_ELEMENTAL               = 15438,
+    //NPC_WORLD_TRIGGER                   = 22515,
+//COMMON ITEM DISPLAY IDS
+    CHEST_HALISCAN                      = 50566, //Haliscan Jacket
+    LEGS_HALISCAN                       = 50567, //Haliscan Pants
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON MOUNTS SPELLS
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827,
+//COMMON AI MISC VALUES
+    BOTAI_MISC_COMBO_POINTS             = 1,
+    BOTAI_MISC_DAGGER_MAINHAND,
+    BOTAI_MISC_DAGGER_OFFHAND,
+    BOTAI_MISC_ENCHANT_IS_AUTO_MH,
+    BOTAI_MISC_ENCHANT_IS_AUTO_OH,
+    BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH,
+    BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH,
+    BOTAI_MISC_ENCHANT_CURRENT_MH,
+    BOTAI_MISC_ENCHANT_CURRENT_OH,
+    BOTAI_MISC_ENCHANT_AVAILABLE_1,
+    BOTAI_MISC_ENCHANT_AVAILABLE_2,
+    BOTAI_MISC_ENCHANT_AVAILABLE_3,
+    BOTAI_MISC_ENCHANT_AVAILABLE_4,
+    BOTAI_MISC_ENCHANT_AVAILABLE_5,
+    BOTAI_MISC_ENCHANT_AVAILABLE_6,
+    BOTAI_MISC_PET_TYPE,
+    BOTAI_MISC_PET_AVAILABLE_1,
+    BOTAI_MISC_PET_AVAILABLE_2,
+    BOTAI_MISC_PET_AVAILABLE_3,
+    BOTAI_MISC_PET_AVAILABLE_4,
+    BOTAI_MISC_PET_AVAILABLE_5,
+    BOTAI_MISC_PET_AVAILABLE_6,
+    BOTAI_MISC_PET_AVAILABLE_7,
+    BOTAI_MISC_PET_AVAILABLE_8,
+    BOTAI_MISC_PET_AVAILABLE_9,
+    BOTAI_MISC_PET_AVAILABLE_10,
+    BOTAI_MISC_PET_AVAILABLE_11,
+    BOTAI_MISC_WEAPON_SPEC,
+    BOTPETAI_MISC_DURATION,
+    BOTPETAI_MISC_MAXLEVEL,
+//ADVANCED
+    //HONORLESS_TARGET                    = 2479,
+    COSMETIC_TELEPORT_EFFECT            = 52096,//visual instant cast omni
+    COSMETIC_RESURRECTION               = 58854,//visual instant cast self (castable while dead, hidden)
+    SUMMON_DEMON_VISUAL                 = 6657,//SUMMON_SERPENT_MESSENGER
+    CALL_PET_VISUAL                     = 30416,//QUEST_WOOD_CLEANSE_EFFECT
+    SPELL_VERTEX_COLOR_BLACK            = 39662,//black color model full
+    SPELL_VERTEX_COLOR_GREY             = 43355,//grey color model full
+////CUSTOM SPELLS - UNUSED IN CODE AND DB
+  //common
+  //modify
+    SPELL_TRIGGERED_HEAL                = 25155,//hidden
+  //unmodify
+    SPELL_ATTACK_MELEE_1H               = 42880,
+    SPELL_TRIGGERED_ENERGIZE            = 60628,//hidden
+//BLADEMASTER
+  //SPELLS
+  //unmodify
+    //SPELL_DEATH_GRIP_JUMP               = 49575,
+/**/SPELL_CRITICAL_STRIKE               = 1132,
+    SPELL_BURNING_BLADE_BLADEMASTER     = 32281,//horde flag visual
+    SPELL_STUN_FREEZE_ANIM              = 59123,//stun forever, full stop
+  //modify
+    SPELL_TRANSPARENCY_50               = 44816,
+/**/SPELL_NETHERWALK                    = 31599,
+/**/SPELL_MIRROR_IMAGE_BM               = 69936,//blank spell
+    SPELL_COMBAT_SPECIAL_2H_ATTACK      = 44079,//animation only
+//SPHYNX
+  //modify
+    SPELL_SHADOW_BOLT                   = 16408,
+    SPELL_SHADOW_BLAST                  = 38085,
+    //SPELL_SHADOW_BLAST_SPLASH           = 38205,
+    SPELL_ATTACK_MELEE_RANDOM           = 42902,
+    SHADOWFURY_VISUAL                   = 47444,//59912,
+    SPELL_DEVOUR_MAGIC                  = 17012,//used by Spellmaw but no matter (this spell does not work as intended)
+    SPELL_DRAIN_MANA                    = 25755,
+    SPELL_REPLENISH_MANA                = 33394,//5406,
+    SPELL_REPLENISH_HEALTH              = 34756,//regenerating aura
+  //unmodify
+    SPELL_DEVOUR_MAGIC_CASTER_IMPACT    = 50527,
+    SPELL_DEVOUR_MAGIC_BEAM             = 54393,
+//ARCHMAGE
+  //modify
+    SPELL_BRILLIANCE_AURA               = 1234,
+    SPELL_FIREBALL                      = 9488,
+    SPELL_BLIZZARD                      = 15783,
+    SPELL_SUMMON_WATER_ELEMENTAL        = 35593,
+    SPELL_WATERBOLT                     = 72898,
+  //unmodify
+//DREADLORD
+  //modify
+    SPELL_VAMPIRIC_AURA                 = 20810,
+    SPELL_SLEEP                         = 20663,
+    SPELL_CARRION_SWARM                 = 34240,
+    SPELL_INFERNO                       = 12740, //summon infernal servant
+    SPELL_INFERNO_METEOR_VISUAL         = 5739, //meteor strike infernal
+  //unmodify
+    SPELL_INFERNO_EFFECT                = 22703, //stun, damage (warlock spell)
+    //SPELL_INFERNO_IMPACT_EXPLOSION      = 00000, //visual
+//SPELLBREAKER
+  //modify
+    SPELL_STEAL_MAGIC                   = 30036, //used by Ethereal Spellfilcher
+    SPELL_FEEDBACK                      = 32897,
+  //unmodify
+//DARK RANGER
+  //modify
+    SPELL_BLACK_ARROW                   = 20733, //supposed to be used by Dark Ranger Clea
+    SPELL_DRAIN_LIFE                    = 17238, //used by Maleki the Palid, supposed to be by Shadow Adept (31145)
+    SPELL_SILENCE                       = 29943,
+    //SPELL_CHARM                         = 11111, //
+  //unmodify
+
+  //SOUNDS
+    SOUND_FREEZE_IMPACT_WINDWALK        = 29,
+    SOUND_AXE_2H_IMPACT_FLESH_CRIT      = 158,
+    SOUND_ABSORB_GET_HIT                = 3334,
+    SOUND_MISS_WHOOSH_2H                = 7081,
+
+//UNUSED
+    //SPELL_SUMMON_FELBLAZE_PREVISUAL     = 46350,//green splash impact head/torso
+
+//OTHER
+    BASE_MANA_SPHYNX                    = 400 * 5,
+    BASE_MANA_SPELLBREAKER              = 250 * 5,
+    //base mana at 10
+    BASE_MANA_10_BM                     = 540 * 5,
+    BASE_MANA_10_ARCHMAGE               = 705 * 5,
+    BASE_MANA_10_DREADLORD              = 600 * 5,
+    BASE_MANA_10_DARK_RANGER            = 570 * 5,
+    //base mana at 1
+    BASE_MANA_1_BM                      = 240 * 5,
+    BASE_MANA_1_ARCHMAGE                = 285 * 5,
+    BASE_MANA_1_DREADLORD               = 270 * 5,
+    BASE_MANA_1_DARK_RANGER             = 225 * 5,
+    //MAX_LOOT_ITEMS                      = 18 // Client limitation 3.3.5 code confirmed
+};
+
+enum BotClasses
+{
+    BOT_CLASS_NONE                      = CLASS_NONE,
+    BOT_CLASS_WARRIOR                   = CLASS_WARRIOR,
+    BOT_CLASS_PALADIN                   = CLASS_PALADIN,
+    BOT_CLASS_HUNTER                    = CLASS_HUNTER,
+    BOT_CLASS_ROGUE                     = CLASS_ROGUE,
+    BOT_CLASS_PRIEST                    = CLASS_PRIEST,
+    BOT_CLASS_DEATH_KNIGHT              = CLASS_DEATH_KNIGHT,
+    BOT_CLASS_SHAMAN                    = CLASS_SHAMAN,
+    BOT_CLASS_MAGE                      = CLASS_MAGE,
+    BOT_CLASS_WARLOCK                   = CLASS_WARLOCK,
+    BOT_CLASS_DRUID                     = CLASS_DRUID,
+
+    BOT_CLASS_BM,
+    BOT_CLASS_SPHYNX,
+    BOT_CLASS_ARCHMAGE,
+    BOT_CLASS_DREADLORD,
+    BOT_CLASS_SPELLBREAKER,
+    BOT_CLASS_DARK_RANGER,
+    BOT_CLASS_END
+};
+
+#define BOT_CLASS_EX_START BOT_CLASS_BM
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = BOT_CLASS_END,
+    WARRIOR_DEFENSIVE_STANCE,
+    WARRIOR_BERSERKER_STANCE,
+    DEATH_KNIGHT_BLOOD_PRESENCE,
+    DEATH_KNIGHT_FROST_PRESENCE,
+    DEATH_KNIGHT_UNHOLY_PRESENCE,
+    DRUID_BEAR_FORM,
+    DRUID_CAT_FORM,
+    DRUID_MOONKIN_FORM,
+    DRUID_TREE_FORM,
+    DRUID_TRAVEL_FORM,
+    DRUID_AQUATIC_FORM,
+    //DRUID_FLIGHT_FORM //NYI
+};
+
+enum BotRoles
+{
+    BOT_ROLE_NONE                       = 0x000,
+    BOT_ROLE_TANK                       = 0x001,
+    BOT_ROLE_DPS                        = 0x002,
+    BOT_ROLE_HEAL                       = 0x004,
+    BOT_ROLE_RANGED                     = 0x008,
+
+    BOT_ROLE_PARTY                      = 0x010, //hidden
+
+    BOT_ROLE_GATHERING_MINING           = 0x020,
+    BOT_ROLE_GATHERING_HERBALISM        = 0x040,
+    BOT_ROLE_GATHERING_SKINNING         = 0x080,
+    BOT_ROLE_GATHERING_ENGINEERING      = 0x100,
+
+    BOT_MAX_ROLE                        = 0x200,
+
+    BOT_ROLE_MASK_MAIN                  = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL | BOT_ROLE_RANGED),
+    //BOT_ROLE_MASK_MAIN_EX               = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL | BOT_ROLE_RANGED | BOT_ROLE_PARTY),
+    BOT_ROLE_MASK_GATHERING             = (BOT_ROLE_GATHERING_MINING | BOT_ROLE_GATHERING_HERBALISM | BOT_ROLE_GATHERING_SKINNING | BOT_ROLE_GATHERING_ENGINEERING),
+
+    //BOT_ROLE_TANK_MELEE                 = (BOT_ROLE_TANK | BOT_ROLE_DPS),
+    //BOT_ROLE_TANK_RANGED                = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_RANGED),
+    //BOT_ROLE_TANK_RANGED_NODPS          = (BOT_ROLE_TANK | BOT_ROLE_RANGED),
+};
+
+enum BotTalentSpecs
+{
+    BOT_SPEC_WARRIOR_ARMS               = 1,
+    BOT_SPEC_WARRIOR_FURY               = 2,
+    BOT_SPEC_WARRIOR_PROTECTION         = 3,
+    BOT_SPEC_PALADIN_HOLY               = 4,
+    BOT_SPEC_PALADIN_PROTECTION         = 5,
+    BOT_SPEC_PALADIN_RETRIBUTION        = 6,
+    BOT_SPEC_HUNTER_BEASTMASTERY        = 7,
+    BOT_SPEC_HUNTER_MARKSMANSHIP        = 8,
+    BOT_SPEC_HUNTER_SURVIVAL            = 9,
+    BOT_SPEC_ROGUE_ASSASINATION         = 10,
+    BOT_SPEC_ROGUE_COMBAT               = 11,
+    BOT_SPEC_ROGUE_SUBTLETY             = 12,
+    BOT_SPEC_PRIEST_DISCIPLINE          = 13,
+    BOT_SPEC_PRIEST_HOLY                = 14,
+    BOT_SPEC_PRIEST_SHADOW              = 15,
+    BOT_SPEC_DK_BLOOD                   = 16,
+    BOT_SPEC_DK_FROST                   = 17,
+    BOT_SPEC_DK_UNHOLY                  = 18,
+    BOT_SPEC_SHAMAN_ELEMENTAL           = 19,
+    BOT_SPEC_SHAMAN_ENHANCEMENT         = 20,
+    BOT_SPEC_SHAMAN_RESTORATION         = 21,
+    BOT_SPEC_MAGE_ARCANE                = 22,
+    BOT_SPEC_MAGE_FIRE                  = 23,
+    BOT_SPEC_MAGE_FROST                 = 24,
+    BOT_SPEC_WARLOCK_AFFLICTION         = 25,
+    BOT_SPEC_WARLOCK_DEMONOLOGY         = 26,
+    BOT_SPEC_WARLOCK_DESTRUCTION        = 27,
+    BOT_SPEC_DRUID_BALANCE              = 28,
+    BOT_SPEC_DRUID_FERAL                = 29,
+    BOT_SPEC_DRUID_RESTORATION          = 30,
+    BOT_SPEC_DEFAULT                    = 31,
+
+    BOT_SPEC_BEGIN                      = BOT_SPEC_WARRIOR_ARMS,
+    BOT_SPEC_END                        = BOT_SPEC_DEFAULT
+
+};
+
+enum BotPetTypes
+{
+    //Warlock
+    BOT_PET_IMP                         = 70501,
+    BOT_PET_VOIDWALKER                  = 70502,
+    BOT_PET_SUCCUBUS                    = 70503,
+    BOT_PET_FELHUNTER                   = 70504,
+    BOT_PET_FELGUARD                    = 70505,
+
+    BOT_PET_WARLOCK_START               = BOT_PET_IMP,
+    BOT_PET_WARLOCK_END                 = BOT_PET_FELGUARD,
+
+    //Hunter
+    //cunning
+    BOT_PET_SPIDER                      = 70506,
+    BOT_PET_SERPENT                     = 70507,
+    BOT_PET_BIRDOFPREY                  = 70508,
+    BOT_PET_BAT                         = 70509,
+    BOT_PET_WINDSERPENT                 = 70510,
+    BOT_PET_RAVAGER                     = 70511,
+    BOT_PET_DRAGONHAWK                  = 70512,
+    BOT_PET_NETHERRAY                   = 70513,
+    BOT_PET_SPOREBAT                    = 70514,
+    //ferocity
+    BOT_PET_CARRIONBIRD                 = 70515,
+    BOT_PET_RAPTOR                      = 70516,
+    BOT_PET_WOLF                        = 70517,
+    BOT_PET_TALLSTRIDER                 = 70518,
+    BOT_PET_CAT                         = 70519,
+    BOT_PET_HYENA                       = 70520,
+    BOT_PET_WASP                        = 70521,
+    BOT_PET_TEROMOTH                    = 70522,
+    //tenacity
+    BOT_PET_SCORPID                     = 70523,
+    BOT_PET_TURTLE                      = 70524,
+    BOT_PET_GORILLA                     = 70525,
+    BOT_PET_BEAR                        = 70526,
+    BOT_PET_BOAR                        = 70527,
+    BOT_PET_CRAB                        = 70528,
+    BOT_PET_CROCOLISK                   = 70529,
+    BOT_PET_WARPSTALKER                 = 70530,
+    //cunning (exotic)
+    BOT_PET_SILITHID                    = 70531,
+    BOT_PET_CHIMAERA                    = 70532,
+    //ferocity (exotic)
+    BOT_PET_SPIRITBEAST                 = 70533,
+    BOT_PET_COREHOUND                   = 70534,
+    BOT_PET_DEVILSAUR                   = 70535,
+    //tenacity (exotic)
+    BOT_PET_RHINO                       = 70536,
+    BOT_PET_WORM                        = 70537,
+
+    BOT_PET_HUNTER_START                = BOT_PET_SPIDER,
+    BOT_PET_HUNTER_END_GENERAL          = BOT_PET_WARPSTALKER,
+    BOT_PET_HUNTER_END_EXOTIC           = BOT_PET_WORM,
+
+    BOT_PET_CUNNING_START               = BOT_PET_SPIDER,
+    BOT_PET_CUNNING_END                 = BOT_PET_SPOREBAT,
+    BOT_PET_FEROCITY_START              = BOT_PET_CARRIONBIRD,
+    BOT_PET_FEROCITY_END                = BOT_PET_TEROMOTH,
+    BOT_PET_TENACITY_START              = BOT_PET_SCORPID,
+    BOT_PET_TENACITY_END                = BOT_PET_WARPSTALKER,
+
+    BOT_PET_EXOTIC_START                = BOT_PET_SILITHID,
+    BOT_PET_EXOTIC_END                  = BOT_PET_WORM,
+
+    //DK
+    BOT_PET_GHOUL                       = 70538,
+    BOT_PET_GARGOYLE                    = 70539,//NYI
+    BOT_PET_DANCING_RUNE_WEAPON         = 70540,//NYI
+    BOT_PET_AOD_GHOUL                   = 70541,//NYI
+
+    //Priest
+    BOT_PET_SHADOWFIEND                 = 70542,
+
+    //Shaman
+    BOT_PET_SPIRIT_WOLF                 = 70543,
+
+    //Mage
+    BOT_PET_WATER_ELEMENTAL             = 70544,
+
+    //Druid
+    BOT_PET_FORCE_OF_NATURE             = 70545,
+
+    //Archmage
+    BOT_PET_AWATER_ELEMENTAL            = 70556,
+
+    //Dreadlord
+    BOT_PET_INFERNAL                    = 70562,
+
+    //Dark Ranger
+    BOT_PET_DARK_MINION                 = 70573,
+    BOT_PET_DARK_MINION_ELITE           = 70574,
+
+    BOT_PET_INVALID                     = 99999
+};
+
+enum BotPetOriginalEntries
+{
+    ORIGINAL_ENTRY_IMP                  = 416,
+    ORIGINAL_ENTRY_VOIDWALKER           = 1860,
+    ORIGINAL_ENTRY_SUCCUBUS             = 1863,
+    ORIGINAL_ENTRY_FELHUNTER            = 417,
+    ORIGINAL_ENTRY_FELGUARD             = 17252,
+    //ORIGINAL_ENTRY_GHOUL                = 26125,
+    //ORIGINAL_ENTRY_SHADOWFIEND          = 19668,
+    //ORIGINAL_ENTRY_SPIRIT_WOLF          = 29264,
+    ORIGINAL_ENTRY_WATER_ELEMENTAL      = 510,
+    //ORIGINAL_ENTRY_FORCE_OF_NATURE      = 1964,
+    ORIGINAL_ENTRY_HUNTER_PET           = 1 // from Pet.cpp InitStatsForLevel()
+};
+
+enum BotEquipSlot
+{
+    BOT_SLOT_MAINHAND           = 0,
+    BOT_SLOT_OFFHAND            = 1,
+    BOT_SLOT_RANGED             = 2,
+    BOT_SLOT_HEAD               = 3,
+    BOT_SLOT_SHOULDERS          = 4,
+    BOT_SLOT_CHEST              = 5,
+    BOT_SLOT_WAIST              = 6,
+    BOT_SLOT_LEGS               = 7,
+    BOT_SLOT_FEET               = 8,
+    BOT_SLOT_WRIST              = 9,
+    BOT_SLOT_HANDS              = 10,
+    BOT_SLOT_BACK               = 11,
+    BOT_SLOT_BODY               = 12,
+    BOT_SLOT_FINGER1            = 13,
+    BOT_SLOT_FINGER2            = 14,
+    BOT_SLOT_TRINKET1           = 15,
+    BOT_SLOT_TRINKET2           = 16,
+    BOT_SLOT_NECK               = 17,
+    BOT_INVENTORY_SIZE
+};
+
+enum BotStatMods
+{
+    //ItemProtoType.h
+    BOT_STAT_MOD_MANA                       = 0,
+    BOT_STAT_MOD_HEALTH                     = 1,
+    BOT_STAT_MOD_AGILITY                    = 3,
+    BOT_STAT_MOD_STRENGTH                   = 4,
+    BOT_STAT_MOD_INTELLECT                  = 5,
+    BOT_STAT_MOD_SPIRIT                     = 6,
+    BOT_STAT_MOD_STAMINA                    = 7,
+    BOT_STAT_MOD_DEFENSE_SKILL_RATING       = 12,
+    BOT_STAT_MOD_DODGE_RATING               = 13,
+    BOT_STAT_MOD_PARRY_RATING               = 14,
+    BOT_STAT_MOD_BLOCK_RATING               = 15,
+    BOT_STAT_MOD_HIT_MELEE_RATING           = 16,
+    BOT_STAT_MOD_HIT_RANGED_RATING          = 17,
+    BOT_STAT_MOD_HIT_SPELL_RATING           = 18,
+    BOT_STAT_MOD_CRIT_MELEE_RATING          = 19,
+    BOT_STAT_MOD_CRIT_RANGED_RATING         = 20,
+    BOT_STAT_MOD_CRIT_SPELL_RATING          = 21,
+    BOT_STAT_MOD_HIT_TAKEN_MELEE_RATING     = 22,
+    BOT_STAT_MOD_HIT_TAKEN_RANGED_RATING    = 23,
+    BOT_STAT_MOD_HIT_TAKEN_SPELL_RATING     = 24,
+    BOT_STAT_MOD_CRIT_TAKEN_MELEE_RATING    = 25,
+    BOT_STAT_MOD_CRIT_TAKEN_RANGED_RATING   = 26,
+    BOT_STAT_MOD_CRIT_TAKEN_SPELL_RATING    = 27,
+    BOT_STAT_MOD_HASTE_MELEE_RATING         = 28,
+    BOT_STAT_MOD_HASTE_RANGED_RATING        = 29,
+    BOT_STAT_MOD_HASTE_SPELL_RATING         = 30,
+    BOT_STAT_MOD_HIT_RATING                 = 31,
+    BOT_STAT_MOD_CRIT_RATING                = 32,
+    BOT_STAT_MOD_HIT_TAKEN_RATING           = 33,
+    BOT_STAT_MOD_CRIT_TAKEN_RATING          = 34,
+    BOT_STAT_MOD_RESILIENCE_RATING          = 35,
+    BOT_STAT_MOD_HASTE_RATING               = 36,
+    BOT_STAT_MOD_EXPERTISE_RATING           = 37,
+    BOT_STAT_MOD_ATTACK_POWER               = 38,
+    BOT_STAT_MOD_RANGED_ATTACK_POWER        = 39,
+    BOT_STAT_MOD_FERAL_ATTACK_POWER         = 40,
+    BOT_STAT_MOD_SPELL_HEALING_DONE         = 41,                 // deprecated
+    BOT_STAT_MOD_SPELL_DAMAGE_DONE          = 42,                 // deprecated
+    BOT_STAT_MOD_MANA_REGENERATION          = 43,
+    BOT_STAT_MOD_ARMOR_PENETRATION_RATING   = 44,
+    BOT_STAT_MOD_SPELL_POWER                = 45,
+    BOT_STAT_MOD_HEALTH_REGEN               = 46,
+    BOT_STAT_MOD_SPELL_PENETRATION          = 47,
+    BOT_STAT_MOD_BLOCK_VALUE                = 48,
+    //END ItemProtoType.h
+
+    BOT_STAT_MOD_DAMAGE_MIN                 = MAX_ITEM_MOD,
+    BOT_STAT_MOD_DAMAGE_MAX,
+    BOT_STAT_MOD_ARMOR,
+    BOT_STAT_MOD_RESIST_HOLY,
+    BOT_STAT_MOD_RESIST_FIRE,
+    BOT_STAT_MOD_RESIST_NATURE,
+    BOT_STAT_MOD_RESIST_FROST,
+    BOT_STAT_MOD_RESIST_SHADOW,
+    BOT_STAT_MOD_RESIST_ARCANE,
+    BOT_STAT_MOD_EX,
+    MAX_BOT_ITEM_MOD,
+
+    BOT_STAT_MOD_RESISTANCE_START           = BOT_STAT_MOD_ARMOR
+};
+
+enum BotAIResetType
+{
+    BOTAI_RESET_INIT                    = 0x01,
+    BOTAI_RESET_DISMISS                 = 0x02,
+    BOTAI_RESET_LOST                    = 0x04,
+    BOTAI_RESET_LOGOUT                  = 0x08,
+
+    BOTAI_RESET_MASK_ABANDON_MASTER     = (BOTAI_RESET_INIT | BOTAI_RESET_DISMISS)
+};
+
+enum BotCommandStates
+{
+    BOT_COMMAND_STAY                    = 0x01,
+    BOT_COMMAND_FOLLOW                  = 0x02,
+    BOT_COMMAND_ATTACK                  = 0x04,
+    BOT_COMMAND_COMBATRESET             = 0x08,
+    BOT_COMMAND_FULLSTOP                = 0x10,
+
+    BOT_COMMAND_MASK_UNCHASE            = BOT_COMMAND_STAY | BOT_COMMAND_FOLLOW | BOT_COMMAND_FULLSTOP,
+    BOT_COMMAND_MASK_UNMOVING           = BOT_COMMAND_STAY | BOT_COMMAND_FULLSTOP
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botdatamgr.cpp b/src/server/game/AI/NpcBots/botdatamgr.cpp
new file mode 100644
index 0000000..558eaa4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdatamgr.cpp
@@ -0,0 +1,437 @@
+#include "botdatamgr.h"
+#include "Item.h"
+#include "Map.h"
+#include "MapManager.h"
+/*
+Npc Bot Data Manager by Trickerer (onlysuffering@gmail.com)
+NpcBots DB Data management
+%Complete: ???
+*/
+
+typedef std::unordered_map<uint32 /*entry*/, NpcBotData*> NpcBotDataMap;
+typedef std::unordered_map<uint32 /*entry*/, NpcBotAppearanceData*> NpcBotAppearanceDataMap;
+typedef std::unordered_map<uint32 /*entry*/, NpcBotExtras*> NpcBotExtrasMap;
+typedef std::set<Creature const*> NpcBotRegistry;
+NpcBotDataMap _botsData;
+NpcBotAppearanceDataMap _botsAppearanceData;
+NpcBotExtrasMap _botsExtras;
+NpcBotRegistry _existingBots;
+
+static std::shared_mutex _lock;
+
+bool allBotsLoaded = false;
+
+bool BotDataMgr::AllBotsLoaded()
+{
+    return allBotsLoaded;
+}
+
+void BotDataMgr::LoadNpcBots()
+{
+    uint32 botoldMSTime = getMSTime();
+
+    TC_LOG_INFO("server.loading", "Starting NpcBot system...");
+
+    Field* field;
+    uint8 index;
+
+    //                                                      1       2     3     4     5          6
+    QueryResult result = WorldDatabase.Query("SELECT entry, gender, skin, face, hair, haircolor, features FROM creature_template_npcbot_appearance");
+    if (result)
+    {
+        do
+        {
+            field = result->Fetch();
+            index = 0;
+            uint32 entry = field[  index].GetUInt32();
+
+            NpcBotAppearanceData* appearanceData = new NpcBotAppearanceData();
+            appearanceData->gender =    field[++index].GetUInt8();
+            appearanceData->skin =      field[++index].GetUInt8();
+            appearanceData->face =      field[++index].GetUInt8();
+            appearanceData->hair =      field[++index].GetUInt8();
+            appearanceData->haircolor = field[++index].GetUInt8();
+            appearanceData->features =  field[++index].GetUInt8();
+
+            _botsAppearanceData[entry] = appearanceData;
+
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", ">> Bot appearance data loaded");
+    }
+    else
+        TC_LOG_INFO("server.loading", ">> Bots appearance data is not loaded. Table `creature_template_npcbot_appearance` is empty!");
+
+    //                                          1      2
+    result = WorldDatabase.Query("SELECT entry, class, race FROM creature_template_npcbot_extras");
+    if (result)
+    {
+        do
+        {
+            field = result->Fetch();
+            index = 0;
+            uint32 entry =      field[  index].GetUInt32();
+
+            NpcBotExtras* extras = new NpcBotExtras();
+            extras->bclass =    field[++index].GetUInt8();
+            extras->race =      field[++index].GetUInt8();
+
+            _botsExtras[entry] = extras;
+
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", ">> Bot race data loaded");
+    }
+    else
+        TC_LOG_INFO("server.loading", ">> Bots race data is not loaded. Table `creature_template_npcbot_extras` is empty!");
+
+    //                                              1      2      3     4        5          6          7          8          9               10          11          12         13
+    result = CharacterDatabase.Query("SELECT entry, owner, roles, spec, faction, equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet,"
+    //   14          15          16         17         18            19            20             21             22
+        "equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM characters_npcbot");
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", ">> Spawned 0 npcbots. Table `characters_npcbot` is empty!");
+        allBotsLoaded = true;
+        return;
+    }
+
+    uint32 botcounter = 0;
+    uint32 datacounter = 0;
+    std::list<uint32> botgrids;
+    QueryResult infores;
+    CreatureTemplate const* proto;
+    NpcBotData* botData;
+    std::list<uint32> entryList;
+
+    do
+    {
+        field = result->Fetch();
+        index = 0;
+        uint32 entry =          field[  index].GetUInt32();
+
+        //load data
+        botData = new NpcBotData(0, 0);
+        botData->owner =        field[++index].GetUInt32();
+        botData->roles =        field[++index].GetUInt16();
+        botData->spec =         field[++index].GetUInt8();
+        botData->faction =      field[++index].GetUInt32();
+
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            botData->equips[i] = field[++index].GetUInt32();
+
+        entryList.push_back(entry);
+        _botsData[entry] = botData;
+        ++datacounter;
+
+    } while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u bot data entries", datacounter);
+
+    for (std::list<uint32>::const_iterator itr = entryList.begin(); itr != entryList.end(); ++itr)
+    {
+        uint32 entry = *itr;
+        proto = sObjectMgr->GetCreatureTemplate(entry);
+        if (!proto)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot find creature_template entry for npcbot (id: %u)!", entry);
+            continue;
+        }
+        //                                     1     2    3           4            5           6
+        infores = WorldDatabase.PQuery("SELECT guid, map, position_x, position_y"/*, position_z, orientation*/" FROM creature WHERE id = %u", entry);
+        if (!infores)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot spawn npcbot %s (id: %u), not found in `creature` table!", proto->Name.c_str(), entry);
+            continue;
+        }
+
+        field = infores->Fetch();
+        uint32 tableGuid = field[0].GetUInt32();
+        uint32 mapId = uint32(field[1].GetUInt16());
+        float pos_x = field[2].GetFloat();
+        float pos_y = field[3].GetFloat();
+        //float pos_z = field[4].GetFloat();
+        //float ori = field[5].GetFloat();
+
+        CellCoord c = Trinity::ComputeCellCoord(pos_x, pos_y);
+        GridCoord g = Trinity::ComputeGridCoord(pos_x, pos_y);
+        ASSERT(c.IsCoordValid() && "Invalid Cell coord!");
+        ASSERT(g.IsCoordValid() && "Invalid Grid coord!");
+        Map* map = sMapMgr->CreateBaseMap(mapId);
+        map->LoadGrid(pos_x, pos_y);
+
+        typedef std::unordered_multimap<uint32, Creature*>::iterator SpawnIter;
+        std::pair<SpawnIter, SpawnIter> creBounds = map->GetCreatureBySpawnIdStore().equal_range(tableGuid);
+        if (creBounds.first == map->GetCreatureBySpawnIdStore().end())
+        {
+            TC_LOG_ERROR("server.loading", "bot %u is not in spawns list, consider re-spawning it!", entry);
+            continue;
+        }
+
+        ObjectGuid Guid(HighGuid::Unit, entry, tableGuid);
+        TC_LOG_DEBUG("server.loading", "bot %u: spawnId %u, full %s", entry, tableGuid, Guid.ToString().c_str());
+        Creature* bot = map->GetCreature(Guid);
+        if (!bot) //not in map, use storage
+            bot = creBounds.first->second;
+        ASSERT(bot);
+        if (!bot->FindMap())
+            TC_LOG_ERROR("server.loading", "bot %u is not in map!", entry);
+        if (!bot->IsInWorld())
+            TC_LOG_ERROR("server.loading", "bot %u is not in world!", entry);
+        if (!bot->IsAlive())
+        {
+            TC_LOG_ERROR("server.loading", "bot %u is dead, respawning!", entry);
+            bot->Respawn();
+        }
+
+        TC_LOG_DEBUG("server.loading", ">> Spawned npcbot %s (id: %u, map: %u, grid: %u, cell: %u)", proto->Name.c_str(), entry, mapId, g.GetId(), c.GetId());
+        botgrids.push_back(g.GetId());
+        ++botcounter;
+    }
+
+    botgrids.sort();
+    botgrids.unique();
+    TC_LOG_INFO("server.loading", ">> Spawned %u npcbot(s) within %u grid(s) in %u ms", botcounter, uint32(botgrids.size()), GetMSTimeDiffToNow(botoldMSTime));
+
+    allBotsLoaded = true;
+}
+
+void BotDataMgr::AddNpcBotData(uint32 entry, uint16 roles, uint8 spec, uint32 faction)
+{
+    //botData must be allocated explicitly
+    NpcBotDataMap::iterator itr = _botsData.find(entry);
+    if (itr == _botsData.end())
+    {
+        NpcBotData* botData = new NpcBotData(roles, faction, spec);
+        _botsData[entry] = botData;
+
+        CharacterDatabasePreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles, spec, faction) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+        bstmt->setUInt32(0, entry);
+        bstmt->setUInt16(1, roles);
+        bstmt->setUInt8(2, spec);
+        bstmt->setUInt32(3, faction);
+        CharacterDatabase.Execute(bstmt);
+
+        return;
+    }
+
+    TC_LOG_ERROR("sql.sql", "BotMgr::AddNpcBotData(): trying to add new data but entry already exists! entry = %u", entry);
+}
+NpcBotData const* BotDataMgr::SelectNpcBotData(uint32 entry)
+{
+    NpcBotDataMap::const_iterator itr = _botsData.find(entry);
+    return itr != _botsData.end() ? itr->second : nullptr;
+}
+void BotDataMgr::UpdateNpcBotData(uint32 entry, NpcBotDataUpdateType updateType, void* data)
+{
+    NpcBotDataMap::iterator itr = _botsData.find(entry);
+    if (itr == _botsData.end())
+        return;
+
+    CharacterDatabasePreparedStatement* bstmt;
+    switch (updateType)
+    {
+        case NPCBOT_UPDATE_OWNER:
+            itr->second->owner = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+            //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, itr->second->owner);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_ROLES:
+            itr->second->roles = *(uint16*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+            //"UPDATE character_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt16(0, itr->second->roles);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_SPEC:
+            itr->second->spec = *(uint8*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_SPEC);
+            //"UPDATE characters_npcbot SET spec = ? WHERE entry = ?", CONNECTION_ASYNCH
+            bstmt->setUInt8(0, itr->second->spec);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_FACTION:
+            itr->second->faction = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_FACTION);
+            //"UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_ASYNCH
+            bstmt->setUInt32(0, itr->second->faction);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_EQUIPS:
+        {
+            Item** items = (Item**)(data);
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(entry, id);
+
+            CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+            //"UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?,
+            //equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC
+            CharacterDatabasePreparedStatement* stmt;
+            uint8 k;
+            for (k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+            {
+                itr->second->equips[k] = items[k] ? items[k]->GetGUID().GetCounter() : 0;
+                if (Item const* botitem = items[k])
+                {
+                    bool standard = false;
+                    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+                    {
+                        if (einfo->ItemEntry[i] == botitem->GetEntry())
+                        {
+                            itr->second->equips[k] = 0;
+                            bstmt->setUInt32(k, 0);
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    uint8 index = 0;
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ITEM_INSTANCE);
+                    //REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid)
+                    //VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC : 0-13
+                    stmt->setUInt32(  index, botitem->GetEntry());
+                    stmt->setUInt32(++index, botitem->GetOwnerGUID().GetCounter());
+                    stmt->setUInt32(++index, botitem->GetGuidValue(ITEM_FIELD_CREATOR).GetCounter());
+                    stmt->setUInt32(++index, botitem->GetGuidValue(ITEM_FIELD_GIFTCREATOR).GetCounter());
+                    stmt->setUInt32(++index, botitem->GetCount());
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_DURATION));
+
+                    std::ostringstream ssSpells;
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                        ssSpells << botitem->GetSpellCharges(i) << ' ';
+                    stmt->setString(++index, ssSpells.str());
+
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_FLAGS));
+
+                    std::ostringstream ssEnchants;
+                    for (uint8 i = 0; i < MAX_ENCHANTMENT_SLOT; ++i)
+                    {
+                        ssEnchants << botitem->GetEnchantmentId(EnchantmentSlot(i)) << ' ';
+                        ssEnchants << botitem->GetEnchantmentDuration(EnchantmentSlot(i)) << ' ';
+                        ssEnchants << botitem->GetEnchantmentCharges(EnchantmentSlot(i)) << ' ';
+                    }
+                    stmt->setString(++index, ssEnchants.str());
+
+                    stmt->setInt16 (++index, botitem->GetItemRandomPropertyId());
+                    stmt->setUInt16(++index, botitem->GetUInt32Value(ITEM_FIELD_DURABILITY));
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
+                    stmt->setString(++index, botitem->GetText());
+                    stmt->setUInt32(++index, botitem->GetGUID().GetCounter());
+
+                    trans->Append(stmt);
+
+                    Item::DeleteFromInventoryDB(trans, botitem->GetGUID().GetCounter()); //prevent duplicates
+
+                    bstmt->setUInt32(k, botitem->GetGUID().GetCounter());
+                }
+                else
+                    bstmt->setUInt32(k, uint32(0));
+            }
+
+            bstmt->setUInt32(k, entry);
+            trans->Append(bstmt);
+            CharacterDatabase.CommitTransaction(trans);
+            break;
+        }
+        case NPCBOT_UPDATE_ERASE:
+        {
+            NpcBotDataMap::iterator itr = _botsData.find(entry);
+            ASSERT(itr != _botsData.end());
+            delete itr->second;
+            _botsData.erase(itr);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+            //"DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        }
+        default:
+            TC_LOG_ERROR("sql.sql", "BotDataMgr:UpdateNpcBotData: unhandled updateType %u", uint32(updateType));
+            break;
+    }
+}
+void BotDataMgr::UpdateNpcBotDataAll(uint32 playerGuid, NpcBotDataUpdateType updateType, void* data)
+{
+    CharacterDatabasePreparedStatement* bstmt;
+    switch (updateType)
+    {
+        case NPCBOT_UPDATE_OWNER:
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER_ALL);
+            //"UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, *(uint32*)(data));
+            bstmt->setUInt32(1, playerGuid);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        //case NPCBOT_UPDATE_ROLES:
+        //case NPCBOT_UPDATE_FACTION:
+        //case NPCBOT_UPDATE_EQUIPS:
+        default:
+            TC_LOG_ERROR("sql.sql", "BotDataMgr:UpdateNpcBotDataAll: unhandled updateType %u", uint32(updateType));
+            break;
+    }
+}
+
+NpcBotAppearanceData const* BotDataMgr::SelectNpcBotAppearance(uint32 entry)
+{
+    NpcBotAppearanceDataMap::const_iterator itr = _botsAppearanceData.find(entry);
+    return itr != _botsAppearanceData.end() ? itr->second : nullptr;
+}
+
+NpcBotExtras const* BotDataMgr::SelectNpcBotExtras(uint32 entry)
+{
+    NpcBotExtrasMap::const_iterator itr = _botsExtras.find(entry);
+    return itr != _botsExtras.end() ? itr->second : nullptr;
+}
+
+void BotDataMgr::RegisterBot(Creature const* bot)
+{
+    if (_existingBots.find(bot) != _existingBots.end())
+    {
+        TC_LOG_ERROR("entities.unit", "BotDataMgr::RegisterBot: bot %u (%s) already registered!",
+            bot->GetEntry(), bot->GetName().c_str());
+        return;
+    }
+
+    std::unique_lock<std::shared_mutex> lock(_lock);
+
+    _existingBots.insert(bot);
+    //TC_LOG_ERROR("entities.unit", "BotDataMgr::RegisterBot: registered bot %u (%s)", bot->GetEntry(), bot->GetName().c_str());
+}
+void BotDataMgr::UnregisterBot(Creature const* bot)
+{
+    if (_existingBots.find(bot) == _existingBots.end())
+    {
+        TC_LOG_ERROR("entities.unit", "BotDataMgr::UnregisterBot: bot %u (%s) not found!",
+            bot->GetEntry(), bot->GetName().c_str());
+        return;
+    }
+
+    std::unique_lock<std::shared_mutex> lock(_lock);
+
+    _existingBots.erase(bot);
+    //TC_LOG_ERROR("entities.unit", "BotDataMgr::UnregisterBot: unregistered bot %u (%s)", bot->GetEntry(), bot->GetName().c_str());
+}
+Creature const* BotDataMgr::FindBotInWorld(uint32 entry)
+{
+    std::shared_lock<std::shared_mutex> lock(_lock);
+
+    for (NpcBotRegistry::const_iterator ci = _existingBots.begin(); ci != _existingBots.end(); ++ci)
+    {
+        if ((*ci)->GetEntry() == entry)
+            return *ci;
+    }
+    return nullptr;
+}
diff --git a/src/server/game/AI/NpcBots/botdatamgr.h b/src/server/game/AI/NpcBots/botdatamgr.h
new file mode 100644
index 0000000..7734dfa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdatamgr.h
@@ -0,0 +1,89 @@
+#ifndef _BOTDATAMGR_H
+#define _BOTDATAMGR_H
+
+#include "botcommon.h"
+
+class Creature;
+
+enum NpcBotDataUpdateType
+{
+    NPCBOT_UPDATE_OWNER                 = 1,
+    NPCBOT_UPDATE_ROLES,
+    NPCBOT_UPDATE_SPEC,
+    NPCBOT_UPDATE_FACTION,
+    NPCBOT_UPDATE_EQUIPS,
+    NPCBOT_UPDATE_ERASE,
+    NPCBOT_UPDATE_END
+};
+
+struct NpcBotData
+{
+    friend class BotDataMgr;
+public:
+    uint32 owner;
+    uint16 roles;
+    uint32 faction;
+    uint8 spec;
+    uint32 equips[BOT_INVENTORY_SIZE];
+
+private:
+    explicit NpcBotData(uint16 iroles, uint32 ifaction, uint8 ispec = 1) : owner(0), roles(iroles), faction(ifaction), spec(ispec)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            equips[i] = 0;
+    }
+    NpcBotData(NpcBotData const&);
+};
+
+struct NpcBotAppearanceData
+{
+    friend class BotDataMgr;
+public:
+    uint8 gender;
+    uint8 skin;
+    uint8 face;
+    uint8 hair;
+    uint8 haircolor;
+    uint8 features;
+private:
+    explicit NpcBotAppearanceData() {}
+    NpcBotAppearanceData(NpcBotAppearanceData const&);
+};
+
+struct NpcBotExtras
+{
+    friend class BotDataMgr;
+public:
+    uint8 race;
+    uint8 bclass;
+private:
+    explicit NpcBotExtras() {}
+    NpcBotExtras(NpcBotExtras const&);
+};
+
+class BotDataMgr
+{
+    public:
+        static void LoadNpcBots();
+
+        static void AddNpcBotData(uint32 entry, uint16 roles, uint8 spec, uint32 faction);
+        static NpcBotData const* SelectNpcBotData(uint32 entry);
+        static void UpdateNpcBotData(uint32 entry, NpcBotDataUpdateType updateType, void* data = nullptr);
+        static void UpdateNpcBotDataAll(uint32 playerGuid, NpcBotDataUpdateType updateType, void* data = nullptr);
+
+        static NpcBotAppearanceData const* SelectNpcBotAppearance(uint32 entry);
+        static NpcBotExtras const* SelectNpcBotExtras(uint32 entry);
+
+        static bool AllBotsLoaded();
+
+        static void RegisterBot(Creature const* bot);
+        static void UnregisterBot(Creature const* bot);
+        static Creature const* FindBotInWorld(uint32 entry);
+
+    private:
+
+        BotDataMgr() {}
+        BotDataMgr(BotDataMgr const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botdpstracker.cpp b/src/server/game/AI/NpcBots/botdpstracker.cpp
new file mode 100644
index 0000000..e1d2aa2
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdpstracker.cpp
@@ -0,0 +1,131 @@
+#include "botdpstracker.h"
+/*
+Name: bot_dps_tracker
+%Complete: 100
+Comment: dps taken tracker for NPCBot system by Trickerer (onlysuffering@gmail.com)
+DPS trackers may collect data from different bot owners if in party but this overdoing has no significance whatsoever
+*/
+
+enum DPSTrackerConstants
+{
+    DPS_UPDATE_TIMER        =  500, //recalculate dps every x ms
+    MAX_DPS_TRACK_TIME      = 5000, //track damage taken for last x ms
+    DPS_INACTIVE_TIMER      = 5000, //reset if combat not active for botparty for x ms
+    //maximum tracked damage taken periods of DPS_UPDATE_TIMER during MAX_DPS_TRACK_TIME
+    MAX_DAMAGES             = MAX_DPS_TRACK_TIME/DPS_UPDATE_TIMER
+};
+
+DPSTracker::DPSTracker()
+{
+    _updateTimer = 0;
+    _inactiveTimer = 0;
+    _trackTimer = 0;
+    _active = false;
+}
+
+DPSTracker::~DPSTracker()
+{
+    for (DamageTakenMap::const_iterator itr = _damages.begin(); itr != _damages.end(); ++itr)
+        delete[] itr->second;
+
+    _damages.clear();
+    _DPSes.clear();
+}
+
+void DPSTracker::Update(uint32 diff)
+{
+    if (_active)
+    {
+        _inactiveTimer += diff;
+        _updateTimer += diff;
+        _trackTimer += diff;
+
+        if (_inactiveTimer >= DPS_INACTIVE_TIMER)
+        {
+            _Reset();
+        }
+        else if (_updateTimer >= DPS_UPDATE_TIMER)
+        {
+            _updateTimer -= DPS_UPDATE_TIMER;
+            _Release();
+        }
+    }
+}
+
+void DPSTracker::_Reset()
+{
+    if (_active)
+    {
+        _active = false;
+
+        for (DamageTakenMap::const_iterator itr = _damages.begin(); itr != _damages.end(); ++itr)
+            for (uint8 i = 0; i != MAX_DAMAGES; ++i)
+                itr->second[i] = 0;
+        for (DPSTakenMap::iterator itr = _DPSes.begin(); itr != _DPSes.end(); ++itr)
+            itr->second = 0;
+
+        _updateTimer = 0;
+        _inactiveTimer = 0;
+        _trackTimer = 0;
+    }
+}
+
+void DPSTracker::_Release()
+{
+    for (DamageTakenMap::const_iterator itr = _damages.begin(); itr != _damages.end(); ++itr)
+    {
+        uint32* dmgs = itr->second;
+        uint32 total_damage = 0;
+        for (uint8 i = 0; i != MAX_DAMAGES; ++i)
+            total_damage += dmgs[i];
+
+        _DPSes[itr->first] = uint32(total_damage / (0.001f * std::max<uint32>(1 * IN_MILLISECONDS, std::min<uint32>(_trackTimer, MAX_DPS_TRACK_TIME))));
+        //TC_LOG_ERROR("entities.player", "DPSTracker::Release(): guidlow = %u, time = %u, tick damage %u, total %u, dps = %u",
+        //    itr->first, _trackTimer, dmgs[0], total_damage, _DPSes[itr->first]);
+
+        //shift
+        for (int8 i = MAX_DAMAGES-1; i > 0; --i)
+            dmgs[i] = dmgs[i-1];
+        dmgs[0] = 0;
+    }
+}
+
+void DPSTracker::_AccumulateDamage(uint64 guid, uint32 damage)
+{
+    DamageTakenMap::const_iterator itr = _damages.find(guid);
+
+    if (itr == _damages.end())
+    {
+        uint32* dmgarray = new uint32[MAX_DAMAGES];
+        memset(dmgarray, 0, sizeof(uint32)*MAX_DAMAGES);
+
+        dmgarray[0] = damage;
+
+        _damages[guid] = dmgarray;
+        return;
+    }
+
+    itr->second[0] += damage;
+}
+//victim is bot owner, bot, party player or party bot; checked in Unit::DealDamage()
+void DPSTracker::TrackDamage(Unit const* victim, uint32 damage)
+{
+    //TC_LOG_ERROR("entities.player", "DPSTracker::OnDamage(): on %s, damage %u", victim->GetName().c_str(), damage);
+
+    _SetActive();
+    _AccumulateDamage(victim->GetGUID().GetRawValue(), damage);
+}
+
+void DPSTracker::_SetActive()
+{
+    _inactiveTimer = 0;
+    if (!_active)
+        _active = true;
+}
+
+uint32 DPSTracker::GetDPSTaken(uint64 guid) const
+{
+    DPSTakenMap::const_iterator itr = _DPSes.find(guid);
+    //TC_LOG_ERROR("entities.player", "DPSTracker::GetDPSTaken(): from %u, damage %u", guid, itr != _DPSes.end() ? itr->second : 0);
+    return itr != _DPSes.end() ? itr->second : 0;
+}
diff --git a/src/server/game/AI/NpcBots/botdpstracker.h b/src/server/game/AI/NpcBots/botdpstracker.h
new file mode 100644
index 0000000..ddb6150
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdpstracker.h
@@ -0,0 +1,36 @@
+#ifndef _BOT_DPSTRACKER_H
+#define _BOT_DPSTRACKER_H
+
+class DPSTracker
+{
+    public:
+        DPSTracker();
+        ~DPSTracker();
+
+        void Update(uint32 diff);
+
+        void TrackDamage(Unit const* victim, uint32 damage);
+        uint32 GetDPSTaken(uint64 guid) const;
+
+        void SetOwner(uint32 guidlow) { _ownerGuid = guidlow; }
+
+    private:
+        void _Reset();
+        void _Release();
+        void _AccumulateDamage(uint64 guid, uint32 damage);
+        void _SetActive();
+
+        typedef std::unordered_map<uint64 /*guid*/, uint32* /*dmgarray*/> DamageTakenMap;
+        typedef std::unordered_map<uint64 /*guid*/, uint32 /*dps*/> DPSTakenMap;
+        DamageTakenMap _damages;
+        DPSTakenMap _DPSes;
+
+        uint32 _ownerGuid;
+
+        uint32 _updateTimer;
+        uint32 _inactiveTimer;
+        uint32 _trackTimer;
+        bool _active;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botgiver.cpp b/src/server/game/AI/NpcBots/botgiver.cpp
new file mode 100644
index 0000000..2dfe9ee
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botgiver.cpp
@@ -0,0 +1,241 @@
+#include "bot_ai.h"
+#include "botcommon.h"
+#include "botdatamgr.h"
+#include "botmgr.h"
+#include "Creature.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+/*
+NPCbot giver NPC by Trickerer (<https://github.com/Trickerer/> <onlysuffering@gmail.com>)
+Complete - ???
+*/
+
+#define HIRE GOSSIP_SENDER_BOTGIVER_HIRE
+#define HIRE_CLASS GOSSIP_SENDER_BOTGIVER_HIRE_CLASS
+#define HIRE_ENTRY GOSSIP_SENDER_BOTGIVER_HIRE_ENTRY
+
+typedef std::set<Creature const*> NpcBotRegistry;
+extern NpcBotRegistry _existingBots;
+
+class script_bot_giver : public CreatureScript
+{
+public:
+    script_bot_giver() : CreatureScript("script_bot_giver") { }
+
+    struct bot_giver_AI : public CreatureAI
+    {
+        bot_giver_AI(Creature* creature) : CreatureAI(creature) {}
+
+        void UpdateAI(uint32 /*diff*/) {}
+
+        bool GossipHello(Player* player) override
+        {
+            if (!BotMgr::IsNpcBotModEnabled())
+            {
+                player->PlayerTalkClass->SendCloseGossip();
+                return true;
+            }
+
+            if (me->isMoving())
+                me->BotStopMovement();
+
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, "I need your services", HIRE, GOSSIP_ACTION_INFO_DEF + 1);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 2);
+
+            player->PlayerTalkClass->SendGossipMenu(GOSSIP_BOTGIVER_GREET, me->GetGUID());
+            return true;
+        }
+
+        bool GossipSelect(Player* player, uint32 /*menuId*/, uint32 gossipListId) override
+        {
+            if (!BotMgr::IsNpcBotModEnabled())
+            {
+                player->PlayerTalkClass->SendCloseGossip();
+                return true;
+            }
+
+            uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+            uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+
+            player->PlayerTalkClass->ClearMenus();
+            bool subMenu = false;
+
+            uint32 gossipTextId = GOSSIP_BOTGIVER_GREET;
+
+            switch (sender)
+            {
+                case 0: //exit
+                    break;
+                case 1: //BACK: return to main menu
+                    return GossipHello(player);
+                case HIRE:
+                {
+                    gossipTextId = GOSSIP_BOTGIVER_HIRE;
+
+                    if (player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                    {
+                        WhisperTo(player, "You have too many bots");
+                        break;
+                    }
+
+                    subMenu = true;
+
+                    uint8 availCount = 0;
+
+                    for (uint8 botclass = BOT_CLASS_WARRIOR; botclass < BOT_CLASS_END; ++botclass)
+                    {
+                        if (!BotMgr::IsClassEnabled(botclass))
+                            continue;
+
+                        if (player->HaveBot() && BotMgr::GetMaxClassBots())
+                        {
+                            uint8 count = 0;
+                            BotMap const* map = player->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                                if (itr->second->GetBotClass() == botclass)
+                                    ++count;
+                            if (count >= BotMgr::GetMaxClassBots())
+                                continue;
+                        }
+
+                        std::ostringstream bclass;
+                        bool validClass = true;
+                        switch (botclass)
+                        {
+                            case BOT_CLASS_WARRIOR:         bclass << "Warriors";       break;
+                            case BOT_CLASS_PALADIN:         bclass << "Paladins";       break;
+                            case BOT_CLASS_MAGE:            bclass << "Mages";          break;
+                            case BOT_CLASS_PRIEST:          bclass << "Priests";        break;
+                            case BOT_CLASS_WARLOCK:         bclass << "Warlocks";       break;
+                            case BOT_CLASS_DRUID:           bclass << "Druids";         break;
+                            case BOT_CLASS_DEATH_KNIGHT:    bclass << "Death Knights";  break;
+                            case BOT_CLASS_ROGUE:           bclass << "Rogues";         break;
+                            case BOT_CLASS_SHAMAN:          bclass << "Shamans";        break;
+                            case BOT_CLASS_HUNTER:          bclass << "Hunters";        break;
+                            case BOT_CLASS_BM:              bclass << "Blademasters";   break;
+                            case BOT_CLASS_SPHYNX:          bclass << "Destroyers";     break;
+                            case BOT_CLASS_ARCHMAGE:        bclass << "Archmagi";       break;
+                            case BOT_CLASS_DREADLORD:       bclass << "Dreadlords";     break;
+                            case BOT_CLASS_SPELLBREAKER:    bclass << "Spell Breakers"; break;
+                            case BOT_CLASS_DARK_RANGER:     bclass << "Dark Rangers";   break;
+                            default:                        validClass = false;         break;
+                        }
+
+                        if (validClass == false)
+                            continue;
+
+                        bclass << " (" << BotMgr::GetNpcBotCostStr(player->GetLevel(), botclass) << ")";
+
+                        AddGossipItemFor(player, GOSSIP_ICON_TALK, bclass.str(), HIRE_CLASS, GOSSIP_ACTION_INFO_DEF + botclass);
+
+                        if (++availCount >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                            break;
+                    }
+
+                    if (availCount == 0)
+                        gossipTextId = GOSSIP_BOTGIVER_HIRE_EMPTY;
+
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+
+                    break;
+                }
+                case HIRE_CLASS:
+                {
+                    gossipTextId = GOSSIP_BOTGIVER_HIRE_CLASS;
+
+                    uint8 botclass = action - GOSSIP_ACTION_INFO_DEF;
+
+                    uint32 cost = BotMgr::GetNpcBotCost(player->GetLevel(), botclass);
+                    if (!player->HasEnoughMoney(cost))
+                    {
+                        WhisperTo(player, "You don't have enough money!");
+                        break;
+                    }
+
+                    subMenu = true;
+
+                    uint8 availCount = 0;
+
+                    //go through bots map to find what bots are available
+                    NpcBotRegistry const& allBots = _existingBots;
+                    for (NpcBotRegistry::const_iterator ci = allBots.begin(); ci != allBots.end(); ++ci)
+                    {
+                        Creature const* bot = *ci;
+                        bot_ai const* ai = bot->GetBotAI();
+                        if (bot->GetBotClass() != botclass || !bot->IsAlive() || ai->IsTempBot() || ai->GetBotOwnerGuid() || bot->HasAura(BERSERK))
+                            continue;
+
+                        std::ostringstream message1;
+                        message1 << "Do you wish to hire " << bot->GetName() << '?';
+                        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TALK, bot->GetName(),
+                            HIRE_ENTRY, GOSSIP_ACTION_INFO_DEF + bot->GetEntry(), message1.str(), cost, false);
+
+                        if (++availCount >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                            break;
+                    }
+
+                    if (availCount == 0)
+                        gossipTextId = GOSSIP_BOTGIVER_HIRE_EMPTY;
+
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Back>", HIRE, GOSSIP_ACTION_INFO_DEF + 1);
+
+                    break;
+                }
+                case HIRE_ENTRY:
+                {
+                    uint32 entry = action - GOSSIP_ACTION_INFO_DEF;
+                    Creature const* bot = BotDataMgr::FindBotInWorld(entry);
+                    if (!bot)
+                    {
+                        //possible but still
+                        TC_LOG_ERROR("entities.unit", "HIRE_NBOT_ENTRY: bot %u not found!", entry);
+                        break;
+                    }
+
+                    bot_ai const* ai = bot->GetBotAI();
+                    if (bot->IsInCombat() || !bot->IsAlive() || bot_ai::CCed(bot) || ai->IsDuringTeleport() ||
+                        bot->HasUnitState(UNIT_STATE_CASTING) || ai->GetBotOwnerGuid() || bot->HasAura(BERSERK))
+                    {
+                        //TC_LOG_ERROR("entities.unit", "HIRE_NBOT_ENTRY: bot %u (%s) is unavailable all of the sudden!", entry);
+                        std::ostringstream failMsg;
+                        failMsg << bot->GetName() << " is a bit busy at the moment, try again later.";
+                        WhisperTo(player, failMsg.str().c_str());
+                        break;
+                    }
+
+                    //laways returns true
+                    bot->GetBotAI()->OnGossipSelect(player, me, GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF);
+
+                    if (player->HaveBot() && player->GetBotMgr()->GetBot(bot->GetGUID()))
+                        WhisperTo(player, "Pleasure doing business with you");
+
+                    break;
+                }
+            }
+
+            if (subMenu)
+                player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+            else
+                player->PlayerTalkClass->SendCloseGossip();
+
+            return true;
+        }
+
+        void WhisperTo(Player* player, char const* message)
+        {
+            me->Whisper(message, LANG_UNIVERSAL, player);
+        }
+    };
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new bot_giver_AI(creature);
+    }
+};
+
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.cpp b/src/server/game/AI/NpcBots/botmgr.cpp
new file mode 100644
index 0000000..58186f9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.cpp
@@ -0,0 +1,1283 @@
+#include "bot_ai.h"
+#include "botdpstracker.h"
+#include "bot_Events.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "MotionMaster.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+/*
+Npc Bot Manager by Trickerer (onlysuffering@gmail.com)
+Player NpcBots management
+TODO: Move creature hooks here
+*/
+
+//config
+uint8 _basefollowdist;
+uint8 _maxNpcBots;
+uint8 _maxClassNpcBots;
+uint8 _xpReductionNpcBots;
+uint8 _healTargetIconFlags;
+uint8 _tankingTargetIconFlags;
+uint8 _dpsTargetIconFlags;
+int32 _botInfoPacketsLimit;
+uint32 _npcBotsCost;
+uint32 _npcBotUpdateDelayBase;
+bool _enableNpcBots;
+bool _enableNpcBotsDungeons;
+bool _enableNpcBotsRaids;
+bool _enableNpcBotsBGs;
+bool _enableNpcBotsArenas;
+bool _enableDungeonFinder;
+bool _limitNpcBotsDungeons;
+bool _limitNpcBotsRaids;
+bool _botPvP;
+bool _botMovementFoodInterrupt;
+bool _displayEquipment;
+bool _showCloak;
+bool _showHelm;
+bool _enableclass_blademaster;
+bool _enableclass_sphynx;
+bool _enableclass_archmage;
+bool _enableclass_dreadlord;
+bool _enableclass_spellbreaker;
+bool _enableclass_darkranger;
+bool _botStatLimits;
+float _botStatLimits_dodge;
+float _botStatLimits_parry;
+float _botStatLimits_block;
+float _botStatLimits_crit;
+float _mult_dmg_physical;
+float _mult_dmg_spell;
+float _mult_healing;
+
+bool __firstload = true;
+
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_blademaster_bot();
+void AddSC_sphynx_bot();
+void AddSC_archmage_bot();
+void AddSC_dreadlord_bot();
+void AddSC_spellbreaker_bot();
+void AddSC_dark_ranger_bot();
+void AddSC_archmage_bot_pets();
+void AddSC_dark_ranger_bot_pets();
+void AddSC_dreadlord_bot_pets();
+void AddSC_hunter_bot_pets();
+void AddSC_warlock_bot_pets();
+void AddSC_deathknight_bot_pets();
+void AddSC_priest_bot_pets();
+void AddSC_shaman_bot_pets();
+void AddSC_mage_bot_pets();
+void AddSC_druid_bot_pets();
+void AddSC_script_bot_commands();
+void AddSC_script_bot_giver();
+
+void AddNpcBotScripts()
+{
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_blademaster_bot();
+    AddSC_sphynx_bot();
+    AddSC_archmage_bot();
+    AddSC_dreadlord_bot();
+    AddSC_spellbreaker_bot();
+    AddSC_dark_ranger_bot();
+    AddSC_archmage_bot_pets();
+    AddSC_dark_ranger_bot_pets();
+    AddSC_dreadlord_bot_pets();
+    AddSC_hunter_bot_pets();
+    AddSC_warlock_bot_pets();
+    AddSC_deathknight_bot_pets();
+    AddSC_priest_bot_pets();
+    AddSC_shaman_bot_pets();
+    AddSC_mage_bot_pets();
+    AddSC_druid_bot_pets();
+    AddSC_script_bot_commands();
+    AddSC_script_bot_giver();
+}
+
+BotMgr::BotMgr(Player* const master) : _owner(master), _dpstracker(new DPSTracker())
+{
+    //LoadConfig(); already loaded (MapManager.cpp)
+    _followdist = _basefollowdist;
+    _exactAttackRange = 0;
+    _attackRangeMode = BOT_ATTACK_RANGE_SHORT;
+    _botsHidden = false;
+
+    _dpstracker->SetOwner(master->GetGUID().GetCounter());
+    master->SetBotMgr(this);
+}
+BotMgr::~BotMgr()
+{
+    delete _dpstracker;
+}
+
+void BotMgr::Initialize()
+{
+    LoadConfig();
+
+    if (!_enableNpcBots)
+        return;
+
+    BotDataMgr::LoadNpcBots();
+    bot_ai::InitBotCustomSpells();
+}
+
+void BotMgr::ReloadConfig()
+{
+    LoadConfig(true);
+}
+
+void BotMgr::LoadConfig(bool reload)
+{
+    if (__firstload)
+        __firstload = false;
+    else if (!reload)
+        return;
+
+    _enableNpcBots          = sConfigMgr->GetBoolDefault("NpcBot.Enable", true);
+    _maxNpcBots             = sConfigMgr->GetIntDefault("NpcBot.MaxBots", 1);
+    _maxClassNpcBots        = sConfigMgr->GetIntDefault("NpcBot.MaxBotsPerClass", 1);
+    _basefollowdist         = sConfigMgr->GetIntDefault("NpcBot.BaseFollowDistance", 30);
+    _xpReductionNpcBots     = sConfigMgr->GetIntDefault("NpcBot.XpReduction", 0);
+    _healTargetIconFlags    = sConfigMgr->GetIntDefault("NpcBot.HealTargetIconsMask", 0);
+    _tankingTargetIconFlags = sConfigMgr->GetIntDefault("NpcBot.TankTargetIconMask", 0);
+    _dpsTargetIconFlags     = sConfigMgr->GetIntDefault("NpcBot.DPSTargetIconMask", 0);
+    _mult_dmg_physical      = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Physical", 1.0f);
+    _mult_dmg_spell         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Spell", 1.0f);
+    _mult_healing           = sConfigMgr->GetFloatDefault("NpcBot.Mult.Healing", 1.0f);
+    _enableNpcBotsDungeons  = sConfigMgr->GetBoolDefault("NpcBot.Enable.Dungeon", true);
+    _enableNpcBotsRaids     = sConfigMgr->GetBoolDefault("NpcBot.Enable.Raid", false);
+    _enableNpcBotsBGs       = sConfigMgr->GetBoolDefault("NpcBot.Enable.BG", false);
+    _enableNpcBotsArenas    = sConfigMgr->GetBoolDefault("NpcBot.Enable.Arena", false);
+    _enableDungeonFinder    = sConfigMgr->GetBoolDefault("NpcBot.Enable.DungeonFinder", true);
+    _limitNpcBotsDungeons   = sConfigMgr->GetBoolDefault("NpcBot.Limit.Dungeon", true);
+    _limitNpcBotsRaids      = sConfigMgr->GetBoolDefault("NpcBot.Limit.Raid", true);
+    _botInfoPacketsLimit    = sConfigMgr->GetIntDefault("NpcBot.InfoPacketsLimit", -1);
+    _npcBotsCost            = sConfigMgr->GetIntDefault("NpcBot.Cost", 1000000);
+    _npcBotUpdateDelayBase  = sConfigMgr->GetIntDefault("NpcBot.UpdateDelay.Base", 0);
+    _botPvP                 = sConfigMgr->GetBoolDefault("NpcBot.PvP", true);
+    _botMovementFoodInterrupt=sConfigMgr->GetBoolDefault("NpcBot.Movements.InterruptFood", false);
+    _displayEquipment       = sConfigMgr->GetBoolDefault("NpcBot.EquipmentDisplay.Enable", true);
+    _showCloak              = sConfigMgr->GetBoolDefault("NpcBot.EquipmentDisplay.ShowCloak", true);
+    _showHelm               = sConfigMgr->GetBoolDefault("NpcBot.EquipmentDisplay.ShowHelm", false);
+    _enableclass_blademaster= sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Blademaster.Enable", true);
+    _enableclass_sphynx     = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.ObsidianDestroyer.Enable", true);
+    _enableclass_archmage   = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Archmage.Enable", true);
+    _enableclass_dreadlord  = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Dreadlord.Enable", true);
+    _enableclass_spellbreaker=sConfigMgr->GetBoolDefault("NpcBot.NewClasses.SpellBreaker.Enable", true);
+    _enableclass_darkranger = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.DarkRanger.Enable", true);
+    _botStatLimits          = sConfigMgr->GetBoolDefault("NpcBot.Stats.Limits.Enable", false);
+    _botStatLimits_dodge    = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Dodge", 95.0f);
+    _botStatLimits_parry    = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Parry", 95.0f);
+    _botStatLimits_block    = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Block", 95.0f);
+    _botStatLimits_crit     = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Crit", 95.0f);
+
+    //limits
+    _mult_dmg_physical      = std::max<float>(_mult_dmg_physical, 0.1f);
+    _mult_dmg_spell         = std::max<float>(_mult_dmg_spell, 0.1f);
+    _mult_healing           = std::max<float>(_mult_healing,   0.1f);
+    _mult_dmg_physical      = std::min<float>(_mult_dmg_physical, 10.f);
+    _mult_dmg_spell         = std::min<float>(_mult_dmg_spell, 10.f);
+    _mult_healing           = std::min<float>(_mult_healing,   10.f);
+}
+
+uint8 BotMgr::GetNpcBotsCount() const
+{
+    //if (!inWorldOnly)
+        return _bots.size();
+
+    //CRITICAL SECTION
+    //inWorldOnly is only for one-shot cases (opcodes, etc.)
+    //maybe convert to (bot && bot->isInWorld()) ?
+    //uint8 count = 0;
+    //for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    //    if (ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)nullptr))
+    //        ++count;
+    //return count;
+}
+
+uint8 BotMgr::GetNpcBotsCountByRole(uint16 roles) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second && (roles & itr->second->GetBotRoles()))
+            ++count;
+    return count;
+}
+
+uint8 BotMgr::GetNpcBotSlotByRole(uint16 roles, Creature const* bot) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (roles & itr->second->GetBotRoles())
+        {
+            if (!(roles == BOT_ROLE_DPS && (itr->second->GetBotRoles() & BOT_ROLE_TANK)))
+                ++count;
+            if (itr->second == bot)
+                return count;
+        }
+    }
+    return 1;
+}
+
+bool BotMgr::IsNpcBotModEnabled()
+{
+    return _enableNpcBots;
+}
+
+bool BotMgr::IsNpcBotDungeonFinderEnabled()
+{
+    return _enableDungeonFinder;
+}
+
+bool BotMgr::DisplayEquipment()
+{
+    return _displayEquipment;
+}
+
+bool BotMgr::ShowEquippedCloak()
+{
+    return _showCloak;
+}
+
+bool BotMgr::ShowEquippedHelm()
+{
+    return _showHelm;
+}
+
+bool BotMgr::IsClassEnabled(uint8 m_class)
+{
+    switch (m_class)
+    {
+        case BOT_CLASS_BM:
+            return _enableclass_blademaster;
+        case BOT_CLASS_SPHYNX:
+            return _enableclass_sphynx;
+        case BOT_CLASS_ARCHMAGE:
+            return _enableclass_archmage;
+        case BOT_CLASS_DREADLORD:
+            return _enableclass_dreadlord;
+        case BOT_CLASS_SPELLBREAKER:
+            return _enableclass_spellbreaker;
+        case BOT_CLASS_DARK_RANGER:
+            return _enableclass_darkranger;
+        default:
+            return true;
+    }
+}
+
+bool BotMgr::IsBotStatsLimitsEnabled()
+{
+    return _botStatLimits;
+}
+bool BotMgr::IsPvPEnabled()
+{
+    return _botPvP;
+}
+bool BotMgr::IsFoodInterruptedByMovement()
+{
+    return _botMovementFoodInterrupt;
+}
+uint8 BotMgr::GetMaxClassBots()
+{
+    return _maxClassNpcBots;
+}
+uint8 BotMgr::GetHealTargetIconFlags()
+{
+    return _healTargetIconFlags;
+}
+uint8 BotMgr::GetTankTargetIconFlags()
+{
+    return _tankingTargetIconFlags;
+}
+uint8 BotMgr::GetDPSTargetIconFlags()
+{
+    return _dpsTargetIconFlags;
+}
+uint32 BotMgr::GetBaseUpdateDelay()
+{
+    return _npcBotUpdateDelayBase;
+}
+float BotMgr::GetBotStatLimitDodge()
+{
+    return _botStatLimits_dodge;
+}
+float BotMgr::GetBotStatLimitParry()
+{
+    return _botStatLimits_parry;
+}
+float BotMgr::GetBotStatLimitBlock()
+{
+    return _botStatLimits_block;
+}
+float BotMgr::GetBotStatLimitCrit()
+{
+    return _botStatLimits_crit;
+}
+
+uint8 BotMgr::GetNpcBotXpReduction()
+{
+    return _xpReductionNpcBots;
+}
+
+uint8 BotMgr::GetMaxNpcBots()
+{
+    return _maxNpcBots <= MAXRAIDSIZE - 1 ? _maxNpcBots : MAXRAIDSIZE - 1;
+}
+
+int32 BotMgr::GetBotInfoPacketsLimit()
+{
+    return _botInfoPacketsLimit;
+}
+
+bool BotMgr::LimitBots(Map const* map)
+{
+    if (_limitNpcBotsDungeons && map->IsNonRaidDungeon())
+        return true;
+    if (_limitNpcBotsRaids && map->IsRaid())
+        return true;
+
+    return false;
+}
+
+void BotMgr::Update(uint32 diff)
+{
+    //remove temp bots from bot map before updating it
+    while (!_removeList.empty())
+    {
+        std::list<ObjectGuid>::iterator itr = _removeList.begin();
+
+        BotMap::iterator bitr = _bots.find(*itr);
+        ASSERT(bitr != _bots.end());
+        _bots.erase(bitr);
+
+        _removeList.erase(itr);
+    }
+
+    _dpstracker->Update(diff);
+
+    if (!HaveBot())
+        return;
+
+    //ObjectGuid guid;
+    Creature* bot;
+    bot_ai* ai;
+    bool partyCombat = IsPartyInCombat();
+    bool restrictBots = RestrictBots(nullptr, false);
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        //guid = itr->first;
+        bot = itr->second;
+        ai = bot->GetBotAI();
+
+        if (ai->IAmFree())
+            continue;
+
+        if (!bot->IsInWorld())
+        {
+            ai->CommonTimers(diff);
+            continue;
+        }
+
+        if (partyCombat == false)
+            ai->UpdateReviveTimer(diff);
+
+        //bot->IsAIEnabled = true;
+
+        if (ai->GetReviveTimer() <= diff)
+        {
+            if (bot->IsInWorld() && !bot->IsAlive() && _owner->IsAlive() && !_owner->IsInCombat() &&
+                !_owner->IsBeingTeleported() && !_owner->InArena() && !_owner->IsInFlight() &&
+                !_owner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !_owner->HasInvisibilityAura() && !_owner->HasStealthAura())
+            {
+                _reviveBot(bot);
+                continue;
+            }
+
+            ai->SetReviveTimer(urand(1000, 5000));
+        }
+
+        if (_owner->IsAlive() && (bot->IsAlive() || restrictBots) && !ai->IsTempBot() && !ai->IsDuringTeleport() &&
+            (restrictBots || bot->GetMap() != _owner->GetMap() ||
+            (!bot->GetBotAI()->HasBotCommandState(BOT_COMMAND_STAY) && _owner->GetDistance(bot) > SIZE_OF_GRIDS)))
+        {
+            //_owner->m_Controlled.erase(bot);
+            TeleportBot(bot, _owner->GetMap(), _owner);
+            continue;
+        }
+
+        ai->canUpdate = true;
+        bot->Update(diff);
+        ai->canUpdate = false;
+    }
+}
+
+bool BotMgr::RestrictBots(Creature const* bot, bool add) const
+{
+    if (!_owner->FindMap())
+        return true;
+
+    if (_owner->IsInFlight())
+        return true;
+
+    if (_botsHidden)
+        return true;
+
+    Map const* currMap = _owner->GetMap();
+
+    if ((!_enableNpcBotsBGs && currMap->IsBattleground()) ||
+        (!_enableNpcBotsArenas && currMap->IsBattleArena()) ||
+        (!_enableNpcBotsDungeons && currMap->IsNonRaidDungeon()) ||
+        (!_enableNpcBotsRaids && currMap->IsRaid()))
+        return true;
+
+    if (LimitBots(currMap))
+    {
+        //if bot is not in instance group - deny (only if trying to teleport to instance)
+        if (add)
+            if (!_owner->GetGroup() || !_owner->GetGroup()->IsMember(bot->GetGUID()))
+                return true;
+
+        InstanceMap const* map = currMap->ToInstanceMap();
+        if (map->GetPlayersCountExceptGMs() + uint32(add) > map->GetMaxPlayers())
+            return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::IsPartyInCombat() const
+{
+    if (_owner->IsInCombat())
+        return true;
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (!itr->second->IsInWorld())
+            continue;
+        if (itr->second->IsInCombat())
+            return true;
+        if (Unit const* pet = itr->second->GetBotsPet())
+            if (pet->IsInCombat())
+                return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::HasBotClass(uint8 botclass) const
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->GetBotClass() == botclass)
+            return true;
+
+    return false;
+}
+
+bool BotMgr::HasBotPetType(uint32 petType) const
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->GetBotsPet() && itr->second->GetBotAI()->GetAIMiscValue(BOTAI_MISC_PET_TYPE) == petType)
+            return true;
+
+    return false;
+}
+
+void BotMgr::_reviveBot(Creature* bot, WorldLocation* dest)
+{
+    if (bot->IsAlive())
+        return;
+
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        if (!dest)
+            bot->CastSpell(bot, COSMETIC_RESURRECTION, false);
+
+        if (!dest)
+            dest = bot->GetBotOwner();
+
+        bot->NearTeleportTo(dest->GetPositionX(), dest->GetPositionY(), dest->GetPositionZ(), dest->GetOrientation());
+        //some weird pos manipulation
+        if (dest != bot)
+            bot->Relocate(dest);
+    }
+
+    bot->SetDisplayId(bot->GetNativeDisplayId());
+    bot->SetUInt32Value(UNIT_NPC_FLAGS, bot->GetCreatureTemplate()->npcflag);
+    bot->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+    bot->RemoveFlag(UNIT_FIELD_FLAGS, uint32(-1));
+    bot->SetPvP(bot->GetBotOwner()->IsPvP());
+    bot->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+    bot->setDeathState(ALIVE);
+    //bot->GetBotAI()->Reset();
+    bot->GetBotAI()->SetShouldUpdateStats();
+
+    bot->SetHealth(bot->GetMaxHealth() / 4); //25% of max health
+    if (bot->GetMaxPower(POWER_MANA) > 1)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA) / 4); //25% of max mana
+
+    if (!bot->GetBotAI()->IAmFree() && !bot->GetBotAI()->HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        bot->GetBotAI()->SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+}
+
+Creature* BotMgr::GetBot(ObjectGuid guid) const
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    return itr != _bots.end() ? itr->second : nullptr;
+}
+
+void BotMgr::OnOwnerSetGameMaster(bool on)
+{
+    Creature* bot;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        if (!bot)
+            continue;
+
+        bot->SetFaction(_owner->GetFaction());
+        //bot->getHostileRefManager().setOnlineOfflineState(!on);
+        bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1)); //pvp state
+
+        if (on && bot->IsInWorld())
+            bot->CombatStop(true);
+
+        if (Unit* pet = bot->GetBotsPet())
+        {
+            pet->SetFaction(_owner->GetFaction());
+            //pet->getHostileRefManager().setOnlineOfflineState(!on);
+            pet->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1)); //pvp state
+
+            if (on)
+                pet->CombatStop(true);
+        }
+    }
+}
+
+void BotMgr::OnTeleportFar(uint32 mapId, float x, float y, float z, float ori)
+{
+    Map* newMap = sMapMgr->CreateBaseMap(mapId);
+    Creature* bot;
+    Position pos;
+    pos.Relocate(x, y, z, ori);
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        ASSERT(bot && "BotMgr::OnTeleportFar(): bot does not exist!!!");
+
+        if (bot->IsTempBot())
+            continue;
+
+        //_owner->m_Controlled.erase(bot);
+        TeleportBot(bot, newMap, &pos);
+    }
+}
+
+void BotMgr::_teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori)
+{
+    ASSERT(bot->GetBotAI());
+    bot->GetBotAI()->AbortTeleport();
+
+    bot->GetBotAI()->UnsummonAll();
+    bot->GetBotAI()->KillEvents(true);
+
+    if (bot->IsInWorld())
+    {
+        //bot->MonsterWhisper("teleport...", bot->GetBotAI()->GetBotOwnerGuid());
+        bot->CastSpell(bot, COSMETIC_TELEPORT_EFFECT, true);
+    }
+
+    //bot->IsAIEnabled = false;
+    //UnitAI* oldAI = bot->GetAI();
+    //bot->SetAI(nullptr);
+
+    //if (bot->IsFreeBot() || bot->GetBotOwner()->GetSession()->isLogingOut())
+    //{
+    //    bot->FarTeleportTo(newMap, x, y, z, ori);
+
+    //    //bot->SetAI(oldAI);
+    //    bot->IsAIEnabled = true;
+    //    return;
+    //}
+
+    ////start Unit::CleanupBeforeRemoveFromMap()
+    bot->InterruptNonMeleeSpells(true);
+    if (bot->IsInWorld())
+        bot->RemoveFromWorld();
+
+    ASSERT(bot->GetGUID());
+
+    // A unit may be in removelist and not in world, but it is still in grid
+    // and may have some references during delete
+    //RemoveAllAuras();
+    bot->RemoveAllGameObjects();
+
+    //if (finalCleanup)
+    //    m_cleanupDone = true;
+
+    bot->m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
+    bot->CombatStop();
+    bot->ClearComboPointHolders();
+    //bot->DeleteThreatList();
+    //bot->getHostileRefManager().setOnlineOfflineState(false);
+    //bot->GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
+    //end Unit::CleanupBeforeRemoveFromMap()
+
+    //bot->CleanupBeforeRemoveFromMap(false);
+
+    bot->BotStopMovement();
+
+    if (Map* mymap = bot->FindMap())
+        mymap->RemoveFromMap(bot, false);
+
+    if (bot->IsFreeBot()/* || bot->GetBotOwner()->GetSession()->isLogingOut()*/)
+    {
+        //bot->FarTeleportTo(newMap, x, y, z, ori);
+
+        //Creature::FarTeleportTo()
+        //{
+        //CleanupBeforeRemoveFromMap(false); //done above
+        //GetMap()->RemoveFromMap(this, false); //done above
+        //Relocate(X, Y, Z, O);
+        //SetMap(map);
+        //GetMap()->AddToMap(this);
+        //}
+        bot->Relocate(x, y, z, ori);
+        bot->SetMap(newMap);
+        bot->GetMap()->AddToMap(bot);
+        //end Creature::FarTeleportTo()
+
+        //bot->SetAI(oldAI);
+        //bot->IsAIEnabled = true;
+        return;
+    }
+
+    //update group member online state
+    if (Group* gr = bot->GetBotOwner()->GetGroup())
+        if (gr->IsMember(bot->GetGUID()))
+            gr->SendUpdate();
+
+    //bot->Relocate(x, y, z);
+    TeleportFinishEvent* finishEvent = new TeleportFinishEvent(bot->GetBotAI()/*, newMap->GetId(), newMap->GetInstanceId(), x, y, z, ori*/);
+    std::chrono::milliseconds delay(urand(5000, 8000));
+    bot->GetBotAI()->GetEvents()->AddEvent(finishEvent, bot->GetBotAI()->GetEvents()->CalculateTime(delay));
+    bot->GetBotAI()->SetTeleportFinishEvent(finishEvent);
+}
+
+void BotMgr::TeleportBot(Creature* bot, Map* newMap, Position* pos)
+{
+    _teleportBot(bot, newMap, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation());
+}
+
+void BotMgr::CleanupsBeforeBotDelete(ObjectGuid guid, uint8 /*removetype*/)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(b)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(b)!!");
+
+    Creature* bot = itr->second;
+
+    //don't allow removing bots while they are teleporting
+    if (!bot->IsInWorld())
+    {
+        bot->GetBotAI()->AbortTeleport();
+        //if (!bot->IsInWorld())
+        //{
+        //    TC_LOG_ERROR("entities.player", "BotMgr::CleanupsBeforeBotDelete(): Failed to abort %s's teleport! Still out of world!", bot->GetName().c_str());
+        //    ASSERT(false);
+        //}
+    }
+
+    RemoveBotFromGroup(bot);
+
+    //remove any summons
+    bot->GetBotAI()->UnsummonAll();
+
+    ASSERT(bot->GetOwnerGUID() == _owner->GetGUID());
+    bot->SetOwnerGUID(ObjectGuid::Empty);
+    //_owner->m_Controlled.erase(bot);
+    bot->SetControlledByPlayer(false);
+    //bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+    bot->SetCreatorGUID(ObjectGuid::Empty);
+
+    Map* map = bot->FindMap();
+    if (!map || map->IsDungeon())
+        bot->RemoveFromWorld();
+}
+
+void BotMgr::_addBotToRemoveList(ObjectGuid guid)
+{
+    _removeList.push_back(guid);
+}
+
+void BotMgr::RemoveAllBots(uint8 removetype)
+{
+    while (!_bots.empty())
+        RemoveBot(_bots.begin()->second->GetGUID(), removetype);
+}
+//Bot is being abandoned by player
+void BotMgr::RemoveBot(ObjectGuid guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(a)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(a)!!");
+
+    //trying to remove temp bot second time means removing all bots
+    //just erase from bots because already cleaned up
+    for (std::list<ObjectGuid>::iterator it = _removeList.begin(); it != _removeList.end(); ++it)
+    {
+        if (*it == guid)
+        {
+            _removeList.erase(it);
+            _bots.erase(itr);
+            return;
+        }
+    }
+
+    Creature* bot = itr->second;
+    CleanupsBeforeBotDelete(guid, removetype);
+
+    ////remove control bar
+    //if (GetNpcBotsCount() <= 1 && !_owner->GetPetGUID() && _owner->m_Controlled.empty())
+    //    _owner->SendRemoveControlBar();
+
+    if (bot->GetBotAI()->IsTempBot())
+    {
+        //bot->GetBotAI()->OnBotDespawn(bot); //send to self
+        _addBotToRemoveList(guid);
+        return;
+    }
+
+    _bots.erase(itr);
+
+    bot->GetBotAI()->ResetBotAI(removetype == BOT_REMOVE_DISMISS ? BOTAI_RESET_DISMISS : BOTAI_RESET_LOGOUT);
+
+    bot->SetFaction(bot->GetCreatureTemplate()->faction);
+    bot->SetLevel(bot->GetCreatureTemplate()->minlevel);
+
+    if (removetype == BOT_REMOVE_DISMISS)
+    {
+        uint32 newOwner = 0;
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+    }
+
+    bot->GetBotAI()->Reset();
+    bot->GetBotAI()->canUpdate = true;
+}
+
+BotAddResult BotMgr::AddBot(Creature* bot, bool takeMoney)
+{
+    ASSERT(bot->IsNPCBot());
+    ASSERT(bot->GetBotAI() != nullptr);
+
+    bool temporary = bot->GetBotAI()->IsTempBot();
+
+    if (!_enableNpcBots)
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.SendSysMessage("NpcBot system is currently disabled. Please contact administration.");
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_DISABLED;
+    }
+    if (GetBot(bot->GetGUID()))
+        return BOT_ADD_ALREADY_HAVE; //Silent error, intended
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s will not join you, already has master: %s",
+            bot->GetName().c_str(), bot->GetBotOwner()->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_NOT_AVAILABLE;
+    }
+    if (bot->GetBotAI()->IsDuringTeleport())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s cannot join you while about to teleport", bot->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_BUSY;
+    }
+    if (!temporary && _owner->GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("Youre exceed max npcbots (%u)", GetMaxNpcBots());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_MAX_EXCEED;
+    }
+    if (!temporary && HaveBot() && _maxClassNpcBots)
+    {
+        uint8 count = 0;
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetBotClass() == bot->GetBotClass())
+                ++count;
+
+        if (count >= _maxClassNpcBots)
+        {
+            ChatHandler ch(_owner->GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, _maxClassNpcBots);
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_MAX_CLASS_EXCEED;
+        }
+    }
+    //Map* curMap = _owner->GetMap();
+    //if (!temporary && LimitBots(curMap))
+    //{
+    //    InstanceMap* map = curMap->ToInstanceMap();
+    //    uint32 count = map->GetPlayersCountExceptGMs();
+    //    if (count >= map->GetMaxPlayers())
+    //    {
+    //        ChatHandler ch(_owner->GetSession());
+    //        ch.PSendSysMessage("Instance players limit exceed (%u of %u)", count, map->GetMaxPlayers());
+    //        //ch.SetSentErrorMessage(true);
+    //        return BOT_ADD_INSTANCE_LIMIT;
+    //    }
+    //}
+    if (!temporary && takeMoney)
+    {
+        uint32 cost = GetNpcBotCost(_owner->GetLevel(), bot->GetBotClass());
+        if (!_owner->HasEnoughMoney(cost))
+        {
+            ChatHandler ch(_owner->GetSession());
+            std::string str = "You don't have enough money (";
+            str += GetNpcBotCostStr(_owner->GetLevel(), bot->GetBotClass());
+            str += ")!";
+            ch.SendSysMessage(str.c_str());
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_CANT_AFFORD;
+        }
+
+        _owner->ModifyMoney(-(int32(cost)));
+    }
+
+    bot->GetBotAI()->canUpdate = false;
+
+    if (!bot->IsAlive())
+        _reviveBot(bot);
+
+    bot->GetBotAI()->UnsummonAll();
+
+    _bots[bot->GetGUID()] = bot;
+
+    ASSERT(!bot->GetOwnerGUID());
+    bot->SetOwnerGUID(_owner->GetGUID());
+    bot->SetCreatorGUID(_owner->GetGUID()); //needed in case of FFAPVP
+    //_owner->m_Controlled.insert(bot);
+    bot->SetControlledByPlayer(true);
+    bot->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+    bot->SetFaction(_owner->GetFaction());
+    bot->SetPhaseMask(_owner->GetPhaseMask(), true);
+
+    bot->GetBotAI()->SetBotOwner(_owner);
+
+    bot->GetBotAI()->Reset();
+
+    if (!temporary)
+    {
+        bot->GetBotAI()->SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+        if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            AddBotToGroup(bot);
+
+        uint32 newOwner = _owner->GetGUID().GetCounter();
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+    }
+
+    return BOT_ADD_SUCCESS;
+}
+
+bool BotMgr::AddBotToGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (gr)
+    {
+        if (gr->IsMember(bot->GetGUID()))
+            return true;
+
+        if (gr->IsFull())
+        {
+            if (!gr->isRaidGroup()) //non-raid group is full
+                gr->ConvertToRaid();
+            else
+                return false;
+        }
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(_owner))
+        {
+            delete gr;
+            return false;
+        }
+        sGroupMgr->AddGroup(gr);
+    }
+
+    if (gr->AddMember((Player*)bot))
+    {
+        if (!bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+        return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::RemoveBotFromGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (!gr || !gr->IsMember(bot->GetGUID()))
+        return false;
+
+    if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY) && !_owner->GetSession()->PlayerLogout())
+        bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+    //debug
+    //if (gr->RemoveMember(bot->GetGUID()))
+    //    TC_LOG_ERROR("entities.player", "RemoveBotFromGroup(): bot %s removed from group", bot->GetName().c_str());
+    //else
+    //    TC_LOG_ERROR("entities.player", "RemoveBotFromGroup(): RemoveMember() returned FALSE on bot %s", bot->GetName().c_str());
+
+    gr->RemoveMember(bot->GetGUID());
+
+    return true;
+}
+
+bool BotMgr::RemoveAllBotsFromGroup()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        RemoveBotFromGroup(itr->second);
+
+    return true;
+}
+
+uint32 BotMgr::GetNpcBotCost(uint8 level, uint8 botclass)
+{
+    //assuming default 1000000
+    //level 1: 1000
+    //11 : 1666
+    //15 : 8333
+    //20 : 16666
+    //30 : 33333
+    //40 : 50000
+    //rest is linear
+    //rare / rareelite bots have their cost adjusted
+    uint32 cost =
+        level < 10 ? _npcBotsCost / 5000 : //2 silver
+        level < 20 ? _npcBotsCost / 100 :  //1 gold
+        level < 30 ? _npcBotsCost / 20 :   //5 gold
+        level < 40 ? _npcBotsCost / 5 :    //20 gold
+        (_npcBotsCost * level) / DEFAULT_MAX_LEVEL; //50 - 100 gold
+
+    switch (botclass)
+    {
+        case BOT_CLASS_BM:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_SPELLBREAKER:
+            cost += cost; //200%
+            break;
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_DARK_RANGER:
+            cost += cost * 4; //500%
+            break;
+        default:
+            break;
+    }
+
+    return cost;
+}
+
+std::string BotMgr::GetNpcBotCostStr(uint8 level, uint8 botclass)
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost(level, botclass))
+    {
+        uint32 gold = uint32(cost / GOLD);
+        cost -= (gold * GOLD);
+        uint32 silver = uint32(cost / SILVER);
+        cost -= (silver * SILVER);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+
+    return money.str();
+}
+
+void BotMgr::ReviveAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        _reviveBot(itr->second);
+}
+
+void BotMgr::SendBotCommandState(uint8 state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->SetBotCommandState(state, true);
+}
+
+void BotMgr::RecallAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->IsInWorld() && itr->second->IsAlive() && !bot_ai::CCed(itr->second, true))
+            itr->second->GetMotionMaster()->MovePoint(_owner->GetMapId(), *_owner, false);
+}
+
+void BotMgr::RecallBot(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    if (bot->IsInWorld() && bot->IsAlive() && !bot_ai::CCed(bot, true))
+        bot->GetMotionMaster()->MovePoint(_owner->GetMapId(), *_owner, false);
+}
+
+void BotMgr::KillAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        KillBot(itr->second);
+}
+
+void BotMgr::KillBot(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    if (bot->IsInWorld() && bot->IsAlive())
+    {
+        bot->setDeathState(JUST_DIED);
+        bot->GetBotAI()->JustDied(bot);
+        //bot->Kill(bot);
+    }
+}
+
+void BotMgr::SetBotsShouldUpdateStats()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->SetShouldUpdateStats();
+}
+
+void BotMgr::UpdatePhaseForBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetPhaseMask(_owner->GetPhaseMask(), itr->second->IsInWorld());
+        if (itr->second->GetBotsPet())
+            itr->second->GetBotsPet()->SetPhaseMask(_owner->GetPhaseMask(), true); //only if in world
+    }
+}
+
+void BotMgr::UpdatePvPForBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        if (itr->second->GetBotsPet())
+            itr->second->GetBotsPet()->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+    }
+}
+
+void BotMgr::TrackDamage(Unit const* u, uint32 damage)
+{
+    _dpstracker->TrackDamage(u, damage);
+}
+
+uint32 BotMgr::GetDPSTaken(Unit const* u) const
+{
+    return _dpstracker->GetDPSTaken(u->GetGUID().GetRawValue());
+}
+
+int32 BotMgr::GetHPSTaken(Unit const* unit) const
+{
+    if (!HaveBot())
+        return 0;
+
+    std::list<Unit*> unitList;
+    Group const* gr = _owner->GetGroup();
+    if (!gr)
+    {
+        if (_owner->HasUnitState(UNIT_STATE_CASTING))
+            unitList.push_back(_owner);
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetTarget() == unit->GetGUID() && itr->second->HasUnitState(UNIT_STATE_CASTING))
+                unitList.push_back(itr->second);
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* player = itr->GetSource();
+            if (player == nullptr) continue;
+            if (_owner->GetMap() != player->FindMap()) continue;
+            if (!Bots)
+                Bots = true;
+            if (player->HasUnitState(UNIT_STATE_CASTING))
+                unitList.push_back(player);
+        }
+        if (Bots)
+        {
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                if (itr->GetSource() == nullptr) continue;
+                if (_owner->GetMap() != itr->GetSource()->FindMap()) continue;
+
+                if (itr->GetSource()->HaveBot())
+                {
+                    BotMap const* map = itr->GetSource()->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                        if (itr->second->GetTarget() == unit->GetGUID() && itr->second->HasUnitState(UNIT_STATE_CASTING))
+                            unitList.push_back(itr->second);
+                }
+            }
+        }
+    }
+
+    int32 amount = 0;
+
+    Unit* u;
+    Spell const* spell;
+    SpellInfo const* spellInfo;
+    for (std::list<Unit*>::const_iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+    {
+        u = *itr;
+
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+        {
+            spell = u->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+
+            ObjectGuid targetGuid = spell->m_targets.GetObjectTargetGUID();
+            if (!targetGuid || !targetGuid.IsUnit())
+                continue;
+
+            if (targetGuid != unit->GetGUID())
+            {
+                if (!gr || !gr->IsMember(unit->GetGUID()))
+                    continue;
+            }
+
+            spellInfo = spell->GetSpellInfo();
+
+            for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
+            {
+                if (spellInfo->Effects[j].Effect != SPELL_EFFECT_HEAL)
+                    continue;
+
+                if (targetGuid != unit->GetGUID())
+                {
+                    if (spellInfo->Effects[j].TargetA.GetSelectionCategory() != TARGET_SELECT_CATEGORY_AREA)
+                        continue;
+
+                    //Targets t = spellInfo->Effects[j].TargetA.GetTarget();
+                    //non-existing case
+                    //if (t == TARGET_UNIT_CASTER_AREA_PARTY && !gr->SameSubGroup(u->GetGUID(), unit->GetGUID()))
+                    //    continue;
+                    Targets t = spellInfo->Effects[j].TargetB.GetTarget();
+                    if (t == TARGET_UNIT_LASTTARGET_AREA_PARTY &&
+                        !(GetBot(unit->GetGUID()) && GetBot(targetGuid)) &&
+                        !gr->SameSubGroup(unit->GetGUID(), targetGuid))
+                        continue;
+                }
+
+                int32 healing = u->SpellHealingBonusDone(const_cast<Unit*>(unit), spellInfo, spellInfo->Effects[0].CalcValue(u), HEAL, 0, {});
+                healing = unit->SpellHealingBonusTaken(u, spellInfo, healing, HEAL);
+
+                if (i == CURRENT_CHANNELED_SPELL)
+                    amount += healing / (spellInfo->Effects[j].Amplitude * 0.001f);
+                else
+                    amount += healing / (std::max<int32>(spell->GetTimer(), 1000) * 0.001f);
+
+                //TC_LOG_ERROR("entities.player", "BotMgr:pendingHeals: found %s's %s on %s in %u (%i, total %i)",
+                //    u->GetName().c_str(), spellInfo->SpellName[0], target->GetName().c_str(), pheal->delay, healing, pheal->amount);
+            }
+
+            break;
+        }
+    }
+
+    //HoTs
+    Unit::AuraEffectList const& hots = unit->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+    for (Unit::AuraEffectList::const_iterator itr = hots.begin(); itr != hots.end(); ++itr)
+        amount += (*itr)->GetAmount() / ((*itr)->GetAmplitude() * 0.001f);
+
+    //if (amount != 0)
+    //    TC_LOG_ERROR("entities.player", "BotMgr:GetHPSTaken(): %s got %i)", unit->GetName().c_str(), amount);
+
+    return amount;
+}
+
+void BotMgr::OnBotDamageDealt(Unit* attacker, Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* spellInfo)
+{
+    attacker->ToCreature()->GetBotAI()->OnBotDamageDealt(victim, damage, cleanDamage, damagetype, spellInfo);
+}
+
+void BotMgr::OnBotDispelDealt(Unit* dispeller, Unit* dispelled, uint8 num)
+{
+    dispeller->ToCreature()->GetBotAI()->OnBotDispelDealt(dispelled, num);
+}
+
+void BotMgr::ApplyBotEffectMods(Unit const* caster, Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value)
+{
+    caster->ToCreature()->GetBotAI()->ApplyBotEffectMods(target, spellInfo, effIndex, value);
+}
+
+float BotMgr::GetBotDamageTakenMod(Creature const* bot, bool magic)
+{
+    return bot->GetBotAI()->GetBotDamageTakenMod(magic);
+}
+
+float BotMgr::GetBotDamageModPhysical()
+{
+    return _mult_dmg_physical;
+}
+float BotMgr::GetBotDamageModSpell()
+{
+    return _mult_dmg_spell;
+}
+float BotMgr::GetBotHealingMod()
+{
+    return _mult_healing;
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.h b/src/server/game/AI/NpcBots/botmgr.h
new file mode 100644
index 0000000..c1a4edc
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.h
@@ -0,0 +1,169 @@
+#ifndef _BOTMGR_H
+#define _BOTMGR_H
+
+class Creature;
+class Map;
+class Player;
+class WorldLocation;
+class DPSTracker;
+
+struct Position;
+
+enum BotAddResult
+{
+    BOT_ADD_DISABLED                    = 0x001,
+    BOT_ADD_ALREADY_HAVE                = 0x002,
+    BOT_ADD_MAX_EXCEED                  = 0x004,
+    BOT_ADD_MAX_CLASS_EXCEED            = 0x008,
+    BOT_ADD_CANT_AFFORD                 = 0x010,
+    BOT_ADD_INSTANCE_LIMIT              = 0x020,
+    BOT_ADD_BUSY                        = 0x040,
+    BOT_ADD_NOT_AVAILABLE               = 0x080,
+
+    BOT_ADD_SUCCESS                     = 0x100,
+
+    BOT_ADD_FATAL                       = (BOT_ADD_DISABLED | BOT_ADD_CANT_AFFORD | BOT_ADD_MAX_EXCEED | BOT_ADD_MAX_CLASS_EXCEED)
+};
+
+enum BotRemoveType
+{
+    BOT_REMOVE_LOGOUT                   = 0,
+    BOT_REMOVE_DISMISS                  = 1,
+    BOT_REMOVE_UNSUMMON                 = 2,
+    BOT_REMOVE_BY_DEFAULT               = BOT_REMOVE_LOGOUT
+};
+
+enum BotAttackRange
+{
+    BOT_ATTACK_RANGE_SHORT              = 1,
+    BOT_ATTACK_RANGE_LONG               = 2,
+    BOT_ATTACK_RANGE_EXACT              = 3
+};
+
+typedef std::unordered_map<ObjectGuid /*guid*/, Creature* /*bot*/> BotMap;
+
+class BotMgr
+{
+    public:
+        BotMgr(Player* const master);
+        ~BotMgr();
+
+        Player* GetOwner() const { return _owner; }
+
+        BotMap const* GetBotMap() const { return &_bots; }
+        BotMap* GetBotMap() { return &_bots; }
+
+        static bool IsNpcBotModEnabled();
+        static bool IsNpcBotDungeonFinderEnabled();
+        static bool DisplayEquipment();
+        static bool ShowEquippedCloak();
+        static bool ShowEquippedHelm();
+        static bool IsClassEnabled(uint8 m_class);
+        static bool IsBotStatsLimitsEnabled();
+        static bool IsPvPEnabled();
+        static bool IsFoodInterruptedByMovement();
+        static uint8 GetMaxClassBots();
+        static uint8 GetHealTargetIconFlags();
+        static uint8 GetTankTargetIconFlags();
+        static uint8 GetDPSTargetIconFlags();
+        static uint32 GetBaseUpdateDelay();
+        static float GetBotStatLimitDodge();
+        static float GetBotStatLimitParry();
+        static float GetBotStatLimitBlock();
+        static float GetBotStatLimitCrit();
+
+        static void Initialize();
+        static void ReloadConfig();
+        static void LoadConfig(bool reload = false);
+
+        //onEvent hooks
+        static void OnBotDamageDealt(Unit* attacker, Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* spellInfo);
+        static void OnBotDispelDealt(Unit* dispeller, Unit* dispelled, uint8 num);
+        //mod hooks
+        static void ApplyBotEffectMods(Unit const* caster, Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value);
+        static float GetBotDamageTakenMod(Creature const* bot, bool magic);
+        static float GetBotDamageModPhysical();
+        static float GetBotDamageModSpell();
+        static float GetBotHealingMod();
+
+        void Update(uint32 diff);
+
+        Creature* GetBot(ObjectGuid guid) const;
+        bool HaveBot() const { return !_bots.empty(); }
+        uint8 GetNpcBotsCount() const;
+        uint8 GetNpcBotsCountByRole(uint16 roles) const;
+        uint8 GetNpcBotSlotByRole(uint16 roles, Creature const* bot) const;
+        static uint8 GetMaxNpcBots();
+        static uint8 GetNpcBotXpReduction();
+        static int32 GetBotInfoPacketsLimit();
+        static bool LimitBots(Map const* map);
+        bool RestrictBots(Creature const* bot, bool add) const;
+        bool IsPartyInCombat() const;
+        bool HasBotClass(uint8 botclass) const;
+        bool HasBotPetType(uint32 petType) const;
+
+        static uint32 GetNpcBotCost(uint8 level, uint8 botclass);
+        static std::string GetNpcBotCostStr(uint8 level, uint8 botclass);
+
+        void OnTeleportFar(uint32 mapId, float x, float y, float z, float ori = 0.f);
+        void OnOwnerSetGameMaster(bool on);
+        void ReviveAllBots();
+        void SendBotCommandState(uint8 state);
+        void RecallAllBots();
+        void RecallBot(Creature* bot);
+        void KillAllBots();
+        void KillBot(Creature* bot);
+
+        void CleanupsBeforeBotDelete(ObjectGuid guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveAllBots(uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveBot(ObjectGuid guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        BotAddResult AddBot(Creature* bot, bool takeMoney);
+        bool AddBotToGroup(Creature* bot);
+        bool RemoveBotFromGroup(Creature* bot);
+        bool RemoveAllBotsFromGroup();
+
+        static uint8 GetBotFollowDistDefault() { return 100; }
+        uint8 GetBotFollowDist() const { return _followdist; }
+        void SetBotFollowDist(uint8 dist) { _followdist = dist; }
+
+        uint8 GetBotExactAttackRange() const { return _exactAttackRange; }
+        uint8 GetBotAttackRangeMode() const { return _attackRangeMode; }
+        void SetBotAttackRangeMode(uint8 mode, uint8 exactRange = 0) { _attackRangeMode = mode; _setBotExactAttackRange(exactRange); }
+
+        void SetBotsHidden(bool hidden) { _botsHidden = hidden; }
+
+        void SetBotsShouldUpdateStats();
+        void UpdatePhaseForBots();
+        void UpdatePvPForBots();
+
+        void TrackDamage(Unit const* u, uint32 damage);
+        uint32 GetDPSTaken(Unit const* u) const;
+        int32 GetHPSTaken(Unit const* unit) const;
+
+        static void ReviveBot(Creature* bot, WorldLocation* dest = nullptr) { _reviveBot(bot, dest); }
+
+        //TELEPORT BETWEEN MAPS
+        //CONFIRMEND UNSAFE (charmer,owner)
+        static void TeleportBot(Creature* bot, Map* newMap, Position* pos);
+
+    private:
+        static void _teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori = 0.f);
+        static void _reviveBot(Creature* bot, WorldLocation* dest = nullptr);
+        void _addBotToRemoveList(ObjectGuid guid);
+        void _setBotExactAttackRange(uint8 exactRange) { _exactAttackRange = exactRange; }
+
+        Player* const _owner;
+        BotMap _bots;
+        std::list<ObjectGuid> _removeList;
+        DPSTracker* const _dpstracker;
+
+        uint8 _followdist;
+        uint8 _exactAttackRange;
+        uint8 _attackRangeMode;
+
+        bool _botsHidden;
+};
+
+void AddNpcBotScripts();
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bpet_ai.cpp b/src/server/game/AI/NpcBots/bpet_ai.cpp
new file mode 100644
index 0000000..041835f
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_ai.cpp
@@ -0,0 +1,2271 @@
+#include "bpet_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot Pet System by Trickerer (https://github.com/trickerer/Trinity-Bots; onlysuffering@gmail.com)
+*/
+
+#define SHAMAN_MAX_PET_POSITIONS 2
+#define DRUID_MAX_PET_POSITIONS 3
+#define DK_MAX_PET_POSITIONS 10
+#define DARK_RANGER_MAX_PET_POSITIONS 5
+float const ShamanPetPositionAnglesByPosNumber[SHAMAN_MAX_PET_POSITIONS] =
+{
+    0.f,//left
+    M_PI//right
+};
+float const DruidPetPositionAnglesByPosNumber[DRUID_MAX_PET_POSITIONS] =
+{
+    0.f,//left
+    M_PI/2,//back
+    M_PI//right
+};
+float const DKPetPositionAnglesByPosNumber[DK_MAX_PET_POSITIONS] =
+{
+    0.f,
+    M_PI,
+    0.3490658f,//1*M_PI/9
+    0.6981317f,//2*M_PI/9
+    1.0471975f,//3*M_PI/9
+    1.3962634f,//4*M_PI/9
+    1.7453292f,//5*M_PI/9
+    2.0943951f,//6*M_PI/9
+    2.4434609f,//7*M_PI/9
+    2.7925268f //8*M_PI/9
+};
+float const DarkRangerPetPositionAnglesByPosNumber[DARK_RANGER_MAX_PET_POSITIONS] =
+{
+    0.f,
+    M_PI,
+    0.7853981f,//1*M_PI/4
+    1.5707963f,//2*M_PI/4
+    2.3561944f //3*M_PI/4
+};
+
+extern uint8 GroupIconsFlags[TARGETICONCOUNT];
+
+static uint16 __rand; //calculated for each bot separately once every updateAI tick
+
+extern bool _botPvP;
+extern uint8 _healTargetIconFlags;
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : CreatureAI(creature)
+{
+    m_botCommandState = BOT_COMMAND_FOLLOW;
+    regenTimer = 0;
+    waitTimer = 0;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _energyFraction = 0.f;
+    _updateTimerMedium = 0;
+    _updateTimerEx1 = urand(12000, 15000);
+    checkAurasTimer = 0;
+
+    myType = 0;
+    petOwner = nullptr;
+    canUpdate = true;
+}
+bot_pet_ai::~bot_pet_ai()
+{
+    while (!_spells.empty())
+    {
+        BotPetSpellMap::iterator itr = _spells.begin();
+        delete itr->second;
+        _spells.erase(itr);
+    }
+}
+
+uint16 bot_pet_ai::Rand() const
+{
+    return __rand;
+}
+//0-178
+void bot_pet_ai::GenerateRand() const
+{
+    __rand = urand(0, IAmFree() ? 100 : 100 + (petOwner->GetBotOwner()->GetNpcBotsCount() - 1) * 2);
+}
+
+bool bot_pet_ai::_checkImmunities(Unit const* target, SpellInfo const* spellInfo) const
+{
+    return target && spellInfo && !target->IsImmunedToDamage(spellInfo);
+}
+//Follow point calculation
+void bot_pet_ai::_calculatePos(Position& pos) const
+{
+    float x,y,z;
+    //destination
+    if (!petOwner->GetMotionMaster()->GetDestination(x, y, z))
+        petOwner->GetPosition(x, y, z);
+    //relative angle
+    float o = petOwner->GetOrientation() + PET_FOLLOW_ANGLE;
+    uint8 posNum = petOwner->GetBotAI()->GetPetPositionNumber(me);
+    if (petOwner->GetBotClass() == BOT_CLASS_DEATH_KNIGHT)
+        o += DKPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_DRUID)
+        o += DruidPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_SHAMAN)
+        o += ShamanPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_DARK_RANGER)
+        o += DarkRangerPetPositionAnglesByPosNumber[posNum];
+
+    o = Position::NormalizeOrientation(o);
+    //distance
+    x += (PET_FOLLOW_DIST + me->GetCombatReach()) * std::cos(o);
+    y += (PET_FOLLOW_DIST + me->GetCombatReach()) * std::sin(o);
+    me->UpdateGroundPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.5f; //prevent going underground
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+void bot_pet_ai::SetBotCommandState(uint8 st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    if ((st & BOT_COMMAND_FOLLOW) && !IsChanneling() &&
+        ((!me->isMoving() && !IsCasting() && petOwner->GetBotOwner()->IsAlive()) || force))
+    {
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 10) return;
+
+        float x,y,z;
+        if (petOwner->GetMotionMaster()->GetDestination(x, y, z) && me->GetDistance(x, y, z) < 6.f)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW))
+                me->GetMotionMaster()->MoveFollow(petOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+        {
+            if (!newpos)
+                _calculatePos(pos);
+            else
+            {
+                pos.m_positionX = newpos->m_positionX;
+                pos.m_positionY = newpos->m_positionY;
+                pos.m_positionZ = newpos->m_positionZ;
+            }
+            me->GetMotionMaster()->MovePoint(petOwner->GetMapId(), pos);
+        }
+        RemoveBotCommandState(BOT_COMMAND_STAY | BOT_COMMAND_FULLSTOP | BOT_COMMAND_ATTACK | BOT_COMMAND_COMBATRESET);
+    }
+    else if (st & BOT_COMMAND_FULLSTOP)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_STAY | BOT_COMMAND_ATTACK);
+        me->AttackStop();
+        me->InterruptNonMeleeSpells(true);
+        if (me->isMoving())
+            me->BotStopMovement();
+    }
+    else if (st & BOT_COMMAND_STAY)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_FULLSTOP);
+        if (me->isMoving())
+            me->BotStopMovement();
+    }
+    else if (st & BOT_COMMAND_ATTACK)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW);
+    }
+    else if (st & BOT_COMMAND_COMBATRESET)
+    {
+        RemoveBotCommandState(BOT_COMMAND_ATTACK);
+    }
+    m_botCommandState |= st;
+}
+
+void bot_pet_ai::RemoveBotCommandState(uint8 st)
+{
+    m_botCommandState &= ~st;
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_pet_ai::CureGroup(uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell) return;
+    if (GC_Timer > diff) return;
+    if (IsCasting()) return;
+
+    if (IAmFree())
+    {
+        std::list<Unit*> cureTargets;
+
+        if (_canCureTarget(me, cureSpell))
+            cureTargets.push_back(me);
+        if (_canCureTarget(petOwner, cureSpell))
+            cureTargets.push_back(petOwner);
+
+        if (!cureTargets.empty())
+            me->CastSpell(Trinity::Containers::SelectRandomContainerElement(cureTargets), cureSpell, false);
+
+        return;
+    }
+
+    if (!me->GetMap()->IsRaid() && Rand() > 35)
+        return;
+
+    std::list<Unit*> targets;
+    Group const* pGroup = petOwner->GetBotOwner()->GetGroup();
+    BotMap const* map;
+    Unit* u;
+    if (!pGroup)
+    {
+        if (_canCureTarget(petOwner->GetBotOwner(), cureSpell))
+            targets.push_back(petOwner->GetBotOwner());
+
+        map = petOwner->GetBotOwner()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            u = itr->second;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+
+        for (Unit::ControlList::const_iterator itr = petOwner->GetBotOwner()->m_Controlled.begin(); itr != petOwner->GetBotOwner()->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (_canCureTarget(tPlayer, cureSpell))
+                targets.push_back(tPlayer);
+        }
+        if (!Bots) return;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                    if (_canCureTarget(u, cureSpell))
+                        targets.push_back(u);
+                }
+            }
+
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+                if (_canCureTarget(u, cureSpell))
+                    targets.push_back(u);
+            }
+        }
+    }
+
+    if (!targets.empty())
+        me->CastSpell(Trinity::Containers::SelectRandomContainerElement(targets), cureSpell, false);
+}
+
+// determines if unit has something to cure
+bool bot_pet_ai::_canCureTarget(Unit const* target, uint32 cureSpell) const
+{
+    if (me->GetLevel() < 10 || target->GetLevel() < 10) return false;
+    if (target->HasUnitState(UNIT_STATE_ISOLATED)) return false;
+    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsTempBot()) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    if (me->GetDistance(target) > CalcSpellMaxRange(cureSpell, false))
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    std::list<Aura const*> dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_pet_ai::_getBotDispellableAuraList(Unit const* target, Unit const* caster, uint32 dispelMask, std::list<Aura const*> &dispelList) const
+{
+    //Unholy Blight prevents diseases from being dispelled
+    if ((dispelMask & (1<<DISPEL_DISEASE)) &&
+        target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0))
+        dispelMask &= ~(1<<DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura const* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            if (((aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount()) > 0)
+                dispelList.push_back(aura);
+        }
+    }
+}
+
+uint32 bot_pet_ai::GetData(uint32 data) const
+{
+    switch (data)
+    {
+        case BOTPETAI_MISC_DURATION:
+            return 0;
+        case BOTPETAI_MISC_MAXLEVEL:
+            return petOwner->GetLevel();
+        default:
+            TC_LOG_DEBUG("entities.unit", "bot_pet_ai::GetData(): unk data type %u!", data);
+            return 0;
+    }
+}
+
+void bot_pet_ai::SetPetStats(bool force)
+{
+    switch (myType)
+    {
+        //warlock
+        case BOT_PET_IMP:
+        case BOT_PET_VOIDWALKER:
+        case BOT_PET_SUCCUBUS:
+        case BOT_PET_FELHUNTER:
+        case BOT_PET_FELGUARD:
+        //hunter
+        //cunning
+        case BOT_PET_SPIDER:
+        case BOT_PET_SERPENT:
+        case BOT_PET_BIRDOFPREY:
+        case BOT_PET_BAT:
+        case BOT_PET_WINDSERPENT:
+        case BOT_PET_RAVAGER:
+        case BOT_PET_DRAGONHAWK:
+        case BOT_PET_NETHERRAY:
+        case BOT_PET_SPOREBAT:
+        //ferocity
+        case BOT_PET_CARRIONBIRD:
+        case BOT_PET_RAPTOR:
+        case BOT_PET_WOLF:
+        case BOT_PET_TALLSTRIDER:
+        case BOT_PET_CAT:
+        case BOT_PET_HYENA:
+        case BOT_PET_WASP:
+        case BOT_PET_TEROMOTH:
+        //tenacity
+        case BOT_PET_SCORPID:
+        case BOT_PET_TURTLE:
+        case BOT_PET_GORILLA:
+        case BOT_PET_BEAR:
+        case BOT_PET_BOAR:
+        case BOT_PET_CRAB:
+        case BOT_PET_CROCOLISK:
+        case BOT_PET_WARPSTALKER:
+        //cunning (exotic)
+        case BOT_PET_SILITHID:
+        case BOT_PET_CHIMAERA:
+        //ferocity (exotic)
+        case BOT_PET_SPIRITBEAST:
+        case BOT_PET_COREHOUND:
+        case BOT_PET_DEVILSAUR:
+        //tenacity (exotic)
+        case BOT_PET_RHINO:
+        case BOT_PET_WORM:
+        //death knight
+        case BOT_PET_GHOUL:
+        //case BOT_PET_GARGOYLE:
+        //case BOT_PET_DANCING_RUNE_WEAPON:
+        //case BOT_PET_AOD_GHOUL:
+        //priest
+        case BOT_PET_SHADOWFIEND:
+        //shaman
+        case BOT_PET_SPIRIT_WOLF:
+        //mage
+        case BOT_PET_WATER_ELEMENTAL:
+        //druid
+        case BOT_PET_FORCE_OF_NATURE:
+        //archmage
+        case BOT_PET_AWATER_ELEMENTAL:
+        //dreadlord
+        case BOT_PET_INFERNAL:
+        //dark ranger
+        case BOT_PET_DARK_MINION:
+        case BOT_PET_DARK_MINION_ELITE:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "bot_pet_ai::SetPetStats(): unk pet type %u, aborting", myType);
+            return;
+    }
+
+    //some time limited summons can only init stats and never change them
+    switch (myType)
+    {
+        case BOT_PET_SHADOWFIEND:
+        case BOT_PET_SPIRIT_WOLF:
+        //case BOT_PET_WATER_ELEMENTAL:
+        case BOT_PET_FORCE_OF_NATURE:
+        case BOT_PET_DARK_MINION:
+        case BOT_PET_DARK_MINION_ELITE:
+            if (force == false)
+                return;
+            break;
+        default:
+            break;
+    }
+
+    uint8 level = std::min<uint8>(petOwner->GetLevel(), GetData(BOTPETAI_MISC_MAXLEVEL));
+    if (level != me->GetLevel())
+    {
+        me->SetLevel(level);
+        force = true;
+    }
+
+    int32 spdtotal;
+    switch (petOwner->GetBotClass())
+    {
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+            spdtotal = petOwner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);
+            break;
+        default:
+            spdtotal = 0;
+            break;
+    }
+
+    if (force)
+    {
+        InitPetSpells();
+        ApplyPetPassives();
+
+        me->RemoveAurasDueToSpell(DAMAGEDONE_PASSIVE);
+        me->RemoveAurasDueToSpell(DAMAGETAKEN_PASSIVE);
+        me->RemoveAurasDueToSpell(SPELLDAMAGE_PASSIVE);
+        me->RemoveAurasDueToSpell(SPELLPENETRATION_PASSIVE);
+        me->RemoveAurasDueToSpell(SPELLHASTE_PASSIVE);
+        me->RemoveAurasDueToSpell(CRITBONUS_PASSIVE);
+
+        me->CastSpell(me, DAMAGEDONE_PASSIVE, true);
+        me->CastSpell(me, DAMAGETAKEN_PASSIVE, true);
+        me->CastSpell(me, SPELLDAMAGE_PASSIVE, true);
+        me->CastSpell(me, SPELLPENETRATION_PASSIVE, true);
+        me->CastSpell(me, SPELLHASTE_PASSIVE, true);
+        me->CastSpell(me, CRITBONUS_PASSIVE, true);
+    }
+
+    //base stats
+    uint32 myarmor = 0;
+    if (force)
+    {
+        uint32 origEntry = bot_ai::GetPetOriginalEntry(myType);
+        CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(origEntry);
+        ASSERT(cinfo);
+
+        me->SetMeleeDamageSchool(SpellSchools(cinfo->dmgschool));
+
+        PetLevelInfo const* pInfo = sObjectMgr->GetPetLevelInfo(origEntry, level);
+        if (pInfo)
+        {
+            me->SetCreateHealth(pInfo->health);
+            if (petOwner->GetBotClass() == BOT_CLASS_HUNTER) //hunter pet use focus
+            {
+                //prevent from modifying powers inside
+                if (me->GetPowerType() != POWER_FOCUS)
+                {
+                    me->SetMaxPower(POWER_FOCUS, 100);
+                    me->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_FOCUS);
+                }
+            }
+            else if (myType == BOT_PET_GHOUL)
+            {
+                if (me->GetPowerType() != POWER_ENERGY)
+                {
+                    me->SetMaxPower(POWER_ENERGY, 100);
+                    me->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_ENERGY);
+                }
+            }
+            else if (myType == BOT_PET_SHADOWFIEND)
+            {
+                me->SetCreateHealth(28 + 30*level);
+                me->SetCreateMana(28 + 10*level);
+                me->SetPowerType(POWER_MANA);
+            }
+            else if (myType == BOT_PET_SPIRIT_WOLF)
+            {
+                me->SetCreateHealth(30*level);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_FORCE_OF_NATURE)
+            {
+                me->SetCreateHealth(30*(level+1));
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_DARK_MINION)
+            {
+                me->SetCreateHealth(pInfo->health / 4);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_DARK_MINION_ELITE)
+            {
+                me->SetCreateHealth(pInfo->health / 2);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_AWATER_ELEMENTAL || myType == BOT_PET_INFERNAL)
+            {
+                //custom pets / not using mana
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else
+            {
+                me->SetCreateMana(pInfo->mana);
+                me->SetPowerType(POWER_MANA);
+            }
+
+            if (pInfo->armor > 0)
+                myarmor = pInfo->armor;
+
+            for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+                me->SetCreateStat(Stats(i), pInfo->stats[i]);
+        }
+        else
+        {
+            CreatureBaseStats const* stats = sObjectMgr->GetCreatureBaseStats(level, me->GetCreatureTemplate()->unit_class);
+            me->SetCreateHealth(stats->BaseHealth[cinfo->expansion]);
+            me->SetCreateMana(stats->BaseMana);
+
+            me->SetCreateStat(STAT_STRENGTH, level * 3 + 20);
+            me->SetCreateStat(STAT_AGILITY, level * 2 + 20);
+            me->SetCreateStat(STAT_STAMINA, level * 5 + 20);
+            me->SetCreateStat(STAT_INTELLECT, level * 2 + 25);
+            me->SetCreateStat(STAT_SPIRIT,  level * 2 + 30);
+            TC_LOG_ERROR("entities.unit", "SetPetStats(): pInfo is NULL, setting default stats for pet %u", myType);
+        }
+    }
+
+    //STAT INHERITANCE
+    //STAT -- 'mod' -- description
+    // WARLOCK
+    //AP      x0.57 -- attack power from spd
+    //Armor   x0.35 -- armor
+    //Resist  x0.4  -- resistances
+    //Stamina x0.75 -- stamina
+    //Int     x0.3  -- int
+    //Spd     x0.15 -- spd
+    //Sppen   x1.00 -- sppenetration
+    // HUNTER
+    //AP      x0.22 -- attack power/spd from ranged AP (0.338 wild hunt)
+    //Stamina x0.4  -- health (0.63 wild hunt)
+    //Spd   x0.1287 -- spd from ranged AP (0.18 wild hunt)
+    //rest is same as warlock
+    // DK
+    //AP      x1.52 -- attack power from master's strength
+    //Stamina x0.88 -- health
+    //rest is same as warlock
+    // PRIEST
+    //Damage from spd
+    // SHAMAN
+    //AP      x0.6  -- attack power glyphed
+    //Stamina x0.75 -- health
+    // MAGE
+    //Stamina x0.75 -- health
+    //Spd     x0.40 -- spd
+    //Int     x0.3  -- int
+    // DRUID
+    //Stamina x0.45 -- health
+    //
+    // SHAMAN
+    //
+    // ARCHMAGE
+    //Stamina x2.5  -- stamina
+    //Spd     x1.0  -- spd
+    //rest is same as warlock
+    // DREADLORD
+    //AP      x1.00 -- attack power from spd
+    //Resist  x2.0  -- resistances
+    //Stamina x2.5  -- stamina
+    //Spd     x1.0  -- spd
+    // DARK RANGER
+    //AP      x0.50 -- attack power
+    //Resist  x0.3  -- resistances
+    //Stamina x0.8  -- stamina
+    //rest is same as warlock
+
+    //attack power
+    if (force)
+    {
+        if (myType == BOT_PET_SHADOWFIEND)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 3 + spdtotal * 0.3f));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 5 + spdtotal * 0.3f));
+        }
+        else if (myType == BOT_PET_SPIRIT_WOLF)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 3));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 5));
+        }
+        else if (myType == BOT_PET_FORCE_OF_NATURE)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 2) + spdtotal * 0.15f);
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 3) + spdtotal * 0.15f);
+        }
+        else if (myType == BOT_PET_DARK_MINION)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level + level / 2));
+        }
+        else if (myType == BOT_PET_DARK_MINION_ELITE)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 3));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 4));
+        }
+        else
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level - (level / 4)));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level + (level / 4)));
+        }
+    }
+    float atpower = /*IAmFree() ? 1000.f :*/ 0; //+1000/+0 base pet ap
+    switch (myType)
+    {
+        case BOT_PET_IMP:
+            atpower += me->GetTotalStatValue(STAT_STRENGTH) - 10.0f;
+            break;
+        case BOT_PET_GHOUL:
+            atpower += me->GetTotalStatValue(STAT_STRENGTH) - 10.0f;
+            atpower += 1.52f * petOwner->GetTotalStatValue(STAT_STRENGTH);
+            atpower += 0.3f * petOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+            atpower += level * 8;
+            break;
+        case BOT_PET_DARK_MINION:
+            atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            atpower += 0.3f * petOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+            break;
+        case BOT_PET_DARK_MINION_ELITE:
+            atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            atpower += 0.4f * petOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+            break;
+        default:
+            //atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            break;
+    }
+    switch (petOwner->GetBotClass())
+    {
+        case BOT_CLASS_HUNTER:
+            atpower += (level >= 80 ? 0.338f : 0.22f) * petOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+            //Hunter vs. Wild
+            if (level >= 30 && Spec() == BOT_SPEC_HUNTER_SURVIVAL)
+                atpower += 0.3f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            //Animal Handler
+            if (level >= 35 && Spec() == BOT_SPEC_HUNTER_BEASTMASTERY)
+                atpower *= 1.1f;
+            break;
+        case BOT_CLASS_SHAMAN:
+            //Glyph of Feral Spirit
+            atpower += 0.6f * petOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+            break;
+        case BOT_CLASS_DRUID:
+            atpower += 300 + 0.3f * petOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+            break;
+        case BOT_CLASS_WARLOCK:
+            atpower += 0.57f * spdtotal;
+            //TC_LOG_ERROR("entities.player", "SetPetStat(): atpower += 0.57 of %i = %.2f", spdtotal, atpower);
+            break;
+        case BOT_CLASS_DREADLORD:
+            atpower += spdtotal * 6;
+            //TC_LOG_ERROR("entities.player", "SetPetStat(): atpower += 0.57 of %i = %.2f", spdtotal, atpower);
+            break;
+        default:
+            break;
+    }
+    me->SetStatFlatModifier(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    me->UpdateAttackPowerAndDamage();
+    //armor
+    myarmor = std::max<uint32>(myarmor, level*50);
+    myarmor += me->GetStat(STAT_AGILITY)*2 + petOwner->GetArmor()*0.35f;
+    //armor bonuses
+    if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+    {
+        //5% innate
+        myarmor += myarmor / 20;
+        //Thick Hide
+        if (level >= 15)
+            myarmor += myarmor / 5;
+        //Natural Armor
+        if (level >= 20)
+            myarmor += myarmor / 10;
+        //Pet Barding
+        if (level >= 32)
+            myarmor += myarmor / 10;
+    }
+    if (petOwner->GetBotClass() == BOT_CLASS_DARK_RANGER)
+    {
+        //even though skeletons have shields their armor needs to be very low
+        myarmor = myarmor / 4;
+    }
+    me->SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, float(myarmor));
+    me->UpdateArmor();
+    //resistances
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        float petResist;
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_DREADLORD:
+                petResist = (petOwner->GetBotAI()->GetBotResistanceBonus(SpellSchools(i)) + petOwner->GetResistance(SpellSchools(i)))*2.0f;
+                break;
+            case BOT_CLASS_DARK_RANGER:
+                petResist = (petOwner->GetBotAI()->GetBotResistanceBonus(SpellSchools(i)) + petOwner->GetResistance(SpellSchools(i)))*0.3f;
+                break;
+            default:
+                petResist = (petOwner->GetBotAI()->GetBotResistanceBonus(SpellSchools(i)) + petOwner->GetResistance(SpellSchools(i)))*0.4f;
+                break;
+        }
+        me->SetStatFlatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, petResist);
+        me->UpdateResistances(i);
+    }
+    //crit physical
+    if (AuraEffect* critbonus = me->GetAuraEffect(CRITBONUS_PASSIVE, 1, me->GetGUID()))
+    {
+        int32 amount = 5; //base crit
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Demonic Tactics part 1 (pet)
+                amount += level >= 45 ? 10 : 0;
+                //Improved Demonic Tactics (pshysical)
+                amount += level >= 50 ? petOwner->GetCreatureCritChance() * 0.3f : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Ferocity
+                if (level >= 20)
+                    amount += 10;
+                //Spider's Bite
+                if (level >= 44)
+                    amount += 9;
+                break;
+            case BOT_CLASS_DREADLORD:
+                amount += petOwner->GetCreatureCritChance() * 0.5f;
+                break;
+            case BOT_CLASS_DARK_RANGER:
+                amount += petOwner->GetCreatureCritChance() * 0.35f;
+                break;
+            default:
+                break;
+        }
+        critbonus->ChangeAmount(amount);
+    }
+    //crit spell
+    if (AuraEffect* critbonus = me->GetAuraEffect(CRITBONUS_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 5; //base crit
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+            case BOT_PET_SUCCUBUS:
+                //Master Demonologist part 1.2 (pet)
+                //Master Demonologist part 3.2 (pet)
+                amount += level >= 35 ? 5 : 0;
+                //Improved Demonic Tactics (pshysical)
+                amount += level >= 50 ? petOwner->GetCreatureCritChance() * 0.3f : 0;
+                break;
+            default:
+                break;
+        }
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Demonic Tactics part 2 (pet)
+                amount += level >= 45 ? 10 : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Ferocity
+                if (level >= 20)
+                    amount += 10;
+                //Spider's Bite
+                if (level >= 44)
+                    amount += 9;
+                break;
+            case BOT_CLASS_ARCHMAGE:
+                amount += petOwner->GetCreatureCritChance();
+                break;
+            default:
+                break;
+        }
+        critbonus->ChangeAmount(amount);
+    }
+    //damage done physical
+    if (AuraEffect* physdam = me->GetAuraEffect(DAMAGEDONE_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+                //Empowered Imp part 1
+                amount += level >= 50 ? 30 : 0;
+                break;
+            case BOT_PET_INFERNAL:
+                amount += 100;
+                break;
+            default:
+                break;
+        }
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Unholy Power
+                if (myType != BOT_PET_IMP)
+                    amount += level >= 30 ? 20 : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Hapiness bonus (always happy) + 5% innate
+                amount += 30;
+                //Unleashed Fury
+                if (level >= 20)
+                    amount += 15;
+                //Kindred Spirits
+                if (level >= 55 && Spec() == BOT_SPEC_HUNTER_BEASTMASTERY)
+                    amount += 20;
+                //Spiked Collar
+                if (level >= 32)
+                    amount += 9;
+                //Shark Attack
+                if (level >= 80)
+                    amount += 6;
+                break;
+            default:
+                break;
+        }
+        //Command (Racial)
+        if (petOwner->GetRace() == RACE_ORC)
+            amount += 5;
+        physdam->ChangeAmount(amount);
+    }
+    //damage done magic
+    if (AuraEffect* spelldam = me->GetAuraEffect(DAMAGEDONE_PASSIVE, 1, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+                //Empowered Imp part 1, Master Demonologist part 1.2 (pet), Improved Imp part 1
+                amount += level >= 50 ? 65 : level >= 35 ? 35 : level >= 10 ? 30 : 0;
+                break;
+            case BOT_PET_SUCCUBUS:
+                //Master Demonologist part 3 (pet)
+                amount += level >= 35 ? 5 : 0;
+                break;
+            default:
+                break;
+        }
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Unholy Power
+                if (myType == BOT_PET_IMP)
+                    amount += level >= 30 ? 20 : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Hapiness bonus (always happy) + 5% innate
+                amount += 30;
+                //Unleashed Fury
+                if (level >= 20)
+                    amount += 15;
+                //Kindred Spirits
+                if (level >= 55 && Spec() == BOT_SPEC_HUNTER_BEASTMASTERY)
+                    amount += 20;
+                //Spiked Collar
+                if (level >= 32)
+                    amount += 9;
+                //Shark Attack
+                if (level >= 80)
+                    amount += 6;
+                break;
+            default:
+                break;
+        }
+        //Command (Racial)
+        if (petOwner->GetRace() == RACE_ORC)
+            amount += 5;
+        spelldam->ChangeAmount(amount);
+    }
+    //spell power
+    if (AuraEffect* spelldam = me->GetAuraEffect(SPELLDAMAGE_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_HUNTER:
+                amount += int32(petOwner->GetTotalAttackPowerValue(RANGED_ATTACK) * (level >= 80 ? 0.18f : 0.1287f));
+                break;
+            case BOT_CLASS_WARLOCK:
+                amount += int32(spdtotal * 0.15f);
+                break;
+            case BOT_CLASS_MAGE:
+                amount += int32(spdtotal * 0.4f);
+                break;
+            case BOT_CLASS_ARCHMAGE:
+                amount += int32(spdtotal * 1.0f);
+                break;
+            case BOT_CLASS_DREADLORD:
+                amount += int32(spdtotal * 1.0f);
+                break;
+            default:
+                break;
+        }
+        spelldam->ChangeAmount(amount);
+    }
+    //spell penetration
+    if (AuraEffect* spellpenet = me->GetAuraEffect(SPELLPENETRATION_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = int32(petOwner->GetCreatureSpellPenetration());
+        spellpenet->ChangeAmount(amount);
+    }
+    //haste spell
+    if (AuraEffect* spellhaste = me->GetAuraEffect(SPELLHASTE_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+                //Demonic Power part 2
+                amount += level >= 20 ? 25 : 0;
+                break;
+            case BOT_PET_SUCCUBUS:
+                //Improved Succubus part 1
+                amount += level >= 20 ? 200 : 0;
+                break;
+            case BOT_PET_AWATER_ELEMENTAL:
+                amount += petOwner->GetBotAI()->GetHaste();
+                break;
+            default:
+                break;
+        }
+        spellhaste->ChangeAmount(amount);
+    }
+    //dmgtaken
+    if (AuraEffect* dmgtaken = me->GetAuraEffect(DAMAGETAKEN_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+
+        if (petOwner->GetBotClass() == BOT_CLASS_WARLOCK)
+        {
+            //Demonic Resilience part 2
+            if (level >= 40)
+                amount += 15;
+        }
+        if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+        {
+            //Great Resistance (everything)
+            if (level >= 44)
+                amount += 15;
+        }
+        if (petOwner->GetBotClass() == BOT_CLASS_DREADLORD)
+        {
+            amount += 25;
+        }
+
+        dmgtaken->ChangeAmount(amount);
+    }
+    //hp
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA) - me->GetCreateStat(STAT_STAMINA);
+    switch (petOwner->GetBotClass())
+    {
+        case BOT_CLASS_HUNTER:
+            stamValue += (level >= 80 ? 0.63f : 0.4f) * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_WARLOCK:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DEATH_KNIGHT:
+            switch (myType)
+            {
+                case BOT_PET_GHOUL:
+                    stamValue += 0.88f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+                default:
+                    stamValue += 0.3f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+            }
+            break;
+        case BOT_CLASS_SHAMAN:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_MAGE:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DRUID:
+            stamValue += 0.45f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_ARCHMAGE:
+            stamValue += 2.50f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DREADLORD:
+            stamValue += 2.50f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DARK_RANGER:
+            switch (myType)
+            {
+                case BOT_PET_DARK_MINION_ELITE:
+                    stamValue += 1.0f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+                default:
+                    stamValue += 0.8f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+            }
+            break;
+        default:
+            break;
+    }
+    float stamMult;
+    switch (myType)
+    {
+        case BOT_PET_IMP:        stamMult = 8.4f;  break;
+        case BOT_PET_VOIDWALKER: stamMult = 11.0f; break;
+        case BOT_PET_SUCCUBUS:   stamMult = 9.1f;  break;
+        case BOT_PET_FELHUNTER:  stamMult = 9.5f;  break;
+        case BOT_PET_FELGUARD:   stamMult = 11.0f; break;
+        default:                 stamMult = 10.f;  break;
+    }
+    //stam bonuses
+    if (petOwner->GetBotClass() == BOT_CLASS_WARLOCK)
+    {
+        //Fel Vitality (pet) part 1
+        if (level >= 15)
+            stamValue *= 1.15f;
+        //Glyph of Voidwalker
+        if (myType == BOT_PET_VOIDWALKER && level >= 15)
+            stamValue *= 1.2f;
+    }
+    if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+    {
+        //Endurance Training
+        if (level >= 10)
+            stamValue *= 1.1f;
+        //Greater Stamina
+        if (level >= 20)
+            stamValue *= 1.12f;
+        //Blood of the Rhino part 1
+        if (level >= 32)
+            stamValue *= 1.04f;
+    }
+    //additional: store stat
+    me->SetStat(STAT_STAMINA, int32(stamValue));
+    float m_totalhp = stamValue * stamMult + me->GetCreateHealth() + (/*IAmFree() ? level * 125.f :*/ 0); //+10000/+0 hp at 80
+    //hp bonuses
+    if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+    {
+        //Innate 5%
+        m_totalhp *= 1.05f;
+    }
+    //TC_LOG_ERROR("entities.player", "SetPetStat(): hp stamval %.1f, stammult %.1f, base %u, total %.2f", stamValue, stamMult, botPet->GetCreateHealth(), m_totalhp);
+    bool fullhp = me->GetHealth() == me->GetMaxHealth();
+    float pct = fullhp ? 100.f : me->GetHealthPct(); // needs for regeneration
+    me->SetStatFlatModifier(UNIT_MOD_HEALTH, BASE_VALUE, m_totalhp);
+    me->UpdateMaxHealth();
+    me->SetHealth(fullhp ? me->GetMaxHealth() : uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+    //mana
+    if (me->GetPowerType() == POWER_MANA)
+    {
+        float intValue = me->GetTotalStatValue(STAT_INTELLECT) - me->GetCreateStat(STAT_INTELLECT);
+        intValue += 0.3f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        float intMult;
+        switch (myType)
+        {
+            case BOT_PET_IMP:        intMult = 4.95f; break;
+            case BOT_PET_VOIDWALKER:
+            case BOT_PET_SUCCUBUS:
+            case BOT_PET_FELHUNTER:
+            case BOT_PET_FELGUARD:   intMult = 11.5f; break;
+            default:                 intMult = 15.f;  break;
+        }
+        //int/mana bonuses
+        if (petOwner->GetBotClass() == BOT_CLASS_WARLOCK)
+        {
+            //Fel Vitality (pet) part 2
+            if (level >= 15)
+                intValue *= 1.15f;
+        }
+        //additional: store stat
+        me->SetStat(STAT_INTELLECT, int32(intValue));
+        float m_totalmana = intValue * intMult/* + me->GetCreatePowerValue(POWER_MANA)*/ + (IAmFree() ? level * 25.f : 0); //+2000/+0 mana at 80
+        //TC_LOG_ERROR("entities.player", "SetPetStat(): mana intValue %.1f, intMult %.1f, base %u, total %.2f", intValue, intMult, botPet->GetCreatePowerValue(POWER_MANA), m_totalmana);
+        bool fullmana = me->GetPower(POWER_MANA) == me->GetMaxPower(POWER_MANA);
+        float pct = fullmana ? 100.f : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+        me->SetStatFlatModifier(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
+        me->UpdateMaxPower(POWER_MANA);
+        me->SetPower(POWER_MANA, fullmana ? me->GetMaxPower(POWER_MANA) :
+            uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        if (me->GetPowerType() == POWER_MANA)
+            me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+        else if (me->GetPowerType() == POWER_FOCUS)
+            me->SetPower(POWER_FOCUS, me->GetMaxPower(POWER_FOCUS));
+    }
+}
+//Force pet to start attack anyone who tries to DAMAGE me or owner
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_pet_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+
+    if (!me->IsValidAttackTarget(attacker) || !attacker->isTargetableForAttack() || IsInBotParty(attacker))
+        return;
+
+    SetBotCommandState(BOT_COMMAND_COMBATRESET);
+    me->Attack(attacker, IsPetMelee());
+}
+
+bool bot_pet_ai::IsPetMelee() const
+{
+    return bot_ai::IsPetMelee(myType);
+}
+
+uint8 bot_pet_ai::Spec() const
+{
+    return petOwner->GetBotAI()->GetSpec();
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_pet_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == petOwner->GetBotOwner() || unit == me || unit == petOwner) return true;
+
+    if (IAmFree())
+    {
+        if (me->GetFaction() == 14 || unit->GetFaction() == 14)
+            return false;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) ||
+            unit->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return false;
+
+        return
+            (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->IsPet() || unit->ToCreature()->IsNPCBot() || unit->ToCreature()->IsNPCBotPet()) &&
+            (unit->GetFaction() == me->GetFaction() ||
+            (me->GetReactionTo(unit) >= REP_FRIENDLY && unit->GetReactionTo(me) >= REP_FRIENDLY));
+    }
+
+    //cheap check
+    if (Group const* gr = petOwner->GetBotOwner()->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i] &&
+                !((BotMgr::GetTankTargetIconFlags() | BotMgr::GetDPSTargetIconFlags()) & GroupIconsFlags[i]))
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                    if (guid == unit->GetGUID())
+                        return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        ObjectGuid ownerGuid = unit->GetOwnerGUID();
+        //controlled by master
+        if (ownerGuid == petOwner->GetBotOwner()->GetGUID())
+            return true;
+        //npcbot/npcbot's pet case
+        if (cre->GetBotOwner() == petOwner->GetBotOwner())
+            return true;
+        if (ownerGuid && petOwner->GetBotOwner()->GetBotMgr()->GetBot(ownerGuid))
+            return true;
+        //controlled by group member
+        //pets, minions, guardians etc.
+        //bot pets too
+        if (ownerGuid)
+            if (Group const* gr = petOwner->GetBotOwner()->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/removes/reapplies aura stacks
+void bot_pet_ai::RefreshAura(uint32 spellId, int8 count, Unit* target) const
+{
+    if (count < 0 || count > 10)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::RefreshAura(): count is out of bounds (%i) for bot %s (botclass: %u, entry: %u)",
+            int32(count), me->GetName().c_str(), uint32(petOwner->GetBotClass()), me->GetEntry());
+        return;
+    }
+    if (!spellId)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::RefreshAura(): spellId is 0 for bot %s (botclass: %u, entry: %u)",
+            me->GetName().c_str(), uint32(petOwner->GetBotClass()), me->GetEntry());
+        return;
+    }
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), uint32(petOwner->GetBotClass()), me->GetEntry());
+        return;
+    }
+
+    if (!target)
+        target = me;
+
+    target->RemoveAurasDueToSpell(spellId);
+
+    for (int8 i = 0; i < count; ++i)
+        target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//All code above 'x = _getTarget() call must not dereference opponent since it can be invalid
+Unit* bot_pet_ai::_getTarget(bool &reset) const
+{
+    if (petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return NULL;
+
+    Unit* mytar = me->GetVictim();
+    Unit* u = petOwner->GetVictim();
+
+    if (mytar && me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+        return mytar;
+
+    if (u)
+    {
+        if (opponent && u != opponent)
+            reset = true;
+        return u;
+    }
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : petOwner->GetBotOwner()->GetBotMgr()->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if ((!u || IAmFree()) && petOwner->GetBotOwner()->IsAlive() && (me->GetDistance(petOwner->GetBotOwner()) > foldist ||
+        (IAmFree() && mytar && me->GetDistance(mytar) > followdist) ||
+        (mytar && petOwner->GetBotOwner()->GetDistance(mytar) > followdist / 2 && !mytar->IsWithinLOSInMap(me)) ||
+        (mytar && petOwner->GetBotOwner()->GetDistance(mytar) > foldist && me->GetDistance(petOwner->GetBotOwner()) > foldist)))
+    {
+        return nullptr;
+    }
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && me->IsValidAttackTarget(mytar))
+    {
+        if (me->GetDistance(mytar) > (!IsPetMelee() ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    return nullptr;
+}
+//'CanAttack' function
+//Only called in class ai UpdateAI function
+bool bot_pet_ai::CheckAttackTarget()
+{
+    bool reset = false;
+    opponent = _getTarget(reset);
+
+    if (!opponent)
+    {
+        if (me->GetVictim() || me->IsInCombat())
+        {
+            if (me->GetVictim())
+                me->AttackStop();
+        }
+
+        return false;
+    }
+
+    if (reset)
+        SetBotCommandState(BOT_COMMAND_COMBATRESET);//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, IsPetMelee());
+
+    return true;
+}
+//POSITION
+//Ranged attack position
+void bot_pet_ai::CalculateAttackPos(Unit const* target, Position& pos) const
+{
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : petOwner->GetBotOwner()->GetBotMgr()->GetBotFollowDist();
+    uint8 rangeMode = IAmFree() ? uint8(BOT_ATTACK_RANGE_LONG) : petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode();
+    uint8 exactRange = rangeMode != BOT_ATTACK_RANGE_EXACT || IAmFree() ? 255 : petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange();
+    float x(0),y(0),z(0),
+        dist = (rangeMode == BOT_ATTACK_RANGE_EXACT) ? exactRange :
+        followdist >= 40 ? followdist :
+        5 + urand(followdist/3, followdist/3 + 5)/*18-23 at 40, 15-20 at 30*/,
+        angle = target->GetAbsoluteAngle(me);
+    //most ranged classes have some sort of 20yd spell
+    if (rangeMode != BOT_ATTACK_RANGE_EXACT)
+        dist = std::min<float>(dist, petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS) ? GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG) - 4.f : 30.f);
+
+    float clockwise = (me->GetEntry() % 2) ? 1.f : -1.f;
+    float angleDelta = frand(0.0f, M_PI*0.10f) * clockwise;
+
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, dist, angle);
+        if (!target->IsWithinLOS(x,y,z))
+        {
+            if (rangeMode != BOT_ATTACK_RANGE_EXACT)
+                dist *= i >= 4 ? 0.1f : 0.33f;
+            if (i >= 4)
+                angle += angleDelta;
+        }
+    }
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_pet_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+    if (CCed(me, true) || JumpingOrFalling())
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || me->isMoving()) && !force)
+        return;
+    if (IsCasting())
+        return;
+
+    if (!IAmFree() && petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+        petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange() == 0)
+    {
+        attackpos.m_positionX = newtarget->GetPositionX() - frand(0.5f, 1.5f) * std::cos(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionY = newtarget->GetPositionY() - frand(0.5f, 1.5f) * std::sin(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionZ = newtarget->GetPositionZ();
+        if (me->GetExactDist2d(&attackpos) > 3.5f)
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+        return;
+    }
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : petOwner->GetBotOwner()->GetBotMgr()->GetBotFollowDist();
+    if (!IsPetMelee())
+    {
+        //do not allow constant runaway from player
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3))
+            return;
+
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetExactDist2d(&attackpos) > 4.f || !me->IsWithinLOSInMap(newtarget))
+        {
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+            if (!me->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                me->SetInFront(newtarget);
+        }
+    }
+    else if (!JumpingOrFalling() && ((!me->HasUnitState(UNIT_STATE_CHASE) && !me->isMoving()) || (!me->HasUnitState(UNIT_STATE_CHASE_MOVE) && me->GetDistance(newtarget) > 1.5f)))
+    {
+        //me->BotStopMovement();
+        me->GetMotionMaster()->MoveChase(newtarget);
+    }
+
+    if (newtarget != me->GetVictim())
+    {
+        if (!me->Attack(newtarget, IsPetMelee()))
+            me->SetInFront(newtarget);
+    }
+}
+
+void bot_pet_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        MoveBehind(me->GetVictim());
+
+        if (petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS) &&
+            !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !me->HasAuraType(SPELL_AURA_MOD_INVISIBILITY))
+        {
+            //if (!CCed(me->GetVictim()) || me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+                DoMeleeAttackIfReady();
+        }
+    }
+}
+
+void bot_pet_ai::MoveBehind(Unit const* target) const
+{
+    if (HasBotCommandState(BOT_COMMAND_MASK_UNMOVING)) return;
+    if (!IsPetMelee() || CCed(me, true)) return;
+    if (JumpingOrFalling()) return;
+
+    if (target->GetVictim() != me && !CCed(target) &&
+        target->IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target->HasInArc(M_PI, me))
+    {
+        float x,y,z;
+        target->GetNearPoint(me, x, y, z, me->GetCombatReach(), me->GetAbsoluteAngle(target));
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+        const_cast<bot_pet_ai*>(this)->waitTimer = 500;
+    }
+}
+bool bot_pet_ai::_canRegenerate() const
+{
+    switch (me->GetEntry())
+    {
+        case BOT_PET_DARK_MINION:
+        case BOT_PET_DARK_MINION_ELITE:
+            return false;
+        default:
+            return true;
+    }
+}
+//Health and Powers regeneration
+void bot_pet_ai::Regenerate()
+{
+    regenTimer += lastdiff;
+
+    //every tick
+    if (me->GetPowerType() == POWER_FOCUS)
+        RegeneratePetFocus();
+    else if (me->GetPowerType() == POWER_ENERGY)
+        RegeneratePetEnergy();
+
+    if (regenTimer >= REGEN_CD)
+    {
+        regenTimer -= REGEN_CD;
+
+        // Regen Pet Health
+        if (_canRegenerate() && (!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+        {
+            int32 add = IAmFree() && !me->GetVictim() ? me->GetMaxHealth() / 32 : 20 + me->GetCreateHealth() / 64;
+
+            if (me->IsPolymorphed())
+                add += me->GetMaxHealth() / 6;
+            else if (!me->IsInCombat() || me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+            {
+                if (!me->IsInCombat())
+                {
+                    Unit::AuraEffectList const& mModHealthRegenPct = me->GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
+                    for (Unit::AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
+                        AddPct(add, (*i)->GetAmount());
+
+                    add += me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * REGEN_CD / 5000;
+                }
+                else if (me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+                    ApplyPct(add, me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));
+            }
+
+            add += me->GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
+
+            if (add < 0)
+                add = 0;
+
+            me->ModifyHealth(add);
+        }
+        // Regen Pet Mana (use bot's regen rate) warlock only
+        if (me->GetPowerType() == POWER_MANA && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+        {
+            float addvalue;
+            if (me->IsUnderLastManaUseEffect())
+                addvalue = petOwner->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER);
+            else
+                addvalue = petOwner->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+
+            addvalue *= sWorld->getRate(RATE_POWER_MANA) * REGEN_CD * 0.001f; //regenTimer threshold / 1000
+            if (addvalue < 0.0f)
+                addvalue = 0.0f;
+
+            me->ModifyPower(POWER_MANA, int32(addvalue));
+        }
+    }
+}
+
+void bot_pet_ai::RegeneratePetFocus()
+{
+    uint32 curValue = me->GetPower(POWER_FOCUS);
+    uint32 maxValue = me->GetMaxPower(POWER_FOCUS);
+
+    // Regen Pet Focus
+    if (curValue < maxValue)
+    {
+        float addvalue = 0.005f * lastdiff * sWorld->getRate(RATE_POWER_FOCUS); //5 per sec
+
+        //Bestial Discipline
+        if (petOwner->GetLevel() >= 30)
+            addvalue *= 2;
+
+        addvalue += _energyFraction;
+
+        if (addvalue == 0x0) //only if world rate for focus is 0
+            return;
+
+        uint32 integerValue = uint32(fabs(addvalue));
+
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            _energyFraction = 0.f;
+        }
+        else
+            _energyFraction = addvalue - float(integerValue);
+
+        if (curValue == maxValue || regenTimer >= REGEN_CD)
+            me->SetPower(POWER_FOCUS, curValue);
+        else
+            me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_FOCUS, curValue);
+    }
+}
+
+void bot_pet_ai::RegeneratePetEnergy()
+{
+    uint32 curValue = me->GetPower(POWER_ENERGY);
+    uint32 maxValue = me->GetMaxPower(POWER_ENERGY);
+
+    if (curValue < maxValue)
+    {
+        float addvalue = 0.01f * lastdiff * sWorld->getRate(RATE_POWER_ENERGY); //10 per sec
+
+        if (addvalue == 0x0) //only if world rate for enegy is 0
+            return;
+
+        addvalue += _energyFraction;
+
+        uint32 integerValue = uint32(fabs(addvalue));
+
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            _energyFraction = 0.f;
+        }
+        else
+            _energyFraction = addvalue - float(integerValue);
+
+        if (curValue == maxValue || regenTimer >= REGEN_CD)
+            me->SetPower(POWER_ENERGY, curValue);
+        else
+            me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_ENERGY, curValue);
+    }
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spellId of max rank allowed for given caster
+//If you want bot to use this spell through doCast() go InitSpellMap(uint32) instead
+uint32 bot_pet_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->GetLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, puts spell of max rank allowed for given caster in spellmap
+void bot_pet_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->GetLevel();
+    uint32 spellId = forceadd ? basespell : 0;
+
+    while (info != nullptr && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotPetSpell* newSpell = _spells[basespell];
+    if (!newSpell)
+    {
+        newSpell = new BotPetSpell();
+        _spells[basespell] = newSpell;
+    }
+
+    newSpell->spellId = spellId;
+}
+//Using first-rank spell as source, return current spell id
+uint32 bot_pet_ai::GetSpell(uint32 basespell) const
+{
+    BotPetSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() && (itr->second->enabled == true || IAmFree()) ? itr->second->spellId : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_pet_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotPetSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() ? itr->second->cooldown : 0;
+}
+bool bot_pet_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD) const
+{
+    if (checkGCD && GC_Timer > diff)
+        return false;
+
+    BotPetSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr == _spells.end() ? true :
+        ((itr->second->enabled == true || IAmFree()) && itr->second->spellId != 0 && itr->second->cooldown <= diff);
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_pet_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotPetSpellMap::iterator itr = _spells.find(basespell);
+    if (itr != _spells.end())
+    {
+        itr->second->cooldown = msCooldown;
+        return;
+    }
+    else if (!msCooldown)
+        return;
+
+    InitSpellMap(basespell, true, false);
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_pet_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotPetSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->first == spellInfo->Id && itr->second->cooldown >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (info && itr->first == spellInfo->Id && info->GetCategory() != category)
+        {
+            TC_LOG_ERROR("scripts", "Warning: SetSpellCategoryCooldown: %s (%u) has baseId %u but category %u, not %u!",
+                info->SpellName[0], info->Id, itr->first, info->GetCategory(), category);
+        }
+
+        if (info && (info->GetCategory() == category || itr->first == spellInfo->Id) && itr->second->cooldown < msCooldown)
+            itr->second->cooldown = msCooldown;
+    }
+}
+//Handles spell cooldowns for spell with IsCooldownStartedOnEvent() == true
+void bot_pet_ai::ReleaseSpellCooldown(uint32 basespell)
+{
+    SpellInfo const* baseInfo = sSpellMgr->GetSpellInfo(basespell);
+
+    if (!baseInfo->IsCooldownStartedOnEvent())
+    {
+        TC_LOG_ERROR("spells", "bot_pet_ai::ReleaseSpellCooldown is called for wrong spell %u!", basespell);
+        return;
+    }
+
+    uint32 rec = baseInfo->RecoveryTime;
+    uint32 catrec = baseInfo->CategoryRecoveryTime;
+
+    SetSpellCooldown(baseInfo->Id, rec > 0 ? rec : 0);
+    SetSpellCategoryCooldown(baseInfo, catrec > 0 && !(baseInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS) ? catrec : 0);
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_pet_ai::RemoveSpell(uint32 basespell)
+{
+    BotPetSpell* newSpell;
+    BotPetSpellMap::iterator itr = _spells.find(basespell);
+    if (itr == _spells.end())
+    {
+        newSpell = new BotPetSpell();
+        _spells[basespell] = newSpell;
+    }
+    else
+        newSpell = itr->second;
+
+    newSpell->spellId = 0;
+    newSpell->cooldown = 0;
+}
+//See CommonTimers(uint32)
+void bot_pet_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotPetSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        if (itr->second->cooldown >= diff)
+            itr->second->cooldown -= diff;
+        else if (itr->second->cooldown > 0)
+            itr->second->cooldown = 0;
+    }
+}
+//Bots cannot dodge/parry from behind so try to condense enemies at front
+//opponent is always valid
+void bot_pet_ai::AdjustTankingPosition() const
+{
+    if (/*!IsTank() || */!me->IsInCombat() || IsCasting() ||
+        JumpingOrFalling() || CCed(me, true) || Rand() > 10 + 20*me->GetMap()->IsDungeon() ||
+        HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+
+    Unit::AttackerSet const& myattackers = me->getAttackers();
+    if (myattackers.size() < 2)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition() by %s", me->GetName().c_str());
+
+    uint32 bCount = 0;
+    for (Unit::AttackerSet::const_iterator itr = myattackers.begin(); itr != myattackers.end(); ++itr)
+    {
+        if (/*!CCed(*itr) && */(*itr)->GetDistance(me) < 5 && !me->HasInArc(M_PI, *itr))
+            ++bCount;
+            //if (++bCount)
+            //    break;
+    }
+
+    if (bCount == 0)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition(): atts %u, behind %u", uint32(myattackers.size()), bCount);
+
+    //calculate new position
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float ori = me->GetOrientation();
+    float const moveDist = -1.f * std::max<float>(opponent->GetCombatReach() * 0.6f, 3.f);
+    float moveX;
+    float moveY;
+    for (uint8 i = 0; i != 3; ++i)
+    {
+        if (i)
+        {
+            ori = Position::NormalizeOrientation(ori + (i+1)*(M_PI*0.5f));
+        }
+
+        //move back
+        moveX = moveDist * std::cos(ori);
+        moveY = moveDist * std::sin(ori);
+
+        if (me->IsWithinLOS(x+moveX, y+moveY, z))
+            break;
+
+        if (i == 2)
+        {
+            moveX *= 0.2f;
+            moveY *= 0.2f;
+        }
+    }
+
+    x+= moveX;
+    y+= moveY;
+
+    me->UpdateAllowedPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.75f; //prevent going underground
+
+    //if (CCed(opponent, true))
+    //    me->AttackStop();
+    //me->SetOrientation(ori);
+    me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+}
+//SpellHit()... OnSpellHit()
+void bot_pet_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    //uint32 const spellId = spell->Id;
+
+    if (spell->HasAura(SPELL_AURA_MOD_TAUNT) || spell->HasEffect(SPELL_EFFECT_ATTACK_ME))
+        if (caster && me->Attack(caster, true))
+            me->GetMotionMaster()->MoveChase(caster);
+
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 const auraname = spell->Effects[i].ApplyAuraName;
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT ||
+            auraname == SPELL_AURA_MOD_RATING || auraname == SPELL_AURA_MOD_RATING_FROM_STAT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+            auraname == SPELL_AURA_230 ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+            shouldUpdateStats = true;
+    }
+
+    if (!me->GetVictim() && (me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        if (me->CanSeeOrDetect(caster) && (caster->IsInCombat() || me->IsInCombat() || petOwner->IsInCombat()))
+            petOwner->GetBotAI()->OwnerAttackedBy(caster);
+    }
+}
+//Update delay
+//Skip UpdateAI cycles for randomization of bots' reaction and performance adjustments
+bool bot_pet_ai::Wait()
+{
+    if (waitTimer > lastdiff)
+        return true;
+
+    if (IAmFree())
+        waitTimer = me->IsInCombat() ? 500 : urand(750, 1250);
+    else if (!me->GetMap()->IsRaid())
+        waitTimer = std::min<uint32>(uint32(50 * (petOwner->GetBotOwner()->GetNpcBotsCount() - 1) + __rand + __rand), 500);
+    else
+        waitTimer = __rand;
+
+    return false;
+}
+//Spell Mod Hooks
+void bot_pet_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    //DAMAGE SPELLS damage bonus (DMG_CLASS_MAGIC)
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+//Spell Mod Utilities
+float bot_pet_ai::CalcSpellMaxRange(uint32 spellId, bool enemy) const
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    ASSERT(spellInfo);
+
+    return spellInfo->GetMaxRange(!enemy);
+}
+bool bot_pet_ai::IAmFree() const
+{
+    return petOwner->IsFreeBot();
+}
+
+bool bot_pet_ai::CCed(Unit const* target, bool root)
+{
+    return bot_ai::CCed(target, root);
+}
+
+bool bot_pet_ai::IsTank(Unit const* unit) const
+{
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+    else if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINTANK;
+            }
+        }
+    }
+
+    return false;
+}
+
+void bot_pet_ai::OnStartAttack(Unit const* /*u*/)
+{
+    AdjustTankingPosition();
+}
+
+bool bot_pet_ai::StartAttack(Unit const* u, bool force)
+{
+    if (HasBotCommandState(BOT_COMMAND_ATTACK) && !force)
+        return false;
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    OnStartAttack(u);
+    return true;
+}
+
+void bot_pet_ai::JustDied(Unit*)
+{
+    KillEvents(false);
+}
+
+void bot_pet_ai::AttackStart(Unit* /*u*/)
+{
+}
+
+void bot_pet_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+    {
+        if (Creature* cre = victim->ToCreature())
+        {
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(petOwner->GetBotOwner());
+
+            //controlled case is handled in Unit::DealDamage
+            if (IAmFree())
+                cre->LowerPlayerDamageReq(cre->GetHealth() < damage ?  cre->GetHealth() : damage);
+        }
+    }
+}
+
+void bot_pet_ai::IsSummonedBy(WorldObject* summoner)
+{
+    //TC_LOG_ERROR("entities.unit", "bot_pet_ai::IsSummonedBy for %s by %s", me->GetName().c_str(), summoner->GetName().c_str());
+    //ASSERT(!petOwner);
+    //ASSERT(summoner->GetTypeId() == TYPEID_UNIT);
+    petOwner = summoner->ToCreature();
+    m_botCommandState = petOwner->GetBotAI()->GetBotCommandState();
+    myType = me->GetEntry();
+    //myType = petOwner->GetBotAI()->GetAIMiscValue(BOTAI_MISC_PET_TYPE);
+    //ASSERT(myType);
+    ASSERT(!me->GetBotAI());
+    ASSERT(!me->GetBotPetAI());
+    me->SetBotPetAI(this);
+    SetPetStats(true);
+}
+//This function is called after Spell::SendSpellCooldown() and Spell::DoAllEffects...() call
+void bot_pet_ai::OnBotPetSpellGo(Spell const* spell)
+{
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+
+    //Set cooldown
+    if (!curInfo->IsCooldownStartedOnEvent() && !curInfo->IsPassive())
+    {
+        uint32 rec = curInfo->RecoveryTime;
+        uint32 catrec = curInfo->CategoryRecoveryTime;
+
+        SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+        SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+    }
+
+    if ((!curInfo->CastTimeEntry || !curInfo->CastTimeEntry->Base) &&
+        curInfo->StartRecoveryTime)
+    {
+        GC_Timer = curInfo->StartRecoveryTime;
+        GC_Timer = std::max<uint32>(GC_Timer, 1000);
+        GC_Timer = std::min<uint32>(GC_Timer, 1500);
+    }
+
+    OnPetClassSpellGo(curInfo);
+}
+
+void bot_pet_ai::OnBotPetSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotPetSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        itr->second->cooldown += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotPetSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+
+    GC_Timer = 0; //reset global cooldown since cast is canceled
+}
+//GLOBAL UPDATE
+//opponent unsafe
+bool bot_pet_ai::GlobalUpdate(uint32 diff)
+{
+    if (!petOwner)
+    {
+        TC_LOG_ERROR("entities.unit", "botpet:GlobalUpdate(): no owner!");
+        return false;
+    }
+
+    ReduceCD(diff);
+
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+        if (!IAmFree())
+        {
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != petOwner->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, petOwner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    //Check current cast state: interrupt casts that became pointless
+    if (me->HasUnitState(UNIT_STATE_CASTING) && urand(1,100) <= 75)
+    {
+        bool interrupt;
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+        {
+            interrupt = false;
+            Spell const* spell = me->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+            Unit const* target = spell->m_targets.GetUnitTarget();
+            if (!target)
+                continue;
+            SpellInfo const* info = spell->GetSpellInfo();
+            if (!info->CastTimeEntry)
+                continue;
+            if (!info->IsPositive())
+            {
+                if (!target->IsAlive())
+                    interrupt = true;
+                //control interruptions should be checked inside pet class ai
+                //else if ((info->Mechanic == MECHANIC_POLYMORPH || info->Mechanic == MECHANIC_SHACKLE ||
+                //    info->Mechanic == MECHANIC_DISORIENTED || info->Mechanic == MECHANIC_SLEEP ||
+                //    info->Mechanic == MECHANIC_CHARM || info->Mechanic == MECHANIC_BANISH ||
+                //    info->Mechanic == MECHANIC_STUN || info->Mechanic == MECHANIC_FREEZE) &&
+                //    !target->getAttackers().empty() && !IsCasting(target))
+                //    interrupt = true; //useless control
+                else if (target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !IsCasting(target) &&
+                    (info->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+                    interrupt = true; //useless control breaks immediately
+            }
+
+            if (interrupt)
+            {
+                me->InterruptSpell(CurrentSpellTypes(i));
+                GC_Timer = 0;
+                break;
+            }
+        }
+    }
+
+    if (_updateTimerEx1 <= diff && !IAmFree())
+    {
+        _updateTimerEx1 = urand(2000, 2500);
+
+        //Ex1-timed updates
+
+        //DEBUG
+        /*
+        Sometimes bots are affected by zone (instance) scripts
+        Good example is CoT: Battle for Mount Hyjal
+        */
+        //Faction
+        //ensure master is not controlled
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(petOwner->GetBotOwner()->GetRace());
+        uint32 fac = rEntry ? rEntry->FactionID : 0;
+        if (me->GetFaction() != petOwner->GetBotOwner()->GetFaction() && petOwner->GetBotOwner()->GetFaction() == fac)
+        {
+            //std::ostringstream msg;
+            //msg << "Something changed my faction (now " << me->GetFaction() << "), changing back to " << fac << "!";
+            //BotWhisper(msg.str().c_str());
+            me->SetFaction(fac);
+        }
+        //Visibility
+        if (!me->IsVisible() && petOwner->GetBotOwner()->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making visible...");
+            me->SetVisible(true);
+        }
+        if (me->IsVisible() && !petOwner->GetBotOwner()->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making invisible...");
+            me->SetVisible(false);
+        }
+        //Phase
+        if (me->GetPhaseMask() != petOwner->GetBotOwner()->GetPhaseMask())
+        {
+            //BotWhisper("Somehow we are not is same phase! Fixing that...");
+            me->SetPhaseMask(petOwner->GetBotOwner()->GetPhaseMask(), true);
+        }
+        //end DEBUG
+    }
+
+    Regenerate();
+
+    //update flags
+    if (!me->IsInCombat())
+    {
+        if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT))
+            me->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PET_IN_COMBAT);
+    }
+
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return false;
+
+    if (HasBotCommandState(BOT_COMMAND_STAY) && !petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_STAY))
+        RemoveBotCommandState(BOT_COMMAND_STAY);
+
+    CheckAttackState();
+
+    if (checkAurasTimer <= lastdiff)
+    {
+        Unit* victim = me->GetVictim();
+        checkAurasTimer += uint32(__rand + __rand + (IAmFree() ? 1000 : 40 * (1 + petOwner->GetBotOwner()->GetNpcBotsCount())));
+
+        if (!HasBotCommandState(BOT_COMMAND_MASK_UNCHASE) && victim && !CCed(me, true) &&
+            !me->isMoving() && !IsCasting())
+        {
+            if (!IAmFree() && petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+                petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange() == 0)
+            {
+                GetInPosition(true, victim);
+            }
+            else if (IsPetMelee())
+            {
+                if (me->GetDistance(victim) > 1.5f)
+                    GetInPosition(true, victim);
+            }
+            else
+            {
+                CalculateAttackPos(victim, attackpos);
+                if (me->GetExactDist2d(&attackpos) > 4.f || !me->IsWithinLOSInMap(victim))
+                    GetInPosition(true, victim, &attackpos);
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == petOwner->GetBotOwner()->GetPhaseMask())
+            SetPetStats(false);
+    }
+
+    if (Wait())
+        return false;
+
+    if (CCed(me))
+        return false;
+
+    GenerateRand();
+
+    bool closeToOwner = false;
+    if (!opponent && !HasBotCommandState(BOT_COMMAND_STAY))
+    {
+        if (!IsCasting())
+        {
+            _calculatePos(pos);
+            if (!petOwner->isMoving())
+            {
+                if (me->GetExactDist(&pos) > 5.f)
+                    SetBotCommandState(BOT_COMMAND_FOLLOW, true, &pos);
+                else
+                    closeToOwner = true;
+            }
+            else
+            {
+                Position destPos;
+                me->GetMotionMaster()->GetDestination(destPos.m_positionX, destPos.m_positionY, destPos.m_positionZ);
+                if (destPos.GetExactDist(&pos) > 5.f)
+                    SetBotCommandState(BOT_COMMAND_FOLLOW, true, &pos);
+                else
+                    closeToOwner = true;
+            }
+        }
+    }
+
+    if (closeToOwner || me->IsInCombat())
+    {
+        uint8 st = (petOwner->GetBotAI()->GetBotCommandState() & BOT_COMMAND_MASK_UNMOVING);
+        if (st && GetBotCommandState() != st)
+        {
+            SetBotCommandState(st);
+            return !(st & BOT_COMMAND_FULLSTOP);
+        }
+    }
+
+    return true;
+}
+
+void bot_pet_ai::CommonTimers(uint32 diff)
+{
+    //_petEvents.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (checkAurasTimer > diff)     checkAurasTimer -= diff;
+    if (waitTimer > diff)           waitTimer -= diff;
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+    if (_updateTimerEx1 > diff)     _updateTimerEx1 -= diff;
+}
+
+void bot_pet_ai::KillEvents(bool /*force*/)
+{
+    //_petEvents.KillAllEvents(force);
+}
diff --git a/src/server/game/AI/NpcBots/bpet_ai.h b/src/server/game/AI/NpcBots/bpet_ai.h
new file mode 100644
index 0000000..ab79a33
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_ai.h
@@ -0,0 +1,165 @@
+#ifndef _BOT_PET_AI_H
+#define _BOT_PET_AI_H
+
+#include "CreatureAI.h"
+/*
+NpcBot Pet System by Trickerer (onlysuffering@gmail.com)
+*/
+
+class bot_pet_ai : public CreatureAI
+{
+    public:
+        virtual ~bot_pet_ai();
+
+        bool canUpdate;
+
+        void InitializeAI() override { Reset(); }
+        void Reset() override {}
+
+        void JustDied(Unit*) override;
+        //virtual void KilledUnit(Unit* u);
+        void AttackStart(Unit* u);
+        //virtual void JustEnteredCombat(Unit* u) override;
+        void MoveInLineOfSight(Unit* /*u*/) override {}
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override;
+        void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/) override { }
+        //void ReceiveEmote(Player* player, uint32 emote);
+        uint32 GetData(uint32 data) const override;
+        void IsSummonedBy(WorldObject* summoner) override;
+
+        Creature* GetPetsOwner() const { return petOwner; }
+
+        //EventProcessor* GetEvents() { return &_petEvents; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        void CommonTimers(uint32 diff);
+        void KillEvents(bool force);
+        void SetBotCommandState(uint8 st, bool force = false, Position* newpos = nullptr);
+        void RemoveBotCommandState(uint8 st);
+        bool HasBotCommandState(uint8 st) const { return (m_botCommandState & st); }
+        uint8 GetBotCommandState() const { return m_botCommandState; }
+        bool IsInBotParty(Unit const* unit) const;
+        bool IsTank(Unit const* unit) const;
+        bool IAmFree() const;
+
+        static bool CCed(Unit const* target, bool root = false);
+
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+
+        //virtual uint32 GetAIMiscValue(uint32 /*data*/) const { return 0; }
+        //virtual void SetAIMiscValue(uint32 /*data*/, uint32 /*value*/) {}
+
+        void OnBotPetSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        void OnBotPetSpellGo(Spell const* spell);
+        virtual void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) {}
+
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+        void ReleaseSpellCooldown(uint32 basespell);
+
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+
+    protected:
+        explicit bot_pet_ai(Creature* creature);
+
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+
+        virtual void ReduceCD(uint32 /*diff*/) {}
+        bool GlobalUpdate(uint32 diff);
+
+        void CureGroup(uint32 cureSpell, uint32 diff);
+        void SetPetStats(bool force);
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        bool IsPetMelee() const;
+        uint8 Spec() const;
+
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+
+        void RefreshAura(uint32 spellId, int8 count = 1, Unit* target = nullptr) const;
+        bool CheckAttackTarget();
+        void MoveBehind(Unit const* target) const;
+
+        void AdjustTankingPosition() const;
+        void OnStartAttack(Unit const* /*u*/);
+        bool StartAttack(Unit const* u, bool force = false);
+
+        inline bool IsChanneling(Unit const* u = nullptr) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit const* u = nullptr) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true, false, false)); }
+        inline bool JumpingFlyingOrFalling() const { return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW); }
+        inline bool JumpingOrFalling() const { return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_FALLING_SLOW); }
+        inline bool Jumping() const { return me->HasUnitState(UNIT_STATE_JUMPING); }
+
+        float CalcSpellMaxRange(uint32 spellId, bool enemy = true) const;
+        void CalculateAttackPos(Unit const* target, Position &pos) const;
+        void GetInPosition(bool force, Unit* newtarget, Position* pos = nullptr);
+        virtual float GetSpellAttackRange(bool longRange) const { return longRange ? 25.f : 15.f; }
+        void CheckAttackState();
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+
+        void CheckAuras(bool force = false);
+        virtual void InitPetSpells() {}
+        virtual void ApplyPetPassives() const {}
+
+        void Regenerate();
+        void RegeneratePetFocus();
+        void RegeneratePetEnergy();
+
+        bool Wait();
+        uint16 Rand() const;
+        void GenerateRand() const;
+
+        static inline uint32 GetLostHP(Unit const* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit const* u) { if (!u || !u->IsAlive() || u->GetMaxHealth() <= 1) return 100; return uint8(((float(u->GetHealth()))/u->GetMaxHealth()) * 100); }
+        static inline uint8 GetManaPCT(Unit const* u) { if (!u || !u->IsAlive() || u->GetMaxPower(POWER_MANA) <= 1) return 100; return (u->GetPower(POWER_MANA)*10/(1 + u->GetMaxPower(POWER_MANA)/10)); }
+
+        Unit* opponent;
+        Creature* petOwner;
+        //EventProcessor _petEvents;
+        uint32 GC_Timer;
+        uint32 myType;
+
+    private:
+        bool _canCureTarget(Unit const* target, uint32 cureSpell) const;
+        void _getBotDispellableAuraList(Unit const* target, Unit const* caster, uint32 dispelMask, std::list<Aura const*> &dispelList) const;
+        void _calculatePos(Position& pos) const;
+
+        bool _canRegenerate() const;
+
+        Unit* _getTarget(bool &reset) const;
+        bool _checkImmunities(Unit const* target, SpellInfo const* spellInfo) const;
+        static inline float _getAttackDistance(float distance) { return distance*0.72f; }
+
+        Position pos, attackpos;
+        uint8 m_botCommandState;
+
+        //timers
+        uint32 lastdiff, checkAurasTimer, waitTimer, regenTimer, _updateTimerMedium, _updateTimerEx1;
+
+        float _energyFraction;
+
+        bool shouldUpdateStats;
+
+        struct BotPetSpell
+        {
+            explicit BotPetSpell() : cooldown(0), enabled(true) {}
+            uint32 spellId;
+            uint32 cooldown;
+            bool enabled;
+        private:
+            BotPetSpell(BotPetSpell const&);
+        };
+
+        typedef std::unordered_map<uint32 /*firstrankspellid*/, BotPetSpell* /*spell*/> BotPetSpellMap;
+        BotPetSpellMap const& GetSpellMap() const { return _spells; }
+        BotPetSpellMap _spells;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bpet_archmage.cpp b/src/server/game/AI/NpcBots/bpet_archmage.cpp
new file mode 100644
index 0000000..3ef0fda
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_archmage.cpp
@@ -0,0 +1,139 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+/*
+Archmage NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum ArchmagePetBaseSpells
+{
+    WATERBOLT_1             = SPELL_WATERBOLT
+};
+
+enum ArchmagePetSpecial
+{
+};
+
+class archmage_pet_bot : public CreatureScript
+{
+public:
+    archmage_pet_bot() : CreatureScript("archmage_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new awater_elemental_botpetAI(creature);
+    }
+
+    struct awater_elemental_botpetAI : public bot_pet_ai
+    {
+        awater_elemental_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(WATERBOLT_1, diff) && me->GetDistance(opponent) < 30)
+            {
+                me->CastSpell(opponent, GetSpell(WATERBOLT_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(WATERBOLT_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+    };
+};
+
+void AddSC_archmage_bot_pets()
+{
+    new archmage_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_dark_ranger.cpp b/src/server/game/AI/NpcBots/bpet_dark_ranger.cpp
new file mode 100644
index 0000000..2c1d27b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_dark_ranger.cpp
@@ -0,0 +1,213 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Dark Ranger NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Notes:
+Extra abilities. For the sake of defending the owner added Taunt. For self defense added Blocking (block value unchanged)
+Both abilities are one-time use
+Complete - 100%
+TODO:
+*/
+
+enum DarkRangerPetBaseSpells
+{
+    BLOCKING_1                          = 3248,
+    TAUNT_1                             = 37548
+};
+enum DarkRangerPetPassives
+{
+};
+enum DarkRangerPetSpecial
+{
+    SPELL_GENERATE_THREAT               = 23604, //reduce threat
+    THREAT_BASE                         = 5,
+    MINION_DURATION                     = 80000
+};
+
+class dark_ranger_pet_bot : public CreatureScript
+{
+public:
+    dark_ranger_pet_bot() : CreatureScript("dark_ranger_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new dark_ranger_botpetAI(creature);
+    }
+
+    struct dark_ranger_botpetAI : public bot_pet_ai
+    {
+        dark_ranger_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(1000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+            //if (threatGenTimer < diff)
+            //{
+            //    threatGenTimer = 1500;
+            //    int32 threat = THREAT_BASE;
+            //    CastSpellExtraArgs args(true);
+            //    args.AddSpellBP0(threat);
+            //    me->CastSpell(me, SPELL_GENERATE_THREAT, args);
+            //}
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= MINION_DURATION)
+            {
+                canUpdate = false;
+                me->setDeathState(JUST_DIED);
+                me->ToTempSummon()->UnSummon(1000);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (IsSpellReady(TAUNT_1, diff, false) && Rand() < 50 &&
+                ((opponent->GetVictim() == petOwner && !IsTank(petOwner)) ||
+                (opponent->GetVictim() == petOwner->GetBotOwner() && !IsTank(petOwner->GetBotOwner()))) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(TAUNT_1), false);
+                SetSpellCooldown(TAUNT_1, std::numeric_limits<uint32>::max());
+                return;
+            }
+
+            if (IsSpellReady(BLOCKING_1, diff) && !me->getAttackers().empty() && Rand() < 40)
+            {
+                me->CastSpell(me, GetSpell(BLOCKING_1), true);
+                SetSpellCooldown(BLOCKING_1, 20000);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint32 GetData(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTPETAI_MISC_DURATION:
+                    return liveTimer;
+                case BOTPETAI_MISC_MAXLEVEL:
+                    return maxlevel;
+                default:
+                    return bot_pet_ai::GetData(data);
+            }
+        }
+
+        void SetData(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTPETAI_MISC_MAXLEVEL:
+                    maxlevel = uint8(value);
+                    SetPetStats(true);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+            maxlevel = 1;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(TAUNT_1, true, false);
+            InitSpellMap(BLOCKING_1, true, false);
+        }
+
+        void ApplyPetPassives() const override
+        {
+
+            if (me->GetEntry() == BOT_PET_DARK_MINION_ELITE)
+                RefreshAura(SPELL_VERTEX_COLOR_BLACK);
+            else if (me->GetEntry() == BOT_PET_DARK_MINION)
+                RefreshAura(SPELL_VERTEX_COLOR_GREY);
+        }
+
+    private:
+        uint32 liveTimer;
+        uint8 maxlevel;
+    };
+};
+
+void AddSC_dark_ranger_bot_pets()
+{
+    new dark_ranger_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_death_knight.cpp b/src/server/game/AI/NpcBots/bpet_death_knight.cpp
new file mode 100644
index 0000000..02c6013
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_death_knight.cpp
@@ -0,0 +1,191 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Deathknight NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 25%
+TODO: Garg, AOD, DRW
+*/
+enum DeathknightPetBaseSpells
+{
+    CLAW_1                              = 47468, //150% damage, 40 cost
+    GNAW_1                              = 47481, //12% damage, stun 3 sec, 30 cost
+    LEAP_1                              = 47482, //jump beh tar, 10 cost
+    HUDDLE_1                            = 47484  //mini-shwall, channeled, 10 sec, 10 cost
+};
+
+enum DeathknightPetPassives
+{
+    AVOIDANCE                           = 62137
+};
+
+enum DeathknightPetSpecial
+{
+    GHOUL_FRENZY_1                      = 63560 //player-on-pet spell
+};
+
+class deathknight_pet_bot : public CreatureScript
+{
+public:
+    deathknight_pet_bot() : CreatureScript("deathknight_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new deathknight_botpetAI(creature);
+    }
+
+    struct deathknight_botpetAI : public bot_pet_ai
+    {
+        deathknight_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            //Unit const* u = opponent->GetVictim();
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (myType == BOT_PET_GHOUL)
+            {
+                if (IsSpellReady(GHOUL_FRENZY_1, diff) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    RefreshAura(GHOUL_FRENZY_1);
+                    SetSpellCooldown(GHOUL_FRENZY_1, 30000);
+                }
+
+                uint32 const energy = me->GetPower(POWER_ENERGY);
+
+                if (IsSpellReady(HUDDLE_1, diff) && energy >= 10 && dist < 7 &&
+                    !me->getAttackers().empty() && GetHealthPCT(me) < 70)
+                {
+                    me->CastSpell(me, GetSpell(HUDDLE_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(LEAP_1, diff) && energy >= 10 &&
+                    !HasBotCommandState(BOT_COMMAND_STAY) &&
+                    !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                    dist > 5 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(LEAP_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(GNAW_1, diff) && canDPS && energy >= 30 &&
+                    me->IsWithinMeleeRange(opponent) && opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(GNAW_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(CLAW_1, diff) && canDPS && energy >= 40 && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(CLAW_1), false);
+                    return;
+                }
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(CLAW_1);
+            InitSpellMap(GNAW_1);
+            InitSpellMap(LEAP_1);
+            InitSpellMap(HUDDLE_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            if (myType == BOT_PET_GHOUL/* || myType == BOT_PET_AOD_GHOUL*/)
+                RefreshAura(AVOIDANCE);
+        }
+
+    private:
+    };
+};
+
+void AddSC_deathknight_bot_pets()
+{
+    new deathknight_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_dreadlord.cpp b/src/server/game/AI/NpcBots/bpet_dreadlord.cpp
new file mode 100644
index 0000000..40e8918
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_dreadlord.cpp
@@ -0,0 +1,163 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Dreadlord NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum DreadlordPetBaseSpells
+{
+};
+
+enum DreadlordPetPassives
+{
+};
+
+enum DreadlordPetSpecial
+{
+    IMMOLATION_DAMAGE       = 35959,
+
+    INFERNAL_DURATION       = 180000 - 2000 //3 min
+};
+
+class dreadlord_pet_bot : public CreatureScript
+{
+public:
+    dreadlord_pet_bot() : CreatureScript("dreadlord_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new dreadlord_botpetAI(creature);
+    }
+
+    struct dreadlord_botpetAI : public bot_pet_ai
+    {
+        dreadlord_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            //infernal death & unsummon
+            if ((liveTimer += diff) >= INFERNAL_DURATION)
+            {
+                canUpdate = false;
+                me->setDeathState(JUST_DIED);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsPetMelee());
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float fdamage = float(damage);
+
+            float pctbonus = 1.0f;
+            pctbonus *= 0.5f;
+
+            if (baseId == IMMOLATION_DAMAGE)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_dreadlord_bot_pets()
+{
+    new dreadlord_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_druid.cpp b/src/server/game/AI/NpcBots/bpet_druid.cpp
new file mode 100644
index 0000000..10a00bf
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_druid.cpp
@@ -0,0 +1,146 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Druid NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum DruidPetBaseSpells
+{
+};
+
+enum DruidPetPassives
+{
+};
+
+enum DruidPetSpecial
+{
+    TREANT_DURATION         = 30000
+};
+
+class druid_pet_bot : public CreatureScript
+{
+public:
+    druid_pet_bot() : CreatureScript("druid_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new druid_botpetAI(creature);
+    }
+
+    struct druid_botpetAI : public bot_pet_ai
+    {
+        druid_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(5000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= TREANT_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsPetMelee());
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_druid_bot_pets()
+{
+    new druid_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_hunter.cpp b/src/server/game/AI/NpcBots/bpet_hunter.cpp
new file mode 100644
index 0000000..6fd3f06
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_hunter.cpp
@@ -0,0 +1,1000 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Map.h"
+#include "ScriptMgr.h"
+#include "SpellMgr.h"
+#include "Player.h"
+/*
+Hunter NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+//talent tiers 20-32-44-56-68-80
+enum HunterPetBaseSpells
+{
+    //common
+    GROWL_1                             = 2649,//1
+    COWER_1                             = 1742,//20
+    //semi-common
+    //attack
+    BITE_1                              = 17253,//1 cost 25, Bat, Boar, Carrion Bird, Chimaera, Core Hound, Crocolisk, Devilsaur, Dragonhawk, Hyena, Nether Ray, Ravager, Serpent, Wolf, Worm
+    CLAW_1                              = 16827,//1 cost 25, Bear, Bird of Prey, Cat, Crab, Raptor, Scorpid, Silithid, Spirit Beast, Tallstrider
+    SMACK_1                             = 49966,//1 cost 25, Gorilla, Sporebat, Moth, Rhino, Wasp
+    //movement
+    //charge
+    SWOOP_1                             = 52825,//44 cost 35 Carrion Bird, Wasp, Teromoth
+    CHARGE_1                            = 61685,//20/44 cost 35 Bear, Boar, Cat, Core Hound, Crab, Crocolisk, Devilsaur, Gorilla, Hyena, Raptor, Rhino, Scorpid, Spirit Beast, Tallstrider, Turtle, Warp Stalker, Wolf, Worm
+    //sprint
+    DASH_1                              = 61684,//20/44 cost 30 Cat, Core Hound, Devilsaur, Hyena, Raptor, Ravager, Serpent, Silithid, Spider, Spirit Beast, Tallstrider, Warp Stalker, Wolf
+    DIVE_1                              = 23145,//20 cost 30 Bat, Bird of Prey, Carrion Bird, Chimaera, Dragonhawk, Moth, Nether Ray, Sporebat, Wasp, Wind Serpent
+    //talents cunning
+    CARRION_FEEDER_1                    = 54045,//44 triggered spell
+    WOLVERINE_BITE_1                    = 53508,//68 after crit (any time for bot)
+    ROAR_OF_RECOVERY_1                  = 53517,//68 mana regen
+    BULLHEADED_1                        = 53490,//68 movement imparing remove
+    //talents ferocity
+    //HEART_OF_THE_PHOENIX_1              = 55709,
+    RABID_1                             = 53401,//68 attack increase proc
+    LICK_YOUR_WOUNDS_1                  = 53426,//68 full heal over 5, channeled
+    CALL_OF_THE_WILD_1                  = 53434,//68 10% AP for pet and hunter
+    //talents tenacity
+    THUNDERSTOMP_1                      = 63900,//44
+    LAST_STAND_1                        = 53478,//68 30%
+    TAUNT_1                             = 53477,//68 3 min cd 126 sec improved
+    ROAR_OF_SACRIFICE_1                 = 53480,//68
+    INTERVENE_1                         = 53476,//68
+    //pet-specific
+    //cunning
+    SONIC_BLAST_1                       = 50519,//bat c80 dmg/stun 20y cd60
+    SNATCH_1                            = 50541,//birdop c20 dmg/disarm 5y cd60
+    FROSTSTORM_BREATH_1                 = 54644,//chimera c20 dmg/slow 30y cd10
+    FIRE_BREATH_1                       = 34889,//dhawk c20 dmg/dot 20y cd10
+    NETHER_SHOCK_1                      = 50479,//nray c20 dmg/interrupt 20y cd40
+    RAVAGE_1                            = 50518,//ravager c0 (bug?) dmg/stun 5y cd40
+    POISON_SPIT_1                       = 35387,//serpent c20 dot/slowcast 30y cd10
+    VENOM_WEB_SPRAY_1                   = 54706,//silithid c0 dot/root 30y cd40
+    WEB_1                               = 4167,//spider c0 root 30y cd40
+    SPORE_CLOUD_1                       = 50274,//sporebat c20 aoedot/-armorpct 6yd cd10
+    LIGHTNING_BREATH_1                  = 24844,//wserpent c20 dmg 20y cd10
+    //ferocity
+    DEMORALIZING_SCREECH_1              = 24423,//cbird c20 dmg/aoe-ap 5y cd10
+    PROWL_1                             = 24450,//cat,spbeast c0 stealth 0y cd10
+    LAVA_BREATH_1                       = 58604,//chound c20 dmg/slowcast 30y cd10
+    MONSTROUS_BITE_1                    = 54680,//dsaur c20 dmg/buff 5y cd10
+    TENDON_RIP_1                        = 50271,//hyena c20 dmg/snare 5y cd20
+    SERENITY_DUST_1                     = 50318,//tmoth c0 hot/buff+ap 0y cd60
+    SAVAGE_REND_1                       = 50498,//raptor c20 dmg/dot 5y cd60
+    SPIRIT_STRIKE_1                     = 61193,//spbeast c20 dmg/dot 30y cd10
+    DUST_CLOUD_1                        = 50285,//tstrider c20 aoe-100hit 10y cd40 lvl6
+    STING_1                             = 56626,//wasp c20 dmg/-5%armor 5y cd6
+    FURIOUS_HOWL_1                      = 24604,//wolf c20 buff+ap 100y cd40
+    //tenacity
+    SWIPE_1                             = 50256,//bear c20 dmg 5y cd5
+    GORE_1                              = 35290,//boar c20 dmg 5y cd10
+    PIN_1                               = 50245,//crab c0 root/dot 5y cd40
+    PUMMEL_1                            = 26090,//gorilla c20 interrupt 5y cd30
+    STAMPEDE_1                          = 57386,//rhino c0 dmg/debuff+bleed 5y cd60
+    SCORPID_POISON_1                    = 24640,//scorpid c20 threat/dot 5y cd10
+    SHELL_SHIELD_1                      = 26064,//turtle c0 buff%dmgtaken 0y cd60
+    WARP_1                              = 35346,//wstalker c0 tp/buff50%avoid 30y cd15
+    ACID_SPIT_1                         = 55749,//worm c20 dmg/debuff-10%armor 30y cd10
+
+    //from hunter's talents
+    SPIRIT_BOND_PET                     = 24529,
+    KINDRED_SPIRITS_PET                 = 57475,
+    INTIMIDATION_1                      = 24394,
+    BESTIAL_WRATH_1                     = 19574,
+    BEAST_WITHIN_1                      = 34471
+};
+
+enum HunterPetPassives
+{
+    //common
+    AVOIDANCE                           = 65220,
+    //pet talents
+    COBRA_REFLEXES                      = 61683,//rank 2
+    //BOARS_SPEED                         = 19596,
+    BLOOD_OF_THE_RHINO                  = 53482,//rank 2
+    OWLS_FOCUS                          = 53516,//rank 2
+    CULLING_THE_HERD                    = 52858,//rank 3
+    GRACE_OF_THE_MANTIS                 = 53451,//rank 2
+    CORNERED                            = 53497,//rank 2
+    FEEDING_FRENZY                      = 53512,//rank 2
+    SILVERBACK                          = 62765,//rank 2
+    //special
+    //Catlike Reflexes and Serpent's Swiftness replacement
+    HASTE_DODGE_PASSIVE                 = 13789,//Lightning Reflexes rank 3 6 dodge 10 haste
+};
+
+enum HunterPetSpecial
+{
+    PET_CATEGORY_CUNNING                = 1,
+    PET_CATEGORY_FEROCITY               = 2,
+    PET_CATEGORY_TENACITY               = 3,
+
+    GO_FOR_THE_THROAT_ENERGIZE          = 34953,
+    FRENZY_BUFF                         = 19615,
+    //HEART_OF_THE_PHOENIX_TRIGGERED      = 54114,//resurrect pet effect
+    //HEART_OF_THE_PHOENIX_DEBUFF         = 55711 //Weakened Heart dummy eff 0 icon 2787
+};
+
+class hunter_pet_bot : public CreatureScript
+{
+public:
+    hunter_pet_bot() : CreatureScript("hunter_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botpetAI(creature);
+    }
+
+    struct hunter_botpetAI : public bot_pet_ai
+    {
+        hunter_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (GetSpell(SPIRIT_BOND_PET) && IsSpellReady(SPIRIT_BOND_PET, diff, false) &&
+                !petOwner->GetAuraEffect(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_GENERIC, 960, 1))
+            {
+                me->CastSpell(me, SPIRIT_BOND_PET, true);
+                SetSpellCooldown(SPIRIT_BOND_PET, uint32(-1));
+            }
+            if (GetSpell(KINDRED_SPIRITS_PET) && IsSpellReady(KINDRED_SPIRITS_PET, diff, false) &&
+                !petOwner->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_GENERIC, 3559, 0))
+            {
+                me->CastSpell(me, KINDRED_SPIRITS_PET, true);
+                SetSpellCooldown(KINDRED_SPIRITS_PET, uint32(-1));
+            }
+
+            //Ignoring pet category
+
+            if (IsSpellReady(CARRION_FEEDER_1, diff, false) && !me->isMoving() && GetHealthPCT(me) <= 80 &&
+                !me->IsInCombat() && !me->GetVictim() && me->getAttackers().empty() &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && Rand() < 20)
+            {
+                WorldObject* result = nullptr;
+                Trinity::AnyDeadUnitSpellTargetInRangeCheck check(me, 5.f, sSpellMgr->GetSpellInfo(CARRION_FEEDER_1), TARGET_CHECK_ENEMY);
+                Trinity::WorldObjectSearcher<Trinity::AnyDeadUnitSpellTargetInRangeCheck> searcher(me, result, check);
+                Cell::VisitWorldObjects(me, searcher, 5.f);
+
+                if (result)
+                {
+                    me->CastSpell(me, GetSpell(CARRION_FEEDER_1), false);
+                    SetSpellCooldown(CARRION_FEEDER_1, 21000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(LICK_YOUR_WOUNDS_1, diff, false) && !me->isMoving() && !me->GetVictim() &&
+                me->getAttackers().empty() && GetHealthPCT(me) <= 50 + 30 * me->IsInCombat() &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && Rand() < 40)
+            {
+                me->CastSpell(me, GetSpell(LICK_YOUR_WOUNDS_1), false);
+                SetSpellCooldown(LICK_YOUR_WOUNDS_1, 126000);
+                return;
+            }
+
+            if (IsSpellReady(ROAR_OF_RECOVERY_1, diff, false) && petOwner->IsInCombat() && opponent &&
+                GetManaPCT(petOwner) < 65 && petOwner->GetDistance(me) < 40)
+            {
+                me->CastSpell(me, GetSpell(ROAR_OF_RECOVERY_1), false);
+                SetSpellCooldown(ROAR_OF_RECOVERY_1, 126000);
+                return;
+            }
+
+            if (IsSpellReady(INTERVENE_1, diff, false) && GetHealthPCT(petOwner) < 95 && !petOwner->getAttackers().empty() &&
+                me->getAttackers().size() <= petOwner->getAttackers().size())
+            {
+                float petdist = me->GetDistance(petOwner);
+                if (petdist < 25 && petdist > 8)
+                {
+                    me->CastSpell(petOwner, GetSpell(INTERVENE_1), false);
+                    SetSpellCooldown(INTERVENE_1, 21000);
+                    return;
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            Unit const* u = opponent->GetVictim();
+            float dist = me->GetDistance(opponent);
+            uint32 focus = me->GetPower(POWER_FOCUS);
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            //improved + Longevity applied to cds
+
+            if (IsSpellReady(BESTIAL_WRATH_1, diff, false) && canDPS && opponent && dist < 10 &&
+                (opponent->GetHealth() > petOwner->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()) ||
+                opponent->GetTypeId() == TYPEID_PLAYER))
+            {
+                if (petOwner->AddAura(GetSpell(BESTIAL_WRATH_1), me))
+                {
+                    if (GetSpell(BEAST_WITHIN_1))
+                        petOwner->AddAura(GetSpell(BEAST_WITHIN_1), petOwner);
+
+                    SetSpellCooldown(BESTIAL_WRATH_1, 70000);
+                    return;
+                }
+            }
+
+            //LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) &&
+                GetHealthPCT(me) < (30 + 20 * (opponent->getAttackers().size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                me->CastSpell(me, GetSpell(LAST_STAND_1), false);
+                SetSpellCooldown(LAST_STAND_1, 252000);
+            }
+
+            if (IsSpellReady(INTIMIDATION_1, diff, false) && !CCed(opponent) && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(INTIMIDATION_1), false);
+                SetSpellCooldown(INTIMIDATION_1, 60000);
+                return;
+            }
+
+            if (IsSpellReady(GROWL_1, diff, false) && u && u != me && focus >= 15 && me->IsWithinMeleeRange(opponent) &&
+                opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 50)) && IsInBotParty(u))
+            {
+                me->CastSpell(opponent, GetSpell(GROWL_1), false);
+                SetSpellCooldown(GROWL_1, 3500);
+                return;
+            }
+
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 50)) && IsInBotParty(u))
+            {
+                me->CastSpell(opponent, GetSpell(TAUNT_1), false);
+                SetSpellCooldown(TAUNT_1, 126000);
+                return;
+            }
+
+            if (IsSpellReady(COWER_1, diff, false) && !me->getAttackers().empty() &&
+                me->GetDistance(*me->getAttackers().begin()) < 7 && GetHealthPCT(me) < 90)
+            {
+                me->CastSpell(me, GetSpell(COWER_1), false);
+                SetSpellCooldown(COWER_1, 31500);
+                return;
+            }
+
+            if (IsSpellReady(BULLHEADED_1, diff, false) && GetHealthPCT(me) < 90 &&
+                ((!me->getAttackers().empty() && me->GetDistance(*me->getAttackers().begin()) < 7) ||
+                (dist > 3 && !opponent->HasInArc(M_PI/2, me) &&
+                (CCed(me, true) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))))
+            {
+                me->CastSpell(me, GetSpell(BULLHEADED_1), false);
+                SetSpellCooldown(BULLHEADED_1, 31500);
+                return;
+            }
+
+            uint32 SPRINT = IsPetTypeSpell(DASH_1) ? DASH_1 : IsPetTypeSpell(DIVE_1) ? DIVE_1 : 0;
+            if (SPRINT && GetSpell(SPRINT) && IsSpellReady(SPRINT, diff, false) && dist > 10 && dist < 30 &&
+                !HasBotCommandState(BOT_COMMAND_STAY))
+            {
+                me->CastSpell(opponent, GetSpell(SPRINT), false);
+                SetSpellCooldown(SPRINT, 17500);
+                return;
+            }
+
+            if (IsSpellReady(CALL_OF_THE_WILD_1, diff, false) && canDPS && opponent && dist < 10)
+            {
+                me->CastSpell(me, GetSpell(CALL_OF_THE_WILD_1), false);
+                SetSpellCooldown(CALL_OF_THE_WILD_1, 210000);
+                return;
+            }
+
+            if (IsSpellReady(RABID_1, diff, false) && canDPS && dist < 10)
+            {
+                me->CastSpell(me, GetSpell(RABID_1), false);
+                SetSpellCooldown(RABID_1, 31500);
+                return;
+            }
+
+            if (IsSpellReady(THUNDERSTOMP_1, diff, false) && canDPS && focus >= 20 &&
+                me->IsWithinMeleeRange(opponent) && me->getAttackers().size() > 1)
+            {
+                me->CastSpell(opponent, GetSpell(THUNDERSTOMP_1), false);
+                SetSpellCooldown(THUNDERSTOMP_1, 7000);
+                return;
+            }
+
+            if (myType == BOT_PET_BAT)
+            {
+                if (IsSpellReady(SONIC_BLAST_1, diff, false) && canDPS && focus >= 80 &&
+                    dist < 20 && opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(SONIC_BLAST_1), false);
+                    SetSpellCooldown(SONIC_BLAST_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_BIRDOFPREY)
+            {
+                if (IsSpellReady(SNATCH_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                    ((opponent->GetTypeId() == TYPEID_PLAYER) ? opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) != nullptr :
+                    opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) != 0))
+                {
+                    me->CastSpell(opponent, GetSpell(SNATCH_1), false);
+                    SetSpellCooldown(SNATCH_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CHIMAERA)
+            {
+                if (IsSpellReady(FROSTSTORM_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(FROSTSTORM_BREATH_1), false);
+                    SetSpellCooldown(FROSTSTORM_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_DRAGONHAWK)
+            {
+                if (IsSpellReady(FIRE_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 20)
+                {
+                    me->CastSpell(opponent, GetSpell(FIRE_BREATH_1), false);
+                    SetSpellCooldown(FIRE_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_NETHERRAY)
+            {
+                if (IsSpellReady(NETHER_SHOCK_1, diff, false) && canDPS && focus >= 20 && dist < 20 &&
+                    opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(NETHER_SHOCK_1), false);
+                    SetSpellCooldown(NETHER_SHOCK_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_RAVAGER)
+            {
+                if (IsSpellReady(RAVAGE_1, diff, false) && canDPS/* && focus >= 0*/ &&
+                    me->IsWithinMeleeRange(opponent) && opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(RAVAGE_1), false);
+                    SetSpellCooldown(RAVAGE_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SERPENT)
+            {
+                if (IsSpellReady(POISON_SPIT_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(POISON_SPIT_1), false);
+                    SetSpellCooldown(POISON_SPIT_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SILITHID)
+            {
+                if (IsSpellReady(VENOM_WEB_SPRAY_1, diff, false) && canDPS/* && focus >= 0*/ && dist < 30 &&
+                    !CCed(opponent, true))
+                {
+                    me->CastSpell(opponent, GetSpell(VENOM_WEB_SPRAY_1), false);
+                    SetSpellCooldown(VENOM_WEB_SPRAY_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SPIDER)
+            {
+                if (IsSpellReady(WEB_1, diff, false)/* && focus >= 0*/ && dist < 30 && !CCed(opponent, true))
+                {
+                    me->CastSpell(opponent, GetSpell(WEB_1), false);
+                    SetSpellCooldown(WEB_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SPOREBAT)
+            {
+                if (IsSpellReady(SPORE_CLOUD_1, diff, false) && canDPS && focus >= 20 && dist < 5)
+                {
+                    me->CastSpell(opponent, GetSpell(SPORE_CLOUD_1), false);
+                    SetSpellCooldown(SPORE_CLOUD_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WINDSERPENT)
+            {
+                if (IsSpellReady(LIGHTNING_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 20)
+                {
+                    me->CastSpell(opponent, GetSpell(LIGHTNING_BREATH_1), false);
+                    SetSpellCooldown(LIGHTNING_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CARRIONBIRD)
+            {
+                if (IsSpellReady(DEMORALIZING_SCREECH_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(DEMORALIZING_SCREECH_1), false);
+                    SetSpellCooldown(DEMORALIZING_SCREECH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CAT)
+            {
+                if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && !me->HasStealthAura() &&
+                    /*focus >= 0 && */dist < 20 && dist > 5)
+                {
+                    me->CastSpell(opponent, GetSpell(PROWL_1), false);
+                    SetSpellCooldown(PROWL_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_COREHOUND)
+            {
+                if (IsSpellReady(LAVA_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(LAVA_BREATH_1), false);
+                    SetSpellCooldown(LAVA_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_DEVILSAUR)
+            {
+                if (IsSpellReady(MONSTROUS_BITE_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(MONSTROUS_BITE_1), false);
+                    SetSpellCooldown(MONSTROUS_BITE_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_HYENA)
+            {
+                if (IsSpellReady(TENDON_RIP_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(TENDON_RIP_1), false);
+                    SetSpellCooldown(TENDON_RIP_1, 14000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_TEROMOTH)
+            {
+                if (IsSpellReady(SERENITY_DUST_1, diff, false) && (canDPS || GetHealthPCT(me) < 90) &&
+                    /*focus >= 0 && */dist < 7)
+                {
+                    me->CastSpell(me, GetSpell(SERENITY_DUST_1), false);
+                    SetSpellCooldown(SERENITY_DUST_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_RAPTOR)
+            {
+                if (IsSpellReady(SAVAGE_REND_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SAVAGE_REND_1), false);
+                    SetSpellCooldown(SAVAGE_REND_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SPIRITBEAST)
+            {
+                if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && !me->HasStealthAura() &&
+                    /*focus >= 0 && */dist < 30 && dist > 5)
+                {
+                    me->CastSpell(opponent, GetSpell(PROWL_1), false);
+                    SetSpellCooldown(PROWL_1, 10000); //custom
+                    return;
+                }
+                if (IsSpellReady(SPIRIT_STRIKE_1, diff, false) && canDPS && !me->HasStealthAura() &&
+                    focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(SPIRIT_STRIKE_1), false);
+                    SetSpellCooldown(SPIRIT_STRIKE_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_TALLSTRIDER)
+            {
+                if (IsSpellReady(DUST_CLOUD_1, diff, false) && focus >= 20 && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(DUST_CLOUD_1), false);
+                    SetSpellCooldown(DUST_CLOUD_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WASP)
+            {
+                if (IsSpellReady(STING_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(STING_1), false);
+                    SetSpellCooldown(STING_1, 4000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WOLF)
+            {
+                if (IsSpellReady(FURIOUS_HOWL_1, diff, false) && canDPS && focus >= 20)
+                {
+                    me->CastSpell(me, GetSpell(FURIOUS_HOWL_1), false);
+                    SetSpellCooldown(FURIOUS_HOWL_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_BEAR)
+            {
+                if (IsSpellReady(SWIPE_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SWIPE_1), false);
+                    SetSpellCooldown(SWIPE_1, 3500);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_BOAR)
+            {
+                if (IsSpellReady(GORE_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(GORE_1), false);
+                    SetSpellCooldown(GORE_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CRAB)
+            {
+                if (IsSpellReady(PIN_1, diff, false) && canDPS/* && focus >= 0*/ &&
+                    me->IsWithinMeleeRange(opponent) && !CCed(opponent, true))
+                {
+                    me->CastSpell(opponent, GetSpell(PIN_1), false);
+                    SetSpellCooldown(PIN_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_GORILLA)
+            {
+                if (IsSpellReady(PUMMEL_1, diff, false) && focus >= 20 && me->IsWithinMeleeRange(opponent) &&
+                    opponent->IsNonMeleeSpellCast(false,false,true))
+                {
+                    me->CastSpell(opponent, GetSpell(PUMMEL_1), false);
+                    SetSpellCooldown(PUMMEL_1, 21000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_RHINO)
+            {
+                if (IsSpellReady(STAMPEDE_1, diff, false) && canDPS/* && focus >= 0*/ &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(STAMPEDE_1), false);
+                    SetSpellCooldown(STAMPEDE_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SCORPID)
+            {
+                if (IsSpellReady(SCORPID_POISON_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SCORPID_POISON_1), false);
+                    SetSpellCooldown(SCORPID_POISON_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_TURTLE)
+            {
+                if (IsSpellReady(SHELL_SHIELD_1, diff, false)/* && focus >= 0*/ && dist < 7 &&
+                    !me->getAttackers().empty())
+                {
+                    me->CastSpell(me, GetSpell(SHELL_SHIELD_1), false);
+                    SetSpellCooldown(SHELL_SHIELD_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WARPSTALKER)
+            {
+                if (IsSpellReady(WARP_1, diff, false)/* && focus >= 0*/ && dist < 10)
+                {
+                    me->CastSpell(opponent, GetSpell(WARP_1), false);
+                    SetSpellCooldown(WARP_1, 10500);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WORM)
+            {
+                if (IsSpellReady(ACID_SPIT_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(ACID_SPIT_1), false);
+                    SetSpellCooldown(ACID_SPIT_1, 7000);
+                    return;
+                }
+            }
+
+            uint32 CHARGE = IsPetTypeSpell(SWOOP_1) ? SWOOP_1 : IsPetTypeSpell(CHARGE_1) ? CHARGE_1 : 0;
+            if (CHARGE && GetSpell(CHARGE) && IsSpellReady(CHARGE, diff, false) && !CCed(opponent, true) && !me->HasStealthAura() &&
+                !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                dist > 8 && dist < 25)
+            {
+                me->CastSpell(opponent, GetSpell(CHARGE), false);
+                SetSpellCooldown(CHARGE, 17500);
+                return;
+            }
+
+            if (GetSpell(WOLVERINE_BITE_1) && canDPS && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(WOLVERINE_BITE_1), false);
+                SetSpellCooldown(WOLVERINE_BITE_1, 7000);
+                return;
+            }
+
+            uint32 ATTACK_1 = IsPetTypeSpell(BITE_1) ? BITE_1 : IsPetTypeSpell(CLAW_1) ? CLAW_1 : SMACK_1;
+            if (GetSpell(ATTACK_1) && IsSpellReady(ATTACK_1, diff) && canDPS && focus >= 25 && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(ATTACK_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isBeas = Spec() == BOT_SPEC_HUNTER_BEASTMASTERY;
+
+            InitSpellMap(GROWL_1);
+            InitSpellMap(COWER_1);
+
+            InitSpellMap(BITE_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(SMACK_1);
+
+            //talents
+  /*Talent*/IsPetTypeSpell(SWOOP_1) ? InitSpellMap(SWOOP_1, true) : RemoveSpell(SWOOP_1);
+  /*Talent*/IsPetTypeSpell(CHARGE_1) ? InitSpellMap(CHARGE_1, true) : RemoveSpell(CHARGE_1);
+  /*Talent*/IsPetTypeSpell(DASH_1) ? InitSpellMap(DASH_1, true) : RemoveSpell(DASH_1);
+  /*Talent*/IsPetTypeSpell(DIVE_1) ? InitSpellMap(DIVE_1, true) : RemoveSpell(DIVE_1);
+            //talents cunning
+  /*Talent*/lvl >= 44 ? InitSpellMap(CARRION_FEEDER_1, true) : RemoveSpell(CARRION_FEEDER_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(WOLVERINE_BITE_1, true) : RemoveSpell(WOLVERINE_BITE_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(ROAR_OF_RECOVERY_1, true) : RemoveSpell(ROAR_OF_RECOVERY_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(BULLHEADED_1, true) : RemoveSpell(BULLHEADED_1);
+            //talents ferocity
+  ///*Talent*/lvl >= 68 ? InitSpellMap(HEART_OF_THE_PHOENIX_1, true) : RemoveSpell(HEART_OF_THE_PHOENIX_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(RABID_1, true) : RemoveSpell(RABID_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(LICK_YOUR_WOUNDS_1, true) : RemoveSpell(LICK_YOUR_WOUNDS_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(CALL_OF_THE_WILD_1, true) : RemoveSpell(CALL_OF_THE_WILD_1);
+            //talents tenacity
+  /*Talent*/lvl >= 44 ? InitSpellMap(THUNDERSTOMP_1, true) : RemoveSpell(THUNDERSTOMP_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(LAST_STAND_1, true) : RemoveSpell(LAST_STAND_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(TAUNT_1, true) : RemoveSpell(TAUNT_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(ROAR_OF_SACRIFICE_1, true) : RemoveSpell(ROAR_OF_SACRIFICE_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(INTERVENE_1, true) : RemoveSpell(INTERVENE_1);
+            //pet-specific
+            InitSpellMap(SONIC_BLAST_1);
+            InitSpellMap(SNATCH_1);
+            InitSpellMap(FROSTSTORM_BREATH_1);
+            InitSpellMap(FIRE_BREATH_1);
+            InitSpellMap(NETHER_SHOCK_1);
+            InitSpellMap(RAVAGE_1);
+            InitSpellMap(POISON_SPIT_1);
+            InitSpellMap(VENOM_WEB_SPRAY_1);
+            InitSpellMap(WEB_1);
+            InitSpellMap(SPORE_CLOUD_1);
+            InitSpellMap(LIGHTNING_BREATH_1);
+            InitSpellMap(DEMORALIZING_SCREECH_1);
+            InitSpellMap(PROWL_1);
+            InitSpellMap(LAVA_BREATH_1);
+            InitSpellMap(MONSTROUS_BITE_1);
+            InitSpellMap(TENDON_RIP_1);
+            InitSpellMap(SERENITY_DUST_1);
+            InitSpellMap(SAVAGE_REND_1);
+            InitSpellMap(SPIRIT_STRIKE_1);
+            InitSpellMap(DUST_CLOUD_1);
+            InitSpellMap(STING_1);
+            InitSpellMap(FURIOUS_HOWL_1);
+            InitSpellMap(SWIPE_1);
+            InitSpellMap(GORE_1);
+            InitSpellMap(PIN_1);
+            InitSpellMap(PUMMEL_1);
+            InitSpellMap(STAMPEDE_1);
+            InitSpellMap(SCORPID_POISON_1);
+            InitSpellMap(SHELL_SHIELD_1);
+            InitSpellMap(WARP_1);
+            InitSpellMap(ACID_SPIT_1);
+
+  /*Talent*/lvl >= 30 && isBeas ? InitSpellMap(SPIRIT_BOND_PET, true) : RemoveSpell(SPIRIT_BOND_PET);
+  /*Talent*/lvl >= 55 && isBeas ? InitSpellMap(KINDRED_SPIRITS_PET, true) : RemoveSpell(KINDRED_SPIRITS_PET);
+  /*Talent*/lvl >= 30 && isBeas ? InitSpellMap(INTIMIDATION_1, true) : RemoveSpell(INTIMIDATION_1);
+  /*Talent*/lvl >= 40 && isBeas ? InitSpellMap(BESTIAL_WRATH_1, true) : RemoveSpell(BESTIAL_WRATH_1);
+  /*Talent*/lvl >= 50 && isBeas ? InitSpellMap(BEAST_WITHIN_1, true) : RemoveSpell(BEAST_WITHIN_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            uint8 lvl = me->GetLevel();
+
+            RefreshAura(AVOIDANCE, lvl >= 60);
+            //ignore pet type
+            RefreshAura(COBRA_REFLEXES, lvl >= 20);
+            RefreshAura(BLOOD_OF_THE_RHINO, lvl >= 32);
+            RefreshAura(OWLS_FOCUS, lvl >= 32);
+            RefreshAura(CULLING_THE_HERD, lvl >= 32);
+            RefreshAura(GRACE_OF_THE_MANTIS, lvl >= 44);
+            RefreshAura(CORNERED, lvl >= 44);
+            RefreshAura(FEEDING_FRENZY, lvl >= 44);
+            RefreshAura(SILVERBACK, lvl >= 80);
+
+            RefreshAura(HASTE_DODGE_PASSIVE, lvl >= 45);
+        }
+
+    private:
+        bool IsPetTypeSpell(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case BITE_1: //lvl 1
+                    switch (myType)
+                    {
+                        case BOT_PET_BAT:
+                        case BOT_PET_BOAR:
+                        case BOT_PET_CARRIONBIRD:
+                        case BOT_PET_CROCOLISK:
+                        case BOT_PET_DRAGONHAWK:
+                        case BOT_PET_HYENA:
+                        case BOT_PET_NETHERRAY:
+                        case BOT_PET_RAVAGER:
+                        case BOT_PET_SERPENT:
+                        case BOT_PET_WOLF:
+
+                        case BOT_PET_CHIMAERA:
+                        case BOT_PET_COREHOUND:
+                        case BOT_PET_DEVILSAUR:
+                        case BOT_PET_WORM:
+                            return true;
+                        default:
+                            return false;
+                    }
+                case CLAW_1: //lvl 1
+                    switch (myType)
+                    {
+                        case BOT_PET_BEAR:
+                        case BOT_PET_BIRDOFPREY:
+                        case BOT_PET_CAT:
+                        case BOT_PET_CRAB:
+                        case BOT_PET_RAPTOR:
+                        case BOT_PET_SCORPID:
+                        case BOT_PET_TALLSTRIDER:
+
+                        case BOT_PET_SILITHID:
+                        case BOT_PET_SPIRITBEAST:
+                            return true;
+                        default:
+                            return false;
+                    }
+                case SMACK_1: //lvl 1
+                    switch (myType)
+                    {
+                        case BOT_PET_GORILLA:
+                        case BOT_PET_SPOREBAT:
+                        case BOT_PET_TEROMOTH:
+                        case BOT_PET_WASP:
+
+                        case BOT_PET_RHINO:
+                            return true;
+                        default:
+                            return false;
+                    }
+                case SWOOP_1: //fliers ferocity lvl 44
+                    switch (myType)
+                    {
+                        case BOT_PET_CARRIONBIRD:
+                        case BOT_PET_WASP:
+                        case BOT_PET_TEROMOTH:
+                            return me->GetLevel() >= 44;
+                        default:
+                            return false;
+                    }
+                case CHARGE_1: //non-fliers tenacity/ferocity lvl 20/44
+                    switch (myType)
+                    {
+                        case BOT_PET_BEAR:
+                        case BOT_PET_BOAR:
+                        case BOT_PET_CAT:
+                        case BOT_PET_CRAB:
+                        case BOT_PET_CROCOLISK:
+                        case BOT_PET_GORILLA:
+                        case BOT_PET_HYENA:
+                        case BOT_PET_RAPTOR:
+                        case BOT_PET_SCORPID:
+                        case BOT_PET_TALLSTRIDER:
+                        case BOT_PET_TURTLE:
+                        case BOT_PET_WARPSTALKER:
+                        case BOT_PET_WOLF:
+
+                        case BOT_PET_COREHOUND:
+                        case BOT_PET_DEVILSAUR:
+                        case BOT_PET_RHINO:
+                        case BOT_PET_SPIRITBEAST:
+                        case BOT_PET_WORM:
+                            return me->GetLevel() >= (IsPetCategory(PET_CATEGORY_FEROCITY) ? 44 : 20);
+                        default:
+                            return false;
+                    }
+                case DASH_1: //non-fliers ferocity/cunning lvl 20/44
+                    switch (myType)
+                    {
+                        case BOT_PET_CAT:
+                        case BOT_PET_HYENA:
+                        case BOT_PET_RAPTOR:
+                        case BOT_PET_RAVAGER:
+                        case BOT_PET_SERPENT:
+                        case BOT_PET_SPIDER:
+                        case BOT_PET_TALLSTRIDER:
+                        case BOT_PET_WARPSTALKER:
+                        case BOT_PET_WOLF:
+
+                        case BOT_PET_COREHOUND:
+                        case BOT_PET_DEVILSAUR:
+                        case BOT_PET_SILITHID:
+                        case BOT_PET_SPIRITBEAST:
+                            return me->GetLevel() >= (IsPetCategory(PET_CATEGORY_CUNNING) ? 44 : 20);
+                        default:
+                            return false;
+                    }
+                case DIVE_1: //fliers lvl 20
+                    switch (myType)
+                    {
+                        case BOT_PET_BAT:
+                        case BOT_PET_BIRDOFPREY:
+                        case BOT_PET_CARRIONBIRD:
+                        case BOT_PET_DRAGONHAWK:
+                        case BOT_PET_TEROMOTH:
+                        case BOT_PET_NETHERRAY:
+                        case BOT_PET_SPOREBAT:
+                        case BOT_PET_WASP:
+                        case BOT_PET_WINDSERPENT:
+
+                        case BOT_PET_CHIMAERA:
+                            return me->GetLevel() >= 20;
+                        default:
+                            return false;
+                    }
+                default:
+                    return true;
+            }
+        }
+
+        bool IsPetCategory(uint8 category) const
+        {
+            switch (myType)
+            {
+                case BOT_PET_SPIDER:
+                case BOT_PET_SERPENT:
+                case BOT_PET_BIRDOFPREY:
+                case BOT_PET_BAT:
+                case BOT_PET_WINDSERPENT:
+                case BOT_PET_RAVAGER:
+                case BOT_PET_DRAGONHAWK:
+                case BOT_PET_NETHERRAY:
+                case BOT_PET_SPOREBAT:
+
+                case BOT_PET_SILITHID:
+                case BOT_PET_CHIMAERA:
+                    return category == PET_CATEGORY_CUNNING;
+                case BOT_PET_CARRIONBIRD:
+                case BOT_PET_RAPTOR:
+                case BOT_PET_WOLF:
+                case BOT_PET_TALLSTRIDER:
+                case BOT_PET_CAT:
+                case BOT_PET_HYENA:
+                case BOT_PET_WASP:
+                case BOT_PET_TEROMOTH:
+
+                case BOT_PET_SPIRITBEAST:
+                case BOT_PET_COREHOUND:
+                case BOT_PET_DEVILSAUR:
+                    return category == PET_CATEGORY_FEROCITY;
+                case BOT_PET_SCORPID:
+                case BOT_PET_TURTLE:
+                case BOT_PET_GORILLA:
+                case BOT_PET_BEAR:
+                case BOT_PET_BOAR:
+                case BOT_PET_CRAB:
+                case BOT_PET_CROCOLISK:
+                case BOT_PET_WARPSTALKER:
+
+                case BOT_PET_RHINO:
+                case BOT_PET_WORM:
+                    return category == PET_CATEGORY_TENACITY;
+                default:
+                    return false;
+            }
+        }
+    };
+};
+
+void AddSC_hunter_bot_pets()
+{
+    new hunter_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_mage.cpp b/src/server/game/AI/NpcBots/bpet_mage.cpp
new file mode 100644
index 0000000..67e35ef
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_mage.cpp
@@ -0,0 +1,176 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellInfo.h"
+#include "TemporarySummon.h"
+/*
+Mage NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum MagePetBaseSpells
+{
+    WATERBOLT_1             = 31707,
+    FREEZE_1                = 33395
+};
+
+enum MagePetSpecial
+{
+    ELEMENTAL_DURATION      = 45000
+};
+
+class mage_pet_bot : public CreatureScript
+{
+public:
+    mage_pet_bot() : CreatureScript("mage_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new water_elemental_botpetAI(creature);
+    }
+
+    struct water_elemental_botpetAI : public bot_pet_ai
+    {
+        water_elemental_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(3000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (!IsSpellReady(FREEZE_1, diff, false) || Rand() > 40 || !IsCasting(petOwner))
+                return;
+
+            Spell const* spell = petOwner->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (!spell || !spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+                !(spell->GetTimer() < spell->GetCastTime() / 2))
+                return;
+
+            Unit* target = ObjectAccessor::GetUnit(*me, spell->m_targets.GetObjectTargetGUID());
+            if (!target || target->IsFrozen() || target->GetDistance(me) - target->GetCombatReach() > 25.f ||
+                !me->IsValidAttackTarget(target))
+                return;
+
+            me->InterruptNonMeleeSpells(false);
+            me->CastSpell(target, GetSpell(FREEZE_1), false);
+            return;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= ELEMENTAL_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(WATERBOLT_1, diff) && me->GetDistance(opponent) < 45)
+            {
+                me->CastSpell(opponent, GetSpell(WATERBOLT_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(WATERBOLT_1);
+            InitSpellMap(FREEZE_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_mage_bot_pets()
+{
+    new mage_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_priest.cpp b/src/server/game/AI/NpcBots/bpet_priest.cpp
new file mode 100644
index 0000000..db247b0
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_priest.cpp
@@ -0,0 +1,172 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Priest NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum PriestPetBaseSpells
+{
+    SHADOWCRAWL_1                       = 63619
+};
+
+enum PriestPetPassives
+{
+    MANA_LEECH                          = 28305,
+    AVOIDANCE                           = 63623
+};
+
+enum PriestPetSpecial
+{
+    GLYPH_SHADOWFIEND_PROC              = 58227,
+
+    SHADOWFIEND_DURATION                = 15000
+};
+
+class priest_pet_bot : public CreatureScript
+{
+public:
+    priest_pet_bot() : CreatureScript("priest_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botpetAI(creature);
+    }
+
+    struct priest_botpetAI : public bot_pet_ai
+    {
+        priest_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(5000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= SHADOWFIEND_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (IsSpellReady(SHADOWCRAWL_1, diff) && canDPS && dist < 30)
+            {
+                me->CastSpell(opponent, GetSpell(SHADOWCRAWL_1), false);
+                SetSpellCooldown(SHADOWCRAWL_1, 6000);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Handled by spell scripts
+            //if (damage && victim && damageType == DIRECT_DAMAGE)
+            //    victim->CastSpell(petOwner, MANA_LEECH_PROC, true);
+
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage) override
+        {
+            if (damage >= me->GetHealth())
+                petOwner->CastSpell(petOwner, GLYPH_SHADOWFIEND_PROC, true);
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(SHADOWCRAWL_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            RefreshAura(MANA_LEECH);
+            RefreshAura(AVOIDANCE);
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_priest_bot_pets()
+{
+    new priest_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_shaman.cpp b/src/server/game/AI/NpcBots/bpet_shaman.cpp
new file mode 100644
index 0000000..ef327a8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_shaman.cpp
@@ -0,0 +1,191 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Shaman NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum ShamanPetBaseSpells
+{
+    BASH_1                              = 58861, //r5 cd45
+    LEAP_1                              = 58867, //r5-30 cd20
+    TWIN_HOWL_1                         = 58857, //r10 cd15
+    SPIRIT_WALK_1                       = 58875  //r25 cd32
+};
+
+enum ShamanPetPassives
+{
+    SPIRIT_HUNT                         = 58877
+};
+
+enum ShamanPetSpecial
+{
+    SPIRITWOLF_DURATION                 = 45000
+};
+
+class shaman_pet_bot : public CreatureScript
+{
+public:
+    shaman_pet_bot() : CreatureScript("shaman_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botpetAI(creature);
+    }
+
+    struct shaman_botpetAI : public bot_pet_ai
+    {
+        shaman_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(5000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (IsSpellReady(SPIRIT_WALK_1, diff) && (me->GetVictim() || petOwner->GetVictim()) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                me->GetDistance(petOwner) < 25)
+            {
+                me->CastSpell(me, GetSpell(SPIRIT_WALK_1), false);
+                return;
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= SPIRITWOLF_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            Unit const* u = opponent->GetVictim();
+            //bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (IsSpellReady(LEAP_1, diff) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                dist > 5 && dist < 30)
+            {
+                me->CastSpell(opponent, GetSpell(LEAP_1), false);
+                return;
+            }
+
+            if (IsSpellReady(BASH_1, diff) && !CCed(opponent) &&
+                me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(BASH_1), false);
+                return;
+            }
+
+            if (IsSpellReady(TWIN_HOWL_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 50)) && IsInBotParty(u))
+            {
+                me->CastSpell(opponent, GetSpell(TWIN_HOWL_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(BASH_1);
+            InitSpellMap(LEAP_1);
+            InitSpellMap(TWIN_HOWL_1);
+            InitSpellMap(SPIRIT_WALK_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            RefreshAura(SPIRIT_HUNT);
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_shaman_bot_pets()
+{
+    new shaman_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_warlock.cpp b/src/server/game/AI/NpcBots/bpet_warlock.cpp
new file mode 100644
index 0000000..13ce014
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_warlock.cpp
@@ -0,0 +1,409 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "botmgr.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "TemporarySummon.h"
+/*
+Warlock NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum WarlockPetBaseSpells
+{
+    //imp
+    FIREBOLT_1                          = 3110,//1
+    BLOOD_PACT_1                        = 6307,//4
+    PHASE_SHIFT_1                       = 4511,//12
+    FIRE_SHIELD_1                       = 2947,//14 unused
+    //voidwalker
+    TORMENT_1                           = 3716,//10
+    SACRIFICE_1                         = 7812,//16
+    CONSUME_SHADOWS_1                   = 17767,//18
+    SUFFERING_1                         = 17735,//24
+    //succubus
+    LASH_OF_PAIN_1                      = 7814,//20
+    SOOTHING_KISS_1                     = 6360,//22
+    SEDUCTION_1                         = 6358,//26
+    LESSER_INVISIBILITY_1               = 7870,//32
+    //felhunter
+    DEVOUR_MAGIC_1                      = 19505,//30
+    FEL_INTELLIGENCE_1                  = 54424,//32
+    SPELL_LOCK_1                        = 19244,//36
+    SHADOW_BITE_1                       = 54049,//42
+    //felguard
+    ANGUISH_1                           = 33698,//50
+    CLEAVE_1                            = 30213,//50
+    INTERCEPT_1                         = 30151 //52
+};
+
+enum WarlockPetPassives
+{
+    AVOIDANCE                           = 32233,
+    DEMONIC_FRENZY                      = 32850
+};
+
+enum WarlockPetSpecial
+{
+    SOUL_LINK_PET                       = 25228//split effect lvl 20 req
+};
+
+class warlock_pet_bot : public CreatureScript
+{
+public:
+    warlock_pet_bot() : CreatureScript("warlock_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botpetAI(creature);
+    }
+
+    struct warlock_botpetAI : public bot_pet_ai
+    {
+        warlock_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (GetSpell(SOUL_LINK_PET) && !petOwner->HasAuraTypeWithCaster(SPELL_AURA_SPLIT_DAMAGE_PCT, me->GetGUID()))
+            {
+                me->CastSpell(me, SOUL_LINK_PET, false);
+                return;
+            }
+            if (myType == BOT_PET_IMP)
+            {
+                //hacked - confilct with soul link due to ownerGuid mismatch
+                if (IsSpellReady(BLOOD_PACT_1, diff, false) && (!me->HasAuraType(SPELL_AURA_230) ||
+                    me->GetAuraEffectsByType(SPELL_AURA_230).front()->GetAmount() < sSpellMgr->GetSpellInfo(GetSpell(BLOOD_PACT_1))->Effects[0].CalcValue()))
+                {
+                    me->CastSpell(me, GetSpell(BLOOD_PACT_1), false);
+                    //CastSpellExtraArgs args(true);
+                    //args.SetOriginalCaster(me->GetGUID());
+                    //petOwner->CastSpell(petOwner, GetSpell(BLOOD_PACT_1), args);
+                    SetSpellCooldown(BLOOD_PACT_1, uint32(-1));
+                }
+
+                if (IsSpellReady(PHASE_SHIFT_1, diff, false) && !me->GetVictim() &&
+                    (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS) || !me->IsInCombat()) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+                {
+                    me->CastSpell(me, GetSpell(PHASE_SHIFT_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_VOIDWALKER)
+            {
+                if (GetSpell(CONSUME_SHADOWS_1) && !me->IsInCombat() && !me->isMoving() &&
+                    me->GetDistance(me) < 10 && GetHealthPCT(me) < 80)
+                {
+                    me->CastSpell(me, GetSpell(CONSUME_SHADOWS_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(SACRIFICE_1, diff, false) &&
+                    (!petOwner->getAttackers().empty() || petOwner->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) &&
+                    me->GetHealth() > me->GetCreateHealth() / 4) //hp cost 25%
+                {
+                    me->CastSpell(me, GetSpell(SACRIFICE_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SUCCUBUS)
+            {
+                if (IsSpellReady(SOOTHING_KISS_1, diff, false) &&
+                    !me->getAttackers().empty() && me->GetDistance(*(me->getAttackers().begin())) < 10)
+                {
+                    me->CastSpell(*(me->getAttackers().begin()), GetSpell(SOOTHING_KISS_1), false);
+                    SetSpellCooldown(SOOTHING_KISS_1, 4000);
+                    return;
+                }
+
+                if (GetSpell(SEDUCTION_1) && Rand() < 20 && !IsCasting())
+                {
+                    Unit* target = petOwner->GetBotAI()->HelpFindStunTarget(30);
+                    if (target && target->GetDiminishing(DIMINISHING_FEAR) <= DIMINISHING_LEVEL_2 + 1 * (target->IsNonMeleeSpellCast(false, false, true)))
+                    {
+                        me->CastSpell(target, GetSpell(SEDUCTION_1), false);
+                        return;
+                    }
+                }
+
+                if (IsSpellReady(LESSER_INVISIBILITY_1, diff, false) && !me->GetVictim() && !me->IsInCombat() &&
+                    !me->HasAuraType(SPELL_AURA_MOD_INVISIBILITY))
+                {
+                    me->CastSpell(me, GetSpell(LESSER_INVISIBILITY_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_FELHUNTER)
+            {
+                //hacked - confilct with soul link due to ownerGuid mismatch
+                if (IsSpellReady(FEL_INTELLIGENCE_1, diff, false) &&
+                    (IAmFree() ||
+                    (!petOwner->GetBotOwner()->GetBotMgr()->HasBotClass(BOT_CLASS_MAGE) &&
+                    !petOwner->GetBotOwner()->GetBotMgr()->HasBotClass(BOT_CLASS_PRIEST))))
+                {
+                    me->CastSpell(me, GetSpell(FEL_INTELLIGENCE_1), false);
+                    //CastSpellExtraArgs args(true);
+                    //args.SetOriginalCaster(me->GetGUID());
+                    //petOwner->CastSpell(petOwner, GetSpell(FEL_INTELLIGENCE_1), args);
+                    SetSpellCooldown(FEL_INTELLIGENCE_1, uint32(-1));
+                }
+
+                if (IsSpellReady(SPELL_LOCK_1, diff, false))
+                {
+                    if (Unit* target = petOwner->GetBotAI()->HelpFindCastingTarget(30, 0, SPELL_LOCK_1))
+                        me->CastSpell(target, GetSpell(SPELL_LOCK_1), false);
+                }
+
+                CureGroup(GetSpell(DEVOUR_MAGIC_1), diff);
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+            {
+                if (myType == BOT_PET_SUCCUBUS)
+                {
+                    if (Unit const* target = spell->m_targets.GetUnitTarget())
+                    {
+                        //Seduction interrupt
+                        if (spell->GetSpellInfo()->GetFirstRankSpell()->Id == SEDUCTION_1 && CCed(target))
+                            me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    }
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            Unit const* u = opponent->GetVictim();
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (myType == BOT_PET_IMP)
+            {
+                if (GetSpell(FIREBOLT_1) && canDPS && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(FIREBOLT_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_VOIDWALKER)
+            {
+                if (IsSpellReady(TORMENT_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                    opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                    (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 20)) && IsInBotParty(u))
+                {
+                    me->CastSpell(opponent, GetSpell(TORMENT_1), false);
+                    SetSpellCooldown(TORMENT_1, 5000);
+                    return;
+                }
+
+                if (IsSpellReady(SUFFERING_1, diff) &&
+                    !(u == me && opponent->GetTypeId() == TYPEID_UNIT &&
+                    (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())))
+                {
+                    std::list<Unit*> targets;
+                    petOwner->GetBotAI()->HelpGetNearbyTargetsList(targets, 9.f, 1, me);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count < 2 && u && u != me && !IsSpellReady(TORMENT_1, diff, false) && !IsTank(u) && !CCed(opponent) && dist < 8 &&
+                        IsInBotParty(u))
+                    {
+                        count += 2;
+                    }
+
+                    if (count > 1)
+                    {
+                        me->CastSpell(me, GetSpell(SUFFERING_1), false);
+                        SetSpellCooldown(SUFFERING_1, 120000);
+                        return;
+                    }
+                }
+            }
+            else if (myType == BOT_PET_SUCCUBUS)
+            {
+                if (IsSpellReady(LASH_OF_PAIN_1, diff, false) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(LASH_OF_PAIN_1), false);
+                    //this could have worked if cast was triggered
+                    //SetSpellCooldown(LASH_OF_PAIN_1, 6000); //Demonic Power part 1
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_FELHUNTER)
+            {
+                if (IsSpellReady(SHADOW_BITE_1, diff, false) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SHADOW_BITE_1), false);
+                    SetSpellCooldown(SHADOW_BITE_1, me->GetLevel() >= 35 ? 2000 : 6000); //improved felhunter part 2
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_FELGUARD)
+            {
+                if (IsSpellReady(INTERCEPT_1, diff, false) && canDPS &&
+                    !HasBotCommandState(BOT_COMMAND_STAY) &&
+                    !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                    dist > 8 && dist < 25 && !CCed(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(INTERCEPT_1), false);
+                    SetSpellCooldown(INTERCEPT_1, 30000);
+                    return;
+                }
+
+                if (IsSpellReady(ANGUISH_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                    opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                    (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 20)) && IsInBotParty(u))
+                {
+                    me->CastSpell(opponent, GetSpell(ANGUISH_1), false);
+                    SetSpellCooldown(ANGUISH_1, 5000);
+                    return;
+                }
+
+                if (IsSpellReady(CLEAVE_1, diff, false) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(CLEAVE_1), false);
+                    SetSpellCooldown(CLEAVE_1, 6000);
+                    return;
+                }
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(FIREBOLT_1);
+            InitSpellMap(BLOOD_PACT_1);
+            InitSpellMap(PHASE_SHIFT_1);
+            //InitSpellMap(FIRE_SHIELD_1);
+
+            InitSpellMap(TORMENT_1);
+            InitSpellMap(SACRIFICE_1);
+            InitSpellMap(CONSUME_SHADOWS_1);
+            InitSpellMap(SUFFERING_1);
+
+            InitSpellMap(LASH_OF_PAIN_1);
+            InitSpellMap(SOOTHING_KISS_1);
+            InitSpellMap(SEDUCTION_1);
+            InitSpellMap(LESSER_INVISIBILITY_1);
+
+            InitSpellMap(DEVOUR_MAGIC_1);
+            InitSpellMap(FEL_INTELLIGENCE_1);
+            InitSpellMap(SPELL_LOCK_1);
+            InitSpellMap(SHADOW_BITE_1);
+
+            InitSpellMap(ANGUISH_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(INTERCEPT_1);
+
+            InitSpellMap(SOUL_LINK_PET);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            uint8 lvl = me->GetLevel();
+            switch (myType)
+            {
+                case BOT_PET_FELGUARD:
+                    RefreshAura(DEMONIC_FRENZY);
+                    break;
+                default:
+                    break;
+            }
+
+            RefreshAura(AVOIDANCE, lvl >= 60 ? 1 : 0);
+        }
+
+    private:
+    };
+};
+
+void AddSC_warlock_bot_pets()
+{
+    new warlock_pet_bot();
+}
diff --git a/src/server/game/Combat/CombatManager.cpp b/src/server/game/Combat/CombatManager.cpp
index 0d396b7..95176da 100644
--- a/src/server/game/Combat/CombatManager.cpp
+++ b/src/server/game/Combat/CombatManager.cpp
@@ -21,6 +21,10 @@
 #include "CreatureAI.h"
 #include "Player.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 /*static*/ bool CombatManager::CanBeginCombat(Unit const* a, Unit const* b)
 {
     // Checks combat validity before initial reference creation.
@@ -192,9 +196,30 @@ bool CombatManager::SetInCombatWith(Unit* who)
     CombatReference* ref;
     if (_owner->IsControlledByPlayer() && who->IsControlledByPlayer())
         ref = new PvPCombatReference(_owner, who);
+    //npcbot: follow pvp rules
+    else if ((_owner->ToCreature() && _owner->ToCreature()->IsNPCBotOrPet() && who->IsControlledByPlayer()) ||
+        (who->ToCreature() && who->ToCreature()->IsNPCBotOrPet() && _owner->IsControlledByPlayer()) ||
+        (_owner->ToCreature() && _owner->ToCreature()->IsNPCBotOrPet() &&
+        who->ToCreature() && who->ToCreature()->IsNPCBotOrPet()))
+        ref = new PvPCombatReference(_owner, who);
+    //end npcbot
     else
         ref = new CombatReference(_owner, who);
 
+    //npcbot
+    /*
+    if (_owner->GetTypeId() == TYPEID_PLAYER && _owner->ToPlayer()->HaveBot())
+    {
+        BotMap const* map = _owner->ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            itr->second->SetInCombatWith(who);
+            if (Unit* botPet = itr->second->GetBotsPet())
+                botPet->SetInCombatWith(who);
+        }
+    }*/
+    //end npcbot
+
     // ...and insert it into both managers
     PutReference(who->GetGUID(), ref);
     who->GetCombatManager().PutReference(_owner->GetGUID(), ref);
diff --git a/src/server/game/Combat/ThreatManager.cpp b/src/server/game/Combat/ThreatManager.cpp
index dfdc24e..8367923 100644
--- a/src/server/game/Combat/ThreatManager.cpp
+++ b/src/server/game/Combat/ThreatManager.cpp
@@ -167,6 +167,11 @@ void ThreatReference::UnregisterAndFree()
             if (tWho->GetSummonerGUID().IsPlayer())
                 return false;
 
+    //npcbot - npcbots and their pets cannot have threatlist
+    if (cWho->IsNPCBot() || cWho->IsNPCBotPet())
+        return false;
+    //end npcbot
+
     return true;
 }
 
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index eb6ca3c..972a9c6 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -114,7 +114,7 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -335,7 +335,7 @@ void LoadDBCStores(const std::string& dataPath)
     LOAD_DBC(sHolidaysStore,                      "Holidays.dbc");
     LOAD_DBC(sItemStore,                          "Item.dbc");
     LOAD_DBC(sItemBagFamilyStore,                 "ItemBagFamily.dbc");
-    //LOAD_DBC(sItemDisplayInfoStore,               "ItemDisplayInfo.dbc");     -- not used currently
+    LOAD_DBC(sItemDisplayInfoStore,               "ItemDisplayInfo.dbc");
     //LOAD_DBC(sItemCondExtCostsStore,              "ItemCondExtCosts.dbc");
     LOAD_DBC(sItemExtendedCostStore,              "ItemExtendedCost.dbc");
     LOAD_DBC(sItemLimitCategoryStore,             "ItemLimitCategory.dbc");
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index f3974d0..cbf615f 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -144,7 +144,7 @@ TC_GAME_API extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptSto
 TC_GAME_API extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 TC_GAME_API extern DBCStorage <ItemEntry>                    sItemStore;
 TC_GAME_API extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
-//TC_GAME_API extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+TC_GAME_API extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;
 TC_GAME_API extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 TC_GAME_API extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 TC_GAME_API extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index ef4d316..910cd5f 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -40,6 +40,12 @@
 #include "World.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botcommon.h"
+#include "botmgr.h"
+#include "Chat.h"
+//end npcbot
+
 namespace lfg
 {
 
@@ -465,6 +471,46 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                         joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
                     ++memberCount;
                     players.insert(plrg->GetGUID());
+
+                    //npcbot
+                    if (!plrg->HaveBot())
+                        continue;
+                    //add npcbots
+                    BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (!grp->IsMember(itr->second->GetGUID()))
+                            continue;
+
+                        //disabled in config
+                        if (!BotMgr::IsNpcBotDungeonFinderEnabled())
+                        {
+                            (ChatHandler(plrg->GetSession())).SendSysMessage("Using npcbots in Dungeon Finder is restricted. Contact your administration.");
+
+                            if (plrg->GetGUID() != grp->GetLeaderGUID())
+                                if (Player* leader = ObjectAccessor::FindPlayer(grp->GetLeaderGUID()))
+                                    (ChatHandler(leader->GetSession())).PSendSysMessage("There is a npcbot in your group (owner: %s). Using npcbots in Dungeon Finder is restricted. Contact your administration.",
+                                        plrg->GetName().c_str());
+
+                            joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            break;
+                        }
+
+                        if (Creature* bot = ObjectAccessor::GetCreature(*plrg, itr->second->GetGUID()))
+                        {
+                            //if (!(bot->GetBotRoles() & ( 1 | 2 | 4 ))) //(BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL)
+                            //{
+                            //    //no valid roles - reqs are not met
+                            //    (ChatHandler(plrg->GetSession())).PSendSysMessage("Your bot %s does not have any viable roles assigned.", bot->GetName().c_str());
+                            //    joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            //    continue;
+                            //}
+
+                            ++memberCount;
+                            players.insert(bot->GetGUID());
+                        }
+                    }
+                    //end npcbot
                 }
             }
 
@@ -562,6 +608,9 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
         SetState(gguid, LFG_STATE_ROLECHECK);
         // Send update to player
         LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_JOIN_QUEUE, dungeons, comment);
+        //npcbot
+        std::map<ObjectGuid, uint8> brolemap;
+        //end npcbot
         for (GroupReference* itr = grp->GetFirstMember(); itr != nullptr; itr = itr->next())
         {
             if (Player* plrg = itr->GetSource())
@@ -575,10 +624,57 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                 if (!debugNames.empty())
                     debugNames.append(", ");
                 debugNames.append(plrg->GetName());
+
+                //npcbot
+                if (!plrg->HaveBot())
+                    continue;
+                //add npcbots
+                BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    ObjectGuid bguid = itr->second->GetGUID();
+                    if (players.find(bguid) == players.end() || !grp->IsMember(bguid))
+                        continue;
+
+                    Creature* bot = ObjectAccessor::GetCreature(*plrg, bguid);
+                    if (!bot)
+                        continue;
+
+                    SetState(bguid, LFG_STATE_ROLECHECK);
+                    if (!isContinue)
+                        SetSelectedDungeons(bguid, dungeons);
+                    roleCheck.roles[bguid] = 0;
+                    if (!debugNames.empty())
+                        debugNames.append(", ");
+                    debugNames.append(bot->GetName());
+
+                    //fill possible roles (as if player selected all roles possible for class)
+                    uint8 broles = PLAYER_ROLE_DAMAGE;
+                    if (bot->GetBotClass() == CLASS_WARRIOR || bot->GetBotClass() == CLASS_PALADIN ||
+                        bot->GetBotClass() == CLASS_DEATH_KNIGHT || bot->GetBotClass() == CLASS_DRUID ||
+                        (bot->GetBotRoles() & BOT_ROLE_TANK))
+                        broles |= PLAYER_ROLE_TANK;
+                    if (bot->GetBotClass() == CLASS_PRIEST || bot->GetBotClass() == CLASS_DRUID ||
+                        bot->GetBotClass() == CLASS_SHAMAN || bot->GetBotClass() == CLASS_PALADIN ||
+                        (bot->GetBotRoles() & BOT_ROLE_HEAL))
+                        broles |= PLAYER_ROLE_HEALER;
+                    //remove unneeded / occupied roles so players can go with role they choose
+                    if (roles & PLAYER_ROLE_TANK)
+                        broles &= ~PLAYER_ROLE_TANK;
+                    if (roles & PLAYER_ROLE_HEALER)
+                        broles &= ~PLAYER_ROLE_HEALER;
+
+                    brolemap[bguid] = broles;
+                }
+                //end npcbot
             }
         }
         // Update leader role
         UpdateRoleCheck(gguid, guid, roles);
+        //npcbot - update bots' roles
+        for (std::map<ObjectGuid, uint8>::const_iterator it = brolemap.begin(); it != brolemap.end(); ++it)
+            UpdateRoleCheck(gguid, it->first, it->second);
+        //end npcbot
     }
     else                                                   // Add player to queue
     {
@@ -958,6 +1054,63 @@ void LFGMgr::MakeNewGroup(LfgProposal const& proposal)
         if (!player)
             continue;
 
+        //npcbot - handle player's bots
+        if (player->HaveBot())
+        {
+            Group* group = player->GetGroup();
+            if (group && group != grp)
+                Player::RemoveFromGroup(group, pguid);
+
+            if (!grp)
+            {
+                grp = new Group();
+                grp->ConvertToLFG();
+                grp->Create(player);
+                ObjectGuid gguid = grp->GetGUID();
+                SetState(gguid, LFG_STATE_PROPOSAL);
+                sGroupMgr->AddGroup(grp);
+            }
+            else if (group != grp)
+                grp->AddMember(player);
+
+            grp->SetLfgRoles(pguid, proposal.players.find(pguid)->second.role);
+
+            // Add the cooldown spell if queued for a random dungeon
+            if (dungeon->type == LFG_TYPE_RANDOM)
+                player->CastSpell(player, LFG_SPELL_DUNGEON_COOLDOWN, false);
+
+            for (GuidList::const_iterator itr2 = players.begin(); itr2 != players.end(); ++itr2)
+            {
+                ObjectGuid bguid = (*itr2);
+                if (bguid.IsPlayer())
+                    continue;
+                Creature* bot = player->GetBotMgr()->GetBot(bguid);
+                if (!bot)
+                    continue;
+
+                player->GetBotMgr()->AddBotToGroup(bot);
+                grp->SetLfgRoles(bguid, proposal.players.find(bguid)->second.role);
+            }
+
+            if (grp->GetMembersCount() >= 5)
+            {
+                uint8 pcount = 0;
+                for (GroupReference const* gitr = grp->GetFirstMember(); gitr != nullptr; gitr = gitr->next())
+                    if (gitr->GetSource())
+                        ++pcount;
+                if (pcount <= 1)
+                {
+                    //only one player in group
+                    ChatHandler ch(player->GetSession());
+                    ch.SendSysMessage("You are the only player in your group, loot method set to Free For All");
+                    grp->SetLootMethod(FREE_FOR_ALL);
+                }
+            }
+
+            continue;
+        }
+        //end npcbot
+
         Group* group = player->GetGroup();
         if (group && group != grp)
             group->RemoveMember(player->GetGUID());
@@ -1032,6 +1185,29 @@ void LFGMgr::UpdateProposal(uint32 proposalId, ObjectGuid guid, bool accept)
     if (itProposalPlayer == proposal.players.end())
         return;
 
+    //npcbot - player accepted proposal
+    //make its bots accept too
+    if (accept && guid.IsPlayer())
+    {
+        if (Player* player = ObjectAccessor::FindConnectedPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                for (LfgProposalPlayerContainer::const_iterator itPlayers = proposal.players.begin(); itPlayers != proposal.players.end(); ++itPlayers)
+                {
+                    ObjectGuid bguid = itPlayers->first;
+                    if (bguid.IsPlayer())
+                        continue;
+                    if (!player->GetBotMgr()->GetBot(bguid))
+                        continue;
+
+                    UpdateProposal(proposalId, bguid, accept);
+                }
+            }
+        }
+    }
+    //end npcbot
+
     LfgProposalPlayer& player = itProposalPlayer->second;
     player.accept = LfgAnswer(accept);
 
diff --git a/src/server/game/DungeonFinding/LFGScripts.cpp b/src/server/game/DungeonFinding/LFGScripts.cpp
index 75dd4ab..4cb80ff 100644
--- a/src/server/game/DungeonFinding/LFGScripts.cpp
+++ b/src/server/game/DungeonFinding/LFGScripts.cpp
@@ -106,6 +106,7 @@ void LFGPlayerScript::OnMapChanged(Player* player)
     {
         Group* group = player->GetGroup();
         if (group && group->GetMembersCount() == 1)
+        if (!player->GetSession()->PlayerLoading())
         {
             sLFGMgr->LeaveLfg(group->GetGUID());
             group->Disband();
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 44596a1..78a4138 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -53,6 +53,11 @@
 #include "WorldPacket.h"
 #include <G3D/g3dmath.h>
 
+//npcbot
+#include "bot_ai.h"
+#include "bpet_ai.h"
+//end npcbot
+
 std::string CreatureMovementData::ToString() const
 {
     char const* const GroundStates[] = { "None", "Run", "Hover" };
@@ -265,6 +270,11 @@ Creature::Creature(bool isWorldObject): Unit(isWorldObject), MapObject(), m_grou
 
     ResetLootMode(); // restore default loot mode
     m_isTempWorldObject = false;
+
+    //npcbot
+    bot_AI = nullptr;
+    bot_pet_AI = nullptr;
+    //end npcbot
 }
 
 void Creature::AddToWorld()
@@ -650,6 +660,29 @@ void Creature::SetPhaseMask(uint32 newPhaseMask, bool update)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (bot_AI)
+    {
+        if (!bot_AI->canUpdate)
+        {
+            return;
+        }
+
+        bot_AI->CommonTimers(diff);
+    }
+    else if (bot_pet_AI)
+    {
+        if (!bot_pet_AI->canUpdate)
+        {
+            //needed for delayed unsummon
+            m_Events.Update(diff);
+            return;
+        }
+
+        bot_pet_AI->CommonTimers(diff);
+    }
+    //end npcbot
+
     if (IsAIEnabled() && m_triggerJustAppeared && m_deathState != DEAD)
     {
         if (m_respawnCompatibilityMode && m_vehicleKit)
@@ -672,6 +705,10 @@ void Creature::Update(uint32 diff)
             break;
         case DEAD:
         {
+            //npcbot
+            if (bot_AI || bot_pet_AI)
+                break;
+            //end npcbot
             if (!m_respawnCompatibilityMode)
             {
                 TC_LOG_ERROR("entities.unit", "Creature %s in wrong state: DEAD (3)", GetGUID().ToString().c_str());
@@ -724,6 +761,16 @@ void Creature::Update(uint32 diff)
             if (IsEngaged())
                 Unit::AIUpdateTick(diff);
 
+            //npcbot: update dead bots
+            if (bot_AI)
+            {
+                bot_AI->UpdateDeadAI(diff);
+                break;
+            }
+            else if (bot_pet_AI)
+                break;
+            //end npcbot
+
             if (m_groupLootTimer && lootingGroupLowGUID)
             {
                 if (m_groupLootTimer <= diff)
@@ -738,6 +785,10 @@ void Creature::Update(uint32 diff)
             }
             else if (m_corpseRemoveTime <= GameTime::GetGameTime())
             {
+                //npcbot: do not remove corpse
+                if (IsNPCBotOrPet())
+                    break;
+                //end npcbot
                 RemoveCorpse(false);
                 TC_LOG_DEBUG("entities.unit", "Removing corpse... %u ", GetUInt32Value(OBJECT_FIELD_ENTRY));
             }
@@ -749,6 +800,9 @@ void Creature::Update(uint32 diff)
 
             // creature can be dead after Unit::Update call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
+            //npcbot - skip dead state for bots (handled by AI)
+            if (!bot_AI && !bot_pet_AI)
+            //end npcbot
             if (!IsAlive())
                 break;
 
@@ -800,8 +854,18 @@ void Creature::Update(uint32 diff)
                 }
             }
 
+            if (bot_AI)
+            {
+                //TC_LOG_ERROR("entities.unit", "creature update for %u", m_spawnId);
+            }
+
             Unit::AIUpdateTick(diff);
 
+            //npcbot: skip regeneration
+            if (bot_AI || bot_pet_AI)
+                break;
+            //end npcbot
+
             // creature can be dead after UpdateAI call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
             if (!IsAlive())
@@ -987,6 +1051,11 @@ bool Creature::AIM_Create(CreatureAI* ai /*= nullptr*/)
 {
     Motion_Initialize();
 
+    //npcbot: prevent overriding bot_AI
+    if (bot_AI || bot_pet_AI)
+        return false;
+    //end npcbot
+
     SetAI(ai ? ai : FactorySelector::SelectAI(this));
 
     return true;
@@ -1674,6 +1743,24 @@ bool Creature::LoadFromDB(ObjectGuid::LowType spawnId, Map* map, bool addToMap,
     // checked at creature_template loading
     m_defaultMovementType = MovementGeneratorType(data->movementType);
 
+    //npcbot
+    if (IsNPCBot())
+    {
+        //prevent loading npcbot twice (grid unload/load case)
+        if (sWorld->GetMaxPlayerCount() > 0)
+            return false;
+
+        TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+        ASSERT(!IsInWorld());
+
+        //don't allow removing dead bot's corpse
+        m_respawnCompatibilityMode = true;
+        m_corpseDelay = 0;
+        m_respawnDelay = 0;
+        setActive(true);
+    }
+    //end npcbot
+
     if (addToMap && !GetMap()->AddToMap(this))
         return false;
     return true;
@@ -1687,6 +1774,11 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -1833,6 +1925,11 @@ bool Creature::IsInvisibleDueToDespawn() const
     if (IsAlive() || isDying() || m_corpseRemoveTime > GameTime::GetGameTime())
         return false;
 
+    //npcbot
+    if (bot_AI || bot_pet_AI)
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -1947,6 +2044,11 @@ void Creature::setDeathState(DeathState s)
 
     if (s == JUST_DIED)
     {
+        //npcbot
+        if (bot_AI)
+            bot_AI->UnsummonAll();
+        //end npcbot
+
         m_corpseRemoveTime = GameTime::GetGameTime() + m_corpseDelay;
 
         uint32 respawnDelay = m_respawnDelay;
@@ -2417,6 +2519,11 @@ void Creature::SaveRespawnTime(uint32 forceDelay)
     if (IsSummon() || !m_spawnId || (m_creatureData && !m_creatureData->dbData))
         return;
 
+    //npcbots: do not save respawn time for bots
+    if (IsNPCBotOrPet())
+        return;
+    //end npcbots
+
     if (m_respawnCompatibilityMode)
     {
         RespawnInfo ri;
@@ -2588,6 +2695,16 @@ void Creature::SendZoneUnderAttackMessage(Player* attacker)
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    //npcbot - bot block value is fully calculated into botAI
+    if (bot_AI)
+    {
+        uint32 blockValue = bot_AI->GetShieldBlockValue();
+        blockValue += GetTotalAuraModifier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE);
+        blockValue *= GetTotalAuraMultiplier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE_PCT);
+        return uint32(blockValue);
+    }
+    //end npcbot
+
     return (GetLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -3186,6 +3303,13 @@ void Creature::ReleaseSpellFocus(Spell const* focusSpell, bool withDelay)
         if (!HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_DISABLE_TURN))
             ReacquireSpellFocusTarget();
     }
+    //npcbot: bots and botpets do not use delay
+    else if (IsNPCBot() || IsNPCBotPet())
+    {
+        if (!HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_DISABLE_TURN))
+            ReacquireSpellFocusTarget();
+    }
+    //end npcbot
     else // don't allow re-target right away to prevent visual bugs
         _spellFocusInfo.Delay = withDelay ? 1000 : 1;
 
@@ -3347,3 +3471,322 @@ std::string Creature::GetDebugInfo() const
         << " WaypointPath: " << GetWaypointPath() << " SpawnId: " << GetSpawnId();
     return sstr.str();
 }
+
+//NPCBOT
+bool Creature::LoadBotCreatureFromDB(ObjectGuid::LowType spawnId, Map* map, bool addToMap)
+{
+    CreatureData const* data = sObjectMgr->GetCreatureData(spawnId);
+    if (!data)
+    {
+        TC_LOG_ERROR("sql.sql", "Bot creature (GUID: %u) not found in table `creature`, can't load. ", spawnId);
+        return false;
+    }
+
+    m_spawnId = spawnId;
+    ASSERT(map->GetInstanceId() == 0);
+
+    m_respawnCompatibilityMode = true;
+    m_creatureData = data;
+    m_wanderDistance = data->wander_distance;
+
+    if (!Create(map->GenerateLowGuid<HighGuid::Unit>(), map, data->phaseMask, data->id, data->spawnPoint, data, 0U , !m_respawnCompatibilityMode))
+        return false;
+
+    //We should set first home position, because then AI calls home movement
+    SetHomePosition(*this);
+
+    m_deathState = ALIVE;
+    m_respawnTime = 0;
+
+    SetSpawnHealth();
+
+    // checked at creature_template loading
+    m_defaultMovementType = MovementGeneratorType(data->movementType);
+
+    TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+    ASSERT(!IsInWorld());
+
+    m_corpseDelay = 0;
+    m_respawnDelay = 0;
+    setActive(true);
+
+    if (addToMap && !GetMap()->AddToMap(this))
+        return false;
+
+    return true;
+}
+
+uint8 Creature::GetBotClass() const
+{
+    return bot_AI ? bot_AI->GetBotClass() : GetClass();
+}
+
+Player* Creature::GetBotOwner() const
+{
+    return bot_AI ? bot_AI->GetBotOwner() : bot_pet_AI ? bot_pet_AI->GetPetsOwner()->GetBotOwner() : nullptr;
+}
+Unit* Creature::GetBotsPet() const
+{
+    return bot_AI ? bot_AI->GetBotsPet() : nullptr;
+}
+
+bool Creature::IsNPCBot() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT;
+}
+
+bool Creature::IsNPCBotPet() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT_PET;
+}
+
+bool Creature::IsNPCBotOrPet() const
+{
+    return IsNPCBot() || IsNPCBotPet();
+}
+
+bool Creature::IsFreeBot() const
+{
+    return bot_AI ? bot_AI->IAmFree() : bot_pet_AI ? bot_pet_AI->IAmFree() : false;
+}
+
+uint16 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    else if (bot_pet_AI)
+        bot_pet_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+}
+void Creature::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+}
+void Creature::ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCostMods(spellInfo, cost);
+}
+void Creature::ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCastTimeMods(spellInfo, casttime);
+}
+void Creature::ApplyCreatureSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellRadiusMods(spellInfo, radius);
+}
+void Creature::ApplyCreatureSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellRangeMods(spellInfo, maxrange);
+}
+void Creature::ApplyCreatureSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellMaxTargetsMods(spellInfo, targets);
+}
+void Creature::ApplyCreatureSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellChanceOfSuccessMods(spellInfo, chance);
+}
+
+void Creature::ApplyCreatureEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotEffectMods(spellInfo, effIndex, value);
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::BotStopMovement()
+{
+    if (IsInWorld())
+    {
+        GetMotionMaster()->Clear();
+        GetMotionMaster()->MoveIdle();
+    }
+    StopMoving();
+    DisableSpline();
+}
+
+bool Creature::CanParry() const
+{
+    return bot_AI ? bot_AI->CanParry() : true;
+}
+
+bool Creature::CanDodge() const
+{
+    return bot_AI ? bot_AI->CanDodge() : true;
+}
+//unused
+bool Creature::CanBlock() const
+{
+    return bot_AI ? bot_AI->CanBlock() : true;
+}
+//unused
+bool Creature::CanCrit() const
+{
+    return bot_AI ? bot_AI->CanCrit() : true;
+}
+bool Creature::CanMiss() const
+{
+    return bot_AI ? bot_AI->CanMiss() : true;
+}
+
+float Creature::GetCreatureParryChance() const
+{
+    return bot_AI ? bot_AI->GetBotParryChance() : 5.0f;
+}
+float Creature::GetCreatureDodgeChance() const
+{
+    return bot_AI ? bot_AI->GetBotDodgeChance() : 5.0f;
+}
+float Creature::GetCreatureBlockChance() const
+{
+    return bot_AI ? bot_AI->GetBotBlockChance() : 5.0f;
+}
+float Creature::GetCreatureCritChance() const
+{
+    return bot_AI ? bot_AI->GetBotCritChance() : 0.0f;
+}
+float Creature::GetCreatureMissChance() const
+{
+    return bot_AI ? bot_AI->GetBotMissChance() : 5.0f;
+}
+float Creature::GetCreatureArmorPenetrationCoef() const
+{
+    return bot_AI ? bot_AI->GetBotArmorPenetrationCoef() : 0.0f;
+}
+uint32 Creature::GetCreatureExpertise() const
+{
+    return bot_AI ? bot_AI->GetBotExpertise() : 0;
+}
+uint32 Creature::GetCreatureSpellPenetration() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPenetration() : 0;
+}
+uint32 Creature::GetCreatureSpellPower() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPower() : 0;
+}
+uint32 Creature::GetCreatureDefense() const
+{
+    return bot_AI ? bot_AI->GetBotDefense() : GetMaxSkillValueForLevel();
+}
+int32 Creature::GetCreatureResistanceBonus(SpellSchoolMask mask) const
+{
+    return bot_AI ? bot_AI->GetBotResistanceBonus(mask) : 0;
+}
+
+uint8 Creature::GetCreatureComboPoints() const
+{
+    return bot_AI ? bot_AI->GetBotComboPoints() : 0;
+}
+
+float Creature::GetCreatureAmmoDPS() const
+{
+    return bot_AI ? bot_AI->GetBotAmmoDPS() : 0.0f;
+}
+
+bool Creature::IsTempBot() const
+{
+    return bot_AI && bot_AI->IsTempBot();
+}
+
+MeleeHitOutcome Creature::BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    return bot_AI ? bot_AI->BotRollCustomMeleeOutcomeAgainst(victim, attType) : RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void Creature::CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx)
+{
+    if (bot_AI)
+        bot_AI->CastBotItemCombatSpell(target, attType, procVictim, procEx);
+}
+
+void Creature::OnSpellGo(Spell const* spell)
+{
+    if (bot_AI)
+        bot_AI->OnBotSpellGo(spell);
+    else if (bot_pet_AI)
+        bot_pet_AI->OnBotPetSpellGo(spell);
+}
+
+bool Creature::HasSpellCooldown(uint32 spell_id) const
+{
+    if (bot_AI)
+        return !bot_AI->IsSpellReady(sSpellMgr->GetSpellInfo(spell_id)->GetFirstRankSpell()->Id, bot_AI->GetLastDiff(), false);
+    else if (bot_pet_AI)
+        return !bot_pet_AI->IsSpellReady(sSpellMgr->GetSpellInfo(spell_id)->GetFirstRankSpell()->Id, bot_pet_AI->GetLastDiff(), false);
+
+    return false;
+}
+void Creature::AddBotSpellCooldown(uint32 spellId, uint32 cooldown)
+{
+    if (bot_AI)
+        bot_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+    else if (bot_pet_AI)
+        bot_pet_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+}
+void Creature::ReleaseBotSpellCooldown(uint32 spellId)
+{
+    if (bot_AI)
+        bot_AI->ReleaseSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id);
+    else if (bot_pet_AI)
+        bot_pet_AI->ReleaseSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id);
+}
+
+void Creature::SpendBotRunes(SpellInfo const* spellInfo, bool didHit)
+{
+    if (bot_AI)
+        bot_AI->SpendRunes(spellInfo, didHit);
+}
+
+//equips
+Item* Creature::GetBotEquips(uint8 slot) const
+{
+    return bot_AI ? bot_AI->GetEquips(slot) : nullptr;
+}
+Item* Creature::GetBotEquipsByGuid(ObjectGuid itemGuid) const
+{
+    return bot_AI ? bot_AI->GetEquipsByGuid(itemGuid) : nullptr;
+}
+
+//static
+bool Creature::IsBotCustomSpell(uint32 spellId)
+{
+    return bot_ai::IsBotCustomSpell(spellId);
+}
+//END NPCBOT
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 32c9a89..dc0431d 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -27,6 +27,11 @@
 #include "MapObject.h"
 #include <list>
 
+// npcbot
+class bot_ai;
+class bot_pet_ai;
+//end npcbot
+
 class CreatureAI;
 class CreatureGroup;
 class Group;
@@ -358,6 +363,75 @@ class TC_GAME_API Creature : public Unit, public GridObject<Creature>, public Ma
 
         std::string GetDebugInfo() const override;
 
+        //NPCBots
+        bool LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap = true);
+        Player* GetBotOwner() const;
+        Unit* GetBotsPet() const;
+        bool IsNPCBot() const;
+        bool IsNPCBotPet() const;
+        bool IsNPCBotOrPet() const;
+        bool IsFreeBot() const;
+        uint8 GetBotClass() const;
+        uint16 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_pet_ai* GetBotPetAI() const { return bot_pet_AI; }
+        void SetBotAI(bot_ai* ai) { bot_AI = ai; }
+        void SetBotPetAI(bot_pet_ai* ai) { bot_pet_AI = ai; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyCreatureSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const;
+        void ApplyCreatureSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const;
+        void ApplyCreatureSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const;
+        void ApplyCreatureSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const;
+        void ApplyCreatureEffectMods(SpellInfo const* spellInfo, uint8 effIndex, float& value) const;
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void BotStopMovement();
+
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanBlock() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+
+        float GetCreatureParryChance() const;
+        float GetCreatureDodgeChance() const;
+        float GetCreatureBlockChance() const;
+        float GetCreatureCritChance() const;
+        float GetCreatureMissChance() const;
+        float GetCreatureArmorPenetrationCoef() const;
+        uint32 GetCreatureExpertise() const;
+        uint32 GetCreatureSpellPenetration() const;
+        uint32 GetCreatureSpellPower() const;
+        uint32 GetCreatureDefense() const;
+        int32 GetCreatureResistanceBonus(SpellSchoolMask mask) const;
+        uint8 GetCreatureComboPoints() const;
+        float GetCreatureAmmoDPS() const;
+
+        bool IsTempBot() const;
+
+        MeleeHitOutcome BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        void CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx);
+
+        void OnSpellGo(Spell const* spell);
+        bool HasSpellCooldown(uint32 spellId) const;
+        void AddBotSpellCooldown(uint32 spellId, uint32 cooldown);
+        void ReleaseBotSpellCooldown(uint32 spellId);
+
+        void SpendBotRunes(SpellInfo const* spellInfo, bool didHit);
+
+        Item* GetBotEquips(uint8 slot) const;
+        Item* GetBotEquipsByGuid(ObjectGuid itemGuid) const;
+
+        static bool IsBotCustomSpell(uint32 spellId);
+        //End NPCBots
+
     protected:
         bool CreateFromProto(ObjectGuid::LowType guidlow, uint32 entry, CreatureData const* data = nullptr, uint32 vehId = 0);
         bool InitEntry(uint32 entry, CreatureData const* data = nullptr);
@@ -411,6 +485,11 @@ class TC_GAME_API Creature : public Unit, public GridObject<Creature>, public Ma
         bool CanAlwaysSee(WorldObject const* obj) const override;
 
     private:
+        //bot system
+        bot_ai* bot_AI;
+        bot_pet_ai* bot_pet_AI;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0, Seconds forceRespawnTimer = 0s);
         bool CheckNoGrayAggroConfig(uint32 playerLevel, uint32 creatureLevel) const; // No aggro from gray creatures
 
diff --git a/src/server/game/Entities/Creature/CreatureData.h b/src/server/game/Entities/Creature/CreatureData.h
index cc10b4d..57d0ec0 100644
--- a/src/server/game/Entities/Creature/CreatureData.h
+++ b/src/server/game/Entities/Creature/CreatureData.h
@@ -60,8 +60,8 @@ enum CreatureFlagsExtra : uint32
     CREATURE_FLAG_EXTRA_UNUSED_23            = 0x00800000,
     CREATURE_FLAG_EXTRA_UNUSED_24            = 0x01000000,
     CREATURE_FLAG_EXTRA_UNUSED_25            = 0x02000000,
-    CREATURE_FLAG_EXTRA_UNUSED_26            = 0x04000000,
-    CREATURE_FLAG_EXTRA_UNUSED_27            = 0x08000000,
+    CREATURE_FLAG_EXTRA_NPCBOT               = 0x04000000,       // custom flag for NPCBots (not confirmed safe)
+    CREATURE_FLAG_EXTRA_NPCBOT_PET           = 0x08000000,       // custom flag for NPCBot pets (not confirmed safe)
     CREATURE_FLAG_EXTRA_DUNGEON_BOSS         = 0x10000000,       // creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)
     CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING   = 0x20000000,       // creature ignore pathfinding
     CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK   = 0x40000000,       // creature is immune to knockback effects
@@ -70,7 +70,7 @@ enum CreatureFlagsExtra : uint32
     // Masks
     CREATURE_FLAG_EXTRA_UNUSED               = (CREATURE_FLAG_EXTRA_UNUSED_16 | CREATURE_FLAG_EXTRA_UNUSED_22 |
                                                 CREATURE_FLAG_EXTRA_UNUSED_23 | CREATURE_FLAG_EXTRA_UNUSED_24 | CREATURE_FLAG_EXTRA_UNUSED_25 |
-                                                CREATURE_FLAG_EXTRA_UNUSED_26 | CREATURE_FLAG_EXTRA_UNUSED_27 | CREATURE_FLAG_EXTRA_UNUSED_31), // SKIP
+                                                CREATURE_FLAG_EXTRA_UNUSED_31), // SKIP
 
     CREATURE_FLAG_EXTRA_DB_ALLOWED           = (0xFFFFFFFF & ~(CREATURE_FLAG_EXTRA_UNUSED | CREATURE_FLAG_EXTRA_DUNGEON_BOSS)) // SKIP
 };
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 5f692e6..f5ac0d4 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -196,6 +196,18 @@ void TempSummon::InitStats(uint32 duration)
     if (!m_Properties)
         return;
 
+    //npcbot: skip deleting/reassigning player totems
+    //normally no creatorGUID is assigned at this point, perform full check anyway for compatibilty reasons
+    bool botTotemCast = false;
+    if (owner && m_Properties->Slot && m_Properties->Slot >= SUMMON_SLOT_TOTEM_FIRE && m_Properties->Slot < MAX_TOTEM_SLOT &&
+        GetCreatorGUID() && GetCreatorGUID().IsCreature())
+    {
+        Creature* bot = ObjectAccessor::GetCreature(*owner, GetCreatorGUID());
+        if (bot && bot->IsNPCBot())
+            botTotemCast = true;
+    }
+    if (!botTotemCast)
+    //end npcbot
     if (owner)
     {
         if (uint32 slot = m_Properties->Slot)
@@ -272,6 +284,19 @@ void TempSummon::UnSummon(uint32 msTime)
             owner->ToGameObject()->AI()->SummonedCreatureDespawn(this);
     }
 
+    //npcbot
+    //if (IsNPCBot())
+    //{
+    //    //TC_LOG_ERROR("entities.player", "TempSummon::UnSummon(): Trying to unsummon Bot %s (guidLow: %u owner: %s)", GetName().c_str(), GetGUIDLow(), GetBotOwner()->GetName().c_str());
+    //    if (IsTempBot())
+    //        if (IS_CREATURE_GUID(GetCreatorGUID()))
+    //            if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+    //                if (bot->ToCreature()->IsNPCBot())
+    //                    bot->ToCreature()->OnBotDespawn(this);
+    //    return;
+    //}
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp b/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp
index b7e8c77..a2d9554 100644
--- a/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp
+++ b/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp
@@ -57,8 +57,8 @@ TC_API_EXPORT EnumText EnumUtils<CreatureFlagsExtra>::ToString(CreatureFlagsExtr
         case CREATURE_FLAG_EXTRA_UNUSED_23: return { "CREATURE_FLAG_EXTRA_UNUSED_23", "CREATURE_FLAG_EXTRA_UNUSED_23", "" };
         case CREATURE_FLAG_EXTRA_UNUSED_24: return { "CREATURE_FLAG_EXTRA_UNUSED_24", "CREATURE_FLAG_EXTRA_UNUSED_24", "" };
         case CREATURE_FLAG_EXTRA_UNUSED_25: return { "CREATURE_FLAG_EXTRA_UNUSED_25", "CREATURE_FLAG_EXTRA_UNUSED_25", "" };
-        case CREATURE_FLAG_EXTRA_UNUSED_26: return { "CREATURE_FLAG_EXTRA_UNUSED_26", "CREATURE_FLAG_EXTRA_UNUSED_26", "" };
-        case CREATURE_FLAG_EXTRA_UNUSED_27: return { "CREATURE_FLAG_EXTRA_UNUSED_27", "CREATURE_FLAG_EXTRA_UNUSED_27", "" };
+        case CREATURE_FLAG_EXTRA_NPCBOT: return { "CREATURE_FLAG_EXTRA_NPCBOT", "CREATURE_FLAG_EXTRA_NPCBOT", "creature is a NPCBot" };
+        case CREATURE_FLAG_EXTRA_NPCBOT_PET: return { "CREATURE_FLAG_EXTRA_NPCBOT_PET", "CREATURE_FLAG_EXTRA_NPCBOT_PET", "creature is a NPCBot's pet" };
         case CREATURE_FLAG_EXTRA_DUNGEON_BOSS: return { "CREATURE_FLAG_EXTRA_DUNGEON_BOSS", "CREATURE_FLAG_EXTRA_DUNGEON_BOSS", "creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)" };
         case CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING: return { "CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING", "CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING", "creature ignore pathfinding" };
         case CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK: return { "CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK", "CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK", "creature is immune to knockback effects" };
@@ -101,8 +101,8 @@ TC_API_EXPORT CreatureFlagsExtra EnumUtils<CreatureFlagsExtra>::FromIndex(size_t
         case 23: return CREATURE_FLAG_EXTRA_UNUSED_23;
         case 24: return CREATURE_FLAG_EXTRA_UNUSED_24;
         case 25: return CREATURE_FLAG_EXTRA_UNUSED_25;
-        case 26: return CREATURE_FLAG_EXTRA_UNUSED_26;
-        case 27: return CREATURE_FLAG_EXTRA_UNUSED_27;
+        case 26: return CREATURE_FLAG_EXTRA_NPCBOT;
+        case 27: return CREATURE_FLAG_EXTRA_NPCBOT_PET;
         case 28: return CREATURE_FLAG_EXTRA_DUNGEON_BOSS;
         case 29: return CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING;
         case 30: return CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK;
@@ -142,8 +142,8 @@ TC_API_EXPORT size_t EnumUtils<CreatureFlagsExtra>::ToIndex(CreatureFlagsExtra v
         case CREATURE_FLAG_EXTRA_UNUSED_23: return 23;
         case CREATURE_FLAG_EXTRA_UNUSED_24: return 24;
         case CREATURE_FLAG_EXTRA_UNUSED_25: return 25;
-        case CREATURE_FLAG_EXTRA_UNUSED_26: return 26;
-        case CREATURE_FLAG_EXTRA_UNUSED_27: return 27;
+        case CREATURE_FLAG_EXTRA_NPCBOT: return 26;
+        case CREATURE_FLAG_EXTRA_NPCBOT_PET: return 27;
         case CREATURE_FLAG_EXTRA_DUNGEON_BOSS: return 28;
         case CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING: return 29;
         case CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK: return 30;
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index a1bdca5..8656496 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1004,6 +1004,11 @@ void WorldObject::setActive(bool on)
     if (GetTypeId() == TYPEID_PLAYER)
         return;
 
+    //npcbot: bots should never be removed from active
+    if (on == false && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return;
+    //end npcbot
+
     m_isActive = on;
 
     if (on && !IsInWorld())
@@ -1641,6 +1646,9 @@ bool WorldObject::CanDetect(WorldObject const* obj, bool ignoreStealth, bool che
 {
     WorldObject const* seer = this;
 
+    //npcbot: master's invisibility should not affect bots' sight
+    if (!(GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot()))
+    //end npcbot
     // Pets don't have detection, they use the detection of their masters
     if (Unit const* thisUnit = ToUnit())
         if (Unit* controller = thisUnit->GetCharmerOrOwner())
@@ -1916,6 +1924,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summonerUnit);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summonerUnit);
             break;
         case UNIT_MASK_MINION:
@@ -1929,6 +1942,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
         return nullptr;
     }
 
+    //npcbot: totem emul step 2
+    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+        summon->SetCreatorGUID(summoner->GetGUID()); // see TempSummon::InitStats()
+    //end npcbot
+
     summon->SetUInt32Value(UNIT_CREATED_BY_SPELL, spellId);
 
     summon->SetHomePosition(pos);
@@ -1937,6 +1955,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 3
+    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+        summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     // call MoveInLineOfSight for nearby creatures
     Trinity::AIRelocationNotifier notifier(*summon);
     Cell::VisitAllObjects(summon, notifier, GetVisibilityRange());
@@ -2264,12 +2287,23 @@ float WorldObject::ApplyEffectModifiers(SpellInfo const* spellInfo, uint8 effInd
                 break;
         }
     }
+
+    //npcbot: handle effect mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyCreatureEffectMods(spellInfo, effIndex, value);
+    //end npcbot
+
     return value;
 }
 
 int32 WorldObject::CalcSpellDuration(SpellInfo const* spellInfo) const
 {
     uint8 comboPoints = 0;
+    //npcbot
+    if (ToCreature() && ToCreature()->IsNPCBot())
+        comboPoints = ToCreature()->GetCreatureComboPoints();
+    else
+    //end npcbot
     if (Unit const* unit = ToUnit())
         comboPoints = unit->GetComboPoints();
 
@@ -2388,6 +2422,11 @@ void WorldObject::ModSpellCastTime(SpellInfo const* spellInfo, int32& castTime,
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, castTime, spell);
 
+    //npcbot - apply bot spell cast time mods
+    if (castTime > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellInfo, castTime);
+    //end npcbot
+
     Unit const* unitCaster = ToUnit();
     if (!unitCaster)
         return;
@@ -2478,6 +2517,11 @@ SpellMissInfo WorldObject::MagicSpellHitResult(Unit* victim, SpellInfo const* sp
     if (Unit const* unit = ToUnit())
         HitChance += int32(unit->m_modSpellHitChance * 100.0f);
 
+    //npcbot: spell hit chance bonus
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        HitChance -= int32(ToCreature()->GetCreatureMissChance() * 100.f);
+    //end npcbot
+
     RoundToInterval(HitChance, 0, 10000);
 
     int32 tmp = 10000 - HitChance;
@@ -2803,6 +2847,15 @@ SpellCastResult WorldObject::CastSpell(SpellCastTargets const& targets, uint32 s
         return SPELL_FAILED_SPELL_UNAVAILABLE;
     }
 
+    //npcbot
+    if (Creature::IsBotCustomSpell(spellId) && !(ToCreature() && (ToCreature()->IsNPCBot() || ToCreature()->IsNPCBotPet())))
+    {
+        TC_LOG_ERROR("entities.unit", "CastSpell: NpcBot system custom spell %u by caster: %s %u), aborted. Please report",
+            spellId, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUID().GetCounter() : GetEntry()));
+        return SPELL_FAILED_SPELL_UNAVAILABLE;
+    }
+    //end npcbot
+
     Spell* spell = new Spell(this, info, args.TriggerFlags, args.OriginalCaster);
     for (auto const& pair : args.SpellValueOverrides)
         spell->SetSpellValue(pair.first, pair.second);
@@ -2857,6 +2910,11 @@ bool WorldObject::IsValidAttackTarget(WorldObject const* target, SpellInfo const
     if (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->IsGameMaster())
         return false;
 
+    //npcbot: can't attack unit if controlled by a GM (bots, pets, possible others)
+    if (unitTarget && unitTarget->IsControlledByPlayer() && unitTarget->GetFaction() == 35)
+        return false;
+    //end npcbot
+
     Unit const* unit = ToUnit();
     // visibility checks (only units)
     if (unit)
@@ -2908,6 +2966,14 @@ bool WorldObject::IsValidAttackTarget(WorldObject const* target, SpellInfo const
             return false;
     }
 
+    //npcbot: CvC case fix for bots, still a TODO
+    if (unit && unitTarget && !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED) &&
+        !target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED) &&
+        ((GetTypeId() == TYPEID_UNIT && (ToCreature()->IsNPCBot() || ToCreature()->IsNPCBotPet())) ||
+        (target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->IsNPCBot() || target->ToCreature()->IsNPCBotPet()))))
+        return GetReactionTo(target) <= REP_NEUTRAL || target->GetReactionTo(this) <= REP_NEUTRAL;
+    //end npcbot
+
     // CvC case - can attack each other only when one of them is hostile
     if (unit && !HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED) && unitTarget && !unitTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED))
         return IsHostileTo(unitTarget) || unitTarget->IsHostileTo(this);
diff --git a/src/server/game/Entities/Player/KillRewarder.cpp b/src/server/game/Entities/Player/KillRewarder.cpp
index 65b9fff..37c8714 100644
--- a/src/server/game/Entities/Player/KillRewarder.cpp
+++ b/src/server/game/Entities/Player/KillRewarder.cpp
@@ -26,6 +26,10 @@
 #include "Pet.h"
 #include "Player.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
  // == KillRewarder ====================================================
  // KillRewarder encapsulates logic of rewarding player upon kill with:
  // * XP;
@@ -153,6 +157,17 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         // 4.2.2. Apply auras modifying rewarded XP (SPELL_AURA_MOD_XP_PCT).
         xp *= player->GetTotalAuraMultiplier(SPELL_AURA_MOD_XP_PCT);
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_reduction = BotMgr::GetNpcBotXpReduction())
+            {
+                uint32 ratePct = std::max<int32>(100 - ((player->GetNpcBotsCount() - 1) * xp_reduction), 10);
+                xp = xp * ratePct / 100;
+            }
+        }
+        //end npcbot
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index bee51fe..e0ab63c 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -102,6 +102,11 @@
 #include "WorldSession.h"
 #include "WorldStatePackets.h"
 
+//npcbot
+#include "botmgr.h"
+#include "botdatamgr.h"
+//end npcbot
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -406,6 +411,10 @@ Player::Player(WorldSession* session): Unit(true)
     m_reputationMgr = new ReputationMgr(this);
 
     m_groupUpdateTimer.Reset(5000);
+
+    /////////////// NPCBot System //////////////////
+    _botMgr = nullptr;
+    ///////////// End NPCBot System ////////////////
 }
 
 Player::~Player()
@@ -442,6 +451,14 @@ Player::~Player()
     delete m_reputationMgr;
     delete _cinematicMgr;
 
+    //npcbot
+    if (_botMgr)
+    {
+        delete _botMgr;
+        _botMgr = nullptr;
+    }
+    //end npcbot
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1351,6 +1368,10 @@ void Player::Update(uint32 p_time)
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
 
+    //NpcBot mod: Update
+    if (_botMgr)
+        _botMgr->Update(p_time);
+    //end Npcbot
 }
 
 void Player::setDeathState(DeathState s)
@@ -1798,6 +1819,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
+            //bot: teleport npcbots
+            if (HaveBot())
+                _botMgr->OnTeleportFar(mapid, x, y, z, orientation);
+            //end bot
+
             // remove all dyn objects
             RemoveAllDynObjects();
 
@@ -1989,6 +2015,25 @@ bool Player::IsImmunedToSpellEffect(SpellInfo const* spellInfo, uint32 index, Wo
     return Unit::IsImmunedToSpellEffect(spellInfo, index, caster);
 }
 
+//NPCBOT
+bool Player::HaveBot() const
+{
+    return _botMgr && _botMgr->HaveBot();
+}
+uint8 Player::GetNpcBotsCount() const
+{
+    return _botMgr ? _botMgr->GetNpcBotsCount() : 0;
+}
+void Player::RemoveAllBots(uint8 removetype)
+{
+    if (_botMgr) _botMgr->RemoveAllBots(removetype);
+}
+void Player::UpdatePhaseForBots()
+{
+    if (_botMgr) _botMgr->UpdatePhaseForBots();
+}
+//END NPCBOT
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2291,6 +2336,11 @@ Creature* Player::GetNPCIfCanInteractWith(ObjectGuid const& guid, uint32 npcflag
     if (creature->GetCharmerGUID())
         return nullptr;
 
+    //npcbot
+    if (creature->IsNPCBot() && creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        return creature;
+    //end npcbot
+
     // not unfriendly/hostile
     if (creature->GetReactionTo(this) <= REP_UNFRIENDLY)
         return nullptr;
@@ -2430,6 +2480,11 @@ void Player::SetGameMaster(bool on)
         m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
     }
 
+    //npcbot: pet is handled already, bots are not, so do it
+    if (HaveBot())
+        _botMgr->OnOwnerSetGameMaster(on);
+    //end npcbot
+
     UpdateObjectVisibility();
 }
 
@@ -2511,6 +2566,49 @@ void Player::RemoveFromGroup(Group* group, ObjectGuid guid, RemoveMethod method
     if (!group)
         return;
 
+    //npcbot - player is being removed from group - remove bots from that group
+    if (Player* player = ObjectAccessor::FindPlayer(guid))
+    {
+        if (player->HaveBot())
+        {
+            //uint8 players = 0;
+            //Group::MemberSlotList const& members = group->GetMemberSlots();
+            //for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+            //{
+            //    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+            //        ++players;
+            //}
+
+            //remove npcbots and set up new group if needed
+            player->GetBotMgr()->RemoveAllBotsFromGroup();
+            group = player->GetGroup();
+            if (!group)
+                return; //group has been disbanded
+        }
+    }
+    //npcbot - bot is being removed from group - find master and remove bot through botmap
+    //else if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Creature*)NULL))
+    else if (guid.IsCreature())
+    {
+        for (GroupReference* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            if (Player* member = itr->GetSource())
+            {
+                if (!member->HaveBot())
+                    continue;
+
+                if (Creature* bot = member->GetBotMgr()->GetBot(guid))
+                {
+                    member->GetBotMgr()->RemoveBotFromGroup(bot);
+                    return;
+                }
+            }
+        }
+        //ASSERT(!bot->IsFreeBot());
+        //bot->GetBotOwner()->GetBotMgr()->RemoveBotFromGroup(bot, false);
+        //return;
+    }
+
     group->RemoveMember(guid, method, kicker, reason);
 }
 
@@ -2679,6 +2777,11 @@ void Player::GiveLevel(uint8 level)
     SendQuestGiverStatusMultiple();
 
     sScriptMgr->OnPlayerLevelChanged(this, oldLevel);
+
+    //npcbot: force bots to update stats
+    if (HaveBot())
+        _botMgr->SetBotsShouldUpdateStats();
+    //end npcbot
 }
 
 bool Player::IsMaxLevel() const
@@ -4421,6 +4524,12 @@ void Player::DeleteFromDB(ObjectGuid playerguid, uint32 accountId, bool updateRe
             trans->Append(stmt);
 
             Corpse::DeleteFromDB(playerguid, trans);
+
+            //npcbot - erase npcbots
+            uint32 newOwner = 0;
+            BotDataMgr::UpdateNpcBotDataAll(guid, NPCBOT_UPDATE_OWNER, &newOwner);
+            //end npcbot
+
             break;
         }
         // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
@@ -6834,6 +6943,36 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, victim);
         }
+        //npcbot: honor for bots
+        else if (victim->ToCreature()->IsNPCBot() && !victim->ToCreature()->IsTempBot())
+        {
+            Creature const* bot = victim->ToCreature();
+
+            uint32 check1 = GetFaction();
+            uint32 check2 = bot->GetFaction();
+
+            if (!bot->IsFreeBot())
+            {
+                check1 = GetTeam();
+                check2 = bot->GetBotOwner()->GetTeam();
+            }
+
+            if (check1 == check2 && !sWorld->IsFFAPvPRealm())
+                return false;
+
+            uint8 k_level = GetLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->GetLevel();
+
+            if (v_level <= k_grey)
+                return false;
+
+            victim_guid.Clear(); // Don't show HK: <rank> message, only log.
+
+            //TODO: honor gain rate
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+        }
+        //end npcbot
         else
         {
             if (!victim->ToCreature()->IsRacialLeader())
@@ -21961,6 +22100,11 @@ void Player::UpdatePvP(bool state, bool _override)
         pvpInfo.EndTimer = GameTime::GetGameTime();
         SetPvP(state);
     }
+
+    //npcbot: update pvp flags for bots
+    if (HaveBot())
+        _botMgr->UpdatePvPForBots();
+    //end npcbot
 }
 
 void Player::UpdatePotionCooldown(Spell* spell)
@@ -23823,6 +23967,11 @@ bool Player::isHonorOrXPTarget(Unit* victim) const
 
     if (Creature const* creature = victim->ToCreature())
     {
+        //npcbot: count npcbots at xp targets (DEPRECATED)
+        if (victim->ToCreature()->IsNPCBotOrPet())
+            return true;
+        //end npcbots
+
         if (creature->IsCritter() || creature->IsTotem())
             return false;
     }
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 64473d7..4bb001a 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -79,6 +79,10 @@ enum ItemClass : uint8;
 enum LootError : uint8;
 enum LootType : uint8;
 
+// NpcBot mod
+class BotMgr;
+// end NpcBot mod
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2173,6 +2177,19 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
 
         std::string GetDebugInfo() const override;
 
+        /*****************************************************************/
+        /***                        NPCBOT SYSTEM                      ***/
+        /*****************************************************************/
+        void SetBotMgr(BotMgr* mgr) { ASSERT (!_botMgr); _botMgr = mgr; }
+        BotMgr* GetBotMgr() const { return _botMgr; }
+        bool HaveBot() const;
+        uint8 GetNpcBotsCount() const;
+        void RemoveAllBots(uint8 removetype = 0);
+        void UpdatePhaseForBots();
+        /*****************************************************************/
+        /***                      END NPCBOT SYSTEM                    ***/
+        /*****************************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         GuidList WhisperList;
@@ -2429,6 +2446,14 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
         TimeTracker m_groupUpdateTimer;
 
     private:
+        /*****************************************************************/
+        /***                        NPCBOT SYSTEM                      ***/
+        /*****************************************************************/
+        BotMgr* _botMgr;
+        /*****************************************************************/
+        /***                      END NPCBOT SYSTEM                    ***/
+        /*****************************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index 5c86d33..1c53b28 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -152,6 +152,13 @@ void Totem::UnSummon(uint32 msTime)
     if (IsAlive())
         setDeathState(DEAD);
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (GetCreatorGUID() && GetCreatorGUID().IsCreature())
+        if (Creature* bot = ObjectAccessor::GetCreature(*GetOwner(), GetCreatorGUID()))
+            if (bot->IsNPCBot())
+                bot->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index 0458f14..15d7836 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -1111,16 +1111,58 @@ void Creature::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized,
     float weaponMinDamage = GetWeaponDamageRange(attType, MINDAMAGE);
     float weaponMaxDamage = GetWeaponDamageRange(attType, MAXDAMAGE);
 
+    //npcbot: support for feral form
+    if (IsNPCBot() && IsInFeralForm())
+    {
+        float att_speed = GetAPMultiplier(attType, false);
+        uint8 lvl = GetLevel();
+        if (lvl > 60)
+            lvl = 60;
+
+        weaponMinDamage = lvl*0.85f*att_speed;
+        weaponMaxDamage = lvl*1.25f*att_speed;
+    }
+    else
+    //end npcbot
     if (!CanUseAttackType(attType)) // disarm case
     {
+        //npcbot: mimic player-like disarm (retain damage)
+        if (IsNPCBot())
+        {
+            // Main hand melee is always usable, but disarm reduces damage drastically
+            if (attType == BASE_ATTACK)
+            {
+                weaponMinDamage *= 0.25f;
+                weaponMaxDamage *= 0.25f;
+            }
+            else
+            {
+                weaponMinDamage = 0.0f;
+                weaponMaxDamage = 0.0f;
+            }
+        }
+        else
+        {
+        //end npcbot
         weaponMinDamage = 0.0f;
         weaponMaxDamage = 0.0f;
+        //npcbot
+        }
+    }
+    //end npcbot
+    //npcbot: support for ammo
+    else if (attType == RANGED_ATTACK)
+    {
+        float att_speed = GetAPMultiplier(attType, false);
+        weaponMinDamage += GetCreatureAmmoDPS() * att_speed;
+        weaponMaxDamage += GetCreatureAmmoDPS() * att_speed;
+    //end npcbot
     }
 
     float attackPower      = GetTotalAttackPowerValue(attType);
     float attackSpeedMulti = GetAPMultiplier(attType, normalized);
-    float baseValue        = GetFlatModifierValue(unitMod, BASE_VALUE) + (attackPower / 14.0f) * variance;
-    float basePct          = GetPctModifierValue(unitMod, BASE_PCT) * attackSpeedMulti;
+    float baseValue        = GetFlatModifierValue(unitMod, BASE_VALUE) + (attackPower / 14.0f) * variance * attackSpeedMulti;
+    float basePct          = GetPctModifierValue(unitMod, BASE_PCT);
     float totalValue       = GetFlatModifierValue(unitMod, TOTAL_VALUE);
     float totalPct         = addTotalPct ? GetPctModifierValue(unitMod, TOTAL_PCT) : 1.0f;
     float dmgMultiplier    = GetCreatureTemplate()->ModDamage; // = ModDamage * _GetDamageMod(rank);
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 71d1176..3c0acbf 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -77,6 +77,10 @@
 #include "WorldSession.h"
 #include <cmath>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 float baseMoveSpeed[MAX_MOVE_TYPE] =
 {
     2.5f,                  // MOVE_WALK
@@ -686,6 +690,22 @@ bool Unit::HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel) cons
     if (UnitAI* attackerAI = attacker ? attacker->GetAI() : nullptr)
         attackerAI->DamageDealt(victim, damage, damagetype);
 
+    //npcbot: damage dealt hook for crits and spells
+    if (attacker && attacker->GetTypeId() == TYPEID_UNIT && attacker->ToCreature()->IsNPCBot())
+        BotMgr::OnBotDamageDealt(attacker, victim, damage, cleanDamage, damagetype, spellProto);
+    //end npcbot
+
+    //npcbot: damage tracker hook
+    if (damage > 0 && damage < victim->GetHealth())
+    {
+        Player const* botowner = victim->GetTypeId() == TYPEID_PLAYER ? victim->ToPlayer() :
+            victim->ToCreature()->IsNPCBot() && !victim->ToCreature()->IsFreeBot() ? victim->ToCreature()->GetBotOwner() : NULL;
+
+        if (botowner && botowner->GetBotMgr() && (botowner->HaveBot() || (botowner->GetGroup() && botowner->GetGroup()->IsMember(victim->GetGUID()))))
+            botowner->GetBotMgr()->TrackDamage(victim, damage);
+    }
+    //end npcbot
+
     // Hook for OnDamage Event
     sScriptMgr->OnDamage(attacker, victim, damage);
 
@@ -977,6 +997,18 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+                //NpcBot mod: apply bot damage mods
+                if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+                {
+                    //TODO: rename to ApplyBotDamageMultiplierPhysical
+                    ToCreature()->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+                    if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                        damage *= BotMgr::GetBotDamageModPhysical();
+                    else if (damageSchoolMask & SPELL_SCHOOL_MASK_MAGIC)
+                        damage *= BotMgr::GetBotDamageModSpell();
+                }
+                //End NpcBot
+
                 // Physical Damage
                 if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
                 {
@@ -1039,6 +1071,17 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+                //NpcBot mod: apply bot damage mods
+                if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+                {
+                    ToCreature()->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+                    if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                        damage *= BotMgr::GetBotDamageModPhysical();
+                    else if (damageSchoolMask & SPELL_SCHOOL_MASK_MAGIC)
+                        damage *= BotMgr::GetBotDamageModSpell();
+                }
+                //End NpcBot
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1183,6 +1226,17 @@ void Unit::CalculateMeleeDamage(Unit* victim, CalcDamageInfo* damageInfo, Weapon
         // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
         sScriptMgr->ModifyMeleeDamage(damageInfo->Target, damageInfo->Attacker, damage);
 
+        //NpcBot mod: apply bot damage mods
+        if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+        {
+            damageInfo->Damages[i].Damage = damage;
+            //damage is unused. TODO: remove this redundant argument
+            ToCreature()->ApplyBotDamageMultiplierMelee(damageInfo->Damages[i].Damage, *damageInfo);
+            damage = damageInfo->Damages[i].Damage;
+            damage *= BotMgr::GetBotDamageModPhysical();
+        }
+        //End NpcBot
+
         // Calculate armor reduction
         if (Unit::IsDamageReducedByArmor(SpellSchoolMask(damageInfo->Damages[i].DamageSchoolMask)))
         {
@@ -1193,6 +1247,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, CalcDamageInfo* damageInfo, Weapon
             damageInfo->Damages[i].Damage = damage;
     }
 
+    //NpcBot mod: check custom melee outcome
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        damageInfo->HitOutCome = ToCreature()->BotRollMeleeOutcomeAgainst(damageInfo->Target, damageInfo->AttackType);
+    else
+    //End NpcBot
     damageInfo->HitOutCome = RollMeleeOutcomeAgainst(damageInfo->Target, damageInfo->AttackType);
 
     switch (damageInfo->HitOutCome)
@@ -1476,6 +1535,13 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
         DamageInfo dmgInfo(*damageInfo);
         ToPlayer()->CastItemCombatSpell(dmgInfo);
     }
+    //npcbot - CastItemCombatSpell for bots
+    else if (ToCreature()->IsNPCBot())
+    {
+        DamageInfo dmgInfo(*damageInfo);
+        ToCreature()->CastCreatureItemCombatSpell(victim, damageInfo->AttackType, damageInfo->ProcVictim, dmgInfo.GetHitMask());
+    }
+    //end npcbot
 
     // Do effect if any damage done to target
     if (damageInfo->Damages[0].Damage + damageInfo->Damages[1].Damage)
@@ -1599,6 +1665,15 @@ void Unit::HandleEmoteCommand(Emote emoteId)
         }
     }
 
+    //npcbot: armor penetration modifier
+    if (attacker->GetTypeId() == TYPEID_UNIT && attacker->ToCreature()->IsNPCBot())
+    {
+        // SPELL_AURA_MOD_ARMOR_PENETRATION_PCT is handled in class mods
+        // No cap
+        armor -= CalculatePct(armor, attacker->ToCreature()->GetCreatureArmorPenetrationCoef());
+    }
+    //end npcbot
+
     if (armor < 0.0f)
         armor = 0.0f;
 
@@ -1701,6 +1776,14 @@ void Unit::HandleEmoteCommand(Emote emoteId)
             victimResistance += float(unitCaster->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));
     }
 
+    //npcbot - spell resist and spell penetration for bots
+    if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        victimResistance -= caster->ToCreature()->GetCreatureSpellPenetration();
+
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+        victimResistance += victim->ToCreature()->GetCreatureResistanceBonus(schoolMask);
+    //end npcbot
+
     // holy resistance exists in pve and comes from level difference, ignore template values
     if (schoolMask & SPELL_SCHOOL_MASK_HOLY)
         victimResistance = 0.0f;
@@ -2111,6 +2194,15 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
     int32 block_chance = int32(GetUnitBlockChance(attType, victim) * 100.0f);
     int32 parry_chance = int32(GetUnitParryChance(attType, victim) * 100.0f);
 
+    //npcbot - expertise
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        int32 reductionFromExpertise = ToCreature()->GetCreatureExpertise() * 100 / 4;
+        dodge_chance -= reductionFromExpertise;
+        parry_chance -= reductionFromExpertise;
+    }
+    //end npcbot
+
     // melee attack table implementation
     // outcome priority:
     //   1. >    2. >    3. >       4. >    5. >   6. >       7. >  8.
@@ -2125,6 +2217,11 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
     // only creatures can dodge if attacker is behind
     bool canDodge = victim->GetTypeId() != TYPEID_PLAYER || canParryOrBlock;
 
+    //npcbot: player rules for dodge
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot() && !canParryOrBlock)
+        canDodge = false;
+    //end npcbot
+
     // if victim is casting or cc'd it can't avoid attacks
     if (victim->IsNonMeleeSpellCast(false) || victim->HasUnitState(UNIT_STATE_CONTROLLED))
     {
@@ -2161,6 +2258,9 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
 
     // 4. GLANCING
     // Max 40% chance to score a glancing blow against mobs that are higher level (can do only players and pets and not with ranged weapon)
+    //npcbot: no glances on npcbots and their pets
+    if (!(victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBotOrPet()))
+    //end npcbot
     if ((GetTypeId() == TYPEID_PLAYER || IsPet()) &&
         victim->GetTypeId() != TYPEID_PLAYER && !victim->IsPet() &&
         GetLevel() < victim->GetLevelForTarget(this))
@@ -2533,6 +2633,10 @@ uint32 Unit::GetDefenseSkillValue(Unit const* target) const
         value += uint32(ToPlayer()->GetRatingBonusValue(CR_DEFENSE_SKILL));
         return value;
     }
+    //npcbot - defense
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return ToCreature()->GetCreatureDefense();
+    //end npcbot
     else
         return GetMaxSkillValueForLevel(target);
 }
@@ -2555,6 +2659,14 @@ float Unit::GetUnitDodgeChance(WeaponAttackType attType, Unit const* victim) con
         if (!victim->IsTotem())
         {
             chance = 5.0f;
+            //npcbot - custom dodge chance instead of bunch of auras and remove base chance
+            if (victim->ToCreature()->IsNPCBot())
+            {
+                if (!victim->ToCreature()->CanDodge())
+                    return 0.f;
+                chance = victim->ToCreature()->GetCreatureDodgeChance();
+            }
+            //end npcbot
             chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
 
             if (skillDiff <= 10)
@@ -2607,6 +2719,14 @@ float Unit::GetUnitParryChance(WeaponAttackType attType, Unit const* victim) con
         if (!victim->IsTotem() && !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY))
         {
             chance = 5.0f;
+            //npcbot - custom parry chance instead of bunch of auras
+            if (victim->ToCreature()->IsNPCBot())
+            {
+                if (!victim->ToCreature()->CanParry())
+                    return 0.f;
+                chance = victim->ToCreature()->GetCreatureParryChance();
+            }
+            //end npcbot
             chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
 
             if (skillDiff <= 10)
@@ -2633,6 +2753,11 @@ float Unit::GetUnitMissChance() const
     if (Player const* player = ToPlayer())
         miss_chance += player->GetMissPercentageFromDefense();
 
+    //npcbot: defense skill bonus
+    if (Creature const* creature = ToCreature())
+        miss_chance += (creature->GetCreatureDefense() - GetLevel() * 5) * 0.04f;
+    //end npcbot
+
     return miss_chance;
 }
 
@@ -2661,6 +2786,10 @@ float Unit::GetUnitBlockChance(WeaponAttackType attType, Unit const* victim) con
         if (!victim->IsTotem() && !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
         {
             chance = 5.0f;
+            //npcbot - custom block chance instead of bunch of auras and remove base chance
+            if (victim->ToCreature()->IsNPCBot())
+                chance = victim->ToCreature()->GetCreatureBlockChance();
+            //end npcbot
             chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
 
             if (skillDiff <= 10)
@@ -2701,6 +2830,10 @@ float Unit::GetUnitCriticalChanceDone(WeaponAttackType attackType) const
         if (!(ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRIT))
         {
             chance = 5.0f;
+            //npcbot - custom crit chance instead of bunch of auras and remove base chance
+            if (ToCreature()->IsNPCBot())
+                chance = ToCreature()->GetCreatureCritChance();
+            //end npcbot
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
         }
@@ -3808,6 +3941,11 @@ void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId
             // Call AfterDispel hook on AuraScript
             aura->CallScriptAfterDispel(&dispelInfo);
 
+            //npcbot: hook dispels
+            if (dispeller->GetTypeId() == TYPEID_UNIT && dispeller->ToCreature()->IsNPCBot())
+                BotMgr::OnBotDispelDealt(dispeller->ToUnit(), this, dispelInfo.GetRemovedCharges());
+            //end npcbot
+
             return;
         }
         else
@@ -5576,6 +5714,9 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
 
     if (creature && !IsControlledByPlayer())
+    //npcbot - not for npcbots either
+    if (!creature->IsNPCBotOrPet())
+    //end npcbot
     {
         EngageWithTarget(victim); // ensure that anything we're attacking has threat
 
@@ -5677,6 +5818,19 @@ void Unit::CombatStopWithPets(bool includingCast)
 
     for (Unit* minion : m_Controlled)
         minion->CombatStop(includingCast);
+
+    //npcbot: combatstop for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            itr->second->CombatStop(includingCast);
+            if (Unit* botPet = itr->second->GetBotsPet())
+                botPet->CombatStop(includingCast);
+        }
+    }
+    //end npcbot
 }
 
 bool Unit::isAttackingPlayer() const
@@ -6260,6 +6414,11 @@ Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
     else if (GetTypeId() == TYPEID_UNIT && IsPet())
         player = GetOwner()->ToPlayer();
 
+    //npcbot: count bot owner
+    if (!player && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && !ToCreature()->IsFreeBot())
+        player = ToCreature()->GetBotOwner();
+    //end npcbot
+
     if (!player)
         return nullptr;
     Group* group = player->GetGroup();
@@ -6292,6 +6451,25 @@ Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
         if (Unit* pet = Target->GetGuardianPet())
             if (pet != this && IsWithinDistInMap(pet, radius) && pet->IsAlive() && !IsHostileTo(pet))
                 nearMembers.push_back(pet);
+
+            //npcbot: push bots and bot pets
+            if (Target->HaveBot())
+            {
+                BotMap const* botMap = Target->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = botMap->begin(); it != botMap->end(); ++it)
+                {
+                    if (group->IsMember(it->second->GetGUID()))
+                    {
+                        if (it->second != this && it->second->IsAlive() &&
+                            IsWithinDistInMap(it->second, radius) && !IsHostileTo(it->second))
+                            nearMembers.push_back(it->second);
+                        //if (Unit* botpet = it->second->GetBotsPet())
+                        //    if (botpet != this && botpet->IsAlive() && IsWithinDistInMap(botpet, radius) && !IsHostileTo(botpet))
+                        //        nearMembers.push_back(botpet);
+                    }
+                }
+            }
+            //end npcbot
         }
 
     if (nearMembers.empty())
@@ -6560,6 +6738,11 @@ float Unit::SpellDamagePctDone(Unit* victim, SpellInfo const* spellProto, Damage
     // Done total percent damage auras
     float DoneTotalMod = 1.0f;
 
+    //npcbot: do not affect bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+    { /*do nothing*/ }
+    else
+    //end npcbot
     // Pet damage?
     if (GetTypeId() == TYPEID_UNIT && !IsPet())
         DoneTotalMod *= ToCreature()->GetSpellDamageMod(ToCreature()->GetCreatureTemplate()->rank);
@@ -6893,6 +7076,11 @@ uint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, ui
         // multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)
         TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, spellProto->GetSchoolMask());
 
+        //npcbot - damage taken modifier
+        if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+            TakenTotalMod *= BotMgr::GetBotDamageTakenMod(ToCreature(), true);
+        //end npcbot
+
         // From caster spells
         if (caster)
         {
@@ -6929,6 +7117,11 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask) const
 {
     int32 DoneAdvertisedBenefit = GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_DAMAGE_DONE, schoolMask);
 
+    //npcbot: apply bot spellpower
+    if ((schoolMask & SPELL_SCHOOL_MASK_MAGIC) && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        DoneAdvertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     if (GetTypeId() == TYPEID_PLAYER)
     {
         // Base value
@@ -6957,6 +7150,9 @@ float Unit::SpellCritChanceDone(SpellInfo const* spellInfo, SpellSchoolMask scho
 {
     //! Mobs can't crit with spells. (Except player controlled)
     if (GetTypeId() == TYPEID_UNIT && !GetSpellModOwner())
+        //npcbot - allow bots to crit
+        if (!ToCreature()->IsNPCBotOrPet())
+        //end npcbot
         return 0.0f;
 
     // not critting spell
@@ -7185,6 +7381,11 @@ float Unit::SpellCritChanceTaken(Unit const* caster, SpellInfo const* spellInfo,
         });
     }
 
+    //npcbot - apply bot spell crit mods
+    if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ApplyBotCritMultiplierAll(this, crit_chance, spellInfo, schoolMask, attackType);
+    //end npcbot
+
     return std::max(crit_chance, 0.0f);
 }
 
@@ -7404,6 +7605,11 @@ uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, ui
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
+    //npcbot - healing bonus done for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyBotDamageMultiplierHeal(victim, heal, spellProto, damagetype, stack);
+    //end npcbot
+
     return uint32(std::max(heal, 0.0f));
 }
 
@@ -7544,6 +7750,11 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask) const
         return false;
     });
 
+    //npcbot: apply bot spellpower to healing
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        advertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -7946,6 +8157,11 @@ uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackT
     // ..taken
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, attacker->GetMeleeDamageSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        TakenTotalMod *= BotMgr::GetBotDamageTakenMod(ToCreature(), false);
+    //end npcbot
+
     // .. taken pct (special attacks)
     if (spellProto)
     {
@@ -8394,6 +8610,12 @@ bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
                 if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                     return true;
 
+    //npcbot - bots are always visible for owner
+    if (Creature const* bot = ToCreature())
+        if (bot->GetBotAI() && seer->GetGUID() == bot->GetBotOwner()->GetGUID())
+            return true;
+    //end npcbot
+
     return false;
 }
 
@@ -8813,6 +9035,12 @@ bool Unit::ApplyDiminishingToDuration(SpellInfo const* auraSpellInfo, bool trigg
 
         if (target->IsAffectedByDiminishingReturns() && source->GetTypeId() == TYPEID_PLAYER)
             duration = limitDuration;
+
+        //npcbot: limit duration if casted by npcbots
+        if (target->GetTypeId() == TYPEID_PLAYER && source->GetTypeId() == TYPEID_UNIT &&
+            source->ToCreature()->IsNPCBotOrPet())
+            duration = limitDuration;
+        //end npcbots
     }
 
     float mod = 1.0f;
@@ -8889,6 +9117,17 @@ uint32 Unit::GetCreatureType() const
             return raceEntry->CreatureType;
         }
     }
+    //npcbot: support for druid's shapeshifting
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        ShapeshiftForm form = GetShapeshiftForm();
+        SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
+        if (ssEntry && ssEntry->CreatureType > 0)
+            return ssEntry->CreatureType;
+        else
+            return CREATURE_TYPE_HUMANOID;
+    }
+    //end npcbot
     else
         return ToCreature()->GetCreatureTemplate()->type;
 }
@@ -10057,6 +10296,14 @@ void Unit::ProcSkillsAndReactives(bool isVictim, Unit* procTarget, uint32 typeMa
                     ModifyAuraState(AURA_STATE_DEFENSE, true);
                     StartReactiveTimer(REACTIVE_DEFENSE);
                 }
+                //npcbot - update reactives for bots (victim)
+                if ((hitMask & PROC_HIT_PARRY) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->IsNPCBot() && ToCreature()->GetBotClass() == CLASS_HUNTER)
+                {
+                    ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
+                    StartReactiveTimer(REACTIVE_HUNTER_PARRY);
+                }
+                //end npcbot
             }
             else // For attacker
             {
@@ -10071,6 +10318,16 @@ void Unit::ProcSkillsAndReactives(bool isVictim, Unit* procTarget, uint32 typeMa
                     AddComboPoints(procTarget, 1);
                     StartReactiveTimer(REACTIVE_WOLVERINE_BITE);
                 }
+
+                //npcbot - update reactives for bots (attacker)
+                if ((hitMask & (PROC_HIT_DODGE | PROC_HIT_PARRY)) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->IsNPCBot() && ToCreature()->GetBotClass() == CLASS_WARRIOR)
+                {
+                    AddComboPoints(procTarget, 1);
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+                //TODO REACTIVE_WOLVERINE_BITE for bot hunter pets
+                //end npcbot
             }
         }
     }
@@ -10442,6 +10699,32 @@ void Unit::ClearComboPointHolders()
         (*m_ComboPointHolders.begin())->ClearComboPoints(); // this also removes it from m_comboPointHolders
 }
 
+//npcbot
+void Unit::ClearReactive(ReactiveType reactive)
+{
+    m_reactiveTimer[reactive] = 0;
+
+    switch (reactive)
+    {
+        case REACTIVE_DEFENSE:
+            if (HasAuraState(AURA_STATE_DEFENSE))
+                ModifyAuraState(AURA_STATE_DEFENSE, false);
+            break;
+        case REACTIVE_HUNTER_PARRY:
+            if (GetClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+            break;
+        case REACTIVE_OVERPOWER:
+            if (GetClass() == CLASS_WARRIOR)
+                ClearComboPoints();
+            break;
+        default:
+            break;
+        //TODO WOLVERINE_BITE clear
+    }
+}
+//end npcbot
+
 void Unit::ClearAllReactives()
 {
     for (uint8 i = 0; i < MAX_REACTIVE; ++i)
@@ -10571,6 +10854,9 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
 {
     // Not apply this to creature cast spells with casttime == 0
     if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !IsPet())
+        //npcbot - skip bots
+        if (!ToCreature()->IsNPCBotOrPet())
+        //end npcbot
         return 3500;
 
     if (CastingTime > 7000) CastingTime = 7000;
@@ -11030,6 +11316,12 @@ bool Unit::InitTamedPet(Pet* pet, uint8 level, uint32 spell_id)
         // at original death (not at SpiritOfRedemtionTalent timeout)
         plrVictim->SetPvPDeath(player != nullptr);
 
+        //npcbot - bots should not cause durability loss
+        if (durabilityLoss && attacker && attacker->GetTypeId() == TYPEID_UNIT && attacker->ToCreature()->GetBotAI() &&
+            !sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP))
+            durabilityLoss = false;
+        //end npcbot
+
         // only if not player and not controlled by player pet. And not at BG
         if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
         {
@@ -11820,6 +12112,16 @@ bool Unit::IsInPartyWith(Unit const* unit) const
     else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT) ||
         (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT))
         return true;
+    //npcbot
+    else if (u1->GetTypeId() == TYPEID_PLAYER && u1->ToPlayer()->HaveBot() && u1->ToPlayer()->GetBotMgr()->GetBot(u2->GetGUID()))
+        return true;
+    else if (u2->GetTypeId() == TYPEID_PLAYER && u2->ToPlayer()->HaveBot() && u2->ToPlayer()->GetBotMgr()->GetBot(u1->GetGUID()))
+        return true;
+    else if (u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetBotAI() && !u1->ToCreature()->IsFreeBot())
+        return u1->ToCreature()->GetBotOwner()->IsInPartyWith(u2);
+    else if (u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetBotAI() && !u2->ToCreature()->IsFreeBot())
+        return u2->ToCreature()->GetBotOwner()->IsInPartyWith(u1);
+    //end npcbot
 
     return u1->GetTypeId() == TYPEID_UNIT && u2->GetTypeId() == TYPEID_UNIT && u1->GetFaction() == u2->GetFaction();
 }
@@ -11839,6 +12141,16 @@ bool Unit::IsInRaidWith(Unit const* unit) const
     else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT) ||
             (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT))
         return true;
+    //npcbot
+    else if (u1->GetTypeId() == TYPEID_PLAYER && u1->ToPlayer()->HaveBot() && u1->ToPlayer()->GetBotMgr()->GetBot(u2->GetGUID()))
+        return true;
+    else if (u2->GetTypeId() == TYPEID_PLAYER && u2->ToPlayer()->HaveBot() && u2->ToPlayer()->GetBotMgr()->GetBot(u1->GetGUID()))
+        return true;
+    else if (u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetBotAI() && !u1->ToCreature()->IsFreeBot())
+        return u1->ToCreature()->GetBotOwner()->IsInRaidWith(u2);
+    else if (u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetBotAI() && !u2->ToCreature()->IsFreeBot())
+        return u2->ToCreature()->GetBotOwner()->IsInRaidWith(u1);
+    //end npcbot
 
     return u1->GetTypeId() == TYPEID_UNIT && u2->GetTypeId() == TYPEID_UNIT && u1->GetFaction() == u2->GetFaction();
 }
@@ -11867,6 +12179,19 @@ void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
                 if (Guardian* pet = Target->GetGuardianPet())
                     if (pet->IsAlive())
                         TagUnitMap.push_back(pet);
+
+                //npcbot: count bots
+                if (!Target->HaveBot())
+                    continue;
+
+                BotMap const* map = Target->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    if (group->GetMemberGroup(it->second->GetGUID()) == subgroup &&
+                        it->second->IsAlive() && IsInMap(it->second) && !IsHostileTo(it->second))
+                        TagUnitMap.push_back(it->second);
+                }
+                //end npcbot
             }
         }
     }
@@ -11877,6 +12202,18 @@ void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
         if (Guardian* pet = owner->GetGuardianPet())
             if ((pet == this || IsInMap(pet)) && pet->IsAlive())
                 TagUnitMap.push_back(pet);
+
+        //npcbot: count bots
+        if (owner->GetTypeId() == TYPEID_PLAYER && owner->ToPlayer()->HaveBot())
+        {
+            BotMap const* map = owner->ToPlayer()->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+            {
+                if (it->second->IsAlive() && IsInMap(it->second) && !IsHostileTo(it->second))
+                    TagUnitMap.push_back(it->second);
+            }
+        }
+        //end npcbot
     }
 }
 
@@ -12047,6 +12384,16 @@ float Unit::MeleeSpellMissChance(Unit const* victim, WeaponAttackType attType, i
     //calculate miss chance
     float missChance = victim->GetUnitMissChance();
 
+    //npcbot - custom miss chance instead of bunch of auras
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        if (!ToCreature()->CanMiss())
+            return 0.f;
+
+        missChance += ToCreature()->GetCreatureMissChance();
+    }
+    //end npcbot
+
     // melee attacks while dual wielding have +19% chance to miss
     if (!spellId && haveOffhandWeapon())
         missChance += 19.0f;
@@ -12103,6 +12450,11 @@ void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
             if ((*itr)->GetTypeId() == TYPEID_UNIT)
                 (*itr)->SetPhaseMask(newPhaseMask, true);
 
+        //npcbot: update for temporarily uncontrolled bots (teleport, taxi)
+        if (GetTypeId() == TYPEID_PLAYER)
+            ToPlayer()->UpdatePhaseForBots();
+        //end npcbot
+
         for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
             if (m_SummonSlot[i])
                 if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
@@ -12368,6 +12720,183 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form, uint32 spellId) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetBotOwner() && ToCreature()->GetBotOwner()->ToPlayer())
+    {
+        //this has to be modified after implementation of bots' appearances which will include player bytes emulation
+        Player const* player = ToCreature()->GetBotOwner();
+        //let's make druids look according to player but base model must be selected based on our race
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (GetRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (GetRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (GetGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (GetRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (GetRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (GetGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftFormEntry const* formEntry = sSpellShapeshiftFormStore.LookupEntry(form);
@@ -12959,6 +13488,19 @@ void Unit::StopAttackFaction(uint32 faction_id)
 
     for (Unit* minion : m_Controlled)
         minion->StopAttackFaction(faction_id);
+
+    //npcbot: stopattackfaction for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            itr->second->StopAttackFaction(faction_id);
+            if (Unit* botPet = itr->second->GetBotsPet())
+                botPet->StopAttackFaction(faction_id);
+        }
+    }
+    //end npcbot
 }
 
 void Unit::OutDebugInfo() const
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 0730871..9c47821 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1158,6 +1158,10 @@ class TC_GAME_API Unit : public WorldObject
         ObjectGuid GetCharmedGUID() const { return GetGuidValue(UNIT_FIELD_CHARM); }
         Unit* GetCharmed() const { return m_charmed; }
 
+        //npcbot
+        void SetControlledByPlayer(bool set) { m_ControlledByPlayer = set; }
+        //end npcbot
+
         bool IsControlledByPlayer() const { return m_ControlledByPlayer; }
         Player* GetControllingPlayer() const;
         ObjectGuid GetCharmerOrOwnerGUID() const override { return IsCharmed() ? GetCharmerGUID() : GetOwnerGUID(); }
@@ -1692,6 +1696,10 @@ class TC_GAME_API Unit : public WorldObject
         void SetIgnoringCombat(bool apply) { _isIgnoringCombat = apply; }
 
         std::string GetDebugInfo() const override;
+
+        bool HasReactive(ReactiveType reactive) const { return m_reactiveTimer[reactive] > 0; }
+        void ClearReactive(ReactiveType reactive);
+
     protected:
         explicit Unit (bool isWorldObject);
 
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 8498e19..2c2c07d 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -1186,6 +1186,11 @@ void ObjectMgr::CheckCreatureTemplate(CreatureTemplate const* cInfo)
         const_cast<CreatureTemplate*>(cInfo)->expansion = 0;
     }
 
+    //npcbot: skip flags check and damage multiplier
+    if (cInfo->flags_extra & (CREATURE_FLAG_EXTRA_NPCBOT | CREATURE_FLAG_EXTRA_NPCBOT_PET))
+        return;
+    //end npcbot
+
     if (uint32 badFlags = (cInfo->flags_extra & ~CREATURE_FLAG_EXTRA_DB_ALLOWED))
     {
         TC_LOG_ERROR("sql.sql", "Table `creature_template` lists creature (Entry: %u) with disallowed `flags_extra` %u, removing incorrect flag.", cInfo->Entry, badFlags);
@@ -8875,6 +8880,82 @@ SkillRangeType GetSkillRangeType(SkillRaceClassInfoEntry const* rcEntry)
     return SKILL_RANGE_LEVEL;
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->FemaleDisplayID;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->MaleDisplayID;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 43eb008..613ebd7 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -172,6 +172,21 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele> GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef std::unordered_map<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1228,6 +1243,8 @@ class TC_GAME_API ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
+
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1489,6 +1506,8 @@ class TC_GAME_API ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         Trainer::Trainer const* GetTrainer(uint32 creatureId) const;
 
         VendorItemData const* GetNpcVendorItemList(uint32 entry) const
@@ -1650,6 +1669,8 @@ class TC_GAME_API ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void LoadQuestRelationsHelper(QuestRelations& map, std::string const& table);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 017243a..80185f5 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -163,6 +163,15 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //npcbot - set loot mode on create
+    //TC_LOG_ERROR("entities.player", "Group::Create(): new group with leader %s", leader->GetName().c_str());
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+    {
+        if (!isLFGGroup())
+            m_lootMethod = FREE_FOR_ALL;
+    }
+    else
+    //end npcbot
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -422,6 +431,11 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    //npcbot - check if trying to add bot
+    //TC_LOG_ERROR("entities.player", "Group::AddMember(): new member %s", player->GetName().c_str());
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     player->SetGroupInvite(nullptr);
     if (player->GetGroup())
     {
@@ -435,6 +449,9 @@ bool Group::AddMember(Player* player)
 
     // if the same group invites the player back, cancel the homebind timer
     player->m_InstanceValid = player->CheckInstanceValidity(false);
+    //npcbot
+    }
+    //end npcbot
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -459,6 +476,10 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    //npcbot - check 2
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -534,6 +555,9 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    //npcbot
+    }
+    //end npcbot
 
     return true;
 }
@@ -564,6 +588,44 @@ bool Group::RemoveMember(ObjectGuid guid, RemoveMethod const& method /*= GROUP_R
     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
         return !m_memberSlots.empty();
 
+    //npcbot: skip group size check before removing a bot
+    if (!guid.IsPlayer())
+    {
+        // Remove bot from group in DB
+        if (!isBGGroup() && !isBFGroup())
+        {
+            CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+            stmt->setUInt32(0, guid.GetCounter());
+            CharacterDatabase.Execute(stmt);
+            DelinkMember(guid);
+
+        }
+        // Update subgroup
+        member_witerator slot = _getMemberWSlot(guid);
+        if (slot != m_memberSlots.end())
+        {
+            SubGroupCounterDecrease(slot->group);
+            m_memberSlots.erase(slot);
+        }
+
+        SendUpdate();
+
+        // do not disband raid group if bot owner logging out within dungeon
+        // 1-player raid groups will not happen unless player is gm - bots will rejoin at login
+        if (GetMembersCount() < 2 && isRaidGroup() && GetLeaderGUID())
+        {
+            Player* player = ObjectAccessor::FindPlayer(GetLeaderGUID());
+            Map* map = player ? player->FindMap() : nullptr;
+            if (!(map && map->IsDungeon() && player && player->GetSession()->PlayerLogout()))
+                Disband();
+        }
+        else if (GetMembersCount() < 2 && !(isLFGGroup() || isBGGroup() || isBFGroup()))
+            Disband();
+
+        return true;
+    }
+    else
+    //end npcbot
     // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
     if (GetMembersCount() > ((isBGGroup() || isLFGGroup() || isBFGroup()) ? 1u : 2u))
     {
@@ -672,6 +734,9 @@ bool Group::RemoveMember(ObjectGuid guid, RemoveMethod const& method /*= GROUP_R
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot: prevent group from being disbanded due to checking only players count
+        if (GetMembersCount() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index d316bfe..95ac72d 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -336,6 +336,9 @@ class TC_GAME_API Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        ObjectGuid const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index c3ac458..01e6ee1 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -38,6 +38,12 @@
 #include "World.h"
 #include "WorldPacket.h"
 
+//npcbot
+#include "bot_ai.h"
+#include "botdatamgr.h"
+#include "botmgr.h"
+//end npcbot
+
 void WorldSession::HandleClientCastFlags(WorldPacket& recvPacket, uint8 castFlags, SpellCastTargets& targets)
 {
     // some spell cast packet including more data (for projectiles?)
@@ -629,6 +635,102 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //npcbot
+    if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->GetClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+
+        Creature const* bot = unit->ToCreature();
+        //npcbot minion without a record in outfits table
+        if (bot->IsNPCBot())
+        {
+            NpcBotAppearanceData const* appearData = BotDataMgr::SelectNpcBotAppearance(unit->GetEntry());
+
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetDisplayId());                               // displayId
+            data << uint8(unit->GetRace());                                     // race
+            data << uint8(appearData ? appearData->gender : unit->GetGender()); // gender
+            data << uint8(bot->GetBotAI()->GetPlayerClass());                   // class
+            data << uint8(appearData ? appearData->skin : 0);                   // skin
+            data << uint8(appearData ? appearData->face : 0);                   // face
+            data << uint8(appearData ? appearData->hair : 0);                   // hair
+            data << uint8(appearData ? appearData->haircolor : 0);              // haircolor
+            data << uint8(appearData ? appearData->features : 0);               // facialhair
+            data << uint32(0);                                                  // guildId
+
+            static uint8 const botItemSlots[MAX_CREATURE_OUTFIT_DISPLAYS] =
+            {
+                BOT_SLOT_HEAD,
+                BOT_SLOT_SHOULDERS,
+                BOT_SLOT_BODY,
+                BOT_SLOT_CHEST,
+                BOT_SLOT_WAIST,
+                BOT_SLOT_LEGS,
+                BOT_SLOT_FEET,
+                BOT_SLOT_WRIST,
+                BOT_SLOT_HANDS,
+                BOT_SLOT_BACK,
+                0//tabard
+            };
+
+            // Display items in visible slots
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+            {
+                uint8 slot = botItemSlots[i];
+                //Items not displayed on bot: tabard, head, back
+                if (slot == 0 ||
+                    (slot == BOT_SLOT_HEAD && BotMgr::ShowEquippedHelm() == false) ||
+                    (slot == BOT_SLOT_BACK && BotMgr::ShowEquippedCloak() == false))
+                {
+                    data << uint32(0);
+                    continue;
+                }
+
+                Item const* item = bot->GetBotEquips(slot);
+                if (item)
+                    data << uint32(item->GetTemplate()->DisplayInfoID);
+                else
+                {
+                    //don't allow to go naked
+                    if (slot == BOT_SLOT_CHEST)
+                        data << uint32(CHEST_HALISCAN);
+                    else if (slot == BOT_SLOT_LEGS)
+                        data << uint32(LEGS_HALISCAN);
+                    else
+                        data << uint32(0);
+                }
+            }
+
+            SendPacket(&data);
+            return;
+        }
+    }
+    //end npcbot
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
 
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index af90ff9..69fc12d 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -51,6 +51,10 @@
 #include <unordered_set>
 #include <vector>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 u_map_magic MapMagic        = { {'M','A','P','S'} };
 u_map_magic MapVersionMagic = { {'v','1','.','9'} };
 u_map_magic MapAreaMagic    = { {'A','R','E','A'} };
@@ -3634,6 +3638,21 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+            //npcbot - count npcbots as group members (event if not in group)
+            if (itr->GetSource()->HaveBot() && BotMgr::LimitBots(this))
+            {
+                ++count;
+                BotMap const* botmap = itr->GetSource()->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = botmap->begin(); itr != botmap->end(); ++itr)
+                {
+                    Creature* cre = itr->second;
+                    if (!cre || !cre->IsInWorld() || cre->FindMap() != this || cre->IsTempBot())
+                        continue;
+                    ++count;
+                }
+            }
+            else
+            //end npcbot
             ++count;
     return count;
 }
@@ -3700,6 +3719,10 @@ void Map::AddToActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->incUnloadActiveLock();
+        //npcbot
+        else if (c->IsNPCBot())
+            EnsureGridLoadedForActiveObject(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())), c);
+        //end npcbot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -3731,6 +3754,10 @@ void Map::RemoveFromActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->decUnloadActiveLock();
+        //npcbot
+        else if (c->IsNPCBot())
+            EnsureGridLoaded(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())));
+        //end npcbot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index f80aded..82d8fb6 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -34,6 +34,10 @@
 #include "WorldSession.h"
 #include "Opcodes.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 MapManager::MapManager()
     : _nextInstanceId(0), _scheduledScripts(0)
 {
@@ -51,6 +55,10 @@ void MapManager::Initialize()
     // Start mtmaps if needed.
     if (num_threads > 0)
         m_updater.activate(num_threads);
+
+    //npcbot: load bots
+    BotMgr::Initialize();
+    //end npcbot
 }
 
 void MapManager::InitializeVisibilityDistanceInfo()
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index c5bca4f..ae9ff14 100644
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -784,6 +784,26 @@ void MotionMaster::MoveJump(float x, float y, float z, float o, float speedXY, f
     if (speedXY < 0.01f)
         return;
 
+    //npcbot: blademaser only (disabled)
+    /*
+    if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBot())
+    {
+        Movement::MoveSplineInit init(_owner);
+        init.MoveTo(x, y, z, false);
+        init.SetParabolic(speedZ, 0);
+        init.SetFacing(o);
+        init.SetOrientationFixed(true);
+        init.SetVelocity(speedXY);
+
+        GenericMovementGenerator* movement = new GenericMovementGenerator(std::move(init), EFFECT_MOTION_TYPE, EVENT_JUMP);
+        movement->Priority = MOTION_PRIORITY_HIGHEST;
+        movement->BaseUnitState = UNIT_STATE_JUMPING;
+        Add(movement);
+        return;
+    }
+    */
+    //end npcbot
+
     float moveTimeHalf = speedZ / Movement::gravity;
     float max_height = -Movement::computeFallElevation(moveTimeHalf, false, -speedZ);
 
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.cpp b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
index cc7e30c..37341af 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
@@ -315,6 +315,23 @@ bool OPvPCapturePoint::Update(uint32 diff)
     if (!fact_diff)
         return false;
 
+    //npcbots - count bots as players but 2 times less affect and only if there is a players difference
+    uint32 botsCount[2];
+
+    for (uint8 team = 0; team != 2; ++team)
+    {
+        botsCount[team] = 0;
+
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(*itr))
+                botsCount[team] += player->GetNpcBotsCount();
+        }
+    }
+
+    fact_diff += 0.5f * ((float)botsCount[0] - (float)botsCount[1]) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    //end npcbot
+
     uint32 Challenger = 0;
     float maxDiff = m_maxSpeed * diff;
 
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 41bc38f..a3d5841 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -43,6 +43,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 // Trait which indicates whether this script type
 // must be assigned in the database.
 template<typename>
@@ -1043,6 +1047,10 @@ void ScriptMgr::Initialize()
     // LFGScripts
     lfg::AddSC_LFGScripts();
 
+    //npcbot: load bot scripts here
+    AddNpcBotScripts();
+    //end npcbot
+
     // Load all static linked scripts through the script loader function.
     ASSERT(_script_loader_callback,
            "Script loader callback wasn't registered!");
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 27e3dfa..e8441be 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -54,6 +54,10 @@
 #include "WorldSocket.h"
 #include <zlib.h>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 namespace {
 
 std::string const DefaultPlayerName = "<none>";
@@ -474,6 +478,10 @@ void WorldSession::LogoutPlayer(bool save)
     m_playerLogout = true;
     m_playerSave = save;
 
+    //npcbot - free all bots and remove from botmap
+    _player->RemoveAllBots();
+    //end npcbots
+
     if (_player)
     {
         if (ObjectGuid lguid = _player->GetLootGUID())
@@ -1625,6 +1633,16 @@ uint32 WorldSession::DosProtection::GetMaxPacketCounterAllowed(uint16 opcode) co
             maxPacketCounterAllowed = PLAYER_SLOTS_COUNT;
             break;
         }
+        //npcbot: prevent kicks when too many bots spawned in one spot
+        case CMSG_GET_MIRRORIMAGE_DATA:
+        {
+            if (BotMgr::GetBotInfoPacketsLimit() > -1)
+                maxPacketCounterAllowed = BotMgr::GetBotInfoPacketsLimit();
+            else
+                maxPacketCounterAllowed = 100;
+            break;
+        }
+        //end npcbot
         default:
         {
             maxPacketCounterAllowed = 100;
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index b49f3b9..71169a5 100644
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -1813,6 +1813,10 @@ void AuraEffect::HandleAuraModShapeshift(AuraApplication const* aurApp, uint8 mo
             case FORM_DEFENSIVESTANCE:
             case FORM_BERSERKERSTANCE:
             {
+                //npcbot: skip this, handled inside class ai
+                if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot())
+                    break;
+                //end npcbot
                 uint32 Rage_val = 0;
                 // Defensive Tactics
                 if (form == FORM_DEFENSIVESTANCE)
@@ -1848,6 +1852,10 @@ void AuraEffect::HandleAuraModShapeshift(AuraApplication const* aurApp, uint8 mo
 
     if (target->GetTypeId() == TYPEID_PLAYER)
         target->ToPlayer()->InitDataForForm();
+    //npcbot: skip bots (handled inside AI)
+    else if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBotOrPet())
+    {}
+    //end npcbot
     else
         target->UpdateDisplayPower();
 
@@ -2730,6 +2738,17 @@ void AuraEffect::HandleAuraModTotalThreat(AuraApplication const* aurApp, uint8 m
 
     Unit* target = aurApp->GetTarget();
 
+    //npcbot: handle for bots
+    if (target->IsAlive() && target->GetTypeId() == TYPEID_UNIT &&
+        target->ToCreature()->IsNPCBotOrPet())
+    {
+        Unit* caster = GetCaster();
+        if (caster && caster->IsAlive())
+            caster->GetThreatManager().UpdateMyTempModifiers();
+        return;
+    }
+    //end npcbot
+
     if (!target->IsAlive() || target->GetTypeId() != TYPEID_PLAYER)
         return;
 
@@ -5094,6 +5113,14 @@ void AuraEffect::HandlePeriodicDamageAurasTick(Unit* target, Unit* caster) const
 
     if (GetAuraType() == SPELL_AURA_PERIODIC_DAMAGE)
     {
+        //npcbot: Black Arrow damage on targets below 20%
+        if (GetSpellInfo()->SpellFamilyName == SPELLFAMILY_WARLOCK && (GetSpellInfo()->SpellFamilyFlags[1] & 0x4) &&
+            target->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+        {
+            damage *= 5;
+        }
+        //end npcbot
+
         // leave only target depending bonuses, rest is handled in calculate amount
         if (GetBase()->GetType() == DYNOBJ_AURA_TYPE)
             damage = caster->SpellDamageBonusDone(target, GetSpellInfo(), damage, DOT, GetEffIndex(), { }, GetBase()->GetStackAmount());
@@ -5620,6 +5647,46 @@ void AuraEffect::HandleProcTriggerSpellAuraProc(AuraApplication* aurApp, ProcEve
     if (SpellInfo const* triggeredSpellInfo = sSpellMgr->GetSpellInfo(triggerSpellId))
     {
         TC_LOG_DEBUG("spells.aura.effect", "AuraEffect::HandleProcTriggerSpellAuraProc: Triggering spell %u from aura %u proc", triggeredSpellInfo->Id, GetId());
+
+        //npcbot
+        Aura const* triggeredByAura = aurApp->GetBase();
+        int32 basepoints0 = 0;
+        switch (triggerSpellId)
+        {
+            // Quest - Self Healing from resurrect (invisible in log)
+            case 25155:
+            {
+                switch (GetId())
+                {
+                    //Vampiric Aura
+                    case 20810:
+                    {
+                        DamageInfo const* dinfo = eventInfo.GetDamageInfo();
+                        uint32 damage = dinfo->GetDamage();
+                        if (!damage)
+                            return;
+
+                        // 100% / 25%
+                        if (triggerTarget->GetGUID() == triggeredByAura->GetCasterGUID())
+                            basepoints0 = int32(damage);
+                        else
+                            basepoints0 = int32(damage / 4);
+
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints0);
+                        triggerCaster->CastSpell(triggerTarget, triggerSpellId, args);
+                        return;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            default:
+                break;
+        }
+        //end npcbot
+
         triggerCaster->CastSpell(triggerTarget, triggeredSpellInfo->Id, this);
     }
     else
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
index 693508b..591b1a6 100644
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -580,6 +580,10 @@ void Aura::_ApplyForTarget(Unit* target, Unit* caster, AuraApplication* auraApp)
             caster->GetSpellHistory()->StartCooldown(m_spellInfo, castItem ? castItem->GetEntry() : 0, nullptr, true);
         }
     }
+    //npcbot: infinity cd for bots
+    if (caster && m_spellInfo->IsCooldownStartedOnEvent() && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->AddBotSpellCooldown(m_spellInfo->Id, std::numeric_limits<uint32>::max());
+    //end npcbot
 }
 
 void Aura::_UnapplyForTarget(Unit* target, Unit* caster, AuraApplication* auraApp)
@@ -608,6 +612,11 @@ void Aura::_UnapplyForTarget(Unit* target, Unit* caster, AuraApplication* auraAp
     if (caster && GetSpellInfo()->IsCooldownStartedOnEvent())
         // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
         caster->GetSpellHistory()->SendCooldownEvent(GetSpellInfo());
+
+    //npcbot: release cd state for bots
+    if (caster && m_spellInfo->IsCooldownStartedOnEvent() && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ReleaseBotSpellCooldown(m_spellInfo->Id);
+    //end npcbot
 }
 
 // removes aura from all targets
@@ -1702,6 +1711,20 @@ void Aura::HandleAuraSpecificMods(AuraApplication const* aurApp, Unit* caster, b
                     case 47788: // Guardian Spirit
                         if (removeMode != AURA_REMOVE_BY_EXPIRE)
                             break;
+
+                        //npcbot: handle Glyph of Guardian Spirit proc for bots
+                        if (Creature* bot = caster->ToCreature())
+                        {
+                            if (bot->IsNPCBot() && bot->HasSpellCooldown(47788))
+                            {
+                                bot->AddBotSpellCooldown(47788, 60000);
+                                bot->GetSpellHistory()->ResetCooldown(GetSpellInfo()->Id, true);
+                                bot->GetSpellHistory()->AddCooldown(GetSpellInfo()->Id, 0, std::chrono::seconds(60));
+                                break;
+                            }
+                        }
+                        //end npcbot
+
                         if (caster->GetTypeId() != TYPEID_PLAYER)
                             break;
 
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 3412310..e607beb 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -553,6 +553,15 @@ m_caster((info->HasAttribute(SPELL_ATTR6_CAST_BY_CHARMER) && caster->GetCharmerO
                     m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetTemplate()->Damage[0].DamageType);
     }
 
+    //npcbot: ranged weapon dmg school
+    if (m_attackType == RANGED_ATTACK && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() &&
+        ((1<<(m_caster->ToCreature()->GetBotClass()-1)) & CLASSMASK_WAND_USERS))
+    {
+        if (Item const* pItem = m_caster->ToCreature()->GetBotEquips(2))
+            m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetTemplate()->Damage[0].DamageType);
+    }
+    //end npcbot
+
     if (originalCasterGUID)
         m_originalCasterGUID = originalCasterGUID;
     else
@@ -1505,6 +1514,10 @@ void Spell::SelectImplicitCasterObjectTargets(SpellEffIndex effIndex, SpellImpli
         case TARGET_UNIT_PET:
             if (Unit* unitCaster = m_caster->ToUnit())
                 target = unitCaster->GetGuardianPet();
+            //npcbot: allow bot pet as target
+            if (!target && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                target = m_caster->ToCreature()->GetBotsPet();
+            //end npcbot
             break;
         case TARGET_UNIT_SUMMONER:
             if (Unit* unitCaster = m_caster->ToUnit())
@@ -1572,6 +1585,11 @@ void Spell::SelectImplicitChainTargets(SpellEffIndex effIndex, SpellImplicitTarg
     if (Player* modOwner = m_caster->GetSpellModOwner())
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_JUMP_TARGETS, maxTargets, this);
 
+    //npcbot - apply bot spell max targets mods
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->ApplyCreatureSpellMaxTargetsMods(m_spellInfo, maxTargets);
+    //end npcbot
+
     if (maxTargets > 1)
     {
         // mark damage multipliers as used
@@ -2572,6 +2590,13 @@ void Spell::TargetInfo::DoDamageAndTriggers(Spell* spell)
                     if (!spell->m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET) && !spell->m_spellInfo->HasAttribute(SPELL_ATTR4_CANT_TRIGGER_ITEM_SPELLS))
                         caster->ToPlayer()->CastItemCombatSpell(*spellDamageInfo);
             }
+
+            //npcbot
+            if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot() && (procSpellType & (PROC_SPELL_TYPE_DAMAGE | PROC_SPELL_TYPE_NO_DMG_HEAL)) &&
+                !(spell->m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) && !spell->m_spellInfo->HasAttribute(SPELL_ATTR4_CANT_TRIGGER_ITEM_SPELLS) &&
+                (spell->m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || spell->m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+                caster->ToCreature()->CastCreatureItemCombatSpell(spell->unitTarget, spell->m_attackType, procVictim, hitMask);
+            //end npcbot
         }
 
         // set hitmask for finish procs
@@ -2952,6 +2977,11 @@ bool Spell::UpdateChanneledTargetList()
         if (Player* modOwner = m_caster->GetSpellModOwner())
             modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
 
+        //npcbot: apply range mods
+        if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+            m_caster->ToCreature()->ApplyCreatureSpellRangeMods(m_spellInfo, range);
+        //end npcbot
+
         // add little tolerance level
         range += std::min(MAX_SPELL_RANGE_TOLERANCE, range*0.1f); // 10% but no more than MAX_SPELL_RANGE_TOLERANCE
     }
@@ -3462,6 +3492,11 @@ void Spell::_cast(bool skipCheck)
         handle_immediate();
     }
 
+    //npcbot - hook for spellcast finish
+    if (m_caster->GetTypeId() == TYPEID_UNIT)
+        m_caster->ToCreature()->OnSpellGo(this);
+    //end npcbot
+
     CallScriptAfterCastHandlers();
 
     if (std::vector<int32> const* spell_triggered = sSpellMgr->GetSpellLinked(m_spellInfo->Id))
@@ -3746,6 +3781,12 @@ void Spell::SendSpellCooldown()
     if (m_caster->GetTypeId() == TYPEID_GAMEOBJECT)
         return;
 
+    //npcbot: handled by AI
+    if (m_caster->GetTypeId() == TYPEID_UNIT &&
+        (m_caster->ToCreature()->IsNPCBot() || m_caster->ToCreature()->IsNPCBotPet()))
+        return;
+    //end npcbot
+
     m_caster->ToUnit()->GetSpellHistory()->HandleCooldowns(m_spellInfo, m_CastItem, this);
 }
 
@@ -3918,6 +3959,9 @@ void Spell::finish(bool ok)
 
     // Stop Attack for some spells
     if (m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET))
+    //npcbot: disable for npcbots
+    if (!(unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot()))
+    //end npcbot
         unitCaster->AttackStop();
 }
 
@@ -4763,9 +4807,39 @@ void Spell::TakePower()
         }
     }
 
+    //npcbot: handle SPELLMOD_SPELL_COST_REFUND_ON_FAIL (druid Primal Precision)
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotClass() == CLASS_DRUID)
+    {
+        if (powerType == POWER_ENERGY/* || powerType == POWER_RAGE || powerType == POWER_RUNE*/)
+        {
+            if (ObjectGuid targetGUID = m_targets.GetUnitTargetGUID())
+            {
+                //auto ihit = std::find_if(std::being());
+                for (std::vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                {
+                    if (ihit->TargetGUID == targetGUID && ihit->MissCondition != SPELL_MISS_NONE)
+                    {
+                        hit = false;
+                        //Primal Precision: 80% refund
+                        if ((m_spellInfo->SpellFamilyFlags[0] & 0x800000) || (m_spellInfo->SpellFamilyFlags[1] & 0x10000080))
+                            m_powerCost = m_powerCost / 5;
+                    }
+                    break;
+                }
+            }
+        }
+    }
+    //end npcbot
+
     if (powerType == POWER_RUNE)
     {
         TakeRunePower(hit);
+
+        //npcbot: spend runes (pass hit result)
+        if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotClass() == CLASS_DEATH_KNIGHT)
+            m_caster->ToCreature()->SpendBotRunes(m_spellInfo, hit);
+        //end npcbot
+
         return;
     }
 
@@ -5125,6 +5199,16 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
             else
                 return SPELL_FAILED_NOT_READY;
         }
+
+        if (m_caster->GetTypeId() == TYPEID_UNIT && !m_caster->ToCreature()->IsNPCBot() &&
+            m_caster->ToCreature()->HasSpellCooldown(m_spellInfo->Id))
+        {
+            //TC_LOG_ERROR("spells", "%s has cd of %u on %s", m_caster->GetName().c_str(), m_caster->ToCreature()->GetCreatureSpellCooldownDelay(m_spellInfo->Id), m_spellInfo->SpellName[0]);
+            if (m_triggeredByAuraSpell)
+                return SPELL_FAILED_DONT_REPORT;
+            else
+                return SPELL_FAILED_NOT_READY;
+        }
     }
 
     if (m_spellInfo->HasAttribute(SPELL_ATTR7_IS_CHEAT_SPELL) && !m_caster->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_ALLOW_CHEAT_SPELLS))
@@ -5324,6 +5408,11 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
         {
             if (m_spellInfo->Effects[j].TargetA.GetTarget() == TARGET_UNIT_PET)
             {
+                //npcbot: allow bot pet as target
+                if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotsPet())
+                    break;
+                else
+                //end npcbot
                 if (!unitCaster->GetGuardianPet())
                 {
                     if (m_triggeredByAuraSpell)              // not report pet not existence for triggered spells
@@ -5351,6 +5440,11 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
                 return SPELL_FAILED_NOT_IN_ARENA;
 
     // zone check
+    //npcbot: do not check location for bots (to avoid crash introduced in TC rev. 5cb8409f1ee57e8d)
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+    {}
+    else
+    //end npcbot
     if (m_caster->GetTypeId() != TYPEID_PLAYER || !m_caster->ToPlayer()->IsGameMaster())
     {
         uint32 zone, area;
@@ -6088,6 +6182,14 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
     {
         if (Unit* unitCaster = m_caster->ToUnit())
         {
+            //npcbot
+            if (unitCaster->ToCreature() && unitCaster->ToCreature()->IsNPCBot())
+            {
+                if (!unitCaster->ToCreature()->GetCreatureComboPoints())
+                    return SPELL_FAILED_NO_COMBO_POINTS;
+            }
+            else
+            //end npcbot
             if (m_spellInfo->NeedsExplicitUnitTarget())
             {
                 if (!unitCaster->GetComboPoints(m_targets.GetUnitTarget()))
@@ -6427,6 +6529,11 @@ SpellCastResult Spell::CheckRange(bool strict) const
     float minRange, maxRange;
     std::tie(minRange, maxRange) = GetMinMaxRange(strict);
 
+    //npcbot: apply range mods
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->ApplyCreatureSpellRangeMods(m_spellInfo, maxRange);
+    //end npcbot
+
     // dont check max_range to strictly after cast
     if (m_spellInfo->RangeEntry && m_spellInfo->RangeEntry->Flags != SPELL_RANGE_MELEE && !strict)
         maxRange += std::min(MAX_SPELL_RANGE_TOLERANCE, maxRange*0.1f); // 10% but no more than MAX_SPELL_RANGE_TOLERANCE
@@ -7719,6 +7826,13 @@ SpellCastResult Spell::CanOpenLock(uint32 effIndex, uint32 lockId, SkillType& sk
                     skillValue = m_CastItem || m_caster->GetTypeId() != TYPEID_PLAYER ?
                         0 : m_caster->ToPlayer()->GetSkillValue(skillId);
 
+                    //npcbot: use bot skill if cast through gossip
+                    if (m_originalCasterGUID)
+                        if (Unit const* unit = ObjectAccessor::GetUnit(*m_caster, m_originalCasterGUID))
+                            if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetBotClass() == CLASS_ROGUE)
+                                skillValue = std::max<int32>(skillValue, int32(unit->GetLevel() * 5));
+                    //end npcbot
+
                     // skill bonus provided by casting spell (mostly item spells)
                     // add the effect base points modifier from the spell cast (cheat lock / skeleton key etc.)
                     if (m_spellInfo->Effects[effIndex].TargetA.GetTarget() == TARGET_GAMEOBJECT_ITEM_TARGET || m_spellInfo->Effects[effIndex].TargetB.GetTarget() == TARGET_GAMEOBJECT_ITEM_TARGET)
diff --git a/src/server/game/Spells/Spell.h b/src/server/game/Spells/Spell.h
index 320cfdd..d2e6ec5 100644
--- a/src/server/game/Spells/Spell.h
+++ b/src/server/game/Spells/Spell.h
@@ -519,6 +519,9 @@ class TC_GAME_API Spell
 
         UsedSpellMods m_appliedMods;
 
+        //npcbot
+        int32 GetTimer() const { return m_timer; }
+        //end npcbot
         int32 GetCastTime() const { return m_casttime; }
         bool IsAutoRepeat() const { return m_autoRepeat; }
         void SetAutoRepeat(bool rep) { m_autoRepeat = rep; }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 0eeb6f0..b3a1fdb 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -500,6 +500,17 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                     damage += int32(energy * multiple);
                     damage += int32(CalculatePct(unitCaster->ToPlayer()->GetComboPoints() * ap, 7));
                 }
+                //npcbot: Ferocious Bite support
+                else if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot() && (m_spellInfo->SpellFamilyFlags[0] & 0x800000) && m_spellInfo->SpellVisual[0] == 6587)
+                {
+                    // converts each extra point of energy into ($f1+$AP/410) additional damage
+                    float ap = unitCaster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    float multiple = ap / 410 + m_spellInfo->Effects[effIndex].DamageMultiplier;
+                    int32 energy = -(unitCaster->ModifyPower(POWER_ENERGY, -30));
+                    damage += int32(energy * multiple);
+                    damage += int32(CalculatePct(unitCaster->ToCreature()->GetCreatureComboPoints() * ap, 7));
+                }
+                //end npcbot
                 // Wrath
                 else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
                 {
@@ -562,6 +573,52 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                                 damage += combo * 40;
                         }
                     }
+                    //npcbot: Envenom support
+                    else if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    {
+                        // consume from stack dozes not more that have combo-points
+                        if (uint8 combo = unitCaster->ToCreature()->GetCreatureComboPoints())
+                        {
+                            // Lookup for Deadly poison (only attacker applied)
+                            if (AuraEffect const* aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x00010000, 0, 0, unitCaster->GetGUID()))
+                            {
+                                // count consumed deadly poison doses at target
+                                bool needConsume = true;
+                                uint32 spellId = aurEff->GetId();
+
+                                uint32 doses = aurEff->GetBase()->GetStackAmount();
+                                if (doses > combo)
+                                    doses = combo;
+
+                                // Master Poisoner
+                                Unit::AuraEffectList const& auraList = player->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
+                                for (Unit::AuraEffectList::const_iterator iter = auraList.begin(); iter != auraList.end(); ++iter)
+                                {
+                                    if ((*iter)->GetSpellInfo()->SpellFamilyName == SPELLFAMILY_ROGUE && (*iter)->GetSpellInfo()->SpellIconID == 1960)
+                                    {
+                                        uint32 chance = (*iter)->GetSpellInfo()->Effects[EFFECT_2].CalcValue(unitCaster);
+
+                                        if (chance && roll_chance_i(chance))
+                                            needConsume = false;
+
+                                        break;
+                                    }
+                                }
+
+                                if (needConsume)
+                                    for (uint32 i = 0; i < doses; ++i)
+                                        unitTarget->RemoveAuraFromStack(spellId, unitCaster->GetGUID());
+
+                                damage *= doses;
+                                damage += int32(player->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * combo);
+                            }
+
+                            // Eviscerate and Envenom Bonus Damage (item set effect)
+                            if (unitCaster->HasAura(37169))
+                                damage += combo * 40;
+                        }
+                    }
+                    //end npcbot
                 }
                 // Eviscerate
                 else if (m_spellInfo->SpellFamilyFlags[0] & 0x00020000)
@@ -578,6 +635,20 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                                 damage += combo*40;
                         }
                     }
+                    //npcbot: Eviscerate support
+                    else if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    {
+                        if (uint32 combo = unitCaster->ToCreature()->GetCreatureComboPoints())
+                        {
+                            float ap = unitCaster->GetTotalAttackPowerValue(BASE_ATTACK);
+                            damage += std::lroundf(ap * combo * 0.07f);
+
+                            // Eviscerate and Envenom Bonus Damage (item set effect)
+                            if (unitCaster->HasAura(37169))
+                                damage += combo*40;
+                        }
+                    }
+                    //end npcbot
                 }
                 break;
             }
@@ -628,6 +699,27 @@ void Spell::EffectSchoolDMG(SpellEffIndex effIndex)
                             damage += irand(int32(dmg_min), int32(dmg_max));
                         damage += int32(caster->GetAmmoDPS() * caster->GetAttackTime(RANGED_ATTACK) * 0.001f);
                     }
+                    //npcbot: calculate bot weapon damage
+                    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                    {
+                        if (Item* item = m_caster->ToCreature()->GetBotEquips(2/*BOT_SLOT_RANGED*/))
+                        {
+                            ItemTemplate const* weaponTemplate = item->GetTemplate();
+                            float dmg_min = 0.f;
+                            float dmg_max = 0.f;
+                            for (uint8 i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+                            {
+                                dmg_min += weaponTemplate->Damage[i].DamageMin;
+                                dmg_max += weaponTemplate->Damage[i].DamageMax;
+                            }
+                            if (dmg_max == 0.0f && dmg_min > dmg_max)
+                                damage += int32(dmg_min);
+                            else
+                                damage += irand(int32(dmg_min), int32(dmg_max));
+                            damage += int32(m_caster->ToCreature()->GetCreatureAmmoDPS() * weaponTemplate->Delay * 0.001f);
+                        }
+                    }
+                    //end npcbot
                 }
                 break;
             }
@@ -733,6 +825,60 @@ void Spell::EffectTriggerSpell(SpellEffIndex effIndex)
         // special cases
         switch (triggered_spell_id)
         {
+            //npcbot: triggered heal/energize calculation (effect)
+            // Quest - Self Healing from resurrect (invisible in log)
+            case 25155:
+            {
+                switch (m_spellInfo->Id)
+                {
+                    //Replenish Life (Regenerating Aura)
+                    case 34756:
+                    {
+                        //cannot target self
+                        if (unitCaster == unitTarget)
+                            return;
+
+                        // % of max health
+                        int32 basepoints0 = 0.01f * unitTarget->GetMaxHealth() * m_spellInfo->Effects[effIndex].BasePoints;
+                        //TC_LOG_ERROR("entities.unit", "TriggerSpell(%u from %u): %s on %s base val %i,",
+                        //    triggered_spell_id, m_spellInfo->Id, m_caster->GetName().c_str(), unitTarget->GetName().c_str(), int32(basepoints0));
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints0);
+                        unitTarget->CastSpell(unitTarget, triggered_spell_id, args);
+                        return;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            // Energize (invisible in log)
+            case 60628:
+            {
+                switch (m_spellInfo->Id)
+                {
+                    //Replenish Mana
+                    case 33394:
+                    {
+                        //cannot target self
+                        if (unitCaster == unitTarget)
+                            return;
+
+                        // % of max mana
+                        int32 basepoints0 = m_spellInfo->Effects[effIndex].BasePoints;
+                        //TC_LOG_ERROR("entities.unit", "TriggerSpell(%u from %u): %s on %s base val %i,",
+                        //    triggered_spell_id, m_spellInfo->Id, m_caster->GetName().c_str(), unitTarget->GetName().c_str(), int32(basepoints0));
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints0);
+                        unitTarget->CastSpell(unitTarget, triggered_spell_id, args);
+                        return;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            //end npcbot
             // Mirror Image
             case 58832:
             {
@@ -1130,6 +1276,11 @@ void Spell::EffectPowerDrain(SpellEffIndex effIndex)
     if (powerType == POWER_MANA)
         power -= unitTarget->GetSpellCritDamageReduction(power);
 
+    //npcbot: handle Obsidian Destroyer's Drain Mana (target is friendly, amount is only limited by caster's max mana)
+    if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->GetBotClass() == 13 && powerType == POWER_MANA)
+        power = unitCaster->GetMaxPower(powerType);
+    //end npcbot
+
     int32 newDamage = -(unitTarget->ModifyPower(powerType, -int32(power)));
 
     // Don't restore from self drain
@@ -3073,6 +3224,14 @@ void Spell::EffectWeaponDmg(SpellEffIndex effIndex)
                     if (Item* item = unitCaster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
                         if (item->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
                             totalDamagePercentMod *= 1.5f;
+
+                //npcbot: handle bot weapons
+                // 50% more damage with daggers
+                if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    if (Item const* weapon = unitCaster->ToCreature()->GetBotEquips(m_attackType))
+                        if (weapon->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
+                            totalDamagePercentMod *= 1.5f;
+                //end npcbot
             }
             // Mutilate (for each hand)
             else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 7bfb459..666a016 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -31,6 +31,10 @@
 #include "SpellMgr.h"
 #include "Vehicle.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
 {
     switch (objType)
@@ -439,6 +443,14 @@ int32 SpellEffectInfo::CalcValue(WorldObject const* caster /*= nullptr*/, int32
     // random damage
     if (casterUnit)
     {
+        //npcbot: bonus amount from combo points and specific mods
+        if (casterUnit->GetTypeId() == TYPEID_UNIT && casterUnit->ToCreature()->IsNPCBot())
+        {
+            if (uint8 comboPoints = casterUnit->ToCreature()->GetCreatureComboPoints())
+                value += PointsPerComboPoint * comboPoints;
+        }
+        else
+        //end npcbot
         // bonus amount from combo points
         if (uint8 comboPoints = casterUnit->GetComboPoints())
             value += PointsPerComboPoint * comboPoints;
@@ -551,6 +563,11 @@ float SpellEffectInfo::CalcRadius(WorldObject* caster /*= nullptr*/, Spell* spel
 
         if (Player* modOwner = caster->GetSpellModOwner())
             modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_RADIUS, radius, spell);
+
+        //npcbot - apply bot spell radius mods
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            caster->ToCreature()->ApplyCreatureSpellRadiusMods(_spellInfo, radius);
+        //end npcbot
     }
 
     return radius;
@@ -3214,6 +3231,11 @@ int32 SpellInfo::CalcPowerCost(WorldObject const* caster, SpellSchoolMask school
         }
     }
 
+    //npcbot - apply bot spell cost mods
+    if (powerCost > 0 && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ApplyCreatureSpellCostMods(this, powerCost);
+    //end npcbot
+
     // PCT mod from user auras by school
     powerCost = int32(powerCost * (1.0f + unitCaster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER + school)));
     if (powerCost < 0)
diff --git a/src/server/scripts/Commands/cs_npc.cpp b/src/server/scripts/Commands/cs_npc.cpp
index fd1f6e7..8e15997 100644
--- a/src/server/scripts/Commands/cs_npc.cpp
+++ b/src/server/scripts/Commands/cs_npc.cpp
@@ -128,6 +128,16 @@ public:
         if (!sObjectMgr->GetCreatureTemplate(id))
             return false;
 
+        //npcbot
+        CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(id);
+        if (cinfo && ((cinfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT) || (cinfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT_PET)))
+        {
+            handler->PSendSysMessage("You tried to spawn creature %u, which is part of NPCBots mod. To spawn bots use '.npcbot spawn' instead.", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        //end npcbot
+
         Player* chr = handler->GetSession()->GetPlayer();
         Map* map = chr->GetMap();
 
@@ -312,6 +322,16 @@ public:
                 handler->SetSentErrorMessage(true);
                 return false;
             }
+
+            //npcbot
+            if (creature->IsNPCBotOrPet())
+            {
+                handler->SendSysMessage("Selected creature has botAI assigned, use '.npcbot delete' instead");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            //end npcbot
+
             if (TempSummon* summon = creature->ToTempSummon())
             {
                 summon->UnSummon();
diff --git a/src/server/scripts/Spells/spell_dk.cpp b/src/server/scripts/Spells/spell_dk.cpp
index 724343f..2fc5a5e 100644
--- a/src/server/scripts/Spells/spell_dk.cpp
+++ b/src/server/scripts/Spells/spell_dk.cpp
@@ -397,6 +397,13 @@ class spell_dk_anti_magic_zone : public SpellScriptLoader
             {
                 SpellInfo const* talentSpell = sSpellMgr->AssertSpellInfo(SPELL_DK_ANTI_MAGIC_SHELL_TALENT);
                 amount = talentSpell->Effects[EFFECT_0].CalcValue(GetCaster());
+                //npcbot: take bot attack power into account
+                if (Creature const* bot = GetCaster()->ToCreature())
+                {
+                    if (bot->IsNPCBot())
+                        amount += int32(2 * bot->GetTotalAttackPowerValue(BASE_ATTACK));
+                }
+                //end npcbot
                 if (Player* player = GetCaster()->ToPlayer())
                      amount += int32(2 * player->GetTotalAttackPowerValue(BASE_ATTACK));
             }
@@ -2344,6 +2351,16 @@ class spell_dk_spell_deflection : public SpellScriptLoader
             void Absorb(AuraEffect* /*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
             {
                 // You have a chance equal to your Parry chance
+                //npcbot handle creature case (and prevent crashes)
+                Unit* target = GetTarget();
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (dmgInfo.GetDamageType() == SPELL_DIRECT_DAMAGE &&
+                        roll_chance_f(target->ToCreature()->GetCreatureParryChance()))
+                        absorbAmount = CalculatePct(dmgInfo.GetDamage(), absorbPct);
+                }
+                else
+                //end npcbot
                 if ((dmgInfo.GetDamageType() == SPELL_DIRECT_DAMAGE) && roll_chance_f(GetTarget()->GetFloatValue(PLAYER_PARRY_PERCENTAGE)))
                     absorbAmount = CalculatePct(dmgInfo.GetDamage(), absorbPct);
             }
diff --git a/src/server/scripts/Spells/spell_druid.cpp b/src/server/scripts/Spells/spell_druid.cpp
index cf7e918..9ae8412 100644
--- a/src/server/scripts/Spells/spell_druid.cpp
+++ b/src/server/scripts/Spells/spell_druid.cpp
@@ -31,6 +31,10 @@
 #include "SpellMgr.h"
 #include "SpellScript.h"
 
+//npcbot
+#include "Group.h"
+//end npcbot
+
 enum DruidSpells
 {
     SPELL_DRUID_BEAR_FORM_PASSIVE           = 1178,
@@ -1195,6 +1199,10 @@ class spell_dru_rip : public AuraScript
     bool Load() override
     {
         Unit* caster = GetCaster();
+        //npcbot
+        if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
         return caster && GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -1204,6 +1212,22 @@ class spell_dru_rip : public AuraScript
 
         if (Unit* caster = GetCaster())
         {
+            //npcbot
+            if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            {
+                uint8 botcp = caster->ToCreature()->GetCreatureComboPoints();
+                // Idol of Feral Shadows. Can't be handled as SpellMod due its dependency from CPs
+                if (AuraEffect const* auraEffIdolOfFeralShadows = caster->GetAuraEffect(SPELL_DRUID_IDOL_OF_FERAL_SHADOWS, EFFECT_0))
+                    amount += botcp * auraEffIdolOfFeralShadows->GetAmount();
+                // Idol of Worship. Can't be handled as SpellMod due its dependency from CPs
+                else if (AuraEffect const* auraEffIdolOfWorship = caster->GetAuraEffect(SPELL_DRUID_IDOL_OF_WORSHIP, EFFECT_0))
+                    amount += botcp * auraEffIdolOfWorship->GetAmount();
+
+                amount += int32(CalculatePct(caster->GetTotalAttackPowerValue(BASE_ATTACK), botcp));
+                return;
+            }
+            //end npcbot
+
             // 0.01 * $AP * cp
             uint8 cp = caster->ToPlayer()->GetComboPoints();
 
@@ -1752,6 +1776,41 @@ class spell_dru_t10_restoration_4p_bonus : public SpellScript
 
     void FilterTargets(std::list<WorldObject*>& targets)
     {
+        //npcbot
+        if (Creature* bot = GetCaster()->ToCreature())
+        {
+            if (bot->IsFreeBot())
+            {
+                targets.clear();
+                targets.push_back(bot);
+                return;
+            }
+
+            targets.remove(GetExplTargetUnit());
+            std::list<Unit*> tempTargets;
+            Group const* gr = bot->GetBotOwner()->GetGroup();
+            if (gr && !gr->IsMember(bot->GetGUID()))
+                gr = nullptr;
+
+            if (gr)
+                for (std::list<WorldObject*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    if (gr->IsMember((*itr)->GetGUID()))
+                        tempTargets.push_back((*itr)->ToUnit());
+
+            if (tempTargets.empty())
+            {
+                targets.clear();
+                FinishCast(SPELL_FAILED_DONT_REPORT);
+                return;
+            }
+
+            Unit* target = Trinity::Containers::SelectRandomContainerElement(tempTargets);
+            targets.clear();
+            targets.push_back(target);
+            return;
+        }
+        //end npcbot
+
         if (!GetCaster()->ToPlayer()->GetGroup())
         {
             targets.clear();
@@ -1803,6 +1862,12 @@ class spell_dru_t10_restoration_4p_bonus_dummy : public AuraScript
         if (!healInfo || !healInfo->GetHeal())
             return false;
 
+        //npcbot: support for Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
+        Creature* creCaster = eventInfo.GetActor()->ToCreature();
+        if (creCaster && creCaster->IsNPCBot())
+            return true;
+        //end npcbot
+
         Player* caster = eventInfo.GetActor()->ToPlayer();
         if (!caster)
             return false;
diff --git a/src/server/scripts/Spells/spell_generic.cpp b/src/server/scripts/Spells/spell_generic.cpp
index 066fa6f..f551c38 100644
--- a/src/server/scripts/Spells/spell_generic.cpp
+++ b/src/server/scripts/Spells/spell_generic.cpp
@@ -266,6 +266,11 @@ class spell_gen_arena_drink : public AuraScript
 
     bool Load() override
     {
+        //npcbot
+        if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
+
         return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -287,6 +292,14 @@ class spell_gen_arena_drink : public AuraScript
         if (!regen)
             return;
 
+        //npcbot
+        if (GetCaster()->GetTypeId() == TYPEID_UNIT)
+        {
+            isPeriodic = false;
+            return;
+        }
+        //end npcbot
+
         // default case - not in arena
         if (!GetCaster()->ToPlayer()->InArena())
             isPeriodic = false;
@@ -298,6 +311,14 @@ class spell_gen_arena_drink : public AuraScript
         if (!regen)
             return;
 
+        //npcbot
+        if (GetCaster()->GetTypeId() == TYPEID_UNIT)
+        {
+            regen->ChangeAmount(amount);
+            return;
+        }
+        //end npcbot
+
         // default case - not in arena
         if (!GetCaster()->ToPlayer()->InArena())
             regen->ChangeAmount(amount);
diff --git a/src/server/scripts/Spells/spell_hunter.cpp b/src/server/scripts/Spells/spell_hunter.cpp
index 7aac8eb..5520b85 100644
--- a/src/server/scripts/Spells/spell_hunter.cpp
+++ b/src/server/scripts/Spells/spell_hunter.cpp
@@ -1380,6 +1380,22 @@ class spell_hun_sniper_training : public SpellScriptLoader
 
             void HandleUpdatePeriodic(AuraEffect* aurEff)
             {
+                //npcbot: handle creatures, remove dead trigger
+                if (!GetUnitOwner()->IsAlive())
+                    return;
+                if (Creature const* bot = GetUnitOwner()->ToCreature())
+                {
+                    if (!bot->IsNPCBot())
+                        return;
+
+                    int32 baseAmount = aurEff->GetBaseAmount();
+                    int32 amount = bot->isMoving() ?
+                    bot->CalculateSpellDamage(GetSpellInfo(), aurEff->GetEffIndex(), &baseAmount) :
+                    aurEff->GetAmount() - 1;
+                    aurEff->SetAmount(amount);
+                    return;
+                }
+                //end npcbot
                 if (Player* playerTarget = GetUnitOwner()->ToPlayer())
                 {
                     int32 baseAmount = aurEff->GetBaseAmount();
diff --git a/src/server/scripts/Spells/spell_mage.cpp b/src/server/scripts/Spells/spell_mage.cpp
index 79fd6e2..4fb97e2 100644
--- a/src/server/scripts/Spells/spell_mage.cpp
+++ b/src/server/scripts/Spells/spell_mage.cpp
@@ -1452,6 +1452,12 @@ class spell_mage_summon_water_elemental : public SpellScriptLoader
             void HandleDummy(SpellEffIndex /*effIndex*/)
             {
                 Unit* caster = GetCaster();
+
+                //npcbot: prevent default handler for bots
+                if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+                    return;
+                //end npcbot
+
                 // Glyph of Eternal Water
                 if (caster->HasAura(SPELL_MAGE_GLYPH_OF_ETERNAL_WATER))
                     caster->CastSpell(caster, SPELL_MAGE_SUMMON_WATER_ELEMENTAL_PERMANENT, true);
diff --git a/src/server/scripts/Spells/spell_paladin.cpp b/src/server/scripts/Spells/spell_paladin.cpp
index 45975e4..ea5dcfc 100644
--- a/src/server/scripts/Spells/spell_paladin.cpp
+++ b/src/server/scripts/Spells/spell_paladin.cpp
@@ -169,6 +169,12 @@ class spell_pal_ardent_defender : public SpellScriptLoader
             {
                 _absorbPct = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
                 _healPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue();
+
+                //npcbot - allow for npcbots
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
+
                 return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -183,6 +189,40 @@ class spell_pal_ardent_defender : public SpellScriptLoader
                 Unit* victim = GetTarget();
                 int32 remainingHealth = victim->GetHealth() - dmgInfo.GetDamage();
                 uint32 allowedHealth = victim->CountPctFromMaxHealth(35);
+
+                //npcbot - calc for bots
+                if (victim->GetTypeId() == TYPEID_UNIT/* && victim->ToCreature()->IsNPCBot()*/)
+                {
+                    if (remainingHealth <= 0 && !victim->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL) &&
+                        !victim->ToCreature()->HasSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        absorbAmount = dmgInfo.GetDamage();
+
+                        float defenseSkillValue = victim->GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (rating from gear)
+                        float reqDefForMaxHeal = victim->GetMaxSkillValueForLevel() + 140.0f;
+                        float defenseFactor = std::min(1.0f, defenseSkillValue / reqDefForMaxHeal);
+
+                        CastSpellExtraArgs args(aurEff);
+                        args.AddSpellBP0(victim->CountPctFromMaxHealth(lroundf(_healPct * defenseFactor)));
+                        victim->CastSpell(victim, PAL_SPELL_ARDENT_DEFENDER_HEAL, args);
+                        victim->GetSpellHistory()->AddCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, 0, std::chrono::minutes(2));
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (victim->GetHealth() < allowedHealth)
+                            ? dmgInfo.GetDamage()
+                            : allowedHealth - remainingHealth;
+                        absorbAmount = CalculatePct(damageToReduce, _absorbPct);
+                    }
+
+                    return;
+                }
+                //end npcbot
+
                 // If damage kills us
                 if (remainingHealth <= 0 && !victim->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
                 {
@@ -535,6 +575,23 @@ class spell_pal_divine_sacrifice : public AuraScript
     {
         if (Unit* caster = GetCaster())
         {
+            //npcbot: handle for bots
+            if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            {
+                Player const* owner = caster->ToCreature()->GetBotOwner();
+                if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+                    return false;
+
+                if (owner->GetGroup())
+                    groupSize = owner->GetGroup()->GetMembersCount();
+                else
+                    groupSize = 1;
+
+                remainingAmount = (caster->CountPctFromMaxHealth(GetSpellInfo()->Effects[EFFECT_2].CalcValue(caster)) * groupSize);
+                minHpPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue(caster);
+                return true;
+            }
+            //end npcbot
             if (caster->GetTypeId() == TYPEID_PLAYER)
             {
                 if (caster->ToPlayer()->GetGroup())
@@ -1832,6 +1889,9 @@ class spell_pal_righteous_defense : public SpellScript
     {
         Unit* caster = GetCaster();
         if (caster->GetTypeId() != TYPEID_PLAYER)
+            //npcbot: this player check makes no sense
+            if (!(caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot()))
+            //end npcbot
             return SPELL_FAILED_DONT_REPORT;
 
         if (Unit* target = GetExplTargetUnit())
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 43865fa..9c76816 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -988,6 +988,9 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() override
             {
+                //npcbot
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
+                //end npcbot
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -1030,6 +1033,10 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                //npcbot: check for player makes no sense
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+                    caster = (Player*)GetCaster();
+                //end npcbot
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target))
                     {
@@ -1221,6 +1228,9 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() override
             {
+                //npcbot
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
+                //end npcbot
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/scripts/Spells/spell_rogue.cpp b/src/server/scripts/Spells/spell_rogue.cpp
index 17a5cdb..6a3918a 100644
--- a/src/server/scripts/Spells/spell_rogue.cpp
+++ b/src/server/scripts/Spells/spell_rogue.cpp
@@ -126,6 +126,10 @@ class spell_rog_cheat_death : public SpellScriptLoader
             bool Load() override
             {
                 absorbChance = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
+                //npcbot
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
                 return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -137,6 +141,27 @@ class spell_rog_cheat_death : public SpellScriptLoader
 
             void Absorb(AuraEffect* /*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
             {
+                //npcbot
+                if (Creature* bot = GetTarget()->ToCreature())
+                {
+                    if (dmgInfo.GetDamage() < bot->GetHealth() || bot->HasSpellCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) ||
+                        bot->GetSpellHistory()->HasCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) || !roll_chance_i(absorbChance))
+                        return;
+
+                    bot->CastSpell(bot, SPELL_ROGUE_CHEAT_DEATH_COOLDOWN, true);
+                    bot->GetSpellHistory()->AddCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN, 0, std::chrono::minutes(1));
+
+                    uint32 health10 = bot->CountPctFromMaxHealth(10);
+
+                    if (bot->GetHealth() > health10)
+                        absorbAmount = dmgInfo.GetDamage() - bot->GetHealth() + health10;
+                    else
+                        absorbAmount = dmgInfo.GetDamage();
+
+                    return;
+                }
+                //end npcbot
+
                 Player* target = GetTarget()->ToPlayer();
                 if (dmgInfo.GetDamage() < target->GetHealth() || target->GetSpellHistory()->HasCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) || !roll_chance_i(absorbChance))
                     return;
@@ -674,6 +699,10 @@ class spell_rog_rupture : public SpellScriptLoader
             {
                 Unit* caster = GetCaster();
                 BonusDuration = 0;
+                //npcbot
+                if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
                 return caster && caster->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -693,6 +722,18 @@ class spell_rog_rupture : public SpellScriptLoader
                         0.0375f         // 5 points: ${($m1 + $b1*5 + 0.0375 * $AP) * 8} damage over 16 secs
                     };
 
+                    //npcbot
+                    if (caster->GetTypeId() == TYPEID_UNIT)
+                    {
+                        uint8 cp = caster->ToCreature()->GetCreatureComboPoints();
+                        if (cp > 5)
+                            cp = 5;
+
+                        amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * attackpowerPerCombo[cp]);
+                        return;
+                    }
+                    //end npcbot
+
                     uint8 cp = caster->ToPlayer()->GetComboPoints();
                     if (cp > 5)
                         cp = 5;
@@ -829,6 +870,12 @@ class spell_rog_setup : public SpellScriptLoader
                     if (eventInfo.GetActor() == target->GetSelectedUnit())
                         return true;
 
+                //npcbot
+                if (Creature* creature = GetTarget()->ToCreature())
+                    if (creature->IsNPCBot())
+                        return true;
+                //end npcbot
+
                 return false;
             }
 
@@ -1066,6 +1113,11 @@ public:
             if (!caster)
                 return;
 
+            //npcbot
+            if (Creature* bot = caster->ToCreature())
+                bot->CastSpell(nullptr, SPELL_ROGUE_HONOR_AMONG_THIEVES_2, true);
+            //end npcbot
+
             if (Player* player = caster->ToPlayer())
                 player->CastSpell(nullptr, SPELL_ROGUE_HONOR_AMONG_THIEVES_2, true);
         }
diff --git a/src/server/scripts/Spells/spell_shaman.cpp b/src/server/scripts/Spells/spell_shaman.cpp
index 1f4c4d4..2043674 100644
--- a/src/server/scripts/Spells/spell_shaman.cpp
+++ b/src/server/scripts/Spells/spell_shaman.cpp
@@ -475,6 +475,16 @@ class spell_sha_earthbind_totem : public SpellScriptLoader
             {
                 if (!GetCaster())
                     return;
+
+                //npcbot: workaround for bots
+                if (ObjectGuid creatorGuid = GetCaster()->GetCreatorGUID())
+                    if (!creatorGuid.IsPlayer())
+                        if (Creature const* bot = ObjectAccessor::GetCreature(*GetCaster(), creatorGuid))
+                            if (AuraEffect const* aur = bot->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 2289, 0))
+                                if (roll_chance_i(aur->GetBaseAmount()))
+                                    GetTarget()->CastSpell(nullptr, SPELL_SHAMAN_TOTEM_EARTHEN_POWER, true);
+                //end npcbot
+
                 if (Player* owner = GetCaster()->GetCharmerOrOwnerPlayerOrPlayerItself())
                     if (AuraEffect* aur = owner->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 2289, 0))
                         if (roll_chance_i(aur->GetBaseAmount()))
@@ -713,6 +723,23 @@ class spell_sha_flametongue_weapon : public SpellScriptLoader
 
             bool CheckProc(ProcEventInfo& eventInfo)
             {
+                //npcbot: handle bot enchant check
+                Creature* bot = eventInfo.GetActor()->ToCreature();
+                if (bot && bot->IsNPCBot())
+                {
+                    Item* item = bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID());
+                    if (!item)
+                        return false;
+
+                    WeaponAttackType attType = bot->GetBotEquips(0/*BOT_SLOT_MAINHAND*/) == item ? BASE_ATTACK : OFF_ATTACK;
+                    if ((attType == BASE_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)) ||
+                        (attType == OFF_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_OFFHAND_ATTACK)))
+                        return false;
+
+                    return true;
+                }
+                //end npcbot
+
                 Player* player = eventInfo.GetActor()->ToPlayer();
                 if (!player)
                     return false;
@@ -736,6 +763,42 @@ class spell_sha_flametongue_weapon : public SpellScriptLoader
             {
                 PreventDefaultAction();
 
+                //npcbot: handle bot enchant proc
+                Creature* bot = eventInfo.GetActor()->ToCreature();
+                if (bot && bot->IsNPCBot())
+                {
+                    Unit* target = eventInfo.GetProcTarget();
+                    WeaponAttackType attType;
+                    if (eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)
+                        attType = BASE_ATTACK;
+                    else
+                        attType = OFF_ATTACK;
+
+                    Item* item = ASSERT_NOTNULL(bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID()));
+
+                    float basePoints = GetSpellInfo()->Effects[aurEff->GetEffIndex()].CalcValue();
+
+                    float attackSpeed = bot->GetAttackTime(attType) / 1000.f;
+                    float fireDamage = basePoints / 100.0f;
+                    fireDamage *= attackSpeed;
+
+                    RoundToInterval(fireDamage, basePoints / 77.0f, basePoints / 25.0f);
+                    float spellPowerBonus = bot->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_FIRE);
+                    spellPowerBonus += target->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELL_SCHOOL_MASK_FIRE);
+
+                    float const factorMod = bot->CalculateSpellpowerCoefficientLevelPenalty(GetSpellInfo());
+                    float const spCoeff = 0.03811f;
+                    spellPowerBonus *= spCoeff * attackSpeed * factorMod;
+
+                    CastSpellExtraArgs args(aurEff);
+                    args
+                        .SetCastItem(item)
+                        .AddSpellBP0(fireDamage + spellPowerBonus);
+                    bot->CastSpell(target, SPELL_SHAMAN_FLAMETONGUE_ATTACK, args);
+                    return;
+                }
+                //end npcbot
+
                 Player* player = eventInfo.GetActor()->ToPlayer();
                 Unit* target = eventInfo.GetProcTarget();
                 WeaponAttackType attType = BASE_ATTACK;
@@ -2308,6 +2371,23 @@ class spell_sha_windfury_weapon : public SpellScriptLoader
 
             bool CheckProc(ProcEventInfo& eventInfo)
             {
+                //npcbot: handle bot enchant check
+                Creature* bot = eventInfo.GetActor()->ToCreature();
+                if (bot && bot->IsNPCBot())
+                {
+                    Item* item = bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID());
+                    if (!item)
+                        return false;
+
+                    WeaponAttackType attType = bot->GetBotEquips(0/*BOT_SLOT_MAINHAND*/) == item ? BASE_ATTACK : OFF_ATTACK;
+                    if ((attType == BASE_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)) ||
+                        (attType == OFF_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_OFFHAND_ATTACK)))
+                        return false;
+
+                    return true;
+                }
+                //end npcbot
+
                 Player* player = eventInfo.GetActor()->ToPlayer();
                 if (!player)
                     return false;
@@ -2331,6 +2411,53 @@ class spell_sha_windfury_weapon : public SpellScriptLoader
             {
                 PreventDefaultAction();
 
+                //npcbot: handle bot enchant proc
+                Creature* bot = eventInfo.GetActor()->ToCreature();
+                if (bot && bot->IsNPCBot())
+                {
+                    uint32 spellId = 0;
+                    WeaponAttackType attType;
+                    if (eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)
+                    {
+                        spellId = SPELL_SHAMAN_WINDFURY_ATTACK_MH;
+                        attType = BASE_ATTACK;
+                    }
+                    else
+                    {
+                        spellId = SPELL_SHAMAN_WINDFURY_ATTACK_OH;
+                        attType = OFF_ATTACK;
+                    }
+
+                    Item* item = ASSERT_NOTNULL(bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID()));
+
+                    int32 enchantId = static_cast<int32>(item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+                    int32 extraAttackPower = 0;
+                    SpellInfo const* spellInfo = sSpellMgr->AssertSpellInfo(SPELL_SHAMAN_WINDFURY_WEAPON_R1);
+                    while (spellInfo)
+                    {
+                        if (spellInfo->Effects[EFFECT_0].MiscValue == enchantId)
+                        {
+                            extraAttackPower = spellInfo->Effects[EFFECT_1].CalcValue(bot);
+                            break;
+                        }
+                        spellInfo = spellInfo->GetNextRankSpell();
+                    }
+
+                    if (!extraAttackPower)
+                        return;
+
+                    int32 amount = static_cast<int32>(extraAttackPower / 14.f * bot->GetAttackTime(attType) / 1000.f);
+
+                    CastSpellExtraArgs args(aurEff);
+                    args.AddSpellBP0(amount);
+                    // Attack twice
+                    for (uint8 i = 0; i < 2; ++i)
+                        bot->CastSpell(eventInfo.GetProcTarget(), spellId, args);
+
+                    return;
+                }
+                //end npcbot
+
                 Player* player = eventInfo.GetActor()->ToPlayer();
 
                 uint32 spellId = 0;
diff --git a/src/server/scripts/Spells/spell_warrior.cpp b/src/server/scripts/Spells/spell_warrior.cpp
index 710e2ae..17c3045 100644
--- a/src/server/scripts/Spells/spell_warrior.cpp
+++ b/src/server/scripts/Spells/spell_warrior.cpp
@@ -336,6 +336,12 @@ class spell_warr_deep_wounds_aura : public SpellScriptLoader
                 if (!damageInfo)
                     return false;
 
+                //npcbot: allow for bots
+                if (eventInfo.GetActor()->GetTypeId() == TYPEID_UNIT &&
+                    eventInfo.GetActor()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
+
                 return eventInfo.GetActor()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/shared/DataStores/DBCStructure.h b/src/server/shared/DataStores/DBCStructure.h
index 56ea114..ff21883 100644
--- a/src/server/shared/DataStores/DBCStructure.h
+++ b/src/server/shared/DataStores/DBCStructure.h
@@ -896,13 +896,15 @@ struct ItemBagFamilyEntry
     //uint32 Name_lang_mask;                                // 17
 };
 
-/*
+
 struct ItemDisplayInfoEntry
 {
-    uint32 ID;                                              // 0
+/*
+  */uint32 ID;/*                                            // 0
     char const* ModelName[2];                               // 1-2
     char const* ModelTexture[2];                            // 3-4
-    char const* InventoryIcon[2];                           // 5-6
+  */char const* InventoryIcon;/*                            // 5
+    char const* InventoryIcon2;                             // 6
     uint32 GeosetGroup[3];                                  // 7-9
     uint32 Flags;                                           // 10
     uint32 SpellVisualID;                                   // 11
@@ -911,8 +913,9 @@ struct ItemDisplayInfoEntry
     char const* Texture[8];                                 // 15-22
     int32 ItemVisual;                                       // 23
     uint32 ParticleColorID;                                 // 24
-};
 */
+};
+
 
 /*
 struct ItemCondExtCostsEntry
diff --git a/src/server/shared/DataStores/DBCfmt.h b/src/server/shared/DataStores/DBCfmt.h
index 69d4e5f..35c8ca0 100644
--- a/src/server/shared/DataStores/DBCfmt.h
+++ b/src/server/shared/DataStores/DBCfmt.h
@@ -76,7 +76,7 @@ char constexpr GtRegenMPPerSptfmt[] = "f";
 char constexpr Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
 char constexpr Itemfmt[] = "niiiiiii";
 char constexpr ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-//char constexpr ItemDisplayTemplateEntryfmt[] = "nxxxxxxxxxxixxxxxxxxxxx";
+char constexpr ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 //char constexpr ItemCondExtCostsEntryfmt[] = "xiii";
 char constexpr ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char constexpr ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index b364635..e51357b 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -4084,3 +4084,243 @@ Metric.OverallStatusInterval = 1
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    NpcBot.Enable
+#        Description: Enables NpcBot system.
+#        Default:     1 - enable
+#                     0 - disable
+
+NpcBot.Enable = 1
+
+#    NpcBot.MaxBots
+#        Description: Maximum number of bots allowed for players.
+#        Default:     1
+#        Max:         39
+
+NpcBot.MaxBots = 1
+
+#    NpcBot.MaxBotsPerClass
+#        Description: Maximum bots of each class allowed for players.
+#        Default:     0 - no limit
+
+NpcBot.MaxBotsPerClass = 0
+
+#    NpcBot.BaseFollowDistance
+#        Description: Default bot follow distance.
+#        Note:        This parameter determines bots' formation size, distance at which bots
+#                     will chase and attack enemies.
+#        Note2:       This parameter is set for each player at login.
+#        Default:     30
+
+NpcBot.BaseFollowDistance = 30
+
+#    NpcBot.XpReduction
+#        Description: XP percent penalty for each bot used starting with second.
+#        Example:     3 bots, xp reduction is 20: ((3-1)*20) = 40%, 60% exp gained only.
+#        Note:        Maximum overall xp reduction is 90%.
+#        Default:     0
+
+NpcBot.XpReduction = 0
+
+#    NpcBot.HealTargetIconsMask
+#        Description: Icon number bitmask which bots use to search for additional
+#                     targets to buff, heal and protect (out of party).
+#        Note:        Many creatures cannot accept heal.
+#        Example:     To check Star, Triangle and Square we need 1 + 8 + 32 = 41.
+#        Default:     0 (Disable)
+#                     1 - Star
+#                     2 - Circle
+#                     4 - Diamond
+#                     8 - Triangle
+#                     16 - Moon
+#                     32 - Square
+#                     64 - Cross
+#                     128 - Skull
+
+NpcBot.HealTargetIconsMask = 0
+
+#    NpcBot.TankTargetIconMask
+#        Description: Icon number bitmask which bot tanks use to search for primary target.
+#        Note:        While icon is active NPCBot tanks will ignore any other targets
+#                     and will not break from combat to follow you.
+#        Example:     To check Star and Cross we need 1 + 64 = 65.
+#        Default:     0 (Disable)
+#                     1 - Star
+#                     2 - Circle
+#                     4 - Diamond
+#                     8 - Triangle
+#                     16 - Moon
+#                     32 - Square
+#                     64 - Cross
+#                     128 - Skull
+
+NpcBot.TankTargetIconMask = 0
+
+#    NpcBot.DPSTargetIconMask
+#        Description: Icon number bitmask which bots use to search for primary attack target.
+#        Note:        While icon is active NPCBots will ignore any other targets
+#                     and will not break from combat to follow you.
+#        Note2:       NPCBot tanks will prioritize targets pointed by TankTargetIconMask.
+#        Note3:       If you set multiple targets only one target at a time will be used.
+#        Example:     To check Skull and Circle we need 128 + 2 = 130.
+#        Default:     0 (Disable)
+#                     1 - Star
+#                     2 - Circle
+#                     4 - Diamond
+#                     8 - Triangle
+#                     16 - Moon
+#                     32 - Square
+#                     64 - Cross
+#                     128 - Skull
+
+NpcBot.DPSTargetIconMask = 0
+
+#    NpcBot.Mult.Damage.Physical
+#    NpcBot.Mult.Damage.Spell
+#    NpcBot.Mult.Healing
+#        Description: Multipliers for bots' damage and healing. Allows to balance bots vs players.
+#        Default:     1.0
+#        Minimum:     0.1
+#        Maximum:    10.0
+
+NpcBot.Mult.Damage.Physical = 1.0
+NpcBot.Mult.Damage.Spell    = 1.0
+NpcBot.Mult.Healing         = 1.0
+
+#    NpcBot.Enable.Dungeon
+#    NpcBot.Enable.Raid
+#    NpcBot.Enable.BG
+#    NpcBot.Enable.Arena
+#    NpcBot.Enable.DungeonFinder
+#        Description: Allow bots to enter PvE/PvP areas and Dungeon Finder query.
+#        Default:     1 - (NpcBot.Enable.Dungeon)
+#                     0 - (NpcBot.Enable.Raid)
+#                     0 - (NpcBot.Enable.BG)
+#                     0 - (NpcBot.Enable.Arena)
+#                     1 - (NpcBot.Enable.DungeonFinder)
+
+NpcBot.Enable.Dungeon       = 1
+NpcBot.Enable.Raid          = 0
+NpcBot.Enable.BG            = 0
+NpcBot.Enable.Arena         = 0
+NpcBot.Enable.DungeonFinder = 1
+
+#    NpcBot.Limit.Dungeon
+#    NpcBot.Limit.Raid
+#        Description: Enable/Disable instance players limitation rules for bots.
+#        Default:     1 - (NpcBot.Limit.Dungeon)
+#                     1 - (NpcBot.Limit.Raid)
+
+NpcBot.Limit.Dungeon = 1
+NpcBot.Limit.Raid    = 1
+
+#    NpcBot.Cost
+#        Description: Bot recruitment cost (in copper).
+#        Note:        This value is for level 80 characters, for lower levels cost is reduced greatly.
+#        Default:     1000000 (100 gold)
+
+NpcBot.Cost = 1000000
+
+#    NpcBot.UpdateDelay.Base
+#        Description: Base delay between bot AI update cycles (in milliseconds).
+#        Note:        This parameter allows you to increase reaction time and slow down bots in general.
+#                     This may be useful if you want to balance bots in PvP.
+#        Note2:       This value is added on top of existing semi-randomized delay.
+#        Default:     0 (No additional delay)
+
+NpcBot.UpdateDelay.Base = 0
+
+#    NpcBot.PvP
+#        Description: Allow bots to attack player-controlled units (players, pets, bots, etc.).
+#        Note:        This rule only applies to player-controlled bots.
+#        Default:     1
+
+NpcBot.PvP = 1
+
+#    NpcBot.Movements.InterruptFood
+#        Description: Remove food and drink auras when starting to move.
+#        Note:        Bots don't use food or drink if not standing still.
+#        Default:     0 - (Do not interrupt)
+#                     1 - (Interrupt food and drink)
+
+NpcBot.Movements.InterruptFood = 0
+
+#    NpcBot.EquipmentDisplay.Enable
+#        Description: Enable displaying equipment changes other than weapons on bot models.
+#        Note:        Client limits equipment updates to
+#                     1) relog
+#                     2) taking a taxi flight
+#                     3) teleporting between maps
+#                     4) not seeing this bot for 3 minutes
+#                     5) bot changing displayId (polymorph, shapeshift, etc.)
+#        Note2:       If client registers (5) of a single bot 3+ times
+#                     said client may crash at exiting game (Error #132) unless (4) happens.
+#        Note3:       Changing this setting requires server restart.
+#        Note4:       Bots having no equipment will not appear naked.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+NpcBot.EquipmentDisplay.Enable = 1
+
+#    NpcBot.EquipmentDisplay.ShowCloak
+#    NpcBot.EquipmentDisplay.ShowHelm
+#        Description: Equipment display rules.
+#        Default:     1 - (NpcBot.EquipmentDisplay.ShowCloak)
+#                     1 - (NpcBot.EquipmentDisplay.ShowHelm)
+
+NpcBot.EquipmentDisplay.ShowCloak = 1
+NpcBot.EquipmentDisplay.ShowHelm  = 1
+
+#    NpcBot.NewClasses.<Class>.Enable
+#        Description: Allow players to hire bots of non-standard classes.
+#        Note:        Some bot abilities may be unbalanced or game breaking under certain circumstances.
+#        Default:     1 - (NpcBot.NewClasses.Blademaster.Enable)
+#                     1 - (NpcBot.NewClasses.ObsidianDestroyer.Enable)
+#                     1 - (NpcBot.NewClasses.Archmage.Enable)
+#                     1 - (NpcBot.NewClasses.Dreadlord.Enable)
+#                     1 - (NpcBot.NewClasses.SpellBreaker.Enable)
+#                     1 - (NpcBot.NewClasses.DarkRanger.Enable)
+
+NpcBot.NewClasses.Blademaster.Enable       = 1
+NpcBot.NewClasses.ObsidianDestroyer.Enable = 1
+NpcBot.NewClasses.Archmage.Enable          = 1
+NpcBot.NewClasses.Dreadlord.Enable         = 1
+NpcBot.NewClasses.SpellBreaker.Enable      = 1
+NpcBot.NewClasses.DarkRanger.Enable        = 1
+
+#    NpcBot.Stats.Limits.Enable
+#        Description: Enable or disable stats limits for bots.
+#        Default:     0 - Disabled
+
+NpcBot.Stats.Limits.Enable = 0
+
+#    NpcBot.Stats.Limits.<Stat>
+#        Description: Set dodge, parry, block and crit chance percentage limit for bots.
+#        Note:        Some bot classes may ignore some of these values.
+#        Note2:       Auras can still increase these stats above limit.
+#        Default:     95.0 (95%)
+
+NpcBot.Stats.Limits.Dodge = 95.0
+NpcBot.Stats.Limits.Parry = 95.0
+NpcBot.Stats.Limits.Block = 95.0
+NpcBot.Stats.Limits.Crit  = 95.0
+
+#    NpcBot.InfoPacketsLimit
+#        Description: This is a workaround for known issue #5.
+#                     If more than 100 bots are spawned in a single spot players trying
+#                     to approach them will be kicked by AntiDOS protection due to
+#                     'flooding' CMSG_GET_MIRRORIMAGE_DATA packets. This setting
+#                     overrides packets limit per tick for that request type.
+#        Note:        If you care about your server stability at all, use this only as a
+#                     temporary solution and spread your bots spawn points properly.
+#        Default:     -1  - (use default limit set by TC devs)
+#                     500 - (500 bots in one spot won't get you kicked)
+
+NpcBot.InfoPacketsLimit = -1
+
+#
+###################################################################################################
-- 
2.10.0.windows.1

