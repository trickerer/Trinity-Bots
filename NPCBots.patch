 .circleci/config.yml                               |    27 +-
 README.md                                          |    44 +-
 sql/Bots/1_world_bot_appearance.sql                |   305 +
 sql/Bots/2_world_bot_extras.sql                    |   358 +
 sql/Bots/3_world_bots.sql                          |   547 +
 sql/Bots/4_world_generate_bot_equips.sql           |   159 +
 sql/Bots/5_world_botgiver.sql                      |    18 +
 sql/Bots/characters_bots.sql                       |    26 +
 sql/Bots/locales/ruRU/npc_text_locale.sql          |   380 +
 sql/Bots/locales/zhCN/npc_text_locale.sql          |   380 +
 sql/Bots/locales/zhTW/npc_text_locale.sql          |   343 +
 sql/Bots/merge_sqls_auth_unix.sh                   |     2 +
 sql/Bots/merge_sqls_auth_windows.bat               |     1 +
 sql/Bots/merge_sqls_characters_unix.sh             |     3 +
 sql/Bots/merge_sqls_characters_windows.bat         |     1 +
 sql/Bots/merge_sqls_world_unix.sh                  |     3 +
 sql/Bots/merge_sqls_world_windows.bat              |     1 +
 .../auth/2021_09_14_00_rbac_permissions.sql        |    39 +
 .../auth/2021_09_14_01_rbac_linked_permissions.sql |    39 +
 .../auth/2021_12_29_00_rbac_permissions.sql        |     7 +
 .../auth/2021_12_29_01_rbac_linked_permissions.sql |     7 +
 .../auth/2022_06_24_00_rbac_permissions.sql        |     7 +
 .../auth/2022_06_24_01_rbac_linked_permissions.sql |     7 +
 .../auth/2022_07_04_00_rbac_permissions.sql        |     7 +
 .../auth/2022_07_04_01_rbac_linked_permissions.sql |     7 +
 .../auth/2022_11_30_00_rbac_permissions.sql        |     7 +
 .../auth/2022_11_30_rbac_linked_permissions.sql    |     7 +
 ...15_characters_npcbot_NPCBots_4.7.8a-4.7.27a.sql |     1 +
 .../2020_06_21_characters_npcbot_43fceb98.sql      |   172 +
 ...8_characters_npcbot_NPCBots_4.7.34a-4.7.39a.sql |     1 +
 .../characters/2021_01_04_characters_npcbot.sql    |     1 +
 .../2021_01_24_characters_npcbot_stats.sql         |    32 +
 .../characters/2021_08_27_characters_npcbot.sql    |     2 +
 .../2022_11_15_characters_npcbot_transmog.SQL      |    10 +
 .../2022_11_27_characters_npcbot_group_member.sql  |    10 +
 .../2020_07_08_creature_template_npcbot_extras.sql |     2 +
 .../updates/world/2020_09_25_creature_template.sql |     2 +
 .../world/2020_10_14_creature_classlevelstats.sql  |   611 +
 .../updates/world/2020_10_14_creature_template.sql |    50 +
 .../updates/world/2020_10_15_creature_template.sql |     2 +
 sql/Bots/updates/world/2020_11_07_npc_text.sql     |   329 +
 sql/Bots/updates/world/2020_12_11_npc_text.sql     |     4 +
 sql/Bots/updates/world/2021_01_04_npc_text.sql     |    19 +
 sql/Bots/updates/world/2021_01_05_npc_text.sql     |    13 +
 sql/Bots/updates/world/2021_01_08_npc_text.sql     |     9 +
 sql/Bots/updates/world/2021_02_01_npc_text.sql     |     2 +
 sql/Bots/updates/world/2021_03_29_npc_text.sql     |    10 +
 .../2021_08_20_creature_template_npcbot_extras.sql |     2 +
 sql/Bots/updates/world/2021_08_27_npc_text.sql     |     4 +
 .../updates/world/2021_10_12_creature_template.sql |     8 +
 ...22_01_02_00_creature_template_npcbot_extras.sql |    12 +
 .../2022_01_02_01_generate_equips_necromancer.sql  |    57 +
 .../world/2022_01_02_02_creature_template.sql      |    21 +
 sql/Bots/updates/world/2022_01_02_03_npc_text.sql  |    15 +
 sql/Bots/updates/world/2022_01_31_npc_text.sql     |    10 +
 ...22_06_15_00_creature_template_npcbot_extras.sql |     2 +
 sql/Bots/updates/world/2022_06_17_npc_text.sql     |     3 +
 ...22_06_22_00_creature_template_npcbot_extras.sql |    11 +
 .../2022_06_22_01_generate_equips_sea_witch.sql    |    50 +
 .../world/2022_06_22_02_creature_template.sql      |    21 +
 sql/Bots/updates/world/2022_06_22_03_npc_text.sql  |    26 +
 sql/Bots/updates/world/2022_06_23_00_command.sql   |    39 +
 sql/Bots/updates/world/2022_06_24_00_npc_text.sql  |     7 +
 sql/Bots/updates/world/2022_06_24_01_npc_text.sql  |     8 +
 sql/Bots/updates/world/2022_06_24_02_command.sql   |     4 +
 sql/Bots/updates/world/2022_07_04_00_command.sql   |     4 +
 sql/Bots/updates/world/2022_07_25_00_npc_text.sql  |     7 +
 sql/Bots/updates/world/2022_11_15_00_npc_text.sql  |     7 +
 sql/Bots/updates/world/2022_11_30_00_command.sql   |     4 +
 sql/Bots/updates/world/2022_12_08_00_npc_text.sql  |     8 +
 src/common/Utilities/EventProcessor.h              |     1 +
 .../Database/Implementation/CharacterDatabase.cpp  |    24 +
 .../Database/Implementation/CharacterDatabase.h    |    20 +
 src/server/game/AI/CoreAI/UnitAI.cpp               |     3 +
 src/server/game/AI/NpcBots/bot_Events.h            |    72 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  1408 ++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 18711 +++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |   712 +
 src/server/game/AI/NpcBots/bot_archmage_ai.cpp     |   393 +
 src/server/game/AI/NpcBots/bot_bm_ai.cpp           |   934 +
 src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp  |   608 +
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp |  2112 +++
 src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp    |   543 +
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        |  2936 +++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  2379 +++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  1843 ++
 src/server/game/AI/NpcBots/bot_necromancer_ai.cpp  |   756 +
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      |  2792 +++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  2118 +++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  2040 ++
 src/server/game/AI/NpcBots/bot_sea_witch_ai.cpp    |   771 +
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  2825 +++
 src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp |   603 +
 src/server/game/AI/NpcBots/bot_sphynx_ai.cpp       |   605 +
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  2103 +++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      |  2264 +++
 src/server/game/AI/NpcBots/botcommands.cpp         |  2215 +++
 src/server/game/AI/NpcBots/botcommon.h             |   564 +
 src/server/game/AI/NpcBots/botdatamgr.cpp          |   709 +
 src/server/game/AI/NpcBots/botdatamgr.h            |   159 +
 src/server/game/AI/NpcBots/botdpstracker.cpp       |   133 +
 src/server/game/AI/NpcBots/botdpstracker.h         |    42 +
 src/server/game/AI/NpcBots/botdump.cpp             |  1019 +
 src/server/game/AI/NpcBots/botdump.h               |    51 +
 src/server/game/AI/NpcBots/botgiver.cpp            |   285 +
 src/server/game/AI/NpcBots/botgossip.h             |   132 +
 src/server/game/AI/NpcBots/botmgr.cpp              |  1771 ++
 src/server/game/AI/NpcBots/botmgr.h                |   240 +
 src/server/game/AI/NpcBots/botspell.h              |   246 +
 src/server/game/AI/NpcBots/bottext.h               |   397 +
 src/server/game/AI/NpcBots/bpet_ai.cpp             |  2445 +++
 src/server/game/AI/NpcBots/bpet_ai.h               |   176 +
 src/server/game/AI/NpcBots/bpet_archmage.cpp       |   141 +
 src/server/game/AI/NpcBots/bpet_dark_ranger.cpp    |   214 +
 src/server/game/AI/NpcBots/bpet_death_knight.cpp   |   191 +
 src/server/game/AI/NpcBots/bpet_dreadlord.cpp      |   164 +
 src/server/game/AI/NpcBots/bpet_druid.cpp          |   146 +
 src/server/game/AI/NpcBots/bpet_hunter.cpp         |  1000 +
 src/server/game/AI/NpcBots/bpet_mage.cpp           |   177 +
 src/server/game/AI/NpcBots/bpet_necromancer.cpp    |   193 +
 src/server/game/AI/NpcBots/bpet_priest.cpp         |   172 +
 src/server/game/AI/NpcBots/bpet_sea_witch.cpp      |   250 +
 src/server/game/AI/NpcBots/bpet_shaman.cpp         |   191 +
 src/server/game/AI/NpcBots/bpet_warlock.cpp        |   409 +
 src/server/game/AI/NpcBots/lib/bottraits.h         |   156 +
 src/server/game/AI/SmartScripts/SmartScript.cpp    |     3 +
 src/server/game/Accounts/RBAC.h                    |    39 +
 src/server/game/Battlegrounds/Battleground.cpp     |    35 +
 .../game/Battlegrounds/BattlegroundQueue.cpp       |    53 +
 src/server/game/Combat/CombatManager.cpp           |    37 +
 src/server/game/Combat/ThreatManager.cpp           |    14 +
 src/server/game/Conditions/ConditionMgr.cpp        |    49 +
 src/server/game/DataStores/DBCStores.cpp           |     4 +-
 src/server/game/DataStores/DBCStores.h             |     2 +-
 src/server/game/DungeonFinding/LFGMgr.cpp          |   180 +
 src/server/game/DungeonFinding/LFGScripts.cpp      |     3 +
 src/server/game/Entities/Creature/Creature.cpp     |   459 +
 src/server/game/Entities/Creature/Creature.h       |    79 +
 src/server/game/Entities/Creature/CreatureData.h   |     6 +-
 .../game/Entities/Creature/TemporarySummon.cpp     |    32 +
 .../Entities/Creature/enuminfo_CreatureData.cpp    |    12 +-
 src/server/game/Entities/Object/Object.cpp         |    85 +-
 src/server/game/Entities/Player/KillRewarder.cpp   |    15 +
 src/server/game/Entities/Player/Player.cpp         |   191 +
 src/server/game/Entities/Player/Player.h           |    25 +
 src/server/game/Entities/Totem/Totem.cpp           |    26 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    46 +-
 src/server/game/Entities/Unit/Unit.cpp             |   633 +
 src/server/game/Entities/Unit/Unit.h               |    15 +-
 src/server/game/Entities/Vehicle/Vehicle.cpp       |    34 +
 src/server/game/Globals/ObjectMgr.cpp              |    81 +
 src/server/game/Globals/ObjectMgr.h                |    21 +
 src/server/game/Grids/Notifiers/GridNotifiers.h    |     4 +
 src/server/game/Groups/Group.cpp                   |   133 +
 src/server/game/Groups/Group.h                     |     7 +
 src/server/game/Groups/GroupMgr.cpp                |     7 +
 src/server/game/Handlers/BattleGroundHandler.cpp   |    20 +
 src/server/game/Handlers/ItemHandler.cpp           |    13 +
 src/server/game/Handlers/SpellHandler.cpp          |   109 +
 src/server/game/Instances/InstanceScript.cpp       |    40 +
 src/server/game/Instances/InstanceScript.h         |     7 +
 src/server/game/Maps/Map.cpp                       |    42 +
 src/server/game/Maps/MapManager.cpp                |     8 +
 src/server/game/Movement/MotionMaster.cpp          |    20 +
 src/server/game/OutdoorPvP/OutdoorPvP.cpp          |    17 +
 src/server/game/Scripting/ScriptMgr.cpp            |     8 +
 src/server/game/Scripting/ScriptMgr.h              |     2 +
 src/server/game/Server/WorldSession.cpp            |    18 +
 src/server/game/Spells/Auras/SpellAuraEffects.cpp  |    72 +
 src/server/game/Spells/Auras/SpellAuras.cpp        |    23 +
 src/server/game/Spells/Spell.cpp                   |   146 +
 src/server/game/Spells/Spell.h                     |     3 +
 src/server/game/Spells/SpellEffects.cpp            |   159 +
 src/server/game/Spells/SpellInfo.cpp               |    51 +
 src/server/game/Spells/SpellMgr.cpp                |    12 +
 src/server/scripts/Commands/cs_npc.cpp             |    31 +
 .../CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp  |     5 +
 .../BattleForMountHyjal/hyjal_trash.cpp            |     8 +
 .../boss_icecrown_gunship_battle.cpp               |    28 +
 .../IcecrownCitadel/instance_icecrown_citadel.cpp  |    21 +
 .../Northrend/Naxxramas/boss_four_horsemen.cpp     |     4 +-
 .../Outland/BlackTemple/boss_warlord_najentus.cpp  |    17 +
 src/server/scripts/Spells/spell_dk.cpp             |    17 +
 src/server/scripts/Spells/spell_druid.cpp          |    66 +
 src/server/scripts/Spells/spell_generic.cpp        |    37 +
 src/server/scripts/Spells/spell_hunter.cpp         |    16 +
 src/server/scripts/Spells/spell_item.cpp           |    23 +
 src/server/scripts/Spells/spell_mage.cpp           |     6 +
 src/server/scripts/Spells/spell_paladin.cpp        |    64 +
 src/server/scripts/Spells/spell_priest.cpp         |    12 +
 src/server/scripts/Spells/spell_rogue.cpp          |    56 +
 src/server/scripts/Spells/spell_shaman.cpp         |   127 +
 src/server/scripts/Spells/spell_warrior.cpp        |    10 +
 src/server/shared/DataStores/DBCStructure.h        |     9 +-
 src/server/shared/DataStores/DBCfmt.h              |     2 +-
 src/server/shared/SharedDefines.h                  |     7 +
 src/server/worldserver/worldserver.conf.dist       |   314 +
 197 files changed, 71812 insertions(+), 76 deletions(-)
 create mode 100644 sql/Bots/1_world_bot_appearance.sql
 create mode 100644 sql/Bots/2_world_bot_extras.sql
 create mode 100644 sql/Bots/3_world_bots.sql
 create mode 100644 sql/Bots/4_world_generate_bot_equips.sql
 create mode 100644 sql/Bots/5_world_botgiver.sql
 create mode 100644 sql/Bots/characters_bots.sql
 create mode 100644 sql/Bots/locales/ruRU/npc_text_locale.sql
 create mode 100644 sql/Bots/locales/zhCN/npc_text_locale.sql
 create mode 100644 sql/Bots/locales/zhTW/npc_text_locale.sql
 create mode 100644 sql/Bots/merge_sqls_auth_unix.sh
 create mode 100644 sql/Bots/merge_sqls_auth_windows.bat
 create mode 100644 sql/Bots/merge_sqls_characters_unix.sh
 create mode 100644 sql/Bots/merge_sqls_characters_windows.bat
 create mode 100644 sql/Bots/merge_sqls_world_unix.sh
 create mode 100644 sql/Bots/merge_sqls_world_windows.bat
 create mode 100644 sql/Bots/updates/auth/2021_09_14_00_rbac_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2021_09_14_01_rbac_linked_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2021_12_29_00_rbac_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2021_12_29_01_rbac_linked_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2022_06_24_00_rbac_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2022_06_24_01_rbac_linked_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2022_07_04_00_rbac_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2022_07_04_01_rbac_linked_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2022_11_30_00_rbac_permissions.sql
 create mode 100644 sql/Bots/updates/auth/2022_11_30_rbac_linked_permissions.sql
 create mode 100644 sql/Bots/updates/characters/2020_05_15_characters_npcbot_NPCBots_4.7.8a-4.7.27a.sql
 create mode 100644 sql/Bots/updates/characters/2020_06_21_characters_npcbot_43fceb98.sql
 create mode 100644 sql/Bots/updates/characters/2020_10_08_characters_npcbot_NPCBots_4.7.34a-4.7.39a.sql
 create mode 100644 sql/Bots/updates/characters/2021_01_04_characters_npcbot.sql
 create mode 100644 sql/Bots/updates/characters/2021_01_24_characters_npcbot_stats.sql
 create mode 100644 sql/Bots/updates/characters/2021_08_27_characters_npcbot.sql
 create mode 100644 sql/Bots/updates/characters/2022_11_15_characters_npcbot_transmog.SQL
 create mode 100644 sql/Bots/updates/characters/2022_11_27_characters_npcbot_group_member.sql
 create mode 100644 sql/Bots/updates/world/2020_07_08_creature_template_npcbot_extras.sql
 create mode 100644 sql/Bots/updates/world/2020_09_25_creature_template.sql
 create mode 100644 sql/Bots/updates/world/2020_10_14_creature_classlevelstats.sql
 create mode 100644 sql/Bots/updates/world/2020_10_14_creature_template.sql
 create mode 100644 sql/Bots/updates/world/2020_10_15_creature_template.sql
 create mode 100644 sql/Bots/updates/world/2020_11_07_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2020_12_11_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_01_04_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_01_05_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_01_08_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_02_01_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_03_29_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_08_20_creature_template_npcbot_extras.sql
 create mode 100644 sql/Bots/updates/world/2021_08_27_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2021_10_12_creature_template.sql
 create mode 100644 sql/Bots/updates/world/2022_01_02_00_creature_template_npcbot_extras.sql
 create mode 100644 sql/Bots/updates/world/2022_01_02_01_generate_equips_necromancer.sql
 create mode 100644 sql/Bots/updates/world/2022_01_02_02_creature_template.sql
 create mode 100644 sql/Bots/updates/world/2022_01_02_03_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_01_31_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_06_15_00_creature_template_npcbot_extras.sql
 create mode 100644 sql/Bots/updates/world/2022_06_17_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_06_22_00_creature_template_npcbot_extras.sql
 create mode 100644 sql/Bots/updates/world/2022_06_22_01_generate_equips_sea_witch.sql
 create mode 100644 sql/Bots/updates/world/2022_06_22_02_creature_template.sql
 create mode 100644 sql/Bots/updates/world/2022_06_22_03_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_06_23_00_command.sql
 create mode 100644 sql/Bots/updates/world/2022_06_24_00_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_06_24_01_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_06_24_02_command.sql
 create mode 100644 sql/Bots/updates/world/2022_07_04_00_command.sql
 create mode 100644 sql/Bots/updates/world/2022_07_25_00_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_11_15_00_npc_text.sql
 create mode 100644 sql/Bots/updates/world/2022_11_30_00_command.sql
 create mode 100644 sql/Bots/updates/world/2022_12_08_00_npc_text.sql
 create mode 100644 src/server/game/AI/NpcBots/bot_Events.h
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_archmage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_bm_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_necromancer_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_sea_witch_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_sphynx_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommon.h
 create mode 100644 src/server/game/AI/NpcBots/botdatamgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botdatamgr.h
 create mode 100644 src/server/game/AI/NpcBots/botdpstracker.cpp
 create mode 100644 src/server/game/AI/NpcBots/botdpstracker.h
 create mode 100644 src/server/game/AI/NpcBots/botdump.cpp
 create mode 100644 src/server/game/AI/NpcBots/botdump.h
 create mode 100644 src/server/game/AI/NpcBots/botgiver.cpp
 create mode 100644 src/server/game/AI/NpcBots/botgossip.h
 create mode 100644 src/server/game/AI/NpcBots/botmgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.h
 create mode 100644 src/server/game/AI/NpcBots/botspell.h
 create mode 100644 src/server/game/AI/NpcBots/bottext.h
 create mode 100644 src/server/game/AI/NpcBots/bpet_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bpet_archmage.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_dark_ranger.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_death_knight.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_dreadlord.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_druid.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_hunter.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_mage.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_necromancer.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_priest.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_sea_witch.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_shaman.cpp
 create mode 100644 src/server/game/AI/NpcBots/bpet_warlock.cpp
 create mode 100644 src/server/game/AI/NpcBots/lib/bottraits.h

diff --git a/.circleci/config.yml b/.circleci/config.yml
index 5c53a91cc..437f63b82 100644
--- a/.circleci/config.yml
+++ b/.circleci/config.yml
@@ -52,11 +52,7 @@ jobs:
           command: |
             mkdir bin
             cd bin
-            if [ "$DOCKERHUB_PUSH_IMAGES" == "TRUE" ]; then
-              cmake ../ -DWITH_WARNINGS=1 -DWITH_COREDEBUG=0 -DUSE_COREPCH=1 -DUSE_SCRIPTPCH=1 -DTOOLS=1 -DSCRIPTS=static -DSERVERS=1 -DNOJEM=0 -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_FLAGS="-Werror" -DCMAKE_CXX_FLAGS="-Werror" -DCMAKE_INSTALL_PREFIX=check_install -DBUILD_TESTING=1
-            else
-              cmake ../ -DWITH_WARNINGS=1 -DWITH_COREDEBUG=0 -DUSE_COREPCH=1 -DUSE_SCRIPTPCH=1 -DTOOLS=1 -DSCRIPTS=static -DSERVERS=1 -DNOJEM=0 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_FLAGS="-Werror" -DCMAKE_CXX_FLAGS="-Werror" -DCMAKE_C_FLAGS_DEBUG="-DNDEBUG" -DCMAKE_CXX_FLAGS_DEBUG="-DNDEBUG" -DCMAKE_INSTALL_PREFIX=check_install -DBUILD_TESTING=1
-            fi
+            cmake ../ -DWITH_WARNINGS=1 -DWITH_COREDEBUG=0 -DUSE_COREPCH=1 -DUSE_SCRIPTPCH=1 -DTOOLS=1 -DSCRIPTS=static -DSERVERS=1 -DNOJEM=0 -DCMAKE_BUILD_TYPE=Debug -DCMAKE_C_FLAGS="-Werror" -DCMAKE_CXX_FLAGS="-Werror" -DCMAKE_C_FLAGS_DEBUG="-DNDEBUG" -DCMAKE_CXX_FLAGS_DEBUG="-DNDEBUG" -DCMAKE_INSTALL_PREFIX=check_install -DBUILD_TESTING=1
             cd ..
       - run:
           name: Build
@@ -74,27 +70,6 @@ jobs:
             cd bin/check_install/bin
             ./authserver --version
             ./worldserver --version
-      - setup_remote_docker:
-          version: 19.03.13
-      - run:
-          name: Create docker images
-          command: |
-            cd bin/check_install/bin
-            cp -r ../../../contrib/Docker/* .
-            cp -r ../../../sql ./sql
-            image_prefix=$(echo $CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME | tr '[:upper:]' '[:lower:]')
-            echo $image_prefix
-            docker build --file Dockerfile --force-rm --tag $image_prefix:$CIRCLE_SHA1 --tag $image_prefix:$(echo $CIRCLE_BRANCH | tr '/' '-' | tr '[:upper:]' '[:lower:]') .
-            docker save $image_prefix | gzip > ../../../docker.tar.gz
-            if [ "$DOCKERHUB_PUSH_IMAGES" == "TRUE" ]; then
-              if [ "$CIRCLE_BRANCH" == "3.3.5" ] || [ "$CIRCLE_BRANCH" == "master" ]; then
-                docker login -u $DOCKERHUB_USERNAME -p $DOCKERHUB_PASSWORD
-                echo "Pushing docker image to dockerhub"
-                docker push --all-tags $image_prefix
-              fi
-            fi
-      - store_artifacts:
-          path: docker.tar.gz
   nopch:
     docker:
       - image: trinitycore/circle-ci:3.3.5-base-22.04
diff --git a/README.md b/README.md
index 5ee2f79a0..6dc890f42 100644
--- a/README.md
+++ b/README.md
@@ -1,15 +1,13 @@
 # ![logo](https://community.trinitycore.org/public/style_images/1_trinitycore.png) TrinityCore (3.3.5)
 
-[![Average time to resolve an issue](https://isitmaintained.com/badge/resolution/TrinityCore/TrinityCore.svg)](https://isitmaintained.com/project/TrinityCore/TrinityCore "Average time to resolve an issue") [![Percentage of issues still open](https://isitmaintained.com/badge/open/TrinityCore/TrinityCore.svg)](https://isitmaintained.com/project/TrinityCore/TrinityCore "Percentage of issues still open")
-
 ## Build Status
 
-master | 3.3.5
-:------------: | :------------:
-[![master Build Status](https://circleci.com/gh/TrinityCore/TrinityCore/tree/master.svg?style=shield)](https://circleci.com/gh/TrinityCore/TrinityCore/tree/master) | [![3.3.5 Build Status](https://circleci.com/gh/TrinityCore/TrinityCore/tree/3.3.5.svg?style=shield)](https://circleci.com/gh/TrinityCore/TrinityCore/tree/3.3.5)
-[![master Build status](https://ci.appveyor.com/api/projects/status/54d0u1fxe50ad80o/branch/master?svg=true)](https://ci.appveyor.com/project/DDuarte/trinitycore/branch/master) | [![Build status](https://ci.appveyor.com/api/projects/status/54d0u1fxe50ad80o/branch/3.3.5?svg=true)](https://ci.appveyor.com/project/DDuarte/trinitycore/branch/3.3.5)
-[![master GCC Build status](https://github.com/TrinityCore/TrinityCore/actions/workflows/gcc-build.yml/badge.svg?branch=master&event=push)](https://github.com/TrinityCore/TrinityCore/actions?query=workflow%3AGCC+branch%3Amaster+event%3Apush) | [![3.3.5 GCC Build status](https://github.com/TrinityCore/TrinityCore/actions/workflows/gcc-build.yml/badge.svg?branch=3.3.5&event=push)](https://github.com/TrinityCore/TrinityCore/actions?query=workflow%3AGCC+branch%3A3.3.5+event%3Apush)
-[![Coverity Scan Build Status](https://scan.coverity.com/projects/435/badge.svg)](https://scan.coverity.com/projects/435) | [![Coverity Scan Build Status](https://scan.coverity.com/projects/4656/badge.svg)](https://scan.coverity.com/projects/4656)
+[![Fetch status](https://github.com/trickerer/NPCBots-cron/actions/workflows/automerge.yml/badge.svg)](https://github.com/trickerer/NPCBots-cron/actions/workflows/automerge.yml)
+
+3.3.5
+:------------:
+[![Build status](https://ci.appveyor.com/api/projects/status/jck8c86eiti50v26/branch/npcbots_3.3.5?svg=true)](https://ci.appveyor.com/project/trickerer/trinitycore-3-3-5-with-npcbots/branch/npcbots_3.3.5)
+[![Build status](https://circleci.com/gh/trickerer/TrinityCore-3.3.5-with-NPCBots/tree/npcbots_3.3.5.svg?style=shield)](https://circleci.com/gh/trickerer/TrinityCore-3.3.5-with-NPCBots/tree/npcbots_3.3.5)
 
 ## Introduction
 
@@ -20,13 +18,9 @@ based on the code of that project with extensive changes over time to optimize,
 improve and cleanup the codebase at the same time as improving the in-game
 mechanics and functionality.
 
-It is completely open source; community involvement is highly encouraged.
-
-If you wish to contribute ideas or code please visit our site linked below or
-make pull requests to our [Github repository](https://github.com/TrinityCore/TrinityCore/pulls).
+[NPCBots](https://github.com/trickerer/Trinity-Bots) is a TrinityCore mod.
 
-For further information on the TrinityCore project, please visit our project
-website at [TrinityCore.org](https://www.trinitycore.org).
+It is completely open source; community involvement is highly encouraged.
 
 ## Requirements
 
@@ -37,27 +31,22 @@ Windows, Linux and OS X.
 
 ## Install
 
-Detailed installation guides are available in the [wiki](https://www.trinitycore.info/display/tc/Installation+Guide) for
-Windows, Linux and OS X.
+Detailed TrinityCore installation guides are available in the [wiki](https://www.trinitycore.info/display/tc/Installation+Guide) for
+Windows, Linux and OS X.  
+NPCBots installation guide is available in the [NPCBots Readme](https://github.com/trickerer/Trinity-Bots#npcbot-mod-installation).
 
 
 ## Reporting issues
 
-Issues can be reported via the [Github issue tracker](https://github.com/TrinityCore/TrinityCore/labels/Branch-3.3.5a).
+Issues can be reported via the [Github issue tracker](https://github.com/trickerer/Trinity-Bots/issues/).
 
 Please take the time to review existing issues before submitting your own to
 prevent duplicates.
 
-In addition, thoroughly read through the [issue tracker guide](https://community.trinitycore.org/topic/37-the-trinitycore-issuetracker-and-you/) to ensure
-your report contains the required information. Incorrect or poorly formed
-reports are wasteful and are subject to deletion.
-
 
 ## Submitting fixes
 
-C++ fixes are submitted as pull requests via Github. For more information on how to
-properly submit a pull request, read the [how-to: maintain a remote fork](https://community.trinitycore.org/topic/9002-howto-maintain-a-remote-fork-for-pull-requests-tortoisegit/).
-For SQL only fixes open a ticket or if a bug report exists for the bug post on existing ticket.
+C++ fixes are submitted as [pull requests](https://github.com/trickerer/TrinityCore-3.3.5-with-NPCBots/pulls).
 
 
 ## Copyright
@@ -74,6 +63,7 @@ Read file [AUTHORS](AUTHORS).
 
 ## Links
 
-* [Website](https://www.trinitycore.org)
-* [Wiki](https://www.trinitycore.info)
-* [Forums](https://community.trinitycore.org)
+* [NPCBots Readme](https://github.com/trickerer/Trinity-Bots/)
+* [TrinityCore Website](https://www.trinitycore.org)
+* [TrinityCore Wiki](https://www.trinitycore.info)
+* [TrinityCore Forums](https://community.trinitycore.org)
diff --git a/sql/Bots/1_world_bot_appearance.sql b/sql/Bots/1_world_bot_appearance.sql
new file mode 100644
index 000000000..82a7bcafe
--- /dev/null
+++ b/sql/Bots/1_world_bot_appearance.sql
@@ -0,0 +1,305 @@
+-- Handmade data, very sensitive
+DROP TABLE IF EXISTS `creature_template_npcbot_appearance`;
+
+CREATE TABLE `creature_template_npcbot_appearance` (
+  `entry` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,
+  `name*` char(16) DEFAULT 'unk' COMMENT 'unused',
+  `gender` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `skin` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `face` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `hair` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `haircolor` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `features` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+insert into `creature_template_npcbot_appearance`(`entry`,`name*`,`gender`,`skin`,`face`,`hair`,`haircolor`,`features`)
+values
+(70001,'Llane',0,3,0,1,1,6),
+(70002,'Thran',0,0,0,4,5,4),
+(70003,'Lyria',1,3,4,6,4,0),
+(70004,'Ander',0,1,11,1,7,6),
+(70005,'Malosh',0,7,0,5,5,5),
+(70006,'Granis',0,0,2,9,4,4),
+(70007,'Kelstrum',0,5,4,2,2,2),
+(70008,'Dannal',0,1,0,8,5,0),
+(70009,'Austil',0,4,1,8,1,7),
+(70010,'Torm',0,7,1,2,0,2),
+(70011,'Sark',0,0,3,7,0,5),
+(70012,'Ker',1,4,0,0,0,1),
+(70013,'Harutt',0,1,3,7,0,4),
+(70014,'Krang',0,5,2,6,2,0),
+(70015,'Frang',0,0,4,1,1,3),
+(70016,'Tarshaw',0,3,3,1,0,7),
+(70017,'Grezz',0,3,5,1,0,3),
+(70018,'Sorek',0,2,1,3,1,6),
+(70019,'Zel\'mak',0,1,0,4,8,1),
+(70020,'Alyissia',1,5,1,5,2,0),
+(70021,'Kyra',1,6,8,4,6,1),
+(70022,'Arias\'ta',1,0,6,3,4,1),
+(70023,'Sildanair',1,3,0,2,4,2),
+(70024,'Chris',0,3,2,2,2,10),
+(70025,'Angela',1,2,7,3,8,6),
+(70026,'Baltus',0,0,0,1,8,1),
+(70027,'Kelv',0,5,1,7,3,1),
+(70028,'Bilban',0,2,2,2,7,1),
+(70029,'Wu',0,4,5,1,0,8),
+(70030,'Ilsa',1,5,6,7,3,4),
+(70031,'Darnath',0,7,8,3,0,0),
+(70032,'Evencane',0,5,9,2,4,2),
+(70033,'Kore',0,4,0,2,1,6),
+(70034,'Ahonan',0,6,1,1,6,5),
+(70035,'Behomat',0,4,8,3,6,3),
+(70036,'Ruada',1,1,2,1,6,0),
+(70037,'Kazi',1,1,2,3,3,0),
+(70038,'Kerra',1,2,0,2,2,0),
+(70051,'Sammuel',0,9,11,6,2,7),
+(70052,'Bromos',0,6,4,2,9,1),
+(70053,'Wilhelm',0,4,2,2,1,6),
+(70054,'Grayson',0,3,2,2,0,2),
+(70055,'Azar',0,2,4,3,1,6),
+(70056,'Valgar',0,4,3,0,0,0),
+(70057,'Beldruk',0,4,6,2,4,2),
+(70058,'Brandur',0,5,4,1,1,3),
+(70059,'Arthur',0,1,0,1,5,2),
+(70060,'Katherine',1,1,3,2,4,0),
+(70061,'Karman',0,3,11,10,5,8),
+(70062,'Jesthenis',0,4,0,0,0,0),
+(70063,'Noellene',1,0,1,1,1,0),
+(70064,'Aurelon',0,8,0,0,0,0),
+(70065,'Osselan',0,8,1,1,2,0),
+(70066,'Ithelis',0,9,2,2,2,0),
+(70067,'Bachi',0,3,0,10,1,0),
+(70068,'Baatun',0,6,4,3,0,7),
+(70069,'Kavaan',0,2,5,5,6,4),
+(70070,'Tullas',1,0,9,9,2,0),
+(70071,'Jol',1,0,8,8,6,0),
+(70072,'Cyssa',1,4,1,7,6,0),
+(70073,'Pyreanor',0,3,3,2,7,1),
+(70074,'Rukua',1,5,8,4,4,1),
+(70101,'Thorgas',0,4,5,8,4,8),
+(70102,'Ogromm',0,4,4,3,1,4),
+(70103,'Grif',0,0,1,5,4,4),
+(70104,'Kragg',0,7,4,3,2,2),
+(70105,'Kary',1,2,1,1,2,1),
+(70106,'Holt',0,18,3,4,0,3),
+(70107,'Urek',0,4,2,2,1,1),
+(70108,'Lanka',0,4,2,2,1,2),
+(70109,'Yaw',0,1,1,5,2,2),
+(70110,'Jen\'shan',1,3,0,2,6,3),
+(70111,'Thotar',0,0,3,3,1,9),
+(70112,'Ormak',0,5,8,1,0,5),
+(70113,'Xor\'juul',0,2,3,2,0,1),
+(70114,'Sian\'dur',1,2,4,1,2,4),
+(70115,'Ayanna',1,5,0,6,5,8),
+(70116,'Dazalar',0,8,0,6,2,3),
+(70117,'Danlaar',0,0,0,3,6,0),
+(70118,'Jeen\'ra',1,7,2,1,4,1),
+(70119,'Jocaste',1,6,1,1,6,1),
+(70120,'Dorion',0,4,6,5,0,5),
+(70121,'Daera',1,0,3,12,4,0),
+(70122,'Olmin',0,3,1,2,2,4),
+(70123,'Regnus',0,3,9,1,4,2),
+(70124,'Kaerbrus',0,2,0,0,2,2),
+(70125,'Einris',1,1,1,5,4,0),
+(70126,'Ulfir',0,6,2,5,8,1),
+(70127,'Thorfin',0,2,2,5,4,7),
+(70128,'Alenndaar',0,2,6,3,2,2),
+(70129,'Dargh',0,3,1,1,4,4),
+(70130,'Sallina',1,4,2,1,1,0),
+(70131,'Hannovia',1,0,2,2,1,0),
+(70132,'Keilnei',1,7,5,2,4,1),
+(70133,'Tana',1,8,1,1,2,0),
+(70134,'Oninath',0,0,0,0,0,0),
+(70135,'Zandine',1,8,0,1,4,0),
+(70136,'Deremiis',0,11,0,5,6,7),
+(70137,'Acteon',0,2,0,0,0,0),
+(70138,'Vord',0,11,0,5,6,7),
+(70139,'Killac',0,11,0,5,6,7),
+(70151,'Jorik',0,3,0,11,1,2),
+(70152,'Solm',0,7,8,4,9,6),
+(70153,'Keryn',1,4,4,7,0,0),
+(70154,'Osborne',0,4,9,9,0,1),
+(70155,'Hogral',0,6,7,10,5,7),
+(70156,'Ian',0,5,9,9,1,6),
+(70157,'David',0,4,2,1,1,1),
+(70158,'Marion',1,5,2,3,5,7),
+(70159,'Rwag',0,0,0,0,0,0),
+(70160,'Kaplak',0,3,5,0,0,3),
+(70161,'Gest',0,4,0,2,0,1),
+(70162,'Ormok',0,3,8,4,0,3),
+(70163,'Shenthul',0,3,0,5,5,1),
+(70164,'Frahun',0,2,1,3,5,4),
+(70165,'Jannok',0,3,2,4,5,3),
+(70166,'Syurna',1,0,3,5,4,0),
+(70167,'Erion',0,5,0,3,4,3),
+(70168,'Anishar',0,5,6,4,6,5),
+(70169,'Carolyn',1,0,6,3,1,7),
+(70170,'Miles',0,0,0,1,9,8),
+(70171,'Gregory',0,3,7,8,4,14),
+(70172,'Hulfdan',0,8,8,8,5,6),
+(70173,'Ormyr',0,0,6,4,4,4),
+(70174,'Fenthwick',0,0,2,2,5,0),
+(70175,'Fahrad',0,3,0,9,4,2),
+(70176,'Tony',0,3,0,1,0,2),
+(70177,'Kariel',0,1,0,0,0,0),
+(70178,'Tannaria',1,2,2,0,2,0),
+(70179,'Zelanis',0,0,1,1,1,0),
+(70180,'Elara',1,2,2,1,4,0),
+(70181,'Nerisen',0,1,1,2,1,0),
+(70201,'Anetta',1,0,9,14,5,0),
+(70202,'Laurena',1,0,1,4,5,0),
+(70203,'Josetta',1,1,3,17,2,0),
+(70204,'Branstock',0,2,7,1,8,0),
+(70205,'Maxan',0,2,0,6,1,5),
+(70206,'Duesten',0,0,9,5,1,0),
+(70207,'Beryl',0,0,0,0,0,12),
+(70208,'Miles',0,0,2,7,9,2),
+(70209,'Malakai',0,4,3,2,6,8),
+(70210,'Cobb',0,5,6,6,4,14),
+(70211,'Shanda',1,1,0,2,7,4),
+(70212,'Laurna',1,0,7,0,2,4),
+(70213,'Tai\'jin',1,0,3,1,6,5),
+(70214,'Ken\'jai',0,5,2,4,3,0),
+(70215,'Astarii',1,0,0,0,0,0),
+(70216,'Jandria',1,1,1,5,3,0),
+(70217,'Lariia',1,0,3,3,6,0),
+(70218,'Lankester',0,2,0,9,4,16),
+(70219,'Lazarus',0,0,0,6,6,14),
+(70220,'Theodrus',0,2,6,5,7,4),
+(70221,'Braenna',1,0,1,1,0,0),
+(70222,'Toldren',0,4,1,3,3,10),
+(70223,'Benjamin',0,9,11,0,0,8),
+(70224,'Joshua',0,3,0,1,1,8),
+(70225,'Zayus',0,2,0,3,1,4),
+(70226,'X\'yera',0,2,1,2,4,4),
+(70227,'Ur\'kyo',0,0,2,2,3,2),
+(70228,'Nara',1,0,7,4,1,3),
+(70229,'Alathea',1,4,3,0,4,5),
+(70230,'Rohan',0,0,9,4,7,5),
+(70231,'Arena',1,0,2,2,1,0),
+(70232,'Ponaris',0,1,0,1,2,0),
+(70233,'Zalduun',0,9,0,0,0,0),
+(70234,'Aldrae',0,3,1,1,1,0),
+(70235,'Lotheolan',0,8,8,1,2,0),
+(70236,'Belestra',1,4,0,1,3,0),
+(70237,'Caedmos',0,4,0,0,4,3),
+(70238,'Guvan',0,12,0,5,6,4),
+(70239,'Izmir',0,7,0,4,6,6),
+(70240,'Fallat',0,7,1,4,6,6),
+(70251,'Haromm',0,0,3,5,0,6),
+(70252,'Siln',1,10,1,3,2,1),
+(70253,'Tigor',0,13,2,2,2,1),
+(70254,'Beram',0,10,0,2,0,5),
+(70255,'Meela',1,8,1,3,0,0),
+(70256,'Narm',0,17,0,6,1,4),
+(70257,'Shikrik',1,3,4,5,1,1),
+(70258,'Swart',0,0,4,5,0,7),
+(70259,'Kardris',1,0,4,7,0,6),
+(70260,'Sian\'tsu',1,3,3,3,1,3),
+(70261,'Sagorne',0,6,1,1,1,2),
+-- (70262,'Firmanvaar',0,0,0,1,0,0),
+-- (70263,'Nobundo',0,0,0,0,0,0),
+-- (70264,'Tuluun',0,0,0,0,0,0),
+(70265,'Sulaa',1,7,2,2,4,6),
+(70266,'Hobahken',0,0,0,0,0,0),
+(70267,'Umbrua',1,1,7,5,5,1),
+(70268,'Javad',0,4,1,6,0,1),
+(70301,'Khelden',0,7,5,7,0,5),
+(70302,'Zaldimar',0,2,10,11,9,3),
+(70303,'Maginor',0,1,9,8,7,4),
+(70304,'Marryk',0,0,4,6,7,1),
+(70305,'Magis',0,1,5,4,6,4),
+(70306,'Isabella',1,2,0,7,1,5),
+(70307,'Cain',0,0,0,7,1,10),
+(70308,'Shymm',0,5,6,6,5,12),
+(70309,'Ursyn',1,0,5,9,1,7),
+(70310,'Thurston',0,4,1,5,5,1),
+(70311,'Pierce',0,0,2,5,8,2),
+(70312,'Anastasia',1,2,7,3,8,5),
+(70313,'Bink',1,2,1,1,6,0),
+(70314,'Juli',1,1,5,5,3,0),
+(70315,'Nittlebur',0,0,4,0,7,6),
+(70316,'Jennea',1,5,4,5,4,4),
+(70317,'Un\'Thuwa',0,1,2,1,3,4),
+(70318,'Pephredo',1,0,4,1,2,5),
+(70319,'Enyo',1,3,4,4,0,0),
+(70320,'Mai\'ah',1,1,2,1,1,5),
+(70321,'Deino',1,2,0,3,3,2),
+(70322,'Uthel\'nay',0,3,4,2,3,0),
+(70323,'Dink',0,1,3,2,6,1),
+(70324,'Julia',1,2,6,2,0,0),
+(70325,'Garridel',1,3,1,2,2,0),
+(70326,'Valaatu',1,9,6,7,6,5),
+(70327,'Zaedana',1,3,2,2,1,0),
+(70328,'Quithas',0,2,3,1,1,0),
+(70329,'Inethven',0,0,0,0,3,0),
+(70330,'Narinth',1,0,2,2,0,0),
+(70331,'Edirah',1,5,0,5,3,0),
+(70332,'Valustraa',1,5,5,9,6,5),
+(70333,'Semid',0,8,9,8,0,7),
+(70334,'Harnan',0,8,8,7,1,3),
+(70335,'Bati',1,8,1,2,1,0),
+(70336,'Derek',0,5,3,3,1,5),
+(70351,'Drusilla',1,0,10,4,0,0),
+(70352,'Alamar',0,2,2,3,2,5),
+(70353,'Demisette',1,0,9,2,0,0),
+(70354,'Maximillian',0,1,10,6,0,6),
+(70355,'Kartosh',0,0,7,0,1,6),
+(70356,'Maximillion',0,5,0,9,5,5),
+(70357,'Rupert',0,0,0,0,0,8),
+(70358,'Nartok',0,0,6,4,0,1),
+(70359,'Dhugru',0,5,6,4,3,9),
+(70360,'Grol\'dar',0,3,2,3,1,2),
+(70361,'Mirket',1,5,3,7,0,5),
+(70362,'Zevrost',0,3,7,5,5,9),
+(70363,'Kaal',0,3,1,4,2,3),
+(70364,'Luther',0,4,9,0,0,0),
+(70365,'Richard',0,5,5,0,0,0),
+(70366,'Thistleheart',0,3,2,6,3,0),
+(70367,'Briarthorn',0,0,6,1,0,3),
+(70368,'Alexander',0,0,10,11,0,6),
+(70369,'Ursula',1,1,4,18,3,6),
+(70370,'Sandahl',0,4,2,11,1,6),
+(70371,'Gimrizz',0,2,5,2,0,3),
+(70372,'Teli\'Larien',0,0,0,0,0,0),
+(70373,'Celoenus',0,0,0,2,0,0),
+(70374,'Alamma',0,0,1,0,0,0),
+(70375,'Talionia',1,0,2,1,2,0),
+(70376,'Zanien',0,0,0,0,3,0),
+(70377,'Babagaya',1,0,6,0,3,0),
+(70401,'Turak',0,4,3,5,0,5),
+(70402,'Sheal',1,7,0,3,1,1),
+(70403,'Kym',1,9,2,3,0,0),
+(70404,'Gart',0,13,1,3,2,2),
+(70405,'Gennia',1,9,3,0,1,3),
+(70406,'Mardant',0,1,1,2,0,4),
+(70407,'Kal',0,2,2,4,4,2),
+(70408,'Mathrengyl',0,5,0,2,6,3),
+(70409,'Denatharion',0,4,8,3,2,5),
+(70410,'Fylerian',0,2,1,4,5,0),
+(70411,'Sheldras',0,0,3,2,2,4),
+(70412,'Theridran',0,2,1,3,7,3),
+(70413,'Maldryn',0,2,8,5,4,0),
+(70414,'Jannos',0,5,3,2,1,5),
+(70415,'Golhine',0,0,2,6,0,4),
+(70416,'Loganaar',0,2,1,1,0,1),
+(70417,'Harene',1,6,0,3,2,4),
+(70418,'Shalannius',0,4,3,0,4,5),
+(70451,'Siouxsie',1,9,9,3,4,9),
+(70452,'Imhadria',1,10,8,6,1,0),
+(70453,'Vaelen',0,16,9,11,9,8),
+(70454,'Mynx',1,10,0,17,11,0),
+(70455,'Lankral',0,6,13,16,12,4),
+(70456,'Sliver',0,10,11,11,6,0),
+(70457,'Vereth',0,4,0,8,9,10),
+(70458,'Arly',1,7,9,2,8,4),
+(70459,'Setaal',1,14,12,15,9,2),
+(70460,'Uzo',0,8,7,8,9,18),
+(70461,'Illyrie',1,9,11,1,12,0),
+(70462,'Crok',0,11,9,10,7,3),
+(70463,'Zor\'be',0,8,7,6,9,18),
+(70464,'Datura',1,10,11,11,18,0),
+(70465,'Stefan',0,10,12,6,12,2),
+-- (70551,'Gorkramato',0,0,14,9,7,5);
+(70555,'Detrae',0,3,12,11,19,4);
diff --git a/sql/Bots/2_world_bot_extras.sql b/sql/Bots/2_world_bot_extras.sql
new file mode 100644
index 000000000..2a17a85a5
--- /dev/null
+++ b/sql/Bots/2_world_bot_extras.sql
@@ -0,0 +1,358 @@
+DROP TABLE IF EXISTS `creature_template_npcbot_extras`;
+
+CREATE TABLE `creature_template_npcbot_extras` (
+  `entry` mediumint(8) unsigned NOT NULL,
+  `class` tinyint(3) unsigned NOT NULL DEFAULT '1',
+  `race` tinyint(3) unsigned NOT NULL DEFAULT '1',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+INSERT INTO `creature_template_npcbot_extras` (`entry`,`class`,`race`) VALUES
+('70001', '1', '1'),
+('70002', '1', '3'),
+('70003', '1', '1'),
+('70004', '1', '3'),
+('70005', '1', '2'),
+('70006', '1', '3'),
+('70007', '1', '3'),
+('70008', '1', '5'),
+('70009', '1', '5'),
+('70010', '1', '6'),
+('70011', '1', '6'),
+('70012', '1', '6'),
+('70013', '1', '6'),
+('70014', '1', '6'),
+('70015', '1', '2'),
+('70016', '1', '2'),
+('70017', '1', '2'),
+('70018', '1', '2'),
+('70019', '1', '8'),
+('70020', '1', '4'),
+('70021', '1', '4'),
+('70022', '1', '4'),
+('70023', '1', '4'),
+('70024', '1', '5'),
+('70025', '1', '5'),
+('70026', '1', '5'),
+('70027', '1', '3'),
+('70028', '1', '7'),
+('70029', '1', '1'),
+('70030', '1', '1'),
+('70031', '1', '4'),
+('70032', '1', '1'),
+('70033', '1', '11'),
+('70034', '1', '11'),
+('70035', '1', '11'),
+('70036', '1', '11'),
+('70037', '1', '11'),
+('70038', '1', '4'),
+('70051', '2', '1'),
+('70052', '2', '3'),
+('70053', '2', '1'),
+('70054', '2', '1'),
+('70055', '2', '3'),
+('70056', '2', '3'),
+('70057', '2', '3'),
+('70058', '2', '3'),
+('70059', '2', '1'),
+('70060', '2', '1'),
+('70061', '2', '1'),
+('70062', '2', '10'),
+('70063', '2', '10'),
+('70064', '2', '11'),
+('70065', '2', '10'),
+('70066', '2', '10'),
+('70067', '2', '10'),
+('70068', '2', '11'),
+('70069', '2', '11'),
+('70070', '2', '11'),
+('70071', '2', '11'),
+('70072', '2', '10'),
+('70073', '2', '10'),
+('70074', '2', '11'),
+('70101', '3', '3'),
+('70102', '3', '2'),
+('70103', '3', '3'),
+('70104', '3', '2'),
+('70105', '3', '6'),
+('70106', '3', '6'),
+('70107', '3', '6'),
+('70108', '3', '6'),
+('70109', '3', '6'),
+('70110', '3', '8'),
+('70111', '3', '2'),
+('70112', '3', '2'),
+('70113', '3', '8'),
+('70114', '3', '8'),
+('70115', '3', '4'),
+('70116', '3', '4'),
+('70117', '3', '4'),
+('70118', '3', '4'),
+('70119', '3', '4'),
+('70120', '3', '4'),
+('70121', '3', '3'),
+('70122', '3', '3'),
+('70123', '3', '3'),
+('70124', '3', '4'),
+('70125', '3', '3'),
+('70126', '3', '3'),
+('70127', '3', '3'),
+('70128', '3', '4'),
+('70129', '3', '3'),
+('70130', '3', '10'),
+('70131', '3', '10'),
+('70132', '3', '11'),
+('70133', '3', '10'),
+('70134', '3', '10'),
+('70135', '3', '11'),
+('70136', '3', '11'),
+('70137', '3', '11'),
+('70138', '3', '11'),
+('70139', '3', '11'),
+('70151', '4', '1'),
+('70152', '4', '3'),
+('70153', '4', '1'),
+('70154', '4', '1'),
+('70155', '4', '3'),
+('70156', '4', '1'),
+('70157', '4', '5'),
+('70158', '4', '5'),
+('70159', '4', '2'),
+('70160', '4', '2'),
+('70161', '4', '2'),
+('70162', '4', '2'),
+('70163', '4', '8'),
+('70164', '4', '4'),
+('70165', '4', '4'),
+('70166', '4', '4'),
+('70167', '4', '4'),
+('70168', '4', '4'),
+('70169', '4', '5'),
+('70170', '4', '5'),
+('70171', '4', '5'),
+('70172', '4', '3'),
+('70173', '4', '3'),
+('70174', '4', '7'),
+('70175', '4', '1'),
+('70176', '4', '1'),
+('70177', '4', '10'),
+('70178', '4', '10'),
+('70179', '4', '10'),
+('70180', '4', '10'),
+('70181', '4', '10'),
+('70201', '5', '1'),
+('70202', '5', '1'),
+('70203', '5', '1'),
+('70204', '5', '3'),
+('70205', '5', '3'),
+('70206', '5', '5'),
+('70207', '5', '5'),
+('70208', '5', '5'),
+('70209', '5', '5'),
+('70210', '5', '5'),
+('70211', '5', '4'),
+('70212', '5', '4'),
+('70213', '5', '8'),
+('70214', '5', '8'),
+('70215', '5', '4'),
+('70216', '5', '4'),
+('70217', '5', '4'),
+('70218', '5', '5'),
+('70219', '5', '5'),
+('70220', '5', '3'),
+('70221', '5', '3'),
+('70222', '5', '3'),
+('70223', '5', '1'),
+('70224', '5', '1'),
+('70225', '5', '8'),
+('70226', '5', '8'),
+('70227', '5', '8'),
+('70228', '5', '4'),
+('70229', '5', '4'),
+('70230', '5', '3'),
+('70231', '5', '10'),
+('70232', '5', '10'),
+('70233', '5', '11'),
+('70234', '5', '10'),
+('70235', '5', '10'),
+('70236', '5', '10'),
+('70237', '5', '11'),
+('70238', '5', '11'),
+('70239', '5', '11'),
+('70240', '5', '11'),
+('70251', '7', '2'),
+('70252', '7', '6'),
+('70253', '7', '6'),
+('70254', '7', '6'),
+('70255', '7', '6'),
+('70256', '7', '6'),
+('70257', '7', '2'),
+('70258', '7', '2'),
+('70259', '7', '2'),
+('70260', '7', '8'),
+('70261', '7', '6'),
+('70265', '7', '11'),
+('70267', '7', '11'),
+('70268', '7', '11'),
+('70301', '8', '1'),
+('70302', '8', '1'),
+('70303', '8', '1'),
+('70304', '8', '7'),
+('70305', '8', '7'),
+('70306', '8', '5'),
+('70307', '8', '5'),
+('70308', '8', '5'),
+('70309', '8', '5'),
+('70310', '8', '5'),
+('70311', '8', '5'),
+('70312', '8', '5'),
+('70313', '8', '7'),
+('70314', '8', '7'),
+('70315', '8', '7'),
+('70316', '8', '1'),
+('70317', '8', '8'),
+('70318', '8', '8'),
+('70319', '8', '8'),
+('70320', '8', '8'),
+('70321', '8', '8'),
+('70322', '8', '8'),
+('70323', '8', '7'),
+('70324', '8', '10'),
+('70325', '8', '10'),
+('70326', '8', '11'),
+('70327', '8', '10'),
+('70328', '8', '10'),
+('70329', '8', '10'),
+('70330', '8', '10'),
+('70331', '8', '11'),
+('70332', '8', '11'),
+('70333', '8', '11'),
+('70334', '8', '11'),
+('70335', '8', '11'),
+('70336', '8', '5'),
+('70351', '9', '1'),
+('70352', '9', '7'),
+('70353', '9', '1'),
+('70354', '9', '1'),
+('70355', '9', '2'),
+('70356', '9', '5'),
+('70357', '9', '5'),
+('70358', '9', '2'),
+('70359', '9', '2'),
+('70360', '9', '2'),
+('70361', '9', '2'),
+('70362', '9', '2'),
+('70363', '9', '2'),
+('70364', '9', '5'),
+('70365', '9', '5'),
+('70366', '9', '7'),
+('70367', '9', '7'),
+('70368', '9', '1'),
+('70369', '9', '1'),
+('70370', '9', '1'),
+('70371', '9', '7'),
+('70372', '9', '10'),
+('70373', '9', '10'),
+('70374', '9', '10'),
+('70375', '9', '10'),
+('70376', '9', '10'),
+('70377', '9', '7'),
+('70401', '11', '6'),
+('70402', '11', '6'),
+('70403', '11', '6'),
+('70404', '11', '6'),
+('70405', '11', '6'),
+('70406', '11', '4'),
+('70407', '11', '4'),
+('70408', '11', '4'),
+('70409', '11', '4'),
+('70410', '11', '4'),
+('70411', '11', '4'),
+('70412', '11', '4'),
+('70413', '11', '6'),
+('70414', '11', '6'),
+('70415', '11', '4'),
+('70416', '11', '4'),
+('70417', '11', '6'),
+('70418', '11', '4'),
+('70451', '6', '4'),
+('70452', '6', '10'),
+('70453', '6', '11'),
+('70454', '6', '10'),
+('70455', '6', '1'),
+('70456', '6', '10'),
+('70457', '6', '5'),
+('70458', '6', '7'),
+('70459', '6', '11'),
+('70460', '6', '8'),
+('70461', '6', '4'),
+('70462', '6', '2'),
+('70463', '6', '8'),
+('70464', '6', '10'),
+('70465', '6', '1'),
+('70501', '0', '0'),
+('70502', '0', '0'),
+('70503', '0', '0'),
+('70504', '0', '0'),
+('70505', '0', '0'),
+('70506', '0', '0'),
+('70507', '0', '0'),
+('70508', '0', '0'),
+('70509', '0', '0'),
+('70510', '0', '0'),
+('70511', '0', '0'),
+('70512', '0', '0'),
+('70513', '0', '0'),
+('70514', '0', '0'),
+('70515', '0', '0'),
+('70516', '0', '0'),
+('70517', '0', '0'),
+('70518', '0', '0'),
+('70519', '0', '0'),
+('70520', '0', '0'),
+('70521', '0', '0'),
+('70522', '0', '0'),
+('70523', '0', '0'),
+('70524', '0', '0'),
+('70525', '0', '0'),
+('70526', '0', '0'),
+('70527', '0', '0'),
+('70528', '0', '0'),
+('70529', '0', '0'),
+('70530', '0', '0'),
+('70531', '0', '0'),
+('70532', '0', '0'),
+('70533', '0', '0'),
+('70534', '0', '0'),
+('70535', '0', '0'),
+('70536', '0', '0'),
+('70537', '0', '0'),
+('70538', '0', '0'),
+('70542', '0', '0'),
+('70543', '0', '0'),
+('70544', '0', '0'),
+('70545', '0', '0'),
+('70551', '12', '15'),
+('70552', '12', '15'),
+('70553', '13', '15'),
+('70554', '13', '15'),
+('70555', '14', '1'),
+('70556', '0', '0'),
+('70557', '15', '15'),
+('70558', '15', '15'),
+('70559', '15', '15'),
+('70560', '15', '15'),
+('70561', '15', '15'),
+('70562', '0', '0'),
+('70563', '16', '15'),
+('70564', '16', '15'),
+('70565', '16', '15'),
+('70566', '16', '15'),
+('70567', '16', '15'),
+('70568', '17', '10'),
+('70569', '17', '10'),
+('70570', '17', '10'),
+('70571', '17', '10'),
+('70572', '17', '10'),
+('70573', '0', '15'),
+('70574', '0', '15');
diff --git a/sql/Bots/3_world_bots.sql b/sql/Bots/3_world_bots.sql
new file mode 100644
index 000000000..725010f7a
--- /dev/null
+++ b/sql/Bots/3_world_bots.sql
@@ -0,0 +1,547 @@
+-- GENERAL --
+
+SET @BOT_START = 70001;
+SET @BOT_END   = 71000;
+
+-- move to creature_template_movement InhabitType
+-- Resistance
+-- basevariance, rangevariance -- spell_school_immune_mask -- damage modifier, expirience modifier
+
+-- TOTAL BOT ENTRIES: 352 (348)
+
+delete from `creature_template` where entry between @BOT_START and @BOT_END;
+
+insert into `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,
+`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,
+`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`type`,`type_flags`,`lootid`,
+`pickpocketloot`,`skinloot`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,
+`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`RacialLeader`,`movementId`,`RegenHealth`,
+`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`)
+values
+('70001','0','0','0','0','0','3343','0','0','0','Llane','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70002','0','0','0','0','0','3399','0','0','0','Thran','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70003','0','0','0','0','0','1300','0','0','0','Lyria','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70004','0','0','0','0','0','3431','0','0','0','Ander','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70005','0','0','0','0','0','4556','0','0','0','Malosh','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70006','0','0','0','0','0','3431','0','0','0','Granis','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70007','0','0','0','0','0','3053','0','0','0','Kelstrum','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70008','0','0','0','0','0','1578','0','0','0','Dannal','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70009','0','0','0','0','0','1599','0','0','0','Austil','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70010','0','0','0','0','0','2103','0','0','0','Torm','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70011','0','0','0','0','0','2096','0','0','0','Sark','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70012','0','0','0','0','0','2113','0','0','0','Ker','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70013','0','0','0','0','0','3793','0','0','0','Harutt','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70014','0','0','0','0','0','3794','0','0','0','Krang','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70015','0','0','0','0','0','1880','0','0','0','Frang','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70016','0','0','0','0','0','3743','0','0','0','Tarshaw','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70017','0','0','0','0','0','1374','0','0','0','Grezz','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70018','0','0','0','0','0','1375','0','0','0','Sorek','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70019','0','0','0','0','0','4242','0','0','0','Zel\'mak','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70020','0','0','0','0','0','1721','0','0','0','Alyissia','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70021','0','0','0','0','0','1707','0','0','0','Kyra','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70022','0','0','0','0','0','2196','0','0','0','Arias\'ta','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70023','0','0','0','0','0','2198','0','0','0','Sildanair','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70024','0','0','0','0','0','2620','0','0','0','Chris','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70025','0','0','0','0','0','2658','0','0','0','Angela','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70026','0','0','0','0','0','2614','0','0','0','Baltus','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70027','0','0','0','0','0','3054','0','0','0','Kelv','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70028','0','0','0','0','0','3055','0','0','0','Bilban','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70029','0','0','0','0','0','3280','0','0','0','Wu','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70030','0','0','0','0','0','3287','0','0','0','Ilsa','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70031','0','0','0','0','0','6071','0','0','0','Darnath','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70032','0','0','0','0','0','11037','0','0','0','Evencane','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70033','0','0','0','0','0','16226','0','0','0','Kore','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70034','0','0','0','0','0','17212','0','0','0','Ahonan','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70035','0','0','0','0','0','17213','0','0','0','Behomat','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70036','0','0','0','0','0','17215','0','0','0','Ruada','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70037','0','0','0','0','0','17214','0','0','0','Kazi','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+('70038','0','0','0','0','0','17211','0','0','0','Kerra','Warrior Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3400','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warrior_bot','-1'),
+-- 70039 - 70050 reserved for warriors
+('70051','0','0','0','0','0','3346','0','0','0','Sammuel','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70052','0','0','0','0','0','3393','0','0','0','Bromos','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70053','0','0','0','0','0','1299','0','0','0','Wilhelm','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70054','0','0','0','0','0','1499','0','0','0','Grayson','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70055','0','0','0','0','0','1622','0','0','0','Azar','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70056','0','0','0','0','0','3089','0','0','0','Valgar','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70057','0','0','0','0','0','3088','0','0','0','Beldruk','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70058','0','0','0','0','0','3087','0','0','0','Brandur','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70059','0','0','0','0','0','3284','0','0','0','Arthur','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70060','0','0','0','0','0','3289','0','0','0','Katherine','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70061','0','0','0','0','0','7356','0','0','0','Karman','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70062','0','0','0','0','0','15521','0','0','0','Jesthenis','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70063','0','0','0','0','0','16685','0','0','0','Noellene','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70064','0','0','0','0','0','16224','0','0','0','Aurelon','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70065','0','0','0','0','0','16815','0','0','0','Osselan','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70066','0','0','0','0','0','16811','0','0','0','Ithelis','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70067','0','0','0','0','0','16829','0','0','0','Bachi','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70068','0','0','0','0','0','17225','0','0','0','Baatun','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70069','0','0','0','0','0','17227','0','0','0','Kavaan','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70070','0','0','0','0','0','17234','0','0','0','Tullas','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70071','0','0','0','0','0','17226','0','0','0','Jol','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70072','0','0','0','0','0','19596','0','0','0','Cyssa','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70073','0','0','0','0','0','21264','0','0','0','Pyreanor','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+('70074','0','0','0','0','0','29735','0','0','0','Rukua','Paladin Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2300','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','paladin_bot','-1'),
+-- 70075 - 70100 reserved for paldins
+('70101','0','0','0','0','0','3395','0','0','0','Thorgas','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70102','0','0','0','0','0','4560','0','0','0','Ogromm','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70103','0','0','0','0','0','3558','0','0','0','Grif','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70104','0','0','0','0','0','4372','0','0','0','Kragg','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70105','0','0','0','0','0','2112','0','0','0','Kary','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70106','0','0','0','0','0','2087','0','0','0','Holt','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70107','0','0','0','0','0','2105','0','0','0','Urek','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70108','0','0','0','0','0','3810','0','0','0','Lanka','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70109','0','0','0','0','0','3811','0','0','0','Yaw','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70110','0','0','0','0','0','1882','0','0','0','Jen\'shan','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70111','0','0','0','0','0','3744','0','0','0','Thotar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70112','0','0','0','0','0','1373','0','0','0','Ormak','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70113','0','0','0','0','0','4239','0','0','0','Xor\'juul','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70114','0','0','0','0','0','4241','0','0','0','Sian\'dur','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70115','0','0','0','0','0','1723','0','0','0','Ayanna','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70116','0','0','0','0','0','1703','0','0','0','Dazalar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70117','0','0','0','0','0','2066','0','0','0','Danlaar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70118','0','0','0','0','0','2205','0','0','0','Jeen\'ra','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70119','0','0','0','0','0','2206','0','0','0','Jocaste','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70120','0','0','0','0','0','2251','0','0','0','Dorion','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70121','0','0','0','0','0','3056','0','0','0','Daera','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70122','0','0','0','0','0','3072','0','0','0','Olmin','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70123','0','0','0','0','0','3073','0','0','0','Regnus','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70124','0','0','0','0','0','3299','0','0','0','Kaerbrus','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70125','0','0','0','0','0','3312','0','0','0','Einris','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70126','0','0','0','0','0','3309','0','0','0','Ulfir','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70127','0','0','0','0','0','3310','0','0','0','Thorfin','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70128','0','0','0','0','0','7538','0','0','0','Alenndaar','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70129','0','0','0','0','0','10245','0','0','0','Dargh','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70130','0','0','0','0','0','15520','0','0','0','Sallina','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70131','0','0','0','0','0','16681','0','0','0','Hannovia','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70132','0','0','0','0','0','16222','0','0','0','Keilnei','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70133','0','0','0','0','0','16778','0','0','0','Tana','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70134','0','0','0','0','0','16816','0','0','0','Oninath','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70135','0','0','0','0','0','16802','0','0','0','Zandine','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70136','0','0','0','0','0','17434','0','0','0','Deremiis','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70137','0','0','0','0','0','16860','0','0','0','Acteon','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70138','0','0','0','0','0','17511','0','0','0','Vord','Hunter Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+('70139','0','0','0','0','0','17488','0','0','0','Killac','Hunter bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2800','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','hunter_bot','-1'),
+-- 70140 - 70150 reserved for hunters
+('70151','0','0','0','0','0','3351','0','0','0','Jorik','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70152','0','0','0','0','0','3407','0','0','0','Solm','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70153','0','0','0','0','0','1297','0','0','0','Keryn','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70154','0','0','0','0','0','1507','0','0','0','Osborne','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70155','0','0','0','0','0','3436','0','0','0','Hogral','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70156','0','0','0','0','0','5146','0','0','0','Ian','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70157','0','0','0','0','0','1580','0','0','0','David','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70158','0','0','0','0','0','2130','0','0','0','Marion','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70159','0','0','0','0','0','1886','0','0','0','Rwag','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70160','0','0','0','0','0','3749','0','0','0','Kaplak','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70161','0','0','0','0','0','1327','0','0','0','Gest','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70162','0','0','0','0','0','1328','0','0','0','Ormok','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70163','0','0','0','0','0','4360','0','0','0','Shenthul','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70164','0','0','0','0','0','1725','0','0','0','Frahun','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70165','0','0','0','0','0','1704','0','0','0','Jannok','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70166','0','0','0','0','0','2231','0','0','0','Syurna','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70167','0','0','0','0','0','2252','0','0','0','Erion','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70168','0','0','0','0','0','2243','0','0','0','Anishar','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70169','0','0','0','0','0','2659','0','0','0','Carolyn','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70170','0','0','0','0','0','2639','0','0','0','Miles','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70171','0','0','0','0','0','2631','0','0','0','Gregory','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70172','0','0','0','0','0','3101','0','0','0','Hulfdan','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70173','0','0','0','0','0','3100','0','0','0','Ormyr','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70174','0','0','0','0','0','3113','0','0','0','Fenthwick','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70175','0','0','0','0','0','5528','0','0','0','Fahrad','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70176','0','0','0','0','0','13171','0','0','0','Tony','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70177','0','0','0','0','0','15519','0','0','0','Kariel','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70178','0','0','0','0','0','16689','0','0','0','Tannaria','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70179','0','0','0','0','0','16767','0','0','0','Zelanis','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70180','0','0','0','0','0','16798','0','0','0','Elara','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+('70181','0','0','0','0','0','16818','0','0','0','Nerisen','Rogue Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','1600','2000','4','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','rogue_bot','-1'),
+-- 70182 - 70200 reserved for rogues
+('70201','0','0','0','0','0','3344','0','0','0','Anetta','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70202','0','0','0','0','0','1495','0','0','0','Laurena','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70203','0','0','0','0','0','1295','0','0','0','Josetta','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70204','0','0','0','0','0','3401','0','0','0','Branstock','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70205','0','0','0','0','0','3429','0','0','0','Maxan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70206','0','0','0','0','0','1579','0','0','0','Duesten','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70207','0','0','0','0','0','1602','0','0','0','Beryl','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70208','0','0','0','0','0','2139','0','0','0','Miles','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70209','0','0','0','0','0','2138','0','0','0','Malakai','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70210','0','0','0','0','0','2137','0','0','0','Cobb','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70211','0','0','0','0','0','1733','0','0','0','Shanda','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70212','0','0','0','0','0','1708','0','0','0','Laurna','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70213','0','0','0','0','0','1897','0','0','0','Tai\'jin','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70214','0','0','0','0','0','4068','0','0','0','Ken\'jai','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70215','0','0','0','0','0','2200','0','0','0','Astarii','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70216','0','0','0','0','0','2201','0','0','0','Jandria','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70217','0','0','0','0','0','2202','0','0','0','Lariia','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70218','0','0','0','0','0','2626','0','0','0','Lankester','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70219','0','0','0','0','0','2618','0','0','0','Lazarus','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70220','0','0','0','0','0','3086','0','0','0','Theodrus','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70221','0','0','0','0','0','3066','0','0','0','Braenna','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70222','0','0','0','0','0','3085','0','0','0','Toldren','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70223','0','0','0','0','0','3282','0','0','0','Benjamin','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70224','0','0','0','0','0','3283','0','0','0','Joshua','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70225','0','0','0','0','0','4690','0','0','0','Zayus','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70226','0','0','0','0','0','10473','0','0','0','X\'yera','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70227','0','0','0','0','0','4711','0','0','0','Ur\'kyo','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70228','0','0','0','0','0','11044','0','0','0','Nara','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70229','0','0','0','0','0','11048','0','0','0','Alathea','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70230','0','0','0','0','0','11053','0','0','0','Rohan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70231','0','0','0','0','0','15518','0','0','0','Arena','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70232','0','0','0','0','0','16707','0','0','0','Ponaris','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70233','0','0','0','0','0','16225','0','0','0','Zalduun','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70234','0','0','0','0','0','16788','0','0','0','Aldrae','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70235','0','0','0','0','0','16817','0','0','0','Lotheolan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70236','0','0','0','0','0','16795','0','0','0','Belestra','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70237','0','0','0','0','0','17247','0','0','0','Caedmos','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70238','0','0','0','0','0','17232','0','0','0','Guvan','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70239','0','0','0','0','0','17249','0','0','0','Izmir','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+('70240','0','0','0','0','0','17248','0','0','0','Fallat','Priest Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3600','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','priest_bot','-1'),
+-- 70241 - 70250 reserved for priests
+('70251','0','0','0','0','0','4552','0','0','0','Haromm','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70252','0','0','0','0','0','2123','0','0','0','Siln','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70253','0','0','0','0','0','2102','0','0','0','Tigor','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70254','0','0','0','0','0','2082','0','0','0','Beram','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70255','0','0','0','0','0','10180','0','0','0','Meela','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70256','0','0','0','0','0','3816','0','0','0','Narm','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70257','0','0','0','0','0','1878','0','0','0','Shikrik','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70258','0','0','0','0','0','3746','0','0','0','Swart','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70259','0','0','0','0','0','1360','0','0','0','Kardris','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70260','0','0','0','0','0','4231','0','0','0','Sian\'tsu','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70261','0','0','0','0','0','13341','0','0','0','Sagorne','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70262','0','0','0','0','0','17598','0','0','0','Firmanvaar','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70263','0','0','0','0','0','17600','0','0','0','Nobundo','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70264','0','0','0','0','0','17599','0','0','0','Tuluun','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70265','0','0','0','0','0','16914','0','0','0','Sulaa','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- ('70266','0','0','0','0','0','17792','0','0','0','Hobahken','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70267','0','0','0','0','0','19598','0','0','0','Umbrua','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+('70268','0','0','0','0','0','21265','0','0','0','Javad','Shaman Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2600','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','shaman_bot','-1'),
+-- 70269 - 70300 reserved for shamans
+('70301','0','0','0','0','0','5001','0','0','0','Khelden','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70302','0','0','0','0','0','1294','0','0','0','Zaldimar','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70303','0','0','0','0','0','1484','0','0','0','Maginor','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70304','0','0','0','0','0','10216','0','0','0','Marryk','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70305','0','0','0','0','0','10215','0','0','0','Magis','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70306','0','0','0','0','0','1592','0','0','0','Isabella','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70307','0','0','0','0','0','1600','0','0','0','Cain','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70308','0','0','0','0','0','2134','0','0','0','Shymm','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70309','0','0','0','0','0','6058','0','0','0','Ursyn','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70310','0','0','0','0','0','2135','0','0','0','Thurston','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70311','0','0','0','0','0','2644','0','0','0','Pierce','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70312','0','0','0','0','0','2657','0','0','0','Anastasia','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70313','0','0','0','0','0','3108','0','0','0','Bink','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70314','0','0','0','0','0','10214','0','0','0','Juli','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70315','0','0','0','0','0','3109','0','0','0','Nittlebur','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70316','0','0','0','0','0','3292','0','0','0','Jennea','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70317','0','0','0','0','0','10171','0','0','0','Un\'Thuwa','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70318','0','0','0','0','0','4524','0','0','0','Pephredo','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70319','0','0','0','0','0','4522','0','0','0','Enyo','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70320','0','0','0','0','0','4526','0','0','0','Mai\'ah','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70321','0','0','0','0','0','4523','0','0','0','Deino','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70322','0','0','0','0','0','6060','0','0','0','Uthel\'nay','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70323','0','0','0','0','0','6072','0','0','0','Dink','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70324','0','0','0','0','0','15522','0','0','0','Julia','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70325','0','0','0','0','0','16680','0','0','0','Garridel','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70326','0','0','0','0','0','16223','0','0','0','Valaatu','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70327','0','0','0','0','0','16781','0','0','0','Zaedana','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70328','0','0','0','0','0','16824','0','0','0','Quithas','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70329','0','0','0','0','0','16809','0','0','0','Inethven','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70330','0','0','0','0','0','16777','0','0','0','Narinth','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70331','0','0','0','0','0','17242','0','0','0','Edirah','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70332','0','0','0','0','0','16856','0','0','0','Valustraa','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70333','0','0','0','0','0','17233','0','0','0','Semid','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70334','0','0','0','0','0','17243','0','0','0','Harnan','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70335','0','0','0','0','0','17241','0','0','0','Bati','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+('70336','0','0','0','0','0','11466','0','0','0','Derek','Mage Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3800','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','mage_bot','-1'),
+-- 70337 - 70350 reserved for mages
+('70351','0','0','0','0','0','3345','0','0','0','Drusilla','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70352','0','0','0','0','0','1930','0','0','0','Alamar','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70353','0','0','0','0','0','1469','0','0','0','Demisette','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70354','0','0','0','0','0','3271','0','0','0','Maximillian','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70355','0','0','0','0','0','4567','0','0','0','Kartosh','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70356','0','0','0','0','0','1581','0','0','0','Maximillion','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70357','0','0','0','0','0','1604','0','0','0','Rupert','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70358','0','0','0','0','0','1884','0','0','0','Nartok','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70359','0','0','0','0','0','3745','0','0','0','Dhugru','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70360','0','0','0','0','0','1324','0','0','0','Grol\'dar','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70361','0','0','0','0','0','1325','0','0','0','Mirket','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70362','0','0','0','0','0','1326','0','0','0','Zevrost','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70363','0','0','0','0','0','2675','0','0','0','Kaal','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70364','0','0','0','0','0','2637','0','0','0','Luther','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70365','0','0','0','0','0','2646','0','0','0','Richard','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70366','0','0','0','0','0','3115','0','0','0','Thistleheart','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70367','0','0','0','0','0','3116','0','0','0','Briarthorn','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70368','0','0','0','0','0','3122','0','0','0','Alexander','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70369','0','0','0','0','0','3291','0','0','0','Ursula','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70370','0','0','0','0','0','3286','0','0','0','Sandahl','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70371','0','0','0','0','0','3607','0','0','0','Gimrizz','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70372','0','0','0','0','0','15524','0','0','0','Teli\'Larien','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70373','0','0','0','0','0','16700','0','0','0','Celoenus','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70374','0','0','0','0','0','16787','0','0','0','Alamma','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70375','0','0','0','0','0','16800','0','0','0','Talionia','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70376','0','0','0','0','0','16831','0','0','0','Zanien','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+('70377','0','0','0','0','0','21604','0','0','0','Babagaya','Warlock Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3500','2000','8','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','warlock_bot','-1'),
+-- 70378 - 70400 reserved for warlocks
+('70401','0','0','0','0','0','2106','0','0','0','Turak','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70402','0','0','0','0','0','2121','0','0','0','Sheal','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70403','0','0','0','0','0','2115','0','0','0','Kym','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70404','0','0','0','0','0','3819','0','0','0','Gart','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70405','0','0','0','0','0','10734','0','0','0','Gennia','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70406','0','0','0','0','0','1732','0','0','0','Mardant','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70407','0','0','0','0','0','1706','0','0','0','Kal','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70408','0','0','0','0','0','2261','0','0','0','Mathrengyl','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70409','0','0','0','0','0','2250','0','0','0','Denatharion','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70410','0','0','0','0','0','2255','0','0','0','Fylerian','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70411','0','0','0','0','0','3300','0','0','0','Sheldras','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70412','0','0','0','0','0','3301','0','0','0','Theridran','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70413','0','0','0','0','0','3302','0','0','0','Maldryn','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70414','0','0','0','0','0','7357','0','0','0','Jannos','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70415','0','0','0','0','0','10738','0','0','0','Golhine','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70416','0','0','0','0','0','12053','0','0','0','Loganaar','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70417','0','0','0','0','0','16739','0','0','0','Harene','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+('70418','0','0','0','0','0','16858','0','0','0','Shalannius','Druid Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','2200','2000','2','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','druid_bot','-1'),
+-- 70419 - 70450 reserved for druids
+('70451','0','0','0','0','0','24935','0','0','0','Siouxsie','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70452','0','0','0','0','0','26939','0','0','0','Imhadria','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70453','0','0','0','0','0','26854','0','0','0','Vaelen','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70454','0','0','0','0','0','28039','0','0','0','Mynx','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70455','0','0','0','0','0','26688','0','0','0','Lankral','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70456','0','0','0','0','0','26195','0','0','0','Sliver','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70457','0','0','0','0','0','27402','0','0','0','Vereth','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70458','0','0','0','0','0','27189','0','0','0','Arly','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70459','0','0','0','0','0','26217','0','0','0','Setaal','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70460','0','0','0','0','0','26222','0','0','0','Uzo','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70461','0','0','0','0','0','28842','0','0','0','Illyrie','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70462','0','0','0','0','0','28837','0','0','0','Crok','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70463','0','0','0','0','0','28840','0','0','0','Zor\'be','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70464','0','0','0','0','0','25512','0','0','0','Datura','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+('70465','0','0','0','0','0','25500','0','0','0','Stefan','Death Knight Bot','','0','80','80','2','35','1','1.1','1.1','1','0','0','3300','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','death_knight_bot','-1'),
+-- 70466 - 70500 reserved for deathknights
+('70501','0','0','0','0','0','4449','0','0','0','Imp',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70502','0','0','0','0','0','1132','0','0','0','Voidwalker',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70503','0','0','0','0','0','4162','0','0','0','Succubus',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70504','0','0','0','0','0','850','0','0','0','Felhunter',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70505','0','0','0','0','0','14255','0','0','0','Felguard',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','1','135266416','warlock_pet_bot','-1'),
+('70506','0','0','0','0','0','368','0','0','0','Spider',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70507','0','0','0','0','0','4312','0','0','0','Serpent',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70508','0','0','0','0','0','16724','0','0','0','Bird of Prey',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70509','0','0','0','0','0','8808','0','0','0','Bat',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70510','0','0','0','0','0','17562','0','0','0','Wind Serpent',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70511','0','0','0','0','0','20308','0','0','0','Ravager',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70512','0','0','0','0','0','17545','0','0','0','Dragonhawk',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70513','0','0','0','0','0','19405','0','0','0','Nether Ray',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70514','0','0','0','0','0','17753','0','0','0','Sporebat',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70515','0','0','0','0','0','15590','0','0','0','Carrion Bird',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70516','0','0','0','0','0','11319','0','0','0','Raptor',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70517','0','0','0','0','0','741','0','0','0','Wolf',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70518','0','0','0','0','0','1220','0','0','0','Tallstrider',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70519','0','0','0','0','0','321','0','0','0','Cat',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70520','0','0','0','0','0','2714','0','0','0','Hyena',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70521','0','0','0','0','0','29113','0','0','0','Wasp',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70522','0','0','0','0','0','17798','0','0','0','Teromoth',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70523','0','0','0','0','0','20790','0','0','0','Scorpid',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70524','0','0','0','0','0','1244','0','0','0','Turtle',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70525','0','0','0','0','0','809','0','0','0','Gorilla',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70526','0','0','0','0','0','706','0','0','0','Bear',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70527','0','0','0','0','0','381','0','0','0','Boar',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70528','0','0','0','0','0','1938','0','0','0','Crab',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70529','0','0','0','0','0','1250','0','0','0','Crocolisk',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70530','0','0','0','0','0','19998','0','0','0','Warp Stalker',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70531','0','0','0','0','0','11087','0','0','0','Silithid',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70532','0','0','0','0','0','10810','0','0','0','Chimaera',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70533','0','0','0','0','0','29673','0','0','0','Spirit Beast',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70534','0','0','0','0','0','12168','0','0','0','Core Hound',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70535','0','0','0','0','0','5239','0','0','0','Devilsaur',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70536','0','0','0','0','0','26279','0','0','0','Rhino',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70537','0','0','0','0','0','13212','0','0','0','Worm',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','hunter_pet_bot','-1'),
+('70538','0','0','0','0','0','24994','24993','24992','24995','Risen Ghoul',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','deathknight_pet_bot','-1'),
+-- 70539 - 70541 reserved for dk pets
+('70542','0','0','0','0','0','19110','0','0','0','Shadowfiend',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','5','1500','1500','2','0','0','0','0','10','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','priest_pet_bot','-1'),
+('70543','0','0','0','0','0','21114','0','0','0','Spirit Wolf',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','1500','1500','1','0','0','0','0','1','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','shaman_pet_bot','-1'),
+('70544','0','0','0','0','0','525','0','0','0','Water Elemental',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','8','0','0','0','0','4','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','mage_pet_bot','-1'),
+('70545','0','0','0','0','0','18922','0','0','0','Treant',NULL,'','0','80','80','2','35','0','1.2','1.3','1','0','0','2000','2000','1','0','0','0','0','4','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','druid_pet_bot','-1'),
+-- 70546 - 70550 reserved for pets
+('70551','0','0','0','0','0','17659','0','0','0','Gorkramato','Blademaster Bot','','0','81','81','2','35','1','1.1','1.1','1','4','0','2200','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157560','blademaster_bot','-1'),
+('70552','0','0','0','0','0','17659','0','0','0','Mirror Image (Blademaster)','Blademaster bot','','0','81','81','2','35','1','1.1','1.1','1','4','0','2200','2000','1','0','16432','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157560','blademaster_bot','-1'),
+('70553','0','0','0','0','0','15343','0','0','0','Osis','Obsidian Destroyer Bot','','0','83','83','2','35','1','1.1','1.1','0.7','2','0','1200','1200','8','0','0','0','0','10','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','sphynx_bot','-1'),
+('70554','0','0','0','0','0','15343','0','0','0','Amot','Obsidian Destroyer Bot','','0','83','83','2','35','1','1.1','1.1','0.7','2','0','1200','1200','8','0','0','0','0','10','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','sphynx_bot','-1'),
+('70555','0','0','0','0','0','6769','0','0','0','Detrae','Archmage Bot','','0','81','81','2','35','1','1.1','1.1','1','4','0','1420','1420','8','0','16432','0','0','7','2048','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','archmage_bot','-1'),
+('70556','0','0','0','0','0','5561','0','0','0','Water Elemental',NULL,'','0','81','81','2','35','0','1.2','1.3','1','0','0','1500','1500','1','0','0','0','0','4','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','archmage_pet_bot','-1'),
+('70557','0','0','0','0','0','348','0','0','0','Neroth','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70558','0','0','0','0','0','348','0','0','0','Fearoth','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70559','0','0','0','0','0','348','0','0','0','Zalamon','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70560','0','0','0','0','0','348','0','0','0','Lotthicus','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70561','0','0','0','0','0','348','0','0','0','Ramarot','Dreadlord Bot','','0','83','83','2','35','1','1.1','1.1','1.5','2','0','1300','1300','2','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dreadlord_bot','-1'),
+('70562','0','0','0','0','0','169','0','0','0','Infernal',NULL,'','0','83','83','2','35','0','1.2','1.3','1.5','0','2','1350','1350','1','0','0','0','0','3','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266416','dreadlord_pet_bot','-1'),
+('70563','0','0','0','0','0','15511','0','0','0','Eanor','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70564','0','0','0','0','0','15511','0','0','0','Narsen','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70565','0','0','0','0','0','15511','0','0','0','Caelnor','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70566','0','0','0','0','0','15511','0','0','0','Daenste','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70567','0','0','0','0','0','15511','0','0','0','Neshdar','Spell Breaker Bot','','0','81','81','2','35','1','1.1','1.1','1.5','4','0','1900','1900','2','0','0','0','0','7','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','spellbreaker_bot','-1'),
+('70568','0','0','0','0','0','30072','0','0','0','Mara','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70569','0','0','0','0','0','30072','0','0','0','Tani','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70570','0','0','0','0','0','30072','0','0','0','Eva','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70571','0','0','0','0','0','30072','0','0','0','Darise','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70572','0','0','0','0','0','30072','0','0','0','Lyra','Dark Ranger Bot','','0','83','83','2','35','1','1.1','1.1','1','2','0','2000','2000','8','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_bot','-1'),
+('70573','0','0','0','0','0','30363','0','0','0','Dark Minion',NULL,'','0','83','83','2','35','0','1.1','1.1','1','0','0','2000','2000','1','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_pet_bot','-1'),
+('70574','0','0','0','0','0','30363','0','0','0','Dark Minion',NULL,'','0','83','83','2','35','0','1.1','1.1','1','1','0','2000','2000','1','0','0','0','0','6','0','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','0','dark_ranger_pet_bot','-1');
+-- 70575 - 71000 reserved for custom stuff
+
+-- GOSSIPS --
+delete from `npc_text` where ID between @BOT_START and @BOT_END;
+insert into `npc_text` (`ID`,`text0_0`,`VerifiedBuild`)
+values
+('70001','I live only to serve the master.','-1'),
+('70002','You need something?','-1'),
+('70003','Mortals... usually I kill wretches like you at sight.','-1'),
+('70004','<You see what is supposed to be an obsidian destroyer. This one looks different though, damaged and faded, and does not react to your presence. You recall the Scourge have been using their own versions of those at some point in the past. How the hell did it end up here? After further examination you notice an opening on creature\'s back.>','-1'),
+('70005','<Obsidian Destroyer stares at you and makes a low growling sound.>','-1'),
+('70006','Are you surprised, mortal? As a lesser nathrezim I have to resort to seeking out allies. You look like you could amuse me at least.','-1'),
+('70007','What is it now, mortal?','-1'),
+('70008','Can you just leave me be? <sigh>','-1'),
+('70009','Now what?','-1'),
+-- 70010 - 70100 reserved for standard/greet gossips
+('70101','|cffff3300Blademaster|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An elite swordsman, former member of Burning Blade clan, now an elite fighter within the Horde\".$B$BMain attribute: Agility.$B$BNetherwalk (Windwalk). Allows Blademaster to become invisible, and move faster for a set amount of time. When the Blademaster attacks a unit to break invisibility, he will deal bonus damage.$B$BMirror Image. Confuses the enemy by creating illusions of the Blademaster and dispelling all magic from the Blademaster.$B$BCritical Strike (passive). Gives a 15% chance to deal critical x2(x3,x4) times normal damage on his attacks.$B$BBladestorm (NIY). Grants immunity to magic and deals damage to all surrounding enemies.$B$B','-1'),
+('70102','|cff9900ccObsidian Destroyer|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An obsidian winged monstrocity with insatiable hunger for magic\".$B$BHigh armor, very high resistances, partially immune to magic, loses mana over time and doesn\'t benefit from passive mana regeneration effects, mail/plate armor, dual-wielding wands, deals spellshadow damage, no physical attack, cannot attack enemies not in front while moving, spell power bonus: 50% attack power + 200% intellect + wands damage.$B$BDevour Magic. Dispels up to 2 magic effects from enemies, up to 2 magic effects and up to 2 curses from allies and damaging summoned units in 20 yards area. Every dispelled effect restores 20% mana and 5% health, 7 seconds cooldown.$B$BShadow Blast. Empowered attack that deals increased splash damage.$B$BDrain Mana. Drains all mana (limited by caster\'s mana pool) from a random friendly unit.$B$BReplenish Mana. Energizes surrounding party and raid members within 25 yards for 2% of their maximum mana nullifying caster\'s mana, affects up to 10 targets, 3 seconds cooldown.$B$BRegenerating Aura. Heals surrounding party and raid members within 25 yards for 3% of their maximum health nullifying caster\'s mana, affects up to 10 targets, 3 seconds cooldown.$B$BShadow Armor (passive). Restores mana equal to a percentage of damage taken.$B$B','-1'),
+('70103','|cff0000ddArchmage|r$b|cffdd6600-=Warcraft III tribute=-|r$B$BSpell damage taken reduced by 35%, partially immune to control effects, cloth armor, deals spellsfire/spellfrost damage, no physical attack, spell power bonus: 100% intellect. Main attribute: Intellect.$B$BBlizzard. Your typical blizzard, just a little more powerful, 6 seconds cooldown.$B$BSummon Water Elemental. Summons a water elemental to attack archmage\'s enemies for 1 min, 20 seconds cooldown.$B$BBrilliance Aura. Increases maximum mana by 10% and greatly increases mana regeneration of party and raid members within 40 yards.$B$BMass Teleport. NIY.','-1'),
+('70104','|cff9900ccDreadlord|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"Incredibly powerful demon who wields power of darkness and mental domination\".$B$BHigh armor, high resistances, partially immune to control effects, damage taken speeds up spells recharge, plate armor, deals melee/spellshadow damage, bonus damage against incapacitated targets, spell power bonus: 200% strength. Main attribute: Strength.$B$BCarrion Swarm. Sends a horde of bats combined with chaotic magic to damage enemies in a very large frontal cone, cannot crit, 10 seconds cooldown.$B$BSleep. Puts the enemy target to sleep for 60 seconds and allows next physical attack on that target to bypass armor, direct damage caused will awaken the target, 6 seconds cooldown.$B$BVampiric Aura. Increases physical critical damage by 5% and heals party and raid members within 40 yards for a percentage (100% for Dreadlord and 25% for everyone else) of damage done by melee physical attacks and Carrion Swarm, no threat.$B$BSummon Infernal Servant. Calls an infernal down from the sky dealing damage and stunning enemy units, infernal is very resistant to magic and lasts 180 seconds, 180 seconds cooldown.','-1'),
+('70105','|cff0000ddSpell Breaker|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An elven warrior trained to disrupt and contort magical energies\".$B$BSpell damage taken reduced by 75%, partially immune to control effects, armor penalty -30%, mail/plate armor, deals melee/arcane damage, spell power bonus: 200% strength. Main attribute: Strength.$B$BSteal Magic (Spellsteal). Steals a benefical spell from an enemy and applies it to a nearby ally or removes a negative spell from an ally and applies it to a nearby enemy, affects magic and curse effects, 3 seconds cooldown.$B$BFeedback (passive). Successful melee attacks burn target\'s mana equal to damage caused (increased by spellpower) dealing arcane damage. If target is drained, Spell Breaker\'s melee attacks will do triple damage with increased critical strike chance','-1'),
+('70106','|cff9900ccDark Ranger|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"A former ranger of Quel\'thalas forcibly raised from the dead\".$B$BSpell damage taken reduced by 35%, undead, partially immune to control effects, leather/cloth armor, deals physical/spellshadow damage, stick to shadows and generates no threat, spell power bonus: 50% intellect. Main attribute: Agility.$B$BSilence. Silences an enemy and up to 4 nearby targets for 8 seconds, 15 seconds cooldown.$B$BBlack Arrow. Fires a cursed arrow dealing 150% weapon damage and additional spellshadow damage over time. If affected target dies from Dark Ranger\'s damage, Dark Minion will spawn from the corpse (maximum 5 Minions, 80 seconds duration, only works on humanoids, beasts and dragonkin). Deals five times more damage if target is under 20% health.$B$BDrain Life. Drains health from an enemy every second for 5 seconds, healing Dark Ranger for 200% of the drained amount.','-1');
+-- 70107 - 70200 reserved for custom class descriptions
+
+-- OUTFITS --
+-- Npc Dress mod by Rochet2
+CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+    `entry` INT(10) UNSIGNED NOT NULL,
+    `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+    `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+    `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    PRIMARY KEY  (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+-- End Npc Dress mod
+
+replace into `creature_template_outfits` (`entry`, `race`, `gender`, `skin`, `face`, `hair`, `haircolor`, `facialhair`, `head`, `shoulders`, `body`, `chest`, `waist`, `legs`, `feet`, `wrists`, `hands`, `back`, `tabard`)
+values
+('70551','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'), -- Blademaster
+('70552','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'); -- Mirror Image (Blademaster)
+
+-- Customize section
+
+SET @CLASS_WARRIOR          = 1;
+SET @CLASS_PALADIN          = 2;
+SET @CLASS_HUNTER           = 3;
+SET @CLASS_ROGUE            = 4;
+SET @CLASS_PRIEST           = 5;
+SET @CLASS_DK               = 6;
+SET @CLASS_SHAMAN           = 7;
+SET @CLASS_MAGE             = 8;
+SET @CLASS_WARLOCK          = 9;
+SET @CLASS_DRUID            = 11;
+SET @CLASS_BM               = 12;
+SET @CLASS_SPHYNX           = 13;
+SET @CLASS_ARCHMAGE         = 14;
+SET @CLASS_DREADLORD        = 15;
+SET @CLASS_SPELLBREAKER     = 16;
+SET @CLASS_DARK_RANGER      = 17;
+
+-- Add flags_extra
+
+SET @EX_NO_PARRY_HASTEN     = 8; -- 0x00000008 - CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN
+SET @EX_NO_BLOCK            = 16; -- 0x00000010 - CREATURE_FLAG_EXTRA_NO_BLOCK
+SET @EX_NO_CRUSH            = 32; -- 0x00000020 - CREATURE_FLAG_EXTRA_NO_CRUSH
+SET @EX_NO_XP               = 64; -- 0x00000040 - CREATURE_FLAG_EXTRA_NO_XP_AT_KILL
+SET @EX_DIMINISH            = 1048576; -- 0x00100000 - CREATURE_FLAG_EXTRA_ALL_DIMINISH
+SET @EX_NPCBOT              = 67108864; -- 0x04000000 - CREATURE_FLAG_EXTRA_NPCBOT - custom flag
+SET @EX_NPCBOT_PET          = 134217728; -- 0x08000000 - CREATURE_FLAG_EXTRA_NPCBOT_PET - custom flag
+SET @FLAGS_EX               = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT;
+SET @FLAGS_EXN              = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT | @EX_NO_PARRY_HASTEN;
+SET @FLAGS_EX_PET           = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT_PET;
+SET @FLAGS_EX_PET_BLOCK     = @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT_PET;
+
+-- Add unit_flags
+-- SET @U_PVP_ATTACKABLE       = 8; -- 0x00000008 - UNIT_FLAG_PVP_ATTACKABLE
+SET @FLAGS_U                = 0;
+SET @FLAGS_U_PET            = 0;
+
+-- Add unit_flags2
+SET @U2_MIRROR_IMAGE        = 16; -- 0x00000010 - UNIT_FLAG2_MIRROR_IMAGE - 22.06.19
+SET @U2_INSTANT_APPEAR_MODEL= 32; -- 0x00000020 - UNIT_FLAG2_INSTANTLY_APPEAR_MODEL - 29.05.19
+SET @U2_ENEMY_INTERRACT     = 16384; -- 0x00004000 - UNIT_FLAG2_ALLOW_ENEMY_INTERACT
+-- SET @U2_DISABLE_TURN        = 32768; -- 0x00008000 - UNIT_FLAG2_DISABLE_TURN
+SET @FLAGS_U2               = @U2_MIRROR_IMAGE | @U2_INSTANT_APPEAR_MODEL | @U2_ENEMY_INTERRACT;
+SET @FLAGS_U2_NM            = @U2_INSTANT_APPEAR_MODEL | @U2_ENEMY_INTERRACT;
+SET @FLAGS_U2_PET           = 0;
+
+-- Add type_flags
+SET @CT_CAN_ASSIST          = 4096; -- 0x00001000 - CREATURE_TYPE_FLAG_CAN_ASSIST - 26.10.19
+SET @FLAGS_CT               = @CT_CAN_ASSIST;
+
+-- general
+UPDATE `creature_template` SET type_flags:=`type_flags`|@FLAGS_CT WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3300, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DK);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2200, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DRUID);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2800, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_HUNTER);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3800, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_MAGE);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2300, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_PALADIN);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3600, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_PRIEST);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=1600, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_ROGUE);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=2600, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SHAMAN);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3500, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_WARLOCK);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, BaseAttackTime:=3400, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_WARRIOR);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, BaseAttackTime:=1940, RangeAttackTime:=1940, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EXN,unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_BM);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, BaseAttackTime:=1350, RangeAttackTime:=1350, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1,scale:=0.7,HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SPHYNX);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, BaseAttackTime:=1420, RangeAttackTime:=1420, dynamicflags:=0, speed_walk:=1.1, speed_run:=2.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2,    AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_ARCHMAGE);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, BaseAttackTime:=2600, RangeAttackTime:=2600, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1,scale:=1.2,HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DREADLORD);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, BaseAttackTime:=1900, RangeAttackTime:=1900, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1,scale:=1.1,HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SPELLBREAKER);
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=82, maxlevel:=82, BaseAttackTime:=2000, RangeAttackTime:=2000, dynamicflags:=0, speed_walk:=1.1, speed_run:=1.1, scale:=1, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=0, flags_extra:=@FLAGS_EX, unit_flags:=`unit_flags`|@FLAGS_U, unit_flags2:=`unit_flags2`|@FLAGS_U2_NM, AIName:=''
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DARK_RANGER);
+
+-- pets
+SET @PET_START              = 70501;
+SET @PET_END                = 70550;
+SET @PET_WATER_ELEMENTAL    = 70556;
+SET @PET_INFERNAL           = 70562;
+SET @PET_DARK_MINION        = 70573;
+SET @PET_DARK_MINION_ELITE  = 70574;
+
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=80, maxlevel:=80, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=1.0, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry` BETWEEN @PET_START and @PET_END;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=81, maxlevel:=81, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=1.3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_WATER_ELEMENTAL;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=1.5, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_INFERNAL;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=0.8, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET_BLOCK, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_DARK_MINION;
+UPDATE `creature_template` SET exp:=2, faction:=35, minlevel:=83, maxlevel:=83, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, scale:=0.9, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, flags_extra:=@FLAGS_EX_PET_BLOCK, unit_flags:=`unit_flags`|@FLAGS_U_PET, unit_flags2:=`unit_flags2`|@FLAGS_U2_PET, AIName:=''
+WHERE `entry`=@PET_DARK_MINION_ELITE;
diff --git a/sql/Bots/4_world_generate_bot_equips.sql b/sql/Bots/4_world_generate_bot_equips.sql
new file mode 100644
index 000000000..3658fab46
--- /dev/null
+++ b/sql/Bots/4_world_generate_bot_equips.sql
@@ -0,0 +1,159 @@
+/*!50003 DROP PROCEDURE IF EXISTS `sp__generate_npcbot_equips`*/;
+
+DELIMITER ;;
+
+/*!50003 CREATE*/
+/*!50003 PROCEDURE `sp__generate_npcbot_equips`()
+BEGIN
+
+DECLARE CLASS_WARRIOR INT DEFAULT 1;
+DECLARE CLASS_PALADIN INT DEFAULT 2;
+DECLARE CLASS_HUNTER INT DEFAULT 3;
+DECLARE CLASS_ROGUE INT DEFAULT 4;
+DECLARE CLASS_PRIEST INT DEFAULT 5;
+DECLARE CLASS_DEATH_KNIGHT INT DEFAULT 6;
+DECLARE CLASS_SHAMAN INT DEFAULT 7;
+DECLARE CLASS_MAGE INT DEFAULT 8;
+DECLARE CLASS_WARLOCK INT DEFAULT 9;
+DECLARE CLASS_DRUID INT DEFAULT 11;
+DECLARE CLASS_BLADEMASTER INT DEFAULT 12;
+DECLARE CLASS_SPHYNX INT DEFAULT 13;
+DECLARE CLASS_ARCHMAGE INT DEFAULT 14;
+DECLARE CLASS_DREADLORD INT DEFAULT 15;
+DECLARE CLASS_SPELL_BREAKER INT DEFAULT 16;
+DECLARE CLASS_DARK_RANGER INT DEFAULT 17;
+
+DECLARE RACE_HUMAN INT DEFAULT 1;
+DECLARE RACE_ORC INT DEFAULT 2;
+DECLARE RACE_DWARF INT DEFAULT 3;
+DECLARE RACE_NELF INT DEFAULT 4;
+DECLARE RACE_UNDEAD INT DEFAULT 5;
+DECLARE RACE_TAUREN INT DEFAULT 6;
+DECLARE RACE_GNOME INT DEFAULT 7;
+DECLARE RACE_TROLL INT DEFAULT 8;
+DECLARE RACE_BELF INT DEFAULT 10;
+DECLARE RACE_DRAENEI INT DEFAULT 11;
+
+DECLARE NPCBOT_ENTRY_BEGIN INT DEFAULT 70001;
+DECLARE NPCBOT_ENTRY_END INT DEFAULT 71000;
+
+DECLARE NPCBOT_ENTRY_PET_DARK_MINION INT DEFAULT 70573;
+DECLARE NPCBOT_ENTRY_PET_DARK_MINION_ELITE INT DEFAULT 70574;
+
+DECLARE cur_pos INT DEFAULT 0;
+DECLARE myclass INT;
+DECLARE myrace INT;
+DECLARE item1 INT DEFAULT 0;
+DECLARE item2 INT DEFAULT 0;
+DECLARE item3 INT DEFAULT 0;
+
+DELETE FROM `creature_equip_template` WHERE `CreatureID` BETWEEN NPCBOT_ENTRY_BEGIN AND NPCBOT_ENTRY_END;
+
+SET cur_pos = NPCBOT_ENTRY_BEGIN;
+WHILE cur_pos < NPCBOT_ENTRY_END DO
+    SET myclass = (SELECT `class` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+    SET myrace = (SELECT `race` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+
+    IF myclass != 0 AND myrace != 0 THEN
+
+        IF myclass = CLASS_WARRIOR THEN
+            IF myrace = RACE_TAUREN THEN
+                SET item1 = 2361; -- hammer
+            ELSEIF myrace IN(RACE_DWARF,RACE_ORC) THEN
+                SET item1 = 2483; -- axe
+            ELSEIF TRUE THEN
+                SET item1 = 2497; -- sword
+            END IF;
+        ELSEIF myclass = CLASS_PALADIN THEN
+            SET item1 = 2488; -- gladius
+            SET item3 = 0;
+            IF myrace = RACE_BELF THEN
+                SET item2 = 20841; -- sunstrider shield
+            ELSE
+                SET item2 = 7188;  -- stormwind guard shield
+            END IF;
+        ELSEIF myclass = CLASS_HUNTER THEN
+            SET item1 = 12282;
+            SET item2 = 0;
+            SET item3 = 2506;
+        ELSEIF myclass = CLASS_ROGUE THEN
+            SET item3 = 25873;
+            IF (cur_pos % 2) = 1 THEN
+                SET item1 = 2092;
+                SET item2 = 3296; -- daggers
+            ELSE
+                SET item1 = 2131;
+                SET item2 = 2484; -- swords
+            END IF;
+        ELSEIF myclass = CLASS_PRIEST THEN
+            SET item1 = 1388; -- short staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DEATH_KNIGHT THEN
+            SET item1 = 38633; -- dk axe
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_SHAMAN THEN
+            SET item1 = 15903; -- claw
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_MAGE THEN
+            SET item1 = 2132; -- staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_WARLOCK THEN
+            SET item1 = 3661; -- staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DRUID THEN
+            SET item1 = 3327; -- staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_BLADEMASTER THEN
+            SET item1 = 24044; -- blademaster polearm
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_SPHYNX THEN
+            SET item1 = 5208; -- smoldering wand
+            SET item2 = 5208;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_ARCHMAGE THEN
+            SET item1 = 25917; -- white staff
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DREADLORD THEN
+            SET item1 = 0;
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_SPELL_BREAKER THEN
+            SET item1 = 0;
+            SET item2 = 0;
+            SET item3 = 0;
+        ELSEIF myclass = CLASS_DARK_RANGER THEN
+            SET item1 = 20849; -- arcane forged shortsword (1.7 dps)
+            SET item2 = 0;
+            SET item3 = 34529; -- vengeful gladiator's longbow
+        END IF;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    ELSEIF cur_pos = NPCBOT_ENTRY_PET_DARK_MINION OR cur_pos = NPCBOT_ENTRY_PET_DARK_MINION_ELITE THEN
+        SET item1 = 3935;
+        SET item2 = 15648;
+        SET item3 = 0;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    END IF;
+
+    SET cur_pos = cur_pos + 1;
+
+END WHILE;
+
+END */;;
+
+DELIMITER ;
+
+CALL `sp__generate_npcbot_equips`();
+
+DROP PROCEDURE IF EXISTS `sp__generate_npcbot_equips`;
diff --git a/sql/Bots/5_world_botgiver.sql b/sql/Bots/5_world_botgiver.sql
new file mode 100644
index 000000000..71bf34434
--- /dev/null
+++ b/sql/Bots/5_world_botgiver.sql
@@ -0,0 +1,18 @@
+DELETE FROM `creature_template` WHERE `entry` = 70000;
+INSERT INTO `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,
+`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,
+`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`type`,`type_flags`,`lootid`,
+`pickpocketloot`,`skinloot`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,
+`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,
+`mechanic_immune_mask`,`spell_school_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`)
+VALUES
+('70000','0','0','0','0','0','27541','0','0','0','Lagretta','Bots for hire','','0','83','83','2','35','1','1.4','1.14286','0.7','4','0','0','0','1','1','1','33088','2048','0','0','0','0','0','0','0','0','0','0','0','','0','1','4.8','1','1','1','1','0','0','1','0','0','0','script_bot_giver','-1');
+
+DELETE FROM `npc_text` WHERE `ID` BETWEEN 70201 AND 70204;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70201','There are always dudes ready to kill for money.','-1'),
+('70202','Mercenaries are always in demand. Here is what available right now.','-1'),
+('70203','Mercenaries are always in demand. Here is what available right now.','-1'),
+('70204','Seems like there is nobody available right now, check again later.','-1');
diff --git a/sql/Bots/characters_bots.sql b/sql/Bots/characters_bots.sql
new file mode 100644
index 000000000..f590d45d6
--- /dev/null
+++ b/sql/Bots/characters_bots.sql
@@ -0,0 +1,26 @@
+DROP TABLE IF EXISTS `characters_npcbot`;
+CREATE TABLE `characters_npcbot` (
+  `entry` int(10) unsigned NOT NULL COMMENT 'creature_template.entry',
+  `owner` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'characters.guid (lowguid)',
+  `roles` smallint(5) unsigned NOT NULL COMMENT 'bitmask: tank(1),dps(2),heal(4),ranged(8)',
+  `faction` int(10) unsigned NOT NULL DEFAULT '35',
+  `equipMhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipOhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipRhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHead` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipShoulders` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipChest` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWaist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipLegs` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFeet` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWrist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHands` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBack` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBody` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipNeck` int(10) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/locales/ruRU/npc_text_locale.sql b/sql/Bots/locales/ruRU/npc_text_locale.sql
new file mode 100644
index 000000000..b5bad3c03
--- /dev/null
+++ b/sql/Bots/locales/ruRU/npc_text_locale.sql
@@ -0,0 +1,380 @@
+DELETE FROM `npc_text_locale` WHERE `Locale`='ruRU' AND `ID` BETWEEN '70000' AND '71000';
+INSERT INTO `npc_text_locale` (`ID`, `Locale`, `Text0_0`, `Text0_1`, `Text1_0`, `Text1_1`, `Text2_0`, `Text2_1`, `Text3_0`, `Text3_1`, `Text4_0`, `Text4_1`, `Text5_0`, `Text5_1`, `Text6_0`, `Text6_1`, `Text7_0`, `Text7_1`)
+VALUES
+('70001', 'ruRU', '    ,   !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70002', 'ruRU', ' - ?', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70003', 'ruRU', '...         !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70004', 'ruRU', '< , ,  . , ,  ,   ,      .    -   . ,  ,   ?         .>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70005', 'ruRU', '<         .>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70006', 'ruRU', ' , ?   ,      .   ,      .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70007', 'ruRU', '  , ?', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70008', 'ruRU', '      ? <>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70009', 'ruRU', ' ?', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70010', 'ruRU', '<    .     ,      .>$B$B - --, --...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70011', 'ruRU', '   -   - -? <   "">$B... , -  .     ?', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70101', 'ruRU', '|cffff3300 |r$b|cffdd6600-=  Warcraft III=-|r$B$B" ,     ,    ".$B$B : .$B$B  (  ).            .     ,   ,    .$B$B .    ,          .$B$B  ().  15%      2(3,4)     .$B$B  (NIY).          .$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70102', 'ruRU', '|cff9900cc |r$b|cffdd6600-=  Warcraft III=-|r$B$B"   ,    ".$B$B ,   ,    ,   ,       , / ,     ,    ,   ,      ,    : 50%   + 200%  +  .$B$B .   2    ,  2     2           20 .     20%   5% ,   7 .$B$B .  ,     .$B$B .    (   )    .$B$B  .          25   3%    ,     ,   3 .$B$B .         25   3%     ,     ,   3 .$B$B  ().        .$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70103', 'ruRU', '|cff0000dd|r$b|cffdd6600-=  Warcraft III=-|r$B$B       35%,     ,  ,     /,   ,    : 100% .  : .$B$B .   ,   ,   6 .$B$B  .   ,    .  : 1 ., 20 .$B$B .      10%            40 .$B$BM  . NIY.$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70104', 'ruRU', '|cff9900cc |r$b|cffdd6600-=  Warcraft III=-|r$B$B"  ,      ".$B$B ,  ,     ,     ,  ,           ,       ,    : 200% .  : .$B$B .            ,     ,   10 .$B$B.       60              ,     ,   6 .$B$B .      5%         40     (100%     25%   )  ,         ,  .$B$B .      180 ,     ,     ,   180 .$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70105', 'ruRU', '|cff0000dd |r$b|cffdd6600-=  Warcraft III=-|r$B$B" ,      ".$B$B,   ,   75%,     ,    -30%, / ,          ,    : 200% .  : .$B$B .                   ,      ,   2 .$B$B  ().       ,    (  ),     .    ,              .     ,       25%   .$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70106', 'ruRU', '|cff9900cc |r$b|cffdd6600-=  Warcraft III=-|r$B$B"  \',     ".$B$B       35%, ,     , / ,   /   ,      ,    : 50% .  : .$B$B.     4      8 ,    ,   15 .$B$B .   ,  150%            .       ,      ( 5 ,  80 ,    ,   ).   ,     20% .$B$B .        5 ,     200%   .$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70107', 'ruRU', '|cff9900cc|r$b|cffdd6600-=  Warcraft III / Diablo II=-|r$B$B      20%,     ,  ,     ,   ,    :  100%.  : .$B$B .  2    ( 6 ,  65 ,    ,   ).$B$B .         75%,    .  45 .    .   30 .$B$B .   ,      35%  75%      (   )   .     .   40 .$B$B.    ,          50%  60 .    50.$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70108', 'ruRU', '|cff0000dd |r$b|cffdd6600-=  Warcraft III=-|r$B$B"  ,      ".$B$B      30%,     ,  ,   /   ,    :  x2,    : 200%  .  : .$B$B .   ,   .   2    (     ),    2 .     .$B$B .       ,    ,       30-70% (     ).$B$B .  ,   100%  ( ) ,    .    1    10    10    1   (     ).$B$B.   ,       ,      .       ,      ,        .    60.$B$B ( ).  ,        .$B$B', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70201', 'ruRU', '  ,    .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70202', 'ruRU', '  .     .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70203', 'ruRU', '  .     .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70204', 'ruRU', '   ,  .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70300', 'ruRU', '!', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70301', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70302', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70303', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70304', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70305', 'ruRU', '       ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70306', 'ruRU', '       ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70307', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70308', 'ruRU', '--...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70309', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70310', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70311', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70312', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70313', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70314', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70315', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70316', 'ruRU', '      !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70317', 'ruRU', 'WTF    !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70318', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70319', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70320', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70321', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70322', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70323', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70324', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70325', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70326', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70327', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70328', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70329', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70330', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70331', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70332', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70333', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70334', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70335', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70336', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70337', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70338', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70339', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70340', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70341', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70342', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70343', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70344', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70345', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70346', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70347', 'ruRU', ', ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70348', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70349', 'ruRU', '        ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70353', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70354', 'ruRU', '.     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70355', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70356', 'ruRU', '  !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70357', 'ruRU', '  !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70358', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70359', 'ruRU', ' !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70360', 'ruRU', '-', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70361', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70362', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70363', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70364', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70365', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70366', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70367', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70368', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70369', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70370', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70371', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70372', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70373', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70374', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70375', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70376', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70377', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70378', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70379', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70380', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70381', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70382', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70383', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70384', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70385', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70386', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70387', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70388', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70389', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70390', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70391', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70392', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70393', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70394', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70395', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70396', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70397', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70398', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70399', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70400', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70402', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70403', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70404', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70405', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70406', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70407', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70408', 'ruRU', '  _5', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70409', 'ruRU', ' _5   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70410', 'ruRU', ' _5   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70411', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70412', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70413', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70414', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70415', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70416', 'ruRU', '.', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70417', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70418', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70419', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70420', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70421', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70422', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70423', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70424', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70425', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70426', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70427', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70428', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70429', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70430', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70431', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70432', 'ruRU', '   ()', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70433', 'ruRU', '   ()', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70434', 'ruRU', 'PvP-', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70435', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70436', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70437', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70438', 'ruRU', '%s () ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70439', 'ruRU', '<>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70440', 'ruRU', ' ,   ,   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70441', 'ruRU', '?', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70442', 'ruRU', '< >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70443', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70444', 'ruRU', '<  >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70445', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70446', 'ruRU', '< >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70447', 'ruRU', '...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70448', 'ruRU', '...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70449', 'ruRU', '...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70450', 'ruRU', '...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70451', 'ruRU', '...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70452', 'ruRU', ' ...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70453', 'ruRU', '< >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70454', 'ruRU', '<  ( )>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70455', 'ruRU', '<  >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70456', 'ruRU', '<    >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70457', 'ruRU', '<  >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70458', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70459', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70460', 'ruRU', '     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70461', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70462', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70463', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70464', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70465', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70466', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70467', 'ruRU', ' ,    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70468', 'ruRU', '<  ( )>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70469', 'ruRU', '<  ( )>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70470', 'ruRU', ' ,    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70471', 'ruRU', '<  ( )>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70472', 'ruRU', '<  ( )>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70473', 'ruRU', ' ,     ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70474', 'ruRU', '<  >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70475', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70476', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70477', 'ruRU', '    ...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70478', 'ruRU', ', ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70479', 'ruRU', '< >', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70480', 'ruRU', ',  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70481', 'ruRU', '.', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70482', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70483', 'ruRU', '<>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70484', 'ruRU', '<>', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70485', 'ruRU', ' ()', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70486', 'ruRU', ' ()', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70487', 'ruRU', ' ()', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70488', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70489', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70490', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70491', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70492', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70493', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70494', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70495', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70496', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70497', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70498', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70499', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70500', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70501', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70502', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70503', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70504', 'ruRU', '1', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70505', 'ruRU', '2', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70506', 'ruRU', '1', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70507', 'ruRU', '2', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70508', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70509', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70510', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70511', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70512', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70513', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70514', 'ruRU', '   c', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70515', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70516', 'ruRU', '...    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70517', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70518', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70519', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70520', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70521', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70522', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70523', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70524', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70525', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70526', 'ruRU', '       ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70527', 'ruRU', '%s    ,    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70528', 'ruRU', '%s    ,     60- ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70529', 'ruRU', '%s    ,     55- ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70530', 'ruRU', '%s    ,     40- ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70531', 'ruRU', '%s    ,     20- ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70532', 'ruRU', '     (%u)', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70533', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70534', 'ruRU', '        ! %u  %u', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70535', 'ruRU', '      %u (%s)!    !', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70536', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70537', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70538', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70539', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70540', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70541', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),		
+('70542', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70543', 'ruRU', '   %s  -  !   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70544', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70545', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70546', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70547', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70548', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70549', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70550', 'ruRU', '    - ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70551', 'ruRU', ' NpcBot    . ,   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70552', 'ruRU', '%s    ,   : %s', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70553', 'ruRU', '%s     : ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70554', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70555', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70556', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70557', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70558', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70559', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70560', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70561', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70562', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70563', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70564', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70565', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70566', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70567', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70568', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70569', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70570', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70571', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70572', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70573', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70574', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70575', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70576', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70577', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70578', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70579', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70580', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70581', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70582', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70583', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70584', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70585', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70586', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70587', 'ruRU', '   ,   .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70588', 'ruRU', '    ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70589', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70590', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70591', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70592', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70593', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70594', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70595', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70596', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70597', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70598', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70599', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70600', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70601', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70602', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70603', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70604', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70605', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70606', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70607', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70608', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70609', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70610', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70611', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70612', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70613', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70614', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70615', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70616', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70617', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70618', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70619', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70620', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70621', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70622', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70623', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70624', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70625', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70626', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70627', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70628', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70629', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70630', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70631', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70632', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70633', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70634', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70635', 'ruRU', '|cff9d9d9d|r', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70636', 'ruRU', '|cffffffff|r', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70637', 'ruRU', '|cff1eff00|r', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70638', 'ruRU', '|cff0070dd|r', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70639', 'ruRU', '|cffa335ee|r', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70640', 'ruRU', '|cffff8000|r', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70641', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70642', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70643', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70644', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70645', 'ruRU', 'Off- ( )', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70646', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70647', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70648', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70649', 'ruRU', '', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70650', 'ruRU', '  ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70652', 'ruRU', ' ,   ?        ...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70653', 'ruRU', ',       .', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70654', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70655', 'ruRU', ' ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70656', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70657', 'ruRU', '   ', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL),
+('70658', 'ruRU', '...', '', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
diff --git a/sql/Bots/locales/zhCN/npc_text_locale.sql b/sql/Bots/locales/zhCN/npc_text_locale.sql
new file mode 100644
index 000000000..147367d5c
--- /dev/null
+++ b/sql/Bots/locales/zhCN/npc_text_locale.sql
@@ -0,0 +1,380 @@
+DELETE FROM `npc_text_locale` WHERE `Locale`='zhCN' AND `ID` BETWEEN '70000' AND '71000';
+INSERT INTO `npc_text_locale` (`ID`, `Locale`, `Text0_0`, `Text0_1`, `Text1_0`, `Text1_1`, `Text2_0`, `Text2_1`, `Text3_0`, `Text3_1`, `Text4_0`, `Text4_1`, `Text5_0`, `Text5_1`, `Text6_0`, `Text6_1`, `Text7_0`, `Text7_1`)
+VALUES
+('70001','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70002','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70003','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70004','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70005','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70006','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70007','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70008','zhCN',' <>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70009','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70101','zhCN','|cffff3300|r$b|cffdd6600-=III=-|r$B$B\\\",,\".$B$B:.$B$B.,.,.$B$B.,.$B$B().15%x2(x3,x4).$B$B. .$B$B',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70102','zhCN','|cff9900cc|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B,,,\\,,,,\\:50%+200% .$B$B.2,22,20.20%5%,7.$B$B.,.$B$B.().$B$B.15,1%,10,3.$B$B.15,2%,10,3.$B$B()..$B$B',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70103','zhCN','|cff0000dd|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B35%,,,/,,:100%.:.$B$B!,,6.1,20.$B$B.10%,40.$B$B.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70104','zhCN','|cff9900cc|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B,,,,,/,,:200%.:.$B$B.,,,10.$B$B.60,,,6.$B$B.5%,40(100%,25%),.$B$B.,180,180.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70105','zhCN','|cff0000dd|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B75%,,-30%,,/,:200%.:.$B$B.,,,3.$B$B().,(),.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70106','zhCN','|cff9900cc|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B35%,,,/,/,,:50%.:.$B$B.48,15.$B$B.,150%.,(5,80,).20%,5.$B$B.,5,200%.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70201','zhCN','',NULL,'',NULL,'',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70202','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70203','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70204','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70300','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70301','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70302','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70303','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70304','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70305','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70306','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70307','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70308','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70309','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70310','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70311','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70312','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70313','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70314','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70315','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70316','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70317','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70318','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70319','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70320','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70321','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70322','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70323','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70324','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70325','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70326','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70327','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70328','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70329','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70330','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70331','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70332','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70333','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70334','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70335','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70336','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70337','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70338','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70339','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70340','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70341','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70342','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70343','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70344','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70345','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70346','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70347','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70348','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70349','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70350','zhCN','NIY',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70351','zhCN','NIY',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70352','zhCN','NIY',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70353','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70354','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70355','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70356','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70357','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70358','zhCN','  ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70359','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70360','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70361','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70362','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70363','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70364','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70365','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70366','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70367','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70368','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70369','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70370','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70371','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70372','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70373','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70374','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70375','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70376','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70377','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70378','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70379','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70380','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70381','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70382','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70383','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70384','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70385','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70386','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70387','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70388','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70389','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70390','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70391','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70392','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70393','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70394','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70395','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70396','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70397','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70398','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70399','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70400','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70401','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70402','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70403','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70404','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70405','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70406','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70407','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70408','zhCN','5',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70409','zhCN','5',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70410','zhCN','5',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70411','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70412','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70413','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70414','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70415','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70416','zhCN','%',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70417','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70418','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70419','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70420','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70421','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70422','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70423','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70424','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70425','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70426','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70427','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70428','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70429','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70430','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70431','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70432','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70433','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70434','zhCN','PvP ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70435','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70436','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70437','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70438','zhCN','%s ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70439','zhCN','<Debug>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70440','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70441','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70442','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70443','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70444','zhCN','<...>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70445','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70446','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70447','zhCN','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70448','zhCN','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70449','zhCN','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70450','zhCN','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70451','zhCN','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70452','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70453','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70454','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70455','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70456','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70457','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70458','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70459','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70460','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70461','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70462','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70463','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70464','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70465','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70466','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70467','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70468','zhCN','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70469','zhCN','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70470','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70471','zhCN','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70472','zhCN','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70473','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70474','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70475','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70476','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70477','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70478','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70479','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70480','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70481','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70482','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70483','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70484','zhCN','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70485','zhCN',' ()',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70486','zhCN',' ()',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70487','zhCN',' ()',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70488','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70489','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70490','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70491','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70492','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70493','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70494','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70495','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70496','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70497','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70498','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70499','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70500','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70501','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70502','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70503','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70504','zhCN','1...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70505','zhCN','2...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70506','zhCN','1...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70507','zhCN','2...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70508','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70509','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70510','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70511','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70512','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70513','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70514','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70515','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70516','zhCN','......',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70517','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70518','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70519','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70520','zhCN',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70521','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70522','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70523','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70524','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70525','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70526','zhCN','  ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70527','zhCN',' %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70528','zhCN','60 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70529','zhCN','55 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70530','zhCN','40 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70531','zhCN','20 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70532','zhCN','%u',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70533','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70534','zhCN','%u%u',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70535','zhCN',' %u (%s)! ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70536','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70537','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70538','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70539','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70540','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70541','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70542','zhCN','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70543','zhCN',' %s ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70544','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70545','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70546','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70547','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70548','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70549','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70550','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70551','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70552','zhCN','%s %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70553','zhCN','%s ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70554','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70555','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70556','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70557','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70558','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70559','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70560','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70561','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70562','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70563','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70564','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70565','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70566','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70567','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70568','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70569','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70570','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70571','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70572','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70573','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70574','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70575','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70576','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70577','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70578','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70579','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70580','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70581','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70582','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70583','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70584','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70585','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70586','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70587','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70588','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70589','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70590','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70591','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70592','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70593','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70594','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70595','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70596','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70597','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70598','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70599','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70600','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70601','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70602','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70603','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70604','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70605','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70606','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70607','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70608','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70609','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70610','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70611','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70612','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70613','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70614','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70615','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70616','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70617','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70618','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70619','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70620','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70621','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70622','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70623','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70624','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70625','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70626','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70627','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70628','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70629','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70630','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70631','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70632','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70633','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70634','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70635','zhCN','|cff9d9d9d|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70636','zhCN','|cffffffff|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70637','zhCN','|cff1eff00|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70638','zhCN','|cff0070dd|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70639','zhCN','|cffa335ee|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70640','zhCN','|cffff8000|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70641','zhCN','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70642','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70643','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70644','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70645','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70646','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70647','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70648','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70649','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70650','zhCN','|AOE|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70651','zhCN','|NIY|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70652','zhCN','|....|r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70653','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70654','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70655','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70656','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70657','zhCN','||r',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
diff --git a/sql/Bots/locales/zhTW/npc_text_locale.sql b/sql/Bots/locales/zhTW/npc_text_locale.sql
new file mode 100644
index 000000000..62661d2b7
--- /dev/null
+++ b/sql/Bots/locales/zhTW/npc_text_locale.sql
@@ -0,0 +1,343 @@
+DELETE FROM `npc_text_locale` WHERE `Locale`='zhTW' AND `ID` BETWEEN '70000' AND '71000';
+INSERT INTO `npc_text_locale` (`ID`, `Locale`, `Text0_0`, `Text0_1`, `Text1_0`, `Text1_1`, `Text2_0`, `Text2_1`, `Text3_0`, `Text3_1`, `Text4_0`, `Text4_1`, `Text5_0`, `Text5_1`, `Text6_0`, `Text6_1`, `Text7_0`, `Text7_1`)
+VALUES
+('70001','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70002','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70003','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70004','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70005','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70006','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70007','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70008','zhTW',' <...>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70009','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70101','zhTW','|cffff3300|r$b|cffdd6600-=III=-|r$B$B\\\",,\".$B$B:.$B$B.,.,.$B$B.,.$B$B().15%x2(x3,x4).$B$B. .$B$B',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70102','zhTW','|cff9900cc|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B,,,\\,,,,\\:50%+200% .$B$B.2,22,20.20%5%,7.$B$B.,.$B$B.().$B$B.15,1%,10,3.$B$B.15,2%,10,3.$B$B()..$B$B',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70103','zhTW','|cff0000dd|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B35%,,,/,,:100%.:.$B$B,,6.1,20.$B$B.10%,40.$B$B.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70104','zhTW','|cff9900cc|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B,,,,,/,,:200%.:.$B$B.,,,10.$B$B.60,,,6.$B$B.5%,40(100%,25%),.$B$B.,180,180.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70105','zhTW','|cff0000dd|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B75%,,-30%,,/,:200%.:.$B$B.,,,3.$B$B().,(),.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70106','zhTW','|cff9900cc|r$b|cffdd6600-=III=-|r$B$B\\\",\\\".$B$B35%,,,/,/,,:50%.:.$B$B.48,15.$B$B.,150%.,(5,80,).20%,5.$B$B.,5,200%.',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70201','zhTW','',NULL,'',NULL,'',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70202','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70203','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70204','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70300','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70301','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70302','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70303','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70304','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70305','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70306','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70307','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70308','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70309','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70310','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70311','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70312','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70313','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70314','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70315','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70316','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70317','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70318','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70319','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70320','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70321','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70322','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70323','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70324','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70325','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70326','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70327','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70328','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70329','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70330','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70331','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70332','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70333','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70334','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70335','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70336','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70337','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70338','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70339','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70340','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70341','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70342','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70343','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70344','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70345','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70346','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70347','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70348','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70349','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70350','zhTW','NIY',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70351','zhTW','NIY',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70352','zhTW','NIY',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70353','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70354','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70355','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70356','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70357','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70358','zhTW','  ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70359','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70360','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70361','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70362','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70363','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70364','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70365','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70366','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70367','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70368','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70369','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70370','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70371','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70372','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70373','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70374','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70375','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70376','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70377','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70378','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70379','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70380','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70381','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70382','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70383','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70384','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70385','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70386','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70387','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70388','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70389','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70390','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70391','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70392','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70393','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70394','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70395','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70396','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70397','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70398','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70399','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70400','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70401','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70402','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70403','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70404','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70405','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70406','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70407','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70408','zhTW','5',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70409','zhTW','5',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70410','zhTW','5',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70411','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70412','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70413','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70414','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70415','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70416','zhTW','%',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70417','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70418','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70419','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70420','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70421','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70422','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70423','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70424','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70425','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70426','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70427','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70428','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70429','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70430','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70431','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70432','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70433','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70434','zhTW','PvP ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70435','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70436','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70437','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70438','zhTW','%s ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70439','zhTW','<Debug>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70440','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70441','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70442','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70443','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70444','zhTW','<...>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70445','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70446','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70447','zhTW','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70448','zhTW','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70449','zhTW','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70450','zhTW','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70451','zhTW','  ...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70452','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70453','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70454','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70455','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70456','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70457','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70458','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70459','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70460','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70461','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70462','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70463','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70464','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70465','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70466','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70467','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70468','zhTW','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70469','zhTW','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70470','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70471','zhTW','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70472','zhTW','< >',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70473','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70474','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70475','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70476','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70477','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70478','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70479','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70480','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70481','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70482','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70483','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70484','zhTW','<>',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70485','zhTW',' ()',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70486','zhTW',' ()',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70487','zhTW',' ()',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70488','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70489','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70490','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70491','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70492','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70493','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70494','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70495','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70496','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70497','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70498','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70499','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70500','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70501','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70502','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70503','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70504','zhTW','1...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70505','zhTW','2...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70506','zhTW','1...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70507','zhTW','2...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70508','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70509','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70510','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70511','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70512','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70513','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70514','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70515','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70516','zhTW','......',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70517','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70518','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70519','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70520','zhTW',' ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70521','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70522','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70523','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70524','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70525','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70526','zhTW','  ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70527','zhTW',' %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70528','zhTW','60 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70529','zhTW','55 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70530','zhTW','40 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70531','zhTW','20 %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70532','zhTW','%u',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70533','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70534','zhTW','%u%u',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70535','zhTW',' %u (%s)! ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70536','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70537','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70538','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70539','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70540','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70541','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70542','zhTW','...',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70543','zhTW',' %s ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70544','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70545','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70546','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70547','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70548','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70549','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70550','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70551','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70552','zhTW','%s %s',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70553','zhTW','%s ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70554','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70555','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70556','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70557','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70558','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70559','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70560','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70561','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70562','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70563','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70564','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70565','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70566','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70567','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70568','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70569','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70570','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70571','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70572','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70573','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70574','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70575','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70576','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70577','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70578','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70579','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70580','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70581','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70582','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70583','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70584','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70585','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70586','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70587','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70588','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70589','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70590','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70591','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70592','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70593','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70594','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70595','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70596','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70597','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70598','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70599','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70600','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70601','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70602','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70603','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70604','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70605','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70606','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70607','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70608','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70609','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70610','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70611','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70612','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70613','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70614','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70615','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70616','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70617','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70618','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70619','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL),
+('70620','zhTW','',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
diff --git a/sql/Bots/merge_sqls_auth_unix.sh b/sql/Bots/merge_sqls_auth_unix.sh
new file mode 100644
index 000000000..a237789bd
--- /dev/null
+++ b/sql/Bots/merge_sqls_auth_unix.sh
@@ -0,0 +1,2 @@
+#!/bin/bash
+cat updates/auth/*.sql > ALL_auth.sql
diff --git a/sql/Bots/merge_sqls_auth_windows.bat b/sql/Bots/merge_sqls_auth_windows.bat
new file mode 100644
index 000000000..1bc1c0145
--- /dev/null
+++ b/sql/Bots/merge_sqls_auth_windows.bat
@@ -0,0 +1 @@
+copy /a updates\auth\*.sql /b ALL_auth.sql
diff --git a/sql/Bots/merge_sqls_characters_unix.sh b/sql/Bots/merge_sqls_characters_unix.sh
new file mode 100644
index 000000000..40f062d93
--- /dev/null
+++ b/sql/Bots/merge_sqls_characters_unix.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+cat characters_bots.sql > ALL_characters.sql
+cat updates/characters/*.sql >> ALL_characters.sql
diff --git a/sql/Bots/merge_sqls_characters_windows.bat b/sql/Bots/merge_sqls_characters_windows.bat
new file mode 100644
index 000000000..45cf6a33e
--- /dev/null
+++ b/sql/Bots/merge_sqls_characters_windows.bat
@@ -0,0 +1 @@
+copy /a characters_bots.sql + /a updates\characters\*.sql /b ALL_characters.sql
diff --git a/sql/Bots/merge_sqls_world_unix.sh b/sql/Bots/merge_sqls_world_unix.sh
new file mode 100644
index 000000000..ab7b2b1f1
--- /dev/null
+++ b/sql/Bots/merge_sqls_world_unix.sh
@@ -0,0 +1,3 @@
+#!/bin/bash
+cat *world_*.sql > ALL_world.sql
+cat updates/world/*.sql >> ALL_world.sql
diff --git a/sql/Bots/merge_sqls_world_windows.bat b/sql/Bots/merge_sqls_world_windows.bat
new file mode 100644
index 000000000..26b87e563
--- /dev/null
+++ b/sql/Bots/merge_sqls_world_windows.bat
@@ -0,0 +1 @@
+copy /a *world_*.sql + /a updates\world\*.sql /b ALL_world.sql
diff --git a/sql/Bots/updates/auth/2021_09_14_00_rbac_permissions.sql b/sql/Bots/updates/auth/2021_09_14_00_rbac_permissions.sql
new file mode 100644
index 000000000..5a9cb7309
--- /dev/null
+++ b/sql/Bots/updates/auth/2021_09_14_00_rbac_permissions.sql
@@ -0,0 +1,39 @@
+--
+SET @PERMISSION_START = 70001;
+SET @PERMISSION_END   = 70033;
+
+DELETE FROM `rbac_permissions` WHERE id BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+('70001','Command: npcbot'),
+('70002','Command: npcbot add'),
+('70003','Command: npcbot remove'),
+('70004','Command: npcbot spawn'),
+('70005','Command: npcbot move'),
+('70006','Command: npcbot delete'),
+('70007','Command: npcbot lookup'),
+('70008','Command: npcbot revive'),
+('70009','Command: npcbot reloadconfig'),
+('70010','Command: npcbot info'),
+('70011','Command: npcbot hide'),
+('70012','Command: npcbot unhide'),
+('70013','Command: npcbot recall'),
+('70014','Command: npcbot kill'),
+('70015','Command: npcbot debug raid'),
+('70016','Command: npcbot debug mount'),
+('70017','Command: npcbot debug spellvisual'),
+('70018','Command: npcbot debug states'),
+('70019','Command: npcbot toggle flags'),
+('70020','Command: npcbot set faction'),
+('70021','Command: npcbot set owner'),
+('70022','Command: npcbot set spec'),
+('70023','Command: npcbot command standstill'),
+('70024','Command: npcbot command stopfully'),
+('70025','Command: npcbot command follow'),
+('70026','Command: npcbot distance attack short'),
+('70027','Command: npcbot distance attack long'),
+('70028','Command: npcbot distance attack'),
+('70029','Command: npcbot distance'),
+('70030','Command: npcbot order cast'),
+('70031','Command: npcbot vehicle eject'),
+('70032','Command: npcbot dump load'),
+('70033','Command: npcbot dump write');
diff --git a/sql/Bots/updates/auth/2021_09_14_01_rbac_linked_permissions.sql b/sql/Bots/updates/auth/2021_09_14_01_rbac_linked_permissions.sql
new file mode 100644
index 000000000..555828ce0
--- /dev/null
+++ b/sql/Bots/updates/auth/2021_09_14_01_rbac_linked_permissions.sql
@@ -0,0 +1,39 @@
+--
+SET @PERMISSION_START = 70001;
+SET @PERMISSION_END   = 70033;
+
+DELETE FROM `rbac_linked_permissions` WHERE linkedId BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('199','70001'),
+('197','70002'),
+('197','70003'),
+('197','70004'),
+('197','70005'),
+('197','70006'),
+('197','70007'),
+('197','70008'),
+('197','70009'),
+('199','70010'),
+('199','70011'),
+('199','70012'),
+('199','70013'),
+('199','70014'),
+('197','70015'),
+('197','70016'),
+('197','70017'),
+('197','70018'),
+('197','70019'),
+('197','70020'),
+('197','70021'),
+('197','70022'),
+('199','70023'),
+('199','70024'),
+('199','70025'),
+('199','70026'),
+('199','70027'),
+('199','70028'),
+('199','70029'),
+('199','70030'),
+('199','70031'),
+('196','70032'),
+('196','70033');
diff --git a/sql/Bots/updates/auth/2021_12_29_00_rbac_permissions.sql b/sql/Bots/updates/auth/2021_12_29_00_rbac_permissions.sql
new file mode 100644
index 000000000..30491065a
--- /dev/null
+++ b/sql/Bots/updates/auth/2021_12_29_00_rbac_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70034;
+SET @PERMISSION_END   = 70034;
+
+DELETE FROM `rbac_permissions` WHERE id BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+('70034','Command: npcbot spawned');
diff --git a/sql/Bots/updates/auth/2021_12_29_01_rbac_linked_permissions.sql b/sql/Bots/updates/auth/2021_12_29_01_rbac_linked_permissions.sql
new file mode 100644
index 000000000..5b960ef79
--- /dev/null
+++ b/sql/Bots/updates/auth/2021_12_29_01_rbac_linked_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70034;
+SET @PERMISSION_END   = 70034;
+
+DELETE FROM `rbac_linked_permissions` WHERE linkedId BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('196','70034');
diff --git a/sql/Bots/updates/auth/2022_06_24_00_rbac_permissions.sql b/sql/Bots/updates/auth/2022_06_24_00_rbac_permissions.sql
new file mode 100644
index 000000000..916767c49
--- /dev/null
+++ b/sql/Bots/updates/auth/2022_06_24_00_rbac_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70035;
+SET @PERMISSION_END   = 70035;
+
+DELETE FROM `rbac_permissions` WHERE id BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+('70035','Command: npcbot command walk');
diff --git a/sql/Bots/updates/auth/2022_06_24_01_rbac_linked_permissions.sql b/sql/Bots/updates/auth/2022_06_24_01_rbac_linked_permissions.sql
new file mode 100644
index 000000000..a62f6925d
--- /dev/null
+++ b/sql/Bots/updates/auth/2022_06_24_01_rbac_linked_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70035;
+SET @PERMISSION_END   = 70035;
+
+DELETE FROM `rbac_linked_permissions` WHERE linkedId BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('199','70035');
diff --git a/sql/Bots/updates/auth/2022_07_04_00_rbac_permissions.sql b/sql/Bots/updates/auth/2022_07_04_00_rbac_permissions.sql
new file mode 100644
index 000000000..deac7ed3e
--- /dev/null
+++ b/sql/Bots/updates/auth/2022_07_04_00_rbac_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70036;
+SET @PERMISSION_END   = 70036;
+
+DELETE FROM `rbac_permissions` WHERE id BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+('70036','Command: npcbot createnew');
diff --git a/sql/Bots/updates/auth/2022_07_04_01_rbac_linked_permissions.sql b/sql/Bots/updates/auth/2022_07_04_01_rbac_linked_permissions.sql
new file mode 100644
index 000000000..dac351bef
--- /dev/null
+++ b/sql/Bots/updates/auth/2022_07_04_01_rbac_linked_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70036;
+SET @PERMISSION_END   = 70036;
+
+DELETE FROM `rbac_linked_permissions` WHERE linkedId BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('196','70036');
diff --git a/sql/Bots/updates/auth/2022_11_30_00_rbac_permissions.sql b/sql/Bots/updates/auth/2022_11_30_00_rbac_permissions.sql
new file mode 100644
index 000000000..9a02a53a5
--- /dev/null
+++ b/sql/Bots/updates/auth/2022_11_30_00_rbac_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70037;
+SET @PERMISSION_END   = 70037;
+
+DELETE FROM `rbac_permissions` WHERE id BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+('70037','Command: npcbot sendto');
diff --git a/sql/Bots/updates/auth/2022_11_30_rbac_linked_permissions.sql b/sql/Bots/updates/auth/2022_11_30_rbac_linked_permissions.sql
new file mode 100644
index 000000000..840f9898f
--- /dev/null
+++ b/sql/Bots/updates/auth/2022_11_30_rbac_linked_permissions.sql
@@ -0,0 +1,7 @@
+--
+SET @PERMISSION_START = 70037;
+SET @PERMISSION_END   = 70037;
+
+DELETE FROM `rbac_linked_permissions` WHERE linkedId BETWEEN @PERMISSION_START AND @PERMISSION_END;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('199','70037');
diff --git a/sql/Bots/updates/characters/2020_05_15_characters_npcbot_NPCBots_4.7.8a-4.7.27a.sql b/sql/Bots/updates/characters/2020_05_15_characters_npcbot_NPCBots_4.7.8a-4.7.27a.sql
new file mode 100644
index 000000000..ab44f6517
--- /dev/null
+++ b/sql/Bots/updates/characters/2020_05_15_characters_npcbot_NPCBots_4.7.8a-4.7.27a.sql
@@ -0,0 +1 @@
+ALTER TABLE `characters_npcbot` ADD `spec` tinyint(3) unsigned NOT NULL DEFAULT '1' AFTER `roles`;
diff --git a/sql/Bots/updates/characters/2020_06_21_characters_npcbot_43fceb98.sql b/sql/Bots/updates/characters/2020_06_21_characters_npcbot_43fceb98.sql
new file mode 100644
index 000000000..368e5a977
--- /dev/null
+++ b/sql/Bots/updates/characters/2020_06_21_characters_npcbot_43fceb98.sql
@@ -0,0 +1,172 @@
+DROP TEMPORARY TABLE IF EXISTS `npcbot_extras_temp`;
+
+CREATE TEMPORARY TABLE `npcbot_extras_temp` (
+  `entry` MEDIUMINT(8) UNSIGNED NOT NULL,
+  `class` TINYINT(3) UNSIGNED NOT NULL DEFAULT '1',
+  PRIMARY KEY (`entry`)
+) ENGINE=INNODB DEFAULT CHARSET=utf8;
+
+INSERT INTO `npcbot_extras_temp` (`entry`,`class`) VALUES
+('70001','1'),('70002','1'),('70003','1'),('70004','1'),('70005','1'),
+('70006','1'),('70007','1'),('70008','1'),('70009','1'),('70010','1'),
+('70011','1'),('70012','1'),('70013','1'),('70014','1'),('70015','1'),
+('70016','1'),('70017','1'),('70018','1'),('70019','1'),('70020','1'),
+('70021','1'),('70022','1'),('70023','1'),('70024','1'),('70025','1'),
+('70026','1'),('70027','1'),('70028','1'),('70029','1'),('70030','1'),
+('70031','1'),('70032','1'),('70033','1'),('70034','1'),('70035','1'),
+('70036','1'),('70037','1'),('70038','1'),('70051','2'),('70052','2'),
+('70053','2'),('70054','2'),('70055','2'),('70056','2'),('70057','2'),
+('70058','2'),('70059','2'),('70060','2'),('70061','2'),('70062','2'),
+('70063','2'),('70064','2'),('70065','2'),('70066','2'),('70067','2'),
+('70068','2'),('70069','2'),('70070','2'),('70071','2'),('70072','2'),
+('70073','2'),('70074','2'),('70101','3'),('70102','3'),('70103','3'),
+('70104','3'),('70105','3'),('70106','3'),('70107','3'),('70108','3'),
+('70109','3'),('70110','3'),('70111','3'),('70112','3'),('70113','3'),
+('70114','3'),('70115','3'),('70116','3'),('70117','3'),('70118','3'),
+('70119','3'),('70120','3'),('70121','3'),('70122','3'),('70123','3'),
+('70124','3'),('70125','3'),('70126','3'),('70127','3'),('70128','3'),
+('70129','3'),('70130','3'),('70131','3'),('70132','3'),('70133','3'),
+('70134','3'),('70135','3'),('70136','3'),('70137','3'),('70138','3'),
+('70139','3'),('70151','4'),('70152','4'),('70153','4'),('70154','4'),
+('70155','4'),('70156','4'),('70157','4'),('70158','4'),('70159','4'),
+('70160','4'),('70161','4'),('70162','4'),('70163','4'),('70164','4'),
+('70165','4'),('70166','4'),('70167','4'),('70168','4'),('70169','4'),
+('70170','4'),('70171','4'),('70172','4'),('70173','4'),('70174','4'),
+('70175','4'),('70176','4'),('70177','4'),('70178','4'),('70179','4'),
+('70180','4'),('70181','4'),('70201','5'),('70202','5'),('70203','5'),
+('70204','5'),('70205','5'),('70206','5'),('70207','5'),('70208','5'),
+('70209','5'),('70210','5'),('70211','5'),('70212','5'),('70213','5'),
+('70214','5'),('70215','5'),('70216','5'),('70217','5'),('70218','5'),
+('70219','5'),('70220','5'),('70221','5'),('70222','5'),('70223','5'),
+('70224','5'),('70225','5'),('70226','5'),('70227','5'),('70228','5'),
+('70229','5'),('70230','5'),('70231','5'),('70232','5'),('70233','5'),
+('70234','5'),('70235','5'),('70236','5'),('70237','5'),('70238','5'),
+('70239','5'),('70240','5'),('70251','7'),('70252','7'),('70253','7'),
+('70254','7'),('70255','7'),('70256','7'),('70257','7'),('70258','7'),
+('70259','7'),('70260','7'),('70261','7'),('70265','7'),('70267','7'),
+('70268','7'),('70301','8'),('70302','8'),('70303','8'),('70304','8'),
+('70305','8'),('70306','8'),('70307','8'),('70308','8'),('70309','8'),
+('70310','8'),('70311','8'),('70312','8'),('70313','8'),('70314','8'),
+('70315','8'),('70316','8'),('70317','8'),('70318','8'),('70319','8'),
+('70320','8'),('70321','8'),('70322','8'),('70323','8'),('70324','8'),
+('70325','8'),('70326','8'),('70327','8'),('70328','8'),('70329','8'),
+('70330','8'),('70331','8'),('70332','8'),('70333','8'),('70334','8'),
+('70335','8'),('70336','8'),('70351','9'),('70352','9'),('70353','9'),
+('70354','9'),('70355','9'),('70356','9'),('70357','9'),('70358','9'),
+('70359','9'),('70360','9'),('70361','9'),('70362','9'),('70363','9'),
+('70364','9'),('70365','9'),('70366','9'),('70367','9'),('70368','9'),
+('70369','9'),('70370','9'),('70371','9'),('70372','9'),('70373','9'),
+('70374','9'),('70375','9'),('70376','9'),('70377','9'),('70401','11'),
+('70402','11'),('70403','11'),('70404','11'),('70405','11'),('70406','11'),
+('70407','11'),('70408','11'),('70409','11'),('70410','11'),('70411','11'),
+('70412','11'),('70413','11'),('70414','11'),('70415','11'),('70416','11'),
+('70417','11'),('70418','11'),('70451','6'),('70452','6'),('70453','6'),
+('70454','6'),('70455','6'),('70456','6'),('70457','6'),('70458','6'),
+('70459','6'),('70460','6'),('70461','6'),('70462','6'),('70463','6'),
+('70464','6'),('70465','6'),('70501','0'),('70502','0'),('70503','0'),
+('70504','0'),('70505','0'),('70506','0'),('70507','0'),('70508','0'),
+('70509','0'),('70510','0'),('70511','0'),('70512','0'),('70513','0'),
+('70514','0'),('70515','0'),('70516','0'),('70517','0'),('70518','0'),
+('70519','0'),('70520','0'),('70521','0'),('70522','0'),('70523','0'),
+('70524','0'),('70525','0'),('70526','0'),('70527','0'),('70528','0'),
+('70529','0'),('70530','0'),('70531','0'),('70532','0'),('70533','0'),
+('70534','0'),('70535','0'),('70536','0'),('70537','0'),('70538','0'),
+('70542','0'),('70543','0'),('70544','0'),('70545','0'),('70551','12'),
+('70552','12'),('70553','13'),('70554','13'),('70555','14'),('70556','0'),
+('70557','15'),('70558','15'),('70559','15'),('70560','15'),('70561','15'),
+('70562','0'),('70563','16'),('70564','16'),('70565','16'),('70566','16'),
+('70567','16'),('70568','17'),('70569','17'),('70570','17'),('70571','17'),
+('70572','17'),('70573','0'),('70574','0');
+
+/*!50003 DROP PROCEDURE IF EXISTS `sp__update_specs_2020_06_21`*/;
+
+DELIMITER ;;
+
+/*!50003 CREATE*/
+/*!50003 PROCEDURE `sp__update_specs_2020_06_21`()
+BEGIN
+
+DECLARE CLASS_WARRIOR INT DEFAULT 1;
+DECLARE CLASS_PALADIN INT DEFAULT 2;
+DECLARE CLASS_HUNTER INT DEFAULT 3;
+DECLARE CLASS_ROGUE INT DEFAULT 4;
+DECLARE CLASS_PRIEST INT DEFAULT 5;
+DECLARE CLASS_DEATH_KNIGHT INT DEFAULT 6;
+DECLARE CLASS_SHAMAN INT DEFAULT 7;
+DECLARE CLASS_MAGE INT DEFAULT 8;
+DECLARE CLASS_WARLOCK INT DEFAULT 9;
+DECLARE CLASS_DRUID INT DEFAULT 11;
+DECLARE CLASS_BLADEMASTER INT DEFAULT 12;
+DECLARE CLASS_SPHYNX INT DEFAULT 13;
+DECLARE CLASS_ARCHMAGE INT DEFAULT 14;
+DECLARE CLASS_DREADLORD INT DEFAULT 15;
+DECLARE CLASS_SPELL_BREAKER INT DEFAULT 16;
+DECLARE CLASS_DARK_RANGER INT DEFAULT 17;
+
+DECLARE SPEC_START_WARRIOR INT DEFAULT 1;
+DECLARE SPEC_START_PALADIN INT DEFAULT 4;
+DECLARE SPEC_START_HUNTER INT DEFAULT 7;
+DECLARE SPEC_START_ROGUE INT DEFAULT 10;
+DECLARE SPEC_START_PRIEST INT DEFAULT 13;
+DECLARE SPEC_START_DEATH_KNIGHT INT DEFAULT 16;
+DECLARE SPEC_START_SHAMAN INT DEFAULT 19;
+DECLARE SPEC_START_MAGE INT DEFAULT 22;
+DECLARE SPEC_START_WARLOCK INT DEFAULT 25;
+DECLARE SPEC_START_DRUID INT DEFAULT 28;
+DECLARE SPEC_DEFAULT INT DEFAULT 31;
+
+DECLARE NPCBOT_ENTRY_BEGIN INT DEFAULT 70001;
+DECLARE NPCBOT_ENTRY_END INT DEFAULT 71000;
+
+DECLARE cur_pos INT;
+DECLARE myclass INT;
+DECLARE myspec INT;
+
+SET cur_pos = NPCBOT_ENTRY_BEGIN;
+WHILE cur_pos < NPCBOT_ENTRY_END DO
+    SET myclass = (SELECT `class` FROM `npcbot_extras_temp` WHERE `entry` = cur_pos);
+    SET myspec = (SELECT `spec` FROM `characters_npcbot` WHERE `entry` = cur_pos);
+
+    IF myclass != 0 AND myspec != 0 AND myspec < 4 THEN
+
+        IF myclass = CLASS_WARRIOR THEN
+            SET myspec = myspec + SPEC_START_WARRIOR - 1;
+        ELSEIF myclass = CLASS_PALADIN THEN
+            SET myspec = myspec + SPEC_START_PALADIN - 1;
+        ELSEIF myclass = CLASS_HUNTER THEN
+            SET myspec = myspec + SPEC_START_HUNTER - 1;
+        ELSEIF myclass = CLASS_ROGUE THEN
+            SET myspec = myspec + SPEC_START_ROGUE - 1;
+        ELSEIF myclass = CLASS_PRIEST THEN
+            SET myspec = myspec + SPEC_START_PRIEST - 1;
+        ELSEIF myclass = CLASS_DEATH_KNIGHT THEN
+            SET myspec = myspec + SPEC_START_DEATH_KNIGHT - 1;
+        ELSEIF myclass = CLASS_SHAMAN THEN
+            SET myspec = myspec + SPEC_START_SHAMAN - 1;
+        ELSEIF myclass = CLASS_MAGE THEN
+            SET myspec = myspec + SPEC_START_MAGE - 1;
+        ELSEIF myclass = CLASS_WARLOCK THEN
+            SET myspec = myspec + SPEC_START_WARLOCK - 1;
+        ELSEIF myclass = CLASS_DRUID THEN
+            SET myspec = myspec + SPEC_START_DRUID - 1;
+        ELSE
+            SET myspec = SPEC_DEFAULT;
+        END IF;
+
+        UPDATE `characters_npcbot` SET `spec` = myspec WHERE `entry` = cur_pos;
+
+    END IF;
+
+    SET cur_pos = cur_pos + 1;
+
+END WHILE;
+
+DROP TEMPORARY TABLE IF EXISTS `npcbot_extras_temp`;
+
+END*/;;
+
+DELIMITER ;
+
+CALL `sp__update_specs_2020_06_21`();
+
+DROP PROCEDURE IF EXISTS `sp__update_specs_2020_06_21`;
diff --git a/sql/Bots/updates/characters/2020_10_08_characters_npcbot_NPCBots_4.7.34a-4.7.39a.sql b/sql/Bots/updates/characters/2020_10_08_characters_npcbot_NPCBots_4.7.34a-4.7.39a.sql
new file mode 100644
index 000000000..74e0e207c
--- /dev/null
+++ b/sql/Bots/updates/characters/2020_10_08_characters_npcbot_NPCBots_4.7.34a-4.7.39a.sql
@@ -0,0 +1 @@
+ALTER TABLE `characters_npcbot` ADD `spells_disabled` longtext AFTER `equipNeck`;
diff --git a/sql/Bots/updates/characters/2021_01_04_characters_npcbot.sql b/sql/Bots/updates/characters/2021_01_04_characters_npcbot.sql
new file mode 100644
index 000000000..d553cc876
--- /dev/null
+++ b/sql/Bots/updates/characters/2021_01_04_characters_npcbot.sql
@@ -0,0 +1 @@
+ALTER TABLE `characters_npcbot` MODIFY COLUMN `roles` int(10) unsigned NOT NULL COMMENT 'bitmask: tank(1),dps(2),heal(4),ranged(8)';
diff --git a/sql/Bots/updates/characters/2021_01_24_characters_npcbot_stats.sql b/sql/Bots/updates/characters/2021_01_24_characters_npcbot_stats.sql
new file mode 100644
index 000000000..4bad36544
--- /dev/null
+++ b/sql/Bots/updates/characters/2021_01_24_characters_npcbot_stats.sql
@@ -0,0 +1,32 @@
+DROP TABLE IF EXISTS `characters_npcbot_stats`;
+
+CREATE TABLE `characters_npcbot_stats` (
+  `entry` int(10) unsigned NOT NULL DEFAULT '0',
+  `maxhealth` int(10) unsigned NOT NULL DEFAULT '0',
+  `maxpower` int(10) unsigned NOT NULL DEFAULT '0',
+  `strength` int(10) unsigned NOT NULL DEFAULT '0',
+  `agility` int(10) unsigned NOT NULL DEFAULT '0',
+  `stamina` int(10) unsigned NOT NULL DEFAULT '0',
+  `intellect` int(10) unsigned NOT NULL DEFAULT '0',
+  `spirit` int(10) unsigned NOT NULL DEFAULT '0',
+  `armor` int(10) unsigned NOT NULL DEFAULT '0',
+  `defense` int(10) unsigned NOT NULL DEFAULT '0',
+  `resHoly` int(10) unsigned NOT NULL DEFAULT '0',
+  `resFire` int(10) unsigned NOT NULL DEFAULT '0',
+  `resNature` int(10) unsigned NOT NULL DEFAULT '0',
+  `resFrost` int(10) unsigned NOT NULL DEFAULT '0',
+  `resShadow` int(10) unsigned NOT NULL DEFAULT '0',
+  `resArcane` int(10) unsigned NOT NULL DEFAULT '0',
+  `blockPct` float unsigned NOT NULL DEFAULT '0',
+  `dodgePct` float unsigned NOT NULL DEFAULT '0',
+  `parryPct` float unsigned NOT NULL DEFAULT '0',
+  `critPct` float unsigned NOT NULL DEFAULT '0',
+  `attackPower` int(10) unsigned NOT NULL DEFAULT '0',
+  `spellPower` int(10) unsigned NOT NULL DEFAULT '0',
+  `spellPen` int(10) unsigned NOT NULL DEFAULT '0',
+  `hastePct` float unsigned NOT NULL DEFAULT '0',
+  `hitBonusPct` float unsigned NOT NULL DEFAULT '0',
+  `expertise` int(10) unsigned NOT NULL DEFAULT '0',
+  `armorPenPct` float unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/updates/characters/2021_08_27_characters_npcbot.sql b/sql/Bots/updates/characters/2021_08_27_characters_npcbot.sql
new file mode 100644
index 000000000..2744daddf
--- /dev/null
+++ b/sql/Bots/updates/characters/2021_08_27_characters_npcbot.sql
@@ -0,0 +1,2 @@
+-- An update for shifted roles
+UPDATE `characters_npcbot` SET `roles` = (roles & 0x1) | ((roles & ~0x1) << 1);
diff --git a/sql/Bots/updates/characters/2022_11_15_characters_npcbot_transmog.SQL b/sql/Bots/updates/characters/2022_11_15_characters_npcbot_transmog.SQL
new file mode 100644
index 000000000..34d70861c
--- /dev/null
+++ b/sql/Bots/updates/characters/2022_11_15_characters_npcbot_transmog.SQL
@@ -0,0 +1,10 @@
+-- 
+DROP TABLE IF EXISTS `characters_npcbot_transmog`;
+CREATE TABLE `characters_npcbot_transmog` (
+  `entry` int(10) unsigned NOT NULL,
+  `slot` tinyint(3) unsigned NOT NULL,
+  `item_id` int(10) unsigned NOT NULL DEFAULT '0',
+  `fake_id` int(10) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`,`slot`),
+  CONSTRAINT `bot_id` FOREIGN KEY (`entry`) REFERENCES `characters_npcbot` (`entry`) ON DELETE CASCADE ON UPDATE CASCADE
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/updates/characters/2022_11_27_characters_npcbot_group_member.sql b/sql/Bots/updates/characters/2022_11_27_characters_npcbot_group_member.sql
new file mode 100644
index 000000000..25d114234
--- /dev/null
+++ b/sql/Bots/updates/characters/2022_11_27_characters_npcbot_group_member.sql
@@ -0,0 +1,10 @@
+-- 
+DROP TABLE IF EXISTS `characters_npcbot_group_member`;
+CREATE TABLE `characters_npcbot_group_member` (
+  `guid` int(10) unsigned NOT NULL,
+  `entry` int(10) unsigned NOT NULL,
+  `memberFlags` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `subgroup` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  `roles` tinyint(3) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/updates/world/2020_07_08_creature_template_npcbot_extras.sql b/sql/Bots/updates/world/2020_07_08_creature_template_npcbot_extras.sql
new file mode 100644
index 000000000..2e67192b3
--- /dev/null
+++ b/sql/Bots/updates/world/2020_07_08_creature_template_npcbot_extras.sql
@@ -0,0 +1,2 @@
+-- Zandine race fix
+UPDATE `creature_template_npcbot_extras` SET `race`='10' WHERE (`entry`='70135');
diff --git a/sql/Bots/updates/world/2020_09_25_creature_template.sql b/sql/Bots/updates/world/2020_09_25_creature_template.sql
new file mode 100644
index 000000000..e714bcb46
--- /dev/null
+++ b/sql/Bots/updates/world/2020_09_25_creature_template.sql
@@ -0,0 +1,2 @@
+-- Marion modelId fix
+UPDATE `creature_template` SET `modelid1`='1603' WHERE (`entry`='70158');
diff --git a/sql/Bots/updates/world/2020_10_14_creature_classlevelstats.sql b/sql/Bots/updates/world/2020_10_14_creature_classlevelstats.sql
new file mode 100644
index 000000000..22639e986
--- /dev/null
+++ b/sql/Bots/updates/world/2020_10_14_creature_classlevelstats.sql
@@ -0,0 +1,611 @@
+--
+SET @CLASS_HUNTER           = 3;
+SET @CLASS_PRIEST           = 5;
+SET @CLASS_DK               = 6;
+SET @CLASS_SHAMAN           = 7;
+SET @CLASS_WARLOCK          = 9;
+SET @CLASS_DRUID            = 11;
+
+-- actual values are irrelevant, but hp and mana must be > 1
+DELETE FROM `creature_classlevelstats` WHERE `class` IN (@CLASS_HUNTER,@CLASS_PRIEST,@CLASS_DK,@CLASS_SHAMAN,@CLASS_WARLOCK,@CLASS_DRUID) AND `level` BETWEEN '1' AND '100';
+INSERT INTO `creature_classlevelstats` (`level`,`class`,`basehp0`,`basehp1`,`basehp2`,`basemana`,`basearmor`,`attackpower`,`rangedattackpower`,`damage_base`,`damage_exp1`,`damage_exp2`,`comment`) VALUES
+('1', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('1', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('1', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('1', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('1', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('1', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('2', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('2', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('2', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('2', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('2', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('2', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('3', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('3', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('3', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('3', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('3', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('3', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('4', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('4', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('4', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('4', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('4', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('4', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('5', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('5', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('5', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('5', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('5', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('5', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('6', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('6', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('6', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('6', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('6', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('6', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('7', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('7', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('7', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('7', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('7', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('7', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('8', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('8', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('8', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('8', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('8', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('8', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('9', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('9', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('9', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('9', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('9', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('9', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('10', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('10', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('10', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('10', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('10', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('10', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('11', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('11', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('11', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('11', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('11', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('11', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('12', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('12', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('12', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('12', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('12', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('12', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('13', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('13', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('13', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('13', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('13', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('13', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('14', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('14', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('14', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('14', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('14', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('14', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('15', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('15', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('15', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('15', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('15', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('15', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('16', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('16', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('16', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('16', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('16', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('16', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('17', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('17', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('17', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('17', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('17', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('17', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('18', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('18', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('18', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('18', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('18', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('18', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('19', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('19', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('19', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('19', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('19', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('19', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('20', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('20', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('20', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('20', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('20', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('20', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('21', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('21', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('21', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('21', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('21', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('21', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('22', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('22', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('22', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('22', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('22', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('22', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('23', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('23', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('23', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('23', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('23', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('23', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('24', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('24', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('24', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('24', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('24', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('24', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('25', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('25', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('25', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('25', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('25', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('25', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('26', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('26', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('26', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('26', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('26', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('26', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('27', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('27', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('27', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('27', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('27', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('27', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('28', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('28', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('28', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('28', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('28', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('28', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('29', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('29', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('29', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('29', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('29', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('29', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('30', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('30', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('30', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('30', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('30', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('30', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('31', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('31', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('31', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('31', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('31', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('31', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('32', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('32', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('32', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('32', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('32', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('32', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('33', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('33', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('33', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('33', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('33', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('33', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('34', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('34', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('34', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('34', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('34', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('34', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('35', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('35', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('35', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('35', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('35', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('35', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('36', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('36', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('36', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('36', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('36', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('36', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('37', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('37', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('37', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('37', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('37', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('37', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('38', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('38', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('38', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('38', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('38', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('38', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('39', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('39', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('39', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('39', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('39', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('39', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('40', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('40', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('40', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('40', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('40', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('40', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('41', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('41', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('41', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('41', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('41', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('41', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('42', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('42', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('42', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('42', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('42', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('42', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('43', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('43', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('43', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('43', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('43', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('43', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('44', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('44', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('44', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('44', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('44', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('44', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('45', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('45', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('45', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('45', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('45', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('45', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('46', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('46', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('46', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('46', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('46', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('46', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('47', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('47', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('47', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('47', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('47', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('47', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('48', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('48', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('48', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('48', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('48', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('48', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('49', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('49', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('49', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('49', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('49', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('49', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('50', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('50', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('50', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('50', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('50', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('50', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('51', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('51', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('51', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('51', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('51', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('51', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('52', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('52', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('52', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('52', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('52', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('52', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('53', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('53', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('53', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('53', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('53', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('53', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('54', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('54', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('54', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('54', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('54', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('54', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('55', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('55', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('55', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('55', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('55', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('55', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('56', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('56', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('56', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('56', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('56', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('56', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('57', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('57', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('57', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('57', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('57', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('57', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('58', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('58', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('58', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('58', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('58', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('58', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('59', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('59', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('59', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('59', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('59', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('59', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('60', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('60', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('60', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('60', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('60', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('60', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('61', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('61', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('61', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('61', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('61', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('61', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('62', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('62', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('62', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('62', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('62', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('62', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('63', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('63', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('63', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('63', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('63', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('63', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('64', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('64', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('64', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('64', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('64', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('64', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('65', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('65', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('65', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('65', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('65', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('65', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('66', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('66', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('66', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('66', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('66', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('66', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('67', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('67', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('67', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('67', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('67', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('67', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('68', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('68', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('68', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('68', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('68', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('68', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('69', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('69', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('69', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('69', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('69', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('69', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('70', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('70', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('70', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('70', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('70', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('70', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('71', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('71', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('71', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('71', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('71', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('71', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('72', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('72', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('72', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('72', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('72', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('72', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('73', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('73', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('73', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('73', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('73', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('73', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('74', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('74', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('74', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('74', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('74', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('74', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('75', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('75', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('75', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('75', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('75', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('75', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('76', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('76', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('76', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('76', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('76', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('76', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('77', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('77', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('77', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('77', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('77', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('77', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('78', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('78', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('78', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('78', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('78', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('78', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('79', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('79', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('79', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('79', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('79', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('79', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('80', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('80', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('80', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('80', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('80', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('80', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('81', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('81', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('81', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('81', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('81', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('81', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('82', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('82', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('82', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('82', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('82', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('82', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('83', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('83', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('83', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('83', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('83', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('83', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('84', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('84', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('84', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('84', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('84', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('84', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('85', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('85', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('85', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('85', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('85', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('85', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('86', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('86', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('86', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('86', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('86', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('86', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('87', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('87', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('87', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('87', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('87', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('87', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('88', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('88', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('88', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('88', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('88', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('88', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('89', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('89', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('89', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('89', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('89', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('89', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('90', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('90', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('90', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('90', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('90', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('90', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('91', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('91', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('91', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('91', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('91', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('91', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('92', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('92', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('92', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('92', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('92', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('92', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('93', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('93', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('93', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('93', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('93', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('93', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('94', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('94', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('94', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('94', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('94', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('94', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('95', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('95', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('95', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('95', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('95', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('95', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('96', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('96', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('96', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('96', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('96', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('96', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('97', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('97', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('97', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('97', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('97', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('97', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('98', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('98', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('98', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('98', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('98', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('98', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('99', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('99', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('99', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('99', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('99', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('99', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('100', @CLASS_HUNTER, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('100', @CLASS_PRIEST, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('100', @CLASS_DK,     '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('100', @CLASS_SHAMAN, '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('100', @CLASS_WARLOCK,'2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL),
+('100', @CLASS_DRUID,  '2', '2', '2', '2', '0', '0', '0', '0.1', '0', '0', NULL);
diff --git a/sql/Bots/updates/world/2020_10_14_creature_template.sql b/sql/Bots/updates/world/2020_10_14_creature_template.sql
new file mode 100644
index 000000000..4580de48b
--- /dev/null
+++ b/sql/Bots/updates/world/2020_10_14_creature_template.sql
@@ -0,0 +1,50 @@
+--
+SET @CLASS_WARRIOR          = 1;
+SET @CLASS_PALADIN          = 2;
+SET @CLASS_HUNTER           = 3;
+SET @CLASS_ROGUE            = 4;
+SET @CLASS_PRIEST           = 5;
+SET @CLASS_DK               = 6;
+SET @CLASS_SHAMAN           = 7;
+SET @CLASS_MAGE             = 8;
+SET @CLASS_WARLOCK          = 9;
+SET @CLASS_DRUID            = 11;
+SET @CLASS_BM               = 12;
+SET @CLASS_SPHYNX           = 13;
+SET @CLASS_ARCHMAGE         = 14;
+SET @CLASS_DREADLORD        = 15;
+SET @CLASS_SPELLBREAKER     = 16;
+SET @CLASS_DARK_RANGER      = 17;
+
+UPDATE `creature_template` SET `unit_class`:=@CLASS_DK
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DK);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_DRUID
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DRUID);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_HUNTER
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_HUNTER);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_MAGE
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_MAGE);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_PALADIN
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_PALADIN);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_PRIEST
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_PRIEST);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_ROGUE
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_ROGUE);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_SHAMAN
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SHAMAN);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_WARLOCK
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_WARLOCK);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_WARRIOR
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_WARRIOR);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_WARRIOR
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_BM);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_WARLOCK
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SPHYNX);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_MAGE
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_ARCHMAGE);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_WARLOCK
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DREADLORD);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_PALADIN
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_SPELLBREAKER);
+UPDATE `creature_template` SET `unit_class`:=@CLASS_DK
+WHERE `entry` IN (SELECT `entry` FROM `creature_template_npcbot_extras` WHERE `class`=@CLASS_DARK_RANGER);
diff --git a/sql/Bots/updates/world/2020_10_15_creature_template.sql b/sql/Bots/updates/world/2020_10_15_creature_template.sql
new file mode 100644
index 000000000..9cb16889d
--- /dev/null
+++ b/sql/Bots/updates/world/2020_10_15_creature_template.sql
@@ -0,0 +1,2 @@
+--
+UPDATE `creature_template` SET `unit_flags2`='16416' WHERE `entry` IN ('70551','70552');
diff --git a/sql/Bots/updates/world/2020_11_07_npc_text.sql b/sql/Bots/updates/world/2020_11_07_npc_text.sql
new file mode 100644
index 000000000..94a866a9e
--- /dev/null
+++ b/sql/Bots/updates/world/2020_11_07_npc_text.sql
@@ -0,0 +1,329 @@
+--
+SET @LOCALIZED_STRINGS_START = 70300;
+SET @LOCALIZED_STRINGS_END   = 70799;
+
+-- LOCALIZATION STRING --
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70300','Die!','-1'),
+('70301','Rezzing You','-1'),
+('70302','Rezzing ','-1'),
+('70303','your bot','-1'),
+('70304','\'s bot','-1'),
+('70305','I can\'t conjure water yet','-1'),
+('70306','I can\'t conjure food yet','-1'),
+('70307','I can\'t do it right now','-1'),
+('70308','Here you go...','-1'),
+('70309','Disabled','-1'),
+('70310','Not ready yet','-1'),
+('70311','Invalid object type','-1'),
+('70312','Failed','-1'),
+('70313','Done','-1'),
+('70314','I am not shapeshifted','-1'),
+('70315','I don\'t have a healthstone','-1'),
+('70316','I can\'t create healthstones yet!','-1'),
+('70317','WTF I don\'t have lockpicking!','-1'),
+('70318','My skill level in not high enough','-1'),
+('70319','Changing my spec to ','-1'),
+('70320','Arms','-1'),
+('70321','Fury','-1'),
+('70322','Protection','-1'),
+('70323','Retribution','-1'),
+('70324','Beast Mastery','-1'),
+('70325','Marksmanship','-1'),
+('70326','Survival','-1'),
+('70327','Assassination','-1'),
+('70328','Combat','-1'),
+('70329','Subtlety','-1'),
+('70330','Discipline','-1'),
+('70331','Holy','-1'),
+('70332','Shadow','-1'),
+('70333','Blood','-1'),
+('70334','Frost','-1'),
+('70335','Unholy','-1'),
+('70336','Elemental','-1'),
+('70337','Enhancement','-1'),
+('70338','Restoration','-1'),
+('70339','Arcane','-1'),
+('70340','Fire','-1'),
+('70341','Affliction','-1'),
+('70342','Demonology','-1'),
+('70343','Destruction','-1'),
+('70344','Balance','-1'),
+('70345','Feral Combat','-1'),
+('70346','Unknown','-1'),
+('70347','Go away, weakling','-1'),
+('70348',' is not convinced','-1'),
+('70349','I am not going to waste my time on just anything','-1'),
+('70350','NIY','-1'),
+('70351','NIY','-1'),
+('70352','NIY','-1'),
+('70353','I am ready','-1'),
+('70354','Go away. I serve my master ','-1'),
+('70355','unknown','-1'),
+('70356',' on You!','-1'),
+('70357',' on myself!','-1'),
+('70358',' on ','-1'),
+('70359',' used!','-1'),
+('70360','bot tank','-1'),
+('70361','class','-1'),
+('70362','player','-1'),
+('70363','master','-1'),
+('70364','none','-1'),
+('70365','Rank','-1'),
+('70366','talent','-1'),
+('70367','passive','-1'),
+('70368','hidden','-1'),
+('70369','known','-1'),
+('70370','ability','-1'),
+('70371','str','-1'),
+('70372','agi','-1'),
+('70373','sta','-1'),
+('70374','int','-1'),
+('70375','spi','-1'),
+('70376','unk stat','-1'),
+('70377','total','-1'),
+('70378','Melee AP','-1'),
+('70379','Ranged AP','-1'),
+('70380','armor','-1'),
+('70381','crit','-1'),
+('70382','defense','-1'),
+('70383','miss','-1'),
+('70384','dodge','-1'),
+('70385','parry','-1'),
+('70386','block','-1'),
+('70387','block value','-1'),
+('70388','Damage taken melee','-1'),
+('70389','Damage taken spell','-1'),
+('70390','Damage range mainhand','-1'),
+('70391','Damage mult mainhand','-1'),
+('70392','Attack time mainhand','-1'),
+('70393','Damage range offhand','-1'),
+('70394','Damage mult offhand','-1'),
+('70395','Attack time offhand','-1'),
+('70396','Damage range ranged','-1'),
+('70397','Damage mult ranged','-1'),
+('70398','Attack time ranged','-1'),
+('70399','min','-1'),
+('70400','max','-1'),
+('70401','DPS','-1'),
+('70402','base hp','-1'),
+('70403','total hp','-1'),
+('70404','base mana','-1'),
+('70405','total mana','-1'),
+('70406','current mana','-1'),
+('70407','spell power','-1'),
+('70408','health regen_5 bonus','-1'),
+('70409','mana regen_5 no cast','-1'),
+('70410','mana regen_5 casting','-1'),
+('70411','haste','-1'),
+('70412','hit','-1'),
+('70413','expertise','-1'),
+('70414','armor penetration','-1'),
+('70415','spell penetration','-1'),
+('70416','pct','-1'),
+('70417','holy','-1'),
+('70418','fire','-1'),
+('70419','nature','-1'),
+('70420','frost','-1'),
+('70421','shadow','-1'),
+('70422','arcane','-1'),
+('70423','Resistance','-1'),
+('70424','Command states','-1'),
+('70425','Follow','-1'),
+('70426','Attack','-1'),
+('70427','Stay','-1'),
+('70428','Reset','-1'),
+('70429','FullStop','-1'),
+('70430','Follow distance','-1'),
+('70431','Spec','-1'),
+('70432','Bot roles mask main','-1'),
+('70433','Bot roles mask gathering','-1'),
+('70434','PvP kills','-1'),
+('70435','players','-1'),
+('70436','Died ','-1'),
+('70437',' times','-1'),
+('70438','%s (bot) calms down','-1'),
+('70439','<Debug>','-1'),
+('70440','Are you sure you want to risk drawing ','-1'),
+('70441','\'s attention?','-1'),
+('70442','<Insert Coin>','-1'),
+('70443','Do you want to entice ','-1'),
+('70444','<Try to make an offering>','-1'),
+('70445','Do you wish to hire ','-1'),
+('70446','<Hire bot>','-1'),
+('70447','Manage equipment...','-1'),
+('70448','Manage roles...','-1'),
+('70449','Manage formation...','-1'),
+('70450','Manage abilities...','-1'),
+('70451','Manage talents...','-1'),
+('70452','Give consumable...','-1'),
+('70453','<Create group>','-1'),
+('70454','<Create group (all bots)>','-1'),
+('70455','<Add to group>','-1'),
+('70456','<Add all bots to group>','-1'),
+('70457','<Remove from group>','-1'),
+('70458','Follow me','-1'),
+('70459','Hold your position','-1'),
+('70460','Stay here and don\'t do anything','-1'),
+('70461','I need food','-1'),
+('70462','I need water','-1'),
+('70463','I need a refreshment table','-1'),
+('70464','Help me pick a lock','-1'),
+('70465','I need your your healthstone','-1'),
+('70466','I need a soulwell','-1'),
+('70467','I need you to refresh poisons','-1'),
+('70468','<Choose poison (Main Hand)>','-1'),
+('70469','<Choose poison (Offhand)>','-1'),
+('70470','I need you to refresh enchants','-1'),
+('70471','<Choose enchant (Main Hand)>','-1'),
+('70472','<Choose enchant (Offhand)>','-1'),
+('70473','I need you to remove shapeshift','-1'),
+('70474','<Choose pet type>','-1'),
+('70475','You are dismissed','-1'),
+('70476','Are you going to abandon ','-1'),
+('70477','You may regret it...','-1'),
+('70478','Pull yourself together, damnit','-1'),
+('70479','<Study the creature>','-1'),
+('70480','Nevermind','-1'),
+('70481','dist','-1'),
+('70482','BACK','-1'),
+('70483','<Auto>','-1'),
+('70484','<None>','-1'),
+('70485','Random (Cunning)','-1'),
+('70486','Random (Ferocity)','-1'),
+('70487','Random (Tenacity)','-1'),
+('70488','Show me your inventory','-1'),
+('70489','Auto-equip...','-1'),
+('70490','Main hand','-1'),
+('70491','Off-hand','-1'),
+('70492','Ranged','-1'),
+('70493','Relic','-1'),
+('70494','Head','-1'),
+('70495','Shoulders','-1'),
+('70496','Chest','-1'),
+('70497','Waist','-1'),
+('70498','Legs','-1'),
+('70499','Feet','-1'),
+('70500','Wrist','-1'),
+('70501','Hands','-1'),
+('70502','Back','-1'),
+('70503','Shirt','-1'),
+('70504','Finger1','-1'),
+('70505','Finger2','-1'),
+('70506','Trinket1','-1'),
+('70507','Trinket2','-1'),
+('70508','Neck','-1'),
+('70509','Unequip all','-1'),
+('70510','Update visual','-1'),
+('70511','visual only','-1'),
+('70512','Equipped','-1'),
+('70513','nothing','-1'),
+('70514','Use your old equipment','-1'),
+('70515','Unequip it','-1'),
+('70516','Hm... I have nothing to give you','-1'),
+('70517','Gathering','-1'),
+('70518','Abilities status','-1'),
+('70519','Manage allowed abilities','-1'),
+('70520','Use ','-1'),
+('70521','Update','-1'),
+('70522','Damage','-1'),
+('70523','Control','-1'),
+('70524','Heal','-1'),
+('70525','Other','-1'),
+('70526',' makes a grinding sound and begins to follow ','-1'),
+('70527','%s will not join you until dismissed by the owner','-1'),
+('70528','%s will not join you until you are level 60','-1'),
+('70529','%s will not join you until you are level 55','-1'),
+('70530','%s will not join you until you are level 40','-1'),
+('70531','%s will not join you until you are level 20','-1'),
+('70532','You exceed max npcbots (%u)','-1'),
+('70533','You don\'t have enough money','-1'),
+('70534','You cannot have more bots of that class! %u of %u','-1'),
+('70535','Cannot reset equipment in slot %u (%s)! Cannot dismiss bot!','-1'),
+('70536','current','-1'),
+('70537','Attack distance','-1'),
+('70538','Short range attacks','-1'),
+('70539','Long range attacks','-1'),
+('70540','Exact','-1'),
+('70541','Remove buff','-1'),
+('70542','Fix your power type','-1'),
+('70543','Cannot unequip %s for some stupid reason! Sending through mail','-1'),
+('70544','Tank','-1'),
+('70545','Ranged','-1'),
+('70546','Miner','-1'),
+('70547','Herbalist','-1'),
+('70548','Skinner','-1'),
+('70549','Engineer','-1'),
+('70550','Bot ownership expired due to inactivity','-1'),
+('70551','NpcBot system is currently disabled. Please contact administration.','-1'),
+('70552','%s will not join you, already has master: %s','-1'),
+('70553','%s cannot join you while about to teleport','-1'),
+('70554','Aspect','-1'),
+('70555','Monkey','-1'),
+('70556','Hawk','-1'),
+('70557','Cheetah','-1'),
+('70558','Viper','-1'),
+('70559','Beast','-1'),
+('70560','Pack','-1'),
+('70561','Wild','-1'),
+('70562','Dragonhawk','-1'),
+('70563','No Aspect','-1'),
+('70564','Aura','-1'),
+('70565','Devotion','-1'),
+('70566','Concentration','-1'),
+('70567','Fire Resistance','-1'),
+('70568','Frost Resistance','-1'),
+('70569','Shadow Resistance','-1'),
+('70570','Retribution','-1'),
+('70571','Crusader','-1'),
+('70572','No Aura','-1'),
+('70573','Crippling','-1'),
+('70574','Instant','-1'),
+('70575','Deadly','-1'),
+('70576','Wound','-1'),
+('70577','Mind-Numbing','-1'),
+('70578','Anesthetic','-1'),
+('70579','Nothing','-1'),
+('70580','Flametongue','-1'),
+('70581','Frostbrand','-1'),
+('70582','Windfury','-1'),
+('70583','Earthliving','-1'),
+('70584','I need your services','-1'),
+('70585','You have too many bots','-1'),
+('70586','Do you wish to hire ','-1'),
+('70587',' is a bit busy at the moment, try again later.','-1'),
+('70588','Pleasure doing business with you','-1'),
+('70589','Warriors','-1'),
+('70590','Paladins','-1'),
+('70591','Mages','-1'),
+('70592','Priests','-1'),
+('70593','Warlocks','-1'),
+('70594','Druids','-1'),
+('70595','Death Knights','-1'),
+('70596','Rogues','-1'),
+('70597','Shamans','-1'),
+('70598','Hunters','-1'),
+('70599','Blademasters','-1'),
+('70600','Destroyers','-1'),
+('70601','Archmagi','-1'),
+('70602','Dreadlords','-1'),
+('70603','Spell Breakers','-1'),
+('70604','Dark Rangers','-1'),
+('70605','Warrior','-1'),
+('70606','Paladin','-1'),
+('70607','Mage','-1'),
+('70608','Priest','-1'),
+('70609','Warlock','-1'),
+('70610','Druid','-1'),
+('70611','Death Knight','-1'),
+('70612','Rogue','-1'),
+('70613','Shaman','-1'),
+('70614','Hunter','-1'),
+('70615','Blademaster','-1'),
+('70616','Destroyer','-1'),
+('70617','Archmage','-1'),
+('70618','Dreadlord','-1'),
+('70619','Spell Breaker','-1'),
+('70620','Dark Ranger','-1');
diff --git a/sql/Bots/updates/world/2020_12_11_npc_text.sql b/sql/Bots/updates/world/2020_12_11_npc_text.sql
new file mode 100644
index 000000000..f9c08b521
--- /dev/null
+++ b/sql/Bots/updates/world/2020_12_11_npc_text.sql
@@ -0,0 +1,4 @@
+--
+DELETE FROM `npc_text` WHERE ID = 70550;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70550','Bot ownership expired','-1');
diff --git a/sql/Bots/updates/world/2021_01_04_npc_text.sql b/sql/Bots/updates/world/2021_01_04_npc_text.sql
new file mode 100644
index 000000000..75681a46c
--- /dev/null
+++ b/sql/Bots/updates/world/2021_01_04_npc_text.sql
@@ -0,0 +1,19 @@
+--
+SET @LOCALIZED_STRINGS_START = 70621;
+SET @LOCALIZED_STRINGS_END   = 70633;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70621','Male','-1'),
+('70622','Female','-1'),
+('70623','Human','-1'),
+('70624','Orc','-1'),
+('70625','Dwarf','-1'),
+('70626','Night Elf','-1'),
+('70627','Undead','-1'),
+('70628','Tauren','-1'),
+('70629','Gnome','-1'),
+('70630','Troll','-1'),
+('70631','Blood Elf','-1'),
+('70632','Draenei','-1'),
+('70633','Unknown','-1');
diff --git a/sql/Bots/updates/world/2021_01_05_npc_text.sql b/sql/Bots/updates/world/2021_01_05_npc_text.sql
new file mode 100644
index 000000000..26352ce0a
--- /dev/null
+++ b/sql/Bots/updates/world/2021_01_05_npc_text.sql
@@ -0,0 +1,13 @@
+--
+SET @LOCALIZED_STRINGS_START = 70634;
+SET @LOCALIZED_STRINGS_END   = 70640;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70634','Looting','-1'),
+('70635','|cff9d9d9dPoor|r','-1'),
+('70636','|cffffffffCommon|r','-1'),
+('70637','|cff1eff00Uncommon|r','-1'),
+('70638','|cff0070ddRare|r','-1'),
+('70639','|cffa335eeEpic|r','-1'),
+('70640','|cffff8000Legendary|r','-1');
diff --git a/sql/Bots/updates/world/2021_01_08_npc_text.sql b/sql/Bots/updates/world/2021_01_08_npc_text.sql
new file mode 100644
index 000000000..6f8781ecd
--- /dev/null
+++ b/sql/Bots/updates/world/2021_01_08_npc_text.sql
@@ -0,0 +1,9 @@
+--
+SET @LOCALIZED_STRINGS_START = 70641;
+SET @LOCALIZED_STRINGS_END   = 70643;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70641','Grab on ','-1'),
+('70642','my ','-1'),
+('70643','<Exit Vehicle>','-1');
diff --git a/sql/Bots/updates/world/2021_02_01_npc_text.sql b/sql/Bots/updates/world/2021_02_01_npc_text.sql
new file mode 100644
index 000000000..b1a2de0ce
--- /dev/null
+++ b/sql/Bots/updates/world/2021_02_01_npc_text.sql
@@ -0,0 +1,2 @@
+--
+UPDATE `npc_text` SET `text0_0`='Auto-equip' WHERE (`ID`='70489');
diff --git a/sql/Bots/updates/world/2021_03_29_npc_text.sql b/sql/Bots/updates/world/2021_03_29_npc_text.sql
new file mode 100644
index 000000000..d198943eb
--- /dev/null
+++ b/sql/Bots/updates/world/2021_03_29_npc_text.sql
@@ -0,0 +1,10 @@
+--
+SET @LOCALIZED_STRINGS_START = 70641;
+SET @LOCALIZED_STRINGS_END   = 70644;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70641','Engage behavior','-1'),
+('70642','Delay attack by','-1'),
+('70643','Delay healing by','-1'),
+('70644','s','-1');
diff --git a/sql/Bots/updates/world/2021_08_20_creature_template_npcbot_extras.sql b/sql/Bots/updates/world/2021_08_20_creature_template_npcbot_extras.sql
new file mode 100644
index 000000000..e6d28d4d2
--- /dev/null
+++ b/sql/Bots/updates/world/2021_08_20_creature_template_npcbot_extras.sql
@@ -0,0 +1,2 @@
+-- Kerra race fix
+UPDATE `creature_template_npcbot_extras` SET `race`='10' WHERE (`entry`='70038');
diff --git a/sql/Bots/updates/world/2021_08_27_npc_text.sql b/sql/Bots/updates/world/2021_08_27_npc_text.sql
new file mode 100644
index 000000000..7835ea5a8
--- /dev/null
+++ b/sql/Bots/updates/world/2021_08_27_npc_text.sql
@@ -0,0 +1,4 @@
+--
+DELETE FROM `npc_text` WHERE ID = 70645;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70645','Off-Tank','-1');
diff --git a/sql/Bots/updates/world/2021_10_12_creature_template.sql b/sql/Bots/updates/world/2021_10_12_creature_template.sql
new file mode 100644
index 000000000..29f14641a
--- /dev/null
+++ b/sql/Bots/updates/world/2021_10_12_creature_template.sql
@@ -0,0 +1,8 @@
+--
+SET @BOT_START = 70001;
+SET @BOT_END   = 71000;
+
+SET @U2_MIRROR_IMAGE		  = 16;    -- 0x00000010 - UNIT_FLAG2_MIRROR_IMAGE
+SET @U2_ENABLE_ENEMY_INTERACT = 16384; -- 0x00004000 - UNIT_FLAG2_ALLOW_ENEMY_INTERACT
+
+UPDATE `creature_template` SET `unit_flags2` = `unit_flags2`&~(@U2_MIRROR_IMAGE|@U2_ENABLE_ENEMY_INTERACT) WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
diff --git a/sql/Bots/updates/world/2022_01_02_00_creature_template_npcbot_extras.sql b/sql/Bots/updates/world/2022_01_02_00_creature_template_npcbot_extras.sql
new file mode 100644
index 000000000..d5f02d0b6
--- /dev/null
+++ b/sql/Bots/updates/world/2022_01_02_00_creature_template_npcbot_extras.sql
@@ -0,0 +1,12 @@
+--
+SET @BOT_START = 70575;
+SET @BOT_END   = 70580;
+
+DELETE FROM `creature_template_npcbot_extras` WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
+INSERT INTO `creature_template_npcbot_extras` (`entry`,`class`,`race`) VALUES
+('70575', '18', '1'),
+('70576', '18', '1'),
+('70577', '18', '1'),
+('70578', '18', '1'),
+('70579', '18', '1'),
+('70580', '0', '15');
diff --git a/sql/Bots/updates/world/2022_01_02_01_generate_equips_necromancer.sql b/sql/Bots/updates/world/2022_01_02_01_generate_equips_necromancer.sql
new file mode 100644
index 000000000..6fe25bd2f
--- /dev/null
+++ b/sql/Bots/updates/world/2022_01_02_01_generate_equips_necromancer.sql
@@ -0,0 +1,57 @@
+/*!50003 DROP PROCEDURE IF EXISTS `sp__generate_necromancer_equips`*/;
+
+DELIMITER ;;
+
+/*!50003 CREATE*/
+/*!50003 PROCEDURE `sp__generate_necromancer_equips`()
+BEGIN
+
+DECLARE CLASS_NECROMANCER INT DEFAULT 18;
+
+DECLARE NPCBOT_ENTRY_BEGIN INT DEFAULT 70575;
+DECLARE NPCBOT_ENTRY_END INT DEFAULT 71000;
+
+DECLARE NPCBOT_ENTRY_PET_NECROSKELETON INT DEFAULT 70580;
+
+DECLARE cur_pos INT DEFAULT 0;
+DECLARE myclass INT;
+DECLARE myrace INT;
+DECLARE item1 INT DEFAULT 0;
+DECLARE item2 INT DEFAULT 0;
+DECLARE item3 INT DEFAULT 0;
+
+DELETE FROM `creature_equip_template` WHERE `CreatureID` BETWEEN NPCBOT_ENTRY_BEGIN AND NPCBOT_ENTRY_END;
+
+SET cur_pos = NPCBOT_ENTRY_BEGIN;
+WHILE cur_pos < NPCBOT_ENTRY_END DO
+    SET myclass = (SELECT `class` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+    SET myrace = (SELECT `race` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+
+    IF myclass != 0 AND myrace != 0 THEN
+
+        IF myclass = CLASS_NECROMANCER THEN
+            SET item1 = 13937; -- staff
+        END IF;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    ELSEIF cur_pos = NPCBOT_ENTRY_PET_NECROSKELETON THEN
+        SET item1 = 3935;
+        SET item2 = 15648;
+        SET item3 = 0;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    END IF;
+
+    SET cur_pos = cur_pos + 1;
+
+END WHILE;
+
+END */;;
+
+DELIMITER ;
+
+CALL `sp__generate_necromancer_equips`();
+
+DROP PROCEDURE IF EXISTS `sp__generate_necromancer_equips`;
diff --git a/sql/Bots/updates/world/2022_01_02_02_creature_template.sql b/sql/Bots/updates/world/2022_01_02_02_creature_template.sql
new file mode 100644
index 000000000..3f3327f5b
--- /dev/null
+++ b/sql/Bots/updates/world/2022_01_02_02_creature_template.sql
@@ -0,0 +1,21 @@
+--
+SET @BOT_START = 70575;
+SET @BOT_END   = 70580;
+
+DELETE FROM `creature_template` WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
+
+INSERT INTO `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,
+`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,
+`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`type`,`type_flags`,`lootid`,
+`pickpocketloot`,`skinloot`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,
+`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`RacialLeader`,`movementId`,`RegenHealth`,
+`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`)
+VALUES
+('70575','0','0','0','0','0','23277','0','0','0','Prakar','Necromancer Bot','','0','82','82','2','35','1','1.1','1.1','1','1','0','1800','1800','9','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','necromancer_bot','-1'),
+('70576','0','0','0','0','0','23277','0','0','0','Rothik','Necromancer Bot','','0','82','82','2','35','1','1.1','1.1','1','1','0','1800','1800','9','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','necromancer_bot','-1'),
+('70577','0','0','0','0','0','23277','0','0','0','Hexir','Necromancer Bot','','0','82','82','2','35','1','1.1','1.1','1','1','0','1800','1800','9','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','necromancer_bot','-1'),
+('70578','0','0','0','0','0','23277','0','0','0','Fikhar','Necromancer Bot','','0','82','82','2','35','1','1.1','1.1','1','1','0','1800','1800','9','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','necromancer_bot','-1'),
+('70579','0','0','0','0','0','23277','0','0','0','Drothum','Necromancer Bot','','0','82','82','2','35','1','1.1','1.1','1','1','0','1800','1800','9','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','68157552','necromancer_bot','-1'),
+('70580','0','0','0','0','0','200','0','0','0','Skeleton',NULL,'','0','82','82','2','35','0','1.2','1.3','1.1','0','0','2000','2000','1','0','0','0','0','6','4096','0','0','0','0','0','0','0','','0','1','1','1','1','0','0','0','0','135266400','necromancer_pet_bot','-1');
diff --git a/sql/Bots/updates/world/2022_01_02_03_npc_text.sql b/sql/Bots/updates/world/2022_01_02_03_npc_text.sql
new file mode 100644
index 000000000..28fb9d0ab
--- /dev/null
+++ b/sql/Bots/updates/world/2022_01_02_03_npc_text.sql
@@ -0,0 +1,15 @@
+--
+SET @LOCALIZED_STRINGS_START = 70107;
+SET @LOCALIZED_STRINGS_END   = 70107;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70107','|cff9900ccNecromancer|r$b|cffdd6600-=Warcraft III / Diablo II tribute=-|r$B$BSpell damage taken reduced by 20%, partially immune to control effects, cloth armor, deals spellshadow damage, no physical attack, spell power bonus: 100% intellect. Main attribute: Intellect.$B$BRaise Dead. Raises 2 Skeletons from a corpse (maximum 6 Skeletons, 65 seconds duration, only works on humanoids, beasts and dragonkin).$B$BUnholy Frenzy. Increases target\'s melee attack speed by 75%, but constantly drains health. Lasts 45 seconds. Cannot be cancelled. Unlocked at level 30.$B$BCorpse Explosion. Causes a corpse to explode, dealing damage equal to 35% to 75% of dead unit\'s maximum health (depends on Necromancer\'s level) to all surrounding enemies. This damage generates no threat. Unlocked at level 40.$B$BCripple. Reduces target\'s movement speed, melee attack speed and total strength by 50% for 60 seconds. Unlocked at level 50.','-1');
+
+SET @LOCALIZED_STRINGS_START = 70646;
+SET @LOCALIZED_STRINGS_END   = 70647;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70646','Necromancers','-1'),
+('70647','Necromancer','-1');
diff --git a/sql/Bots/updates/world/2022_01_31_npc_text.sql b/sql/Bots/updates/world/2022_01_31_npc_text.sql
new file mode 100644
index 000000000..c33bf5d74
--- /dev/null
+++ b/sql/Bots/updates/world/2022_01_31_npc_text.sql
@@ -0,0 +1,10 @@
+--
+
+SET @LOCALIZED_STRINGS_START = 70648;
+SET @LOCALIZED_STRINGS_END   = 70650;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70648','Attack angle','-1'),
+('70649','Normal','-1'),
+('70650','Avoid frontal AOE','-1');
diff --git a/sql/Bots/updates/world/2022_06_15_00_creature_template_npcbot_extras.sql b/sql/Bots/updates/world/2022_06_15_00_creature_template_npcbot_extras.sql
new file mode 100644
index 000000000..12b9362cc
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_15_00_creature_template_npcbot_extras.sql
@@ -0,0 +1,2 @@
+-- Maldryn race fix
+UPDATE `creature_template_npcbot_extras` SET `race`='4' WHERE (`entry`='70413');
diff --git a/sql/Bots/updates/world/2022_06_17_npc_text.sql b/sql/Bots/updates/world/2022_06_17_npc_text.sql
new file mode 100644
index 000000000..4e8ebf0b9
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_17_npc_text.sql
@@ -0,0 +1,3 @@
+--
+
+UPDATE `npc_text` SET `text0_0`='|cff9900ccObsidian Destroyer|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An obsidian winged monstrocity with insatiable hunger for magic\".$B$BHigh armor, very high resistances, partially immune to magic, loses mana over time and doesn\'t benefit from passive mana regeneration effects, mail/plate armor, dual-wielding wands, deals spellshadow damage, no physical attack, cannot attack enemies not in front while moving, spell power bonus: 50% attack power + 200% intellect + wands damage.$B$BDevour Magic. Dispels up to 2 magic effects from enemies, up to 2 magic effects and up to 2 curses from allies and damaging summoned units in 20 yards area. Every dispelled effect restores 20% mana and 5% health, 7 seconds cooldown.$B$BShadow Blast. Empowered attack that deals increased splash damage.$B$BDrain Mana. Drains all mana (limited by caster\'s mana pool) from a random friendly unit.$B$BReplenish Mana. Energizes surrounding party and raid members within 25 yards for 3% of their maximum mana nullifying caster\'s mana, 3 seconds cooldown.$B$BRegenerating Aura. Heals surrounding party and raid members within 25 yards for 3% of their maximum health nullifying caster\'s mana, 3 seconds cooldown.$B$BShadow Armor (passive). Restores mana equal to a percentage of damage taken.$B$B' WHERE (`ID`='70102');
diff --git a/sql/Bots/updates/world/2022_06_22_00_creature_template_npcbot_extras.sql b/sql/Bots/updates/world/2022_06_22_00_creature_template_npcbot_extras.sql
new file mode 100644
index 000000000..8dc2d4ba8
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_22_00_creature_template_npcbot_extras.sql
@@ -0,0 +1,11 @@
+--
+SET @BOT_START = 70581;
+SET @BOT_END   = 70585;
+
+DELETE FROM `creature_template_npcbot_extras` WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
+INSERT INTO `creature_template_npcbot_extras` (`entry`,`class`,`race`) VALUES
+('70581', '19', '13'),
+('70582', '19', '13'),
+('70583', '19', '13'),
+('70584', '19', '13'),
+('70585', '19', '13');
diff --git a/sql/Bots/updates/world/2022_06_22_01_generate_equips_sea_witch.sql b/sql/Bots/updates/world/2022_06_22_01_generate_equips_sea_witch.sql
new file mode 100644
index 000000000..766a70b40
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_22_01_generate_equips_sea_witch.sql
@@ -0,0 +1,50 @@
+/*!50003 DROP PROCEDURE IF EXISTS `sp__generate_seawitch_equips`*/;
+
+DELIMITER ;;
+
+/*!50003 CREATE*/
+/*!50003 PROCEDURE `sp__generate_seawitch_equips`()
+BEGIN
+
+DECLARE CLASS_SEA_WITCH INT DEFAULT 19;
+
+DECLARE NPCBOT_ENTRY_BEGIN INT DEFAULT 70581;
+DECLARE NPCBOT_ENTRY_END INT DEFAULT 70585;
+
+DECLARE cur_pos INT DEFAULT 0;
+DECLARE myclass INT;
+DECLARE myrace INT;
+DECLARE item1 INT DEFAULT 0;
+DECLARE item2 INT DEFAULT 0;
+DECLARE item3 INT DEFAULT 0;
+
+DELETE FROM `creature_equip_template` WHERE `CreatureID` BETWEEN NPCBOT_ENTRY_BEGIN AND NPCBOT_ENTRY_END;
+
+SET cur_pos = NPCBOT_ENTRY_BEGIN;
+WHILE cur_pos <= NPCBOT_ENTRY_END DO
+    SET myclass = (SELECT `class` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+    SET myrace = (SELECT `race` FROM `creature_template_npcbot_extras` WHERE `entry` = cur_pos);
+
+    IF myclass != 0 AND myrace != 0 THEN
+
+        IF myclass = CLASS_SEA_WITCH THEN
+            SET item1 = 20852; -- dagger
+            SET item2 = 20852; -- dagger
+            SET item3 = 17069; -- bow
+        END IF;
+
+        INSERT INTO `creature_equip_template` (`CreatureID`,`ID`,`itemID1`,`itemID2`,`itemID3`,`VerifiedBuild`) VALUES (cur_pos,1,item1,item2,item3,-1);
+
+    END IF;
+
+    SET cur_pos = cur_pos + 1;
+
+END WHILE;
+
+END */;;
+
+DELIMITER ;
+
+CALL `sp__generate_seawitch_equips`();
+
+DROP PROCEDURE IF EXISTS `sp__generate_seawitch_equips`;
diff --git a/sql/Bots/updates/world/2022_06_22_02_creature_template.sql b/sql/Bots/updates/world/2022_06_22_02_creature_template.sql
new file mode 100644
index 000000000..99477625f
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_22_02_creature_template.sql
@@ -0,0 +1,21 @@
+--
+SET @BOT_START = 70581;
+SET @BOT_END   = 70586;
+
+DELETE FROM `creature_template` WHERE `entry` BETWEEN @BOT_START AND @BOT_END;
+
+INSERT INTO `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,
+`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`dmgschool`,`BaseAttackTime`,`RangeAttackTime`,
+`BaseVariance`,`RangeVariance`,`unit_class`,`unit_flags`,`unit_flags2`,`dynamicflags`,`family`,`type`,`type_flags`,`lootid`,
+`pickpocketloot`,`skinloot`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,
+`HoverHeight`,`HealthModifier`,`ManaModifier`,`ArmorModifier`,`DamageModifier`,`ExperienceModifier`,`RacialLeader`,`movementId`,`RegenHealth`,
+`mechanic_immune_mask`,`spell_school_immune_mask`,`flags_extra`,`ScriptName`,`VerifiedBuild`)
+VALUES
+('70581','0','0','0','0','0','20748','0','0','0','Kondra','Sea Witch Bot','','0','83','83','2','35','1','1.05','1.05','0.5','2','0','1900','1900','1','1','8','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','1','1','0','0','0','0','0','68157552','sea_witch_bot','-1'),
+('70582','0','0','0','0','0','20748','0','0','0','Serpentra','Sea Witch Bot','','0','83','83','2','35','1','1.05','1.05','0.5','2','0','1900','1900','1','1','8','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','1','1','0','0','0','0','0','68157552','sea_witch_bot','-1'),
+('70583','0','0','0','0','0','20748','0','0','0','Serena','Sea Witch Bot','','0','83','83','2','35','1','1.05','1.05','0.5','2','0','1900','1900','1','1','8','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','1','1','0','0','0','0','0','68157552','sea_witch_bot','-1'),
+('70584','0','0','0','0','0','20748','0','0','0','Asprah','Sea Witch Bot','','0','83','83','2','35','1','1.05','1.05','0.5','2','0','1900','1900','1','1','8','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','1','1','0','0','0','0','0','68157552','sea_witch_bot','-1'),
+('70585','0','0','0','0','0','20748','0','0','0','Charib\'dishal','Sea Witch Bot','','0','83','83','2','35','1','1.05','1.05','0.5','2','0','1900','1900','1','1','8','0','32','0','0','7','4096','0','0','0','0','0','0','0','','0','1','1','1','1','1','1','0','0','0','0','0','68157552','sea_witch_bot','-1'),
+('70586','0','0','0','0','0','20211','0','0','0','Tornado','','','0','83','83','2','35','0','0.9','0.9','3','1','0','2000','2000','1','1','1','33554432','32768','0','0','4','33554432','0','0','0','0','0','0','0','','0','1','1','1','1','1','1','0','0','0','0','0','671096832','sea_witch_pet_bot','-1');
diff --git a/sql/Bots/updates/world/2022_06_22_03_npc_text.sql b/sql/Bots/updates/world/2022_06_22_03_npc_text.sql
new file mode 100644
index 000000000..b10c1c9cd
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_22_03_npc_text.sql
@@ -0,0 +1,26 @@
+--
+SET @LOCALIZED_STRINGS_START = 70010;
+SET @LOCALIZED_STRINGS_END   = 70011;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70010','<You see an emaciated naga matron. She looks tired and weak, and avoids looking at you.>$B$BS-s-s-spare the words, mortal...','-1'),
+('70011','Did I mess-s-s-s up my hair again? <She brushes her \"hair\">$B...No, I didn\'t. Then what is it?','-1');
+
+SET @LOCALIZED_STRINGS_START = 70108;
+SET @LOCALIZED_STRINGS_END   = 70108;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70108','|cff0000ddSea Witch|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B"A vicious scaly denizen of ocean often associated with the coming of prodigious storms".$B$BSpell damage taken reduced by 30%, partially immune to control effects, cloth armor, deals physical/spellfrost/spellstorm damage, attack power bonus: agility x2, spell power bonus: 200% intellect. Main attribute: Intellect.$B$BForked Lightning. Calls forth a cone of lightning to damage enemies. Hits from 2 to all targets (depending on Sea Witch\'s level), stunning them for 2 seconds. This damage generates no threat.$B$BFrost Arrows. Imbues arrow with spellfrost for extra damage, slowing target\'s movement, attack and casting speed by 30% to 70% (depending on Sea Witch\'s level).$B$BMana Shield. Creates a shield that absorbs 100% incoming (non-mitigated) damage by using Sea Witch\'s mana. Absorbs 2 to 10 damage per point of mana (depending on Sea Witch\'s level).$B$BTornado. Summons a fierce tornado that damages and slows nearby enemy units, sometimes incapacitating them completely. Tornado grows over time oudoors, increasing damage dealt and area of effect, but shrinks indoors, dissipating quickly. Unlocked at level 60.$B$BNaga (Passive). Swim speed increased by 200%, damage and dodge chance are greatly increased while in water.','-1');
+
+SET @LOCALIZED_STRINGS_START = 70651;
+SET @LOCALIZED_STRINGS_END   = 70655;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70651','NIY','-1'),
+('70652','Are you sure this is gonna work? It\'s better be the best water in the world...','-1'),
+('70653','Seems like you could really use a drink of fresh water.','-1'),
+('70654','Sea Witches','-1'),
+('70655','Sea Witch','-1');
diff --git a/sql/Bots/updates/world/2022_06_23_00_command.sql b/sql/Bots/updates/world/2022_06_23_00_command.sql
new file mode 100644
index 000000000..559db7f78
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_23_00_command.sql
@@ -0,0 +1,39 @@
+--
+DELETE FROM `command` WHERE `name` LIKE 'npcbot %';
+INSERT INTO `command` (`name`) VALUES
+('npcbot add'),
+('npcbot command'),
+('npcbot command follow'),
+('npcbot command standstill'),
+('npcbot command stopfully'),
+('npcbot delete'),
+('npcbot distance'),
+('npcbot distance attack'),
+('npcbot distance attack long'),
+('npcbot distance attack short'),
+('npcbot dump'),
+('npcbot dump load'),
+('npcbot dump write'),
+('npcbot hide'),
+('npcbot info'),
+('npcbot kill'),
+('npcbot lookup'),
+('npcbot move'),
+('npcbot order'),
+('npcbot order cast'),
+('npcbot recall'),
+('npcbot recall teleport'),
+('npcbot reloadconfig'),
+('npcbot remove'),
+('npcbot revive'),
+('npcbot set'),
+('npcbot set faction'),
+('npcbot set owner'),
+('npcbot set spec'),
+('npcbot show'),
+('npcbot spawn'),
+('npcbot spawned'),
+('npcbot suicide'),
+('npcbot unhide'),
+('npcbot vehicle'),
+('npcbot vehicle eject');
diff --git a/sql/Bots/updates/world/2022_06_24_00_npc_text.sql b/sql/Bots/updates/world/2022_06_24_00_npc_text.sql
new file mode 100644
index 000000000..d0142c2e0
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_24_00_npc_text.sql
@@ -0,0 +1,7 @@
+--
+SET @LOCALIZED_STRINGS_START = 70108;
+SET @LOCALIZED_STRINGS_END   = 70108;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70108','|cff0000ddSea Witch|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B"A vicious scaly denizen of ocean often associated with the coming of prodigious storms".$B$BSpell damage taken reduced by 30%, partially immune to control effects, cloth armor, deals physical/spellfrost/spellstorm damage, attack power bonus: agility x2, spell power bonus: 200% intellect. Main attribute: Intellect.$B$BForked Lightning. Calls forth a cone of lightning to damage enemies. Hits from 2 to all targets (depending on Sea Witch\'s level), stunning them for 2 seconds. This damage generates no threat.$B$BFrost Arrows. Imbues arrow with spellfrost for extra damage, slowing target\'s movement, attack and casting speed by 30% to 70% (depending on Sea Witch\'s level).$B$BMana Shield. Creates a shield that absorbs 100% incoming (non-mitigated) damage by using Sea Witch\'s mana. Effect ranges from 1 damage per 10 mana to 10 damage per 1 mana (depending on Sea Witch\'s level).$B$BTornado. Summons a fierce tornado that damages and slows nearby enemy units, sometimes incapacitating them completely. Tornado grows over time oudoors, increasing damage dealt and area of effect, but shrinks indoors, dissipating quickly. Unlocked at level 60.$B$BNaga (Passive). Swim speed increased by 200%, damage and dodge chance are greatly increased while in water.','-1');
diff --git a/sql/Bots/updates/world/2022_06_24_01_npc_text.sql b/sql/Bots/updates/world/2022_06_24_01_npc_text.sql
new file mode 100644
index 000000000..7fd7be96a
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_24_01_npc_text.sql
@@ -0,0 +1,8 @@
+--
+SET @LOCALIZED_STRINGS_START = 70656;
+SET @LOCALIZED_STRINGS_END   = 70657;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+('70656','Mana per damage','-1'),
+('70657','Damage per mana','-1');
diff --git a/sql/Bots/updates/world/2022_06_24_02_command.sql b/sql/Bots/updates/world/2022_06_24_02_command.sql
new file mode 100644
index 000000000..33e5d791d
--- /dev/null
+++ b/sql/Bots/updates/world/2022_06_24_02_command.sql
@@ -0,0 +1,4 @@
+--
+DELETE FROM `command` WHERE `name`='npcbot command walk';
+INSERT INTO `command` (`name`) VALUES
+('npcbot command walk');
diff --git a/sql/Bots/updates/world/2022_07_04_00_command.sql b/sql/Bots/updates/world/2022_07_04_00_command.sql
new file mode 100644
index 000000000..eef20dd21
--- /dev/null
+++ b/sql/Bots/updates/world/2022_07_04_00_command.sql
@@ -0,0 +1,4 @@
+--
+DELETE FROM `command` WHERE `name`='npcbot createnew';
+INSERT INTO `command` (`name`) VALUES
+('npcbot createnew');
diff --git a/sql/Bots/updates/world/2022_07_25_00_npc_text.sql b/sql/Bots/updates/world/2022_07_25_00_npc_text.sql
new file mode 100644
index 000000000..9eee94a9d
--- /dev/null
+++ b/sql/Bots/updates/world/2022_07_25_00_npc_text.sql
@@ -0,0 +1,7 @@
+--
+UPDATE `npc_text` SET `text0_0`='|cff0000ddArchmage|r$b|cffdd6600-=Warcraft III tribute=-|r$B$BSpell damage taken reduced by 35%, partially immune to control effects, cloth armor, deals spellsfire/spellfrost damage, no physical attack, spell power bonus: 100% intellect. Main attribute: Intellect.$B$BBlizzard. Your typical blizzard, just a little more powerful, 6 seconds cooldown.$B$BSummon Water Elemental. Summons a water elemental to attack archmage\'s enemies for 1 min, 20 seconds cooldown.$B$BBrilliance Aura. Increases maximum mana by 10% and greatly increases mana regeneration of party and raid members within 40 yards.$B$BMass Teleport. NIY.$B$B' WHERE (`ID`='70103');
+UPDATE `npc_text` SET `text0_0`='|cff9900ccDreadlord|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"Incredibly powerful demon who wields power of darkness and mental domination\".$B$BHigh armor, high resistances, partially immune to control effects, damage taken speeds up spells recharge, plate armor, deals melee/spellshadow damage, bonus damage against incapacitated targets, spell power bonus: 200% strength. Main attribute: Strength.$B$BCarrion Swarm. Sends a horde of bats combined with chaotic magic to damage enemies in a very large frontal cone, cannot crit, 10 seconds cooldown.$B$BSleep. Puts the enemy target to sleep for 60 seconds and allows next physical attack on that target to bypass armor, direct damage caused will awaken the target, 6 seconds cooldown.$B$BVampiric Aura. Increases physical critical damage by 5% and heals party and raid members within 40 yards for a percentage (100% for Dreadlord and 25% for everyone else) of damage done by melee physical attacks and Carrion Swarm, no threat.$B$BSummon Infernal Servant. Calls an infernal down from the sky dealing damage and stunning enemy units, infernal is very resistant to magic and lasts 180 seconds, 180 seconds cooldown.$B$B' WHERE (`ID`='70104');
+UPDATE `npc_text` SET `text0_0`='|cff0000ddSpell Breaker|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"An elven warrior trained to disrupt and contort magical energies\".$B$BSpell damage taken reduced by 75%, partially immune to control effects, armor penalty -30%, mail/plate armor, deals melee/arcane damage, spell power bonus: 200% strength. Main attribute: Strength.$B$BSteal Magic (Spellsteal). Steals a benefical spell from an enemy and applies it to a nearby ally or removes a negative spell from an ally and applies it to a nearby enemy, affects magic and curse effects, 2 seconds cooldown.$B$BFeedback (passive). Successful melee attacks burn target\'s mana equal to damage caused (increased by spellpower) dealing arcane damage. If target\'s mana is depleted, Spell Breaker\'s melee attacks will do triple damage with increased critical strike chance. If target does not have mana, Spell Breaker will gain mana equal to 25% of damage dealt.$B$B' WHERE (`ID`='70105');
+UPDATE `npc_text` SET `text0_0`='|cff9900ccDark Ranger|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"A former ranger of Quel\'thalas forcibly raised from the dead\".$B$BSpell damage taken reduced by 35%, undead, partially immune to control effects, leather/cloth armor, deals physical/spellshadow damage, stick to shadows and generates no threat, spell power bonus: 50% intellect. Main attribute: Agility.$B$BSilence. Silences an enemy and up to 4 nearby targets for 8 seconds, 15 seconds cooldown.$B$BBlack Arrow. Fires a cursed arrow dealing 150% weapon damage and additional spellshadow damage over time. If affected target dies from Dark Ranger\'s damage, Dark Minion will spawn from the corpse (maximum 5 Minions, 80 seconds duration, only works on humanoids, beasts and dragonkin). Deals five times more damage if target is under 20% health.$B$BDrain Life. Drains health from an enemy every second for 5 seconds, healing Dark Ranger for 200% of the drained amount.$B$B' WHERE (`ID`='70106');
+UPDATE `npc_text` SET `text0_0`='|cff9900ccNecromancer|r$b|cffdd6600-=Warcraft III / Diablo II tribute=-|r$B$BSpell damage taken reduced by 20%, partially immune to control effects, cloth armor, deals spellshadow damage, no physical attack, spell power bonus: 100% intellect. Main attribute: Intellect.$B$BRaise Dead. Raises 2 Skeletons from a corpse (maximum 6 Skeletons, 65 seconds duration, only works on humanoids, beasts and dragonkin).$B$BUnholy Frenzy. Increases target\'s melee attack speed by 75%, but constantly drains health. Lasts 45 seconds. Cannot be cancelled. Unlocked at level 30.$B$BCorpse Explosion. Causes a corpse to explode, dealing damage equal to 35% to 75% of dead unit\'s maximum health (depends on Necromancer\'s level) to all surrounding enemies. This damage generates no threat. Unlocked at level 40.$B$BCripple. Reduces target\'s movement speed, melee attack speed and total strength by 50% for 60 seconds. Unlocked at level 50.$B$B' WHERE (`ID`='70107');
+UPDATE `npc_text` SET `text0_0`='|cff0000ddSea Witch|r$b|cffdd6600-=Warcraft III tribute=-|r$B$B\"A vicious scaly denizen of ocean often associated with the coming of prodigious storms\".$B$BSpell damage taken reduced by 30%, partially immune to control effects, cloth armor, deals physical/spellfrost/spellstorm damage, attack power bonus: agility x2, spell power bonus: 200% intellect. Main attribute: Intellect.$B$BForked Lightning. Calls forth a cone of lightning to damage enemies. Hits from 2 to all targets (depending on Sea Witch\'s level), stunning them for 2 seconds. This damage generates no threat.$B$BFrost Arrows. Imbues arrow with spellfrost for extra damage, slowing target\'s movement, attack and casting speed by 30% to 70% (depending on Sea Witch\'s level).$B$BMana Shield. Creates a shield that absorbs 100% incoming (non-mitigated) damage by using Sea Witch\'s mana. Effect ranges from 1 damage per 10 mana to 10 damage per 1 mana (depending on Sea Witch\'s level).$B$BTornado. Summons a fierce tornado that damages and slows nearby enemy units, sometimes incapacitating them completely. Tornado grows over time outdoors, increasing damage dealt and area of effect, but shrinks indoors, dissipating quickly. Unlocked at level 60.$B$BNaga (Passive). Swim speed, damage and dodge chance are greatly increased while in water.$B$B' WHERE (`ID`='70108');
diff --git a/sql/Bots/updates/world/2022_11_15_00_npc_text.sql b/sql/Bots/updates/world/2022_11_15_00_npc_text.sql
new file mode 100644
index 000000000..9385da803
--- /dev/null
+++ b/sql/Bots/updates/world/2022_11_15_00_npc_text.sql
@@ -0,0 +1,7 @@
+--
+SET @LOCALIZED_STRINGS_START = 70658;
+SET @LOCALIZED_STRINGS_END   = 70658;
+
+DELETE FROM `npc_text` WHERE ID BETWEEN @LOCALIZED_STRINGS_START and @LOCALIZED_STRINGS_END;
+INSERT INTO `npc_text` (`ID`,`text0_0`) VALUES
+('70658','Transmogrification...');
diff --git a/sql/Bots/updates/world/2022_11_30_00_command.sql b/sql/Bots/updates/world/2022_11_30_00_command.sql
new file mode 100644
index 000000000..774534e3f
--- /dev/null
+++ b/sql/Bots/updates/world/2022_11_30_00_command.sql
@@ -0,0 +1,4 @@
+--
+DELETE FROM `command` WHERE `name`='npcbot sendto';
+INSERT INTO `command` (`name`) VALUES
+('npcbot sendto');
diff --git a/sql/Bots/updates/world/2022_12_08_00_npc_text.sql b/sql/Bots/updates/world/2022_12_08_00_npc_text.sql
new file mode 100644
index 000000000..9448118b9
--- /dev/null
+++ b/sql/Bots/updates/world/2022_12_08_00_npc_text.sql
@@ -0,0 +1,8 @@
+-- 
+SET @BOT_START = 70659;
+SET @BOT_END   = 70659;
+
+DELETE FROM `npc_text` WHERE `ID` BETWEEN @BOT_START AND @BOT_END AND `ID` != 70100;
+
+INSERT INTO `npc_text` (`ID`,`text0_0`,`VerifiedBuild`) VALUES
+(@BOT_START+0, "DISABLE combat positioning", -1);
diff --git a/src/common/Utilities/EventProcessor.h b/src/common/Utilities/EventProcessor.h
index 2bf682165..0b8261ec0 100644
--- a/src/common/Utilities/EventProcessor.h
+++ b/src/common/Utilities/EventProcessor.h
@@ -57,6 +57,7 @@ class TC_COMMON_API BasicEvent
 
         // Aborts the event at the next update tick
         void ScheduleAbort();
+        bool IsActive() const { return m_abortState == AbortState::STATE_RUNNING; }
 
     private:
         void SetAborted();
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.cpp b/src/server/database/Database/Implementation/CharacterDatabase.cpp
index 87af6be58..8cab18eee 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/database/Database/Implementation/CharacterDatabase.cpp
@@ -594,6 +594,30 @@ void CharacterDatabaseConnection::DoPrepareStatements()
 
     // DeserterTracker
     PrepareStatement(CHAR_INS_DESERTER_TRACK, "INSERT INTO battleground_deserters (guid, type, datetime) VALUES (?, ?, NOW())", CONNECTION_ASYNC);
+
+    // NPCBots
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER, "UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER_ALL, "UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE characters_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE, "SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid, itemEntry, owner_guid "
+        "FROM item_instance WHERE guid IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE characters_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO characters_npcbot (entry, roles, spec, faction) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_FACTION, "UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_SPEC, "UPDATE characters_npcbot SET spec = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_DISABLED_SPELLS, "UPDATE characters_npcbot SET spells_disabled = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_REP_NPCBOT_STATS, "REPLACE INTO characters_npcbot_stats "
+        "(entry, maxhealth, maxpower, strength, agility, stamina, intellect, spirit, armor, defense, resHoly, resFire, resNature, resFrost, resShadow, resArcane, blockPct, dodgePct, parryPct, critPct, attackPower, spellPower, spellPen, hastePct, hitBonusPct, expertise, armorPenPct) VALUES "
+        "(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_REP_NPCBOT_TRANSMOG, "REPLACE INTO characters_npcbot_transmog (entry, slot, item_id, fake_id) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT_TRANSMOG, "DELETE FROM characters_npcbot_transmog WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT_TRANSMOG_ALL, "DELETE FROM characters_npcbot_transmog WHERE entry IN (SELECT entry FROM characters_npcbot WHERE owner = ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT_GROUP_MEMBER, "INSERT INTO characters_npcbot_group_member (guid, entry, memberFlags, subgroup, roles) VALUES(?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT_GROUP_MEMBER, "DELETE FROM characters_npcbot_group_member WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_GROUP_MEMBER_FLAG, "UPDATE characters_npcbot_group_member SET memberFlags = ? WHERE entry = ?", CONNECTION_ASYNC);
+    // End NPCBots
 }
 
 CharacterDatabaseConnection::CharacterDatabaseConnection(MySQLConnectionInfo& connInfo) : MySQLConnection(connInfo)
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.h b/src/server/database/Database/Implementation/CharacterDatabase.h
index 7404a615c..5fea7b1d6 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.h
+++ b/src/server/database/Database/Implementation/CharacterDatabase.h
@@ -510,6 +510,26 @@ enum CharacterDatabaseStatements : uint32
 
     CHAR_INS_DESERTER_TRACK,
 
+    // NPCBot
+    CHAR_UPD_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER_ALL,
+    CHAR_UPD_NPCBOT_ROLES,
+    CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_DEL_NPCBOT,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_FACTION,
+    CHAR_UPD_NPCBOT_SPEC,
+    CHAR_UPD_NPCBOT_DISABLED_SPELLS,
+    CHAR_REP_NPCBOT_STATS,
+    CHAR_REP_NPCBOT_TRANSMOG,
+    CHAR_DEL_NPCBOT_TRANSMOG,
+    CHAR_DEL_NPCBOT_TRANSMOG_ALL,
+    CHAR_INS_NPCBOT_GROUP_MEMBER,
+    CHAR_DEL_NPCBOT_GROUP_MEMBER,
+    CHAR_UPD_NPCBOT_GROUP_MEMBER_FLAG,
+    // End NPCBot
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/game/AI/CoreAI/UnitAI.cpp b/src/server/game/AI/CoreAI/UnitAI.cpp
index 79d847cfe..c311dd823 100644
--- a/src/server/game/AI/CoreAI/UnitAI.cpp
+++ b/src/server/game/AI/CoreAI/UnitAI.cpp
@@ -268,6 +268,9 @@ bool DefaultTargetSelector::operator()(Unit const* target) const
         return false;
 
     if (_playerOnly && (target->GetTypeId() != TYPEID_PLAYER))
+        //npcbot: allow to target bots
+        //if (!(target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot()))
+        //end npcbot
         return false;
 
     if (_dist > 0.0f && !_me->IsWithinCombatRange(target, _dist))
diff --git a/src/server/game/AI/NpcBots/bot_Events.h b/src/server/game/AI/NpcBots/bot_Events.h
new file mode 100644
index 000000000..6e6347754
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_Events.h
@@ -0,0 +1,72 @@
+#ifndef _BOT_EVENTS_H
+#define _BOT_EVENTS_H
+
+#include "EventProcessor.h"
+
+/*
+Name: bot_Events
+%Complete: ???
+Comment: Custom event types for NPCBot system by Trickerer (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/events
+
+Notes:
+All events must be executed through botAI
+*/
+
+//Teleport home: near or far, only used for free bots
+class TeleportHomeEvent : public BasicEvent
+{
+    friend class bot_ai;
+    protected:
+        TeleportHomeEvent(bot_ai* ai) : _ai(ai) {}
+        ~TeleportHomeEvent() {}
+
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->TeleportHome();
+            return true;
+        }
+
+    private:
+        bot_ai* _ai;
+};
+//Delayed teleport finish: adds bot back to world on new location
+class TeleportFinishEvent : public BasicEvent
+{
+    friend class bot_ai;
+    friend class BotMgr;
+    protected:
+        TeleportFinishEvent(bot_ai* ai) : _ai(ai) {}
+        ~TeleportFinishEvent() {}
+
+        //Execute is always called while creature is out of world so ai is never deleted
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->FinishTeleport();
+            return true;
+        }
+
+    private:
+        bot_ai* _ai;
+};
+//Await state removal
+class AwaitStateRemovalEvent : public BasicEvent
+{
+    friend class bot_ai;
+    protected:
+        AwaitStateRemovalEvent(bot_ai* ai, uint8 state) : _ai(ai), _state(state) {}
+        ~AwaitStateRemovalEvent() = default;
+
+        //Execute is always called while creature is out of world so ai is never deleted
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->EventRemoveBotAwaitState(_state);
+            return true;
+        }
+
+    private:
+        bot_ai* _ai;
+        const uint8 _state;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 000000000..4a5e00e9e
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,1408 @@
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "bot_ai.h"
+#include "botspell.h"
+#include "Corpse.h"
+#include "Creature.h"
+#include "DBCStores.h"
+#include "DynamicObject.h"
+#include "GameObject.h"
+#include "Group.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "SpellMgr.h"
+#include "Vehicle.h"
+/*
+Name: bot_GridNotifiers
+%Complete: 99+
+Comment: Custom grid notifiers for Bot system by Trickerer (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+extern bool _botPvP;
+
+template<class Check>
+struct Unit2LastSearcher
+{
+    Unit* &i_result1;
+    Unit* &i_result2;
+    Check& i_check;
+
+    Unit2LastSearcher(Unit* &result1, Unit* &result2, Check& check)
+        : i_result1(result1), i_result2(result2), i_check(check) { }
+
+    void Visit(CreatureMapType &m)
+    {
+        for (CreatureMapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+        {
+            switch ((uint32)i_check(itr->GetSource()))
+            {
+                case 1: i_result1 = itr->GetSource(); break;
+                case 2: i_result2 = itr->GetSource(); break;
+                default:                              break;
+            }
+        }
+    }
+
+    void Visit(PlayerMapType &m)
+    {
+        for (PlayerMapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+        {
+            switch ((uint32)i_check(itr->GetSource()))
+            {
+                case 1: i_result1 = itr->GetSource(); break;
+                case 2: i_result2 = itr->GetSource(); break;
+                default:                              break;
+            }
+        }
+    }
+
+    template<class NOT_INTERESTED> void Visit(GridRefManager<NOT_INTERESTED> &) { }
+};
+
+class ImmunityShieldDispelTargetCheck
+{
+    public:
+        explicit ImmunityShieldDispelTargetCheck(Unit const* unit, float dist, bot_ai const* m_ai) :
+        me(unit), range(dist), ai(m_ai) { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (!_botPvP && !free && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, range))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (!u->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+                return false;
+
+            if (!u->IsWithinLOSInMap(me))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float range;
+        bot_ai const* ai;
+        bool free;
+        ImmunityShieldDispelTargetCheck(ImmunityShieldDispelTargetCheck const&);
+};
+
+class NearestHostileUnitCheck
+{
+    enum : uint32 {
+        INVALID         = 0,
+        VALID_PRIMARY   = 1,
+        VALID_SECONDARY = 2
+    };
+
+    public:
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&) = delete;
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false, bool withSecondary = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed), checkSecondary(withSecondary)
+        { free = ai->IAmFree(); }
+        uint32 operator()(Unit const* u)
+        {
+            if (u == me)
+                return INVALID;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return INVALID;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return INVALID;
+            if (/*!free && */!u->IsInCombat())
+                return INVALID;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return INVALID;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return INVALID;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer() && !u->IsInCombat())
+                    return INVALID;
+            }
+            else
+            {
+                if (!u->IsWithinLOSInMap(me))
+                    return INVALID;
+            }
+
+            uint32 res = VALID_PRIMARY;
+            if (!ai->CanBotAttack(u, byspell))
+            {
+                if (checkSecondary && ai->CanBotAttack(u, byspell, checkSecondary))
+                    res = VALID_SECONDARY;
+                else
+                    return INVALID;
+            }
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return res;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        bool checkSecondary;
+        bool free;
+};
+
+class NearbyHostileVehicleTargetCheck
+{
+    public:
+        explicit NearbyHostileVehicleTargetCheck(Unit const* unit, float dist, bot_ai const* m_ai) : veh(unit), m_range(dist), ai(m_ai) { }
+        bool operator()(Unit const* u)
+        {
+            if (u == veh)
+                return false;
+            if (!veh->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            //if (!veh->IsValidAttackTarget(u))
+            //    return false;
+            //if (!u->isTargetableForAttack(false))
+            //    return false;
+            //if (ai->IsInBotParty(u))
+            //    return false;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(veh) >= REP_NEUTRAL)
+                return false;
+            //if (!u->IsWithinLOSInMap(veh))
+            //    return false;
+
+            return true;
+        }
+    private:
+        Unit const* veh;
+        float m_range;
+        bot_ai const* ai;
+        NearbyHostileVehicleTargetCheck(NearbyHostileVehicleTargetCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = nullptr) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->IsInCombat() &&
+                u->InSamePhase(me) &&
+                u->IsWithinDistInMap(me, m_range) &&
+                u->isTargetableForAttack() &&
+                //!ai->InDuel(u) &&
+                (!ai->IsInBotParty(u) || ai->IsInHeroicOrRaid()) &&
+                (ai->IsInBotParty(u->GetVictim()) || me->GetVictim() == u))
+            {
+                if (!checksteal && u->GetEntry() == 25744 && !u->GetOwnedAuras().empty()) // Sunwell - Dark Fiend
+                    return true;
+
+                if (checksteal)
+                {
+                    if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449), me))
+                        return false; //immune to steal
+                }
+                else if (ai->GetBotClass() == BOT_CLASS_SHAMAN)
+                {
+                    if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(370), me))
+                        return false; //immune to purge
+                }
+                //else if (ai->GetBotClass() == BOT_CLASS_PRIEST)
+                //{
+                //    if (me->GetLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527), me))
+                //        return false; //immune to dispel magic
+                //}
+
+                Unit::AuraApplicationMap const &AurApps = u->GetAppliedAuras();
+                SpellInfo const* Info;
+                uint32 id;
+                for (Unit::AuraApplicationMap::const_iterator itr = AurApps.begin(); itr != AurApps.end(); ++itr)
+                {
+                    Info = itr->second->GetBase()->GetSpellInfo();
+                    if (itr->second->IsPositive() && Info->Dispel == DISPEL_MAGIC &&
+                        !(Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) &&
+                        !(checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)))
+                    {
+                        id = Info->Id;
+                        if (id != 20050 && id != 20052 && id != 20053 && //Vengeance
+                            id != 50447 && id != 50448 && id != 50449) //Bloody Vengeance
+                            return true;
+                    }
+                }
+
+                //Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                //SpellInfo const* Info;
+                //uint32 id;
+                //for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                //{
+                //    Aura* aura = itr->second;
+                //    Info = aura->GetSpellInfo();
+                //    if (Info->Dispel != DISPEL_MAGIC) continue;
+                //    id = Info->Id;
+                //    if (id == 20050 || id == 20052 || id == 20053 || //Vengeance
+                //        id == 50447 || id == 50448 || id == 50449) //Bloody Vengeance
+                //        continue;
+                //    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                //    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                //    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                //    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                //    if (aurApp && aurApp->IsPositive())
+                //        return true;
+                //}
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(ObjectGuid casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (caster && u->HasUnitFlag(UNIT_FLAG_UNINTERACTIBLE))
+                return false;
+            if (!checker->IsWithinDistInMap(u, m_range))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            //else if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            //else if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            else if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+            else if (needhostile == 4 && !(u->GetTypeId() == TYPEID_PLAYER && u->IsFriendlyTo(checker))) return false;
+
+            //if (u->HasAura(spell, caster)
+            //    return true;
+
+            Unit::AuraApplicationMap const &Auras = u->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+            {
+                AuraApplication const* auraApp = itr->second;
+                if (itr->first == spell)
+                    if (caster == 0 || auraApp->GetBase()->GetCasterGUID() == caster)
+                        return true;
+            }
+            return false;
+        }
+    private:
+        ObjectGuid const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->GetVictim() || u == me->GetVictim())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || me->GetVictim()->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->IsFrozen() ||
+                u->IsRooted() ||
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE) ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118), me))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514), me))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->IsFeared())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER)
+                return false;
+            if (u->IsTotem())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            //Unit::GetDiminishing() should be const but it isn't
+            if (const_cast<Unit*>(u)->GetDiminishing(DIMINISHING_FEAR) > DIMINISHING_LEVEL_3)
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782), me))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513), me))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (me->ToCreature()->GetBotClass() != BOT_CLASS_DREADLORD && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER && me->GetTarget() == u->GetGUID())//auto shot
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_DRUID &&
+                !(u->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN && me->GetDistance(u) < 10)//prevent break due to AOE damage
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066), me))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210), me))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386), me))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991), me))//scatter shot
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(2094), me))//blind
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                u->GetCreatureType() == CREATURE_TYPE_HUMANOID &&
+                (u->GetVictim() || u->IsControlledByPlayer()) &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(6358), me))//seduction
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_DREADLORD &&
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(SPELL_SLEEP), me))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist, bot_ai const* ai, uint32 spell, bool unattacked) :
+        me(unit), m_range(dist), m_ai(ai), m_spellId(spell), _unattacked(unattacked) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (_unattacked && !u->getAttackers().empty())
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PRIEST &&
+                !(u->GetCreatureType() == CREATURE_TYPE_UNDEAD && !u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD && u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                ((u->GetCreatureType() != CREATURE_TYPE_DEMON && u->GetCreatureType() != CREATURE_TYPE_ELEMENTAL) ||
+                m_ai->IsPointedAnyAttackTarget(u)))
+                return false;
+            if (u->GetVictim() && !m_ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId), me))
+                return false;
+            if (m_ai->IsPointedNoDPSTarget(u) && bot_ai::IsDamagingSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bot_ai const* m_ai;
+        uint32 m_spellId;
+        bool _unattacked;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, float dist, bot_ai const* ai, uint32 spell = 0) :
+        me(unit), m_range(dist), m_ai(ai), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == me->GetVictim())
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack(false))
+                return false;
+            if (u->IsFrozen() || u->IsRooted())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetVictim() && !m_ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAuraType(SPELL_AURA_MOD_PACIFY_SILENCE)/*hex*/ ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PALADIN, 0x4)/*repentance*/ ||
+                u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STUN, SPELLFAMILY_PRIEST, 0x40000000)/*shackle undead*/)
+                return false;
+            if (m_ai->IsPointedNoDPSTarget(u) && bot_ai::IsDamagingSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId), me))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bot_ai const* m_ai;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, uint32 spell = 0, uint8 minHpPct = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_spell(spell), m_minHpPct(minHpPct) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->GetTarget() && !u->IsInCombat())
+                return false;
+            if (u->IsTotem())
+                return false;
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u->HealthBelowPct(m_minHpPct))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->isTargetableForAttack(false))
+                return false;
+            //if (!m_friend && u->HasUnitFlag(UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCast(false,false,true))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (u->GetReactionTo(me) >= REP_FRIENDLY)
+                return false;
+            if (m_spell)
+            {
+                if ((m_spell == 5782 || //fear (warlock)
+                    m_spell == 64044 || //fear (priest)
+                    m_spell == SPELL_SLEEP) &&
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                    return false;
+                if (m_spell == 10326 && //turn evil
+                    !(u->GetCreatureType() == CREATURE_TYPE_UNDEAD ||
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON))
+                    return false;
+                if (m_spell == 20066 && //repentance
+                    !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (m_spell == 2637 && //hibernate
+                    !(u->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN))
+                    return false;
+                if (m_spell == 9484 && //shackle undead (priest)
+                    u->GetCreatureType() != CREATURE_TYPE_UNDEAD)
+                    return false;
+
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(m_spell);
+                if (u->IsImmunedToSpell(spellInfo, me))
+                    return false;
+
+                if (me->GetTypeId() == TYPEID_UNIT && me->ToCreature()->GetBotAI() && me->ToCreature()->GetBotAI()->IsPointedNoDPSTarget(u) &&
+                    bot_ai::IsDamagingSpell(spellInfo))
+                    return false;
+
+                if (!CastInterruptionCheck(u, spellInfo))
+                    return false;
+            }
+
+            return true;
+        }
+
+        static bool CastInterruptionCheck(Unit const* u, SpellInfo const* spellInfo)
+        {
+            if (spellInfo->HasEffect(SPELL_EFFECT_INTERRUPT_CAST) && spellInfo->GetFirstRankSpell()->Id != 853) //hammer of justice
+            {
+                if (u->GetTypeId() == TYPEID_UNIT &&
+                    (u->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << (MECHANIC_INTERRUPT - 1))))
+                    return false;
+
+                Spell* curSpell;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    curSpell = u->GetCurrentSpell(i);
+                    if (!curSpell)
+                        continue;
+
+                    //copied conditions from Spell::EffectInterruptCast
+                    if (!((curSpell->getState() == SPELL_STATE_CASTING ||
+                        (curSpell->getState() == SPELL_STATE_PREPARING && curSpell->GetCastTime() > 0.0f)) &&
+                        curSpell->GetSpellInfo()->PreventionType == SPELL_PREVENTION_TYPE_SILENCE &&
+                        ((i == CURRENT_GENERIC_SPELL && curSpell->GetSpellInfo()->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) ||
+                        (i == CURRENT_CHANNELED_SPELL && curSpell->GetSpellInfo()->ChannelInterruptFlags & CHANNEL_INTERRUPT_FLAG_INTERRUPT))))
+                        return false;
+                }
+            }
+            bool silenceSpell = false;
+            for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+            {
+                if (spellInfo->_effects[i].Effect == SPELL_EFFECT_APPLY_AURA &&
+                    spellInfo->_effects[i].ApplyAuraName == SPELL_AURA_MOD_SILENCE)
+                {
+                    silenceSpell = true;
+                    break;
+                }
+            }
+            if (silenceSpell)
+            {
+                if (u->GetTypeId() == TYPEID_UNIT &&
+                    (u->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1 << (MECHANIC_SILENCE - 1))))
+                    return false;
+
+                Spell* curSpell;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                {
+                    curSpell = u->GetCurrentSpell(i);
+                    if (curSpell && curSpell->GetSpellInfo()->PreventionType != SPELL_PREVENTION_TYPE_SILENCE)
+                        return false;
+                }
+            }
+
+            return true; //do not check players and non-interrupt non-silence spells
+        }
+
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        uint32 m_spell;
+        uint8 m_minHpPct;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack(false) &&
+                u->IsVisible() &&
+                ai->IsInBotParty(u->GetVictim()) &&
+                u->GetReactionTo(me) <= REP_NEUTRAL)
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801), me))
+                    return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai, uint8 CCoption, WorldObject const* source) :
+        me(unit), max_range(maxdist), ai(m_ai), m_CCoption(CCoption), _source(source)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me || u == _source)
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(_source))
+                return false;
+            if ((m_CCoption & 1) && u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if ((m_CCoption & 2) && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_CRITTER)
+                return false;
+            if (!_source->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack(false))
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        uint8 m_CCoption;
+        bool free;
+        WorldObject const* _source;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+class NearbyHostileUnitInConeCheck
+{
+    public:
+        explicit NearbyHostileUnitInConeCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) :
+        me(unit), max_range(maxdist), ai(m_ai), cone(float(M_PI)/2)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+            //    return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!me->HasInArc(cone, u))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack(false))
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        float cone;
+        bool free;
+        NearbyHostileUnitInConeCheck(NearbyHostileUnitInConeCheck const&);
+};
+
+class NearbyFriendlyUnitCheck
+{
+    public:
+        explicit NearbyFriendlyUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (!u->IsInCombat())
+            //    return false;
+            if (!u->IsAlive())
+                return false;
+            if (u->HasUnitState(UNIT_STATE_ISOLATED))
+                return false;
+            //if (u->IsTotem() || u->IsSummon())
+            //    return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!ai->IsInBotParty(u))
+                return false;
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (!me->IsValidAssistTarget(u))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyFriendlyUnitCheck(NearbyFriendlyUnitCheck const&);
+};
+
+class FarTauntUnitCheck
+{
+    public:
+        explicit FarTauntUnitCheck(Unit const* unit, float maxdist, bool ally, bot_ai const* m_ai) :
+        me(unit), max_range(maxdist), targetAlly(ally), ai(m_ai)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (!u->GetVictim() || u->GetVictim() == me)
+                return false;
+            if (!u->CanHaveThreatList())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_MOD_TAUNT))
+                return false;
+            if (ai->IsTank(u->GetVictim()))
+                return false;
+            //if (ai->InDuel(u))
+            //    return false;
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARRIOR && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(355), me))
+                return false; //taunt
+            else if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(62124), me))
+                return false; //HoR
+            else if (me->ToCreature()->GetBotClass() == BOT_CLASS_DRUID && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(6795), me))
+                return false; //Growl
+
+            if (free && (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack(false)))
+                return false;
+
+            if (me->GetDistance(targetAlly ? u->GetVictim() : u) > max_range)
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bool targetAlly;
+        bot_ai const* ai;
+        bool free;
+        FarTauntUnitCheck(FarTauntUnitCheck const&);
+};
+
+class ManaDrainUnitCheck
+{
+    public:
+        explicit ManaDrainUnitCheck(Unit const* unit, float maxdist, bot_ai const* ai) : me(unit), max_range(maxdist), ai(ai)
+        { maxPool = me->GetMaxPower(POWER_MANA) * 3 / 2; }
+        bool operator()(Unit const* u)
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u == me)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetTypeId() == TYPEID_PLAYER && !u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            //if (u->IsControlledByPlayer())
+            //    return false;
+            if (ai->IAmFree())
+            {
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+                if (ai->IsInBotParty(u))
+                    return false;
+            }
+            //if (ai->InDuel(u))
+            //    return false;
+            if (u->GetPowerType() != POWER_MANA)
+                return false;
+            if (u->GetMaxPower(POWER_MANA) < maxPool)
+                return false;
+            if (u->GetPower(POWER_MANA)*10/(u->GetMaxPower(POWER_MANA)/10) < 15)
+                return false;
+            if (!me->HasInArc(float(M_PI)*0.5f, u))
+                return false;
+            if (me->GetDistance(u) > max_range)
+                return false;
+
+            maxPool = u->GetMaxPower(POWER_MANA);
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        uint32 maxPool;
+        ManaDrainUnitCheck(ManaDrainUnitCheck const&);
+};
+
+class NearbyRezTargetCheck
+{
+    public:
+        explicit NearbyRezTargetCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(WorldObject const* u) const
+        {
+            if (u == me)
+                return false;
+            if (u->GetTypeId() != TYPEID_PLAYER && u->GetTypeId() != TYPEID_CORPSE)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (Player const* p = u->ToPlayer())
+            {
+                if (p->IsAlive())
+                    return false;
+                if (p->IsResurrectRequested())
+                    return false;
+                if (!ai->IsInBotParty(p))
+                    return false;
+            }
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (urand(0,100) > 20)
+                return false;
+            if (u->GetTypeId() == TYPEID_CORPSE && !ObjectAccessor::FindPlayer(u->ToCorpse()->GetOwnerGUID()))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyRezTargetCheck(NearbyRezTargetCheck const&);
+};
+
+class NearestLockedGameObjectInRangeCheck
+{
+public:
+    NearestLockedGameObjectInRangeCheck(WorldObject const* unit, float range) : _unit(unit), _range(range) { }
+    bool operator()(GameObject* go)
+    {
+        if (go->GetGOInfo()->GetLockId() &&
+            !go->HasFlag(GO_FLAG_IN_USE) &&
+            //go->getLootState() == GO_READY &&
+            _unit->IsWithinDistInMap(go, _range))
+        {
+            _range = _unit->GetExactDist(go);
+            return true;
+        }
+        return false;
+    }
+private:
+    WorldObject const* _unit;
+    float _range;
+
+    NearestLockedGameObjectInRangeCheck(NearestLockedGameObjectInRangeCheck const&);
+};
+
+class NearestVehicleWithEmptySeatInRangeCheck
+{
+public:
+    NearestVehicleWithEmptySeatInRangeCheck(WorldObject const* unit, float range, Unit const* exveh) : _unit(unit), _range(range), _exveh(exveh)
+    { ASSERT(_unit->isType(TYPEMASK_UNIT)); }
+    bool operator()(Unit* u)
+    {
+        if (u->GetTypeId() == TYPEID_UNIT && u->IsVehicle() && u->IsAlive() && u != _exveh &&
+            u->GetVehicleKit()->GetAvailableSeatCount() > 0 && _unit->IsWithinDistInMap(u, _range))
+        {
+            _range = _unit->GetExactDist(u);
+            return true;
+        }
+        return false;
+    }
+private:
+    WorldObject const* _unit;
+    float _range;
+    Unit const* _exveh; //only compare, may be NULL
+
+    NearestVehicleWithEmptySeatInRangeCheck(NearestVehicleWithEmptySeatInRangeCheck const&);
+};
+
+//Professions
+class NearbyObjectBySkillCheck
+{
+public:
+    NearbyObjectBySkillCheck(WorldObject const* checker, float const range, uint32 skillMask) :
+      _checker(checker), _range(range), _skillMask(skillMask) { ASSERT(_checker->GetTypeId() == TYPEID_PLAYER); }
+
+    bool operator()(WorldObject const* ob)
+    {
+        if (!_checker->IsWithinDistInMap(ob, _range))
+            return false;
+
+        if (GameObject const* go = ob->ToGameObject())
+        {
+            if (/*go->getLootState() == GO_READY && */go->isSpawned() && go->GetGOInfo()->GetLockId() &&
+                go->IsLootAllowedFor(_checker->ToPlayer()) && _checker->CanSeeOrDetect(go) && _checker->ToPlayer()->HaveAtClient(ob))
+            {
+                if (LockEntry const* lockInfo = sLockStore.LookupEntry(go->GetGOInfo()->GetLockId()))
+                {
+                    for (uint8 i = 0; i != MAX_LOCK_CASE; ++i)
+                    {
+                        if (lockInfo->Type[i] == LOCK_KEY_SKILL &&
+                            CheckSkill(SkillByLockType(LockType(lockInfo->Index[i]))) &&
+                            lockInfo->Skill[i] <= MaxSkillForLevel(_checker->ToUnit()->GetLevel()))
+                            return true;
+                    }
+                }
+            }
+        }
+        else if (Creature const* cre = ob->ToCreature())
+        {
+            if (cre->IsVisible() && cre->getDeathState() == CORPSE && cre->HasUnitFlag(UNIT_FLAG_SKINNABLE) && cre->loot.isLooted() &&
+                cre->isTappedBy(_checker->ToPlayer()) && CheckSkill(cre->GetCreatureTemplate()->GetRequiredLootSkill()))
+            {
+                if (int32(cre->GetLevel() < 20 ? (cre->GetLevel() - 10) * 10 : cre->GetLevel() * 5) <= int32(MaxSkillForLevel(_checker->ToUnit()->GetLevel())))
+                    return true;
+            }
+        }
+        return false;
+    }
+private:
+    WorldObject const* _checker;
+    float const _range;
+    uint32 const _skillMask;
+
+    inline bool CheckSkill(SkillType const skill) const
+    {
+        switch (skill)
+        {
+            case SKILL_MINING:
+                return (_skillMask & BOT_ROLE_GATHERING_MINING);
+            case SKILL_HERBALISM:
+                return (_skillMask & BOT_ROLE_GATHERING_HERBALISM);
+            case SKILL_SKINNING:
+                return (_skillMask & BOT_ROLE_GATHERING_SKINNING);
+            case SKILL_ENGINEERING:
+                return (_skillMask & BOT_ROLE_GATHERING_ENGINEERING);
+            default:
+                return false;
+        }
+    }
+
+    inline uint32 MaxSkillForLevel(uint8 const level) const
+    {
+        return
+            level <= 20 ? 150 :
+            level <= 40 ? 225 :
+            level <= 60 ? 300 :
+            level <= 70 ? 375 : 450;
+
+        //return level <= 60 ? level * 5 : 300 + (((level - 60) * 15) / 2);
+    }
+
+    NearbyObjectBySkillCheck(NearbyObjectBySkillCheck const&);
+};
+
+//Autolooting
+class NearbyLootableCreatureCheck
+{
+public:
+    NearbyLootableCreatureCheck(WorldObject* checker, float const range) : _checker(checker), _range(range)
+    { ASSERT(_checker->GetTypeId() == TYPEID_PLAYER); }
+
+    bool operator()(Unit const* unit)
+    {
+        if (Creature const* cre = unit->ToCreature())
+            if (_checker->IsWithinDistInMap(cre, _range))
+                return cre->IsVisible() && cre->getDeathState() == CORPSE &&
+                    cre->HasDynamicFlag(UNIT_DYNFLAG_LOOTABLE) &&
+                    _checker->ToPlayer()->isAllowedToLoot(cre);
+        return false;
+    }
+private:
+    WorldObject* _checker;
+    float const _range;
+
+    NearbyLootableCreatureCheck(NearbyLootableCreatureCheck const&);
+};
+
+//AoE caster dynobject
+class NearbyHostileAoEDynobjectCheck
+{
+    public:
+        explicit NearbyHostileAoEDynobjectCheck(Unit const* unit, float maxdist) : _me(unit), _range(maxdist) { }
+        bool operator()(WorldObject const* u) const
+        {
+            DynamicObject const* dObj = u->ToDynObject();
+            if (!dObj || !dObj->GetSpellId() || !dObj->GetCaster())
+                return false;
+            if (dObj->GetByteValue(DYNAMICOBJECT_BYTES, 0) != DYNAMIC_OBJECT_AREA_SPELL)
+                return false;
+            if (!dObj->InSamePhase(_me))
+                return false;
+            if (!dObj->GetRadius())
+                return false;
+            if (!dObj->IsWithinDistInMap(_me, _range))
+                return false;
+            if (!dObj->GetCaster()->IsValidAttackTarget(_me))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* _me;
+        float _range;
+        NearbyHostileAoEDynobjectCheck(NearbyHostileAoEDynobjectCheck const&);
+};
+
+namespace BOTAI_PRED
+{
+    class HealTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->IsSummon() || target->IsTotem() || (target->GetHealthPct() > 90 && target->GetMaxHealth() - target->GetHealth() < 500);
+            }
+    };
+    class BuffTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->IsSummon() || target->IsTotem();
+            }
+    };
+    class DrainTargetExclude
+    {
+        public:
+            bool operator()(Unit const* target)
+            {
+                return target->IsTotem() || target->GetPowerType() != POWER_MANA || target->GetPower(POWER_MANA) < 1000;
+            }
+    };
+    class UnitExclude
+    {
+        public:
+            UnitExclude(Unit const* unit) { _unit = unit; }
+            bool operator()(Unit const* target)
+            {
+                return target == _unit;
+            }
+        private:
+            Unit const* _unit;
+    };
+
+    class AuraedTargetExclude
+    {
+        public:
+            AuraedTargetExclude(uint32 spellId, uint8 minstacks = 0) : _spellId(spellId), _minstacks(minstacks) {}
+            bool operator()(Unit const* target)
+            {
+                AuraApplication const* aurApp = target->GetAuraApplicationOfRankedSpell(_spellId);
+                return aurApp && (!_minstacks || aurApp->GetBase()->GetStackAmount() >= _minstacks);
+            }
+        private:
+            uint32 _spellId;
+            uint8 _minstacks;
+    };
+
+    class AuraedTargetExcludeByCaster
+    {
+        public:
+            AuraedTargetExcludeByCaster(uint32 spellId, ObjectGuid caster, uint8 minstacks = 0) :
+                _spellId(spellId), _caster(caster), _minstacks(minstacks) {}
+            bool operator()(Unit const* target)
+            {
+                AuraApplication const* aurApp = target->GetAuraApplicationOfRankedSpell(_spellId, _caster);
+                return aurApp && (!_minstacks || aurApp->GetBase()->GetStackAmount() >= _minstacks);
+            }
+        private:
+            uint32 _spellId;
+            ObjectGuid _caster;
+            uint8 _minstacks;
+    };
+
+    class HpPctAboveExclude
+    {
+        public:
+        HpPctAboveExclude(float pct) : _pct(pct) {}
+            bool operator()(Unit const* target)
+            {
+                return target->GetHealthPct() > _pct;
+            }
+        private:
+            float _pct;
+    };
+
+    class UnitCombatStateExclude
+    {
+        public:
+        UnitCombatStateExclude(bool combat) : _combat(combat) {}
+            bool operator()(Unit const* target)
+            {
+                return target->IsInCombat() == _combat;
+            }
+        private:
+            bool _combat;
+    };
+
+    class UnitLivingStateExclude
+    {
+        public:
+        UnitLivingStateExclude(bool living) : _living(living) {}
+            bool operator()(Unit const* target)
+            {
+                return target->IsAlive() == _living;
+            }
+        private:
+            bool _living;
+    };
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 000000000..25c7daf59
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,18711 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "bot_GridNotifiers.h"
+#include "botdatamgr.h"
+#include "botmgr.h"
+#include "botgossip.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "bpet_ai.h"
+#include "Bag.h"
+#include "CellImpl.h"
+#include "CharacterCache.h"
+#include "CharacterDatabase.h"
+#include "Chat.h"
+#include "DatabaseEnv.h"
+#include "DBCStores.h"
+#include "GameEventMgr.h"
+#include "GameObjectAI.h"
+#include "GossipDef.h"
+#include "GridNotifiersImpl.h"
+#include "InstanceScript.h"
+#include "Item.h"
+#include "LFG.h"
+#include "LFGMgr.h"
+#include "Log.h"
+#include "Mail.h"
+#include "MapManager.h"
+#include "MotionMaster.h"
+#include "ObjectMgr.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+#include "TemporarySummon.h"
+#include "Transport.h"
+#include "World.h"
+/*
+NpcBot System by Trickerer (https://github.com/trickerer/Trinity-Bots; onlysuffering@gmail.com)
+Version 4.15.22a
+Original idea: https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+dk pets (garg, aod, rdw)
+'Go there and do stuff' scenarios
+Encounter Scenarios
+Notes:
+Methods may have null arg1 (Unit*):
+DamageTaken(Unit*, ), JustDied(Unit*, ), OwnerAttackedBy(Unit*, ), HealReceived(Unit*, )
+Possibly others
+*/
+
+static constexpr GossipOptionIcon BOT_ICON_ON = GOSSIP_ICON_BATTLE;
+static constexpr GossipOptionIcon BOT_ICON_OFF = GOSSIP_ICON_CHAT;
+
+static constexpr uint32 MAX_AMMO_LEVEL = 13;
+uint8 constexpr AmmoDPSForLevel[MAX_AMMO_LEVEL][2] =
+{
+    {  1,  1 },
+    {  5,  2 },
+    { 10,  3 },
+    { 15,  4 },
+    { 25,  7 },
+    { 30,  8 },
+    { 37, 12 },
+    { 44, 15 },
+    { 52, 17 },
+    { 57, 26 },
+    { 62, 43 },
+    { 72, 67 },
+    { 80, 91 }
+};
+static constexpr uint32 MAX_POTION_SPELLS = 8;
+static constexpr uint32 MAX_FEAST_SPELLS = 11;
+uint32 constexpr ManaPotionSpells[MAX_POTION_SPELLS][2] =
+{
+    {  5,   437 },
+    { 14,   438 },
+    { 22,  2023 },
+    { 31, 11903 },
+    { 41, 17530 },
+    { 49, 17531 },
+    { 55, 28499 },
+    { 70, 43186 }
+};
+uint32 constexpr HealingPotionSpells[MAX_POTION_SPELLS][2] =
+{
+    {  1,   439 },
+    {  3,   440 },
+    { 12,   441 },
+    { 21,  2024 },
+    { 35,  4042 },
+    { 45, 17534 },
+    { 55, 28495 },
+    { 70, 43185 }
+};
+uint32 constexpr DrinkSpells[MAX_FEAST_SPELLS][2] =
+{
+    {  1,   430 },
+    {  5,   431 },
+    { 15,   432 },
+    { 25,  1133 },
+    { 35,  1135 },
+    { 45,  1137 },
+    { 60, 34291 },
+    { 65, 27089 },
+    { 70, 43182 },
+    { 75, 43183 },
+    { 80, 57073 }
+};
+uint32 constexpr EatSpells[MAX_FEAST_SPELLS][2] =
+{
+    {  1,   433 },
+    {  5,   434 },
+    { 15,   435 },
+    { 25,  1127 },
+    { 35,  1129 },
+    { 45,  1131 },
+    { 55, 27094 },
+    { 65, 35270 },
+    { 70, 43180 }, //req 65 but
+    { 75, 45548 },
+    { 80, 45548 }
+};
+uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+void ApplyBotPercentModFloatVar(float &var, float val, bool apply)
+{
+    var *= (apply ? ((100.f + val) / 100.f) : (100.f / (100.f + val)));
+}
+
+static uint16 __rand; //calculated for each bot separately once every updateAI tick
+
+static std::set<uint32> BotCustomSpells;
+
+bot_ai::bot_ai(Creature* creature) : CreatureAI(creature)
+{
+    //moved
+    _potionTimer = 0;
+
+    _classinfo = new PlayerClassLevelInfo();
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        _equips[i] = nullptr;
+
+    _reviveTimer = 0;
+    _powersTimer = 0;
+    _chaseTimer = 0;
+    _engageTimer = 0;
+
+    _jumpCount = 0;
+    _evadeCount = 0;
+
+    _lastTargetGuid = ObjectGuid::Empty;
+
+    checkMasterTimer = urand(5000, 15000);
+    feast_health = false;
+    feast_mana = false;
+    spawned = false;
+    firstspawn = true;
+    _evadeMode = false;
+    _atHome = true;
+    _roleMask = 0;
+    haste = 0;
+    hit = 0.f;
+    parry = 0.f;
+    dodge = 0.f;
+    block = 0.f;
+    crit = 0.f;
+    dmg_taken_phy = 1.f;
+    dmg_taken_mag = 1.f;
+    armor_pen = 0.f;
+    expertise = 0;
+    spellpower = 0;
+    spellpen = 0;
+    defense = 0;
+    blockvalue = 1;
+    regenTimer = 0;
+    m_botSpellInfo = nullptr;
+    waitTimer = 0;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _energyFraction = 0.f;
+    _updateTimerMedium = 0;
+    _updateTimerEx1 = urand(12000, 15000);
+    checkAurasTimer = 0;
+    roleTimer = 0;
+    ordersTimer = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    movepos.m_positionX = 0.f;
+    movepos.m_positionY = 0.f;
+    movepos.m_positionZ = 0.f;
+    aftercastTargetGuid = ObjectGuid::Empty;
+
+    shouldEnterVehicle = false;
+
+    _saveDisabledSpellsTimer = 0;
+    _saveDisabledSpells = false;
+
+    _deathsCount = 0;
+    _killsCount = 0;
+    _pvpKillsCount = 0;
+    _playerKillsCount = 0;
+
+    for (uint8 i = 0; i != 6; ++i)
+        resistbonus[i] = 0;
+
+    botPet = nullptr;
+    canUpdate = true;
+
+    teleHomeEvent = nullptr;
+    teleFinishEvent = nullptr;
+    awaitStateRemEvent = nullptr;
+
+    _lastZoneId = 0;
+    _lastAreaId = 0;
+    _lastWMOAreaId = 0;
+
+    _wmoAreaUpdateTimer = 0;
+
+    _ownerGuid = 0;
+
+    opponent = nullptr;
+    disttarget = nullptr;
+
+    ResetBotAI(BOTAI_RESET_INIT);
+
+    BotDataMgr::RegisterBot(me);
+}
+bot_ai::~bot_ai()
+{
+    while (!_spells.empty())
+    {
+        BotSpellMap::iterator itr = _spells.begin();
+        delete itr->second;
+        _spells.erase(itr);
+    }
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        if (_equips[i])
+            delete _equips[i];
+
+    delete _classinfo;
+
+    BotDataMgr::UnregisterBot(me);
+}
+
+uint16 bot_ai::Rand() const
+{
+    return __rand;
+}
+//0-178
+void bot_ai::GenerateRand() const
+{
+    __rand = urand(0, IAmFree() ? 100 : 100 + (master->GetNpcBotsCount() - 1) * 2);
+}
+
+std::map<uint32, std::string> unk_botstrings;
+const std::string& bot_ai::LocalizedNpcText(Player const* forPlayer, uint32 textId)
+{
+    LocaleConstant loc = forPlayer ? forPlayer->GetSession()->GetSessionDbLocaleIndex() : sWorld->GetDefaultDbcLocale();
+
+    if (GossipText const* nt = sObjectMgr->GetGossipText(textId))
+    {
+        std::wstring wnamepart;
+        NpcTextLocale const* ntl = sObjectMgr->GetNpcTextLocale(textId);
+        if (loc != DEFAULT_LOCALE && ntl && !ntl->Text_0[0][loc].empty() && Utf8FitTo(ntl->Text_0[0][loc], wnamepart))
+            return ntl->Text_0[0][loc];
+        else
+            return nt->Options[0].Text_0;
+    }
+
+    if (!unk_botstrings.count(textId))
+    {
+        TC_LOG_ERROR("entities.player", "NPCBots: bot text string #%u is not localized, at least for %s",
+            textId, localeNames[loc]);
+
+        std::ostringstream msg;
+        msg << (loc == DEFAULT_LOCALE ? "<undefined string " : "<unlocalized string ") << textId << ">";
+        unk_botstrings[textId] = msg.str();
+    }
+
+    return unk_botstrings[textId];
+}
+
+void bot_ai::BotSay(const std::string &text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->Say(text, LANG_UNIVERSAL, target);
+}
+void bot_ai::BotWhisper(const std::string &text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    Player* playerTarget = const_cast<Player*>(target);
+
+    me->Whisper(text, LANG_UNIVERSAL, playerTarget);
+}
+void bot_ai::BotYell(const std::string &text, Player const* /*target*/) const
+{
+    //if (!target && master->GetTypeId() == TYPEID_PLAYER)
+    //    target = master;
+    //if (!target)
+    //    return;
+
+    me->Yell(text, LANG_UNIVERSAL);
+}
+void bot_ai::BotSay(std::string&& text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->Say(text, LANG_UNIVERSAL, target);
+}
+void bot_ai::BotWhisper(std::string&& text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    Player* playerTarget = const_cast<Player*>(target);
+
+    me->Whisper(text, LANG_UNIVERSAL, playerTarget);
+}
+void bot_ai::BotYell(std::string&& text, Player const* /*target*/) const
+{
+    me->Yell(text, LANG_UNIVERSAL);
+}
+
+void bot_ai::ReportSpellCast(uint32 spellId, const std::string& followedByString, Player const* target) const
+{
+    std::string spellName;
+    _LocalizeSpell(target, spellName, spellId);
+    BotWhisper(spellName + followedByString, target);
+}
+
+bool bot_ai::SetBotOwner(Player* newowner)
+{
+    ASSERT(newowner, "Trying to set NULL owner!!!");
+    ASSERT(newowner->GetGUID().IsPlayer(), "Trying to set a non-player as owner!!!");
+    //ASSERT(master->GetGUID() == me->GetGUID());
+    //ASSERT(IAmFree());
+
+    //have master already
+    if (master->GetGUID() != me->GetGUID())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): bot %s (id: %u) has master %s while trying to set to %s...",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+    if (!IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): minion bot %s (id: %u) IS NOT FREE (has master %s) while trying to set to %s",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+
+    BotMgr* mgr = newowner->GetBotMgr();
+    if (!mgr)
+        mgr = new BotMgr(newowner);
+
+    bool takeMoney = (_ownerGuid != newowner->GetGUID().GetCounter());
+    if (mgr->AddBot(me, takeMoney) & BOT_ADD_FATAL)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): player %s (%s) can't add bot %s (FATAL), removing...",
+        //    master->GetName().c_str(), master->GetGUID().ToString().c_str(), me->GetName().c_str());
+        //failed to add bot
+        //if (_ownerGuid)
+        //{
+        //    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //    //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        //    stmt->setUInt32(0, uint32(0));
+        //    stmt->setUInt32(1, me->GetEntry());
+        //    CharacterDatabase.Execute(stmt);
+        //}
+
+        if (_ownerGuid)
+        {
+            TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): %s's master %s (%s) is found but bot failed to set owner (fatal)! Unbinding bot temporarily (until server restart)...",
+                me->GetName().c_str(), newowner->GetName().c_str(), newowner->GetGUID().ToString().c_str());
+            //_ownerGuid = 0;
+
+            SetBotCommandState(BOT_COMMAND_FULLSTOP); //prevent all actions
+            me->SetStandState(UNIT_STAND_STATE_SLEEP);
+            return false;
+        }
+
+        checkMasterTimer = 30000;
+        ResetBotAI(BOTAI_RESET_LOST);
+        return false;
+    }
+
+    spawned = false;
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 &= ~(UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->ReplaceAllUnitFlags2(UnitFlags2(me->GetCreatureTemplate()->unit_flags2));
+
+    //recursive
+    if (master->GetGUID() == newowner->GetGUID())
+        return true;
+
+    master = newowner;
+    _ownerGuid = newowner->GetGUID().GetCounter();
+
+    ASSERT(me->IsInWorld());
+    AbortTeleport();
+    return true;
+}
+//Check if should totally unlink from owner
+void bot_ai::CheckOwnerExpiry()
+{
+    if (!BotMgr::GetOwnershipExpireTime())
+        return; //disabled
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData, "bot_ai::CheckOwnerExpiry(): data not found!");
+
+    NpcBotExtras const* npcBotExtra = BotDataMgr::SelectNpcBotExtras(me->GetEntry());
+    ASSERT(npcBotExtra, "bot_ai::CheckOwnerExpiry(): extra data not found!");
+
+    if (npcBotData->owner == 0)
+        return;
+
+    ObjectGuid ownerGuid = ObjectGuid(HighGuid::Player, 0, npcBotData->owner);
+    time_t timeNow = time(0);
+    time_t expireTime = time_t(BotMgr::GetOwnershipExpireTime());
+    uint32 accId = sCharacterCache->GetCharacterAccountIdByGuid(ownerGuid);
+    QueryResult result = accId ? LoginDatabase.PQuery("SELECT UNIX_TIMESTAMP(last_login) FROM account WHERE id = %u", accId) : nullptr;
+
+    Field* fields = result ? result->Fetch() : nullptr;
+    time_t lastLoginTime = fields ? time_t(fields[0].GetUInt32()) : timeNow;
+
+    //either expired or owner does not exist
+    if (timeNow >= lastLoginTime + expireTime)
+    {
+        std::string name = "unknown";
+        sCharacterCache->GetCharacterNameByGuid(ownerGuid, name);
+        TC_LOG_DEBUG("server.loading", ">> %s's (guid: %u) ownership over bot %s (%u) has expired!",
+            name.c_str(), npcBotData->owner, me->GetName().c_str(), me->GetEntry());
+
+        //send all items back
+        CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+        //        0            1                2      3         4        5      6             7                 8           9           10    11    12         13
+        //"SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid, itemEntry, owner_guid "
+        //  "FROM item_instance WHERE guid IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_SYNCH
+
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            stmt->setUInt32(i, npcBotData->equips[i]);
+
+        PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+        if (iiresult)
+        {
+            std::vector<Item*> items;
+
+            do
+            {
+                Field* fields2 = iiresult->Fetch();
+                uint32 itemGuidLow = fields2[11].GetUInt32();
+                uint32 itemId = fields2[12].GetUInt32();
+                Item* item = new Item;
+                ASSERT(item->LoadFromDB(itemGuidLow, ownerGuid, fields2, itemId));
+                items.push_back(item);
+
+            } while (iiresult->NextRow());
+
+            CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+            while (!items.empty())
+            {
+                static const std::string subject = LocalizedNpcText(nullptr, BOT_TEXT_OWNERSHIP_EXPIRED);
+                MailDraft draft(subject, "");
+                for (uint8 i = 0; !items.empty() && i < MAX_MAIL_ITEMS; ++i)
+                {
+                    Item* item = items.back();
+                    items.pop_back();
+                    item->SetOwnerGUID(ownerGuid);
+                    item->FSetState(ITEM_CHANGED);
+                    item->SaveToDB(trans);
+                    draft.AddItem(item);
+                }
+                draft.SendMailTo(trans, MailReceiver(npcBotData->owner), MailSender(me, MAIL_STATIONERY_GM));
+            }
+            CharacterDatabase.CommitTransaction(trans);
+
+            BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_EQUIPS, _equips);
+        }
+
+        //hard reset owner
+        uint32 newOwner = 0;
+        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+        //...roles
+        uint32 roleMask = DefaultRolesForClass(npcBotExtra->bclass);
+        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_ROLES, &roleMask);
+        //...and spec
+        uint8 spec = DefaultSpecForClass(npcBotExtra->bclass);
+        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_SPEC, &spec);
+    }
+}
+
+void bot_ai::InitUnitFlags()
+{
+    if (BotMgr::DisplayEquipment() == true && CanDisplayNonWeaponEquipmentChanges())
+    {
+        (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE;
+        me->ReplaceAllUnitFlags2(UnitFlags2(me->GetCreatureTemplate()->unit_flags2));
+    }
+    (const_cast<CreatureMovementData&>(me->GetMovementTemplate())).Chase = CreatureChaseMovementType::CanWalk;
+}
+
+void bot_ai::ResetBotAI(uint8 resetType)
+{
+    //ASSERT(me->IsInWorld());
+
+    m_botCommandState = BOT_COMMAND_FOLLOW;
+    _botAwaitState = BOT_AWAIT_NONE;
+
+    master = reinterpret_cast<Player*>(me);
+    if (resetType & BOTAI_RESET_MASK_ABANDON_MASTER)
+        _ownerGuid = 0;
+    if (resetType == BOTAI_RESET_INIT)
+        CheckOwnerExpiry();
+    if (resetType == BOTAI_RESET_LOGOUT)
+        _saveStats();
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 |= (UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->ReplaceAllUnitFlags2(UnitFlags2(me->GetCreatureTemplate()->unit_flags2));
+
+    if (resetType == BOTAI_RESET_DISMISS)
+        EnableAllSpells();
+
+    //me->IsAIEnabled = true;
+    canUpdate = true;
+
+    if (spawned)
+        ReturnHome();
+
+    if (!me->IsInWorld())
+    {
+        AbortTeleport();
+
+        //if no master - will teleport to spawn position
+        //otherwise - will teleport to master
+        teleHomeEvent = new TeleportHomeEvent(this);
+        Events.AddEvent(teleHomeEvent, Events.CalculateTime(std::chrono::milliseconds(0))); //make sure event will be deleted
+        if (teleHomeEvent->IsActive())
+            teleHomeEvent->ScheduleAbort(); //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+    }
+    else
+    {
+        _atHome = false;
+        spawned = false;
+    }
+}
+
+bool bot_ai::_checkImmunities(Unit const* target, SpellInfo const* spellInfo) const
+{
+    return target && spellInfo && !target->IsImmunedToDamage(spellInfo);
+}
+
+SpellCastResult bot_ai::CheckBotCast(Unit const* victim, uint32 spellId) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->IsGameMaster())
+        return SPELL_FAILED_BAD_TARGETS;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (me->IsMounted() && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED))
+        return SPELL_FAILED_NOT_MOUNTED;
+
+    if (me->GetMap()->IsDungeon() && spellInfo->CastTimeEntry && !CCed(me, true) && IsWithinAoERadius(*me))
+    {
+        int32 castTime = spellInfo->CastTimeEntry->Base;
+        if (castTime > 0)
+            ApplyClassSpellCastTimeMods(spellInfo, castTime);
+
+        if (castTime > 0)
+            return SPELL_FAILED_NOT_IDLE;
+    }
+
+    if (int32(me->GetPower(spellInfo->PowerType)) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_NO_POWER;
+
+    if (!IsSpellReady(spellInfo->GetFirstRankSpell()->Id, lastdiff, false))
+        return SPELL_FAILED_NOT_READY;
+
+    //if (victim->isType(TYPEMASK_UNIT) && InDuel(victim))
+    //    return SPELL_FAILED_BAD_TARGETS;
+
+    if (!CanBotAttackOnVehicle())
+        return SPELL_FAILED_CASTER_AURASTATE;
+
+    //forced to follow but not close enough to master
+    if (!IAmFree() && !master->GetBotMgr()->GetBotAllowCombatPositioning())
+    {
+        Position mpos;
+        _calculatePos(mpos);
+
+        if (me->GetDistance(mpos) > float(std::max<uint8>(5, master->GetBotMgr()->GetBotFollowDist() / 8)))
+            return SPELL_FAILED_NOT_IDLE;
+    }
+
+    //scaling aura
+    if (victim->isType(TYPEMASK_UNIT) && victim != me &&
+        !spellInfo->IsPassive() && spellInfo->SpellLevel && !spellInfo->IsChanneled() &&
+        (victim->GetLevel() + 10) < int32(spellInfo->GetFirstRankSpell()->SpellLevel))
+    {
+        for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->_effects[i].Effect == SPELL_EFFECT_APPLY_AURA && spellInfo->IsPositiveEffect(i))
+            {
+                //TC_LOG_ERROR("scripts", "CheckBotCast(): deny cast of %s by %s on low-level target %s (lvl %u)",
+                //    spellInfo->SpellName[0], me->GetName().c_str(), victim->GetName().c_str(), victim->GetLevel());
+                return SPELL_FAILED_LOWLEVEL;
+            }
+        }
+    }
+
+    //disarmed
+    if (spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON)
+    {
+        if (spellInfo->EquippedItemInventoryTypeMask != 0)
+        {
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1<<INVTYPE_WEAPONMAINHAND)) &&
+                !me->CanUseAttackType(BASE_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1<<INVTYPE_WEAPONOFFHAND)) &&
+                !me->CanUseAttackType(OFF_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & ((1<<INVTYPE_RANGED)|(1<<INVTYPE_RANGEDRIGHT)|(1<<INVTYPE_THROWN))) &&
+                !me->CanUseAttackType(RANGED_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+        else if (!me->CanUseAttackType(BASE_ATTACK))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+    }
+
+    //immunities
+    if (victim->isType(TYPEMASK_UNIT))
+    {
+        if (spellInfo->HasEffect(SPELL_EFFECT_HEAL) || spellInfo->HasAura(SPELL_AURA_PERIODIC_HEAL))
+        {
+            //banish or something
+            Unit::AuraEffectList const& healPctEffects = victim->GetAuraEffectsByType(SPELL_AURA_MOD_HEALING_PCT);
+            if (!healPctEffects.empty())
+            {
+                int32 castTime = spellInfo->CastTimeEntry ? spellInfo->CastTimeEntry->Base : 0;
+                if (castTime)
+                    ApplyClassSpellCastTimeMods(spellInfo, castTime);
+                for (Unit::AuraEffectList::const_iterator itr = healPctEffects.begin(); itr != healPctEffects.end(); ++itr)
+                    if ((*itr)->GetAmount() <= -100 && (!castTime || (*itr)->GetBase()->GetDuration() >= castTime))
+                        return SPELL_FAILED_BAD_TARGETS;
+            }
+        }
+        else if (//spells that ignore immunities
+            spellId != 64382 && //shattering throw
+            spellId != 32375 && //mass dispel
+            !_checkImmunities(victim, spellInfo))
+            return SPELL_FAILED_BAD_TARGETS;
+    }
+
+    switch (_botclass)
+    {
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_WARRIOR: //BladeStorm
+        case BOT_CLASS_BM: //BladeStorm PLACEHOLDER
+        case BOT_CLASS_ROGUE: //Killing Spree
+            if (me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+        case BOT_CLASS_NECROMANCER:
+        case BOT_CLASS_SEA_WITCH:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "CheckBotCast(): Unknown bot class %u", _botclass);
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered)
+{
+    return doCast(victim, spellId, triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags)
+{
+    if (spellId == 0) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+    if (IsCasting()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    //select aura level
+    if (victim->isType(TYPEMASK_UNIT))
+    {
+        if (SpellInfo const* actualSpellInfo = m_botSpellInfo->GetAuraRankForLevel(victim->GetLevel()))
+            m_botSpellInfo = actualSpellInfo;
+
+        if (!m_botSpellInfo->IsTargetingArea())
+        {
+            uint8 approximateAuraEffectMask = 0;
+            uint8 nonAuraEffectMask = 0;
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                if (m_botSpellInfo->_effects[i].IsAura())
+                    approximateAuraEffectMask |= 1 << i;
+                else if (m_botSpellInfo->_effects[i].IsEffect())
+                    nonAuraEffectMask |= 1 << i;
+            }
+
+            for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                // check if target already has the same type, but more powerful aura
+                if (!nonAuraEffectMask && (approximateAuraEffectMask & (1 << i)))
+                    if (!victim->IsHighestExclusiveAuraEffect(m_botSpellInfo, AuraType(m_botSpellInfo->_effects[i].ApplyAuraName),
+                        m_botSpellInfo->_effects[i].CalcValue(me, &m_botSpellInfo->_effects[i].BasePoints), approximateAuraEffectMask, false))
+                        return false;
+            }
+        }
+
+        if ((flags & TRIGGERED_FULL_MASK) != TRIGGERED_FULL_MASK &&
+            !(m_botSpellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS) &&
+            !IsInBotParty(victim) && !me->IsWithinLOSInMap(victim))
+            return false;
+    }
+
+    //check wrong spell interruption attempts
+    if (/*victim->isType(TYPEMASK_UNIT) && */!HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) &&
+        !CastingUnitCheck::CastInterruptionCheck(victim, m_botSpellInfo))
+        return false;
+
+    //for debug only
+    if (victim->isType(TYPEMASK_UNIT) && !victim->IsAlive() &&
+        !(m_botSpellInfo->AttributesEx2 & SPELL_ATTR2_CAN_TARGET_DEAD) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_RESURRECT) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_RESURRECT_NEW) &&
+        !m_botSpellInfo->HasEffect(SPELL_EFFECT_SELF_RESURRECT))
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::doCast(): %s (bot class %u) tried to cast spell %u on a dead target %s",
+            me->GetName().c_str(), _botclass, spellId, victim->GetName().c_str());
+        //return false;
+    }
+
+    //spells with cast time
+    if (me->isMoving() && !HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) && !HasBotCommandState(BOT_COMMAND_STAY) &&
+        ((m_botSpellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_MOVEMENT)
+        //autorepeat spells missing SPELL_INTERRUPT_FLAG_MOVEMENT
+        || spellId == SHOOT_WAND
+        //channeled spells missing SPELL_INTERRUPT_FLAG_MOVEMENT
+        //Mind Flay (Rank 8)
+        || spellId == 48155) &&
+        !(m_botSpellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING) && !m_botSpellInfo->IsAutoRepeatRangedSpell() &&
+        !(flags & TRIGGERED_CAST_DIRECTLY) && (m_botSpellInfo->IsChanneled() || m_botSpellInfo->CalcCastTime()))
+    {
+        if (JumpingOrFalling())
+            return false;
+        if (!me->GetVictim() && me->IsInWorld() && (me->GetMap()->IsRaid() || me->GetMap()->IsHeroic()))
+            return false;
+        if (!m_botSpellInfo->HasEffect(SPELL_EFFECT_HEAL) && Rand() > (IAmFree() ? 80 : 50))
+            return false;
+
+        //if (m_botSpellInfo->IsChanneled())
+        //    TC_LOG_ERROR("entities.player", "bot_ai::doCast(): spell %u interrupts movement", spellId);
+        me->BotStopMovement();
+    }
+
+    if ((!victim->isType(TYPEMASK_UNIT) || IsInBotParty(victim)) && !victim->IsWithinLOSInMap(me) &&
+        !HasBotCommandState(BOT_COMMAND_STAY) && !me->GetVehicle())
+    {
+        if (!IAmFree())
+        {
+            if (me->GetDistance(victim) > 10.f)
+            {
+                Position pos = victim->GetPosition();
+                //victim->GetPosition(&pos);
+                BotMovement(BOT_MOVE_POINT, &pos);
+                //me->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            }
+            else
+                me->Relocate(victim);
+        }
+        else
+            return false;
+    }
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            if (!removeShapeshiftForm())
+                return false;
+    }
+
+    //CHECKS PASSED, NOW DO IT
+
+    if (me->GetStandState() == UNIT_STAND_STATE_SIT && !(m_botSpellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING))
+    {
+        if (!doMana && me->HasInterruptFlag(AURA_INTERRUPT_FLAG_NOT_SEATED))
+            UpdateMana();
+
+        feast_health = false;
+        feast_mana = false;
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+
+    //debug
+    //TC_LOG_ERROR("entities.player", "CheckBotCast(): %s (%u) by %s on %s", m_botSpellInfo->SpellName[0], spellId, me->GetName().c_str(), victim->GetName().c_str());
+
+    bool triggered = (flags & TRIGGERED_CAST_DIRECTLY);
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags);
+    spell->prepare(targets); //sets current spell if succeed
+/*
+    SpellCastResult result = spell->CheckCast(true);
+    if (result != SPELL_CAST_OK)
+        TC_LOG_ERROR("entities.player", "doCast(): %s (%u) by %s on %s failed with %u",
+        m_botSpellInfo->SpellName[0], spellId, me->GetName().c_str(), victim->GetName().c_str(), uint32(result));
+*/
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        if (HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) &&
+            !_orders.empty() && _orders.front()._type == BOT_ORDER_SPELLCAST &&
+            _orders.front().params.spellCastParams.baseSpell == m_botSpellInfo->GetFirstRankSpell()->Id)
+        {
+            if (DEBUG_BOT_ORDERS)
+                TC_LOG_ERROR("entities.player", "doCast(): ordered spell %u is not casted!", m_botSpellInfo->Id);
+            CancelOrder(_orders.front());
+        }
+
+        return false;
+    }
+
+    if (triggered)
+        return true;
+    if (m_botSpellInfo->IsPassive() || m_botSpellInfo->IsCooldownStartedOnEvent())
+        return true;
+    if (!m_botSpellInfo->StartRecoveryCategory || !m_botSpellInfo->StartRecoveryTime)
+        return true;
+
+    float gcd = float(m_botSpellInfo->StartRecoveryTime);
+
+    ApplyBotSpellGlobalCooldownMods(m_botSpellInfo, gcd);
+    //Apply haste to cooldown
+    if (haste && m_botSpellInfo->StartRecoveryCategory == 133 && m_botSpellInfo->StartRecoveryTime == 1500 &&
+        m_botSpellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE && m_botSpellInfo->DmgClass != SPELL_DAMAGE_CLASS_RANGED &&
+        !(m_botSpellInfo->Attributes & (SPELL_ATTR0_REQ_AMMO|SPELL_ATTR0_ABILITY)))
+        ApplyBotPercentModFloatVar(gcd, float(haste), false);
+
+    //if cast time is lower than 1.5 sec it also reduces gcd but only if not instant
+    if (m_botSpellInfo->CastTimeEntry)
+    {
+        if (int32 castTime = m_botSpellInfo->CastTimeEntry->Base)
+        {
+            if (castTime > 0)
+            {
+                ApplyClassSpellCastTimeMods(m_botSpellInfo, castTime);
+                if (castTime < gcd)
+                    gcd = float(castTime);
+            }
+        }
+    }
+
+    GC_Timer = uint32(gcd);
+    //global cd cannot be less than 1000 ms
+    GC_Timer = std::max<uint32>(GC_Timer, 1000);
+    //global cd cannot be greater than 1500 ms
+    GC_Timer = std::min<uint32>(GC_Timer, 1500);
+
+    return true;
+}
+//Follow point calculation
+void bot_ai::_calculatePos(Position& pos) const
+{
+    ASSERT(!IAmFree());
+
+    uint8 followdist = master->GetBotMgr()->GetBotFollowDist();
+    float mydist, angle;
+
+    if (HasRole(BOT_ROLE_TANK) && !IsTank(master))
+    {
+        uint8 tanks = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_TANK, me);
+        angle = float(M_PI) / 6.0f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / tanks) * (slot - (slot % 2)); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        mydist = 3.5f;
+    }
+    else if (HasRole(BOT_ROLE_RANGED))
+    {
+        uint8 rangeds = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_RANGED);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_RANGED, me);
+        angle = float(M_PI) / 3.5f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / rangeds) * (slot - (slot % 2)); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        angle += float(M_PI); //behind
+        mydist = 1.0f;
+    }
+    else if (HasRole(BOT_ROLE_DPS))
+    {
+        uint8 dpss = master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_DPS);
+        uint8 slot = master->GetBotMgr()->GetNpcBotSlotByRole(BOT_ROLE_DPS, me);
+        angle = float(M_PI) / 7.5f; //max bias (left of right) //total arc is angle * 2
+        angle = (angle / dpss) * (slot); //bias
+        if (slot % 2) angle *= -1.f; //bias interchange
+        angle += float(((slot % 4) < 2) ? (M_PI/2.f) : -(M_PI/2.f)); //sides
+        mydist = 2.0f;
+    }
+    else
+    {
+        angle = float((me->GetEntry() % 2) ? (M_PI/2.f) : -(M_PI/2.f));
+        mydist = 0.5f;
+    }
+
+    mydist += std::max<int32>(int32(followdist) - 30, 5) / 7.f; //1.f-10.f
+    mydist = std::max<float>(mydist - 2.f, 0.0f); //get bots closer
+
+    if (me->GetVehicle())
+        mydist *= 2.f;
+
+    Position mpos;
+    Unit const* bmover = me->GetVehicle() ? me->GetVehicleBase() : me;
+    Unit* mmover = master->GetVehicle() ? master->GetVehicleBase() : master;
+    uint32 movFlags = mmover->m_movementInfo.GetMovementFlags();
+    float size = bmover->GetCombatReach() * 2;
+    if (bmover->CanFly())
+    {
+        angle += mmover->GetOrientation();
+        float &x = mpos.m_positionX, &y = mpos.m_positionY, &z = mpos.m_positionZ;
+        bool over = false;
+        for (uint8 i = 0; i != 5 + over; ++i)
+        {
+            if (over)
+            {
+                mydist *= 0.2f;
+                break;
+            }
+            mmover->GetNearPoint(bmover, x, y, z, mydist, angle);
+            if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+            {
+                mydist *= 0.4f - float(i*0.07f);
+                size *= 0.1f;
+                if (size < 0.1)
+                    size = 0.f;
+            }
+            else
+                over = true;
+        }
+    }
+    else
+        mpos = mmover->GetFirstCollisionPosition(mydist+size, angle);
+
+    if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & MOVEMENTFLAG_FALLING_FAR))
+    {
+        float const aheadDist = std::max<float>(followdist * 0.08f, 6.f);
+        float tx = mpos.m_positionX + aheadDist * std::cos(mmover->GetOrientation());
+        float ty = mpos.m_positionY + aheadDist * std::sin(mmover->GetOrientation());
+        float tz = mpos.m_positionZ;
+        if (!bmover->CanFly())
+            bmover->UpdateAllowedPositionZ(tx, ty, tz);
+        if (mmover->IsWithinLOS(tx, ty, tz))
+            mpos.Relocate(tx, ty, tz);
+    }
+
+    if (me->GetPositionZ() < mpos.GetPositionZ())
+        mpos.m_positionZ += 0.5f; //prevent going underground while moving
+
+    pos.Relocate(mpos);
+
+    //         TTT
+    //      m       m
+    //     m    M    m
+    //      m       m
+    //        rrrrr
+    //
+    //M - master
+    //T - bot tank (ROLE_TANK)
+    //r - ranged (ROLE_RANGED)
+    //m - melee (ROLE_DPS)
+}
+// Movement set
+// Uses MovePoint() for following instead of MoveFollow()
+// This helps bots overcome a bug with fanthom walls on grid borders blocking pathing
+void bot_ai::BotMovement(BotMovementType type, Position const* pos, Unit* target, bool generatePath) const
+{
+    Vehicle* veh = me->GetVehicle();
+    VehicleSeatEntry const* seat = veh ? veh->GetSeatForPassenger(me) : nullptr;
+    bool canControl = seat ? (seat->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL) : false;
+    Unit* mover = canControl ? veh->GetBase() : !veh ? me : nullptr;
+    if (!mover)
+        return;
+
+    switch (type)
+    {
+        case BOT_MOVE_CHASE:
+            ASSERT(target);
+            mover->GetMotionMaster()->MoveChase(target);
+            break;
+        case BOT_MOVE_POINT:
+            mover->GetMotionMaster()->MovePoint(mover->GetMapId(), *pos, generatePath);
+            break;
+        default:
+            TC_LOG_ERROR("scripts", "BotMovement: unhandled bot movement type %u", uint32(type));
+            return;
+    }
+}
+bool bot_ai::CanBotMoveVehicle() const
+{
+    if (VehicleSeatEntry const* seat = me->GetVehicle() ? me->GetVehicle()->GetSeatForPassenger(me) : nullptr)
+        return seat->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL;
+
+    return false;
+}
+
+void bot_ai::SetBotAwaitState(uint8 state)
+{
+    if (HasBotAwaitState(state))
+        return;
+
+    if (!me->IsAlive())
+        return;
+
+    _botAwaitState |= state;
+
+    AbortAwaitStateRemoval();
+    awaitStateRemEvent = new AwaitStateRemovalEvent(this, state);
+    Events.AddEvent(awaitStateRemEvent, Events.CalculateTime(30s));
+}
+
+void bot_ai::EventRemoveBotAwaitState(uint8 state)
+{
+    AbortAwaitStateRemoval();
+    RemoveBotAwaitState(state);
+}
+
+void bot_ai::AbortAwaitStateRemoval()
+{
+    if (awaitStateRemEvent)
+    {
+        if (awaitStateRemEvent->IsActive())
+            awaitStateRemEvent->ScheduleAbort();
+        awaitStateRemEvent = nullptr;
+    }
+}
+
+void bot_ai::SetBotCommandState(uint8 st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    Vehicle* veh = me->GetVehicle();
+    VehicleSeatEntry const* seat = veh ? veh->GetSeatForPassenger(me) : nullptr;
+    bool canControl = seat ? (seat->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL) : false;
+    Unit* mover = canControl ? veh->GetBase() : !veh ? me : nullptr;
+    if (mover)
+    {
+        if ((st & BOT_COMMAND_FOLLOW) && !IsChanneling() &&
+            ((!mover->isMoving() && !IsCasting() && master->IsAlive() && !Feasting()) || force))
+        {
+            if (!me->IsInMap(master)) return;
+            if (CCed(mover, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+            //if (mover->isMoving() && Rand() > 10) return;
+            if (!newpos)
+                _calculatePos(movepos);
+            else
+            {
+                movepos.m_positionX = newpos->m_positionX;
+                movepos.m_positionY = newpos->m_positionY;
+                movepos.m_positionZ = newpos->m_positionZ;
+            }
+            if (me->GetStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+            if (IsShootingWand())
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            BotMovement(BOT_MOVE_POINT, &movepos);
+            //me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+            //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+            RemoveBotCommandState(BOT_COMMAND_STAY | BOT_COMMAND_FULLSTOP | BOT_COMMAND_ATTACK | BOT_COMMAND_COMBATRESET);
+        }
+        else if (st & BOT_COMMAND_FULLSTOP)
+        {
+            RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_STAY | BOT_COMMAND_ATTACK);
+            me->AttackStop();
+            me->InterruptNonMeleeSpells(true);
+            if (mover != me->ToUnit())
+            {
+                mover->AttackStop();
+                mover->InterruptNonMeleeSpells(true);
+            }
+            if (mover->isMoving())
+                mover->ToCreature()->BotStopMovement();
+        }
+        else if (st & BOT_COMMAND_STAY)
+        {
+            RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_FULLSTOP);
+            if (mover->isMoving())
+                mover->ToCreature()->BotStopMovement();
+        }
+        else if (st & BOT_COMMAND_ATTACK)
+        {
+            RemoveBotCommandState(BOT_COMMAND_FOLLOW);
+        }
+        else if (st & BOT_COMMAND_COMBATRESET)
+        {
+            RemoveBotCommandState(BOT_COMMAND_ATTACK);
+        }
+    }
+
+    m_botCommandState |= st;
+}
+
+void bot_ai::RemoveBotCommandState(uint8 st)
+{
+    m_botCommandState &= ~st;
+}
+
+bool bot_ai::IsPointedTarget(Unit const* target, uint8 targetFlags) const
+{
+    if (Group const* gr = (IAmFree() ? nullptr : master->GetGroup()))
+        if (targetFlags)
+            for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+                if (targetFlags & GroupIconsFlags[i])
+                    if (target->GetGUID() == gr->GetTargetIcons()[i])
+                        return true;
+
+    return false;
+}
+bool bot_ai::IsPointedHealTarget(Unit const* target) const
+{
+    return IsPointedTarget(target, BotMgr::GetHealTargetIconFlags());
+}
+//unused
+bool bot_ai::IsPointedTankingTarget(Unit const* target) const
+{
+    return IsPointedTarget(target, BotMgr::GetOffTankTargetIconFlags());
+}
+//unused
+bool bot_ai::IsPointedDPSTarget(Unit const* target) const
+{
+    return IsPointedTarget(target, BotMgr::GetDPSTargetIconFlags());
+}
+//unused
+bool bot_ai::IsPointedRangedDPSTarget(Unit const* target) const
+{
+    return IsPointedTarget(target, BotMgr::GetRangedDPSTargetIconFlags());
+}
+bool bot_ai::IsPointedNoDPSTarget(Unit const* target) const
+{
+    return IsPointedTarget(target, BotMgr::GetNoDPSTargetIconFlags());
+}
+bool bot_ai::IsPointedAnyAttackTarget(Unit const* target) const
+{
+    return IsPointedTarget(target, BotMgr::GetOffTankTargetIconFlags() | BotMgr::GetDPSTargetIconFlags() | BotMgr::GetRangedDPSTargetIconFlags());
+}
+// Buffs And Heal (really)
+// Priority as follows: 1) heal players 2) buff players 3) heal bots 4) buff bots
+// Priority adjustments to be considered
+void bot_ai::BuffAndHealGroup(uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        //heals
+        //if (HealTarget(me, diff))
+        //    return;
+        //if (botPet)
+        //{
+        //    if (botPet->IsAlive())
+        //    {
+        //        if (HealTarget(botPet, diff))
+        //            return;
+        //    }
+        //}
+
+        bool omniHostile = (me->GetFaction() == 14 || me->HasAura(BERSERK));
+
+        //if (!omniHostile && HasRole(BOT_ROLE_HEAL))
+        //{
+        //    std::list<Unit*> targets1;
+        //    GetNearbyFriendlyTargetsList(targets1, 38);
+        //    targets1.remove_if(BOTAI_PRED::HealTargetExclude());
+        //    if (!targets1.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets1), diff))
+        //        return;
+        //}
+
+        //buffs
+        if (BuffTarget(me, diff))
+            return;
+
+        if (!omniHostile)
+        {
+            std::list<Unit*> targets2;
+            GetNearbyFriendlyTargetsList(targets2, 30);
+            targets2.remove_if(BOTAI_PRED::BuffTargetExclude());
+            for (std::list<Unit*>::const_iterator itr = targets2.begin(); itr != targets2.end(); ++itr)
+                if (urand(1,100) <= 30 && BuffTarget(*itr, diff))
+                    return;
+        }
+
+        return;
+    }
+
+    BotMap const* map;
+    Group const* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        //heals
+        map = master->GetBotMgr()->GetBotMap();
+        if (HasRole(BOT_ROLE_HEAL))
+        {
+            std::list<Unit*> targets3;
+            if (master->IsAlive() && !master->HasUnitState(UNIT_STATE_ISOLATED) && GetHealthPCT(master) < 95 && me->GetDistance(master) < 40)
+                targets3.push_back(master);
+            if (master->GetVehicleBase() && !(master->GetVehicleBase()->GetTypeId() == TYPEID_UNIT &&
+                master->GetVehicleCreatureBase()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                !master->GetVehicleBase()->HasUnitState(UNIT_STATE_ISOLATED) && GetHealthPCT(master->GetVehicleBase()) < 95 &&
+                me->GetDistance(master->GetVehicleBase()) < 40)
+                targets3.push_back(master->GetVehicleBase());
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Unit* u = itr->second;
+                if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                    u->ToCreature()->IsTempBot() || me->GetDistance(u) > 40 ||
+                    (GetHealthPCT(u) > 95 && !IsTank(u))))
+                    targets3.push_back(u);
+
+                u = itr->second->GetBotsPet();
+
+                if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 40 || GetHealthPCT(u) > 95))
+                    targets3.push_back(u);
+
+                u = itr->second->GetVehicleBase();
+                if (u && !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                    !u->HasUnitState(UNIT_STATE_ISOLATED) && GetHealthPCT(u) < 95 && me->GetDistance(u) < 40)
+                    targets3.push_back(u);
+            }
+            for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                    u->IsTotem() || u->GetEntry() == SHAMAN_EARTH_ELEMENTAL || me->GetDistance(u) > 40 ||
+                    (GetHealthPCT(u) > 95 && !IsTank(u)))
+                    continue;
+
+                targets3.push_back(u);
+            }
+
+            if (!targets3.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets3), diff))
+                return;
+        }
+        //buffs
+        std::list<Unit*> targets4;
+        if (master->IsAlive() && me->GetDistance(master) < 30)
+            targets4.push_back(master);
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Unit* u = itr->second;
+            if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                u->IsTotem() || me->GetDistance(u) > 30))
+                targets4.push_back(u);
+
+            //u = itr->second->GetBotsPet();
+
+            //if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 30))
+            //    targets4.push_back(u);
+        }
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                u->IsTotem() || me->GetDistance(u) > 30) continue;
+
+            targets4.push_back(u);
+        }
+
+        if (!targets4.empty() && BuffTarget(Trinity::Containers::SelectRandomContainerElement(targets4), diff))
+            return;
+
+        return;
+    }
+    bool Bots = false;
+    //heals
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        std::list<Unit*> targets5;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (tPlayer->HaveBot() && !Bots)
+                Bots = true;
+            if (!tPlayer->IsAlive() || tPlayer->HasUnitState(UNIT_STATE_ISOLATED)) continue;
+            if (me->GetDistance(tPlayer) > 40) continue;
+            if (GetHealthPCT(tPlayer) < 95 || IsTank(tPlayer))
+                targets5.push_back(tPlayer);
+            if (tPlayer->GetVehicleBase() && !(tPlayer->GetVehicleBase()->GetTypeId() == TYPEID_UNIT &&
+                tPlayer->GetVehicleCreatureBase()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                !tPlayer->GetVehicleBase()->HasUnitState(UNIT_STATE_ISOLATED) && GetHealthPCT(tPlayer->GetVehicleBase()) < 95 &&
+                me->GetDistance(tPlayer->GetVehicleBase()) < 40)
+                targets5.push_back(tPlayer->GetVehicleBase());
+        }
+        if (Bots)
+        {
+            for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* tPlayer = itr->GetSource();
+                if (tPlayer == nullptr) continue;
+                if (me->GetMap() != tPlayer->FindMap()) continue;
+
+                if (tPlayer->HaveBot())
+                {
+                    map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                    {
+                        Unit* u = bitr->second;
+                        if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                            u->ToCreature()->IsTempBot() || me->GetDistance(u) > 40 ||
+                            (GetHealthPCT(u) > 95 && !IsTank(u))))
+                            targets5.push_back(u);
+
+                        u = bitr->second->GetBotsPet();
+
+                        if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 40 || GetHealthPCT(u) > 95))
+                            targets5.push_back(u);
+
+                        u = bitr->second->GetVehicleBase();
+                        if (u && !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                            !u->HasUnitState(UNIT_STATE_ISOLATED) && GetHealthPCT(u) < 95 && me->GetDistance(u) < 40)
+                            targets5.push_back(u);
+                    }
+                }
+                for (Unit::ControlList::const_iterator bitr = master->m_Controlled.begin(); bitr != master->m_Controlled.end(); ++bitr)
+                {
+                    Unit* u = *bitr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                        u->IsTotem() || u->GetEntry() == SHAMAN_EARTH_ELEMENTAL || me->GetDistance(u) > 40 ||
+                        (GetHealthPCT(u) > 95 && !IsTank(u)))
+                        continue;
+
+                    targets5.push_back(u);
+                }
+            }
+        }
+
+        //check if we have pointed heal target
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = pGroup->GetTargetIcons()[i])
+                {
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsAlive() && !unit->HasUnitState(UNIT_STATE_ISOLATED) && me->GetMap() == unit->FindMap() && me->GetDistance(unit) < 40 &&
+                            !unit->IsFullHealth() && master->GetVictim() != unit && !IsInBotParty(unit->GetVictim()) &&
+                            unit->GetEntry() != SHAMAN_EARTH_ELEMENTAL &&
+                            !(unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetCreatureTemplate()->type == CREATURE_TYPE_MECHANICAL) &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            targets5.push_back(unit);
+                        }
+                    }
+                }
+            }
+        }
+        if (!targets5.empty() && HealTarget(Trinity::Containers::SelectRandomContainerElement(targets5), diff))
+            return;
+    }
+    //buffs
+    std::list<Unit*> targets6;
+    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == nullptr) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (tPlayer->HaveBot() && !Bots)
+            Bots = true;
+        if (!tPlayer->IsAlive() || tPlayer->HasUnitState(UNIT_STATE_ISOLATED)) continue;
+        if (me->GetDistance(tPlayer) > 30) continue;
+        targets6.push_back(tPlayer);
+    }
+    if (Bots)
+    {
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player const* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    Unit* u = bitr->second;
+                    if (!(!u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                        u->IsTotem() || me->GetDistance(u) > 30))
+                        targets6.push_back(u);
+
+                    //u = bitr->second->GetBotsPet();
+
+                    //if (!(!u || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) || me->GetDistance(u) > 30))
+                    //    targets6.push_back(u);
+                }
+            }
+            for (Unit::ControlList::const_iterator bitr = master->m_Controlled.begin(); bitr != master->m_Controlled.end(); ++bitr)
+            {
+                Unit* u = *bitr;
+                if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || u->HasUnitState(UNIT_STATE_ISOLATED) ||
+                    u->IsTotem() || me->GetDistance(u) > 30) continue;
+
+                targets6.push_back(u);
+            }
+        }
+    }
+
+    if (!targets6.empty() && BuffTarget(Trinity::Containers::SelectRandomContainerElement(targets6), diff))
+        return;
+}
+// Attempt to resurrect dead players and bots
+// Target is either bot, player or player corpse
+// no need to check global cooldown
+void bot_ai::ResurrectGroup(uint32 spell_id)
+{
+    if (!spell_id || Rand() > 10)
+        return;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell_id);
+    ASSERT(spellInfo);
+    if (int32(me->GetPower(spellInfo->PowerType)) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return;
+
+    //TC_LOG_ERROR("entities.player", "ResurrectGroup by %s", me->GetName().c_str());
+
+    if (IAmFree())
+    {
+        if (me->GetFaction() == 14 || me->HasAura(BERSERK))
+            return;
+
+        WorldObject* playerOrCorpse = GetNearbyRezTarget();
+        if (!playerOrCorpse)
+            return;
+
+        if (!playerOrCorpse->IsWithinLOSInMap(me))
+            me->Relocate(*playerOrCorpse);
+
+        Unit* target = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToUnit() : (Unit*)playerOrCorpse->ToCorpse();
+        if (doCast(target, spell_id)) //rezzing it
+        {
+            if (Player const* player = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToPlayer() : ObjectAccessor::FindPlayer(playerOrCorpse->ToCorpse()->GetOwnerGUID()))
+                BotWhisper(LocalizedNpcText(player, BOT_TEXT_REZZING_YOU), player);
+        }
+
+        return;
+    }
+
+    Group const* group = master->GetGroup();
+    std::vector<Creature*> bottargets;
+    BotMap const* map;
+    Player* player;
+    Unit* target;
+    if (!group)
+    {
+        player = master;
+        if (!player->IsAlive() && !player->IsResurrectRequested())
+        {
+            target = player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST) ? player->ToUnit() : (Unit*)player->GetCorpse();
+            if (target && target->IsInWorld() && me->GetMap() == target->FindMap() &&
+                !player->GetBotMgr()->IsBeingResurrected(target))
+            {
+                if (me->GetDistance(target) > 30 && !HasBotCommandState(BOT_COMMAND_STAY) && !me->GetVehicle())
+                {
+                    BotMovement(BOT_MOVE_POINT, target);
+                    //me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    return;
+                }
+                else if (me->GetDistance(target) < 15 && !target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, spell_id))//rezzing it
+                {
+                    BotWhisper(LocalizedNpcText(player, BOT_TEXT_REZZING_YOU));
+                    return;
+                }
+            }
+        }
+
+        map = player->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+        {
+            target = bitr->second;
+            if (!target || !target->IsInWorld() || target->IsAlive()) continue;
+            if (bitr->second->GetBotAI()->GetReviveTimer() < 15000) continue;
+            if (me->GetDistance(target) < 30 && target->IsWithinLOSInMap(me) &&
+                !player->GetBotMgr()->IsBeingResurrected(target))
+                bottargets.push_back(bitr->second);
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            player = itr->GetSource();
+            target = player;
+            if (!player || player->FindMap() != me->GetMap()) continue;
+            if (!Bots && player->HaveBot())
+                Bots = true;
+            if (player->IsAlive() || player->IsResurrectRequested()) continue;
+            if (player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                target = (Unit*)player->GetCorpse();
+            if (!target || !target->IsInWorld()) continue;
+            if (target->GetTypeId() != player->GetTypeId() && me->GetMap() != target->FindMap()) continue;
+            if (master->GetBotMgr()->IsBeingResurrected(target)) return;
+            if (me->GetDistance(target) > 30 && !HasBotCommandState(BOT_COMMAND_STAY) && !me->GetVehicle())
+            {
+                if (player == master)
+                {
+                    BotMovement(BOT_MOVE_POINT, target);
+                    //me->GetMotionMaster()->MovePoint(me->GetMapId(), *target);
+                    return;
+                }
+                continue;
+            }
+            else if (me->GetDistance(target) < 15 && !target->IsWithinLOSInMap(me))
+                me->Relocate(*target);
+
+            if (doCast(target, spell_id))//rezzing it
+            {
+                BotWhisper(LocalizedNpcText(player, BOT_TEXT_REZZING_YOU), player);
+                if (player != master)
+                    BotWhisper(LocalizedNpcText(master, BOT_TEXT_REZZING_) + player->GetName());
+                return;
+            }
+        }
+
+        if (!Bots)
+            return;
+
+        for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            player = itr->GetSource();
+            if (!player || player->FindMap() != me->GetMap() || !player->HaveBot()) continue;
+
+            map = player->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+            {
+                target = bitr->second;
+                if (!target || !target->IsInWorld() || target->IsAlive()) continue;
+                if (bitr->second->GetBotAI()->GetReviveTimer() < 15000) continue;
+                if (me->GetDistance(target) < 30 && target->IsWithinLOSInMap(me) &&
+                    !player->GetBotMgr()->IsBeingResurrected(target))
+                    bottargets.push_back(bitr->second);
+            }
+        }
+    }
+
+    //TC_LOG_ERROR("entities.unit", "ResurrectGroup: %s found %u targets", me->GetName().c_str(), uint32(bottargets.size()));
+
+    if (bottargets.empty())
+        return;
+
+    target = bottargets.size() < 2 ? bottargets.front() : Trinity::Containers::SelectRandomContainerElement(bottargets);
+
+    if (doCast(target, spell_id))
+    {
+        Player const* targetOwner = target->ToCreature()->GetBotOwner();
+        if (targetOwner != master)
+        {
+            std::string rezstr1 =
+                LocalizedNpcText(targetOwner, BOT_TEXT_REZZING_) + target->GetName() + " (" + LocalizedNpcText(targetOwner, BOT_TEXT_YOUR_BOT) + ")";
+            std::string rezstr2 =
+                LocalizedNpcText(master, BOT_TEXT_REZZING_) + target->GetName() + " (" + targetOwner->GetName() + LocalizedNpcText(master, BOT_TEXT__S_BOT) + ")";
+
+            BotWhisper(std::move(rezstr1), targetOwner);
+            BotWhisper(std::move(rezstr2));
+        }
+        else
+            BotWhisper(LocalizedNpcText(master, BOT_TEXT_REZZING_) + target->GetName());
+
+        return;
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_ai::CureGroup(uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell) return;
+    if (GC_Timer > diff) return;
+    if (me->IsMounted())
+    if (IsTank() && me->GetVictim() && me->GetMap()->IsRaid()) return;
+    if (IsCasting()) return;
+
+    if (IAmFree())
+    {
+        std::list<Unit*> cureTargets;
+
+        if (_canCureTarget(me, cureSpell))
+            cureTargets.push_back(me);
+        if (botPet && _canCureTarget(botPet, cureSpell))
+            cureTargets.push_back(botPet);
+
+        if (!(me->GetFaction() == 14 || me->HasAura(BERSERK)))
+        {
+            std::list<Unit*> targets1;
+            GetNearbyFriendlyTargetsList(targets1, 38);
+            for (std::list<Unit*>::const_iterator itr = targets1.begin(); itr != targets1.end(); ++itr)
+                if (_canCureTarget(*itr, cureSpell))
+                    cureTargets.push_back(*itr);
+        }
+
+        if (!cureTargets.empty())
+        {
+            if (doCast(Trinity::Containers::SelectRandomContainerElement(cureTargets), cureSpell))
+                return;
+        }
+
+        return;
+    }
+
+    if (!master->GetMap()->IsRaid() && Rand() > 35)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    std::list<Unit*> targets;
+    Group const* pGroup = master->GetGroup();
+    BotMap const* map;
+    Unit* u;
+    if (!pGroup)
+    {
+        if (_canCureTarget(master, cureSpell))
+            targets.push_back(master);
+
+        map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            u = itr->second;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            u = *itr;
+            if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (_canCureTarget(tPlayer, cureSpell))
+                targets.push_back(tPlayer);
+        }
+        if (!Bots) return;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    u = bitr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                    if (_canCureTarget(u, cureSpell))
+                        targets.push_back(u);
+                }
+            }
+
+            for (Unit::ControlList::const_iterator bitr = tPlayer->m_Controlled.begin(); bitr != tPlayer->m_Controlled.end(); ++bitr)
+            {
+                u = *bitr;
+                if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+                if (_canCureTarget(u, cureSpell))
+                    targets.push_back(u);
+            }
+        }
+    }
+
+    if (!targets.empty())
+    {
+        if (doCast(Trinity::Containers::SelectRandomContainerElement(targets), cureSpell))
+            return;
+    }
+}
+
+// determines if unit has something to cure
+bool bot_ai::_canCureTarget(Unit const* target, uint32 cureSpell) const
+{
+    if (me->GetLevel() < 10 || target->GetLevel() < 10) return false;
+    if (target->HasUnitState(UNIT_STATE_ISOLATED)) return false;
+    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsTempBot()) return false;
+    if (target->HasAuraType(SPELL_AURA_MOD_POSSESS) && !IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    if (me->GetDistance(target) > CalcSpellMaxRange(cureSpell, false))
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->_effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->_effects[i].MiscValue));
+
+    //SpellBreaker addins
+    if (cureSpell == SPELL_STEAL_MAGIC)
+        dispelMask |= (1<<DISPEL_MAGIC) | (1<<DISPEL_CURSE);
+
+    if (dispelMask == 0)
+        return false;
+
+    std::list<Aura const*> dispel_list;
+    _getBotDispellableAuraList(target, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_ai::_getBotDispellableAuraList(Unit const* target, uint32 dispelMask, std::list<Aura const*> &dispelList) const
+{
+    //Unholy Blight prevents diseases from being dispelled
+    if ((dispelMask & (1<<DISPEL_DISEASE)) &&
+        target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0))
+        dispelMask &= ~(1<<DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura const* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(me))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (HasRole(BOT_ROLE_HEAL) && aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            if (((aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount()) > 0)
+                dispelList.push_back(aura);
+        }
+    }
+}
+// Check if can cast some spell out of main rotation to use up target's spell reflection charges
+// Supposed to check instant non-damaging spells but these checks are not performed (Shaman, Priest)
+bool bot_ai::CanRemoveReflectSpells(Unit const* target, uint32 spellId) const
+{
+    if (!target || !spellId)
+        return false;
+
+    if (!target->HasAuraType(SPELL_AURA_REFLECT_SPELLS) && !target->HasAuraType(SPELL_AURA_REFLECT_SPELLS_SCHOOL))
+        return false;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return false;
+
+    if (!spellInfo->IsPositive() && spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+        !(spellInfo->Attributes & SPELL_ATTR0_ABILITY) && !(spellInfo->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+        !(spellInfo->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
+    {
+        //bool directDamage = false;
+        //for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        //{
+        //    if (spellInfo->_effects[i].TargetA.GetTarget() == TARGET_UNIT_TARGET_ENEMY)
+        //    {
+        //        if (spellInfo->_effects[i].IsEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+        //            spellInfo->_effects[i].IsAura(SPELL_AURA_PERIODIC_DAMAGE) ||
+        //            spellInfo->_effects[i].IsAura(SPELL_AURA_PERIODIC_LEECH) ||
+        //            spellInfo->_effects[i].IsAura(SPELL_AURA_MOD_SPEED_SLOW_ALL) ||//Icy Touch
+        //            spellInfo->_effects[i].IsAura(SPELL_AURA_HASTE_SPELLS))//Slow
+        //        {
+        //            directDamage = true;
+        //            break;
+        //        }
+        //    }
+        //}
+        //if (directDamage)
+        //{
+            Unit::AuraEffectList const& reflectAuras1 = target->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS);
+            for (Unit::AuraEffectList::const_iterator itr = reflectAuras1.begin(); itr != reflectAuras1.end(); ++itr)
+            {
+                //All existing SPELL_AURA_REFLECT_SPELLS spells have at least amount 50
+                if ((*itr)->GetBase()->IsUsingCharges() &&
+                    (*itr)->GetBase()->GetCharges() <= target->getAttackers().size() * ((*itr)->GetBase()->GetDuration() / 1000) / 4)
+                    return true;
+            }
+
+            Unit::AuraEffectList const& reflectAuras2 = target->GetAuraEffectsByType(SPELL_AURA_REFLECT_SPELLS_SCHOOL);
+            for (Unit::AuraEffectList::const_iterator itr = reflectAuras2.begin(); itr != reflectAuras2.end(); ++itr)
+            {
+                if ((*itr)->GetBase()->IsUsingCharges() &&
+                    (*itr)->GetAmount() >= 50 && ((*itr)->GetMiscValue() & spellInfo->GetSchoolMask()) &&
+                    (*itr)->GetBase()->GetCharges() <= ((*itr)->GetBase()->GetDuration() / 1000) / 4)
+                    return true;
+            }
+        //}
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player const* player, Unit const* unit) const
+{
+    //if (player->GetSession()->GetSecurity() == SEC_PLAYER) return;
+    if (!player->IsGameMaster() && (IAmFree() || !IsInBotParty(player))) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    botstring.setf(std::ios_base::fixed);
+    uint32 const bot_pet_player_class = unit->GetTypeId() == TYPEID_PLAYER ? unit->GetClass() : unit->ToCreature()->GetBotAI()->GetBotClass();
+    botstring << unit->GetName() << " (" << LocalizedNpcText(player, BOT_TEXT_CLASS) << ": " << uint32(bot_pet_player_class) << "), ";
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << LocalizedNpcText(player, BOT_TEXT_PLAYER);
+    else if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->IsNPCBot())
+    {
+        bot_ai const* ai = unit->ToCreature()->GetBotAI();
+        botstring << LocalizedNpcText(player, BOT_TEXT_MASTER) << ": ";
+        Player const* owner = ai->GetBotOwner();
+        botstring << (owner != unit ? owner->GetName() : LocalizedNpcText(player, BOT_TEXT_NONE));
+    }
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->_effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        botstring << "\n" << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        botstring << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell()))
+            rank = talentcost;
+        else if (learnSpellInfo && (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell()))
+            rank = spellInfo->GetRank();
+        else if (spellInfo->GetNextRankSpell() || spellInfo->GetPrevRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            botstring << " " << LocalizedNpcText(player, BOT_TEXT_RANK) << " " << rank;
+        if (talentcost > 0)
+            botstring << " [" << LocalizedNpcText(player, BOT_TEXT_TALENT) << "]";
+        if (spellInfo->IsPassive())
+            botstring << " [" << LocalizedNpcText(player, BOT_TEXT_PASSIVE) << "]";
+        if ((spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) ||
+            (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+            botstring << " [" << LocalizedNpcText(player, BOT_TEXT_HIDDEN) << "]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            botstring << " [" << LocalizedNpcText(player, BOT_TEXT_KNOWN) << "]";
+        else if (unit == me && GetSpell(spellInfo->GetFirstRankSpell()->Id))
+            botstring << " [" << LocalizedNpcText(player, BOT_TEXT_ABILITY) << "]";
+    }
+    botstring.precision(1);
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = LocalizedNpcText(player, BOT_TEXT_STAT_STR); break;
+            case STAT_AGILITY: mystat = LocalizedNpcText(player, BOT_TEXT_STAT_AGI); break;
+            case STAT_STAMINA: mystat = LocalizedNpcText(player, BOT_TEXT_STAT_STA); break;
+            case STAT_INTELLECT: mystat = LocalizedNpcText(player, BOT_TEXT_STAT_INT); break;
+            case STAT_SPIRIT: mystat = LocalizedNpcText(player, BOT_TEXT_STAT_SPI); break;
+            default: mystat = LocalizedNpcText(player, BOT_TEXT_STAT_UNK); break;
+        }
+        //ch.PSendSysMessage("base %s: %.1f", mystat.c_str(), unit->GetCreateStat(Stats(i));
+        float totalstat = unit->GetTotalStatValue(Stats(i));
+        //ch.PSendSysMessage("base total %s: %.1f", mystat.c_str(), totalstat);
+        if (unit == me)
+        {
+            BotStatMods t = MAX_BOT_ITEM_MOD;
+            switch (i)
+            {
+                case STAT_STRENGTH:     t = BOT_STAT_MOD_STRENGTH;  break;
+                case STAT_AGILITY:      t = BOT_STAT_MOD_AGILITY;   break;
+                case STAT_STAMINA:      t = BOT_STAT_MOD_STAMINA;   break;
+                case STAT_INTELLECT:    t = BOT_STAT_MOD_INTELLECT; break;
+                case STAT_SPIRIT:       t = BOT_STAT_MOD_SPIRIT;    break;
+                default:                                            break;
+            }
+
+            if (t < MAX_BOT_ITEM_MOD)
+                totalstat = GetTotalBotStat(t);
+        }
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_TOTAL) << " " << mystat << ": " << float(totalstat);
+    }
+    botstring.precision(2);
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_MELEE_AP) << ": " << int32(unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_RANGED_AP) << ": " << int32(unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_ARMOR) << ": " << uint32(unit->GetArmor());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_CRIT) << ": " << float(unit->GetUnitCriticalChanceDone(BASE_ATTACK));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DEFENSE) << ": " << uint32(unit->GetDefenseSkillValue());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_MISS) << ": " << float(unit->GetUnitMissChance());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DODGE) << ": " << float(unit->GetUnitDodgeChance(BASE_ATTACK, me));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_PARRY) << ": " << float(unit->GetUnitParryChance(BASE_ATTACK, me));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_BLOCK) << ": " << float(unit->GetUnitBlockChance(BASE_ATTACK, me));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_BLOCKVALUE) << ": " << uint32(unit->GetShieldBlockValue());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_TAKEN_MELEE) << ": " << float(dmg_taken_phy * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_TAKEN_SPELL) << ": " << float(dmg_taken_mag * unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+
+    WeaponAttackType type = BASE_ATTACK;
+    float attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_RANGE_MAINHAND) << ": " << LocalizedNpcText(player, BOT_TEXT_MIN) << ": " << int32(unit->GetFloatValue(UNIT_FIELD_MINDAMAGE)) << ", " << LocalizedNpcText(player, BOT_TEXT_MAX) << ": " << int32(unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_MULT_MAINHAND) << ": " << float(unit->GetPctModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetPctModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_ATTACK_TIME_MAINHAND) << ": " << float(attSpeed)
+        << " (" << float(((unit->GetFloatValue(UNIT_FIELD_MINDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2) / attSpeed) << " " << LocalizedNpcText(player, BOT_TEXT_DPS) << ")";
+    if (unit->haveOffhandWeapon())
+    {
+        type = OFF_ATTACK;
+        attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_RANGE_OFFHAND) << ": " << LocalizedNpcText(player, BOT_TEXT_MIN) << ": " << int32(unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE)) << ", " << LocalizedNpcText(player, BOT_TEXT_MAX) << ": " << int32(unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_MULT_OFFHAND) << ": " << float(unit->GetPctModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetPctModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_ATTACK_TIME_OFFHAND) << ": " << float(attSpeed)
+            << " (" << float(((unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE)) / 2) / attSpeed) << " " << LocalizedNpcText(player, BOT_TEXT_DPS) << ")";
+    }
+    if (unit != me ||
+        (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + BOT_SLOT_RANGED) &&
+        _botclass != BOT_CLASS_PALADIN &&
+        _botclass != BOT_CLASS_DEATH_KNIGHT &&
+        _botclass != BOT_CLASS_DRUID &&
+        _botclass != BOT_CLASS_SHAMAN))
+    {
+        type = RANGED_ATTACK;
+        attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_RANGE_RANGED) << ": " << LocalizedNpcText(player, BOT_TEXT_MIN) << ": " << int32(unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE)) << ", " << LocalizedNpcText(player, BOT_TEXT_MAX) << ": " << int32(unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DMG_MULT_RANGED) << ": " << float(unit->GetPctModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetPctModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_ATTACK_TIME_RANGED) << ": " << float(attSpeed)
+            << " (" << float(((unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE)) / 2) / attSpeed) << " " << LocalizedNpcText(player, BOT_TEXT_DPS) << ")";
+    }
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_BASE_HP) << ": " << int32(unit->GetCreateHealth());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_TOTAL_HP) << ": " << int32(unit->GetMaxHealth());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_BASE_MP) << ": " << int32(unit->GetCreateMana());
+    botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_TOTAL_MP) << ": " << int32(unit->GetMaxPower(POWER_MANA));
+    if (unit->GetMaxPower(POWER_MANA) > 1 && unit->GetPowerType() != POWER_MANA)
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_CURR_MP) << ": " << int32(unit->GetPower(POWER_MANA));
+
+    if (unit == me)
+    {
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_SPELLPOWER) << ": " << int32(me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_REGEN_HP) << ": " << int32(_getTotalBotStat(BOT_STAT_MOD_HEALTH_REGEN));
+        if (me->GetMaxPower(POWER_MANA) > 1)
+        {
+            botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_REGEN_MP_CAST) << ": " << float((_botclass == BOT_CLASS_SPHYNX ? -1.f : 1.f) * me->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 5.0f);
+            botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_REGEN_MP_NOCAST) << ": " << float((_botclass == BOT_CLASS_SPHYNX ? -1.f : 1.f) * me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 5.0f);
+        }
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_HASTE) << ": " << (haste >= 0 ? "+" : "-") << float(haste) << " " << LocalizedNpcText(player, BOT_TEXT_PCT);
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_HIT) << ": +" << float(hit) << " " << LocalizedNpcText(player, BOT_TEXT_PCT);
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_EXPERTISE) << ": " << int32(expertise) << " (-" << float(float(expertise) * 0.25f) << " " << LocalizedNpcText(player, BOT_TEXT_PCT) << ")";
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_ARMOR_PEN) << ": " << float(me->GetCreatureArmorPenetrationCoef()) << " " << LocalizedNpcText(player, BOT_TEXT_PCT);
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_SPELL_PEN) << ": " << uint32(spellpen);
+
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            uint32 curresist = me->GetResistance(SpellSchools(i)) + resistbonus[i-1];
+
+            std::string resist;
+            switch (i)
+            {
+                case 1: resist = LocalizedNpcText(player, BOT_TEXT_HOLY);   break;
+                case 2: resist = LocalizedNpcText(player, BOT_TEXT_FIRE);   break;
+                case 3: resist = LocalizedNpcText(player, BOT_TEXT_NATURE); break;
+                case 4: resist = LocalizedNpcText(player, BOT_TEXT_FROST);  break;
+                case 5: resist = LocalizedNpcText(player, BOT_TEXT_SHADOW); break;
+                case 6: resist = LocalizedNpcText(player, BOT_TEXT_ARCANE); break;
+            }
+            botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_RESISTANCE) << ": " << resist << ": " << uint32(curresist);
+        }
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_COMMAND_STATES) << ":";
+        if (HasBotCommandState(BOT_COMMAND_FOLLOW))
+            botstring << " " << LocalizedNpcText(player, BOT_TEXT_COMMAND_FOLLOW);
+        if (HasBotCommandState(BOT_COMMAND_ATTACK))
+            botstring << " " << LocalizedNpcText(player, BOT_TEXT_COMMAND_ATTACK);
+        if (HasBotCommandState(BOT_COMMAND_STAY))
+            botstring << " " << LocalizedNpcText(player, BOT_TEXT_COMMAND_STAY);
+        if (HasBotCommandState(BOT_COMMAND_COMBATRESET))
+            botstring << " " << LocalizedNpcText(player, BOT_TEXT_COMMAND_RESET);
+        if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+            botstring << " " << LocalizedNpcText(player, BOT_TEXT_COMMAND_FULLSTOP);
+        if (!IAmFree())
+            botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_FOLLOW_DISTANCE) << ": " << uint32(master->GetBotMgr()->GetBotFollowDist());
+
+        if (_botclass < BOT_CLASS_EX_START)
+            botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_SPEC) << ": " << uint32(_spec);
+
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_BOT_ROLEMASK_MAIN) << ": " << uint32(_roleMask & BOT_ROLE_MASK_MAIN);
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_BOT_ROLEMASK_GATHERING) << ": " << uint32(_roleMask & BOT_ROLE_MASK_GATHERING);
+
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_PVP_KILLS) << ": " << uint32(_pvpKillsCount) << ", " << LocalizedNpcText(player, BOT_TEXT_PLAYERS) << ": " << uint32(_playerKillsCount) << ", " << LocalizedNpcText(player, BOT_TEXT_TOTAL) << ": " << uint32(_killsCount);
+        botstring << "\n" << LocalizedNpcText(player, BOT_TEXT_DIED_) << uint32(_deathsCount) << LocalizedNpcText(player, BOT_TEXT__TIMES);
+
+        //debug
+        botstring << "\n_lastWMOAreaId: " << uint32(_lastWMOAreaId);
+
+        //debug
+        //botstring << "\ncurrent Engage timer: " << GetEngageTimer();
+
+        //debug
+        //for (uint32 i = 0; i != 148; ++i)
+        //{
+        //    float val = me->GetFloatValue(i);
+        //    ch.PSendSysMessage("Float value at %u: %.9f", i, val);
+        //}
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint32 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+    }
+
+    ch.SendSysMessage(botstring.str().c_str());
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_ai::SetStats(bool force)
+{
+    if (IsTempBot() && !force)
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = std::min<uint8>(master->GetLevel(), 80);
+
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    shouldUpdateStats = false;
+    /*TC_LOG_ERROR("entities.player", "*etStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    switch (me->GetCreatureTemplate()->rank) //TODO: conditions
+    {
+        case CREATURE_ELITE_RARE:       mylevel += 1;   break;
+        case CREATURE_ELITE_ELITE:      mylevel += 2;   break;
+        case CREATURE_ELITE_RAREELITE:  mylevel += 3;   break;
+        default:                                        break;
+    }
+    mylevel = std::min<uint8>(mylevel, 83);
+
+    //Do not remove this code
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+    else if (_botclass == BOT_CLASS_SPHYNX)
+        mylevel = std::max<uint8>(mylevel, 60);
+    else if (_botclass == BOT_CLASS_ARCHMAGE)
+        mylevel = std::max<uint8>(mylevel, 20);
+    else if (_botclass == BOT_CLASS_DREADLORD)
+        mylevel = std::max<uint8>(mylevel, 60);
+    else if (_botclass == BOT_CLASS_SPELLBREAKER)
+        mylevel = std::max<uint8>(mylevel, 20);
+    else if (_botclass == BOT_CLASS_DARK_RANGER)
+        mylevel = std::max<uint8>(mylevel, 40);
+    else if (_botclass == BOT_CLASS_NECROMANCER)
+        mylevel = std::max<uint8>(mylevel, 20);
+    //else if (_botclass == BOT_CLASS_SEA_WITCH)
+    //    mylevel = std::max<uint8>(mylevel, 10);
+
+    //LEVEL
+    if (me->GetLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //reinit spells/passives/other
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells(); //this must stay before class passives
+        ApplyClassPassives();
+
+        sObjectMgr->GetPlayerClassLevelInfo(GetPlayerClass(), std::min<uint8>(mylevel, 80), _classinfo);
+
+        PlayerLevelInfo info;
+        sObjectMgr->GetPlayerLevelInfo(GetPlayerRace(), GetPlayerClass(), std::min<uint8>(mylevel, 80), &info);
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+            me->SetCreateStat(Stats(i), info.stats[i]);
+    }
+
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_WARLOCK:
+        case DRUID_BEAR_FORM:
+        case DRUID_CAT_FORM:
+        case DRUID_MOONKIN_FORM:
+        case DRUID_TREE_FORM:
+        case DRUID_TRAVEL_FORM:
+        case DRUID_AQUATIC_FORM:
+        //case DRUID_FLIGHT_FORM:
+        case BOT_CLASS_BM:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+        case BOT_CLASS_NECROMANCER:
+        case BOT_CLASS_SEA_WITCH:
+            break;
+
+        default:
+            TC_LOG_ERROR("entities.player", "minion_ai: *etStats():Init - unknown bot class %u, real class: %u, _botclass: %u", myclass, GetPlayerClass(), _botclass);
+            break;
+    }
+
+    float value;
+    float tempval;
+    float ap_mod = 1.0f, armor_mod = 1.0f;
+
+    //DAMAGE PHYSICAL
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        float weap_damage_base_min = _getBotStat(i, BOT_STAT_MOD_DAMAGE_MIN);
+        float weap_damage_base_max = _getBotStat(i, BOT_STAT_MOD_DAMAGE_MAX);
+        me->SetBaseWeaponDamage(WeaponAttackType(BASE_ATTACK + i), MINDAMAGE, std::max<float>(weap_damage_base_min, 1.f));
+        me->SetBaseWeaponDamage(WeaponAttackType(BASE_ATTACK + i), MAXDAMAGE, std::max<float>(weap_damage_base_max, 1.f));
+    }
+
+    //Update Attack Time on main hand for shapeshifters
+    //do not add me->GetShapeshiftForm() check here, need to change attack time after shapeshift removal too
+    if (_botclass == BOT_CLASS_DRUID && RespectEquipsAttackTime())
+    {
+        uint32 delay;
+        SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(me->GetShapeshiftForm());
+        if (!ssEntry || !ssEntry->CombatRoundTime)
+            delay = _equips[BOT_SLOT_MAINHAND] ? _equips[BOT_SLOT_MAINHAND]->GetTemplate()->Delay : me->GetCreatureTemplate()->BaseAttackTime;
+        else
+            delay = ssEntry->CombatRoundTime;
+
+        me->SetAttackTime(BASE_ATTACK, delay);
+    }
+
+    float atpower = float(me->GetLevel() * (/*IAmFree() ? 100 : */3)); //+8000/+240(legit) base ap at 80
+    atpower += _getTotalBotStat(BOT_STAT_MOD_ATTACK_POWER);
+
+    float strmult, agimult;
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_DRUID:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_SHAMAN:
+            strmult = 1.f; agimult = 1.f; break;
+        case BOT_CLASS_HUNTER:
+            strmult = 0.5f; agimult = 1.f;break; //until attack power is separated
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+            strmult = 1.f; agimult = 0.f; break;
+        case DRUID_CAT_FORM:
+            strmult = 2.f; agimult = 1.f; break;
+        case DRUID_BEAR_FORM:
+        case DRUID_MOONKIN_FORM:
+        case DRUID_TREE_FORM:
+        case DRUID_TRAVEL_FORM:
+        case DRUID_AQUATIC_FORM:
+        //case DRUID_FLIGHT_FORM:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_BM:
+            strmult = 0.f; agimult = 9.f; break;
+        case BOT_CLASS_SPHYNX:
+            strmult = 2.f; agimult = 0.f; break;
+        case BOT_CLASS_ARCHMAGE:
+            strmult = 0.f; agimult = 0.f; break;
+        case BOT_CLASS_DREADLORD:
+            strmult = 8.f; agimult = 0.f; break;
+        case BOT_CLASS_SPELLBREAKER:
+            strmult = 5.f; agimult = 0.f; break;
+        case BOT_CLASS_DARK_RANGER:
+            strmult = 0.f; agimult = 4.f; break;
+        case BOT_CLASS_NECROMANCER:
+            strmult = 0.f; agimult = 0.f; break;
+        case BOT_CLASS_SEA_WITCH:
+            strmult = 0.f; agimult = 2.f; break;
+        default:
+            TC_LOG_ERROR("entities.player", "_MeleeDamageUpdate(): NIY myclass %u!", uint32(myclass));
+            strmult = 0.f; agimult = 0.f; break;
+    }
+
+    atpower += (strmult != 0x0) ? strmult * _getTotalBotStat(BOT_STAT_MOD_STRENGTH) : 0.f;
+    atpower += (agimult != 0x0) ? agimult * _getTotalBotStat(BOT_STAT_MOD_AGILITY) : 0.f;
+
+    //hunter Expose Weakness checked
+    Unit::AuraEffectList const& mAPbyStat = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT);
+    for (Unit::AuraEffectList::const_iterator i = mAPbyStat.begin(); i != mAPbyStat.end(); ++i)
+        atpower += CalculatePct(me->GetStat(Stats((*i)->GetMiscValue())), (*i)->GetAmount());
+
+    atpower += me->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+
+    //Unit::AuraEffectList const& mAPbyArmor = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+    //for (Unit::AuraEffectList::const_iterator iter = mAPbyArmor.begin(); iter != mAPbyArmor.end(); ++iter)
+    //    atpower += int32(me->GetArmor() / (*iter)->GetAmount());
+
+    //Handle mods
+    if (_botclass == BOT_CLASS_DRUID)
+    {
+        //Heart of the Wild part 3
+        if (mylevel >= 35 && myclass == DRUID_CAT_FORM && _spec == BOT_SPEC_DRUID_FERAL)
+            ap_mod *= 1.1f;
+        //Protector of the Pack part 2
+        if (mylevel >= 45 && myclass == DRUID_BEAR_FORM && _spec == BOT_SPEC_DRUID_FERAL)
+            ap_mod *= 1.06f;
+    }
+    if (_botclass == BOT_CLASS_ROGUE)
+    {
+        //Deadliness
+        if (mylevel >= 35 && _spec == BOT_SPEC_ROGUE_SUBTLETY)
+            ap_mod *= 1.1f;
+        //Savage Combat
+        if (mylevel >= 50 && _spec == BOT_SPEC_ROGUE_COMBAT)
+            ap_mod *= 1.04f;
+    }
+    //from stats mods
+    if (myclass == DRUID_BEAR_FORM || myclass == DRUID_CAT_FORM)
+    {
+        atpower += _getTotalBotStat(BOT_STAT_MOD_FERAL_ATTACK_POWER);
+        //Predatory Strikes
+        if (me->GetLevel() >= 25)
+        {
+            uint8 slot = BOT_SLOT_MAINHAND;
+            atpower += 1.5f * me->GetLevel();
+            atpower += 0.2f * (
+                _getBotStat(slot, BOT_STAT_MOD_FERAL_ATTACK_POWER)
+                + _getBotStat(slot, BOT_STAT_MOD_ATTACK_POWER)
+                //+ _getBotStat(slot, BOT_STAT_MOD_RANGED_ATTACK_POWER)
+                );
+        }
+    }
+    if (_botclass == BOT_CLASS_HUNTER)
+    {
+        //Careful Aim
+        if (me->GetLevel() >= 15)
+            atpower += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        //Hunter vs. Wild
+        if (me->GetLevel() >= 30 && _spec == BOT_SPEC_HUNTER_SURVIVAL)
+            atpower += 0.3f * _getTotalBotStat(BOT_STAT_MOD_STAMINA);
+    }
+    if (_botclass == BOT_CLASS_SHAMAN)
+    {
+        //Mental Dexterity
+        if (me->GetLevel() >= 30 && _spec == BOT_SPEC_SHAMAN_ENHANCEMENT)
+            atpower += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+    }
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+    {
+        atpower += 2.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        if (me->GetLevel() >= 60)
+            ap_mod *= 1.15f;
+    }
+    if (_botclass == BOT_CLASS_SEA_WITCH)
+    {
+        if (me->GetLevel() >= 20)
+            atpower += 2.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        else if (me->GetLevel() >= 10)
+            atpower += 1.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+    }
+
+    atpower *= ap_mod;
+    me->SetStatFlatModifier(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+
+    me->UpdateAttackPowerAndDamage();
+    if (_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_PRIEST || _botclass == BOT_CLASS_WARLOCK ||
+        _botclass == BOT_CLASS_DARK_RANGER || _botclass == BOT_CLASS_SEA_WITCH)
+    {
+        atpower += _getTotalBotStat(BOT_STAT_MOD_RANGED_ATTACK_POWER) * ap_mod;
+        me->SetStatFlatModifier(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+
+    //ARMOR
+    //value = IAmFree() ? 0 : me->GetLevel() * 10; //0/800 at 80
+    value = 2.f * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+    value += _getTotalBotStat(BOT_STAT_MOD_ARMOR);
+
+    if (mylevel >= 10)
+    {
+        //Toughness
+        if (mylevel >= 20 && (_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PALADIN || _botclass == BOT_CLASS_DEATH_KNIGHT))
+            armor_mod += 0.1f;
+        //Frost Presence
+        if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+            armor_mod += 0.6f;
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Thick Hide
+            if (mylevel >= 15)
+                armor_mod += 0.1f;
+            //Survival of the Fittest
+            if (myclass == DRUID_BEAR_FORM && _spec == BOT_SPEC_DRUID_FERAL)
+                armor_mod += 0.33f + (me->GetShapeshiftForm() == FORM_BEAR ? 1.8f : 3.7f);
+            //Moonkin Form innate
+            else if (myclass == DRUID_MOONKIN_FORM && _spec == BOT_SPEC_DRUID_BALANCE)
+                armor_mod += 3.7f;
+            //Improved Tree Form
+            else if (myclass == DRUID_TREE_FORM && _spec == BOT_SPEC_DRUID_RESTORATION)
+                armor_mod += 2.0f;
+            //Improved Barkskin
+            //else if (myclass == DRUID_TRAVEL_FORM || GetBotStance() == BOT_STANCE_NONE)
+            //    armor_mod += 1.6f;
+        }
+        if (_botclass == BOT_CLASS_HUNTER)
+        {
+            //Thick Hide
+            if (mylevel >= 15)
+                armor_mod += 0.1f;
+        }
+        if (_botclass == BOT_CLASS_MAGE)
+        {
+            //Arcane Fortitude
+            if (mylevel >= 15)
+                value += 1.5f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_SPHYNX)
+        {
+            value += 5.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            armor_mod += 0.5f;
+        }
+        if (_botclass == BOT_CLASS_ARCHMAGE)
+        {
+            value += 5.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_DREADLORD)
+        {
+            armor_mod += 0.5f;
+        }
+        if (_botclass == BOT_CLASS_SPELLBREAKER)
+        {
+            armor_mod += -0.3f; // reduce armor so cannot really tank
+        }
+        if (_botclass == BOT_CLASS_NECROMANCER)
+        {
+            value += 5.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+    }
+
+    value *= armor_mod;
+    //Druid armor mods should not affect armor from weapons
+    if (_botclass == BOT_CLASS_DRUID && _stats[BOT_SLOT_MAINHAND][BOT_STAT_MOD_ARMOR] != 0 && armor_mod > 1.f)
+        value -= _stats[BOT_SLOT_MAINHAND][BOT_STAT_MOD_ARMOR] * (armor_mod - 1.f);
+    me->SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor(); //buffs will be processed here
+
+    //RESISTANCES
+    //Do not store resistance bonuses directly lest we want calcs screwed up
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = IAmFree() ? 0 : mylevel;
+        value += _getTotalBotStat(BotStatMods(BOT_STAT_MOD_RESIST_HOLY + (i - 1)));
+
+        //res bonuses
+        if (_botclass == BOT_CLASS_SPHYNX)
+            value += mylevel * 5; //total 498 at 83
+        if (_botclass == BOT_CLASS_DREADLORD)
+            value += mylevel * 3; //total 332 at 83
+        if (_botclass == BOT_CLASS_DARK_RANGER || _botclass == BOT_CLASS_SEA_WITCH)
+            value += mylevel * 2; //total 249 at 83
+
+        resistbonus[i-1] = int32(value);
+        //me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    value = 1.0f;
+    tempval = 1.0f;
+
+    //class-specified
+    //Protector of the Pack part 1
+    if (myclass == DRUID_BEAR_FORM && mylevel >= 45)
+    {
+        value -= 0.12f;
+        tempval -= 0.12f;
+    }
+    //Deadened Nerves
+    if (_botclass == BOT_CLASS_ROGUE && mylevel >= 45 && _spec == BOT_SPEC_ROGUE_ASSASINATION)
+    {
+        value -= 0.06f;
+        tempval -= 0.06f;
+    }
+    //Survival Instincts
+    if (_botclass == BOT_CLASS_HUNTER && mylevel >= 15)
+    {
+        value -= 0.04f;
+        tempval -= 0.04f;
+    }
+    //Spell Warding
+    if (_botclass == BOT_CLASS_PRIEST && mylevel >= 15)
+        tempval -= 0.1f;
+    //Elemental Warding
+    if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 15)
+    {
+        value -= 0.06f;
+        tempval -= 0.06f;
+    }
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+    {
+        //Magic Suppression (everything)
+        if (mylevel >= 60 && _spec == BOT_SPEC_DK_UNHOLY)
+            tempval -= 0.06f;
+        //Improved Frost Presence
+        if (mylevel >= 61 && GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE && _spec == BOT_SPEC_DK_FROST)
+        {
+            value -= 0.02f;
+            tempval -= 0.02f;
+        }
+    }
+    if (_botclass == BOT_CLASS_WARLOCK)
+    {
+        //Molten Skin
+        if (mylevel >= 15)
+        {
+            value -= 0.06f;
+            tempval -= 0.06f;
+        }
+        //Master Demonologist part 2, Master Demonologist part 4
+        if (mylevel >= 35 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY && botPet && botPet->IsAlive())
+        {
+            if (GetAIMiscValue(BOTAI_MISC_PET_TYPE) == BOT_PET_VOIDWALKER)
+                value -= 0.1f;
+            else if (GetAIMiscValue(BOTAI_MISC_PET_TYPE) == BOT_PET_FELHUNTER)
+                tempval -= 0.1f;
+        }
+    }
+    //Frozen Core (everything), Prismatic Cloak part 1
+    if (_botclass == BOT_CLASS_MAGE)
+    {
+        if (mylevel >= 30 && _spec == BOT_SPEC_MAGE_FROST)
+            tempval -= 0.06f;
+        else if (mylevel >= 35 && _spec == BOT_SPEC_MAGE_ARCANE)
+        {
+            value -= 0.06f;
+            tempval -= 0.06f;
+        }
+    }
+    if (_botclass == BOT_CLASS_SPHYNX)
+    {
+        value -= 0.33f;
+        tempval -= 0.33f;
+    }
+    if (_botclass == BOT_CLASS_ARCHMAGE)
+    {
+        value -= 0.1f;
+        tempval -= 0.35f;
+    }
+    if (_botclass == BOT_CLASS_DREADLORD)
+    {
+        value -= 0.15f;
+        tempval -= 0.2f;
+    }
+    if (_botclass == BOT_CLASS_SPELLBREAKER)
+    {
+        value -= 0.2f;
+        tempval -= 0.75f;
+    }
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+    {
+        tempval -= 0.35f;
+    }
+    if (_botclass == BOT_CLASS_NECROMANCER)
+    {
+        tempval -= 0.2f;
+    }
+    if (_botclass == BOT_CLASS_SEA_WITCH)
+    {
+        tempval -= 0.3f;
+    }
+
+    dmg_taken_phy = value;
+    dmg_taken_mag = tempval;
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        //unapply old haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    value =  IAmFree() ? std::max<int32>(int32(mylevel) - 50, 0) : 0; // +30%/+0% haste at 80
+
+    //25.5 HR = 1% haste at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_HASTE_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_HASTE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HASTE_MELEE) | (1 << CR_HASTE_RANGED) | (1 << CR_HASTE_SPELL));
+
+    if (_botclass == BOT_CLASS_WARLOCK)
+    {
+        //Spellstone: just emulate the rating bonus
+        uint8 ratingBonus;
+        if      (mylevel >= 78) ratingBonus = 60;
+        else if (mylevel >= 72) ratingBonus = 50;
+        else if (mylevel >= 66) ratingBonus = 40;
+        else if (mylevel >= 60) ratingBonus = 30;
+        else if (mylevel >= 48) ratingBonus = 20;
+        else if (mylevel >= 36) ratingBonus = 10;
+        else                    ratingBonus = 0;
+
+        //Master Conjuror
+        if (mylevel >= 30 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+            ratingBonus *= 4;
+
+        tempval += (float)ratingBonus;
+    }
+
+    value += tempval * ((_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_DARK_RANGER || _botclass == BOT_CLASS_SEA_WITCH) ?
+        _getRatingMultiplier(CR_HASTE_RANGED) :
+        std::max<float>(_getRatingMultiplier(CR_HASTE_MELEE), _getRatingMultiplier(CR_HASTE_SPELL)));
+
+    //class-specific
+    if (_botclass == BOT_CLASS_HUNTER)
+    {
+        value += 15.f; //innate ranged haste bonus 15% for hunters (still applies to all haste types)
+        //Serpent's Swiftness
+        if (mylevel >= 45 && _spec == BOT_SPEC_HUNTER_BEASTMASTERY)
+            value += 20.f;
+    }
+    if (_botclass == BOT_CLASS_ROGUE)
+    {
+        //Lightning Reflexes part 2
+        if (mylevel >= 25 && _spec == BOT_SPEC_ROGUE_COMBAT)
+            value += 10.f;
+    }
+    if (_botclass == BOT_CLASS_PRIEST)
+    {
+        //Enlightenment part 2
+        if (mylevel >= 35 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+            value += 6.f;
+    }
+    if (_botclass == BOT_CLASS_MAGE)
+    {
+        //Netherwind Presence
+        if (mylevel >= 55 && _spec == BOT_SPEC_MAGE_ARCANE)
+            value += 6.f;
+    }
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        float haste_per_lvl;
+        switch (_botclass)
+        {
+            case BOT_CLASS_BM:
+            case BOT_CLASS_DREADLORD:
+                haste_per_lvl = 0.875f;
+                break;
+            case BOT_CLASS_ARCHMAGE:
+            case BOT_CLASS_DARK_RANGER:
+            case BOT_CLASS_SEA_WITCH:
+                haste_per_lvl = 0.5f;
+                break;
+            default:
+                haste_per_lvl = 0.25f;
+                break;
+        }
+        value += mylevel * haste_per_lvl;
+    }
+
+    haste = int32(value);
+
+    if (haste)
+    {
+        //apply new haste (using truncated value - gonna need it for unapply on next SetStats)
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    if (CanMiss())
+    {
+        value = IAmFree() ? mylevel / 8 : 0; // +10%/+0% at 80
+        //32.5 HR = 1% hit at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_HIT_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_HIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HIT_MELEE) | (1 << CR_HIT_RANGED) | (1 << CR_HIT_SPELL));
+        value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_HIT_MELEE), _getRatingMultiplier(CR_HIT_SPELL)));
+
+        //class-specific
+        //Precision
+        if (_botclass == BOT_CLASS_ROGUE && mylevel >= 15)
+            value += 5.f;
+        //Enlightened Judgements part 2,3
+        if (_botclass == BOT_CLASS_PALADIN && _spec == BOT_SPEC_PALADIN_HOLY && mylevel >= 55)
+            value += 4.f;
+        //Virulence part 1, Nerves of Cold Steel part 1
+        if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+            value += 3.f;
+        //Dual Wield Specialization
+        if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 40 && me->haveOffhandWeapon())
+            value += 6.f;
+        //Precision
+        if (_botclass == BOT_CLASS_WARRIOR && mylevel >= 30 && _spec == BOT_SPEC_WARRIOR_FURY)
+            value += 3.f;
+        //Focused Aim
+        if (_botclass == BOT_CLASS_HUNTER && mylevel >= 10)
+            value += 3.f;
+        //Shadow Focus part 1
+        if (_botclass == BOT_CLASS_PRIEST && mylevel >= 15)
+            value += 3.f;
+        //Arcane Focus part 1, Precision part 2
+        if (_botclass == BOT_CLASS_MAGE && mylevel >= 10)
+            value += mylevel >= 15 ? 6.f : 3.f;
+        //Suppression
+        if (_botclass == BOT_CLASS_WARLOCK && mylevel >= 10)
+            value += 3.f;
+
+        hit = value;
+    }
+    else
+        hit = 100.0f;
+
+    //ARMOR PENETRATION
+    value = IAmFree() ? 5 + mylevel / 4 : 0; // 25%/0% at 80
+    //? APR = 1% armor ignored at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_ARMOR_PENETRATION_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_ARMOR_PENETRATION));
+    value += tempval * _getRatingMultiplier(CR_ARMOR_PENETRATION);
+
+    //class-specific
+    //Blood Gorged
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT && mylevel >= 64 && _spec == BOT_SPEC_DK_BLOOD)
+        value += 10.f;
+
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+        value += 50.f;
+
+    armor_pen = value;
+
+    //EXPERTISE
+    value = IAmFree() ? mylevel / 2 : 0; // -10%/-0% at 80
+    //~8.0 ER = 1 expertise at 80
+    tempval = _getTotalBotStat(BOT_STAT_MOD_EXPERTISE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_EXPERTISE));
+    value += tempval * _getRatingMultiplier(CR_EXPERTISE);
+
+    //class-specific
+    //Weapon Expertise
+    if (mylevel >= 35 && _botclass == BOT_CLASS_ROGUE && _spec == BOT_SPEC_ROGUE_COMBAT)
+        value += 10.f;
+    //Combat Expertise
+    if (mylevel >= 45 && _botclass == BOT_CLASS_PALADIN && _spec == BOT_SPEC_PALADIN_PROTECTION)
+        value += 6.f;
+    if (_botclass == BOT_CLASS_WARRIOR)
+    {
+        //Vitality: 6, Strength of Arms: 4
+        if (mylevel >= 45 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+            value += 10.f;
+        else if (mylevel >= 40 && _spec == BOT_SPEC_WARRIOR_ARMS)
+            value += 4.f;
+    }
+    if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+    {
+        //Tundra Stalker, Rage of Rivendare: 5
+        //Veteral of the Third War part 3: 6
+        if (mylevel >= 64 && _spec == BOT_SPEC_DK_FROST)
+            value += 5.f;
+        else if (mylevel >= 64 && _spec == BOT_SPEC_DK_UNHOLY)
+            value += 5.f;
+        else if (mylevel >= 59 && _spec == BOT_SPEC_DK_BLOOD)
+            value += 6.f;
+    }
+    if (_botclass == BOT_CLASS_DREADLORD)
+    {
+        value += 40.f;
+    }
+
+    expertise = value;
+
+    //CRIT
+    if (CanCrit())
+    {
+        value = IAmFree() ? mylevel / 4 : 0; // +20%/+0% at 80
+        tempval = value;
+
+        GtChanceToMeleeCritBaseEntry const* critBaseMelee  = sGtChanceToMeleeCritBaseStore.LookupEntry(GetPlayerClass()-1);
+        GtChanceToMeleeCritEntry const* critRatioMelee = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1);
+        if (critBaseMelee && critRatioMelee)
+            value += (critBaseMelee->Data + _getTotalBotStat(BOT_STAT_MOD_AGILITY) * critRatioMelee->Data) * 100.0f;
+
+        //crit from intellect
+        GtChanceToSpellCritBaseEntry const* critBaseSpell  = sGtChanceToSpellCritBaseStore.LookupEntry(GetPlayerClass()-1);
+        GtChanceToSpellCritEntry const* critRatioSpell = sGtChanceToSpellCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1);
+        if (critBaseSpell && critRatioSpell)
+            tempval += (critBaseSpell->Data + _getTotalBotStat(BOT_STAT_MOD_INTELLECT) * critRatioSpell->Data) * 100.f;
+
+        value = std::max<float>(value, tempval);
+
+        //45 CR = 1% crit at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_CRIT_MELEE_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_RANGED_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_SPELL_RATING) + _getTotalBotStat(BOT_STAT_MOD_CRIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_CRIT_MELEE) | (1 << CR_CRIT_RANGED) | (1 << CR_CRIT_SPELL));
+
+        //Molten Armor: 35% spirit to crit rating (+40% double-glyphed + 15% T9P2 bonus)
+        if (_botclass == BOT_CLASS_MAGE && me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RATING_FROM_STAT, SPELLFAMILY_MAGE, 0x40000))
+            tempval += _getTotalBotStat(BOT_STAT_MOD_SPIRIT) * (mylevel >= 80 ? 0.9f : mylevel >= 70 ? 0.75f : 0.55f);
+        //Firestone: just emulate the rating bonus
+        if (_botclass == BOT_CLASS_WARLOCK)
+        {
+            uint8 ratingBonus;
+            if      (mylevel >= 80) ratingBonus = 49;
+            else if (mylevel >= 74) ratingBonus = 42;
+            else if (mylevel >= 66) ratingBonus = 35;
+            else if (mylevel >= 56) ratingBonus = 28;
+            else if (mylevel >= 46) ratingBonus = 21;
+            else if (mylevel >= 36) ratingBonus = 14;
+            else if (mylevel >= 28) ratingBonus = 7;
+            else                    ratingBonus = 0;
+
+            //Master Conjuror
+            if (mylevel >= 30 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                ratingBonus *= 4;
+
+            tempval += (float)ratingBonus;
+        }
+
+        value += tempval * (_botclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_CRIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_CRIT_MELEE), _getRatingMultiplier(CR_CRIT_SPELL)));
+
+        //common crit talents
+        if (mylevel >= 10 &&
+            (_botclass != BOT_CLASS_MAGE && _botclass != BOT_CLASS_PRIEST &&
+            _botclass != BOT_CLASS_DRUID && _botclass != BOT_CLASS_WARLOCK))
+            value += 5.f;
+
+        //class-specific
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Sharpened Claws
+            if (mylevel >= 20 && (myclass == DRUID_CAT_FORM || myclass == DRUID_BEAR_FORM))
+                value += 6.f;
+        }
+        if (_botclass == BOT_CLASS_ROGUE)
+        {
+            //Close Quarters Combat
+            if (mylevel >= 20)
+            {
+                if (Item const* mainhand = _equips[BOT_SLOT_MAINHAND])
+                {
+                    if (mainhand->GetTemplate()->Class == ITEM_CLASS_WEAPON &&
+                        (mainhand->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                        mainhand->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_FIST))
+                        value += 5.f;
+                }
+            }
+        }
+        if (_botclass == BOT_CLASS_PALADIN)
+        {
+            //Sanctity of Battle part 1
+            if (mylevel >= 25 && _spec == BOT_SPEC_PALADIN_RETRIBUTION)
+                value += 3.f;
+            //Combat Expertise
+            if (mylevel >= 45 && _spec == BOT_SPEC_PALADIN_PROTECTION)
+                value += 6.f;
+        }
+        if (_botclass == BOT_CLASS_HUNTER)
+        {
+            //Killer Instinct
+            if (mylevel >= 30 && _spec == BOT_SPEC_HUNTER_BEASTMASTERY)
+                value += 3.f;
+            //Master Marksman
+            if (mylevel >= 45 && _spec == BOT_SPEC_HUNTER_MARKSMANSHIP)
+                value += 5.f;
+        }
+        if (_botclass == BOT_CLASS_PRIEST)
+        {
+            //Focused Will part 1
+            if (mylevel >= 40 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+                value += 3.f;
+        }
+        if (_botclass == BOT_CLASS_DEATH_KNIGHT)
+        {
+            //Annihilation part 1
+            if (mylevel >= 57)
+                value += 3.f;
+        }
+        if (_botclass == BOT_CLASS_WARLOCK)
+        {
+            //Backlash
+            if (mylevel >= 30)
+                value += 3.f;
+            //Demonic Tactics part 1, part 2 (me)
+            if (mylevel >= 45 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                value += 10.f;
+        }
+        if (_botclass == BOT_CLASS_MAGE)
+        {
+            //Arcane Instability part 2
+            if (mylevel >= 35 && _spec == BOT_SPEC_MAGE_ARCANE)
+                value += 3.f;
+        }
+        if (_botclass == BOT_CLASS_DREADLORD)
+        {
+            value = value * 2.f;
+        }
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+        {
+            value += 20.f;
+        }
+
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            crit = std::min<float>(value, BotMgr::GetBotStatLimitCrit());
+        else
+            crit = value;
+
+        if (crit < 0.0f)
+            crit = 0.0f;
+    }
+    else
+        crit = 0.0f;
+
+    //DEFENSE
+    value = 0.f;
+    tempval = _getTotalBotStat(BOT_STAT_MOD_DEFENSE_SKILL_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+    value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL);
+    value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE);
+    defense = mylevel * 5 + uint32(value); //truncate
+
+    float defbonus = defense - mylevel * 5; //difference
+
+    //PARRY
+    if (CanParry())
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : 0); // +10%/+0% at 80
+
+        if (mylevel >= 10)
+        {
+            //67 PR = 1% parry at 80
+            tempval = _getTotalBotStat(BOT_STAT_MOD_PARRY_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_PARRY));
+
+            //Forceful Deflection: 25% of strength goes to parry rating
+            if (_botclass == BOT_CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+                tempval += _getTotalBotStat(BOT_STAT_MOD_STRENGTH) * 0.25f;
+
+            value += tempval * _getRatingMultiplier(CR_PARRY);
+            //125 DR = 1% block/parry/dodge at 80
+            value += defbonus * 0.04f;
+        }
+
+        //Deflection (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_PALADIN) && mylevel >= 10)
+            value += 5.0f;
+        if (_botclass == BOT_CLASS_HUNTER && mylevel >= 20)
+            value += 3.f;
+
+        if (_botclass == BOT_CLASS_SEA_WITCH)
+            value += 25.f;
+
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            parry = std::min<float>(value, BotMgr::GetBotStatLimitParry());
+        else
+            parry = value;
+
+        if (parry < 0.0f)
+            parry = 0.0f;
+    }
+    else
+        parry = 0.0f;
+
+    //DODGE
+    if (CanDodge())
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : 0); // +10%/+0% at 80
+
+        if (GtChanceToMeleeCritEntry  const* dodgeRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += _getTotalBotStat(BOT_STAT_MOD_AGILITY) * dodgeRatio->Data * 100.0f;
+
+        if (mylevel >= 10)
+        {
+            //53 DR = 1% dodge at 80
+            tempval = _getTotalBotStat(BOT_STAT_MOD_DODGE_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DODGE));
+            value += tempval * _getRatingMultiplier(CR_DODGE);
+            //125 DR = 1% block/parry/dodge at 80
+            value += defbonus * 0.04f;
+        }
+
+        //evasion, anticipation (general)
+        if ((_botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_ROGUE || _botclass == BOT_CLASS_PALADIN ||
+            _botclass == BOT_CLASS_DEATH_KNIGHT || _botclass == BOT_CLASS_SHAMAN) && mylevel >= 15)
+            value += 5.0f;
+
+        //class-specific
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            //Feral Swiftness
+            if (mylevel >= 20 && (myclass == DRUID_CAT_FORM || myclass == DRUID_BEAR_FORM))
+                value += 4.f;
+        }
+
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+        {
+            //base dodge 30%
+            value += 30.f;
+        }
+
+        if (_botclass == BOT_CLASS_SEA_WITCH && IsInContactWithWater())
+        {
+            //TC_LOG_ERROR("scripts", "BOT_CLASS_SEA_WITCH dodge: %s now in water", me->GetName().c_str());
+            value += 50.f;
+        }
+
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            dodge = std::min<float>(value, BotMgr::GetBotStatLimitDodge());
+        else
+            dodge = value;
+
+        if (dodge < 0.0f)
+            dodge = 0.0f;
+    }
+    else
+        dodge = 0.0f;
+
+    //BLOCK
+    if (IsBlockingClass(_botclass))
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 4 : 0); // +20%/+0% at 80
+
+        //16.5 BR = 1% block at 80
+        tempval = _getTotalBotStat(BOT_STAT_MOD_BLOCK_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_BLOCK));
+        value += tempval * _getRatingMultiplier(CR_BLOCK);
+        //125 DR = 1% block/parry/dodge at 80
+        value += defbonus * 0.04f;
+
+        //base block chance is capped at 75%
+        if (BotMgr::IsBotStatsLimitsEnabled())
+            block = std::min<float>(value, BotMgr::GetBotStatLimitBlock());
+        else
+            block = std::min<float>(value, 75.0f);
+
+        if (block < 0.0f)
+            block = 0.0f;
+
+        //Spellbreaker wears tall shield so should always block
+        if (_botclass == BOT_CLASS_SPELLBREAKER)
+            block += 90.f;
+
+        //BLOCK VALUE
+        //2 str = 1 block value
+        value = 0.5f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH) - 10.f;
+        value += _getTotalBotStat(BOT_STAT_MOD_BLOCK_VALUE);
+
+        //Shield Mastery part 1
+        if (_botclass == BOT_CLASS_WARRIOR && mylevel >= 20 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+            value *= 1.3f;
+        //Redoubt handled in passives
+        //if (mylevel >= 45 && _botclass == BOT_CLASS_PALADIN)
+        //    value *= 1.3f;
+
+        blockvalue = std::max<float>(int32(value), 1.f);
+    }
+    //else
+    //{
+    //    block = 0.0f;
+    //    blockvalue = 0;
+    //}
+
+    //MANA
+    _OnManaUpdate();
+
+    if (IsCastingClass(_botclass))
+    {
+        //SPELL PENETRATION
+        value = IAmFree() ? mylevel : 0; // 80/0 at 80
+        //~1 SPPR = 1 spell penetration
+        value += _getTotalBotStat(BOT_STAT_MOD_SPELL_PENETRATION);
+        spellpen = uint32(value);
+
+        //SPELL POWER
+        value = /*IAmFree() ? std::max<int32>((int8(mylevel) - 30) * 40, 0) : */0; // +2000/+0 spp at 80
+        value += _getTotalBotStat(BOT_STAT_MOD_SPELL_POWER);
+
+        //class-specified mods
+        if (_botclass == BOT_CLASS_PALADIN && mylevel >= 50)
+        {
+            //Touched by the Light - 60% of strength to spell power
+            if (_spec == BOT_SPEC_PALADIN_PROTECTION)
+                value += 0.6f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+            //Sheath of Light - 30% attack power to spell power
+            if (_spec == BOT_SPEC_PALADIN_RETRIBUTION)
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Holy Guidance - 20% Intellect to spell power
+            if (_spec == BOT_SPEC_PALADIN_HOLY)
+                value += 0.2f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_PRIEST && mylevel >= 30)
+        {
+            float totalSpi = _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            //Spiritual Guidance - 25% Spirit to spell power
+            if (_spec == BOT_SPEC_PRIEST_HOLY)
+                value += 0.25f * totalSpi;
+            //Twisted Faith - 20% Spirit to spell power
+            else if (mylevel >= 55 && _spec == BOT_SPEC_PRIEST_SHADOW)
+                value += 0.2f * totalSpi;
+            //Shadowy Insight (Glyph of Shadow)
+            if (mylevel >= 30 &&
+                me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_GENERIC, 1499, 0))
+                value += 0.3f * totalSpi;
+        }
+        if (_botclass == BOT_CLASS_SHAMAN && mylevel >= 50 && _spec == BOT_SPEC_SHAMAN_ENHANCEMENT)
+        {
+            //Mental Quickness - 30% attack power to spell power (only enhancement)
+            value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+        }
+        if (_botclass == BOT_CLASS_DRUID && mylevel >= 30)
+        {
+            //Nurturing Instinct - 70% Agility to spell power
+            value += 0.7f * _getTotalBotStat(BOT_STAT_MOD_AGILITY);
+            //Lunar Guidance - 12% Intellect to spell power
+            value += 0.12f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            //Improved Moonkin Form - 30% Spirit to spell power
+            if (mylevel >= 40 && myclass == DRUID_MOONKIN_FORM)
+                value += 0.3f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            //Improved Tree (of Life) Form - 15% Spirit to spell power
+            if (mylevel >= 50 && myclass == DRUID_TREE_FORM)
+                value += 0.15f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+        }
+        if (_botclass == BOT_CLASS_MAGE && mylevel >= 45 && _spec == BOT_SPEC_MAGE_ARCANE)
+        {
+            //Mind Mastery - 15% Intellect to spell power
+            value += 0.15f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_WARLOCK)
+        {
+            if (me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 0x0, 0x20000000, 0x0))
+            {
+                //Fel Armor + Demonic Aegis - 39% Spirit to spell power
+                value += 0.39f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+            }
+            //Demonic Knowledge
+            if (botPet && botPet->IsAlive() && mylevel >= 40 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                value += 0.12f * botPet->GetStat(STAT_STAMINA) + botPet->GetStat(STAT_INTELLECT);
+            //Glyph of Life Tap: 20% of spirit to spellpower
+            if (me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 208, 0))
+                value += 0.2f * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+        }
+        if (_botclass == BOT_CLASS_SPHYNX)
+        {
+            //bonus from attack power (for tank) or intellect (ranged)
+            value += 2.0f *_getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            value += 0.5f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //from wands
+            for (uint8 i = BOT_SLOT_MAINHAND; i <= BOT_SLOT_OFFHAND; ++i)
+                if (ItemTemplate const* proto = _equips[i] ? _equips[i]->GetTemplate() : nullptr)
+                    value += proto->getDPS() * 1.35f;
+        }
+        if (_botclass == BOT_CLASS_ARCHMAGE)
+        {
+            //bonus from intellect
+            value += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_DREADLORD)
+        {
+            //bonus from strength
+            value += 2.f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+        }
+        if (_botclass == BOT_CLASS_SPELLBREAKER)
+        {
+            //bonus from strength
+            value += 2.f * _getTotalBotStat(BOT_STAT_MOD_STRENGTH);
+        }
+        if (_botclass == BOT_CLASS_DARK_RANGER)
+        {
+            //bonus from intellect
+            value += 0.5f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_NECROMANCER)
+        {
+            //bonus from intellect
+            value += _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+        if (_botclass == BOT_CLASS_SEA_WITCH)
+        {
+            //bonus from intellect
+            value += 2.f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        }
+
+        spellpower = uint32(value);
+    }
+    //else
+    //{
+    //    spellpower = 0;
+    //}
+
+    //if init or levelup
+    if (force)
+    {
+        InitHeals();
+        me->SetFullHealth();
+        if (_botclass != BOT_CLASS_SPHYNX)
+            me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    if (botPet)
+        botPet->GetBotPetAI()->SetShouldUpdateStats();
+}
+
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                break;
+            }
+            SetBotCommandState(BOT_COMMAND_STAY);
+            //BotWhisper("Standing Still.", player);
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                break;
+            }
+            if (me->IsNonMeleeSpellCast(true))
+                me->InterruptNonMeleeSpells(true);
+            SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+            //BotWhisper("Following!", player);
+            break;
+        case TEXT_EMOTE_TICKLE:
+        {
+            if (master != player)
+                break;
+
+            if ((me->HasUnitFlag(UNIT_FLAG_STUNNED) || me->HasUnitState(UNIT_STATE_STUNNED)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_STUN))
+            {
+                me->ClearUnitState(UNIT_STATE_STUNNED);
+                me->RemoveUnitFlag(UNIT_FLAG_STUNNED);
+            }
+            if ((me->HasUnitFlag(UNIT_FLAG_CONFUSED) || me->HasUnitState(UNIT_STATE_CONFUSED)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_CONFUSE))
+            {
+                me->ClearUnitState(UNIT_STATE_CONFUSED);
+                me->RemoveUnitFlag(UNIT_FLAG_CONFUSED);
+            }
+            if ((me->HasUnitFlag(UNIT_FLAG_FLEEING) || me->HasUnitState(UNIT_STATE_FLEEING)) &&
+                !me->HasAuraType(SPELL_AURA_MOD_FEAR))
+            {
+                me->ClearUnitState(UNIT_STATE_FLEEING);
+                me->RemoveUnitFlag(UNIT_FLAG_FLEEING);
+            }
+            me->BotStopMovement();
+
+            me->TextEmote(LocalizedNpcText(player, BOT_TEXT_BOT_TICKLED).c_str());
+            break;
+        }
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == master || unit == me || unit == botPet) return true;
+
+    if (IAmFree())
+    {
+        if (me->GetFaction() == 14 || unit->GetFaction() == 14)
+            return false;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) ||
+            unit->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return false;
+
+        return
+            (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->IsPet() || unit->ToCreature()->IsNPCBotOrPet()) &&
+            (unit->GetFaction() == me->GetFaction() ||
+            (me->GetReactionTo(unit) >= REP_FRIENDLY && unit->GetReactionTo(me) >= REP_FRIENDLY));
+    }
+
+    //cheap check
+    if (Group const* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if ((BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i]) &&
+                !((BotMgr::GetOffTankTargetIconFlags() | BotMgr::GetDPSTargetIconFlags()) & GroupIconsFlags[i]))
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                    if (guid == unit->GetGUID())
+                        return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        ObjectGuid ownerGuid = unit->GetOwnerGUID() ? unit->GetOwnerGUID() : unit->GetCreatorGUID();
+        if (!ownerGuid && unit->IsVehicle())
+            ownerGuid = unit->GetCharmerGUID();
+        //controlled by master
+        if (ownerGuid == master->GetGUID())
+            return true;
+        //npcbot/npcbot's pet case
+        if (cre->GetBotOwner() == master)
+            return true;
+        if (ownerGuid && master->GetBotMgr()->GetBot(ownerGuid))
+            return true;
+        //controlled by group member
+        //pets, minions, guardians etc.
+        //bot pets too
+        if (ownerGuid)
+            if (Group const* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+    }
+
+    return false;
+}
+
+bool bot_ai::IsInBotParty(ObjectGuid guid) const
+{
+    if (!guid) return false;
+    if (guid == master->GetGUID() || guid == me->GetGUID()) return true;
+    if (master->GetVehicle() && guid == master->GetCharmedGUID()) return true;
+    if (me->GetVehicle() && guid == me->GetCharmedGUID()) return true;
+
+    if (IAmFree())
+    {
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return false;
+
+        return !(me->GetVictim() && me->GetVictim()->GetGUID() == guid);
+    }
+
+    //cheap check
+    if (Group const* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(guid))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if ((BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i]) &&
+                !((BotMgr::GetOffTankTargetIconFlags() | BotMgr::GetDPSTargetIconFlags()) & GroupIconsFlags[i]))
+                if (ObjectGuid gguid = gr->GetTargetIcons()[i])
+                    if (gguid == guid)
+                        return true;
+
+        for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+        {
+            Player const* p = ref->GetSource();
+            if (p && (p->GetPetGUID() == guid || (p->GetVehicle() && p->GetCharmedGUID() == guid)))
+                return true;
+            if (p && p->HaveBot())
+            {
+                if (Creature const* bot = p->GetBotMgr()->GetBot(guid))
+                    if (bot->GetGUID() == guid || (bot->GetBotsPet() && bot->GetBotsPet()->GetGUID() == guid) ||
+                        (bot->GetVehicle() && bot->GetCharmedGUID() == guid))
+                        return true;
+            }
+        }
+    }
+    else
+    {
+        if (master->GetPetGUID() == guid || (master->GetVehicle() && master->GetCharmedGUID() == guid))
+            return true;
+        if (Creature const* bot = master->GetBotMgr()->GetBot(guid))
+            if (bot->GetGUID() == guid || (bot->GetBotsPet() && bot->GetBotsPet()->GetGUID() == guid) ||
+                (bot->GetVehicle() && bot->GetCharmedGUID() == guid))
+                return true;
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/removes/reapplies aura
+void bot_ai::RefreshAura(uint32 spellId, int8 count, Unit* target) const
+{
+    if (count < 0 || count > 1)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): count is out of bounds (%i) for bot %s (botclass: %u, entry: %u)",
+            int32(count), me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return;
+    }
+
+    if (!spellId)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): spellId is 0 for bot %s (botclass: %u, entry: %u)",
+            me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return;
+    }
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), uint32(_botclass), me->GetEntry());
+        return;
+    }
+
+    if (!target)
+        target = me;
+
+    target->RemoveAurasDueToSpell(spellId);
+
+    //for (int8 i = 0; i < count; ++i)
+    if (count)
+        target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+}
+
+bool bot_ai::CanBotAttack(Unit const* target, int8 byspell, bool secondary) const
+{
+    if (!target)
+        return false;
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return false;
+    if (target->CanHaveThreatList() && GetEngageTimer() > lastdiff)
+        return false;
+    if (!BotMgr::IsPvPEnabled() && !IAmFree() && target->IsControlledByPlayer())
+        return false;
+    if (me->GetFaction() == 35 && IAmFree() && target->GetTypeId() == TYPEID_UNIT && target->GetVictim() != me)
+        return false;
+    if ((target->GetFaction() == 35 || target->GetFaction() == me->GetFaction()) && me->GetFaction() != 14)
+        return false;
+    if (!CanBotAttackOnVehicle())
+        return false;
+    if (IsPointedNoDPSTarget(target))
+        return false;
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!IAmFree() && IsRanged() && me->IsWithinLOSInMap(target))
+        _extendAttackRange(foldist);
+
+    SpellSchoolMask mainMask;
+    if (!byspell)
+        mainMask = SPELL_SCHOOL_MASK_NORMAL;
+    else
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_PRIEST:      mainMask = SPELL_SCHOOL_MASK_SHADOW;                                                                break;
+            case BOT_CLASS_SHAMAN:      mainMask = Rand() > 50 && me->GetLevel() >= 70 ? SPELL_SCHOOL_MASK_FIRE : SPELL_SCHOOL_MASK_NATURE; break;
+            case BOT_CLASS_MAGE:        mainMask = Rand() > 50 ? SPELL_SCHOOL_MASK_FIRE : SPELL_SCHOOL_MASK_FROST;                          break;
+            case BOT_CLASS_WARLOCK:     mainMask = Rand() > 50 ? SPELL_SCHOOL_MASK_SHADOW : SPELL_SCHOOL_MASK_FIRE;                         break;
+            case BOT_CLASS_DRUID:       mainMask = Rand() > 50 ? SPELL_SCHOOL_MASK_ARCANE : SPELL_SCHOOL_MASK_NATURE;                       break;
+            case BOT_CLASS_SPHYNX:      mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_ARCHMAGE:    mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_DREADLORD:   mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_SPELLBREAKER:mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_DARK_RANGER: mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_NECROMANCER: mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            case BOT_CLASS_SEA_WITCH:   mainMask = SPELL_SCHOOL_MASK_NONE;                                                                  break;
+            default:                    mainMask = SPELL_SCHOOL_MASK_NORMAL;                                                                break;
+        }
+    }
+
+    return
+        (target->IsAlive() && target->IsVisible() && me->IsValidAttackTarget(target) &&
+        target->isTargetableForAttack(false) && !IsInBotParty(target) &&
+        ((me->CanSeeOrDetect(target) && target->InSamePhase(me)) || CanSeeEveryone()) &&
+        (!master->IsAlive() || target->IsControlledByPlayer() ||
+        (followdist > 0 && (master->GetDistance(target) <= foldist || HasBotCommandState(BOT_COMMAND_STAY)))) &&//if master is killed pursue to the end
+        (!HasBotCommandState(BOT_COMMAND_STAY) ||
+        ((!IsRanged() && !secondary) ? me->IsWithinMeleeRange(target) : me->GetDistance(target) <= foldist)) &&//if stationery check own distance
+        (target->IsHostileTo(master) || target->IsHostileTo(me) ||//if master is controlled
+        (target->GetReactionTo(me) < REP_FRIENDLY && (master->IsInCombat() || target->IsInCombat()))) &&
+        (byspell == -1 || !target->IsTotem()) &&
+        (byspell == -1 || !mainMask || !target->IsImmunedToDamage(mainMask)));
+}
+bool bot_ai::CanBotAttackOnVehicle() const
+{
+    if (VehicleSeatEntry const* seat = me->GetVehicle() ? me->GetVehicle()->GetSeatForPassenger(me) : nullptr)
+        return seat->Flags & VEHICLE_SEAT_FLAG_CAN_ATTACK;
+
+    return true;
+}
+//GETVEHICLETARGET
+//Returns attack target or 'no target'
+//All code above 'x = _getVehicleTarget() call must not dereference opponent since it can be invalid
+Unit* bot_ai::_getVehicleTarget(BotVehicleStrats /*strat*/) const
+{
+    ASSERT(!IAmFree());
+    Creature* veh = me->GetVehicleCreatureBase();
+    Creature* masterVeh = master->GetVehicleCreatureBase();
+    ASSERT(veh);
+    //ASSERT(masterVeh);
+    Unit* mmover = masterVeh ? masterVeh->ToUnit() : master->ToUnit();
+    ObjectGuid curTarget = veh->GetTarget();
+
+    Unit* mytar = !curTarget.IsEmpty() ? ObjectAccessor::GetUnit(*veh, curTarget) : nullptr;
+
+    if (mytar && veh->HasAuraType(SPELL_AURA_MOD_TAUNT))
+        return mytar;
+
+    Group const* gr = !IAmFree() ? master->GetGroup() : nullptr;
+
+    if (gr && IsOffTank())
+    {
+        Unit* tankTar = nullptr;
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (BotMgr::GetOffTankTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid && mytar->GetVictim() == veh)
+                        return mytar;
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*veh, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && veh->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (veh->CanSeeOrDetect(unit) && unit->InSamePhase(veh))))
+                        {
+                            Unit* tempTar = tankTar ? tankTar : unit;
+                            tankTar = unit;
+                            Unit* tVic = unit->GetVictim();
+                            if (!tVic || (tVic != veh && tVic->GetVictim() == unit && IsTank(tVic) && IsInBotParty(tVic)))
+                            {
+                                tankTar = tempTar;
+                                continue;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (tankTar)
+            return tankTar;
+    }
+    if (gr)
+    {
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (ObjectGuid guid = gr->GetTargetIcons()[i])
+            {
+                if ((HasRole(BOT_ROLE_RANGED)|| HasVehicleRoleOverride(BOT_ROLE_RANGED)) &&
+                    (BotMgr::GetRangedDPSTargetIconFlags() & GroupIconsFlags[i]))
+                {
+                    if (mytar && mytar->GetGUID() == guid)
+                        return mytar;
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: found dps icon target %s", unit->GetName().c_str());
+                            return unit;
+                        }
+                    }
+                }
+                if (BotMgr::GetDPSTargetIconFlags() & GroupIconsFlags[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid)
+                        return mytar;
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*veh, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && veh->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (veh->CanSeeOrDetect(unit) && unit->InSamePhase(veh))))
+                            return unit;
+                    }
+                }
+            }
+        }
+    }
+
+    float followdist = float (master->GetBotMgr()->GetBotFollowDist() * 2);
+    if (float distOverride = GetVehicleAttackDistanceOverride())
+        followdist = distOverride * 2.f;
+    if (mytar && mytar->GetTypeId() == TYPEID_UNIT &&
+        mytar->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS)
+        followdist *= 1.5f;
+    else if (mmover->isMoving() && veh->GetMapId() == 578) //oculus
+        followdist *= 0.5f;
+
+    if (mytar && (veh->IsInCombat() || mytar->IsInCombat()) &&
+        (!masterVeh || !mmover->IsAlive() || mmover->GetDistance(mytar) < followdist) && veh->IsValidAttackTarget(mytar))
+        return mytar;
+
+    if (mmover->IsAlive())
+    {
+        if (followdist == 0 || (mytar &&
+            (mmover->GetDistance(mytar) > followdist || (mmover->GetDistance(mytar) > followdist * 0.75f && !mytar->IsWithinLOSInMap(veh)))))
+        {
+            //if (mytar)
+            //{
+            //    TC_LOG_ERROR("scripts", "_getVehicleTarget %s's veh is too far from master - lost target (%.2f > %.2f)",
+            //        me->GetName().c_str(), veh->GetDistance(mmover), followdist);
+            //}
+            return nullptr;
+        }
+    }
+
+    //check targets around
+    float maxdist = InitAttackRange(followdist, IsRanged());
+    Unit* t = nullptr;
+    NearbyHostileVehicleTargetCheck check(veh, maxdist, this);
+    Trinity::UnitSearcher <NearbyHostileVehicleTargetCheck> searcher(veh, t, check);
+    Cell::VisitAllObjects(veh, searcher, maxdist);
+    //veh->VisitNearbyObject(maxdist, searcher);
+
+    return t;
+}
+//GETTARGET
+//Returns attack target or 'no target' and distant check target or 'no target'
+//All code above 'x = _getTarget() call must not dereference opponent or disttarget since it can be invalid
+std::tuple<Unit*, Unit*> bot_ai::_getTargets(bool byspell, bool ranged, bool &reset) const
+{
+    //if (_evadeMode) //IAmFree() case only
+    //    return { nullptr, nullptr };
+
+    if (!CanBotAttackOnVehicle())
+        return { nullptr, nullptr };
+
+    Unit* mytar = me->GetVictim();
+
+    //check if no need to change target
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s", me->GetName().c_str());
+
+    if (mytar && me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+        return { mytar, mytar };
+
+    //Immediate targets
+    if (!IAmFree() && me->GetMap()->GetEntry() && !me->GetMap()->GetEntry()->IsWorldMap())
+    {
+        static const std::array WMOAreaGroupMarrowgar = { 47833u }; // The Spire
+        static const std::array WMOAreaGroupSindragosa = { 48066u }; // Frost Queen's Lair
+        static const std::array WMOAreaGroupLichKing = { 50038u, 50040u }; // The Frozen Throne
+
+        static auto isInWMOArea = [this](auto const& ids) {
+            for (auto wmoId : ids) {
+                if (wmoId == _lastWMOAreaId)
+                    return true;
+            }
+            return false;
+        };
+
+        // Icecrown Citadel - Lord Marrowgar
+        if (me->GetMapId() == 631 && isInWMOArea(WMOAreaGroupMarrowgar) && me->IsInCombat() && HasRole(BOT_ROLE_DPS) && !IsTank())
+        {
+            static const std::array BoneSpikeIds = { CREATURE_ICC_BONE_SPIKE1, CREATURE_ICC_BONE_SPIKE2, CREATURE_ICC_BONE_SPIKE3 };
+
+            auto boneSpikeCheck = [=, mydist = 50.f](Unit const* unit) mutable {
+                if (!unit->IsAlive())
+                    return false;
+                for (uint32 bsId : BoneSpikeIds) {
+                    if (unit->GetEntry() == bsId)  {
+                        if (HasRole(BOT_ROLE_RANGED))
+                            return true;
+                        float dist = me->GetDistance2d(unit);
+                        if (dist < mydist) {
+                            mydist = dist;
+                            return true;
+                        }
+                    }
+                }
+                return false;
+            };
+
+            std::list<Creature*> cList;
+            Trinity::CreatureListSearcher searcher(me, cList, boneSpikeCheck);
+            Cell::VisitAllObjects(me, searcher, 50.f);
+
+            if (Creature* spike = cList.empty() ? nullptr : cList.size() == 1 ? cList.front() :
+                Trinity::Containers::SelectRandomContainerElement(cList))
+            {
+                // Bone Spike is always attackable - no additional checks needed
+                return { spike, nullptr };
+            }
+        }
+
+        // Icecrown Citadel - Sindragosa
+        if (me->GetMapId() == 631 && isInWMOArea(WMOAreaGroupSindragosa)/* &&
+            (!mytar || (mytar->GetEntry() != CREATURE_ICC_ICE_TOMB1 && mytar->GetEntry() != CREATURE_ICC_ICE_TOMB2 &&
+            mytar->GetEntry() != CREATURE_ICC_ICE_TOMB3 && mytar->GetEntry() != CREATURE_ICC_ICE_TOMB4))*/)
+        {
+            static const std::array IceTombIds = { CREATURE_ICC_ICE_TOMB1, CREATURE_ICC_ICE_TOMB2, CREATURE_ICC_ICE_TOMB3, CREATURE_ICC_ICE_TOMB4 };
+            static const std::array SindragosaIds = { CREATURE_ICC_SINDRAGOSA1, CREATURE_ICC_SINDRAGOSA2, CREATURE_ICC_SINDRAGOSA3, CREATURE_ICC_SINDRAGOSA4 };
+
+            static auto SiItCheck = [=](Unit const* unit) {
+                if (unit->IsAlive())
+                {
+                    for (uint32 itId : IceTombIds)
+                        if (unit->GetEntry() == itId)
+                            return true;
+                    for (uint32 siId : SindragosaIds)
+                        if (unit->GetEntry() == siId)
+                            return true;
+                }
+                return false;
+            };
+
+            std::list<Creature*> cList;
+            Trinity::CreatureListSearcher searcher(master, cList, SiItCheck);
+            Cell::VisitAllObjects(me, searcher, 200.f);
+
+            if (!cList.empty())
+            {
+                Creature* sindragosa = nullptr;
+                Creature* icetomb = nullptr;
+                for (Creature* siit : cList)
+                {
+                    if (!icetomb)
+                    {
+                        for (uint32 itId : IceTombIds)
+                        {
+                            if (siit->GetEntry() == itId)
+                            {
+                                icetomb = siit;
+                                break;
+                            }
+                        }
+                    }
+                    if (!sindragosa)
+                    {
+                        for (uint32 siId : SindragosaIds)
+                        {
+                            if (siit->GetEntry() == siId)
+                            {
+                                sindragosa = siit;
+                                break;
+                            }
+                        }
+                    }
+                    else
+                        break;
+                }
+
+                if (icetomb)
+                {
+                    bool air_phase = sindragosa && sindragosa->GetReactState() == REACT_PASSIVE;
+                    bool above35 = GetHealthPCT(icetomb) > 35;
+                    if (!air_phase || above35)
+                        return { icetomb, nullptr };
+                    else if (mytar == icetomb || !master->GetVictim())
+                    {
+                        if (botPet && botPet->GetVictim())
+                            botPet->AttackStop();
+                        return { nullptr, nullptr };
+                    }
+                }
+            }
+        }
+
+        // Icecrown Citadel - The Lich King
+        if (me->GetMapId() == 631 && isInWMOArea(WMOAreaGroupLichKing) && me->IsInCombat() && HasRole(BOT_ROLE_DPS) && !IsTank())
+        {
+            static const std::array IceSphereIds = { CREATURE_ICC_ICE_SPHERE1, CREATURE_ICC_ICE_SPHERE2, CREATURE_ICC_ICE_SPHERE3, CREATURE_ICC_ICE_SPHERE4 };
+            static const std::array ValkyrShadowguardIds = { CREATURE_ICC_VALKYR_LK1, CREATURE_ICC_VALKYR_LK2, CREATURE_ICC_VALKYR_LK3, CREATURE_ICC_VALKYR_LK4 };
+
+            static auto valkyrCheck = [=](Unit const* unit) {
+                for (uint32 vsId : ValkyrShadowguardIds) {
+                    if (unit->IsAlive() && unit->GetEntry() == vsId && !unit->HasUnitFlag(UNIT_FLAG_UNINTERACTIBLE))
+                        return true;
+                }
+                return false;
+            };
+
+            Creature* valkyr = nullptr;
+            Trinity::CreatureSearcher searcher(me, valkyr, valkyrCheck);
+            Cell::VisitAllObjects(me, searcher, 50.f);
+
+            if (valkyr)
+                return { valkyr, nullptr };
+
+            Unit const* usearcher = master->IsAlive() ? master->ToUnit() : me->ToUnit();
+            auto iceSphereCheck = [=, mydist = 30.f](Unit const* unit) mutable {
+                for (uint32 isId : IceSphereIds) {
+                    if (unit->IsAlive() && unit->GetEntry() == isId) {
+                        float dist = usearcher->GetDistance2d(unit);
+                        if (dist < mydist && (HasRole(BOT_ROLE_RANGED) || dist < 7.f)) {
+                            mydist = dist;
+                            return true;
+                        }
+                    }
+                }
+                return false;
+            };
+
+            Creature* sphere = nullptr;
+            Trinity::CreatureLastSearcher searcher2(usearcher, sphere, iceSphereCheck);
+            Cell::VisitAllObjects(usearcher, searcher2, 30.f);
+
+            if (sphere)
+                return { sphere, nullptr };
+        }
+    }
+
+    Group const* gr = !IAmFree() ? master->GetGroup() : nullptr;
+
+    if (gr && IsOffTank())
+    {
+        Unit* tankTar = nullptr;
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (BotMgr::GetOffTankTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid && mytar->GetVictim() == me)
+                    {
+                        //TC_LOG_ERROR("entities.unit", "_getTarget: %s continues %s", me->GetName().c_str(), mytar->GetName().c_str());
+                        return { mytar, mytar };
+                    }
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: %s found new offtanking icon target %s", me->GetName().c_str(), unit->GetName().c_str());
+                            Unit* tempTar = tankTar ? tankTar : unit;
+                            tankTar = unit;
+                            Unit* tVic = unit->GetVictim();
+                            if (!tVic || (tVic != me && tVic->GetVictim() == unit && IsTank(tVic) && IsInBotParty(tVic)))
+                            {
+                                //TC_LOG_ERROR("entities.unit", "_getTarget: %s skipped %s (%s)", me->GetName().c_str(), unit->GetName().c_str(), tVic->GetName().c_str());
+                                tankTar = tempTar;
+                                continue;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (tankTar)
+        {
+            //TC_LOG_ERROR("entities.unit", "_getTarget: %s returning %s", me->GetName().c_str(), tankTar->GetName().c_str());
+            return { tankTar, tankTar };
+        }
+    }
+    if (gr && IsTank())
+    {
+        Unit* tankTar = nullptr;
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (BotMgr::GetTankTargetIconFlags() & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid && mytar->GetVictim() == me)
+                    {
+                        //TC_LOG_ERROR("entities.unit", "_getTarget: %s continues %s", me->GetName().c_str(), mytar->GetName().c_str());
+                        return { mytar, mytar };
+                    }
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: %s found new mtanking icon target %s", me->GetName().c_str(), unit->GetName().c_str());
+                            Unit* tempTar = tankTar ? tankTar : unit;
+                            tankTar = unit;
+                            Unit* tVic = unit->GetVictim();
+                            if (!tVic || (tVic != me && tVic->GetVictim() == unit && IsTank(tVic) && IsInBotParty(tVic)))
+                            {
+                                //TC_LOG_ERROR("entities.unit", "_getTarget: %s skipped %s (%s)", me->GetName().c_str(), unit->GetName().c_str(), tVic->GetName().c_str());
+                                tankTar = tempTar;
+                                continue;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+        if (tankTar)
+        {
+            //TC_LOG_ERROR("entities.unit", "_getTarget: %s returning %s", me->GetName().c_str(), tankTar->GetName().c_str());
+            return { tankTar, tankTar };
+        }
+    }
+    if (gr)
+    {
+        for (int8 i = TARGETICONCOUNT - 1; i >= 0; --i)
+        {
+            if (ObjectGuid guid = gr->GetTargetIcons()[i])
+            {
+                if (HasRole(BOT_ROLE_RANGED) && (BotMgr::GetRangedDPSTargetIconFlags() & GroupIconsFlags[i]))
+                {
+                    if (mytar && mytar->GetGUID() == guid)
+                        return { mytar, mytar };
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: found rdps icon target %s", unit->GetName().c_str());
+                            return { unit, unit };
+                        }
+                    }
+                }
+                if (BotMgr::GetDPSTargetIconFlags() & GroupIconsFlags[i])
+                {
+                    if (mytar && mytar->GetGUID() == guid)
+                        return { mytar, mytar };
+
+                    if (Unit* unit = ObjectAccessor::GetUnit(*me, guid))
+                    {
+                        if (unit->IsVisible() && unit->isTargetableForAttack(false) && me->IsValidAttackTarget(unit) &&
+                            unit->IsInCombat() && (CanSeeEveryone() || (me->CanSeeOrDetect(unit) && unit->InSamePhase(me))))
+                        {
+                            //TC_LOG_ERROR("entities.unit", "_getTarget: found dps icon target %s", unit->GetName().c_str());
+                            return { unit, unit };
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    Unit* u = master->GetVictim();
+//Disabled due to a bug:
+//when spell cast is finished target is immideately put in combat which makes bots attack immediately
+//caster must be put in combat at spell launch
+//but target must be put in combat at spell hit
+/*
+    if (!u && !IAmFree() && master->IsInCombat() && Rand() < 15)
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+        {
+            if (Spell const* spell = master->GetCurrentSpell(CurrentSpellTypes(i)))
+            {
+                //if (spell->getState() == SPELL_STATE_FINISHED)
+                //    continue;
+
+                if (mytar && spell->m_targets.GetUnitTargetGUID() == mytar->GetGUID())
+                {
+                    u = mytar;
+                    break;
+                }
+
+                //direct damaging spells
+                if (!spell->GetSpellInfo()->IsPositive() &&
+                    (spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_WEAPON_DAMAGE) ||
+                    spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+                    spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL)))
+                {
+                    Unit* victim = ObjectAccessor::GetUnit(*me, spell->m_targets.GetUnitTargetGUID());
+                    if (victim && victim->IsInCombat())
+                    {
+                        u = victim;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+*/
+    if (u && u == mytar && !IAmFree() && u->GetTypeId() == TYPEID_PLAYER && CanBotAttack(u, byspell))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return { u, u };//forced
+    }
+    //Follow if...
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() / 2 : master->GetBotMgr()->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!IAmFree() && IsRanged())
+    {
+        _extendAttackRange(foldist);
+        //TC_LOG_ERROR("entities.player", "bot %s ranged foldist %.2f spelldist %.2f", me->GetName().c_str(), foldist, spelldist);
+    }
+    bool dropTarget = followdist == 0 && master->IsAlive();
+    if (!dropTarget && (!u || IAmFree()) && master->IsAlive() && mytar && mytar == opponent)
+    {
+        dropTarget = IAmFree() ?
+            me->GetDistance(mytar) > foldist :
+            HasBotCommandState(BOT_COMMAND_STAY) ?
+            (!IsRanged() ? !me->IsWithinMeleeRange(mytar) : me->GetDistance(mytar) > foldist) :
+            (master->GetDistance(mytar) > foldist || (master->GetDistance(mytar) > foldist * 0.75f && !mytar->IsWithinLOSInMap(me)));
+    }
+    if (dropTarget)
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away or not in LoS", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "unk");
+        mytar = nullptr;
+    }
+
+    if (u && !IAmFree() && (master->IsInCombat() || u->IsInCombat())/* && !InDuel(u)*/ && !IsInBotParty(u) && (BotMgr::IsPvPEnabled() || !u->IsControlledByPlayer()) &&
+        (!HasBotCommandState(BOT_COMMAND_STAY) || (!IsRanged() ? me->IsWithinMeleeRange(u) : me->GetDistance(u) < foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return { u, u };
+    }
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && CanBotAttack(mytar, byspell) &&/* !InDuel(mytar) &&*/
+        !(mytar->GetVictim() != nullptr && IsTank() && IsTank(mytar->GetVictim())))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && !HasBotCommandState(BOT_COMMAND_MASK_UNCHASE))
+            reset = true;
+        return { mytar, mytar };
+    }
+
+    //check group
+    if (!IAmFree())
+    {
+        if (!gr)
+        {
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Creature const* bot = itr->second;
+                if (!bot || bot == me || !bot->InSamePhase(me)) continue;
+                if (IsTank() && IsTank(bot)) continue;
+                u = bot->GetVictim();
+                if (u && (bot->IsInCombat() || u->IsInCombat()) && CanBotAttack(u, byspell))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return { u, u };
+                }
+            }
+        }
+        else
+        {
+            for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+            {
+                Player const* pl = ref->GetSource();
+                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                if (IsTank() && IsTank(pl)) continue;
+                u = pl->GetVictim();
+                if (u && pl != master && (pl->IsInCombat() || u->IsInCombat()) && CanBotAttack(u, byspell))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                    return { u, u };
+                }
+                if (!pl->HaveBot()) continue;
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (!bot || bot == me || !bot->InSamePhase(me)) continue;
+                    if (!bot->IsInWorld()) continue;
+                    if (me->GetMap() != bot->FindMap()) continue;
+                    if (IsTank() && IsTank(bot)) continue;
+                    u = bot->GetVictim();
+                    if (u && (bot->IsInCombat() || u->IsInCombat()) && CanBotAttack(u, byspell))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                        return { u, u };
+                    }
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t1 = nullptr;
+    Unit* t2 = nullptr;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t1)
+        {
+            bool attackCC = i;
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC, !IsRanged() && HasBotCommandState(BOT_COMMAND_STAY));
+            Unit2LastSearcher<NearestHostileUnitCheck> searcher(t1, t2, check);
+            Cell::VisitAllObjects(HasBotCommandState(BOT_COMMAND_STAY) ? me->ToUnit() : master->ToUnit(), searcher, maxdist);
+            //me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    Unit* curtar = opponent ? opponent : disttarget ? disttarget : nullptr;
+    if (t1 && curtar && t1 != curtar)
+        reset = true;
+
+    //Allow free bots to ignore temp invulnerabilities if no other target is present
+    if (IAmFree() && t1 == nullptr)
+        t1 = mytar;
+
+    //if (t)
+    //    TC_LOG_ERROR("entities.player", "bot %s has found new target %s", me->GetName().c_str(), t->GetName().c_str());
+
+    return { t1, t2 };
+}
+//'CanAttack' function
+//Only called in class ai UpdateAI function
+//Side effects: opponent, disttarget
+bool bot_ai::CheckAttackTarget()
+{
+    if (IsDuringTeleport()/* || _evadeMode*/)
+    {
+        //me->AttackStop(); //already in CombatStop()
+        me->CombatStop(true);
+        return false;
+    }
+
+    if (IAmFree() && Feasting())
+        return false;
+
+    bool ranged = HasRole(BOT_ROLE_RANGED);
+    bool byspell = false;
+    bool reset = false;
+
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            switch (GetBotStance())
+            {
+                case DRUID_CAT_FORM:
+                case DRUID_BEAR_FORM:
+                    break;
+                case DRUID_TREE_FORM:
+                case DRUID_TRAVEL_FORM:
+                case DRUID_AQUATIC_FORM:
+                //case DRUID_FLIGHT_FORM:
+                    ranged = true;
+                    break;
+                case DRUID_MOONKIN_FORM:
+                    byspell = true;
+                    break;
+                case BOT_STANCE_NONE:
+                    byspell = ranged && HasRole(BOT_ROLE_DPS);
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "bot_ai::CheckAttackTarget(): druid has NYI bot stance %u", uint32(GetBotStance()));
+                    break;
+            }
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            byspell = ranged && HasRole(BOT_ROLE_DPS);
+            break;
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_NECROMANCER:
+            byspell = HasRole(BOT_ROLE_DPS);
+            break;
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_BM:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+        case BOT_CLASS_SEA_WITCH:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown bot class %u", _botclass);
+            return false;
+    }
+
+    std::tie(opponent, disttarget) = _getTargets(byspell, ranged, reset);
+
+    if (!opponent && !disttarget)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s lost target", me->GetName().c_str());
+        if (me->GetVictim() || me->IsInCombat()/* || !me->GetThreatManager().isThreatListEmpty()*/)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s Evades", me->GetName().c_str());
+            if (me->GetVictim())
+                me->AttackStop();
+            else if (me->IsInCombat())
+                Evade();
+        }
+    }
+    else
+    {
+        Unit* mytar = opponent ? opponent : disttarget;
+        //boss engage phase // CanHaveThreatList checks for typeid == UNIT
+        if (GetEngageTimer() > lastdiff)
+            return false;
+        else if (!IsTank() && mytar != me->GetVictim() && mytar->GetVictim() && mytar->CanHaveThreatList() &&
+            mytar->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_WORLDBOSS && me->GetMap()->IsRaid())
+        {
+            uint32 threat = uint32(mytar->ToCreature()->GetThreatManager().GetThreat(mytar->GetVictim()));
+            if (threat < std::min<uint32>(50000, mytar->GetVictim()->GetMaxHealth() / 2))
+                return false;
+        }
+
+        if (reset)
+            SetBotCommandState(BOT_COMMAND_COMBATRESET);//reset AttackStart()
+
+        if (mytar != me->GetVictim())
+            me->Attack(mytar, !ranged);
+    }
+
+    return true;
+}
+//IMMEDIATE TARGETS
+bool bot_ai::ProcessImmediateNonAttackTarget()
+{
+    if ((me->GetMap()->GetEntry() && me->GetMap()->GetEntry()->IsWorldMap()) || IAmFree() || IsCasting())
+        return false;
+
+    static constexpr std::array<uint32, 2> WMOAreaGroupMuru = { 41736, 42759 }; // Shrine of the Eclipse
+    static constexpr std::array<uint32, 2> WMOAreaGroupNajentus = { 41129, 41130 }; // Karabor Sewers
+
+    static auto isInWMOArea = [=](auto const& ids) {
+        for (auto wmoId : ids) {
+            if (wmoId == _lastWMOAreaId)
+                return true;
+        }
+        return false;
+    };
+
+    if (me->GetMapId() == 580 && isInWMOArea(WMOAreaGroupMuru)) // Sunwell - M'uru
+    {
+        static const uint32 SPELL_PURGE_1 = 370u;
+        static const uint32 SPELL_DISPEL_MAGIC_1 = 527u;
+        uint32 dspell = 0;
+        if (_botclass == BOT_CLASS_SHAMAN)
+            dspell = SPELL_PURGE_1;
+        else if (_botclass == BOT_CLASS_PRIEST)
+            dspell = SPELL_DISPEL_MAGIC_1;
+
+        if (dspell && IsSpellReady(dspell, lastdiff))
+        {
+            std::list<Creature*> cList;
+            Trinity::AllCreaturesOfEntryInRange check(me, 25744, 30.f); // Dark Fiend
+            Trinity::CreatureListSearcher<Trinity::AllCreaturesOfEntryInRange> searcher(me, cList, check);
+            Cell::VisitAllObjects(me, searcher, 30.f);
+
+            //Dark Fiends do not die instantly, remove purged ones
+            cList.remove_if(Trinity::UnitAuraCheck(false, 45934)); // "Dark Fiend"
+
+            if (Unit* fiend = cList.empty() ? nullptr : cList.size() == 1u ? cList.front() :
+                Trinity::Containers::SelectRandomContainerElement(cList))
+            {
+                if (CheckBotCast(fiend, GetSpell(dspell)) == SPELL_CAST_OK)
+                    if (doCast(fiend, GetSpell(dspell)))
+                        return true;
+            }
+        }
+    }
+    if (me->GetMapId() == 564 && isInWMOArea(WMOAreaGroupNajentus) && Rand() < 10) // Black Temple - High Warlord Naj'entus
+    {
+        if (Group const* gr = master->GetGroup())
+        {
+            if (Rand() < 4)
+            {
+                InstanceScript* iscript = me->GetMap()->ToInstanceMap()->GetInstanceScript();
+                Unit* najentus = iscript ? iscript->GetCreature(0) : nullptr; // boss_warlord_najentus.cpp::DATA_HIGH_WARLORD_NAJENTUS
+
+                if (najentus && najentus->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127)) // Tidal Shield
+                {
+                    //Try to grab spines from corpses of dead players
+                    std::vector<Player*> spiners;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* pl = itr->GetSource();
+                        if (pl && pl->IsInWorld() && me->GetMap() == pl->FindMap() && !pl->IsAlive() &&
+                            me->GetDistance(pl) < 25.f && pl->HasItemCount(32408)) // Naj'entus Spine
+                            spiners.push_back(pl);
+                    }
+
+                    if (Player* pl = spiners.empty() ? nullptr : spiners.size() == 1u ? spiners.front() :
+                        Trinity::Containers::SelectRandomContainerElement(spiners))
+                    {
+                        BotWhisper("Taking 1 Naj'entus Spine from you");
+                        me->CastSpell(najentus, 39948, true); // Hurl Spine
+                        pl->DestroyItemCount(32408, 1, true); // Naj'entus Spine
+                    }
+                }
+            }
+
+            std::vector<Unit*> spines;
+            //Find and free impaled player (player gets the spine)
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                //We don't make bots run to player to "click" the spine, so range is rather big
+                if (pl && pl->IsInWorld() && me->GetMap() == pl->FindMap())
+                {
+                    auto is_impaled = [=](Unit const* unit) -> bool {
+                        return unit->IsAlive() && unit->HasUnitState(UNIT_STATE_STUNNED) &&
+                            me->GetDistance(unit) < 25.f && unit->HasAura(39837); // "Impaling Spine"
+                    };
+
+                    if (is_impaled(pl))
+                        spines.push_back(pl->ToUnit());
+                    if (pl->HaveBot())
+                    {
+                        BotMap const* bmap = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator ci = bmap->begin(); ci != bmap->end(); ++ci)
+                        {
+                            Creature* bot = ci->second;
+                            if (bot && is_impaled(bot))
+                                spines.push_back(bot->ToUnit());
+                        }
+                    }
+                }
+            }
+
+            if (Unit* u = spines.empty() ? nullptr : spines.size() == 1u ? spines.front() :
+                Trinity::Containers::SelectRandomContainerElement(spines))
+            {
+                if (GameObject const* spine = u->GetFirstGameObjectById(185584)) // Naj'entus Spine
+                {
+                    Player* receiver = u->GetTypeId() == TYPEID_PLAYER ? u->ToPlayer() : master;
+                    if (spine->AI() && spine->AI()->OnGossipHello(receiver))
+                    {
+                        // Item is created by spell 39956 Create Naj'entus Spine - cannot target dead, force add item
+                        if (!receiver->IsAlive())
+                            receiver->AddItem(32408, 1); // Naj'entus Spine
+                        return true;
+                    }
+                }
+            }
+        }
+    }
+
+    return false;
+}
+//POSITION
+AoeSpotsVec const& bot_ai::GetAoeSpots() const
+{
+    return master->GetBotMgr()->GetAoeSpots();
+}
+
+void bot_ai::CalculateAoeSpots(Unit const* unit, AoeSpotsVec& spots)
+{
+    std::list<WorldObject*> doList;
+    NearbyHostileAoEDynobjectCheck check(unit, 60.f);
+    Trinity::WorldObjectListSearcher<NearbyHostileAoEDynobjectCheck> searcher(unit, doList, check, GRID_MAP_TYPE_MASK_DYNAMICOBJECT);
+    //unit->VisitNearbyObject(60.f, searcher);
+    Cell::VisitAllObjects(unit, searcher, 60.f);
+
+    //if (!doList.empty())
+    //    TC_LOG_ERROR("scripts", "CalculateAoeSpots %u aoes around %s", uint32(doList.size()), unit->GetName().c_str());
+
+    //filter and add to list
+    DynamicObject const* dObj;
+    SpellInfo const* spellInfo;
+    for (std::list<WorldObject*>::const_iterator ci = doList.begin(); ci != doList.end(); ++ci)
+    {
+        dObj = (*ci)->ToDynObject();
+        ASSERT_NODEBUGINFO(dObj);
+        ASSERT_NODEBUGINFO(dObj->GetSpellId());
+        spellInfo = sSpellMgr->GetSpellInfo(dObj->GetSpellId());
+        if (IsPeriodicDynObjAOEDamage(spellInfo))
+        {
+            //TC_LOG_ERROR("scripts", "CalculateAoeSpots found %s's aoe %s (%u) radius %.2f size %.2f",
+            //    dObj->GetCaster()->GetName().c_str(), spellInfo->SpellName[0], spellInfo->Id, dObj->GetRadius(), dObj->GetObjectSize());
+
+            float radius = dObj->GetRadius() + DEFAULT_PLAYER_BOUNDING_RADIUS;
+            radius += (unit->GetVehicle() ? unit->GetVehicleBase()->GetCombatReach() : DEFAULT_PLAYER_COMBAT_REACH) * 1.2f;
+            spots.push_back(AoeSpotsVec::value_type(*dObj, radius));
+        }
+    }
+
+    //Additional: aoe coming from spawned npcs
+
+    //The Eye of Eternity
+    if (unit->GetMapId() == 616 && unit->GetVehicle())
+    {
+        std::list<Creature*> cList;
+        Trinity::AllCreaturesOfEntryInRange check2(unit->GetVehicleBase(), CREATURE_EOE_STATIC_FIELD, 60.f);
+        Trinity::CreatureListSearcher<Trinity::AllCreaturesOfEntryInRange> searcher2(unit->GetVehicleBase(), cList, check2);
+        //unit->GetVehicleBase()->VisitNearbyObject(60.f, searcher2);
+        Cell::VisitAllObjects(unit->GetVehicleBase(), searcher2, 60.f);
+
+        spellInfo = sSpellMgr->GetSpellInfo(57429); //Static Field damage
+        for (std::list<Creature*>::const_iterator ci = cList.begin(); ci != cList.end(); ++ci)
+        {
+            float radius = spellInfo->_effects[0].CalcRadius() + unit->GetVehicleBase()->GetCombatReach() * 1.2f;
+            spots.push_back(AoeSpotsVec::value_type(*(*ci), radius));
+        }
+    }
+    //Zul'Aman
+    else if (unit->GetMapId() == 568)
+    {
+        std::list<Creature*> cList;
+        Trinity::AllCreaturesOfEntryInRange check2(unit, CREATURE_ZA_FIRE_BOMB, 40.f);
+        Trinity::CreatureListSearcher<Trinity::AllCreaturesOfEntryInRange> searcher2(unit, cList, check2);
+        //unit->VisitNearbyObject(40.f, searcher2);
+        Cell::VisitAllObjects(unit, searcher2, 40.f);
+
+        spellInfo = sSpellMgr->GetSpellInfo(42630); //Fire Bomb
+        for (std::list<Creature*>::const_iterator ci = cList.begin(); ci != cList.end(); ++ci)
+        {
+            float radius = spellInfo->_effects[0].CalcRadius() + DEFAULT_PLAYER_COMBAT_REACH * 1.2f;
+            spots.push_back(AoeSpotsVec::value_type(*(*ci), radius));
+        }
+    }
+    //Icecrown Citadel
+    else if (unit->GetMapId() == 631)
+    {
+        std::list<Creature*> cList;
+        Trinity::AllCreaturesOfEntryInRange check2(unit, CREATURE_ICC_OOZE_PUDDLE, 50.f);
+        Trinity::CreatureListSearcher<Trinity::AllCreaturesOfEntryInRange> searcher2(unit, cList, check2);
+        //unit->VisitNearbyObject(50.f, searcher2);
+        Cell::VisitAllObjects(unit, searcher2, 50.f);
+
+        for (std::list<Creature*>::const_iterator ci = cList.begin(); ci != cList.end(); ++ci)
+        {
+            float radius = (*ci)->GetObjectScale() * 2.5f + DEFAULT_PLAYER_COMBAT_REACH * 3.f; //grows
+            spots.push_back(AoeSpotsVec::value_type(*(*ci), radius));
+        }
+    }
+}
+
+void bot_ai::CalculateAoeSafeSpots(Unit* target, float maxdist, AoeSafeSpotsVec& safespots) const
+{
+    if (!IAmFree() && !GetAoeSpots().empty())
+    {
+        //find 200 safe spots
+        Position ppos;
+        float distdelta = maxdist / 200.f;
+        float angledelta = float(M_PI) / 12.5f;
+        float aoedist = 0.f;
+        float aoeangle;
+        for (uint8 i = 0; i < 8; ++i)
+        {
+            aoeangle = 0.0f;
+            for (uint8 j = 0; j < 25; ++j)
+            {
+                aoedist += distdelta;
+                aoeangle += angledelta;
+
+                ppos = target->GetFirstCollisionPosition(aoedist, Position::NormalizeOrientation(aoeangle - target->GetOrientation()));
+                bool toofaraway = master->GetDistance(ppos) > maxdist;
+
+                if (!toofaraway && !IsWithinAoERadius(ppos))
+                    safespots.push_back(ppos);
+            }
+        }
+    }
+}
+
+bool bot_ai::IsPeriodicDynObjAOEDamage(SpellInfo const* spellInfo)
+{
+    if (!spellInfo->IsPositive())
+    {
+        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->_effects[i].Effect == SPELL_EFFECT_PERSISTENT_AREA_AURA &&
+                spellInfo->_effects[i].ApplyAuraName != 0)
+            {
+                switch (spellInfo->_effects[i].ApplyAuraName)
+                {
+                    case SPELL_AURA_PERIODIC_DAMAGE:
+                    case SPELL_AURA_PERIODIC_DAMAGE_PERCENT:
+                    case SPELL_AURA_POWER_BURN:
+                    case SPELL_AURA_PERIODIC_LEECH:
+                    //Most of these are damaging spells
+                    case SPELL_AURA_PERIODIC_TRIGGER_SPELL:
+                    case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+                    //Scripted spells (mostly, some of these are wrong or not periodic damage)
+                    case SPELL_AURA_PERIODIC_DUMMY:
+                    //Channeled spells with SPELL_AURA_PERIODIC_TRIGGER_SPELL -> damage on TARGET_DEST_CHANNEL_TARGET (mostly)
+                    case SPELL_AURA_DUMMY:
+                        return true;
+                    default:
+                        break;
+                }
+            }
+        }
+    }
+    return false;
+}
+bool bot_ai::IsWithinAoERadius(Position const& pos) const
+{
+    if (!IAmFree())
+    {
+        AoeSpotsVec const& spots = GetAoeSpots();
+        if (!spots.empty())
+        {
+            Unit const* mover = me->GetVehicle() ? me->GetVehicleBase() : me;
+            float cr_diff = mover->GetCombatReach() - DEFAULT_PLAYER_COMBAT_REACH;
+            for (AoeSpotsVec::const_iterator ci = spots.begin(); ci != spots.end(); ++ci)
+                if (pos.GetExactDist(&ci->first) - cr_diff < ci->second)
+                    return true;
+        }
+    }
+
+    return false;
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    /*if (IAmFree())
+        origRange = sWorld->GetMaxVisibleDistanceOnContinents();
+    else */if (!master->IsAlive())
+        origRange = sWorld->GetMaxVisibleDistanceOnContinents();
+    else if (me->HasAuraType(SPELL_AURA_MOUNTED))
+        origRange *= 0.2f;
+    else if (ranged)
+        origRange *= 1.25f;
+
+    return origRange;
+}
+void bot_ai::_extendAttackRange(float& dist) const
+{
+    ASSERT(!IAmFree());
+
+    uint8 rangeMode = master->GetBotMgr()->GetBotAttackRangeMode();
+    if (master->GetBotMgr()->GetBotFollowDist() > 0)
+    {
+        float spelldist;
+        if (rangeMode == BOT_ATTACK_RANGE_EXACT)
+            spelldist = master->GetBotMgr()->GetBotExactAttackRange();
+        else
+            spelldist = GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG);
+        dist = std::max<float>(dist, spelldist * 0.5f + 4.f);
+    }
+}
+//Ranged attack position
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos, bool& force) const
+{
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    uint8 rangeMode = IAmFree() ? uint8(BOT_ATTACK_RANGE_LONG) : master->GetBotMgr()->GetBotAttackRangeMode();
+    uint8 exactRange = rangeMode != BOT_ATTACK_RANGE_EXACT || IAmFree() ? 255 : master->GetBotMgr()->GetBotExactAttackRange();
+    uint8 angleMode = IAmFree() ? uint8(BOT_ATTACK_ANGLE_NORMAL) : master->GetBotMgr()->GetBotAttackAngleMode();
+    float dist = (rangeMode == BOT_ATTACK_RANGE_EXACT) ? exactRange : GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG) - 4.f;
+    float angle = target->GetAbsoluteAngle(me);
+    if ((target->m_movementInfo.GetMovementFlags() & MOVEMENTFLAG_FORWARD) && target->HasInArc(float(M_PI)/1.5f, me))
+        dist = std::min<float>(dist + 10.f, 30.f);
+
+    //if ranged try to acquire a position in the back (will be ignored if too far away from master)
+    if (angleMode == BOT_ATTACK_ANGLE_AVOID_FRONTAL_AOE)
+    {
+        static const float rangedAngleDelta = float(M_PI) * 0.62f;
+        if (HasRole(BOT_ROLE_RANGED) && !IAmFree() && !target->IsControlledByPlayer() && target->HasInArc(float(M_PI), me) &&
+            (IsTank(master) || master->GetDistance(target) < 2.5f || !target->HasInArc(float(M_PI), master)))
+            angle += (target->GetRelativeAngle(master) > 0.f) ? rangedAngleDelta : -rangedAngleDelta;
+    }
+
+    float clockwise = (me->GetEntry() % 2) ? 1.f : -1.f;
+    float angleDelta1 = ((IsTank(master) && !IsTank(me)) ? frand(float(M_PI)*0.40f, float(M_PI)*0.60f) : frand(0.0f, float(M_PI)*0.15f)) * clockwise;
+    float angleDelta2 = frand(0.0f, float(M_PI)*0.08f) * clockwise;
+
+    Position ppos;
+
+    if (me->GetVehicle())
+    {
+        ASSERT(!IAmFree());
+
+        if (float vehdist = GetVehicleAttackDistanceOverride())
+            dist = vehdist + 5.f;
+
+        uint8 posSlot = master->GetBotMgr()->GetNpcBotSlot(me);
+        clockwise = (posSlot % 2) ? 1.f : -1.f;
+
+        Unit* angunit = target->GetVictim() ? target->GetVictim() : master->GetVehicle() ? master->GetVehicleBase() : master;
+        if (angunit == me->GetVehicleBase() || angunit == me)
+            angle = target->GetAbsoluteAngle(me->GetVehicleBase());
+        else
+            angle = target->GetAbsoluteAngle(angunit) + 0.5f * M_PI / master->GetNpcBotsCount() * posSlot * clockwise;
+
+        for (uint8 i = 0; i < 4; ++i)
+        {
+            if (me->GetVehicleBase()->CanFly())
+            {
+                //collision point bug, distance shinked to 0, so use GetNearPoint
+                float &tx = ppos.m_positionX, &ty = ppos.m_positionY, &tz = ppos.m_positionZ;
+                target->GetNearPoint(me->GetVehicleBase(), tx, ty, tz, dist, Position::NormalizeOrientation(angle));
+                if (!target->IsWithinLOS(tx, ty, tz))
+                    dist *= i >= 3 ? 0.2f : i >= 2 ? 0.5f : 0.75f;
+            }
+            else
+                ppos = target->GetFirstCollisionPosition(dist, Position::NormalizeOrientation(angle - target->GetOrientation()));
+            //target->GetNearPoint(me->GetVehicleBase(), x, y, z, 0.f, dist, Position::NormalizeOrientation(angle));
+
+            bool toofar = master->GetDistance(ppos) > (followdist > 30.f ? 60.f : followdist < 10 ? 20.f : float(followdist*2));
+            bool isinaoe = (i == 0 && me->GetVehicleBase()->GetDistance(ppos) < 4.f && IsWithinAoERadius(*me->GetVehicleBase())) || IsWithinAoERadius(ppos);
+            if (!toofar && !isinaoe)
+                break;
+
+            if (toofar)
+            {
+                if (i >= 1)
+                    angle += -(clockwise) * angleDelta1/* * i*/;
+                if (i >= 2)
+                    dist = std::max(0.f, dist - 5.f);
+            }
+            if (isinaoe)
+            {
+                //TC_LOG_ERROR("scripts", "CalculateAttackPos %s veh skipped aoe pos", me->GetName().c_str());
+                if (me->GetVehicleBase()->CanFly())
+                    ppos.m_positionZ += (master->GetPositionZ() < target->GetPositionZ()) ? -8.f : 8.f;
+                else
+                    angle += angleDelta2 * 2.f;
+            }
+        }
+
+        pos.Relocate(ppos);
+        //pos.m_positionX = x;
+        //pos.m_positionY = y;
+        //pos.m_positionZ = z;
+
+        return;
+    }
+
+    AoeSpotsVec const& aoespots = IAmFree() ? AoeSpotsVec() : GetAoeSpots();
+
+    bool toofaraway;
+
+    if (!aoespots.empty())
+    {
+        ppos.Relocate(me);
+        toofaraway = master->GetDistance(ppos) > (followdist > 38 ? 38.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(ppos.m_positionX, ppos.m_positionY, ppos.m_positionZ);
+        bool isinaoe = IsWithinAoERadius(ppos);
+        bool canattack = HasRole(BOT_ROLE_RANGED) || me->IsWithinMeleeRangeAt(ppos, target);
+        if (!toofaraway && !outoflos && !isinaoe && canattack)
+        {
+            //if (!aoespots.empty())
+            //    TC_LOG_ERROR("scripts", "CalculateAttackPos %s spot is still safe", me->GetName().c_str());
+
+            pos.Relocate(ppos);
+            return;
+        }
+    }
+
+    AoeSafeSpotsVec safespots;
+    CalculateAoeSafeSpots(target, float(followdist), safespots);
+
+    bool angle_reset_to_master = false;
+    for (uint8 i = 0; i < 5; ++i)
+    {
+        ppos = target->GetFirstCollisionPosition(dist, Position::NormalizeOrientation(angle - target->GetOrientation()));
+        toofaraway = master->GetDistance(ppos) > (followdist > 38 ? 38.f : followdist < 20 ? 20.f : float(followdist));
+        if (!toofaraway)
+            break;
+
+        if (!angle_reset_to_master)
+        {
+            angle_reset_to_master = true;
+            angle = target->GetAbsoluteAngle(master);
+        }
+        else
+            angle += angleDelta1;
+
+        if (i >= 1 && i <= 3)
+            dist = std::max<float>(0.f, dist - 5.f);
+    }
+
+    if (!safespots.empty())
+    {
+        //find closest safe spot
+        Position const* closestPos = nullptr;
+        Position const* closestAttackPos = nullptr;
+        float minposdist = 100.f;
+        float minattackposdist = 100.f;
+        for (AoeSafeSpotsVec::const_iterator ci = safespots.begin(); ci != safespots.end(); ++ci)
+        {
+            float curdist = me->GetExactDist2d(*ci);
+            if (curdist < minposdist)
+            {
+                closestPos = &(*ci);
+                minposdist = curdist;
+            }
+            if (curdist < minattackposdist &&
+                (HasRole(BOT_ROLE_RANGED) ? (target->GetDistance(*ci) - me->GetCombatReach() < dist) : me->IsWithinMeleeRangeAt(*ci, target)))
+            {
+                closestAttackPos = &(*ci);
+                minattackposdist = curdist;
+            }
+        }
+
+        //TC_LOG_ERROR("scripts", "CalculateAttackPos %u safe spots, chosen at dist %.2f", uint32(safespots.size()), mindist);
+        pos.Relocate(closestAttackPos ? closestAttackPos : closestPos ? closestPos : me);
+        force = true;
+        return;
+    }
+    else if (!aoespots.empty() && !IAmFree())
+    {
+        pos.Relocate(master);
+        force = true;
+        return;
+    }
+
+    pos.Relocate(ppos);
+    if (!me->IsWithinLOSInMap(target))
+        force = true;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    Unit* mover = me->GetVehicle() ? me->GetVehicleBase() : me;
+    if (HasBotCommandState(BOT_COMMAND_STAY))
+        return;
+    if (!IAmFree() && !master->GetBotMgr()->GetBotAllowCombatPositioning())
+        return;
+    if (CCed(mover, true) || (mover == me && JumpingOrFalling()))
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || (mover->isMoving()/* && Rand() > 50*/)) && !force)
+        return;
+    if (IsCasting(mover))
+        return;
+    if (IsShootingWand(mover) && newtarget->GetVictim() == mover)
+        return;
+    if (UpdateImpossibleChase(newtarget))
+        return;
+    if (AdjustTankingPosition(newtarget))
+        return;
+
+    if (!IAmFree() && master->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+        master->GetBotMgr()->GetBotExactAttackRange() == 0)
+    {
+        attackpos.m_positionX = newtarget->GetPositionX() - frand(0.5f, 1.5f) * std::cos(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionY = newtarget->GetPositionY() - frand(0.5f, 1.5f) * std::sin(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionZ = newtarget->GetPositionZ();
+        if (me->GetExactDist2d(&attackpos) > 3.5f)
+            BotMovement(BOT_MOVE_POINT, &attackpos);
+            //me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+        return;
+    }
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : master->GetBotMgr()->GetBotFollowDist();
+    if (IsRanged() || (!IAmFree() && !GetAoeSpots().empty()))
+    {
+        //do not allow constant runaway from player
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3))
+            return;
+
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos, force);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        //TC_LOG_ERROR("scripts", "GetInPosition %s to %s dist %.2f, to pos %.2f", me->GetName().c_str(),
+        //    newtarget->GetName().c_str(), me->GetExactDist2d(newtarget), me->GetExactDist2d(&attackpos));
+        if (mover->GetExactDist2d(&attackpos) > (force ? 0.1f : 4.f))
+        {
+            BotMovement(BOT_MOVE_POINT, &attackpos);
+            //me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+            if (mover == me && !me->HasUnitState(UNIT_STATE_MELEE_ATTACKING) && CanBotAttackOnVehicle())
+                me->SetInFront(newtarget);
+            else if (!mover->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                mover->SetInFront(newtarget);
+        }
+    }
+    else
+    {
+        if (!JumpingOrFalling() && ((!mover->HasUnitState(UNIT_STATE_CHASE) && !mover->isMoving()) || (!mover->HasUnitState(UNIT_STATE_CHASE_MOVE) && mover->GetDistance(newtarget) > 1.5f)))
+            BotMovement(BOT_MOVE_CHASE, nullptr, newtarget);
+            //me->GetMotionMaster()->MoveChase(newtarget);
+    }
+
+    if (newtarget != me->GetVictim() && (mover == me || CanBotAttackOnVehicle()))
+    {
+        if (!me->Attack(newtarget, !HasRole(BOT_ROLE_RANGED)))
+            me->SetInFront(newtarget);
+    }
+}
+//Bots cannot dodge/parry from behind so try to condense enemies at front
+//opponent is always valid
+bool bot_ai::AdjustTankingPosition(Unit const* mytarget) const
+{
+    //problem: chasing unit is constantly moving. Whoever the hell did that
+//    if (/*!IsTank() || */!me->IsInCombat() || me->isMoving() || IsCasting() ||
+//        JumpingOrFalling() || CCed(me, true) || Rand() > 10 + 20*me->GetMap()->IsDungeon())
+//        return;
+    if (/*!IsTank() || */!me->IsInCombat() || IsCasting() || me->GetVehicle() ||
+        JumpingOrFalling() || CCed(me, true) || Rand() > 10 + 20*me->GetMap()->IsDungeon() ||
+        HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return false;
+
+    Unit::AttackerSet const& myattackers = me->getAttackers();
+    if (myattackers.size() < 2)
+        return false;
+
+    if (IsMelee())
+    {
+        if (!me->IsWithinMeleeRange(mytarget))
+            return false;
+    }
+    else
+    {
+        uint8 rangeMode = IAmFree() ? uint8(BOT_ATTACK_RANGE_LONG) : master->GetBotMgr()->GetBotAttackRangeMode();
+        uint8 exactRange = rangeMode != BOT_ATTACK_RANGE_EXACT || IAmFree() ? 255 : master->GetBotMgr()->GetBotExactAttackRange();
+        float dist = (rangeMode == BOT_ATTACK_RANGE_EXACT) ? exactRange : GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG);
+
+        if (me->GetDistance(mytarget) > dist)
+            return false;
+    }
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankPosition() by %s", me->GetName().c_str());
+
+    uint32 bCount = 0;
+    for (Unit::AttackerSet::const_iterator itr = myattackers.begin(); itr != myattackers.end(); ++itr)
+    {
+        if (/*!CCed(*itr) && */(*itr)->IsWithinMeleeRange(me) && !me->HasInArc(float(M_PI), *itr))
+            ++bCount;
+            //if (++bCount)
+            //    break;
+    }
+
+    if (bCount == 0)
+        return false;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankPosition(): atts %u, behind %u", uint32(myattackers.size()), bCount);
+
+    //calculate new position
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float ori = CCed(mytarget, true) ? me->GetOrientation() + 0.75f * M_PI : me->GetOrientation();
+    float const moveDist = -1.f * std::max<float>(mytarget->GetCombatReach(), 3.f);
+    float moveX;
+    float moveY;
+    //bool move = false;
+    for (uint32 i = 0; i != 6; ++i)
+    {
+        if (i)
+        {
+            ori = Position::NormalizeOrientation(ori + (i+1)*(M_PI*0.31f));
+        }
+
+        //move back
+        moveX = moveDist * std::cos(ori);
+        moveY = moveDist * std::sin(ori);
+
+        Position ppos;
+        ppos.Relocate(x+moveX, y+moveY, z);
+        if (me->IsWithinLOS(x+moveX, y+moveY, z) && !IsWithinAoERadius(ppos))
+            break;
+
+        if (i == 2)
+        {
+            moveX *= 0.2f;
+            moveY *= 0.2f;
+        }
+    }
+
+    x+= moveX;
+    y+= moveY;
+
+    me->UpdateAllowedPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.75f; //prevent going underground
+
+    //if (CCed(mytarget, true))
+    //    me->AttackStop();
+    //me->SetOrientation(ori);
+    Position position;
+    position.Relocate(x, y, z);
+    BotMovement(BOT_MOVE_POINT, &position);
+    //me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z, false);
+    return true;
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS) && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !me->HasAuraType(SPELL_AURA_MOD_INVISIBILITY) &&
+            !IsShootingWand())
+            DoMeleeAttackIfReady();
+    }
+}
+//Move behind current target if needed (avoid cleaves and dodges/parries, also rogues/ferals)
+void bot_ai::MoveBehind(Unit const* target) const
+{
+    if (HasBotCommandState(BOT_COMMAND_MASK_UNMOVING) || HasRole(BOT_ROLE_RANGED) || JumpingOrFalling() ||
+        /*(me->isMoving() && target->GetTypeId() != TYPEID_PLAYER) ||*/
+        me->GetVehicle() || (IsTank() && target->GetVictim() == me) || CCed(me, true) ||
+        !target->IsWithinCombatRange(me, ATTACK_DISTANCE) || !target->HasInArc(float(M_PI), me))
+        return;
+
+    bool targetMe = target->GetVictim() == me;
+    bool cced = CCed(target);
+    bool isPlayer = target->GetTypeId() == TYPEID_PLAYER;
+
+    if ((_botclass == BOT_CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM) ? (!targetMe || cced || isPlayer) : (!targetMe && (!cced || isPlayer)))
+    {
+        float myangle = Position::NormalizeOrientation(target->GetAbsoluteAngle(me) + float(M_PI));
+        float mydist = me->GetCombatReach();
+        Position position;
+        target->GetNearPoint(me, position.m_positionX, position.m_positionY, position.m_positionZ, mydist, myangle);
+
+        if (IsWithinAoERadius(position))
+            return;
+
+        BotMovement(BOT_MOVE_POINT, &position);
+        //me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+        const_cast<bot_ai*>(this)->waitTimer = 500;
+    }
+}
+//MOUNT SUPPORT
+void bot_ai::_updateMountedState()
+{
+    if (IAmFree())
+        return;
+    //if (GetBotCommandState() != COMMAND_FOLLOW)
+    //    return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted() && (_botclass != BOT_CLASS_ARCHMAGE || aura);
+    bool template_fly = me->GetCreatureTemplate()->Movement.Flight == CreatureFlightMovementType::CanFly;
+
+    //allow dismount
+    if (!CanMount() && !aura && !mounted)
+        return;
+
+    if ((!master->IsMounted() || aura != mounted || (!mounted && template_fly) || (me->IsInCombat() && (opponent || disttarget))) && (aura || mounted || template_fly))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->Movement.Flight = CreatureFlightMovementType::None;
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        me->Dismount();
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING|MOVEMENTFLAG_FALLING_FAR|MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW);
+        me->BotStopMovement();
+        return;
+    }
+    if (me->IsInCombat() || me->GetVehicle() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) || IsCasting())
+        return;
+
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        Unit::AuraEffectList const& mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        Aura const* mountAura = nullptr;
+        int32 maxMountSpeed = 0;
+        for (AuraEffect const* meff : mounts)
+        {
+            for (uint8 i = EFFECT_0; i < MAX_SPELL_EFFECTS; ++i)
+            {
+                AuraEffect const* maeff = meff->GetBase()->GetEffect(i);
+                if (maeff && (maeff->GetSpellEffectInfo().IsAura(master->CanFly() ? SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED : SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)) &&
+                    maeff->GetAmount() > maxMountSpeed)
+                {
+                    maxMountSpeed = maeff->GetAmount();
+                    mountAura = meff->GetBase();
+                }
+            }
+        }
+
+        uint32 const mountSpellId = mountAura ? mountAura->GetId() : 0;
+        uint32 myMountSpellId = 0;
+        if (maxMountSpeed > 20)
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                myMountSpellId = master->CanFly() ? REINDEER_FLY : REINDEER;
+            if (!myMountSpellId && me->GetMapId() == 531) //Ahn'Qiraj
+            {
+                //Select AQ40 mount
+                static const std::array<uint32, 4> QirajiMountSpellIds = { QIRAJI_BATTLE_TANK_1, QIRAJI_BATTLE_TANK_2, QIRAJI_BATTLE_TANK_3, QIRAJI_BATTLE_TANK_4 };
+                //Count Black Qiraji Battle Tank too
+                if (mountSpellId == 26656 || std::find(QirajiMountSpellIds.cbegin(), QirajiMountSpellIds.cend(), mountSpellId) != QirajiMountSpellIds.end())
+                    myMountSpellId = QirajiMountSpellIds[me->GetEntry() % QirajiMountSpellIds.size()];
+            }
+            if (!myMountSpellId)
+            {
+                using MountArray = std::array<uint32, NUM_MOUNTS_PER_SPEED>;
+
+                bool useSlowMount = master->CanFly() ?  (me->GetLevel() < 70 || maxMountSpeed < 220) : (me->GetLevel() < 40 || maxMountSpeed < 80);
+
+                if (!master->CanFly())
+                {
+                    //Select by class
+                    switch (_botclass)
+                    {
+                        case BOT_CLASS_DARK_RANGER:
+                            myMountSpellId = BOT_DARK_RANGER_MOUNT;
+                            break;
+                        case BOT_CLASS_WARLOCK:
+                            myMountSpellId = useSlowMount ? BOT_WARLOCK_MOUNT : BOT_WARLOCK_FAST_MOUNT;
+                            break;
+                        case BOT_CLASS_PALADIN:
+                            if (me->GetRace() == RACE_BLOODELF)
+                                myMountSpellId = useSlowMount ? BOT_BE_PALLY_MOUNT : BOT_BE_PALLY_FAST_MOUNT;
+                            else
+                                myMountSpellId = useSlowMount ? BOT_ALLI_PALLY_MOUNT : BOT_ALLI_PALLY_FAST_MOUNT;
+                            break;
+                        case BOT_CLASS_DEATH_KNIGHT:
+                            myMountSpellId = BOT_DEATH_KNIGHT_MOUNT;
+                            break;
+                        default:
+                            break;
+                    }
+                    //Select by race
+                    if (!myMountSpellId)
+                    {
+                        static const MountArray MOUNTS_60_HUMAN = { BOT_MOUNT_HUMAN_60_1, BOT_MOUNT_HUMAN_60_2, BOT_MOUNT_HUMAN_60_3 };
+                        static const MountArray MOUNTS_60_ORC = { BOT_MOUNT_ORC_60_1, BOT_MOUNT_ORC_60_2, BOT_MOUNT_ORC_60_3 };
+                        static const MountArray MOUNTS_60_DWARF = { BOT_MOUNT_DWARF_60_1, BOT_MOUNT_DWARF_60_2, BOT_MOUNT_DWARF_60_3 };
+                        static const MountArray MOUNTS_60_NIGHTELF = { BOT_MOUNT_NIGHTELF_60_1, BOT_MOUNT_NIGHTELF_60_2, BOT_MOUNT_NIGHTELF_60_3 };
+                        static const MountArray MOUNTS_60_FORSAKEN = { BOT_MOUNT_FORSAKEN_60_1, BOT_MOUNT_FORSAKEN_60_2, BOT_MOUNT_FORSAKEN_60_3 };
+                        static const MountArray MOUNTS_60_TAUREN = { BOT_MOUNT_TAUREN_60_1, BOT_MOUNT_TAUREN_60_2, BOT_MOUNT_TAUREN_60_3 };
+                        static const MountArray MOUNTS_60_GNOME = { BOT_MOUNT_GNOME_60_1, BOT_MOUNT_GNOME_60_2, BOT_MOUNT_GNOME_60_3 };
+                        static const MountArray MOUNTS_60_TROLL = { BOT_MOUNT_TROLL_60_1, BOT_MOUNT_TROLL_60_2, BOT_MOUNT_TROLL_60_3 };
+                        static const MountArray MOUNTS_60_BLOODELF = { BOT_MOUNT_BLOODELF_60_1, BOT_MOUNT_BLOODELF_60_2, BOT_MOUNT_BLOODELF_60_3 };
+                        static const MountArray MOUNTS_60_DRAENEI = { BOT_MOUNT_DRAENEI_60_1, BOT_MOUNT_DRAENEI_60_2, BOT_MOUNT_DRAENEI_60_3 };
+
+                        static const MountArray MOUNTS_100_HUMAN = { BOT_MOUNT_HUMAN_100_1, BOT_MOUNT_HUMAN_100_2, BOT_MOUNT_HUMAN_100_3 };
+                        static const MountArray MOUNTS_100_ORC = { BOT_MOUNT_ORC_100_1, BOT_MOUNT_ORC_100_2, BOT_MOUNT_ORC_100_3 };
+                        static const MountArray MOUNTS_100_DWARF = { BOT_MOUNT_DWARF_100_1, BOT_MOUNT_DWARF_100_2, BOT_MOUNT_DWARF_100_3 };
+                        static const MountArray MOUNTS_100_NIGHTELF = { BOT_MOUNT_NIGHTELF_100_1, BOT_MOUNT_NIGHTELF_100_2, BOT_MOUNT_NIGHTELF_100_3 };
+                        static const MountArray MOUNTS_100_FORSAKEN = { BOT_MOUNT_FORSAKEN_100_1, BOT_MOUNT_FORSAKEN_100_2, BOT_MOUNT_FORSAKEN_100_3 };
+                        static const MountArray MOUNTS_100_TAUREN = { BOT_MOUNT_TAUREN_100_1, BOT_MOUNT_TAUREN_100_2, BOT_MOUNT_TAUREN_100_3 };
+                        static const MountArray MOUNTS_100_GNOME = { BOT_MOUNT_GNOME_100_1, BOT_MOUNT_GNOME_100_2, BOT_MOUNT_GNOME_100_3 };
+                        static const MountArray MOUNTS_100_TROLL = { BOT_MOUNT_TROLL_100_1, BOT_MOUNT_TROLL_100_2, BOT_MOUNT_TROLL_100_3 };
+                        static const MountArray MOUNTS_100_BLOODELF = { BOT_MOUNT_BLOODELF_100_1, BOT_MOUNT_BLOODELF_100_2, BOT_MOUNT_BLOODELF_100_3 };
+                        static const MountArray MOUNTS_100_DRAENEI = { BOT_MOUNT_DRAENEI_100_1, BOT_MOUNT_DRAENEI_100_2, BOT_MOUNT_DRAENEI_100_3 };
+
+                        Optional<MountArray> myMounts;
+                        switch (me->GetRace())
+                        {
+                            case RACE_HUMAN:         myMounts = useSlowMount ? MOUNTS_60_HUMAN : MOUNTS_100_HUMAN;       break;
+                            case RACE_ORC:           myMounts = useSlowMount ? MOUNTS_60_ORC : MOUNTS_100_ORC;           break;
+                            case RACE_DWARF:         myMounts = useSlowMount ? MOUNTS_60_DWARF : MOUNTS_100_DWARF;       break;
+                            case RACE_NIGHTELF:      myMounts = useSlowMount ? MOUNTS_60_NIGHTELF : MOUNTS_100_NIGHTELF; break;
+                            case RACE_UNDEAD_PLAYER: myMounts = useSlowMount ? MOUNTS_60_FORSAKEN : MOUNTS_100_FORSAKEN; break;
+                            case RACE_TAUREN:        myMounts = useSlowMount ? MOUNTS_60_TAUREN : MOUNTS_100_TAUREN;     break;
+                            case RACE_GNOME:         myMounts = useSlowMount ? MOUNTS_60_GNOME : MOUNTS_100_GNOME;       break;
+                            case RACE_TROLL:         myMounts = useSlowMount ? MOUNTS_60_TROLL : MOUNTS_100_TROLL;       break;
+                            case RACE_BLOODELF:      myMounts = useSlowMount ? MOUNTS_60_BLOODELF : MOUNTS_100_BLOODELF; break;
+                            case RACE_DRAENEI:       myMounts = useSlowMount ? MOUNTS_60_DRAENEI : MOUNTS_100_DRAENEI;   break;
+                            default:                                                                                     break;
+                        }
+
+                        if (myMounts)
+                            myMountSpellId = (*myMounts)[me->GetEntry() % myMounts->size()];
+                    }
+                }
+                else //if (master->CanFly())
+                {
+                    static const MountArray MOUNTS_150_ALLIANCE = { BOT_MOUNT_FLY_ALLIANCE_150_1, BOT_MOUNT_FLY_ALLIANCE_150_2, BOT_MOUNT_FLY_ALLIANCE_150_3 };
+                    static const MountArray MOUNTS_150_HORDE = { BOT_MOUNT_FLY_HORDE_150_1, BOT_MOUNT_FLY_HORDE_150_2, BOT_MOUNT_FLY_HORDE_150_3 };
+                    static const MountArray MOUNTS_280_ALLIANCE = { BOT_MOUNT_FLY_ALLIANCE_280_1, BOT_MOUNT_FLY_ALLIANCE_280_2, BOT_MOUNT_FLY_ALLIANCE_280_3 };
+                    static const MountArray MOUNTS_280_HORDE = { BOT_MOUNT_FLY_HORDE_280_1, BOT_MOUNT_FLY_HORDE_280_2, BOT_MOUNT_FLY_HORDE_280_3 };
+
+                    Optional<MountArray> myMounts;
+                    if (me->GetRaceMask() & RACEMASK_ALLIANCE)
+                        myMounts = useSlowMount ? MOUNTS_150_ALLIANCE : MOUNTS_280_ALLIANCE;
+                    else if (me->GetRaceMask() & RACEMASK_HORDE)
+                        myMounts = useSlowMount ? MOUNTS_150_HORDE : MOUNTS_280_HORDE;
+
+                    if (myMounts)
+                        myMountSpellId = (*myMounts)[me->GetEntry() % myMounts->size()];
+                }
+            }
+        }
+
+        if (!myMountSpellId) // shouldn't happen normally
+        {
+            if (mountSpellId)
+                myMountSpellId = mountSpellId;
+            else if (!mounts.empty())
+                myMountSpellId = mounts.front()->GetId();
+        }
+
+        if (myMountSpellId)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+
+            //me->RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_NOT_MOUNTED);
+
+            //if (!GetSpell(mount))
+            //    InitSpellMap(mount, true); //learn
+
+            me->BotStopMovement();
+            if (_botclass == BOT_CLASS_DRUID && me->GetShapeshiftForm() != FORM_NONE)
+                removeShapeshiftForm();
+            if (doCast(me, myMountSpellId))
+            { }
+
+            //RemoveSpell(mount);
+        }
+    }
+}
+//STANDSTATE
+void bot_ai::_updateStandState() const
+{
+    if (IAmFree())
+    {
+        if (CanSit())
+        {
+            if (_atHome && !_evadeMode && !me->IsInCombat() && !me->isMoving() &&
+                me->IsStandState() && Rand() < 15)
+            {
+                uint16 mapid;
+                Position pos;
+                GetHomePosition(mapid, &pos);
+                if (me->GetExactDist(&pos) < 5 && me->GetOrientation() == pos.GetOrientation())
+                {
+                    if (_botclass == BOT_CLASS_DRUID && me->GetShapeshiftForm() != FORM_NONE)
+                        const_cast<bot_ai*>(this)->removeShapeshiftForm();
+
+                    me->SetStandState(UNIT_STAND_STATE_SIT);
+                }
+            }
+        }
+        else if (me->IsSitState() && !me->HasInterruptFlag(AURA_INTERRUPT_FLAG_NOT_SEATED))
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+
+        return;
+    }
+
+    if (me->GetVehicle())
+        return;
+
+    if ((master->GetStandState() == UNIT_STAND_STATE_STAND || !CanSit()) &&
+        me->GetStandState() == UNIT_STAND_STATE_SIT &&
+        !me->HasInterruptFlag(AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if (CanSit() && !me->IsInCombat() && !me->isMoving() &&
+        (master->GetStandState() == UNIT_STAND_STATE_SIT || me->HasInterruptFlag(AURA_INTERRUPT_FLAG_NOT_SEATED)) &&
+        me->GetStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+}
+//RATIONS
+void bot_ai::_updateRations()
+{
+    bool noFeast = me->IsInCombat() || (BotMgr::IsFoodInterruptedByMovement() && me->isMoving()) || me->GetVictim() || CCed(me);
+
+    //check
+    if (IAmFree() || !master->IsSitState())
+    {
+        if (feast_mana)
+        {
+            if (noFeast || me->IsStandState() || me->GetMaxPower(POWER_MANA) <= 1 || me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA))
+            {
+                std::list<uint32> spellIds;
+                Unit::AuraApplicationMap const& aurApps = me->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::const_iterator ci = aurApps.begin(); ci != aurApps.end(); ++ci)
+                    if (ci->second->GetBase()->GetSpellInfo()->GetSpellSpecific() == SPELL_SPECIFIC_DRINK &&
+                        !ci->second->GetBase()->GetSpellInfo()->HasAura(SPELL_AURA_PERIODIC_TRIGGER_SPELL)) //skip buffing food
+                        spellIds.push_back(ci->first);
+                for (std::list<uint32>::const_iterator cit = spellIds.begin(); cit != spellIds.end(); ++cit)
+                    me->RemoveAurasDueToSpell(*cit);
+                feast_mana = false;
+                UpdateMana();
+            }
+        }
+        if (feast_health)
+        {
+            if (noFeast || me->IsStandState() || me->GetHealth() >= me->GetMaxHealth())
+            {
+                std::list<uint32> spellIds;
+                Unit::AuraApplicationMap const& aurApps = me->GetAppliedAuras();
+                for (Unit::AuraApplicationMap::const_iterator ci = aurApps.begin(); ci != aurApps.end(); ++ci)
+                    if (ci->second->GetBase()->GetSpellInfo()->GetSpellSpecific() == SPELL_SPECIFIC_FOOD &&
+                        !ci->second->GetBase()->GetSpellInfo()->HasAura(SPELL_AURA_PERIODIC_TRIGGER_SPELL)) //skip buffing food
+                        spellIds.push_back(ci->first);
+                for (std::list<uint32>::const_iterator cit = spellIds.begin(); cit != spellIds.end(); ++cit)
+                    me->RemoveAurasDueToSpell(*cit);
+                feast_health = false;
+            }
+        }
+    }
+
+    if (noFeast)
+        return;
+
+    //drink
+    if (!feast_mana && me->GetMaxPower(POWER_MANA) > 1 && !me->HasAuraType(SPELL_AURA_MOUNTED) && !me->isMoving() && CanDrink() &&
+        !me->IsInCombat() && !me->GetVehicle() && !IsCasting() && GetManaPCT(me) < 75 && urand(0, 100) < 20)
+    {
+        //me->SetStandState(UNIT_STAND_STATE_SIT);
+        CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+        me->CastSpell(me, GetRation(true), args);
+    }
+
+    //eat
+    if (!feast_health && !me->HasAuraType(SPELL_AURA_MOUNTED) && !me->isMoving() && CanEat() &&
+        !me->IsInCombat() && !me->GetVehicle() && !IsCasting() && GetHealthPCT(me) < 80 && urand(0, 100) < 20)
+    {
+        //me->SetStandState(UNIT_STAND_STATE_SIT);
+        CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+        me->CastSpell(me, GetRation(false), args);
+    }
+}
+//Health and Powers regeneration
+//Rage regen is handled inside class AI UpdateAI()
+void bot_ai::Regenerate()
+{
+    regenTimer += lastdiff;
+
+    //every tick
+    if (me->GetPowerType() == POWER_ENERGY)
+        RegenerateEnergy();
+
+    if (regenTimer >= REGEN_CD)
+    {
+        regenTimer -= REGEN_CD;
+        // Regen Health
+        int32 baseRegen = int32(_getTotalBotStat(BOT_STAT_MOD_HEALTH_REGEN));
+        if ((!me->IsInCombat() || me->IsPolymorphed() || CanRegenInCombat() || baseRegen > 0 ||
+            me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT) || me->HasAuraType(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT)) &&
+            me->GetHealth() < me->GetMaxHealth())
+        {
+            int32 add = me->IsInCombat() ? 0 : IAmFree() && !me->GetVictim() ? me->GetMaxHealth() / 32 : 5 + me->GetCreateHealth() / 256;
+            if (baseRegen > 0)
+                add += std::max<int32>(baseRegen / 5, 1);
+
+            //cannot eat
+            if (_botclass == BOT_CLASS_SPHYNX)
+                add += me->GetMaxHealth() / 100; //1%
+
+            if (me->IsPolymorphed())
+                add += me->GetMaxHealth() / 6;
+            else if (!me->IsInCombat() || me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+            {
+                if (!me->IsInCombat())
+                {
+                    Unit::AuraEffectList const& mModHealthRegenPct = me->GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
+                    for (Unit::AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
+                        AddPct(add, (*i)->GetAmount());
+
+                    add += me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * REGEN_CD / 5000;
+                }
+                else if (me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+                    ApplyPct(add, me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));
+            }
+
+            add += me->GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
+
+            if (add < 0)
+                add = 0;
+
+            me->ModifyHealth(add);
+        }
+
+        // Regen Mana
+        if (me->GetMaxPower(POWER_MANA) > 1 &&
+            (me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) || _botclass == BOT_CLASS_SPHYNX))
+        {
+            float addvalue;
+            if (me->IsUnderLastManaUseEffect())
+                addvalue = me->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER);
+            else
+                addvalue = me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+
+            addvalue *= sWorld->getRate(RATE_POWER_MANA) * REGEN_CD * 0.001f; //regenTimer threshold / 1000
+
+            if (addvalue < 0.0f)
+                addvalue = 0.0f;
+
+            if (_botclass == BOT_CLASS_SPHYNX)
+                addvalue *= -1.f;
+
+            me->ModifyPower(POWER_MANA, int32(addvalue));
+        }
+    }
+}
+
+void bot_ai::RegenerateEnergy()
+{
+    uint32 curValue = me->GetPower(POWER_ENERGY);
+    uint32 maxValue = me->GetMaxPower(POWER_ENERGY);
+
+    if (curValue < maxValue)
+    {
+        float addvalue = 0.01f * lastdiff * sWorld->getRate(RATE_POWER_ENERGY); //10 per sec
+        Unit::AuraEffectList const& ModPowerRegenPCTAuras = me->GetAuraEffectsByType(SPELL_AURA_MOD_POWER_REGEN_PERCENT);
+        for (Unit::AuraEffectList::const_iterator i = ModPowerRegenPCTAuras.begin(); i != ModPowerRegenPCTAuras.end(); ++i)
+            if (Powers((*i)->GetMiscValue()) == POWER_ENERGY)
+                AddPct(addvalue, (*i)->GetAmount());
+
+        //not present in db
+        //addvalue += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_ENERGY) * lastdiff / 5000;
+        //me->ModifyPower(POWER_ENERGY, int32(addvalue));
+
+        addvalue += _energyFraction;
+
+        if (addvalue == 0x0) //only if world rate for enegy is 0
+            return;
+
+        uint32 integerValue = uint32(fabs(addvalue));
+
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            _energyFraction = 0.f;
+        }
+        else
+            _energyFraction = addvalue - float(integerValue);
+
+        if (curValue == maxValue || regenTimer >= REGEN_CD)
+            me->SetPower(POWER_ENERGY, curValue);
+        else
+            me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_ENERGY, curValue);
+    }
+}
+
+bool bot_ai::Feasting() const
+{
+    if (!me->HasInterruptFlag(AURA_INTERRUPT_FLAG_NOT_SEATED))
+        return false;
+
+    return
+        me->IsSitState() &&
+        (me->HasAuraType(SPELL_AURA_MOD_REGEN)       || me->HasAuraType(SPELL_AURA_OBS_MOD_HEALTH) ||
+         me->HasAuraType(SPELL_AURA_MOD_POWER_REGEN) || me->HasAuraType(SPELL_AURA_OBS_MOD_POWER));
+}
+uint32 bot_ai::GetRation(bool drink) const
+{
+    for (int8 i = MAX_FEAST_SPELLS - 1; i >= 0; --i)
+        if (me->GetLevel() >= (drink ? DrinkSpells[i][0] : EatSpells[i][0]))
+            return (drink ? DrinkSpells[i][1] : EatSpells[i][1]);
+
+    return (drink ? DrinkSpells[0][1] : EatSpells[0][1]);
+}
+
+void bot_ai::DrinkPotion(bool mana)
+{
+    if (IsCasting())
+        return;
+
+    me->CastSpell(me, GetPotion(mana));
+}
+bool bot_ai::IsPotionReady() const
+{
+    return _potionTimer <= lastdiff;
+}
+uint32 bot_ai::GetPotion(bool mana) const
+{
+    for (int8 i = MAX_POTION_SPELLS - 1; i >= 0; --i)
+        if (me->GetLevel() >= (mana ? ManaPotionSpells[i][0] : HealingPotionSpells[i][0]))
+            return (mana ? ManaPotionSpells[i][1] : HealingPotionSpells[i][1]);
+
+    return (mana ? ManaPotionSpells[0][1] : HealingPotionSpells[0][1]);
+}
+bool bot_ai::IsPotionSpell(uint32 spellId) const
+{
+    return spellId == GetPotion(true) || spellId == GetPotion(false);
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+//Deprecated after 4c26c85
+//bool bot_ai::InDuel(Unit const* target) const
+//{
+//    if (!target) return false;
+//    bool isbot = target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot();
+//    Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner()->ToPlayer() : nullptr;
+//    if (!player)
+//    {
+//        if (!target->IsControlledByPlayer())
+//            return false;
+//        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+//    }
+//
+//    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+//}
+////////////////
+//GRID SEARCHERS
+////////////////
+//Finds player or it's corpse for resurrection returned as WorldObject*
+WorldObject* bot_ai::GetNearbyRezTarget(float dist) const
+{
+    std::list<WorldObject*> list;
+
+    NearbyRezTargetCheck check(me, dist, this);
+    Trinity::WorldObjectListSearcher <NearbyRezTargetCheck> searcher(me, list, check);
+    Cell::VisitWorldObjects(me, searcher, dist);
+
+    if (list.empty())
+        return nullptr;
+    if (list.size() == 1)
+        return *list.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(list);
+}
+//Finds target for warrior's Shattering Throw
+Unit* bot_ai::FindImmunityShieldDispelTarget(float dist) const
+{
+    //not checking range
+    if (me->GetVictim() && me->GetVictim()->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+        return me->GetVictim();
+
+    Unit* unit = nullptr;
+
+    ImmunityShieldDispelTargetCheck check(me, dist, this);
+    Trinity::UnitSearcher <ImmunityShieldDispelTargetCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+//Used to find target for priest's dispels, mage's spellsteal and shaman's purge
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    std::list<Unit*> unitList;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitListSearcher <HostileDispelTargetCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+// DEPRECATED our party players (hostile = 1)
+// DEPRECATED our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any friendly player (hostile = 4)
+//    any target in range  (hostile = any other value)
+Unit* bot_ai::FindAffectedTarget(uint32 spellId, ObjectGuid caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return nullptr;
+    if ((hostile == 2 || hostile == 1)/* && IAmFree()*/)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::FindAffectedTarget(): hostile = %u Setting to ALL...", hostile);
+        hostile = 255;
+    }
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    Unit* unit = nullptr;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitSearcher <AffectedTargetCheck> searcher(master, unit, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_ai::FindPolyTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    PolyUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <PolyUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for direct fear (warlock, hunter)
+Unit* bot_ai::FindFearTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <FearUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for CC spells with MECHANIC_STUN
+Unit* bot_ai::FindStunTarget(float dist) const
+{
+    std::list<Unit*> unitList;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitListSearcher <StunUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for priest's shackles
+Unit* bot_ai::FindUndeadCCTarget(float dist, uint32 spellId, bool unattacked) const
+{
+    if (!spellId)
+        return nullptr;
+
+    std::list<Unit*> unitList;
+
+    UndeadCCUnitCheck check(me, dist, this, spellId, unattacked);
+    Trinity::UnitListSearcher <UndeadCCUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    if (!spellId)
+        return nullptr;
+
+    std::list<Unit*> unitList;
+
+    RootUnitCheck check(me, dist, this, spellId);
+    Trinity::UnitListSearcher <RootUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds casting target (neutral or enemy)
+//Can be used to get silence/interruption/reflect/grounding check
+Unit* bot_ai::FindCastingTarget(float maxdist, float mindist, uint32 spellId, uint8 minHpPct) const
+{
+    std::list<Unit*> unitList;
+
+    CastingUnitCheck check(me, mindist, maxdist, spellId, minHpPct);
+    Trinity::UnitListSearcher <CastingUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+// Returns target for dest AOE spell (blizzard, hurricane, etc.) based on crowd size, movement state and direction
+Unit* bot_ai::FindAOETarget(float dist, WorldObject const* src) const
+{
+    if (!src)
+        src = me;
+
+    std::list<Unit*> unitList;
+    GetNearbyTargetsList(unitList, dist, 0);
+
+    if (unitList.size() < 3)
+        return nullptr;
+
+    Unit* unit = nullptr;
+    float mydist = dist;
+    for (std::list<Unit*>::const_iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+    {
+        if ((*itr)->isMoving() && (*itr)->GetVictim() &&
+            ((*itr)->GetDistance2d((*itr)->GetVictim()->GetPositionX(), (*itr)->GetVictim()->GetPositionY()) > 7.5f ||
+            !(*itr)->HasInArc(float(M_PI)*0.75f, (*itr)->GetVictim())))
+            continue;
+
+        if (!unit && (*itr)->GetVictim() && (*itr)->GetDistance((*itr)->GetVictim()) < dist * 0.334f)
+        {
+            unit = *itr;
+            continue;
+        }
+        if (!unit)
+        {
+            float destDist = src->GetDistance((*itr)->GetPositionX(), (*itr)->GetPositionY(), (*itr)->GetPositionZ());
+            if (destDist < mydist)
+            {
+                mydist = destDist;
+                unit = *itr;
+            }
+        }
+        if (unit)
+        {
+            uint8 count = 0;
+            for (std::list<Unit*>::const_iterator it = unitList.begin(); it != unitList.end(); ++it)
+            {
+                if (*it != unit && (*it)->GetDistance2d(unit->GetPositionX(), unit->GetPositionY()) < 5.f)
+                {
+                    if (++count > 2)
+                    {
+                        if (src->GetDistance(*it) < src->GetDistance(unit) && unit->HasInArc(float(M_PI)/2, src))
+                            unit = *it;
+                        break;
+                    }
+                }
+            }
+            if (count > 2)
+                break;
+
+            unit = nullptr;
+        }
+    }
+
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, etc.
+Unit* bot_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return nullptr;
+
+    if (me->GetDistance(To) > dist)
+        return nullptr;
+
+    Unit* unit = nullptr;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitSearcher <SecondEnemyCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    return unit;
+}
+// Finds secondary target for AoE spells like Mind Sear (not damaging primary target)
+Unit* bot_ai::FindSplashTarget(float dist, Unit* To, float splashdist, uint8 minTargets) const
+{
+    if (!To || minTargets < 1)
+        return nullptr;
+
+    if (me->GetDistance(To) > dist)
+        return nullptr;
+
+    std::list<Unit*> unitList;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitListSearcher <SecondEnemyCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, dist);
+    //me->VisitNearbyObject(dist, searcher);
+
+    if (uint8(unitList.size()) < minTargets)
+        return nullptr;
+    if (unitList.size() == 1)
+        return *unitList.begin();
+
+    return Trinity::Containers::SelectRandomContainerElement(unitList);
+}
+//Finds target for hunter's Tranquilizing Shot (has dispellable magic or enrage effect)
+Unit* bot_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    Unit* unit = nullptr;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitSearcher <TranquilTargetCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    return unit;
+}
+//Find target to cast taunt on
+//In case of paladin's Righetoous Defense returns IsInBotParty() unit
+Unit* bot_ai::FindDistantTauntTarget(float maxdist, bool ally) const
+{
+    std::list<Unit*> unitList;
+
+    FarTauntUnitCheck check(me, maxdist, ally, this);
+    Trinity::UnitListSearcher <FarTauntUnitCheck> searcher(me, unitList, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    if (unitList.empty())
+        return nullptr;
+
+    Unit* unit = unitList.size() == 1 ? *unitList.begin() : Trinity::Containers::SelectRandomContainerElement(unitList);
+    return ally ? unit->GetVictim() : unit;
+}
+//Finds target for Warlock's Mana Drain
+//Returns nearby CCed unit with most mana
+Unit* bot_ai::FindDrainTarget(float maxdist) const
+{
+    Unit* unit = nullptr;
+
+    ManaDrainUnitCheck check(me, maxdist, this);
+    Trinity::UnitLastSearcher <ManaDrainUnitCheck> searcher(me, unit, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+
+    return unit;
+}
+//Finds all targets within given range
+//used for finding targets for spells which need reasonable amount of targets (ex. Death Knight AOE spells)
+//CCoption:= mask
+//1 - not CCed
+//2 - has no periodic damage auras (can be safely CCed)
+void bot_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, uint8 CCoption, WorldObject const* source) const
+{
+    if (!source)
+        source = me;
+
+    NearbyHostileUnitCheck check(me, maxdist, this, CCoption, source);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+}
+//Find all targets within given range in cone in front of caster; angle is PI/2 (TC confirmed)
+//used by mage Dragon's Breath and Cone of Cold spells
+//also Swipe (Bear) and Swipe (Cat)
+void bot_ai::GetNearbyTargetsInConeList(std::list<Unit*> &targets, float maxdist) const
+{
+    NearbyHostileUnitInConeCheck check(me, maxdist, this);
+    Trinity::UnitListSearcher <NearbyHostileUnitInConeCheck> searcher(me, targets, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+}
+//Finds all friendly targets within given range
+//used for finding targets to heal/buff for uncontrolled bots
+void bot_ai::GetNearbyFriendlyTargetsList(std::list<Unit*> &targets, float maxdist) const
+{
+    NearbyFriendlyUnitCheck check(me, maxdist, this);
+    Trinity::UnitListSearcher <NearbyFriendlyUnitCheck> searcher(me, targets, check);
+    Cell::VisitAllObjects(me, searcher, maxdist);
+    //me->VisitNearbyObject(maxdist, searcher);
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spellId of max rank allowed for given caster
+//If you want bot to use this spell through doCast() go InitSpellMap(uint32) instead
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->GetLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, puts spell of max rank allowed for given caster in spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->GetLevel();
+    uint32 spellId = forceadd ? basespell : 0;
+
+    while (info != nullptr && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotSpell* newSpell = _spells[basespell];
+    if (!newSpell)
+    {
+        newSpell = new BotSpell();
+        _spells[basespell] = newSpell;
+    }
+
+    newSpell->spellId = spellId;
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    if (npcBotData->disabled_spells.find(basespell) != npcBotData->disabled_spells.end())
+    {
+        newSpell->enabled = false;
+        //TC_LOG_ERROR("entities.player", "bot_ai::InitSpellMap(): %s (%u -> %u) is disabled for %s!",
+        //    sSpellMgr->GetSpellInfo(basespell)->SpellName[0], basespell, spellId, me->GetName().c_str());
+    }
+}
+//Using first-rank spell as source, return true if spell is inited
+bool bot_ai::HasSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() && (itr->second->spellId != 0);
+}
+//Using spell name as source, return first-rank spell if spell is inited
+uint32 bot_ai::GetBaseSpell(std::string_view spell_name, LocaleConstant locale) const
+{
+    uint32 basespell = 0;
+    std::wstring wname;
+    if (Utf8toWStr(spell_name, wname))
+    {
+        wstrToLower(wname);
+        for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+        {
+            //we ignore enabled state since this is exactly what we want
+            if (itr->second->spellId == 0) //not init'ed
+                continue;
+            spell_name = sSpellMgr->GetSpellInfo(itr->first)->SpellName[locale];
+            std::wstring wcname;
+            if (!Utf8toWStr(spell_name, wcname))
+                continue;
+            wstrToLower(wcname);
+            if (wcname == wname)
+            {
+                basespell = itr->first;
+                break;
+            }
+        }
+    }
+
+    return basespell;
+}
+//Using first-rank spell as source, return current spell id if inited and enabled
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() && (itr->second->enabled == true || IAmFree()) ? itr->second->spellId : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() ? itr->second->cooldown : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD) const
+{
+    if (checkGCD && GC_Timer > diff)
+        return false;
+
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr == _spells.end() ? true :
+        ((itr->second->enabled == true || IAmFree() || IsLastOrder(BOT_ORDER_SPELLCAST, basespell)) &&
+            itr->second->spellId != 0 && itr->second->cooldown <= diff);
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotSpellMap::const_iterator itr = _spells.find(basespell);
+    if (itr != _spells.end())
+    {
+        itr->second->cooldown = msCooldown;
+        return;
+    }
+    else if (!msCooldown)
+        return;
+
+    InitSpellMap(basespell, true, false);
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->first == spellInfo->Id && itr->second->cooldown >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (info && itr->first == spellInfo->Id && info->GetCategory() != category)
+        {
+            //if (itr->first != 7814) // Lash of Pain
+            {
+                TC_LOG_ERROR("scripts", "Warning: SetSpellCategoryCooldown: %u has baseId %u but category %u, not %u!",
+                    info->Id, itr->first, info->GetCategory(), category);
+            }
+        }
+        if (info && (info->GetCategory() == category || itr->first == spellInfo->Id) && itr->second->cooldown < msCooldown)
+            itr->second->cooldown = msCooldown;
+    }
+}
+//Handles spell cooldowns for spell with IsCooldownStartedOnEvent() == true
+void bot_ai::ReleaseSpellCooldown(uint32 basespell)
+{
+    SpellInfo const* baseInfo = sSpellMgr->GetSpellInfo(basespell);
+
+    if (!baseInfo->IsCooldownStartedOnEvent())
+    {
+        TC_LOG_ERROR("spells", "bot_ai::ReleaseSpellCooldown is called for wrong spell %u!", basespell);
+        return;
+    }
+
+    uint32 rec = baseInfo->RecoveryTime;
+    uint32 catrec = baseInfo->CategoryRecoveryTime;
+
+    ApplyBotSpellCooldownMods(baseInfo, rec);
+    ApplyBotSpellCategoryCooldownMods(baseInfo, catrec);
+
+    SetSpellCooldown(baseInfo->Id, rec > 0 ? rec : 0);
+    SetSpellCategoryCooldown(baseInfo, catrec > 0 && !(baseInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS) ? catrec : 0);
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpell* newSpell;
+    BotSpellMap::iterator itr = _spells.find(basespell);
+    if (itr == _spells.end())
+    {
+        newSpell = new BotSpell();
+        _spells[basespell] = newSpell;
+    }
+    else
+        newSpell = itr->second;
+
+    newSpell->spellId = 0;
+    newSpell->cooldown = 0;
+}
+//
+//void bot_ai::RemoveAllSpells()
+//{
+//    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+//        itr->second->spellId = 0;
+//}
+void bot_ai::EnableAllSpells()
+{
+    NpcBotData* npcBotData = const_cast<NpcBotData*>(BotDataMgr::SelectNpcBotData(me->GetEntry()));
+    npcBotData->disabled_spells.clear();
+    _saveDisabledSpells = true;
+
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+        if (itr->second->enabled == false)
+            itr->second->enabled = true;
+}
+//See CommonTimers(uint32)
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        if (itr->second->cooldown >= diff)
+            itr->second->cooldown -= diff;
+        else if (itr->second->cooldown > 0)
+            itr->second->cooldown = 0;
+    }
+}
+uint32 bot_ai::RaceSpellForClass(uint8 myrace, uint8 myclass)
+{
+    switch (myrace)
+    {
+        case RACE_ORC:
+            switch (myclass)
+            {
+                case BOT_CLASS_WARLOCK:
+                    return RACIAL_BLOOD_FURY_WARLOCK;
+                case BOT_CLASS_SHAMAN:
+                    return RACIAL_BLOOD_FURY_SHAMAN;
+                default:
+                    return RACIAL_BLOOD_FURY_OTHERS;
+            }
+            break;
+        case RACE_BLOODELF:
+            switch (myclass)
+            {
+                case BOT_CLASS_DEATH_KNIGHT:
+                    return RACIAL_ARCANE_TORRENT_DEATHKNIGHT;
+                case BOT_CLASS_ROGUE:
+                    return RACIAL_ARCANE_TORRENT_ROGUE;
+                default:
+                    return RACIAL_ARCANE_TORRENT_OTHERS;
+            }
+            break;
+        case RACE_DRAENEI:
+            switch (myclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    return RACIAL_GIFT_OF_NAARU_WARRIOR;
+                case BOT_CLASS_PALADIN:
+                    return RACIAL_GIFT_OF_NAARU_PALADIN;
+                case BOT_CLASS_HUNTER:
+                    return RACIAL_GIFT_OF_NAARU_HUNTER;
+                case BOT_CLASS_PRIEST:
+                    return RACIAL_GIFT_OF_NAARU_PRIEST;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    return RACIAL_GIFT_OF_NAARU_DEATHKNIGHT;
+                case BOT_CLASS_SHAMAN:
+                    return RACIAL_GIFT_OF_NAARU_SHAMAN;
+                case BOT_CLASS_MAGE:
+                    return RACIAL_GIFT_OF_NAARU_MAGE;
+                default:
+                    TC_LOG_ERROR("entities.player", "RaceSpellForClass(): unknows race:class combo %u, %u", uint32(myrace), uint32(myclass));
+                    return 0;
+            }
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "RaceSpellForClass(): unknows race:class combo %u, %u", uint32(myrace), uint32(myclass));
+            return 0;
+    }
+}
+//Health magement for minions
+//Including health calcs, set
+void bot_ai::_OnHealthUpdate() const
+{
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->GetLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    bool fullhp = me->GetHealth() == me->GetMaxHealth();
+    float pct = fullhp ? 100.f : me->GetHealthPct(); // needs for regeneration
+    uint32 m_basehp = uint32(_classinfo->basehealth * BotMgr::GetBotHPMod());
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+
+    float stamValue = _getTotalBotStat(BOT_STAT_MOD_STAMINA);
+
+    stamValue -= std::min<float>(me->GetCreateStat(STAT_STAMINA), 20.f); //not a mistake
+    stamValue = std::max<float>(stamValue, 0.f);
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    float hp_add = stamValue * 10.f + 20; //20 is not a mistake;
+    //hp_add += IAmFree() ? mylevel * 375.f : 0; //+30000/+0 hp at 80
+    hp_add += _getTotalBotStat(BOT_STAT_MOD_HEALTH);
+    //TC_LOG_ERROR("entities.player", "health to add after stam mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + int32(hp_add * BotMgr::GetBotHPMod()); //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+
+    //hp bonuses
+    uint8 bonuspct = 0;
+    //Endurance Training
+    if (_botclass == BOT_CLASS_HUNTER && mylevel >= 10)
+        bonuspct += 5;
+    //Fel Vitality
+    if (_botclass == BOT_CLASS_WARLOCK && mylevel >= 15)
+        bonuspct += 3;
+    //Sphynx bonus (some equip slots unavailable)
+    if (_botclass == BOT_CLASS_SPHYNX)
+        bonuspct += 50;
+    //Dreadlord's vitality
+    if (_botclass == BOT_CLASS_DREADLORD)
+        bonuspct += 20;
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+
+    //m_totalhp = float(uint32(m_totalhp) - (uint32(m_totalhp) % 10));
+    me->SetStatFlatModifier(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth(); //will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(fullhp ? me->GetMaxHealth() : uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana management for minions
+//Including calcs and set
+void bot_ai::_OnManaUpdate() const
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->GetLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    bool fullmana = me->GetPower(POWER_MANA) == me->GetMaxPower(POWER_MANA);
+    float pct = fullmana ? 100.f : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana;
+    if (_botclass == BOT_CLASS_BM)
+        m_basemana = BASE_MANA_1_BM + (BASE_MANA_10_BM - BASE_MANA_1_BM) * (mylevel/81.f);
+    if (_botclass == BOT_CLASS_SPHYNX)
+        m_basemana = BASE_MANA_SPHYNX;
+    if (_botclass == BOT_CLASS_ARCHMAGE)
+        m_basemana = BASE_MANA_1_ARCHMAGE + (BASE_MANA_10_ARCHMAGE - BASE_MANA_1_ARCHMAGE) * ((mylevel - 20)/81.f);
+    if (_botclass == BOT_CLASS_DREADLORD)
+        m_basemana = BASE_MANA_1_DREADLORD + (BASE_MANA_10_DREADLORD - BASE_MANA_1_DREADLORD) * ((mylevel - 60)/83.f);
+    if (_botclass == BOT_CLASS_SPELLBREAKER)
+        m_basemana = BASE_MANA_SPELLBREAKER;
+    if (_botclass == BOT_CLASS_DARK_RANGER)
+        m_basemana = BASE_MANA_1_DARK_RANGER + (BASE_MANA_10_DARK_RANGER - BASE_MANA_1_DARK_RANGER) * ((mylevel - 40)/82.f);
+    if (_botclass == BOT_CLASS_NECROMANCER)
+        m_basemana = BASE_MANA_NECROMANCER;
+    if (_botclass == BOT_CLASS_SEA_WITCH)
+        m_basemana = BASE_MANA_1_SEA_WITCH + (BASE_MANA_10_SEA_WITCH - BASE_MANA_1_SEA_WITCH) * (mylevel/83.f);
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+
+    me->SetCreateMana(uint32(m_basemana));
+
+    float intValue = _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+
+    intValue -= std::min<float>(me->GetCreateStat(STAT_INTELLECT), 20.f); //not a mistake
+    intValue = std::max<float>(intValue, 0.f);
+
+    float intMult = _botclass < BOT_CLASS_EX_START ? 15.f : IsHeroExClass(_botclass) ? 5.f : 1.5f;
+
+    m_basemana = intValue * intMult + 20.f; //20.f is not a mistake
+    //m_basemana += IAmFree() ? mylevel * 50.f : 0; //+4000/+0 mana at 80
+    m_basemana += _getTotalBotStat(BOT_STAT_MOD_MANA);
+
+    //mana bonuses
+    uint8 bonuspct = 0;
+    //Fel Vitality
+    if (_botclass == BOT_CLASS_WARLOCK && mylevel >= 15)
+        bonuspct += 3;
+    if (bonuspct)
+        m_basemana = (m_basemana * (100 + bonuspct)) / 100;
+
+    //m_basemana = float(uint32(m_basemana) - (uint32(m_basemana) % 5));
+    me->SetStatFlatModifier(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, fullmana ? me->GetMaxPower(POWER_MANA) :
+        uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+
+    _OnManaRegenUpdate();
+}
+//Mana regen for minions
+void bot_ai::_OnManaRegenUpdate() const
+{
+    //regen_normal
+    uint8 mylevel = me->GetLevel();
+    float value = IAmFree() ? mylevel/2 : 0; //200/0 mp5 at 80
+
+    float power_regen_mp5;
+    int32 modManaRegenInterrupt;
+    if (_botclass < BOT_CLASS_EX_START)
+    {
+        // Mana regen from spirit and intellect
+        float spiregen = 0.001f;
+        if (GtRegenMPPerSptEntry const* moreRatio = sGtRegenMPPerSptStore.LookupEntry((_botclass-1)*GT_MAX_LEVEL + mylevel-1))
+            spiregen = moreRatio->Data * _getTotalBotStat(BOT_STAT_MOD_SPIRIT);
+
+        // PCT bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT aura on spirit base regen
+        value += sqrt(_getTotalBotStat(BOT_STAT_MOD_INTELLECT)) * spiregen * me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+        // regen from SPELL_AURA_MOD_POWER_REGEN aura (per second)
+        power_regen_mp5 = 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+        if (IAmFree())
+            power_regen_mp5 += float(mylevel);
+        // bonus from SPELL_AURA_MOD_MANA_REGEN_FROM_STAT aura
+        Unit::AuraEffectList const& regenAura = me->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+            power_regen_mp5 += me->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() * 0.002f; //per second
+
+        //bot also receive bonus from SPELL_AURA_MOD_POWER_REGEN_PERCENT for mp5 regen
+        power_regen_mp5 *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+
+        // Set regen rate in cast state apply only on spirit based regen
+        modManaRegenInterrupt = std::min<int32>(100, me->GetTotalAuraModifier(SPELL_AURA_MOD_MANA_REGEN_INTERRUPT));
+    }
+    else
+    {
+        modManaRegenInterrupt = 100;
+        power_regen_mp5 = 0.0f;
+
+        if (IsHeroExClass(_botclass))
+        {
+            float basemana;
+            if (_botclass == BOT_CLASS_BM)
+                basemana = BASE_MANA_1_BM;
+            else if (_botclass == BOT_CLASS_ARCHMAGE)
+                basemana = BASE_MANA_1_ARCHMAGE;
+            else if (_botclass == BOT_CLASS_DREADLORD)
+                basemana = BASE_MANA_1_DREADLORD;
+            else if (_botclass == BOT_CLASS_DARK_RANGER)
+                basemana = BASE_MANA_1_DARK_RANGER;
+            else if (_botclass == BOT_CLASS_SEA_WITCH)
+                basemana = BASE_MANA_1_SEA_WITCH;
+            else
+                basemana = 0.f;
+
+            value = basemana * 0.0087f + 0.08f * GetTotalBotStat(BOT_STAT_MOD_INTELLECT);
+            value += 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+            value *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+
+            //if (_botclass == BOT_CLASS_SEA_WITCH && me->HasAuraType(SPELL_AURA_MANA_SHIELD))
+            //    modManaRegenInterrupt *= 0.25f;
+        }
+        else if (_botclass == BOT_CLASS_SPHYNX)
+        {
+            value = CalculatePct(me->GetCreateMana(), 2); //-2% basemana/sec
+        }
+        else if (_botclass == BOT_CLASS_SPELLBREAKER)
+        {
+            value = 4.f; //base 0.8/sec
+            value += 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+            value *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+        }
+        else if (_botclass == BOT_CLASS_NECROMANCER)
+        {
+            value = 7.5f; //base 1.5/sec
+            value += 0.2f * (me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + _getTotalBotStat(BOT_STAT_MOD_MANA_REGENERATION));
+            value *= me->GetTotalAuraMultiplierByMiscValue(SPELL_AURA_MOD_POWER_REGEN_PERCENT, POWER_MANA);
+        }
+        else
+            value = 0;
+
+        if (IAmFree())
+            value += float(mylevel);
+    }
+
+    //Unrelenting Storm, Dreamstate: 12% of intellect as mana regen always (divided by 5)
+    if ((_botclass == BOT_CLASS_SHAMAN && _spec == BOT_SPEC_SHAMAN_ELEMENTAL) ||
+        (_botclass == BOT_CLASS_DRUID && _spec == BOT_SPEC_DRUID_BALANCE))
+        power_regen_mp5 += 0.024f * _getTotalBotStat(BOT_STAT_MOD_INTELLECT);
+
+    me->SetStatFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER, power_regen_mp5 + CalculatePct(value, modManaRegenInterrupt));
+    me->SetStatFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER, power_regen_mp5 + value);
+}
+
+void bot_ai::_UpdateWMOArea()
+{
+    _wmoAreaUpdateTimer = urand(7000, 9000);
+
+    uint32 mogpFlags;
+    int32 adtId, rootId, groupId;
+    me->GetMap()->GetAreaInfo(me->GetPhaseMask(), me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(),
+        mogpFlags, adtId, rootId, groupId);
+
+    if (WMOAreaTableEntry const* wmoEntry = GetWMOAreaTableEntryByTripple(rootId, adtId, groupId))
+    {
+        _lastWMOAreaId = wmoEntry->ID;
+        //TC_LOG_ERROR("scripts", "_UpdateWMOArea(): bot %s: area %u, wmoarea %u", me->GetName().c_str(), _lastAreaId, _lastWMOAreaId);
+    }
+}
+
+void bot_ai::_OnZoneUpdate(uint32 zoneId, uint32 areaId)
+{
+    ASSERT(!IAmFree());
+    ASSERT(me->IsInWorld());
+
+    _lastZoneId = zoneId;
+
+    _OnAreaUpdate(areaId);
+
+    AreaTableEntry const* zone = sAreaTableStore.LookupEntry(zoneId);
+    if (!zone)
+        return;
+
+    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(zoneId);
+    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+    {
+        if (itr->second->autocast && itr->second->IsFitToRequirements(master, zoneId, 0))
+        {
+            if (!me->HasAura(itr->second->spellId))
+                me->CastSpell(me, itr->second->spellId, true);
+            if (botPet && !botPet->HasAura(itr->second->spellId))
+                botPet->CastSpell(botPet, itr->second->spellId, true);
+        }
+    }
+}
+
+void bot_ai::_OnAreaUpdate(uint32 areaId)
+{
+    ASSERT(!IAmFree());
+    ASSERT(me->IsInWorld());
+
+    _lastAreaId = areaId;
+
+    Unit::AuraMap& ownerAuras = me->GetOwnedAuras();
+    for (Unit::AuraMap::iterator iter = ownerAuras.begin(); iter != ownerAuras.end();)
+    {
+        if (iter->second->GetSpellInfo()->CheckLocation(me->GetMapId(), _lastZoneId, areaId, master, false) != SPELL_CAST_OK)
+        {
+            //me->RemoveOwnedAura(iter);
+            //we assume 1 aura at a time at most for area (once per 1.5 sec)
+            me->RemoveAurasDueToSpell(iter->first);
+            if (botPet)
+                botPet->RemoveAurasDueToSpell(iter->first);
+            break;
+        }
+        else
+            ++iter;
+    }
+
+    SpellAreaForAreaMapBounds saBounds = sSpellMgr->GetSpellAreaForAreaMapBounds(areaId);
+    for (SpellAreaForAreaMap::const_iterator itr = saBounds.first; itr != saBounds.second; ++itr)
+    {
+        if (itr->second->autocast && itr->second->IsFitToRequirements(master, _lastZoneId, 0))
+        {
+            if (!me->HasAura(itr->second->spellId))
+                me->CastSpell(me, itr->second->spellId, true);
+            if (botPet && !botPet->HasAura(itr->second->spellId))
+                botPet->CastSpell(botPet, itr->second->spellId, true);
+        }
+    }
+}
+
+bool bot_ai::IsInHeroicOrRaid() const
+{
+    return me->FindMap() && (me->GetMap()->IsHeroic() || me->GetMap()->IsRaid());
+}
+
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    //uint32 const spellId = spell->Id;
+
+    if (!spell->IsPositive() && spell->GetMaxDuration() > 1000 && caster->IsControlledByPlayer() &&
+        _botclass >= BOT_CLASS_EX_START)
+    {
+        //bots of W3 classes will not be easily CCed
+        if (spell->HasAura(SPELL_AURA_MOD_STUN) || spell->HasAura(SPELL_AURA_MOD_CONFUSE) ||
+            spell->HasAura(SPELL_AURA_MOD_PACIFY) || spell->HasAura(SPELL_AURA_MOD_ROOT))
+        {
+            if (Aura* cont = me->GetAura(spell->Id, caster->GetGUID()))
+            {
+                if (AuraApplication const* aurApp = cont->GetApplicationOfTarget(me->GetGUID()))
+                {
+                    if (!aurApp->IsPositive())
+                    {
+                        int32 dur = std::max<int32>(cont->GetMaxDuration() / 3, 1000);
+                        cont->SetDuration(dur);
+                        cont->SetMaxDuration(dur);
+                    }
+                }
+            }
+        }
+    }
+
+    if (!HasBotCommandState(BOT_COMMAND_FULLSTOP))
+    {
+        if (spell->HasAura(SPELL_AURA_MOD_TAUNT) || spell->HasEffect(SPELL_EFFECT_ATTACK_ME))
+            if (caster && me->Attack(caster, !HasRole(BOT_ROLE_RANGED)))
+            {}//me->GetMotionMaster()->MoveChase(caster);
+    }
+
+    if (spell->GetSpellSpecific() == SPELL_SPECIFIC_DRINK)
+    {
+        feast_mana = true;
+        UpdateMana();
+        regenTimer = 0;
+    }
+    else if (spell->GetSpellSpecific() == SPELL_SPECIFIC_FOOD)
+    {
+        feast_health = true;
+        regenTimer = 0;
+    }
+
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 const auraname = spell->_effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            //TC_LOG_ERROR("entities.unit", "OnSpellHit: mount on %s", me->GetName().c_str());
+            UnsummonAll();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                //TC_LOG_ERROR("entities.unit", "OnSpellHit: modding flight speed");
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->Movement.Flight = CreatureFlightMovementType::CanFly;
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                if (Aura* mount = me->GetAura(spell->Id))
+                {
+                    //TC_LOG_ERROR("entities.unit", "OnSpellHit: found aura");
+                    for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
+                    {
+                        if (spell->_effects[j].ApplyAuraName != SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED &&
+                            spell->_effects[j].ApplyAuraName != SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED &&
+                            spell->_effects[j].ApplyAuraName != SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                            continue;
+                        if (AuraEffect* meff = mount->GetEffect(j))
+                        {
+                            meff->ChangeAmount(meff->GetAmount() * 3);
+                        }
+                    }
+                }
+                //me->SetSpeedRate(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                //me->SetSpeedRate(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                me->m_movementInfo.SetMovementFlags(MOVEMENTFLAG_FLYING);
+            }
+            else
+                me->SetSpeedRate(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.1f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE || auraname == SPELL_AURA_MOD_SKILL ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT ||
+            auraname == SPELL_AURA_MOD_RATING || auraname == SPELL_AURA_MOD_RATING_FROM_STAT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+            auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2 blood pact, commanding shout
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+            UpdateHealth();
+        else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+            UpdateMana(); //Divine Hymn - max mana increase
+
+        uint32 const effect = spell->_effects[i].Effect;
+        if (effect == SPELL_EFFECT_RESURRECT || effect == SPELL_EFFECT_RESURRECT_NEW || effect == SPELL_EFFECT_SELF_RESURRECT)
+        {
+            //resurrect effects are not handled for creatures
+            if (!me->IsAlive())
+            {
+                uint32 health = 0;
+                uint32 mana = 0;
+                int32 damage = spell->_effects[i].BasePoints;
+
+                if (effect == SPELL_EFFECT_RESURRECT_NEW)
+                {
+                    //Glyph of Rebirth: resurrect with 100% health
+                    if (spell->IsRankOf(sSpellMgr->GetSpellInfo(20484)))
+                        health = me->GetMaxHealth();
+                    else
+                        health = damage;
+                    mana = spell->_effects[i].MiscValue;
+                }
+                else if (damage < 0)
+                {
+                    health = uint32(-damage);
+                    mana = spell->_effects[i].MiscValue;
+                }
+                else
+                {
+                    health = me->CountPctFromMaxHealth(damage);
+                    if (me->GetMaxPower(POWER_MANA) > 1)
+                        mana = CalculatePct(me->GetMaxPower(POWER_MANA), damage);
+                }
+
+                BotMgr::ReviveBot(me, caster);
+
+                me->SetHealth(health);
+                if (me->GetMaxPower(POWER_MANA) > 1)
+                    me->SetPower(POWER_MANA, mana);
+            }
+        }
+        //ravasaur poison (EffectEnchantHeldItem) for mh and oh
+        if (effect == SPELL_EFFECT_ENCHANT_HELD_ITEM)
+        {
+            uint32 enchant_id = spell->_effects[i].MiscValue;
+            if (!enchant_id)
+                continue;
+
+            EnchantmentSlot slot = TEMP_ENCHANTMENT_SLOT;
+            Item* weap = _equips[BOT_SLOT_MAINHAND];
+            if (!weap || weap->GetEnchantmentId(slot))
+                weap = _equips[BOT_SLOT_OFFHAND];
+            if (!weap || weap->GetTemplate()->Class != ITEM_CLASS_WEAPON || weap->GetEnchantmentId(slot))
+                continue;
+
+            int32 duration = spell->GetDuration();
+            if (!duration)
+                duration = 10; //10 sec default
+
+            if (!IAmFree())
+                master->GetSession()->SendEnchantmentLog(me->GetGUID(), caster->GetGUID(), weap->GetEntry(), enchant_id);
+
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration * IN_MILLISECONDS);
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, 0);
+            ApplyItemBonuses(weap == _equips[BOT_SLOT_MAINHAND] ? BOT_SLOT_MAINHAND : BOT_SLOT_OFFHAND);
+        }
+    }
+
+    //TODO:
+    if (/*!(spell->AttributesEx & SPELL_ATTR1_NO_THREAT) &&
+        !(spell->AttributesEx3 & SPELL_ATTR3_NO_INITIAL_AGGRO) && !CCed(me) && */
+        !me->GetVictim() &&
+        (me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        //_atHome = false;
+        if (!me->CanSeeOrDetect(caster))
+        {
+            if (_evadeMode)
+                me->BotStopMovement();
+        }
+        else if (caster->IsInCombat() || me->IsInCombat())
+            this->OwnerAttackedBy(caster);
+        //if (_evadeMode == true && me->isMoving() && IAmFree())
+    }
+}
+void bot_ai::OnSpellHitTarget(Unit* /*target*/, SpellInfo const* spell)
+{
+    if (me->GetVehicle())
+    {
+        uint32 spellId = spell->Id;
+
+        //Flame Spike, Revivify
+        if (spellId == 56091 || spellId == 57090)
+        {
+            vehcomboPoints = std::min(vehcomboPoints + 1, 5);
+            //TC_LOG_ERROR("scripts", "OnBotSpellGo(): veh cp spell %u now cp %u", curInfo->Id, uint32(vehcomboPoints));
+        }
+        //Engulf in Flames, Life Burst, Flame Shield   moved to globalupdate
+        if (spellId == 56092 || spellId == 57143 || spellId == 57108)
+        {
+            vehcomboPoints = 0;
+            //TC_LOG_ERROR("scripts", "OnSpellHitTarget(): veh cp waster %u", curInfo->Id);
+        }
+    }
+}
+//Update delay
+//Skip UpdateAI cycles for randomization of bots' reaction and performance adjustments
+bool bot_ai::Wait()
+{
+    if (waitTimer > lastdiff || !master->IsInWorld())
+        return true;
+
+    if (IAmFree())
+        waitTimer = me->IsInCombat() ? 500 : urand(750, 1250);
+    else if (!master->GetMap()->IsRaid())
+        waitTimer = std::min<uint32>(uint32(50 * (master->GetNpcBotsCount() - 1) + __rand), 500);
+    else
+        waitTimer = __rand;
+
+    waitTimer += BotMgr::GetBaseUpdateDelay();
+
+    return false;
+}
+//Spell Mod Hooks
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    //WHITE ATTACKS damage bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool iscrit) const
+{
+    //MELEE ABILITIES damage bonus (DMG_CLASS != DMG_CLASS_MAGIC)
+    ApplyClassDamageMultiplierMeleeSpell(damage, damageinfo, spellInfo, attackType, iscrit);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool iscrit) const
+{
+    //DAMAGE SPELLS damage bonus (DMG_CLASS_MAGIC)
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, iscrit);
+}
+void bot_ai::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    //HEALING SPELLS amount bonus
+    ApplyClassDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+    heal = (heal * BotMgr::GetBotHealingMod());
+}
+void bot_ai::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    //ALL SPELLS crit bonus + base
+    ApplyClassSpellCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+    crit_chance += crit;
+}
+void bot_ai::ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    //ALL SPELLS power cost bonus
+    ApplyClassSpellCostMods(spellInfo, cost);
+}
+void bot_ai::ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    //ALL SPELLS cast time bonus
+    ApplyClassSpellCastTimeMods(spellInfo, casttime);
+}
+void bot_ai::ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS cooldown bonus
+    ApplyClassSpellCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS category cooldown bonus
+    ApplyClassSpellCategoryCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+{
+    //ALL SPELLS global cooldown bonus
+    ApplyClassSpellGlobalCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+{
+    //ALL SPELLS radius bonus (not range)
+    ApplyClassSpellRadiusMods(spellInfo, radius);
+}
+void bot_ai::ApplyBotSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+{
+    //ALL SPELLS range bonus
+    ApplyClassSpellRangeMods(spellInfo, maxrange);
+}
+void bot_ai::ApplyBotSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+{
+    //ALL SPELLS max targets bonus
+    ApplyClassSpellMaxTargetsMods(spellInfo, targets);
+}
+void bot_ai::ApplyBotSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+{
+    //ALL CLASS PROC_TRIGGER_SPELL SPELLS chance of success bonus
+    ApplyClassSpellChanceOfSuccessMods(spellInfo, chance);
+}
+void bot_ai::ApplyBotEffectMods(WorldObject const* wtarget, SpellInfo const* spellInfo, uint8 effIndex, float& value) const
+{
+    //ALL SPELLS SPELLMOD_EFFECT_X bonus
+    ApplyClassEffectMods(wtarget, spellInfo, effIndex, value);
+}
+void bot_ai::ApplyBotThreatMods(SpellInfo const* spellInfo, float& threat) const
+{
+    //ALL threat mods
+    ApplyClassThreatMods(spellInfo, threat);
+}
+void bot_ai::ApplyBotEffectValueMultiplierMods(SpellInfo const* spellInfo, SpellEffIndex effIndex, float& multiplier) const
+{
+    //ALL SPELLMOD_VALUE_MULTIPLIER mods
+    ApplyClassEffectValueMultiplierMods(spellInfo, effIndex, multiplier);
+}
+//Spell Mod Utilities
+float bot_ai::CalcSpellMaxRange(uint32 spellId, bool enemy) const
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    //ASSERT(spellInfo);
+
+    float maxRange = spellInfo->GetMaxRange(!enemy);
+    if (maxRange == 0x0)
+        return maxRange;
+
+    ApplyClassSpellRangeMods(spellInfo, maxRange);
+    return maxRange;
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello
+bool bot_ai::OnGossipHello(Player* player, uint32 /*option*/)
+{
+    if (!BotMgr::IsNpcBotModEnabled() || !BotMgr::IsClassEnabled(_botclass) ||
+        IsTempBot() || me->IsInCombat() || CCed(me) || IsCasting() || IsDuringTeleport() ||
+        HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) ||
+        (me->GetVehicle() && me->GetVehicle()->GetBase()->IsInCombat()))
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    if (me->isMoving())
+        me->BotStopMovement();
+
+    uint32 gossipTextId;
+    if (!IAmFree())
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DARKRANGER;
+        else if (_botclass == BOT_CLASS_SEA_WITCH)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SEAWITCH;
+        else
+            gossipTextId = GOSSIP_NORMAL_SERVE_MASTER;
+    }
+    else
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DARKRANGER;
+        else if (_botclass == BOT_CLASS_SEA_WITCH)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SEAWITCH;
+        else
+            gossipTextId = GOSSIP_GREET_NEED_SMTH;
+    }
+
+    bool menus = false;
+
+    if (player->IsGameMaster())
+    {
+        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_DEBUG), GOSSIP_SENDER_DEBUG, GOSSIP_ACTION_INFO_DEF + 1);
+        menus = true;
+    }
+
+    if (player->GetGUID().GetCounter() != _ownerGuid)
+    {
+        if (IAmFree())
+        {
+            uint32 cost = BotMgr::GetNpcBotCost(player->GetLevel(), _botclass);
+
+            int8 reason = 0;
+            if (me->HasAura(BERSERK))
+                reason = -1;
+            if (!reason && _ownerGuid)
+                reason = 1;
+            if (!reason && player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                reason = 2;
+            if (!reason && !player->HasEnoughMoney(cost))
+                reason = 3;
+
+            if (!reason && BotMgr::GetMaxClassBots() && player->HaveBot())
+            {
+                uint8 count = 0;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    if (itr->second->GetBotClass() == _botclass)
+                        ++count;
+
+                if (!reason && count >= BotMgr::GetMaxClassBots())
+                    reason = 4;
+            }
+
+            std::ostringstream message1;
+            std::ostringstream message2;
+            if (_botclass == BOT_CLASS_SPHYNX)
+            {
+                message1 << LocalizedNpcText(player, BOT_TEXT_HIREWARN_SPHYNX_1) << me->GetName() << LocalizedNpcText(player, BOT_TEXT_HIREWARN_SPHYNX_2);
+                message2 << LocalizedNpcText(player, BOT_TEXT_HIREOPTION_SPHYNX);
+            }
+            else if (_botclass == BOT_CLASS_DREADLORD)
+            {
+                message1 << LocalizedNpcText(player, BOT_TEXT_HIREWARN_DREADLORD) << me->GetName() << '?';
+                message2 << LocalizedNpcText(player, BOT_TEXT_HIREOPTION_DREADLORD);
+            }
+            else if (_botclass == BOT_CLASS_SEA_WITCH)
+            {
+                message1 << LocalizedNpcText(player, BOT_TEXT_HIREWARN_SEAWITCH);
+                message2 << LocalizedNpcText(player, BOT_TEXT_HIREOPTION_SEAWITCH);
+            }
+            else
+            {
+                message1 << LocalizedNpcText(player, BOT_TEXT_HIREWARN_DEFAULT) << me->GetName() << '?';
+                message2 << LocalizedNpcText(player, BOT_TEXT_HIREOPTION_DEFAULT);
+            }
+
+            if (!reason)
+            {
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, message2.str().c_str(),
+                    GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + 0, message1.str().c_str(), cost, false);
+            }
+            else
+                AddGossipItemFor(player, GOSSIP_ICON_TAXI, message2.str().c_str(), GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + reason);
+
+            menus = true;
+        }
+    }
+
+    if (_ownerGuid)
+    {
+        Group const* gr = player->GetGroup();
+
+        if (player == master)
+        {
+            menus = true;
+
+            //general: equips, roles, distance, abilities, comsumables, group
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_MANAGE_EQUIPMENT), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_MANAGE_ROLES), GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_MANAGE_FORMATION), GOSSIP_SENDER_FORMATION, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_MANAGE_ABILITIES), GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+            if (_botclass < BOT_CLASS_EX_START)
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_MANAGE_TALENTS), GOSSIP_SENDER_SPEC, GOSSIP_ACTION_INFO_DEF + 1);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_GIVE_CONSUMABLE), GOSSIP_SENDER_USEITEM, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+
+            if (!gr)
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_CREATE_GROUP), GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+                if (player->GetNpcBotsCount() > 1)
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_CREATE_GROUP_ALL), GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+            else if (!gr->IsMember(me->GetGUID()))
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_ADD_TO_GROUP), GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_ADD_TO_GROUP_ALL), GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+            else
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_REMOVE_FROM_GROUP), GOSSIP_SENDER_LEAVE_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //movement toggle
+            if (HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_FOLLOW_ME), GOSSIP_SENDER_FOLLOWME, GOSSIP_ACTION_INFO_DEF + 1);
+            if (!HasBotCommandState(BOT_COMMAND_STAY))
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_HOLD_POSITION), GOSSIP_SENDER_HOLDPOSITION, GOSSIP_ACTION_INFO_DEF + 1);
+            if (!HasBotCommandState(BOT_COMMAND_FULLSTOP))
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_STAY_HERE), GOSSIP_SENDER_DONOTHING, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        if (player == master || (gr && gr->IsMember(master->GetGUID())))
+        {
+            //class-specific for party: mage rations, rogue lockpicking etc.
+            //TODO: priest lightwell (manual only) maybe move into abilities
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_MAGE_FOOD), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_MAGE_DRINK), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    if (me->GetLevel() >= 70)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_MAGE_TABLE), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                    menus = true;
+                    break;
+                }
+                case BOT_CLASS_ROGUE:
+                {
+                    //Learned at 16
+                    //Allow rogues to gain skill with bot's help
+                    if (me->GetLevel() >= 16/* && !player->HasSkill(SKILL_LOCKPICKING)*/)
+                    {
+                        std::ostringstream msg;
+                        msg << LocalizedNpcText(player, BOT_TEXT_ROGUE_PICKLOCK) << " (" << uint32(me->GetLevel() * 5) << ")";
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                        menus = true;
+                    }
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_WARLOCK_HEALTHSTONE), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    if (me->GetLevel() >= 68)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_WARLOCK_SOULWELL), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                    menus = true;
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+        if (player == master)
+        {
+            //class-specific for owner: poisons, enchants, etc.
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    if (me->GetLevel() >= 20)
+                    {
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_ROGUE_POISON_REFRESH), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                        AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ROGUE_POISON_MH), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                        Item const* oweap = _equips[BOT_SLOT_OFFHAND];
+                        if (oweap && oweap->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+                            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ROGUE_POISON_OH), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 4);
+                    }
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    if (me->GetLevel() >= 10)
+                    {
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_SHAMAN_ENCH_REFRESH), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                        AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SHAMAN_ENCH_MH), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 3);
+                        Item const* oweap = _equips[BOT_SLOT_OFFHAND];
+                        if (oweap && oweap->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+                            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SHAMAN_ENCH_OH), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 4);
+                    }
+                    if (me->GetShapeshiftForm() != FORM_NONE)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_REMOVE_SHAPESHIFT), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 5);
+                    break;
+                }
+                case BOT_CLASS_DRUID:
+                {
+                    if (me->GetShapeshiftForm() != FORM_NONE)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_REMOVE_SHAPESHIFT), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    break;
+                }
+                case BOT_CLASS_HUNTER:
+                {
+                    if (me->GetLevel() >= 10)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_CHOOSE_PET_TYPE), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_CHOOSE_PET_TYPE), GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    break;
+                }
+                default:
+                    break;
+            }
+
+            std::ostringstream astr;
+            astr << LocalizedNpcText(player, BOT_TEXT_ABANDON_WARN_1) << me->GetName() << "? " << LocalizedNpcText(player, BOT_TEXT_ABANDON_WARN_2);
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, LocalizedNpcText(player, BOT_TEXT_UR_DISMISSED),
+                GOSSIP_SENDER_DISMISS, GOSSIP_ACTION_INFO_DEF + 1, astr.str().c_str(), 0, false);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_PULL_URSELF), GOSSIP_SENDER_TROUBLESHOOTING, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+    }
+
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        menus = true;
+        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_STUDY_CREATURE), GOSSIP_SENDER_SCAN, GOSSIP_ACTION_INFO_DEF + 1);
+    }
+
+    if (!menus)
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NEVERMIND), 0, GOSSIP_ACTION_INFO_DEF + 1);
+    player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_ai::OnGossipSelect(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action)
+{
+    //if (!IsInBotParty(player))
+    //{
+    //    player->PlayerTalkClass->SendCloseGossip();
+    //    return true;
+    //}
+
+    if (!BotMgr::IsNpcBotModEnabled() || me->HasUnitState(UNIT_STATE_CASTING) || CCed(me) || IsDuringTeleport() ||
+        HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) ||
+        (me->GetVehicle() && me->GetVehicle()->GetBase()->IsInCombat()))
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    uint32 gossipTextId;
+    if (!IAmFree())
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DARKRANGER;
+        else if (_botclass == BOT_CLASS_SEA_WITCH)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SEAWITCH;
+        else
+            gossipTextId = GOSSIP_NORMAL_SERVE_MASTER;
+    }
+    else
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DARKRANGER;
+        else if (_botclass == BOT_CLASS_SEA_WITCH)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SEAWITCH;
+        else
+            gossipTextId = GOSSIP_GREET_NEED_SMTH;
+    }
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            BotSay("...", player);
+            break;
+        }
+        case 1: //BACK: return to main menu
+        {
+            return bot_ai::OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_CLASS:
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+
+                    uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+                    if (option == 1 || option == 2) //food, water
+                    {
+                        //Prevent high-leveled consumables for low-level characters
+                        Unit* checker;
+                        if (player->GetLevel() < me->GetLevel())
+                            checker = player;
+                        else
+                            checker = me;
+
+                        // Conjure Refreshment rank 1
+                        uint32 food = InitSpell(checker, 42955);
+                        bool iswater = (option == 2);
+                        if (!food)
+                        {
+                            if (!iswater)// Conjure Food rank 1
+                                food = InitSpell(checker, 587);
+                            else// Conjure Water rank 1
+                                food = InitSpell(checker, 5504);
+                        }
+                        if (!food)
+                        {
+                            BotWhisper(LocalizedNpcText(player, iswater ? BOT_TEXT_CANT_CONJURE_WATER_YET : BOT_TEXT_CANT_CONJURE_FOOD_YET), player);
+                            break;
+                        }
+                        SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                        Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+                        SpellCastTargets targets;
+                        targets.SetUnitTarget(player);
+                        SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                        if (result != SPELL_CAST_OK)
+                        {
+                            foodspell->finish(false);
+                            delete foodspell;
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_CANT_RIGHT_NOW), player);
+                        }
+                        else
+                        {
+                            aftercastTargetGuid = player->GetGUID();
+                            foodspell->prepare(targets);
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_HERE_YOU_GO), player);
+                        }
+                        break;
+                    }
+                    else if (option == 3) //refreshment table
+                    {
+                        uint32 tableSpellId = GetSpell(43987); //Ritual of Refreshment
+                        if (!tableSpellId)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_DISABLED), player);
+                            break;
+                        }
+                        if (!IsSpellReady(43987, GetLastDiff(), false))
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_NOT_READY_YET), player);
+                            break;
+                        }
+                        uint32 tableGOForSpell = (tableSpellId == 43987 ? GO_REFRESHMENT_TABLE_1 : GO_REFRESHMENT_TABLE_2);
+                        GameObjectTemplate const* goInfo = sObjectMgr->GetGameObjectTemplate(tableGOForSpell);
+                        if (!goInfo)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_INVALID_OBJECT_TYPE), player);
+                            break;
+                        }
+                        float x,y,z;
+                        me->GetClosePoint(x, y, z, me->GetCombatReach(), 0.f, 0.f);
+                        QuaternionData rot = QuaternionData::fromEulerAnglesZYX(me->GetOrientation(), 0.f, 0.f);
+
+                        GameObject* table = new GameObject;
+                        if (!table->Create(me->GetMap()->GenerateLowGuid<HighGuid::GameObject>(), tableGOForSpell, me->GetMap(),
+                            me->GetPhaseMask(), Position(x,y,z,me->GetOrientation()), rot, 255, GO_STATE_READY))
+                        {
+                            delete table;
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_FAILED), player);
+                            break;
+                        }
+
+                        SetSpellCooldown(43987, 300000);
+
+                        table->SetRespawnTime(180);
+                        //table->SetOwnerGUID(master->GetGUID());
+                        master->AddGameObject(table);
+                        table->SetSpellId(tableSpellId);
+                        me->GetMap()->AddToMap(table);
+
+                        BotWhisper(LocalizedNpcText(player, BOT_TEXT_DONE), player);
+                        break;
+                    }
+                    break;
+                }
+                case BOT_CLASS_ROGUE:
+                {
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 1)
+                    {
+                        // Pick Lock
+                        subMenu = true;
+
+                        uint32 count = 0;
+                        uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 1; //BACK
+
+                        //1 Nearest gameobject
+                        GameObject* obj = nullptr;
+                        NearestLockedGameObjectInRangeCheck check(player, 4.f);
+                        Trinity::GameObjectLastSearcher<NearestLockedGameObjectInRangeCheck> searcher(player, obj, check);
+                        Cell::VisitAllObjects(player, searcher, 4.f);
+                        //player->VisitNearbyGridObject(4.f, searcher);
+                        if (obj)
+                        {
+                            std::ostringstream msg;
+                            msg << obj->GetGOInfo()->name << " (" << LocalizedNpcText(player, BOT_TEXT_DISTANCE_SHORT) << " = " << player->GetExactDist(obj) << ")";
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + ++count);
+                        }
+
+                        //2 Inventory
+                        Item* item = nullptr;
+                        LockEntry const* lockInfo;
+
+                        //backpack
+                        for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+                        {
+                            item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                            if (item && item->IsLocked() && item->GetTemplate()->LockID)
+                            {
+                                lockInfo = sLockStore.LookupEntry(item->GetTemplate()->LockID);
+                                if (!lockInfo)
+                                    continue;
+
+                                for (uint8 j = 0; j != MAX_LOCK_CASE; ++j)
+                                {
+                                    if (lockInfo->Type[j] == LOCK_KEY_SKILL && lockInfo->Index[j] == LOCKTYPE_PICKLOCK &&
+                                        lockInfo->Skill[j] <= uint32(15 + creature->GetLevel() * 5))
+                                    {
+                                        std::ostringstream name;
+                                        _AddItemLink(player, item, name, false);
+                                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                        //bags
+                        for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                        {
+                            if (Bag const* bag = player->GetBagByPos(i))
+                            {
+                                for (uint32 j = 0; j != bag->GetBagSize() && count <= maxcounter; ++j)
+                                {
+                                    item = player->GetItemByPos(i, j);
+                                    if (item && item->IsLocked() && item->GetTemplate()->LockID)
+                                    {
+                                        lockInfo = sLockStore.LookupEntry(item->GetTemplate()->LockID);
+                                        if (!lockInfo)
+                                            continue;
+
+                                        for (uint8 k = 0; k != MAX_LOCK_CASE; ++k)
+                                        {
+                                            if (lockInfo->Type[k] == LOCK_KEY_SKILL && lockInfo->Index[k] == LOCKTYPE_PICKLOCK &&
+                                                lockInfo->Skill[k] <= uint32(15 + creature->GetLevel() * 5))
+                                            {
+                                                std::ostringstream name;
+                                                _AddItemLink(player, item, name, false);
+                                                AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_CLASS_ACTION, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                                ++count;
+                                                break;
+                                            }
+                                        }
+                                    }
+                                }
+                            }
+                        }
+
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + ++count);
+                    }
+                    else if (action == 2)
+                    {
+                        //Clear poisons (autorefresh is in class ai DoNonCombatActions
+                        RemoveItemClassEnchants();
+                    }
+                    else if (action == 3)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_MH);
+                        //Send list of available poisons on MH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_6; ++i)
+                        {
+                            uint32 possiblePoison = GetAIMiscValue(i);
+                            if (uint32 possiblePoisonMaxRank = GetSpell(possiblePoison))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possiblePoisonMaxRank);
+                                uint32 curMHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH);
+                                bool same = possiblePoison == curMHId;
+                                std::string spellName;
+                                _LocalizeSpell(player, spellName, availableInfo->Id);
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, spellName, GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + possiblePoison);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AUTO), GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 4)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_OH);
+                        //Send list of available poisons on OH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_6; ++i)
+                        {
+                            uint32 possiblePoison = GetAIMiscValue(i);
+                            if (uint32 possiblePoisonMaxRank = GetSpell(possiblePoison))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possiblePoisonMaxRank);
+                                uint32 curOHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH);
+                                bool same = possiblePoison == curOHId;
+                                std::string spellName;
+                                _LocalizeSpell(player, spellName, availableInfo->Id);
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, spellName, GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + possiblePoison);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AUTO), GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        //Clear enchants (autorefresh is in class ai DoNonCombatActions
+                        RemoveItemClassEnchants();
+                    }
+                    else if (action == 3)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_MH);
+                        //Send list of available enchants on MH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_5; ++i)
+                        {
+                            uint32 possibleEnchant = GetAIMiscValue(i);
+                            if (uint32 possibleEcnhantMaxRank = GetSpell(possibleEnchant))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possibleEcnhantMaxRank);
+                                uint32 curMHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH);
+                                bool same = possibleEnchant == curMHId;
+                                std::string spellName;
+                                _LocalizeSpell(player, spellName, availableInfo->Id);
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, spellName, GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + possibleEnchant);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AUTO), GOSSIP_SENDER_CLASS_ACTION2, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 4)
+                    {
+                        subMenu = true;
+                        bool isauto = GetAIMiscValue(BOTAI_MISC_ENCHANT_IS_AUTO_OH);
+                        //Send list of available enchants on OH
+                        for (uint32 i = BOTAI_MISC_ENCHANT_AVAILABLE_1; i <= BOTAI_MISC_ENCHANT_AVAILABLE_5; ++i)
+                        {
+                            uint32 possibleEnchant = GetAIMiscValue(i);
+                            if (uint32 possibleEcnhantMaxRank = GetSpell(possibleEnchant))
+                            {
+                                SpellInfo const* availableInfo = sSpellMgr->GetSpellInfo(possibleEcnhantMaxRank);
+                                uint32 curOHId = GetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH);
+                                bool same = possibleEnchant == curOHId;
+                                std::string spellName;
+                                _LocalizeSpell(player, spellName, availableInfo->Id);
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, spellName, GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + possibleEnchant);
+                            }
+                        }
+                        AddGossipItemFor(player, isauto ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AUTO), GOSSIP_SENDER_CLASS_ACTION3, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 5)
+                    {
+                        if (me->GetShapeshiftForm() == FORM_NONE)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_NOT_SHAPESHIFTED), player);
+                            break;
+                        }
+                        removeShapeshiftForm();
+                    }
+
+                    break;
+                }
+                case BOT_CLASS_HUNTER:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        subMenu = true;
+                        uint32 curType = GetAIMiscValue(BOTAI_MISC_PET_TYPE);
+                        for (uint32 i = BOTAI_MISC_PET_AVAILABLE_1; i <= BOTAI_MISC_PET_AVAILABLE_11; ++i)
+                        {
+                            if (uint32 possibleType = GetAIMiscValue(i))
+                            {
+                                std::string name;
+                                if (possibleType == BOT_PET_CUNNING_START)
+                                {
+                                    name = LocalizedNpcText(player, BOT_TEXT_RANDOMPET_CUNNING);
+                                    possibleType = urand(BOT_PET_CUNNING_START, BOT_PET_CUNNING_END);
+                                }
+                                else if (possibleType == BOT_PET_FEROCITY_START)
+                                {
+                                    name = LocalizedNpcText(player, BOT_TEXT_RANDOMPET_FEROCITY);
+                                    possibleType = urand(BOT_PET_FEROCITY_START, BOT_PET_FEROCITY_END);
+                                }
+                                else if (possibleType == BOT_PET_TENACITY_START)
+                                {
+                                    name = LocalizedNpcText(player, BOT_TEXT_RANDOMPET_TENACITY);
+                                    possibleType = urand(BOT_PET_TENACITY_START, BOT_PET_TENACITY_END);
+                                }
+                                else
+                                {
+                                    CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(possibleType);
+                                    ASSERT(cinfo);
+                                    name = cinfo->Name;
+                                }
+                                bool same = possibleType == curType;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, name.c_str(), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + possibleType);
+                            }
+                        }
+                        bool noPet = curType == BOT_PET_INVALID;
+                        AddGossipItemFor(player, noPet ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NONE2), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + uint32(BOT_PET_INVALID));
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AUTO), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+
+                    action -= GOSSIP_ACTION_INFO_DEF;
+
+                    if (action == 2)
+                    {
+                        subMenu = true;
+                        uint32 curType = GetAIMiscValue(BOTAI_MISC_PET_TYPE);
+                        for (uint32 i = BOTAI_MISC_PET_AVAILABLE_1; i <= BOTAI_MISC_PET_AVAILABLE_5; ++i)
+                        {
+                            if (uint32 possibleType = GetAIMiscValue(i))
+                            {
+                                CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(possibleType);
+                                ASSERT(cinfo);
+                                bool same = possibleType == curType;
+                                AddGossipItemFor(player, same ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, cinfo->Name.c_str(), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + possibleType);
+                            }
+                        }
+                        bool noPet = curType == BOT_PET_INVALID;
+                        AddGossipItemFor(player, noPet ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NONE2), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + uint32(BOT_PET_INVALID));
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AUTO), GOSSIP_SENDER_CLASS_ACTION4, GOSSIP_ACTION_INFO_DEF + 0);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else if (action == 1)
+                    {
+                        if (GetAIMiscValue(6201) == 0)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_NO_HEALTHSTONE), player);
+                            break;
+                        }
+
+                        //Prevent high-leveled healthstone for low-level characters
+                        Unit* checker;
+                        if (player->GetLevel() < me->GetLevel())
+                            checker = player;
+                        else
+                            checker = me;
+
+                        static uint32 HealthStones[8] = { 19005,19007,19009,19011,19013,22105,36891,36894 };
+                        uint32 spellId = InitSpell(me, 6201); //Create Healthstone Rank 1
+                        SpellInfo const* spellInfo = spellId ? sSpellMgr->GetSpellInfo(spellId) : nullptr;
+                        if (!spellInfo)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_CANT_CREATE_HEALTHSTONE), player);
+                            break;
+                        }
+
+                        int8 i = spellInfo->GetRank() - 1;
+                        for (; i != 0; --i)
+                            if (ItemTemplate const* stone = sObjectMgr->GetItemTemplate(HealthStones[i]))
+                                if (stone->RequiredLevel <= checker->GetLevel())
+                                    break;
+
+                        //at least rank 1 (even if player is level 1)
+                        ItemPosCountVec dest;
+                        InventoryResult msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, HealthStones[i], 1);
+                        if (msg != EQUIP_ERR_OK)
+                        {
+                            player->SendEquipError(msg, nullptr, nullptr, HealthStones[i]);
+                            break;
+                        }
+                        Item* item = player->StoreNewItem(dest, HealthStones[i], true, 0);
+                        if (!item)
+                        {
+                            player->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
+                            break;
+                        }
+
+                        //remove healthstone
+                        SetAIMiscValue(6201, 0);
+
+                        player->SendNewItem(item, 1, true, false, true);
+                    }
+                    else if (action == 3) //soulwell
+                    {
+                        uint32 wellSpellId = GetSpell(29893); //Ritual of Souls
+                        if (!wellSpellId)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_DISABLED), player);
+                            break;
+                        }
+                        if (!IsSpellReady(29893, GetLastDiff(), false))
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_NOT_READY_YET), player);
+                            break;
+                        }
+                        uint32 wellGOForSpell = (wellSpellId == 29893 ? GO_SOULWELL_1 : GO_SOULWELL_2);
+                        GameObjectTemplate const* goInfo = sObjectMgr->GetGameObjectTemplate(wellGOForSpell);
+                        if (!goInfo)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_INVALID_OBJECT_TYPE), player);
+                            break;
+                        }
+                        float x,y,z;
+                        me->GetClosePoint(x, y, z, me->GetCombatReach(), 0.f, 0.f);
+                        QuaternionData rot = QuaternionData::fromEulerAnglesZYX(me->GetOrientation(), 0.f, 0.f);
+
+                        GameObject* soulwell = new GameObject;
+                        if (!soulwell->Create(me->GetMap()->GenerateLowGuid<HighGuid::GameObject>(), wellGOForSpell, me->GetMap(),
+                            me->GetPhaseMask(), Position(x,y,z,me->GetOrientation()), rot, 255, GO_STATE_READY))
+                        {
+                            delete soulwell;
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_FAILED), player);
+                            break;
+                        }
+
+                        SetSpellCooldown(29893, 300000);
+
+                        soulwell->SetRespawnTime(180);
+                        //soulwell->SetOwnerGUID(master->GetGUID());
+                        master->AddGameObject(soulwell);
+                        soulwell->SetSpellId(wellSpellId);
+                        me->GetMap()->AddToMap(soulwell);
+
+                        BotWhisper(LocalizedNpcText(player, BOT_TEXT_DONE), player);
+                        break;
+                    }
+                    break;
+                }
+                case BOT_CLASS_DRUID:
+                {
+                    if (IsCasting())
+                    {
+                        player->SendEquipError(EQUIP_ERR_OBJECT_IS_BUSY, nullptr);
+                        break;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_NONE)
+                    {
+                        BotWhisper(LocalizedNpcText(player, BOT_TEXT_NOT_SHAPESHIFTED), player);
+                        break;
+                    }
+
+                    removeShapeshiftForm();
+                    break;
+                }
+
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_CLASS_ACTION:
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    if (!IsCasting())
+                    {
+                        // Pick Lock
+                        uint32 picklock = InitSpell(me, 1804);
+                        if (!picklock)
+                        {
+                            BotWhisper(LocalizedNpcText(player, BOT_TEXT_NO_LOCKPICKING), player);
+                            break;
+                        }
+
+                        SpellInfo const* Info = sSpellMgr->GetSpellInfo(picklock);
+                        Spell* lockpickspell = new Spell(player, Info, TRIGGERED_NONE, me->GetGUID());
+                        SpellCastTargets targets;
+
+                        if (action == GOSSIP_ACTION_INFO_DEF + 1)
+                        {
+                            //1 Nearest gameobject
+                            GameObject* obj = nullptr;
+                            NearestLockedGameObjectInRangeCheck check(player, 4.f);
+                            Trinity::GameObjectLastSearcher<NearestLockedGameObjectInRangeCheck> searcher(player, obj, check);
+                            Cell::VisitAllObjects(player, searcher, 4.f);
+                            //player->VisitNearbyGridObject(4.f, searcher);
+                            if (obj)
+                            {
+                                targets.SetGOTarget(obj);
+                                lockpickspell->m_targets.SetGOTarget(obj); //for checkCast only
+                            }
+                        }
+                        else
+                        {
+                            //2 Inventory
+                            Item* item = nullptr;
+                            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+                            bool found = false;
+                            //backpack
+                            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+                            {
+                                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                                if (item && item->GetGUID().GetCounter() == guidLow)
+                                {
+                                    targets.SetItemTarget(item);
+                                    lockpickspell->m_targets.SetItemTarget(item); //for checkCast only
+                                    found = true;
+                                    break;
+                                }
+                            }
+                            //bags
+                            if (!found)
+                            {
+                                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                                {
+                                    if (Bag const* bag = player->GetBagByPos(i))
+                                    {
+                                        for (uint32 j = 0; j != bag->GetBagSize(); ++j)
+                                        {
+                                            item = player->GetItemByPos(i, j);
+                                            if (item && item->GetGUID().GetCounter() == guidLow)
+                                            {
+                                                targets.SetItemTarget(item);
+                                                lockpickspell->m_targets.SetItemTarget(item); //for checkCast only
+                                                found = true;
+                                                break;
+                                            }
+                                        }
+                                    }
+
+                                    if (found)
+                                        break;
+                                }
+                            }
+                        }
+
+                        SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : lockpickspell->CheckCast(false);
+                        if (result != SPELL_CAST_OK)
+                        {
+                            lockpickspell->finish(false);
+                            delete lockpickspell;
+                            if (result == SPELL_FAILED_LOW_CASTLEVEL)
+                                BotWhisper(LocalizedNpcText(player, BOT_TEXT_SKILL_LEVEL_TOO_LOW), player);
+                            else
+                                BotWhisper(LocalizedNpcText(player, BOT_TEXT_FAILED), player);
+                        }
+                        else
+                        {
+                            lockpickspell->prepare(targets);
+                            //BotWhisper("Here...", player);
+                        }
+                    }
+                    return OnGossipSelect(player, creature, GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    //break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_CLASS_ACTION2: //set cur MH enchant
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH, baseId);
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_MH, baseId);
+                    break;
+                }
+            }
+            return OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_CLASS_ACTION3: //set cur OH enchant
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_ROGUE:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH, baseId);
+                    break;
+                }
+                case BOT_CLASS_SHAMAN:
+                {
+                    uint32 baseId = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_ENCHANT_CURRENT_OH, baseId);
+                    break;
+                }
+            }
+            return OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_CLASS_ACTION4: //set pet type
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_HUNTER:
+                {
+                    uint32 petType = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_PET_TYPE, petType);
+                    break;
+                }
+                case BOT_CLASS_WARLOCK:
+                {
+                    uint32 petType = action - GOSSIP_ACTION_INFO_DEF;
+                    SetAIMiscValue(BOTAI_MISC_PET_TYPE, petType);
+                    break;
+                }
+            }
+            return OnGossipHello(player, 0);
+        }
+        case GOSSIP_SENDER_MODEL_UPDATE:
+        {
+            if (Aura* trans = me->AddAura(MODEL_TRANSITION, me))
+            {
+                me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + BOT_SLOT_OFFHAND, 0); //debug: remove offhand visuals
+                trans->SetDuration(500);
+                trans->SetMaxDuration(500);
+            }
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_SHOW_INVENTORY), GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //auto-equip
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_AUTOEQUIP) + "...", GOSSIP_SENDER_EQUIP_AUTOEQUIP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_MH) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_MAINHAND));
+            if (_canUseOffHand())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_OH) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_OFFHAND));
+            if (_canUseRanged())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_RH) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_RANGED));
+            if (_canUseRelic())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_RELIC) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_RANGED));
+
+            //armor
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_HEAD) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_HEAD));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_SHOULDERS) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_SHOULDERS));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_CHEST) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_CHEST));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_WAIST) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_WAIST));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_LEGS) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_LEGS));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_FEET) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_FEET));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_WRIST) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_WRIST));
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_HANDS) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_HANDS));
+
+            if (IsHumanoidClass(_botclass))
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_BACK) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_BACK));
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_SHIRT) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_BODY));
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_FINGER1) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_FINGER1));
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_FINGER2) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_FINGER2));
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_TRINKET1) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_TRINKET1));
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_TRINKET2) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_TRINKET2));
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_SLOT_NECK) + "...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + uint32(BOT_SLOT_NECK));
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UNEQUIP_ALL), GOSSIP_SENDER_UNEQUIP_ALL, GOSSIP_ACTION_INFO_DEF + 1);
+            if (creature->GetCreatureTemplate()->unit_flags2 & UNIT_FLAG2_MIRROR_IMAGE)
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UPDATE_VISUAL), GOSSIP_SENDER_MODEL_UPDATE, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo, "Trying to send equipment list for bot with no equip info!");
+
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                Item const* item = _equips[i];
+                if (!item) continue;
+                std::ostringstream msg;
+                _AddItemLink(player, item, msg/*, false*/);
+                //uncomment if needed
+                //msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                if (i <= BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+                    msg << " |cffe6cc80|h[!" << LocalizedNpcText(player, BOT_TEXT_VISUALONLY) << "!]|h|r";
+                BotWhisper(msg.str(), player);
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_BODY:      //12 - 1 body
+        {
+            uint8 slot = sender - GOSSIP_SENDER_EQUIP_TRANSMOGRIFY;
+            uint32 itemId = action;
+
+            Item const* item = _equips[slot];
+            ASSERT(item);
+
+            BotDataMgr::UpdateNpcBotTransmogData(me->GetEntry(), slot, item->GetEntry(), itemId);
+
+            if (slot <= BOT_SLOT_RANGED)
+                me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, itemId ? itemId : item->GetEntry());
+
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        case GOSSIP_SENDER_EQUIP_TRANSMOG_INFO:
+        {
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+
+            NpcBotTransmogData const* tramsmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+            ASSERT(tramsmogData);
+            ASSERT(tramsmogData->transmogs[slot].second);
+
+            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(tramsmogData->transmogs[slot].second);
+            if (proto)
+            {
+                std::ostringstream msg;
+                _AddItemTemplateLink(player, proto, msg);
+
+                BotWhisper(msg.str(), player);
+            }
+
+            //break; //no break here - return to menu
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_EQUIP_TRANSMOGS:
+        {
+            subMenu = true;
+
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+            Item const* item = _equips[slot];
+            ASSERT(item);
+
+            std::set<uint32> itemList, idsList;
+
+            //s5.1: build list
+            //s5.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    if (IsValidTransmog(slot, pItem->GetTemplate()) && idsList.find(pItem->GetEntry()) == idsList.end())
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s5.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            if (IsValidTransmog(slot, pItem->GetTemplate()) && idsList.find(pItem->GetEntry()) == idsList.end())
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //s5.1.3: inventory
+            for (uint8 i = EQUIPMENT_SLOT_START; i != EQUIPMENT_SLOT_END; ++i)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    if (IsValidTransmog(slot, pItem->GetTemplate()) && idsList.find(pItem->GetEntry()) == idsList.end())
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s5.2: add gossips
+            NpcBotTransmogData const* tramsmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+            if (tramsmogData && tramsmogData->transmogs[slot].first)
+            {
+                if (tramsmogData->transmogs[slot].second)
+                {
+                    //s5.2.1.1: current
+                    std::ostringstream msg;
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(tramsmogData->transmogs[slot].second))
+                        _AddItemTemplateLink(player, proto, msg);
+                    else
+                        msg << '<' << LocalizedNpcText(player, BOT_TEXT_UNKNOWN) << "(" << tramsmogData->transmogs[slot].second << ")>";
+
+                    AddGossipItemFor(player, GOSSIP_ICON_BATTLE, msg.str(), GOSSIP_SENDER_EQUIP_TRANSMOG_INFO, GOSSIP_ACTION_INFO_DEF + slot);
+
+                    //s5.2.1.2a: reset
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NONE2), GOSSIP_SENDER_EQUIP_TRANSMOGRIFY + slot, 0);
+                }
+                else
+                {
+                    //s5.2.1.2b: None
+                    AddGossipItemFor(player, GOSSIP_ICON_BATTLE, LocalizedNpcText(player, BOT_TEXT_NONE2), GOSSIP_SENDER_EQUIP_TRANSMOGS, action);
+                }
+            }
+
+            if (!itemList.empty())
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 3; //current, reset, back
+                Item const* item;
+                //s5.2.2: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str(), GOSSIP_SENDER_EQUIP_TRANSMOGRIFY + slot, item->GetEntry());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = EQUIPMENT_SLOT_START; i != EQUIPMENT_SLOT_END; ++i)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str(), GOSSIP_SENDER_EQUIP_TRANSMOGRIFY + slot, item->GetEntry());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str(), GOSSIP_SENDER_EQUIP_TRANSMOGRIFY + slot, item->GetEntry());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo, "Trying to send equipment info for bot with no equip info!");
+
+            uint8 slot = action - GOSSIP_ACTION_INFO_DEF;
+            Item const* item = _equips[slot];
+            ASSERT(item);
+
+            std::ostringstream msg;
+            _AddItemLink(player, item, msg, false);
+
+            if (slot <= BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                msg << " |cffe6cc80|h[!" << LocalizedNpcText(player, BOT_TEXT_VISUALONLY) << "!]|h|r";
+
+            BotWhisper(msg.str(), player);
+
+            //break; //no break here - return to menu
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo, "Trying to send equipment show for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+                    if (_canEquip(pItem, action - GOSSIP_ACTION_INFO_DEF, true) &&
+                        /*itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                        (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+                            if (_canEquip(pItem, action - GOSSIP_ACTION_INFO_DEF, true) &&
+                                /*itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                                (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 const slot = action - GOSSIP_ACTION_INFO_DEF;
+            std::ostringstream str;
+            str << LocalizedNpcText(player, BOT_TEXT_EQUIPPED) << ": ";
+            if (Item const* item = _equips[slot])
+            {
+                bool visual_only = slot <= BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry();
+
+                _AddItemLink(player, item, str);
+                if (visual_only)
+                    str << " |cffe6cc80|h[!" << LocalizedNpcText(player, BOT_TEXT_VISUALONLY) << "!]|h|r";
+
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+
+                if (!visual_only && BotMgr::DisplayEquipment() && BotMgr::IsTransmogEnabled() && slot < BOT_TRANSMOG_INVENTORY_SIZE && CanDisplayNonWeaponEquipmentChanges())
+                    AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_TRANSMOGRIFICATION), GOSSIP_SENDER_EQUIP_TRANSMOGS, action);
+            }
+            else
+            {
+                str << LocalizedNpcText(player, BOT_TEXT_NOTHING);
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            if (_equips[slot])
+            {
+                //s2.2.1 add unequip option if have weapon (GMs only)
+                if (slot <= BOT_SLOT_RANGED)
+                {
+                    if (einfo->ItemEntry[slot] != 0)
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_USE_OLD_EQUIPMENT), GOSSIP_SENDER_EQUIP_RESET, action);
+                    else
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UNEQUIP), GOSSIP_SENDER_UNEQUIP, action);
+                }
+
+                //s2.2.2 add unequip option for non-weapons
+                if (slot > BOT_SLOT_RANGED)
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UNEQUIP), GOSSIP_SENDER_UNEQUIP, action);
+            }
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NOTHING_TO_GIVE), 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 5; //unequip, reset, current, transmog, back
+                Item const* item;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            if (BotMgr::SendEquipListItems())
+                                BotWhisper(name.str(), player);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + slot, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    if (BotMgr::SendEquipListItems())
+                                        BotWhisper(name.str(), player);
+                                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + slot, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip DEPRECATED
+        {
+            if (!_unequip(action - GOSSIP_ACTION_INFO_DEF, player->GetGUID()))
+            {} //BotWhisper("Impossible...", player);
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        case GOSSIP_SENDER_UNEQUIP_ALL:
+        {
+            bool suc = true;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i, player->GetGUID()) : _unequip(i, player->GetGUID())))
+                {
+                    suc = false;
+                    //std::ostringstream estr;
+                    //estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i) << ")!";
+                    //BotWhisper(estr.str().c_str(), player);
+                }
+            }
+
+            if (suc)
+                me->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+
+            break;
+        }
+        //autoequips change s5b: AtoEquip item
+        //base is GOSSIP_SENDER_EQUIP_AUTOEQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY:      //12 - 1 body
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1:   //13 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2:   //14 - 2 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1:  //15 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2:  //16 - 2 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK:      //17 - 1 neck
+        {
+            Item* item = nullptr;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUID().GetCounter() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                {
+                    if (Bag const* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUID().GetCounter() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP, item, player->GetGUID())){}
+
+            //break; //no break: update list
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP:
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo, "Trying to send auto-equip for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //1: build list
+            //1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                if (Item const* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    bool canEquip = false;
+
+                    for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+                    {
+                        if (_canEquip(pItem, k))
+                        {
+                            canEquip = true;
+                            break;
+                        }
+                    }
+
+                    if (canEquip &&/* itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                        (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                    {
+                        if (Item const* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+
+                            bool canEquip = false;
+
+                            for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(pItem, k))
+                                {
+                                    canEquip = true;
+                                    break;
+                                }
+                            }
+
+                            if (canEquip &&/* itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() &&*/
+                                (pItem->GetItemRandomPropertyId() == 0 ? idsList.find(pItem->GetEntry()) == idsList.end() : true))
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //2: add gossips
+
+            if (itemList.empty())
+            {
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NOTHING_TO_GIVE), 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 1; // back
+                Item const* item;
+                //add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            uint8 k = 0;
+                            for (; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(item, k))
+                                {
+                                    //workaround for double slots
+                                    //if first slot is occupied and second slot is vacant use second slot
+                                    if (k == BOT_SLOT_FINGER1 || k == BOT_SLOT_TRINKET1)
+                                        if (_equips[k] != nullptr && _canEquip(item, k + 1))
+                                            ++k;
+                                    break;
+                                }
+                            }
+
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            if (BotMgr::SendEquipListItems())
+                                BotWhisper(name.str(), player);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    uint8 k = 0;
+                                    for (; k != BOT_INVENTORY_SIZE; ++k)
+                                    {
+                                        if (_canEquip(item, k))
+                                        {
+                                            //workaround for double slots
+                                            //if first slot is occupied and second slot is vacant use second slot
+                                            if (k == BOT_SLOT_FINGER1 || k == BOT_SLOT_TRINKET1)
+                                                if (_equips[k] != nullptr && _canEquip(item, k + 1))
+                                                    ++k;
+                                            break;
+                                        }
+                                    }
+
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    if (BotMgr::SendEquipListItems())
+                                        BotWhisper(name.str(), player);
+                                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (_resetEquipment(action - GOSSIP_ACTION_INFO_DEF, player->GetGUID())){}
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        //equips change s4b: Equip item
+        //base is GOSSIP_SENDER_EQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_MHAND:     //0 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //1 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //2 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //3 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //4 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //5 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //6 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //7 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //8 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //9 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //10 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //11 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //12 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //13 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //15 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //17 - 1 neck
+        {
+            Item* item = nullptr;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUID().GetCounter() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                {
+                    if (Bag const* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUID().GetCounter() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP, item, player->GetGUID())){}
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+        }
+        case GOSSIP_SENDER_ROLES_MAIN_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            [[fallthrough]];
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_MAIN: //ROLES 1: list
+        {
+            subMenu = true;
+
+            if (IsHumanoidClass(_botclass))
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_GATHERING) + "...", GOSSIP_SENDER_ROLES_GATHERING, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_LOOTING) + "...", GOSSIP_SENDER_ROLES_LOOTING, GOSSIP_ACTION_INFO_DEF + 2);
+
+            uint32 role = BOT_ROLE_TANK;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & BOT_ROLE_MASK_MAIN)) //hidden
+                    continue;
+                if (role == BOT_ROLE_HEAL && !IsHealingClass(_botclass))
+                    continue;
+
+                AddGossipItemFor(player, GetRoleIcon(role), LocalizedNpcText(player, GetRoleString(role)), GOSSIP_SENDER_ROLES_MAIN_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_GATHERING_TOGGLE:
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            [[fallthrough]];
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_GATHERING:
+        {
+            subMenu = true;
+
+            uint32 role = BOT_ROLE_GATHERING_MINING;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & BOT_ROLE_MASK_GATHERING)) //hidden
+                    continue;
+
+                AddGossipItemFor(player, GetRoleIcon(role), LocalizedNpcText(player, GetRoleString(role)), GOSSIP_SENDER_ROLES_GATHERING_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_LOOTING_TOGGLE:
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            [[fallthrough]];
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES_LOOTING:
+        {
+            subMenu = true;
+
+            uint32 role = BOT_ROLE_AUTOLOOT;
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (!(role & (BOT_ROLE_AUTOLOOT | BOT_ROLE_MASK_LOOTING)))
+                    continue;
+
+                AddGossipItemFor(player, GetRoleIcon(role), LocalizedNpcText(player, GetRoleString(role)), GOSSIP_SENDER_ROLES_LOOTING_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_ROLES_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+                //if (CheckBotCast(me, basespell, me->GetBotClass()) == SPELL_CAST_OK)
+                    if (IsSpellReady(basespell, lastdiff, true))
+                        doCast(player, GetSpell(basespell));
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF;
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            if (HasAbilitiesSpecifics())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ABILITIES_STATUS) + "...", GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ALLOWED_ABILITIES) + "...", GOSSIP_SENDER_ABILITIES_USAGE_LIST, GOSSIP_ACTION_INFO_DEF + 2);
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = itr->first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, lastdiff, false)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                name << LocalizedNpcText(player, BOT_TEXT_USE_);
+                _AddSpellLink(player, spellInfo, name);
+                AddGossipItemFor(player, GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UPDATE), sender, action);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST:
+        {
+            subMenu = true;
+
+            std::list<std::string> specList;
+            FillAbilitiesSpecifics(player, specList);
+            for (std::list<std::string>::const_iterator itr = specList.begin(); itr != specList.end(); ++itr)
+                AddGossipItemFor(player, GOSSIP_ICON_CHAT, *itr, GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_DAMAGE:
+        case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_CC:
+        case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_HEAL:
+        case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_SUPPORT:
+        {
+            NpcBotData* npcBotData = const_cast<NpcBotData*>(BotDataMgr::SelectNpcBotData(me->GetEntry()));
+
+            uint32 basespell = action - GOSSIP_ACTION_INFO_DEF;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                if (itr->first == basespell)
+                {
+                    itr->second->enabled = !itr->second->enabled;
+                    if (itr->second->enabled)
+                        npcBotData->disabled_spells.erase(basespell);
+                    else
+                        npcBotData->disabled_spells.insert(basespell);
+
+                    _saveDisabledSpells = true;
+                    break;
+                }
+            }
+
+            uint32 newSender;
+            switch (sender)
+            {
+                case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_DAMAGE:
+                    newSender = GOSSIP_SENDER_ABILITIES_USAGE_LIST_DAMAGE;  break;
+                case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_CC:
+                    newSender = GOSSIP_SENDER_ABILITIES_USAGE_LIST_CC;      break;
+                case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_HEAL:
+                    newSender = GOSSIP_SENDER_ABILITIES_USAGE_LIST_HEAL;    break;
+                case GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_SUPPORT:
+                    newSender = GOSSIP_SENDER_ABILITIES_USAGE_LIST_SUPPORT; break;
+                default:
+                    ASSERT(false);
+            }
+            sender = newSender;
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST_DAMAGE:
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST_CC:
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST_HEAL:
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST_SUPPORT:
+        {
+            subMenu = true;
+
+            uint32 toggleSender;
+            std::vector<uint32> const* myspells;
+            switch (sender)
+            {
+                case GOSSIP_SENDER_ABILITIES_USAGE_LIST_DAMAGE:
+                    toggleSender = GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_DAMAGE;
+                    myspells = GetDamagingSpellsList();
+                    break;
+                case GOSSIP_SENDER_ABILITIES_USAGE_LIST_CC:
+                    toggleSender = GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_CC;
+                    myspells = GetCCSpellsList();
+                    break;
+                case GOSSIP_SENDER_ABILITIES_USAGE_LIST_HEAL:
+                    toggleSender = GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_HEAL;
+                    myspells = GetHealingSpellsList();
+                    break;
+                case GOSSIP_SENDER_ABILITIES_USAGE_LIST_SUPPORT:
+                    toggleSender = GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_SUPPORT;
+                    myspells = GetSupportSpellsList();
+                    break;
+                default:
+                    ASSERT(false);
+            }
+
+            ASSERT(myspells);
+
+            uint32 counter = 0;
+            SpellInfo const* spellInfo;
+            for (std::vector<uint32>::const_iterator itr = myspells->begin(); itr != myspells->end(); ++itr)
+            {
+                if (!HasSpell(*itr)) //not init'ed (cannot be used)
+                    continue;
+
+                spellInfo = sSpellMgr->GetSpellInfo(*itr); //always valid
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+
+                GossipOptionIcon icon = (GetSpell(*itr) != 0) ? BOT_ICON_ON : BOT_ICON_OFF;
+                AddGossipItemFor(player, icon, name.str().c_str(), toggleSender, GOSSIP_ACTION_INFO_DEF + *itr);
+                if (++counter >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                {
+                    TC_LOG_ERROR("scripts", "bot_ai: gossip abilities list overflow with sender %u for bot class %u!",
+                        sender, uint32(_botclass));
+                    break;
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_ABILITIES_USAGE_LIST, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USAGE_LIST:
+        {
+            subMenu = true;
+
+            if (GetDamagingSpellsList())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_DAMAGE) + "...", GOSSIP_SENDER_ABILITIES_USAGE_LIST_DAMAGE, GOSSIP_ACTION_INFO_DEF + 1);
+            if (GetCCSpellsList())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_CONTROL) + "...", GOSSIP_SENDER_ABILITIES_USAGE_LIST_CC, GOSSIP_ACTION_INFO_DEF + 2);
+            if (GetHealingSpellsList())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_HEAL) + "...", GOSSIP_SENDER_ABILITIES_USAGE_LIST_HEAL, GOSSIP_ACTION_INFO_DEF + 3);
+            if (GetSupportSpellsList())
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_OTHER) + "...", GOSSIP_SENDER_ABILITIES_USAGE_LIST_SUPPORT, GOSSIP_ACTION_INFO_DEF + 4);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 5);
+            break;
+        }
+        case GOSSIP_SENDER_SPEC_SET:
+        {
+            uint8 newSpec = action - GOSSIP_ACTION_INFO_DEF;
+
+            if (newSpec != _spec && newSpec >= BOT_SPEC_BEGIN && newSpec <= BOT_SPEC_END)
+            {
+                _newspec = newSpec;
+                me->CastSpell(me, ACTIVATE_SPEC, false);
+                BotWhisper(LocalizedNpcText(player, BOT_TEXT_CHANGING_MY_SPEC_TO_) + LocalizedNpcText(player, TextForSpec(_newspec)));
+                break;
+            }
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_SPEC:
+        {
+            subMenu = true;
+
+            uint8 specIndex;
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:         specIndex = BOT_SPEC_WARRIOR_ARMS;          break;
+                case BOT_CLASS_PALADIN:         specIndex = BOT_SPEC_PALADIN_HOLY;          break;
+                case BOT_CLASS_HUNTER:          specIndex = BOT_SPEC_HUNTER_BEASTMASTERY;   break;
+                case BOT_CLASS_ROGUE:           specIndex = BOT_SPEC_ROGUE_ASSASINATION;    break;
+                case BOT_CLASS_PRIEST:          specIndex = BOT_SPEC_PRIEST_DISCIPLINE;     break;
+                case BOT_CLASS_DEATH_KNIGHT:    specIndex = BOT_SPEC_DK_BLOOD;              break;
+                case BOT_CLASS_SHAMAN:          specIndex = BOT_SPEC_SHAMAN_ELEMENTAL;      break;
+                case BOT_CLASS_MAGE:            specIndex = BOT_SPEC_MAGE_ARCANE;           break;
+                case BOT_CLASS_WARLOCK:         specIndex = BOT_SPEC_WARLOCK_AFFLICTION;    break;
+                case BOT_CLASS_DRUID:           specIndex = BOT_SPEC_DRUID_BALANCE;         break;
+                default:
+                    TC_LOG_ERROR("entities.unit", "bot_ai:GOSSIP_SENDER_SPEC called for class %u with no specs!", uint32(_botclass));
+                    return true;
+            }
+
+            for (uint8 i = specIndex; i < specIndex + 3; ++i)
+            {
+                GossipOptionIcon icon = (_spec == i) ? BOT_ICON_ON : BOT_ICON_OFF;
+                AddGossipItemFor(player, icon, LocalizedNpcText(player, TextForSpec(i)), GOSSIP_SENDER_SPEC_SET, GOSSIP_ACTION_INFO_DEF + i);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_USEITEM_USE:
+        {
+            if (uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF)
+            {
+                Item const* item = nullptr;
+                bool found = false;
+                for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+                {
+                    item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                    if (item && item->GetGUID().GetCounter() == guidLow)
+                    {
+                        found = true;
+                        break;
+                    }
+                }
+
+                if (!found)
+                {
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+                    {
+                        if (Bag const* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); ++j)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == guidLow)
+                                {
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+                }
+
+                if (found)
+                {
+                    ItemTemplate const* proto = item->GetTemplate();
+                    // Learning (483 / 55884)
+                    if (proto->Spells[0].SpellId == 483 || proto->Spells[0].SpellId == 55884)
+                        break;
+
+                    // cast item spell
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(me);
+                    _castBotItemUseSpell(item, targets);
+                }
+            }
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF;
+            [[fallthrough]];
+        }
+        case GOSSIP_SENDER_USEITEM:
+        {
+            subMenu = true;
+
+            uint32 counter = 0;
+            uint32 maxcounter = BOT_GOSSIP_MAX_ITEMS - 2; //update, back
+            Item const* item;
+
+            static const auto is_consumable_item = [](Item const* item, Creature const* bot) {
+                if (ItemTemplate const* proto = item ? item->GetTemplate() : nullptr)
+                {
+                    if (!(proto->Class != ITEM_CLASS_WEAPON && proto->Class != ITEM_CLASS_ARMOR &&
+                        (proto->AllowableClass == 0 || (proto->AllowableClass & (1 << (bot->GetBotClass() - 1)))) &&
+                        proto->RequiredSkill == 0 && proto->RequiredSpell == 0 && bot->GetLevel() >= proto->RequiredLevel))
+                        return false;
+                    bool has_spell = false;
+                    for (auto const& ispell: proto->Spells)
+                    {
+                        if (ispell.SpellId != 0)
+                        {
+                            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(ispell.SpellId))
+                            {
+                                if (spellInfo->IsPassive())
+                                    continue;
+                                bool valid_effect = true;
+                                for (uint8 i = EFFECT_0; i < MAX_SPELL_EFFECTS; ++i)
+                                {
+                                    SpellEffectInfo const& effect = spellInfo->GetEffect(SpellEffIndex(i));
+                                    if (!effect.IsEffect())
+                                        continue;
+                                    if (effect.TargetA.GetTarget() != TARGET_UNIT_CASTER || effect.TargetB.GetTarget() != 0)
+                                        valid_effect = false;
+                                    else
+                                    {
+                                        switch (effect.Effect)
+                                        {
+                                            case SPELL_EFFECT_SUMMON:
+                                            case SPELL_EFFECT_CREATE_ITEM:
+                                                valid_effect = false;
+                                                break;
+                                            default:
+                                                break;
+                                        }
+                                    }
+                                }
+                                if (!valid_effect)
+                                    continue;
+                                has_spell = true;
+                            }
+                        }
+                    }
+                    return has_spell;
+                }
+                return false;
+            };
+
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; ++i)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (is_consumable_item(item, me))
+                {
+                    std::ostringstream name;
+                    _AddItemLink(player, item, name);
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_USEITEM_USE, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                    ++counter; //no need to check max counter here
+                }
+            }
+
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; ++i)
+            {
+                if (Bag const* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize() && counter < maxcounter; ++j)
+                    {
+                        item = player->GetItemByPos(i, j);
+                        if (is_consumable_item(item, me))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            AddGossipItemFor(player, GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_USEITEM_USE, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                        }
+                    }
+                }
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UPDATE), sender, action);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_HIRE:
+        {
+            int32 reason = action - GOSSIP_ACTION_INFO_DEF;
+            if (!reason)
+            {
+                if (_ownerGuid)
+                {
+                    //std::ostringstream ostr;
+                    //std::string name;
+                    //ostr << "Go away. I serve my master ";
+                    //if (sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                    //    ostr << name;
+                    //else
+                    //    ostr << "unknown (" << _ownerGuid << ')';
+                    //BotWhisper(ostr.str().c_str(), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_OWNED).c_str(), me->GetName().c_str());
+                    break;
+                }
+
+                if (_botclass == BOT_CLASS_DEATH_KNIGHT && player->GetLevel() < 55)
+                {
+                    BotWhisper(LocalizedNpcText(player, BOT_TEXT_HIREDENY_DK), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL55).c_str(), me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_SPHYNX && player->GetLevel() < 60)
+                {
+                    me->TextEmote((me->GetName() + LocalizedNpcText(player, BOT_TEXT_HIREDENY_SPHYNX)).c_str());
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL60).c_str(), me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_ARCHMAGE && player->GetLevel() < 20)
+                {
+                    BotWhisper(LocalizedNpcText(player, BOT_TEXT_HIREDENY_ARCHMAGE), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL20).c_str(), me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_DREADLORD && player->GetLevel() < 60)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL60).c_str(), me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_SPELLBREAKER && player->GetLevel() < 20)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL20).c_str(), me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_DARK_RANGER && player->GetLevel() < 40)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL40).c_str(), me->GetName().c_str());
+                    break;
+                }
+                if (_botclass == BOT_CLASS_NECROMANCER && player->GetLevel() < 20)
+                {
+                    //BotWhisper("placeholder", player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_LVL20).c_str(), me->GetName().c_str());
+                    break;
+                }
+
+                if (SetBotOwner(player))
+                {
+                    if (_botclass == BOT_CLASS_SPHYNX)
+                    {
+                        std::string msg1 = me->GetName() + LocalizedNpcText(player, BOT_TEXT_HIRE_EMOTE_SPHYNX) + player->GetName();
+                        me->TextEmote(msg1.c_str());
+                    }
+                    else
+                        BotWhisper(LocalizedNpcText(player, BOT_TEXT_HIRE_SUCCESS), player);
+                }
+                else
+                    BotSay("...", player);
+            }
+            else if (reason == -1)
+            {
+                me->SetFaction(14);
+                if (botPet)
+                    botPet->SetFaction(14);
+                BotYell(LocalizedNpcText(player, BOT_TEXT_DIE), player);
+                me->Attack(player, true);
+                break;
+            }
+            else
+            {
+                ChatHandler ch(player->GetSession());
+                switch (reason)
+                {
+                    case 1: //has owner
+                    {
+                        std::ostringstream ostr;
+                        std::string name;
+                        ostr << LocalizedNpcText(player, BOT_TEXT_HIREDENY_MY_MASTER_IS_);
+                        if (sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                            ostr << name;
+                        else
+                            ostr << LocalizedNpcText(player, BOT_TEXT_UNKNOWN) + " (" << _ownerGuid << ')';
+                        BotWhisper(ostr.str().c_str(), player);
+                        ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_OWNED).c_str(), me->GetName().c_str());
+                        break;
+                    }
+                    case 2: //max npcbots exceed
+                        ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_MAXBOTS).c_str(), BotMgr::GetMaxNpcBots());
+                        BotSay("...", player);
+                        break;
+                    case 3: //not enough money
+                    {
+                        std::string str = LocalizedNpcText(player, BOT_TEXT_HIREFAIL_COST) + " (";
+                        str += BotMgr::GetNpcBotCostStr(player->GetLevel(), _botclass);
+                        str += ")!";
+                        ch.SendSysMessage(str.c_str());
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+                        BotSay("...", player);
+                        break;
+                    }
+                    case 4: //class bots exceed
+                    {
+                        uint8 count = 0;
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                            if (itr->second->GetBotClass() == GetBotClass())
+                                ++count;
+
+                        ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_HIREFAIL_MAXCLASSBOTS).c_str(), count, BotMgr::GetMaxClassBots());
+                        BotSay("...", player);
+                        break;
+                    }
+                    default:
+                        break;
+                }
+            }
+            break;
+        }
+        case GOSSIP_SENDER_DISMISS:
+        {
+            BotMgr* mgr = player->GetBotMgr();
+            ASSERT(mgr);
+
+            //send items to owner -- Unequip all
+            bool abort = false;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i, player->GetGUID()) : _unequip(i, player->GetGUID())))
+                {
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage(LocalizedNpcText(player, BOT_TEXT_CANT_DISMISS_EQUIPMENT).c_str(),
+                        uint32(i), LocalizedNpcText(player, BOT_TEXT_SLOT_MH + i).c_str());
+                    abort = true;
+                    break;
+                }
+            }
+
+            if (abort)
+                break;
+
+            mgr->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+            if (BotMgr::IsEnrageOnDimissEnabled())
+            {
+                if (Aura* bers = me->AddAura(BERSERK, me))
+                {
+                    uint32 dur = 5 * MINUTE * IN_MILLISECONDS;
+                    bers->SetDuration(dur);
+                    bers->SetMaxDuration(dur);
+                }
+            }
+            //if (urand(1,100) <= 25)
+            //{
+            //    me->SetFaction(14);
+            //    if (Creature* pet = GetBotsPet())
+            //        pet->SetFaction(14);
+            //    BotSay("Fool...", player);
+            //    me->Attack(player, true);
+            //}
+            //else
+                BotSay("...", player);
+
+            break;
+        }
+        case GOSSIP_SENDER_JOIN_GROUP:
+        {
+            uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+            switch (option)
+            {
+                case 1: //single bot
+                    player->GetBotMgr()->AddBotToGroup(me);
+                    break;
+                case 2: //all bots
+                {
+                    BotMap const* bmap = player->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator citr = bmap->begin(); citr != bmap->end(); ++citr)
+                    {
+                        if (!citr->second)
+                            continue;
+                        player->GetBotMgr()->AddBotToGroup(citr->second);
+                    }
+                    break;
+                }
+            }
+            break;
+        }
+        case GOSSIP_SENDER_LEAVE_GROUP:
+        {
+            player->GetBotMgr()->RemoveBotFromGroup(me);
+            break;
+        }
+        case GOSSIP_SENDER_HOLDPOSITION:
+        {
+            SetBotCommandState(BOT_COMMAND_STAY);
+            //BotWhisper("Standing still");
+            break;
+        }
+        case GOSSIP_SENDER_DONOTHING:
+        {
+            SetBotCommandState(BOT_COMMAND_FULLSTOP);
+            //BotWhisper("As you wish");
+            break;
+        }
+        case GOSSIP_SENDER_FOLLOWME:
+        {
+            SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+            //BotWhisper("Following");
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION_TOGGLE_COMBAT_POSITIONING:
+        {
+            player->GetBotMgr()->SetBotAllowCombatPositioning(!player->GetBotMgr()->GetBotAllowCombatPositioning());
+
+            //break; //return to menu
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_FORMATION:
+        {
+            subMenu = true;
+            std::ostringstream diststr;
+            diststr << LocalizedNpcText(player, BOT_TEXT_FOLLOW_DISTANCE) << " (" << LocalizedNpcText(player, BOT_TEXT_CURRENT) << ": " << uint32(master->GetBotMgr()->GetBotFollowDist()) << ')';
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, diststr.str(),
+                GOSSIP_SENDER_FORMATION_FOLLOW_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 1, "", 0, true);
+
+            if (HasRole(BOT_ROLE_RANGED))
+            {
+                AddGossipItemFor(player, !player->GetBotMgr()->GetBotAllowCombatPositioning() ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT,
+                    LocalizedNpcText(player, BOT_TEXT_DISABLE_COMBAT_POSITIONING) + "...", GOSSIP_SENDER_FORMATION_TOGGLE_COMBAT_POSITIONING, GOSSIP_ACTION_INFO_DEF + 2);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ATTACK_DISTANCE) + "...", GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE, GOSSIP_ACTION_INFO_DEF + 3);
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ATTACK_ANGLE) + "...", GOSSIP_SENDER_FORMATION_ATTACK_ANGLE, GOSSIP_ACTION_INFO_DEF + 4);
+            }
+
+            if (!HasRole(BOT_ROLE_TANK) && HasRole(BOT_ROLE_DPS | BOT_ROLE_HEAL))
+                AddGossipItemFor(player, GOSSIP_ICON_TALK, LocalizedNpcText(player, BOT_TEXT_ENGAGE_BEHAVIOR) + "...", GOSSIP_SENDER_ENGAGE_BEHAVIOR, GOSSIP_ACTION_INFO_DEF + 5);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 6);
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET:
+        {
+            uint32 choice = action - GOSSIP_ACTION_INFO_DEF;
+            if (choice == 1) //short
+            {
+                player->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_SHORT);
+            }
+            else if (choice == 2) //long
+            {
+                player->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_LONG);
+            }
+
+            //break; //return to menu
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE:
+        {
+            subMenu = true;
+
+            uint8 mode = master->GetBotMgr()->GetBotAttackRangeMode();
+            AddGossipItemFor(player, mode == BOT_ATTACK_RANGE_SHORT ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_SHORT_RANGE_ATTACKS), GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, mode == BOT_ATTACK_RANGE_LONG ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_LONG_RANGE_ATTACKS), GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 2);
+
+            std::ostringstream diststr;
+            if (mode == BOT_ATTACK_RANGE_EXACT)
+                diststr << LocalizedNpcText(player, BOT_TEXT_EXACT) << " (" << LocalizedNpcText(player, BOT_TEXT_CURRENT) << ": " << uint32(master->GetBotMgr()->GetBotExactAttackRange()) << ')';
+            else
+                diststr << LocalizedNpcText(player, BOT_TEXT_EXACT) << " (0-50)";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, mode == BOT_ATTACK_RANGE_EXACT ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT,
+                diststr.str(), GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET, GOSSIP_ACTION_INFO_DEF + 3, "", 0, true);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 4);
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION_ATTACK_ANGLE_SET:
+        {
+            uint32 choice = action - GOSSIP_ACTION_INFO_DEF;
+            if (choice == 1) //normal
+            {
+                player->GetBotMgr()->SetBotAttackAngleMode(BOT_ATTACK_ANGLE_NORMAL);
+            }
+            if (choice == 2) //avoid frontal aoe
+            {
+                player->GetBotMgr()->SetBotAttackAngleMode(BOT_ATTACK_ANGLE_AVOID_FRONTAL_AOE);
+            }
+
+            //break; //return to menu
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_FORMATION_ATTACK_ANGLE:
+        {
+            subMenu = true;
+
+            uint8 mode = master->GetBotMgr()->GetBotAttackAngleMode();
+            AddGossipItemFor(player, mode == BOT_ATTACK_ANGLE_NORMAL ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_NORMAL), GOSSIP_SENDER_FORMATION_ATTACK_ANGLE_SET, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, mode == BOT_ATTACK_ANGLE_AVOID_FRONTAL_AOE ? GOSSIP_ICON_BATTLE : GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_AVOID_FRONTAL_AOE), GOSSIP_SENDER_FORMATION_ATTACK_ANGLE_SET, GOSSIP_ACTION_INFO_DEF + 2);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 3);
+            break;
+        }
+        case GOSSIP_SENDER_ENGAGE_BEHAVIOR:
+        {
+            subMenu = true;
+
+            if (HasRole(BOT_ROLE_DPS))
+            {
+                std::ostringstream delaystr;
+                delaystr.setf(std::ios_base::fixed);
+                delaystr.precision(2);
+                delaystr << LocalizedNpcText(player, BOT_TEXT_DELAY_ATTACK_BY) << ": " << float(player->GetBotMgr()->GetEngageDelayDPS() / 1000.f) << LocalizedNpcText(player, BOT_TEXT_SECOND_SHORT);
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, delaystr.str(),
+                    GOSSIP_SENDER_ENGAGE_DELAY_SET_ATTACK, GOSSIP_ACTION_INFO_DEF + 1, "", 0, true);
+            }
+            if (HasRole(BOT_ROLE_HEAL))
+            {
+                std::ostringstream delaystr;
+                delaystr.setf(std::ios_base::fixed);
+                delaystr.precision(2);
+                delaystr << LocalizedNpcText(player, BOT_TEXT_DELAY_HEALING_BY) << ": " << float(player->GetBotMgr()->GetEngageDelayHeal() / 1000.f) << LocalizedNpcText(player, BOT_TEXT_SECOND_SHORT);
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, delaystr.str(),
+                    GOSSIP_SENDER_ENGAGE_DELAY_SET_HEALING, GOSSIP_ACTION_INFO_DEF + 2, "", 0, true);
+            }
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 3);
+            break;
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING_AURA:
+        {
+            uint32 spellId = action - GOSSIP_ACTION_INFO_DEF;
+            Unit::AuraMap const& auras = me->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+            {
+                if (itr->first != spellId)
+                    continue;
+
+                SpellInfo const* info = itr->second->GetSpellInfo();
+                if (info->IsChanneled())
+                    if (Spell const* curSpell = me->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+                        if (curSpell->m_spellInfo->Id == spellId)
+                            me->InterruptSpell(CURRENT_CHANNELED_SPELL);
+
+                //Debug
+                //std::ostringstream msg;
+                //msg << "Removing ";
+                //_AddSpellLink(player, info, msg);
+                //msg << " by ";
+                //ObjectGuid casterGuid = itr->second->GetCasterGUID();
+                //Unit* caster = casterGuid ? ObjectAccessor::GetUnit(*me, casterGuid) : nullptr;
+                //if (caster)
+                //{
+                //    if (casterGuid == me->GetGUID())
+                //        msg << "me";
+                //    else
+                //        msg << caster->GetName();
+                //}
+                //else
+                //    msg << "Unknown unit";
+                //BotWhisper(msg.str().c_str());
+
+                me->RemoveOwnedAura(spellId, ObjectGuid::Empty, 0, AURA_REMOVE_BY_CANCEL);
+                break;
+            }
+
+            //break;
+            action = GOSSIP_ACTION_INFO_DEF + 2; //return to the list and update
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_TROUBLESHOOTING_FIX:
+        {
+            uint32 option = action - GOSSIP_ACTION_INFO_DEF;
+            switch (option)
+            {
+                //MOVED TO RECEIVEEMOTE
+                //case 1: //Bot is not mounting, not following while player is mounted
+                //{
+                //    //Reason: creature can sometimes retain UNIT_FLAG_X and UNIT_STATE_X
+                //    //rare occasion, even for bots, you can still talk to them so yeah, stange
+                //    if (me->HasUnitState(UNIT_STATE_STUNNED) && !me->HasAuraType(SPELL_AURA_MOD_STUN))
+                //    {
+                //        me->ClearUnitState(UNIT_STATE_STUNNED);
+                //        me->RemoveUnitFlag(UNIT_FLAG_STUNNED);
+                //    }
+                //    if (me->HasUnitState(UNIT_STATE_CONFUSED) && !me->HasAuraType(SPELL_AURA_MOD_CONFUSE))
+                //    {
+                //        me->ClearUnitState(UNIT_STATE_CONFUSED);
+                //        me->RemoveUnitFlag(UNIT_FLAG_CONFUSED);
+                //    }
+                //    break;
+                //}
+                case 2: //Remove a visible buff
+                {
+                    subMenu = true;
+                    uint32 count = 0;
+                    Unit::AuraMap const& auras = me->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        SpellInfo const* info = itr->second->GetSpellInfo();
+                        //spells we cannot remove
+                        //1 passive, negative spells, hidden, locked, shapeshift / mount spells (no hook for that)
+                        if (info->IsPassive() || !info->IsPositive())
+                            continue;
+                        if ((info->Attributes & (SPELL_ATTR0_CANT_CANCEL | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) ||
+                            (info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+                            continue;
+                        if (info->HasAura(SPELL_AURA_MOD_SHAPESHIFT))
+                            continue;
+                        if (info->HasAura(SPELL_AURA_MOUNTED) && player->HasAura(info->Id))
+                            continue;
+                        //2 custom list
+                        //2.1 Leader of the Pack AOE (supposed to be passive)
+                        if (info->Id == 24932)
+                            continue;
+                        //2.2 Tree of Life AOE (supposed to be passive)
+                        if (info->Id == 34123)
+                            continue;
+                        //2.3 Moonkin Aura AOE (supposed to be passive)
+                        if (info->Id == 24907)
+                            continue;
+                        //2.4 Blood Pact AOE (supposed to be passive)
+                        if (info->GetFirstRankSpell()->Id == 6307)
+                            continue;
+                        //2.5 Fel Intelligence AOE (supposed to be passive)
+                        if (info->GetFirstRankSpell()->Id == 54424)
+                            continue;
+
+                        std::ostringstream msg;
+                        _AddSpellLink(player, info, msg);
+                        AddGossipItemFor(player, GOSSIP_ICON_CHAT, msg.str().c_str(), GOSSIP_SENDER_TROUBLESHOOTING_AURA, GOSSIP_ACTION_INFO_DEF + itr->first);
+
+                        if (++count >= BOT_GOSSIP_MAX_ITEMS - 2) //update, back
+                            break;
+                    }
+
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_UPDATE), sender, action);
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+                    break;
+                }
+                case 3: //Fix Powers
+                {
+                    InitPowers();
+                    break;
+                }
+                default:
+                    //BotWhisper("Unknown action in GOSSIP_SENDER_TROUBLESHOOTING_FIX", player);
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_TROUBLESHOOTING:
+        {
+            subMenu = true;
+            //AddGossipItemFor(player, GOSSIP_ICON_CHAT, "Fix not mounting/following", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_REMOVE_BUFF) + "...", GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 2);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_FIX_POWER), GOSSIP_SENDER_TROUBLESHOOTING_FIX, GOSSIP_ACTION_INFO_DEF + 3);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 4);
+            break;
+        }
+        case GOSSIP_SENDER_DEBUG_ACTION:
+        {
+            //!!! player != owner !!!
+            //DEBUG ACTIONS ARE NOT LOCALIZED
+            bool close = true;
+            switch (action - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 1: //reset owner
+                    if (!IAmFree())
+                        master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+                    else
+                    {
+                        uint32 newOwner = 0;
+                        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+                        ResetBotAI(BOTAI_RESET_DISMISS);
+                    }
+                    break;
+                case 2: //reset stats
+                    spawned = false;
+                    DefaultInit();
+                    break;
+                case 3: //list stats
+                    close = false;
+                    ReceiveEmote(player, TEXT_EMOTE_BONK);
+                    break;
+                case 4: //list roles
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Roles:", me->GetName().c_str());
+                    for (uint32 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+                    {
+                        if (_roleMask & i)
+                        {
+                            switch (i)
+                            {
+                                case BOT_ROLE_TANK:
+                                    ch.SendSysMessage("BOT_ROLE_TANK");
+                                    break;
+                                case BOT_ROLE_TANK_OFF:
+                                    ch.SendSysMessage("BOT_ROLE_TANK_OFF");
+                                    break;
+                                case BOT_ROLE_DPS:
+                                    ch.SendSysMessage("BOT_ROLE_DPS");
+                                    break;
+                                case BOT_ROLE_HEAL:
+                                    ch.SendSysMessage("BOT_ROLE_HEAL");
+                                    break;
+                                //case BOT_ROLE_MELEE:
+                                //    ch.SendSysMessage("BOT_ROLE_MELEE");
+                                //    break;
+                                case BOT_ROLE_RANGED:
+                                    ch.SendSysMessage("BOT_ROLE_RANGED");
+                                    break;
+                                case BOT_ROLE_PARTY:
+                                    ch.SendSysMessage("BOT_ROLE_PARTY");
+                                    break;
+                                default:
+                                    ch.PSendSysMessage("BOT_ROLE_%u",i);
+                                    break;
+                            }
+                        }
+                    }
+                    break;
+                }
+                case 5: //list spells
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Spells:", me->GetName().c_str());
+                    uint32 counter = 0;
+                    SpellInfo const* spellInfo;
+                    BotSpellMap const& myspells = GetSpellMap();
+                    for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                    {
+                        //if (itr->second->spellId == 0)
+                        //    continue;
+
+                        ++counter;
+                        std::ostringstream sstr;
+                        spellInfo = sSpellMgr->GetSpellInfo(itr->first); //always valid
+                        _AddSpellLink(player, spellInfo, sstr);
+                        sstr << " id: " <<  itr->second->spellId << ", base: " << itr->first
+                            << ", cd: " << itr->second->cooldown << ", base: " << std::max<uint32>(spellInfo->RecoveryTime, spellInfo->CategoryRecoveryTime);
+                        if (itr->second->enabled == false)
+                            sstr << " (disabled)";
+                        ch.PSendSysMessage("%u) %s", counter, sstr.str().c_str());
+                    }
+                    break;
+                }
+                case 6: //reload config
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+
+                    TC_LOG_INFO("misc", "Re-Loading config settings...");
+                    sWorld->LoadConfigSettings(true);
+                    sMapMgr->InitializeVisibilityDistanceInfo();
+                    ch.SendGlobalGMSysMessage("World config settings reloaded.");
+                    BotMgr::ReloadConfig();
+                    ch.SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+
+                    break;
+                }
+                default:
+                    close = false;
+                    break;
+            }
+
+            if (close)
+                break;
+        }
+        [[fallthrough]];
+        case GOSSIP_SENDER_DEBUG:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            std::ostringstream ostr;
+            std::string name;
+            ostr << "Bot: " << me->GetName()
+                << " (Id: " << me->GetEntry()
+                << ", guidlow: " << me->GetGUID().GetCounter()
+                << ", spec: " << uint32(_spec) << '(' << LocalizedNpcText(player, TextForSpec(_spec)) << ')'
+                << ", faction: " << me->GetFaction()
+                << "). owner: ";
+            if (_ownerGuid && sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                ostr << name << " (" << _ownerGuid << ')';
+            else
+                ostr << "none";
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, ostr.str().c_str(), GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 0);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Reset Owner>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 1);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Reset Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 2);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<List Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 3);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<List Roles>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 4);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<List Spells>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 5);
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, "<Reload Config>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 6);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+            break;
+        }
+        case GOSSIP_SENDER_SCAN:
+        {
+            subMenu = true;
+
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    gossipTextId = GOSSIP_CLASSDESC_BM;
+                    break;
+                case BOT_CLASS_SPHYNX:
+                    gossipTextId = GOSSIP_CLASSDESC_SPHYNX;
+                    break;
+                case BOT_CLASS_ARCHMAGE:
+                    gossipTextId = GOSSIP_CLASSDESC_ARCHMAGE;
+                    break;
+                case BOT_CLASS_DREADLORD:
+                    gossipTextId = GOSSIP_CLASSDESC_DREADLORD;
+                    break;
+                case BOT_CLASS_SPELLBREAKER:
+                    gossipTextId = GOSSIP_CLASSDESC_SPELLBREAKER;
+                    break;
+                case BOT_CLASS_DARK_RANGER:
+                    gossipTextId = GOSSIP_CLASSDESC_DARKRANGER;
+                    break;
+                case BOT_CLASS_NECROMANCER:
+                    gossipTextId = GOSSIP_CLASSDESC_NECROMANCER;
+                    break;
+                case BOT_CLASS_SEA_WITCH:
+                    gossipTextId = GOSSIP_CLASSDESC_SEAWITCH;
+                    break;
+                default:
+                    break;
+            }
+
+            //AddGossipItemFor(player, GOSSIP_ICON_CHAT, LocalizedNpcText(player, BOT_TEXT_BACK), 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->PlayerTalkClass->SendCloseGossip();
+
+    return true;
+}
+
+//GossipSelectCode
+bool bot_ai::OnGossipSelectCode(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action, char const* code)
+{
+    if (!*code)
+        return true;
+
+    if (!BotMgr::IsNpcBotModEnabled() || me->HasUnitState(UNIT_STATE_CASTING) || CCed(me) || IsDuringTeleport() ||
+        HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) ||
+        (me->GetVehicle() && me->GetVehicle()->GetBase()->IsInCombat()))
+    {
+        player->PlayerTalkClass->SendCloseGossip();
+        return true;
+    }
+
+    uint32 gossipTextId;
+    if (player->GetGUID().GetCounter() == _ownerGuid || !IAmFree())
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_DARKRANGER;
+        else if (_botclass == BOT_CLASS_SEA_WITCH)
+            gossipTextId = GOSSIP_NORMAL_CUSTOM_SEAWITCH;
+        else
+            gossipTextId = GOSSIP_NORMAL_SERVE_MASTER;
+    }
+    else
+    {
+        if (_botclass == BOT_CLASS_SPHYNX)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SPHYNX;
+        else if (_botclass == BOT_CLASS_DREADLORD)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DREADLORD;
+        else if (_botclass == BOT_CLASS_DARK_RANGER)
+            gossipTextId = GOSSIP_GREET_CUSTOM_DARKRANGER;
+        else if (_botclass == BOT_CLASS_SEA_WITCH)
+            gossipTextId = GOSSIP_GREET_CUSTOM_SEAWITCH;
+        else
+            gossipTextId = GOSSIP_GREET_NEED_SMTH;
+    }
+
+    player->PlayerTalkClass->ClearMenus();
+
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case GOSSIP_SENDER_FORMATION_FOLLOW_DISTANCE_SET:
+        {
+            char* dist = strtok((char*)code, "");
+            uint8 distance = (uint8)std::min<int32>(std::max<int32>(atoi(dist), 0), 100);
+
+            player->GetBotMgr()->SetBotFollowDist(distance);
+
+            player->PlayerTalkClass->SendCloseGossip();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION, action);
+        }
+        case GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET:
+        {
+            uint32 choice = action - GOSSIP_ACTION_INFO_DEF;
+            if (choice == 3) //exact
+            {
+                char* dist = strtok((char*)code, "");
+                uint8 distance = (uint8)std::min<int32>(std::max<int32>(atoi(dist), 0), 50);
+
+                player->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_EXACT, distance);
+            }
+
+            player->PlayerTalkClass->SendCloseGossip();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE, action);
+        }
+        case GOSSIP_SENDER_ENGAGE_DELAY_SET_ATTACK:
+        {
+            char* dist = strtok((char*)code, "");
+            float delay = std::min<float>(std::max<float>(atof(dist), 0.f), 10.f);
+
+            player->GetBotMgr()->SetEngageDelayDPS(uint32(delay * 1000));
+
+            player->PlayerTalkClass->SendCloseGossip();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_ENGAGE_BEHAVIOR, action);
+        }
+        case GOSSIP_SENDER_ENGAGE_DELAY_SET_HEALING:
+        {
+            char* dist = strtok((char*)code, "");
+            float delay = std::min<float>(std::max<float>(atof(dist), 0.f), 10.f);
+
+            player->GetBotMgr()->SetEngageDelayHeal(uint32(delay * 1000));
+
+            player->PlayerTalkClass->SendCloseGossip();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_ENGAGE_BEHAVIOR, action);
+        }
+        default:
+            break;
+    }
+
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->PlayerTalkClass->SendCloseGossip();
+
+    return true;
+}
+//PvP trinket for minions
+void bot_ai::BreakCC(uint32 diff)
+{
+    if (_botclass < BOT_CLASS_EX_START && me->GetLevel() >= 60 && IsSpellReady(PVPTRINKET, diff, false) &&
+        CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()) && Rand() < 20)
+    {
+        if (doCast(me, PVPTRINKET))
+            return;
+    }
+
+    uint8 myrace = me->GetRace();
+
+    //Racial 6) Every Man for Himself
+    if (myrace == RACE_HUMAN && IsSpellReady(RACIAL_EVERY_MAN_FOR_HIMSELF, diff, false) && CCed(me, true) &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && Rand() < 40 && !IsCasting() &&
+        (me->GetLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)))
+    {
+        if (doCast(me, RACIAL_EVERY_MAN_FOR_HIMSELF))
+            return;
+    }
+    //Racial 5) Forsaken (Will of the Forsaken)
+    if (myrace == RACE_UNDEAD_PLAYER && IsSpellReady(RACIAL_WILL_OF_THE_FORSAKEN, diff, false) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && CCed(me) &&
+        Rand() < 10 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting() &&
+        (me->GetLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)) &&
+        me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+    {
+        if (doCast(me, RACIAL_WILL_OF_THE_FORSAKEN))
+            return;
+    }
+    //Racial 7) Escape Artist
+    if (me->GetRace() == RACE_GNOME && IsSpellReady(RACIAL_ESCAPE_ARTIST, diff, false) && CCed(me, true) &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+        (me->IsInCombat() || !me->getAttackers().empty()) && Rand() < 40 && !IsCasting() &&
+        (me->GetLevel() < 60 || !IsSpellReady(PVPTRINKET, diff, false)) &&
+        me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+    {
+        if (doCast(me, RACIAL_ESCAPE_ARTIST))
+            return;
+    }
+}
+//Racial abilities
+void bot_ai::CheckRacials(uint32 diff)
+{
+    //At this point checked CCed and pots
+    uint8 myrace = me->GetRace();
+    //Racial 1) Tauren (War Stomp)
+    if (myrace == RACE_TAUREN && IsSpellReady(RACIAL_WARSTOMP, diff, false) &&
+        (!IsTank() || me->GetShapeshiftForm() == FORM_NONE) &&
+        Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        Unit const* u = me->SelectNearestTarget(7);
+        if (u && u->IsInCombat() && !CCed(u) && u->isTargetableForAttack(false) && IsInBotParty(u->GetVictim()) && me->IsWithinLOSInMap(u))
+        {
+            if (doCast(me, RACIAL_WARSTOMP))
+                return;
+        }
+    }
+    //Racial 2) Orc (Blood Fury)
+    if (myrace == RACE_ORC)
+    {
+        uint32 bloodFury = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(bloodFury, diff, false) && me->GetVictim() && GetHealthPCT(me) > 35 && !CCed(me, true) &&
+            (me->GetVictim()->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1) &&
+            Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+        {
+            if (doCast(me, bloodFury))
+                return;
+        }
+    }
+    //Racial 3) Dwarf (Stoneform)
+    if (myrace == RACE_DWARF && IsSpellReady(RACIAL_STONEFORM, diff, false) && GetHealthPCT(me) < 80 &&
+        Rand() < 10 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        //Unholy Blight prevents diseases from being dispelled
+        uint32 const dispelMask = me->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0) ?
+            (1<<DISPEL_POISON) : (1<<DISPEL_DISEASE)|(1<<DISPEL_POISON);
+        uint8 count = 0;
+        Unit::AuraMap const& auras = me->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            Aura const* aura = itr->second;
+
+            if (aura->IsPassive())
+                continue;
+
+            AuraApplication const* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+            if (!aurApp)
+                continue;
+            if (aurApp->IsPositive())
+                continue;
+
+            if ((aura->GetSpellInfo()->GetDispelMask() & dispelMask) ||
+                aura->GetSpellInfo()->Mechanic == MECHANIC_BLEED)
+                if (++count > 1)
+                    break;
+        }
+
+        if (count > 1 - 1*(me->IsInCombat()) && doCast(me, RACIAL_STONEFORM))
+            return;
+    }
+    //Racial 4) Night Elf (Shadowmeld)
+    if (myrace == RACE_NIGHTELF && IsSpellReady(RACIAL_SHADOWMELD, diff, false) && !me->IsInCombat() && me->GetVictim() &&
+        me->GetVictim()->GetTypeId() == TYPEID_PLAYER && Rand() < 50 &&
+        !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        if (Spell const* spell = me->GetVictim()->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+        {
+            if (spell->m_targets.GetUnitTarget() == me && spell->GetTimer() < 500 &&
+                spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                if (doCast(me, RACIAL_SHADOWMELD))
+                    return;
+        }
+    }
+    //Racial 8) Troll (Berserking)
+    if (myrace == RACE_TROLL && IsSpellReady(RACIAL_BERSERKING, diff, false) && me->GetVictim() &&
+        GetHealthPCT(me) > 35 && !CCed(me, true) &&
+        (me->GetVictim()->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1) &&
+        Rand() < 20 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !IsCasting())
+    {
+        if (doCast(me, RACIAL_BERSERKING))
+            return;
+    }
+    //Racial 9) Blood Elf (Arcane Torrent)
+    if (myrace == RACE_BLOODELF)
+    {
+        uint32 arcaneTorrent = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(arcaneTorrent, diff, false) && !IsCasting() && !Feasting())
+        {
+            Unit const* victim = me->GetVictim();
+            if (victim && victim->IsNonMeleeSpellCast(false, false, true) &&
+                (me->GetVictim()->GetHealth() > me->GetHealth() / 4 || me->getAttackers().size() > 1) &&
+                me->GetDistance(victim) < 7 && Rand() < 30 && !me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            {
+                if (Spell const* spell = victim->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (IsInBotParty(spell->m_targets.GetUnitTarget()) && spell->GetTimer() < 1000)
+                        if (doCast(me, arcaneTorrent))
+                            return;
+                }
+            }
+            else if (GetManaPCT(me) < 25)
+                if (doCast(me, arcaneTorrent))
+                    return;
+        }
+    }
+    //Racial 10) Draenei (Gift of The Naaru) - self only
+    if (myrace == RACE_DRAENEI)
+    {
+        uint32 giftOfNaaru = RaceSpellForClass(myrace, _botclass);
+        if (IsSpellReady(giftOfNaaru, diff, false) && (me->IsInCombat() || !me->getAttackers().empty()) &&
+            GetHealthPCT(me) < 60 - 10*me->HasAuraType(SPELL_AURA_PERIODIC_HEAL) &&
+            Rand() < 50 && !IsCasting())
+        {
+            if (doCast(me, giftOfNaaru))
+                return;
+        }
+    }
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return;
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+    else if (!IsMelee() && (opponent || disttarget))
+        return;
+    //if (InDuel(attacker))
+    //    return;
+
+    bool byspell = false;
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            byspell = GetBotStance() == BOT_STANCE_NONE || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+            byspell = true;
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "minion_ai: OnOwnerDamagedBy() - unknown bot class %u", uint8(_botclass));
+            break;
+    }
+
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    SetBotCommandState(BOT_COMMAND_COMBATRESET); //reset AttackStart()
+    me->Attack(attacker, !HasRole(BOT_ROLE_RANGED));
+}
+//force vehicle targeting and attack if vehicle is damaged
+void bot_ai::OnOwnerVehicleDamagedBy(Unit* attacker)
+{
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return;
+
+    Creature* veh = me->GetVehicleCreatureBase();
+    if (!veh || (veh->GetTarget() && HasBotCommandState(BOT_COMMAND_ATTACK)) || !veh->IsValidAttackTarget(attacker))
+        return;
+
+    veh->SetTarget(attacker->GetGUID());
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    me->GetVehicleBase()->Attack(attacker, false);
+}
+//////////
+///LOOT///
+//////////
+uint32 bot_ai::_getLootQualityMask() const
+{
+    uint32 lootRoleMask = (_roleMask & BOT_ROLE_MASK_LOOTING);
+    uint32 lootMask = 0;
+
+    if (lootRoleMask & BOT_ROLE_AUTOLOOT_POOR)
+        lootMask |= (1 << ITEM_QUALITY_POOR);
+    if (lootRoleMask & BOT_ROLE_AUTOLOOT_COMMON)
+        lootMask |= (1 << ITEM_QUALITY_NORMAL);
+    if (lootRoleMask & BOT_ROLE_AUTOLOOT_UNCOMMON)
+        lootMask |= (1 << ITEM_QUALITY_UNCOMMON);
+    if (lootRoleMask & BOT_ROLE_AUTOLOOT_RARE)
+        lootMask |= (1 << ITEM_QUALITY_RARE);
+    if (lootRoleMask & BOT_ROLE_AUTOLOOT_EPIC)
+        lootMask |= (1 << ITEM_QUALITY_EPIC);
+    if (lootRoleMask & BOT_ROLE_AUTOLOOT_LEGENDARY)
+        lootMask |= (1 << ITEM_QUALITY_LEGENDARY);
+
+    return lootMask;
+}
+uint32 bot_ai::_getLootQualityThreshold() const
+{
+    uint32 lootThreshold;
+    Group const* gr = master->GetGroup();
+    if (!gr)
+        lootThreshold = uint32(MAX_ITEM_QUALITY);
+    else
+    {
+        switch (gr->GetLootMethod())
+        {
+            case GROUP_LOOT: case NEED_BEFORE_GREED: case MASTER_LOOT:
+                lootThreshold = uint32(gr->GetLootThreshold()); break;
+            default:
+                lootThreshold = uint32(MAX_ITEM_QUALITY);       break;
+        }
+    }
+
+    return lootThreshold;
+}
+bool bot_ai::_canLootItemForPlayer(Player* player, Creature* creature, uint8 slot) const
+{
+    NotNormalLootItem* qitem = nullptr;
+    NotNormalLootItem* ffaitem = nullptr;
+    NotNormalLootItem* conditem = nullptr;
+
+    LootItem const* item = creature->loot.LootItemInSlot(slot, player, &qitem, &ffaitem, &conditem);
+    if (!item || item->is_looted)
+    {
+        //TC_LOG_ERROR("scripts", "can't loot item %u, no item", slot);
+        return false;
+    }
+
+    if (!qitem && item->is_blocked)
+    {
+        //TC_LOG_ERROR("scripts", "can't loot item %u (%u), blocked", slot, item->itemid);
+        return false;
+    }
+
+    if (!item->rollWinnerGUID.IsEmpty() && item->rollWinnerGUID != player->GetGUID())
+    {
+        //TC_LOG_ERROR("scripts", "can't loot item %u (%u), roll won", slot, item->itemid);
+        return false;
+    }
+
+    ItemPosCountVec dest;
+    if (player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+        return true;
+
+    //TC_LOG_ERROR("scripts", "can't loot item %u (%u), can't store", slot, item->itemid);
+    return false;
+}
+bool bot_ai::_canLootCreatureForPlayer(Player* player, Creature* creature, uint32 lootQualityMask, uint32 lootThreshold) const
+{
+    if (!player || master->GetMap() != player->FindMap()/* || !player->IsAlive() || !p->IsAtGroupRewardDistance(creature)*/)
+        return false;
+
+    bool canLoot = false;
+    uint8 slot = 0;
+    for (std::vector<LootItem>::const_iterator i = creature->loot.items.begin(); i != creature->loot.items.end(); ++i)
+    {
+        ++slot;
+
+        if (i->is_blocked || i->is_looted)
+        {
+            //TC_LOG_ERROR("scripts", "item %u is blocked", i->itemid);
+            continue;
+        }
+
+        if (!i->rollWinnerGUID.IsEmpty() && i->rollWinnerGUID != player->GetGUID())
+        {
+            //TC_LOG_ERROR("scripts", "can't loot item %u (%u), roll won", slot, i->itemid);
+            continue;
+        }
+
+        ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(i->itemid);
+        if (!itemProto)
+        {
+            //TC_LOG_ERROR("scripts", "no item proto for itemId %u", i->itemid);
+            return false;
+        }
+
+        if (itemProto->Quality >= lootThreshold)
+        {
+            //TC_LOG_ERROR("scripts", "item %u group quality threshold mismatch", i->itemid);
+            continue;
+        }
+
+        if (!((1 << itemProto->Quality) & lootQualityMask))
+        {
+            //TC_LOG_ERROR("scripts", "item %u lootQualityMask mismatch", i->itemid);
+            continue;
+        }
+
+        if (_canLootItemForPlayer(player, creature, slot - 1) && i->AllowedForPlayer(player))
+        {
+            canLoot = true;
+            break;
+        }
+    }
+    if (!canLoot)
+    {
+        NotNormalLootItemMap const& lootPlayerQuestItems = creature->loot.GetPlayerQuestItems();
+        NotNormalLootItemMap::const_iterator q_itr = lootPlayerQuestItems.find(player->GetGUID());
+        if (q_itr != lootPlayerQuestItems.end())
+        {
+            NotNormalLootItemList* q_list = q_itr->second;
+            for (NotNormalLootItemList::const_iterator qi = q_list->begin(); qi != q_list->end(); ++qi)
+            {
+                LootItem* i = &creature->loot.quest_items[qi->index];
+                if (i->is_looted || qi->is_looted)
+                {
+                    //TC_LOG_ERROR("scripts", "item %u is looted", i->itemid);
+                    continue;
+                }
+
+                if (!i->rollWinnerGUID.IsEmpty() && i->rollWinnerGUID != player->GetGUID())
+                {
+                    //TC_LOG_ERROR("scripts", "can't loot item %u (%u), roll won", slot, i->itemid);
+                    continue;
+                }
+
+                ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(i->itemid);
+
+                if (itemProto->Quality >= lootThreshold)
+                {
+                    //TC_LOG_ERROR("scripts", "item %u group quality threshold mismatch", i->itemid);
+                    continue;
+                }
+
+                if (!((1 << itemProto->Quality) & lootQualityMask))
+                {
+                    //TC_LOG_ERROR("scripts", "item %u lootQualityMask mismatch", i->itemid);
+                    continue;
+                }
+
+                uint8 qslot = uint8(creature->loot.items.size() + (qi - q_list->begin()));
+
+                if (_canLootItemForPlayer(player, creature, qslot) && i->AllowedForPlayer(player))
+                {
+                    canLoot = true;
+                    break;
+                }
+            }
+        }
+    }
+
+    return canLoot;
+}
+bool bot_ai::_canLootCreature(Creature* creature) const
+{
+    Loot* loot = &creature->loot;
+
+    if (loot->gold)
+        return true;
+
+    uint32 lootQualityMask = _getLootQualityMask();
+    uint32 lootThreshold = _getLootQualityThreshold();
+    //TC_LOG_ERROR("scripts", "lootQualityMask %u, lootThreshold %u", lootQualityMask, lootThreshold);
+    bool canLootQuality = false;
+
+    //std::vector<LootItem> const& lootItems = loot->quest_items;
+    for (std::vector<LootItem>::const_iterator ci = loot->quest_items.begin(); ci != loot->quest_items.end(); ++ci)
+    {
+        ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(ci->itemid);
+        if (!itemProto)
+        {
+            //TC_LOG_ERROR("scripts", "no item proto for itemId %u", ci->itemid);
+            return false;
+        }
+
+        if (itemProto->Quality >= lootThreshold)
+        {
+            //TC_LOG_ERROR("scripts", "item %u group quality threshold mismatch", i->itemid);
+            continue;
+        }
+
+        if ((1 << itemProto->Quality) & lootQualityMask)
+        {
+            canLootQuality = true;
+            break;
+        }
+    }
+    if (!canLootQuality)
+    {
+        for (std::vector<LootItem>::const_iterator ci = loot->items.begin(); ci != loot->items.end(); ++ci)
+        {
+            ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(ci->itemid);
+            if (!itemProto)
+            {
+                //TC_LOG_ERROR("scripts", "no item proto for itemId %u", ci->itemid);
+                return false;
+            }
+
+            if (itemProto->Quality >= lootThreshold)
+            {
+                //TC_LOG_ERROR("scripts", "item %u group quality threshold mismatch", i->itemid);
+                continue;
+            }
+
+            if ((1 << itemProto->Quality) & lootQualityMask)
+            {
+                canLootQuality = true;
+                break;
+            }
+        }
+    }
+
+    if (!canLootQuality)
+    {
+        //TC_LOG_ERROR("scripts", "can't loot by quality");
+        return false;
+    }
+
+    bool canLootPlayers = false;
+
+    Group const* gr = master->GetGroup();
+    if (!gr)
+        canLootPlayers = _canLootCreatureForPlayer(master, creature, lootQualityMask, lootThreshold);
+    else
+    {
+        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            if (_canLootCreatureForPlayer(itr->GetSource(), creature, lootQualityMask, lootThreshold))
+            {
+                canLootPlayers = true;
+                break;
+            }
+        }
+    }
+
+    if (!canLootPlayers)
+    {
+        //TC_LOG_ERROR("scripts", "can't loot by canLootPlayers");
+        return false;
+    }
+
+    return true;
+}
+void bot_ai::_autoLootCreatureGold(Creature* creature) const
+{
+    Loot* loot = &creature->loot;
+
+    loot->NotifyMoneyRemoved();
+    Group const* gr = master->GetGroup();
+    if (!gr)
+    {
+        master->ModifyMoney(loot->gold);
+        master->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_MONEY, loot->gold);
+
+        WorldPacket data(SMSG_LOOT_MONEY_NOTIFY, 4 + 1);
+        data << uint32(loot->gold);
+        data << uint8(1);   // "You loot..."
+        master->GetSession()->SendPacket(&data);
+    }
+    else
+    {
+        std::vector<Player*> players;
+        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* p = itr->GetSource();
+            if (p && p->IsAtGroupRewardDistance(creature))
+                players.push_back(p);
+        }
+
+        uint32 goldPerPlayer = uint32(loot->gold / uint32(players.size()));
+
+        for (std::vector<Player*>::const_iterator i = players.begin(); i != players.end(); ++i)
+        {
+            (*i)->ModifyMoney(goldPerPlayer);
+            (*i)->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_MONEY, goldPerPlayer);
+
+            WorldPacket data(SMSG_LOOT_MONEY_NOTIFY, 4 + 1);
+            data << uint32(goldPerPlayer);
+            data << uint8(players.size() <= 1); // Controls the text displayed in chat. 0 is "Your share is..." and 1 is "You loot..."
+            (*i)->SendDirectMessage(&data);
+        }
+    }
+
+    loot->gold = 0;
+
+    if (loot->isLooted())
+    {
+        //TC_LOG_ERROR("scripts", "creature gold is looted, releasing");
+        creature->AllLootRemovedFromCorpse();
+        creature->RemoveDynamicFlag(UNIT_DYNFLAG_LOOTABLE);
+        loot->clear();
+    }
+}
+void bot_ai::_autoLootCreatureItems(Player* receiver, Creature* creature, uint32 lootQualityMask, uint32 lootThreshold) const
+{
+    uint8 slot = 0;
+    for (std::vector<LootItem>::iterator i = creature->loot.items.begin(); i != creature->loot.items.end(); ++i)
+    {
+        ++slot;
+
+        if (i->is_blocked || i->is_looted)
+        {
+            //TC_LOG_ERROR("scripts", "item %u is blocked", i->itemid);
+            continue;
+        }
+
+        if (!i->rollWinnerGUID.IsEmpty() && i->rollWinnerGUID != receiver->GetGUID())
+        {
+            //TC_LOG_ERROR("scripts", "can't loot item %u (%u), roll won", slot, i->itemid);
+            continue;
+        }
+
+        ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(i->itemid);
+
+        if (itemProto->Quality >= lootThreshold)
+            continue;
+        if (!((1 << itemProto->Quality) & lootQualityMask))
+            continue;
+
+        if (_canLootItemForPlayer(receiver, creature, slot - 1) && i->AllowedForPlayer(receiver))
+        {
+            //TC_LOG_ERROR("scripts", "looting %s (%u), quality %u, threshold %u",
+            //    itemProto->Name1.c_str(), itemProto->ItemId, itemProto->Quality, lootThreshold);
+            receiver->StoreLootItem(slot - 1, &creature->loot);
+        }
+    }
+
+    NotNormalLootItemMap const& lootPlayerQuestItems = creature->loot.GetPlayerQuestItems();
+    NotNormalLootItemMap::const_iterator q_itr = lootPlayerQuestItems.find(receiver->GetGUID());
+    if (q_itr != lootPlayerQuestItems.end())
+    {
+        NotNormalLootItemList* q_list = q_itr->second;
+        for (NotNormalLootItemList::const_iterator qi = q_list->begin(); qi != q_list->end(); ++qi)
+        {
+            LootItem* i = &creature->loot.quest_items[qi->index];
+            if (i->is_looted || qi->is_looted)
+            {
+                //TC_LOG_ERROR("scripts", "item %u is looted", i->itemid);
+                continue;
+            }
+
+            if (!i->rollWinnerGUID.IsEmpty() && i->rollWinnerGUID != receiver->GetGUID())
+            {
+                //TC_LOG_ERROR("scripts", "can't loot item %u (%u), roll won", slot, i->itemid);
+                continue;
+            }
+
+            ItemTemplate const* itemProto = sObjectMgr->GetItemTemplate(i->itemid);
+
+            if (itemProto->Quality >= lootThreshold)
+                continue;
+            if (!((1 << itemProto->Quality) & lootQualityMask))
+                continue;
+
+            //if (!receiver->HasQuestForItem(i->itemid))
+            //    continue;
+
+            uint8 qslot = uint8(creature->loot.items.size() + (qi - q_list->begin()));
+
+            if (_canLootItemForPlayer(receiver, creature, qslot) && i->AllowedForPlayer(receiver))
+                receiver->StoreLootItem(qslot, &creature->loot);
+        }
+    }
+    if (creature->loot.isLooted())
+    {
+        //TC_LOG_ERROR("scripts", "creature items is looted, releasing");
+        creature->AllLootRemovedFromCorpse();
+        creature->RemoveDynamicFlag(UNIT_DYNFLAG_LOOTABLE);
+        creature->loot.clear();
+    }
+}
+void bot_ai::_autoLootCreature(Creature* creature)
+{
+    //money
+    if (creature->loot.gold)
+    {
+        _autoLootCreatureGold(creature);
+
+        //nothing but gold was there
+        if (creature->loot.empty())
+            return;
+    }
+
+    //items
+    uint32 lootQualityMask = _getLootQualityMask();
+    uint32 lootThreshold = _getLootQualityThreshold();
+
+    std::set<Player*> pLooters;
+    Group* gr = master->GetGroup();
+    if (!gr)
+    {
+        if (_canLootCreatureForPlayer(master, creature, lootQualityMask, lootThreshold))
+            pLooters.insert(master);
+    }
+    else
+    {
+        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            if (_canLootCreatureForPlayer(itr->GetSource(), creature, lootQualityMask, lootThreshold))
+                pLooters.insert(itr->GetSource());
+        }
+    }
+
+    //creature->lootForBody = true;
+
+    if (gr && creature->loot.loot_type == LOOT_NONE)
+    {
+        switch (gr->GetLootMethod())
+        {
+            case GROUP_LOOT:        gr->GroupLoot(&creature->loot, creature);       break;
+            case NEED_BEFORE_GREED: gr->NeedBeforeGreed(&creature->loot, creature); break;
+            case MASTER_LOOT:       gr->MasterLoot(&creature->loot, creature);      break;
+            default:                                                                break;
+        }
+    }
+
+    if (creature->loot.loot_type != LOOT_SKINNING)
+        creature->loot.loot_type = LOOT_CORPSE;
+
+    Player* receiver = pLooters.size() == 1 ? *pLooters.begin() :
+        creature->loot.roundRobinPlayer ? ObjectAccessor::GetPlayer(*creature, creature->loot.roundRobinPlayer) : nullptr;
+
+    if (!receiver)
+    {
+        if (pLooters.empty())
+            return;
+
+        ASSERT(pLooters.size() >= 2);
+
+        do
+        {
+            receiver = Trinity::Containers::SelectRandomContainerElement(pLooters);
+        } while (receiver == _prevRRobin);
+    }
+
+    _prevRRobin = receiver;
+
+    _autoLootCreatureItems(receiver, creature, lootQualityMask, lootThreshold);
+}
+//////////
+//EQUIPS//
+//////////
+bool bot_ai::_canUseOffHand() const
+{
+    //bm can on only equip in main hand
+    if (_botclass == BOT_CLASS_BM)
+        return false;
+    //sphynx can grab anything
+    if (_botclass == BOT_CLASS_SPHYNX)
+        return true;
+    //dreadlord can on only equip in main hand
+    if (_botclass == BOT_CLASS_DREADLORD)
+        return false;
+
+    //warrior can wield any offhand with titan's grip
+    if (_botclass == BOT_CLASS_WARRIOR && me->GetLevel() >= 60 && _spec == BOT_SPEC_WARRIOR_FURY)
+        return true;
+
+    ItemTemplate const* protoMH = _equips[BOT_SLOT_MAINHAND] ? _equips[BOT_SLOT_MAINHAND]->GetTemplate() : nullptr;
+
+    //no mainhand weapon OR
+    //mainhand is an one-hand weapon
+    if (!protoMH)
+        return true;
+
+    if (protoMH->Class == ITEM_CLASS_WEAPON &&
+        (protoMH->InventoryType == INVTYPE_WEAPON || protoMH->InventoryType == INVTYPE_WEAPONMAINHAND) &&
+        (protoMH->SubClass == ITEM_SUBCLASS_WEAPON_AXE || protoMH->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+        protoMH->SubClass == ITEM_SUBCLASS_WEAPON_FIST || protoMH->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+        protoMH->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+        return true;
+
+    //NO
+    return false;
+}
+
+bool bot_ai::_canUseRanged() const
+{
+    return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PRIEST ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK ||
+        _botclass == BOT_CLASS_DARK_RANGER || _botclass == BOT_CLASS_SEA_WITCH);
+}
+
+bool bot_ai::_canUseRelic() const
+{
+    return (_botclass == BOT_CLASS_PALADIN || _botclass == BOT_CLASS_SHAMAN ||
+        _botclass == BOT_CLASS_DRUID || _botclass == BOT_CLASS_DEATH_KNIGHT);
+}
+
+bool bot_ai::_canEquip(Item const* newItem, uint8 slot, bool ignoreItemLevel) const
+{
+    ItemTemplate const* newProto = newItem->GetTemplate();
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    if (Item const* oldItem = _equips[slot])
+    {
+        ItemTemplate const* oldProto = oldItem->GetTemplate();
+        //prevent reequipping same items
+        if (newProto->ItemId == oldProto->ItemId && !newItem->GetItemRandomPropertyId())
+            return false;
+        //prevent equipping worse items (only standard or not)
+        if (!ignoreItemLevel)
+            if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != oldProto->ItemId)
+                if (IAmFree() || !master->IsGameMaster())
+                    if (_getItemGearScore(oldItem, slot) > _getItemGearScore(newItem, slot))
+                        return false;
+    }
+
+    if (slot == BOT_SLOT_OFFHAND && !_canUseOffHand())
+        return false;
+
+    //level requirements
+    if (me->GetLevel() < newProto->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (_botclass < BOT_CLASS_EX_START && !(newProto->AllowableClass & (1<<(_botclass-1))))
+        return false;
+
+    //skip race requirements
+
+    //inventory related conditions
+    if (newProto->Class == ITEM_CLASS_WEAPON)
+    {
+        switch (slot)
+        {
+            case BOT_SLOT_MAINHAND:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                        if (newProto->SubClass != ITEM_SUBCLASS_WEAPON_POLEARM &&
+                            newProto->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                            newProto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2)
+                            return false;
+                        break;
+                    case BOT_CLASS_ARCHMAGE:
+                    case BOT_CLASS_NECROMANCER:
+                        if (newProto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                            return false;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case BOT_SLOT_OFFHAND:
+                if (newProto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM || newProto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_ROGUE:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_HUNTER:
+                        if (me->GetLevel() < 20)
+                            return false;
+                        break;
+                    case BOT_CLASS_SHAMAN:
+                        if (me->GetLevel() < 40 || _spec != BOT_SPEC_SHAMAN_ENHANCEMENT)
+                            return false;
+                        break;
+                    case BOT_CLASS_SPHYNX:
+                        break;
+                    case BOT_CLASS_DARK_RANGER:
+                        break;
+                    case BOT_CLASS_SEA_WITCH:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_SLOT_RANGED:
+                if (!_canUseRanged())
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (newProto->InventoryType)
+        {
+            case INVTYPE_WEAPONMAINHAND:
+                if (slot != BOT_SLOT_MAINHAND)
+                    return false;
+                break;
+            case INVTYPE_WEAPONOFFHAND:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_2HWEAPON:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_WARRIOR:
+                        switch (slot)
+                        {
+                            case BOT_SLOT_OFFHAND:
+                                if (me->GetLevel() < 60)
+                                    return false;
+                                break;
+                            case BOT_SLOT_RANGED:
+                                return false;
+                            default:
+                                break;
+                        }
+                        break;
+                    case BOT_CLASS_SPHYNX:
+                        break;
+                    default:
+                        if (slot != BOT_SLOT_MAINHAND)
+                            return false;
+                        break;
+                }
+                break;
+            case INVTYPE_WEAPON:
+                if (slot != BOT_SLOT_MAINHAND && slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_THROWN:
+            case INVTYPE_RANGED:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            case INVTYPE_RANGEDRIGHT:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        if (slot != BOT_SLOT_MAINHAND && slot != BOT_SLOT_OFFHAND)
+                            return false;
+                        break;
+                    default:
+                        if (slot != BOT_SLOT_RANGED)
+                            return false;
+                        break;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                    //case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_DEATH_KNIGHT:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_HUNTER:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    //case ITEM_SUBCLASS_WEAPON_MACE:
+                    //case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    //case ITEM_SUBCLASS_WEAPON_THROWN: //hunters can use thrown but bots can't, also pointless
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_ROGUE:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+                    case ITEM_SUBCLASS_WEAPON_GUN:
+                    case ITEM_SUBCLASS_WEAPON_THROWN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_PRIEST:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DRUID:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SHAMAN:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_BM:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SPHYNX:
+                switch (newProto->SubClass)
+                {
+                    //case ITEM_SUBCLASS_WEAPON_MACE:
+                    //case ITEM_SUBCLASS_WEAPON_MACE2:
+                    //case ITEM_SUBCLASS_WEAPON_SWORD:
+                    //case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    //case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_WAND:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_ARCHMAGE:
+            case BOT_CLASS_NECROMANCER:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DREADLORD:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_AXE2:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_MACE2:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_SWORD2:
+                    case ITEM_SUBCLASS_WEAPON_POLEARM:
+                    case ITEM_SUBCLASS_WEAPON_STAFF:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SPELLBREAKER:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_DARK_RANGER:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case BOT_CLASS_SEA_WITCH:
+                switch (newProto->SubClass)
+                {
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_BOW:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        return true;
+    }
+    else if (newProto->Class == ITEM_CLASS_ARMOR/* || newProto->Class == ITEM_CLASS_QUEST*/)
+    {
+        switch (newProto->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                return false;
+        }
+
+        switch (newProto->SubClass)
+        {
+            case ITEM_SUBCLASS_ARMOR_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPELLBREAKER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_SHAMAN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_PLATE:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SPHYNX:
+                    case BOT_CLASS_DREADLORD:
+                    case BOT_CLASS_SPELLBREAKER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        if (me->GetLevel() >= 40 || newProto->Quality == ITEM_QUALITY_HEIRLOOM)
+                            break;
+                        return false;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_MAIL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SPHYNX:
+                    case BOT_CLASS_SPELLBREAKER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        break;
+                    case BOT_CLASS_SHAMAN:
+                    case BOT_CLASS_HUNTER:
+                        if (me->GetLevel() >= 40 || newProto->Quality == ITEM_QUALITY_HEIRLOOM)
+                            break;
+                        return false;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_LEATHER:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DARK_RANGER:
+                        break;
+                    case BOT_CLASS_WARRIOR:
+                    case BOT_CLASS_PALADIN:
+                    case BOT_CLASS_DEATH_KNIGHT:
+                    case BOT_CLASS_BM:
+                    case BOT_CLASS_SHAMAN:
+                    case BOT_CLASS_HUNTER:
+                    case BOT_CLASS_ROGUE:
+                    case BOT_CLASS_DRUID:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_CLOTH:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    case BOT_CLASS_DREADLORD:
+                    case BOT_CLASS_SPELLBREAKER:
+                        if (newProto->InventoryType != INVTYPE_CLOAK)
+                            return false;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_MISC:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SPHYNX:
+                        return false;
+                    default:
+                        break;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_LIBRAM:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_PALADIN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_IDOL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DRUID:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_TOTEM:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_SHAMAN:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            case ITEM_SUBCLASS_ARMOR_SIGIL:
+                switch (_botclass)
+                {
+                    case BOT_CLASS_DEATH_KNIGHT:
+                        break;
+                    default:
+                        return false;
+                }
+                break;
+            default:
+                return false;
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+bool bot_ai::_unequip(uint8 slot, ObjectGuid receiver)
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo, "Trying to unequip item for bot with no equip info!");
+
+    Item* item = _equips[slot];
+    if (!item)
+        return true; //already unequipped
+
+    uint32 itemId = item->GetEntry();
+
+    RemoveItemBonuses(slot);
+    ApplyItemSetBonuses(item, false);
+
+    //hand old weapon to master
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+    {
+        if (receiver == master->GetGUID())
+        {
+            ItemPosCountVec dest;
+            uint32 no_space = 0;
+            InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+            if (msg != EQUIP_ERR_OK)
+            {
+                std::ostringstream istr;
+                _AddItemLink(master, item, istr, false);
+                ChatHandler ch(master->GetSession());
+                ch.PSendSysMessage(LocalizedNpcText(master, BOT_TEXT_CANT_UNEQUIP_MAILING).c_str(), istr.str().c_str());
+
+                item->SetOwnerGUID(master->GetGUID());
+
+                CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+                item->FSetState(ITEM_CHANGED);
+                item->SaveToDB(trans);
+                MailDraft(istr.str(), "").AddItem(item).SendMailTo(trans, MailReceiver(master), MailSender(me));
+                CharacterDatabase.CommitTransaction(trans);
+
+                //master->SendEquipError(msg, nullptr, nullptr, itemId);
+                //return false;
+            }
+            else
+            {
+                Item* pItem = master->StoreItem(dest, item, true);
+                master->SendNewItem(pItem, 1, true, false, false);
+            }
+        }
+        else
+        {
+            item->SetOwnerGUID(receiver);
+
+            CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+            item->FSetState(ITEM_CHANGED);
+            item->SaveToDB(trans);
+            static const std::string subject = LocalizedNpcText(nullptr, BOT_TEXT_OWNERSHIP_EXPIRED);
+            MailDraft(subject, "").AddItem(item).SendMailTo(trans, MailReceiver(receiver.GetCounter()), MailSender(me));
+            CharacterDatabase.CommitTransaction(trans);
+        }
+    }
+    else
+    {
+        //slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == itemId
+        //we have our standard weapon which we should get rid of
+        //item->SetState(ITEM_REMOVED, master); //delete Item object
+        delete item; //!Invalidated!
+        //item = nullptr; //already in "_updateEquips(slot, nullptr);"
+    }
+
+    if (slot <= BOT_SLOT_RANGED && CanChangeEquip(slot)) //weapons
+    {
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), BASE_ATTACK_TIME); //without weapon
+    }
+
+    _updateEquips(slot, nullptr);
+
+    //offhand check
+    if (slot == BOT_SLOT_OFFHAND)
+    {
+        if (me->CanDualWield())
+            me->SetCanDualWield(false);
+        if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+    }
+
+    return true;
+}
+
+bool bot_ai::_equip(uint8 slot, Item* newItem, ObjectGuid receiver)
+{
+    ASSERT(newItem);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo, "Trying to equip item for bot with no equip info!");
+
+    ItemTemplate const* proto = newItem->GetTemplate();
+
+    if (newItem->GetState() == ITEM_REMOVED)
+    {
+        TC_LOG_ERROR("entities.player",
+            "minion_ai::_equip(): player %s (%s) is trying to make bot %s (id: %u) equip item: %s (id: %u, %s) which has state ITEM_REMOVED!",
+            master->GetName().c_str(), master->GetGUID().ToString().c_str(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUID().ToString().c_str());
+        return false;
+    }
+
+    uint32 newItemId = newItem->GetEntry();
+
+    if (Item const* oldItem = _equips[slot])
+    {
+        //same id
+        if (oldItem->GetEntry() == newItemId && !newItem->GetItemRandomPropertyId())
+            return false;
+    }
+
+    if (!_unequip(slot, receiver))
+    {
+        //BotWhisper("You have no space for my current item", master);
+        return false;
+    }
+
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+    {
+        ASSERT(receiver == master->GetGUID());
+
+        //cheating
+        if (newItem->GetOwnerGUID() != master->GetGUID() || !master->HasItemCount(newItemId, 1))
+        {
+            //std::ostringstream msg;
+            //msg << "Cannot find ";
+            //_AddItemLink(master, newItem, msg, false);
+            //msg << " (id: " << uint32(newItemId) << ")!";
+            //BotWhisper(msg.str().c_str());
+
+            TC_LOG_ERROR("entities.player",
+                "minion_ai::_equip(): player %s (%s) is trying to make bot %s (id: %u) equip item: %s (id: %u, %s) but either does not have this item or does not own it",
+                master->GetName().c_str(), master->GetGUID().ToString().c_str(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUID().ToString().c_str());
+            return false;
+        }
+
+        master->MoveItemFromInventory(newItem->GetBagSlot(), newItem->GetSlot(), true);
+        //Item is removed from inventory table in _updateEquips(slot, newItem);
+        //newItem->SetOwnerGUID(ObjectGuid::Empty); //needed to prevent some logs to be sent to master, restored at unequip
+    }
+
+    if (slot <= BOT_SLOT_RANGED)
+    {
+        if (CanChangeEquip(slot))
+        {
+            NpcBotTransmogData const* transmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+            if (einfo->ItemEntry[slot] != newItemId && transmogData && BotMgr::IsTransmogEnabled() && (transmogData->transmogs[slot].first == newItemId || BotMgr::TransmogUseEquipmentSlots()))
+                me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, transmogData->transmogs[slot].second);
+            else
+                me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, newItemId);
+        }
+        uint32 delay =
+            /*einfo->ItemEntry[slot] != newItemId || */RespectEquipsAttackTime() || slot == BOT_SLOT_OFFHAND ? proto->Delay :
+            slot == BOT_SLOT_RANGED ? me->GetCreatureTemplate()->RangeAttackTime : me->GetCreatureTemplate()->BaseAttackTime;
+        //attack time will be updated in SetStats() -> OnMeleeDamageUpdate()
+        if (!me->IsInFeralForm())
+            me->SetAttackTime(WeaponAttackType(slot), delay); //set attack speed
+    }
+
+    _updateEquips(slot, newItem);
+
+    //only for non-standard items
+    if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+        ApplyItemBonuses(slot);
+    ApplyItemSetBonuses(newItem, true);
+
+    if (slot == BOT_SLOT_OFFHAND)
+    {
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            if (!me->CanDualWield())
+                me->SetCanDualWield(true);
+        }
+        else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else if (slot == BOT_SLOT_MAINHAND)
+    {
+        if (proto->InventoryType == INVTYPE_2HWEAPON && !(_botclass == BOT_CLASS_WARRIOR && me->GetLevel() >= 60 && _spec == BOT_SPEC_WARRIOR_FURY))
+        {
+            //if have incompatible offhand unequip it
+            if (_equips[BOT_SLOT_OFFHAND] != nullptr)
+                _unequip(BOT_SLOT_OFFHAND, receiver);
+        }
+        else if (_equips[BOT_SLOT_OFFHAND] == nullptr && einfo->ItemEntry[BOT_SLOT_OFFHAND])
+            _resetEquipment(BOT_SLOT_OFFHAND, receiver);
+    }
+
+    //send info to class ai
+    if (proto->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot == BOT_SLOT_MAINHAND)
+        {
+            SetAIMiscValue(BOTAI_MISC_DAGGER_MAINHAND, proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER);
+            SetAIMiscValue(BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH, newItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+            SetAIMiscValue(BOTAI_MISC_WEAPON_SPEC, proto->SubClass);
+        }
+        if (slot == BOT_SLOT_OFFHAND)
+        {
+            SetAIMiscValue(BOTAI_MISC_DAGGER_OFFHAND, proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER);
+            SetAIMiscValue(BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH, newItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+        }
+    }
+
+    return true;
+}
+
+void bot_ai::_updateEquips(uint8 slot, Item* item)
+{
+    _equips[slot] = item;
+    BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_EQUIPS, _equips);
+}
+//Called from gossip menu only (applies only to weapons)
+bool bot_ai::_resetEquipment(uint8 slot, ObjectGuid receiver)
+{
+    ASSERT(slot <= BOT_SLOT_RANGED);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo, "Trying to reset equipment for bot with no equip info!");
+
+    uint32 itemId = einfo->ItemEntry[slot];
+    if (!itemId)
+        return _unequip(slot, receiver);
+    else if (Item const* oldItem = _equips[slot])
+        if (oldItem->GetEntry() == itemId)
+            return true;
+
+    if (slot == BOT_SLOT_MAINHAND && !(_botclass == BOT_CLASS_WARRIOR && me->GetLevel() >= 60 && _spec == BOT_SPEC_WARRIOR_FURY))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+            {
+                if (!_unequip(BOT_SLOT_OFFHAND, receiver))
+                    return false;
+            }
+        }
+    }
+
+    //we have our standard weapon itemId which we should use to create new item
+    Item* stItem = Item::CreateItem(itemId, 1, nullptr);
+    ASSERT(stItem, "Failed to create standard Item for bot!");
+
+    if (!_equip(slot, stItem, receiver))
+    {
+        TC_LOG_ERROR("entities.player", "minion_ai::_resetEquipment(): player %s (%s) failed to reset equipment for bot %s (id: %u) in slot %u",
+            master->GetName().c_str(), master->GetGUID().ToString().c_str(), me->GetName().c_str(), me->GetEntry(), slot);
+        return false;
+    }
+    return true;
+}
+
+void bot_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : nullptr;
+
+    uint32 ssd_level = me->GetLevel();
+    if (ssd && ssd_level > ssd->Maxlevel)
+        ssd_level = ssd->Maxlevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : nullptr;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val      = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatID[i] < 0)
+                continue;
+            statType = ssd->StatID[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Bonus[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    _stats[slot][BOT_STAT_MOD_RESIST_HOLY] += proto->HolyRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_FIRE] += proto->FireRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_NATURE] += proto->NatureRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_FROST] += proto->FrostRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_SHADOW] += proto->ShadowRes;
+    _stats[slot][BOT_STAT_MOD_RESIST_ARCANE] += proto->ArcaneRes;
+
+    _stats[slot][BOT_STAT_MOD_ARMOR] += proto->Armor;
+    _stats[slot][BOT_STAT_MOD_BLOCK_VALUE] += proto->Block;
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    if (item->GetEntry() != einfo->ItemEntry[slot])
+    {
+        if (ssv)
+        {
+            float average = ssv->getDPSMod(proto->ScalingStatValue) * proto->Delay / 1000.0f;
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += 0.7f * average;
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += 1.3f * average;
+        }
+        else
+        {
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += proto->Damage[0].DamageMin + proto->Damage[1].DamageMin;
+            _stats[slot][BOT_STAT_MOD_DAMAGE_MAX] += proto->Damage[0].DamageMax + proto->Damage[1].DamageMax;
+        }
+
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            int32 dpsMod = 0;
+            int32 feral_bonus = 0;
+
+            if (ssv)
+            {
+                dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+                feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+            }
+
+            feral_bonus += proto->getFeralBonus(dpsMod);
+            if (feral_bonus)
+                _stats[slot][BOT_STAT_MOD_FERAL_ATTACK_POWER] += feral_bonus;
+                //ApplyFeralAPBonus(feral_bonus, apply);
+        }
+    }
+
+    ApplyItemEnchantments(item, slot);
+    ApplyItemEquipSpells(item, true);
+
+    shouldUpdateStats = true;
+}
+
+void bot_ai::RemoveItemBonuses(uint8 slot)
+{
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    RemoveItemEnchantments(item); //remove spells
+    ApplyItemEquipSpells(item, false);
+
+    shouldUpdateStats = true;
+}
+
+void bot_ai::ApplyItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        ApplyItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_ai::ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (pEnchant->MinLevel > me->GetLevel())
+        return;
+
+    uint32 enchant_display_type;
+    uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->Effect[s];
+        enchant_amount = pEnchant->EffectPointsMin[s];
+        enchant_spell_id = pEnchant->EffectArg[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                _stats[slot][BOT_STAT_MOD_DAMAGE_MIN] += enchant_amount;
+                _stats[slot][BOT_STAT_MOD_DAMAGE_MAX] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                {
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->Enchantment[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    CastSpellExtraArgs args(item);
+                    if (basepoints)
+                    {
+                        args.AddSpellBP0(basepoints);
+                    }
+                    me->CastSpell(me, enchant_spell_id, args);
+                }
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand)
+                    {
+                        for (uint8 k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand->Enchantment[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+                _stats[slot][BOT_STAT_MOD_RESISTANCE_START + enchant_spell_id] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+            {
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand_suffix)
+                    {
+                        for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand_suffix->Enchantment[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand_suffix->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                switch (enchant_spell_id)
+                {
+                    case ITEM_MOD_MANA:
+                    case ITEM_MOD_HEALTH:
+                    case ITEM_MOD_AGILITY:
+                    case ITEM_MOD_STRENGTH:
+                    case ITEM_MOD_INTELLECT:
+                    case ITEM_MOD_SPIRIT:
+                    case ITEM_MOD_STAMINA:
+                    case ITEM_MOD_DEFENSE_SKILL_RATING:
+                    case ITEM_MOD_DODGE_RATING:
+                    case ITEM_MOD_PARRY_RATING:
+                    case ITEM_MOD_BLOCK_RATING:
+                    case ITEM_MOD_HIT_MELEE_RATING:
+                    case ITEM_MOD_HIT_RANGED_RATING:
+                    case ITEM_MOD_HIT_SPELL_RATING:
+                    case ITEM_MOD_CRIT_MELEE_RATING:
+                    case ITEM_MOD_CRIT_RANGED_RATING:
+                    case ITEM_MOD_CRIT_SPELL_RATING:
+                    case ITEM_MOD_HASTE_MELEE_RATING:
+                    case ITEM_MOD_HASTE_RANGED_RATING:
+                    case ITEM_MOD_HASTE_SPELL_RATING:
+                    case ITEM_MOD_HIT_RATING:
+                    case ITEM_MOD_CRIT_RATING:
+                    case ITEM_MOD_HASTE_RATING:
+                    case ITEM_MOD_RESILIENCE_RATING:
+                    case ITEM_MOD_EXPERTISE_RATING:
+                    case ITEM_MOD_ATTACK_POWER:
+                    case ITEM_MOD_RANGED_ATTACK_POWER:
+                    case ITEM_MOD_MANA_REGENERATION:
+                    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                    case ITEM_MOD_SPELL_POWER:
+                    case ITEM_MOD_HEALTH_REGEN:
+                    case ITEM_MOD_SPELL_PENETRATION:
+                    case ITEM_MOD_BLOCK_VALUE:
+                    case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+                    case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                        _stats[slot][enchant_spell_id] += enchant_amount;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_ai::RemoveItemEnchantments(Item const* item)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        RemoveItemEnchantment(item, EnchantmentSlot(i));
+}
+
+void bot_ai::RemoveItemEnchantment(Item const* item, EnchantmentSlot eslot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    ////skip level reqs
+    //if (pEnchant->MinLevel > me->GetLevel())
+    //    return;
+
+    uint32 enchant_display_type;
+    //uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->Effect[s];
+        //enchant_amount = pEnchant->EffectPointsMin[s];
+        enchant_spell_id = pEnchant->EffectArg[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                    me->RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_ai::RemoveItemClassEnchants()
+{
+    uint8 eslot = TEMP_ENCHANTMENT_SLOT;
+    for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_SLOT_RANGED; ++k)
+    {
+        if (!GetAIMiscValue(k == BOT_SLOT_MAINHAND ? BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH : BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH))
+            continue;
+
+        Item* weap = _equips[k];
+        if (!weap || !weap->GetEnchantmentId(EnchantmentSlot(eslot)))
+            continue;
+
+        RemoveItemEnchantment(weap, EnchantmentSlot(eslot));
+
+        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+            weap->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + eslot*MAX_ENCHANTMENT_OFFSET + i, 0);
+    }
+}
+
+void bot_ai::ApplyItemEquipSpells(Item* item, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+
+        if (!spellData.SpellId)
+            continue;
+
+        // wrong triggering type
+        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
+            continue;
+
+        // check if it is valid spell
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        //ApplyEquipSpell(spellproto, item, apply);
+
+        //if (apply)
+        //    me->AddAura(spellInfo->Id, me);
+        //else
+        //    me->RemoveAura(spellInfo->Id);
+
+        CastSpellExtraArgs args(item);
+        if (apply)
+            me->CastSpell(me, spellInfo->Id, args);
+        else
+            me->RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
+    }
+}
+
+void bot_ai::ApplyItemEquipEnchantmentSpells(Item* item)
+{
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        if (!enchant_id)
+            continue;
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+        if (pEnchant->MinLevel > me->GetLevel())
+            continue;
+
+        uint32 enchant_display_type;
+        //uint32 enchant_amount;
+        uint32 enchant_spell_id;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            enchant_display_type = pEnchant->Effect[s];
+            //enchant_amount = pEnchant->EffectPointsMin[s];
+            enchant_spell_id = pEnchant->EffectArg[s];
+
+            switch (enchant_display_type)
+            {
+                case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                {
+                    if (!enchant_spell_id)
+                        break;
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->Enchantment[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    CastSpellExtraArgs args(item);
+                    if (basepoints)
+                    {
+                        args.AddSpellBP0(basepoints);
+                    }
+                    me->CastSpell(me, enchant_spell_id, args);
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+    }
+}
+
+void bot_ai::ApplyItemSetBonuses(Item* item, bool apply)
+{
+    if (item) //(un)equip, NOT from loops
+    {
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            return;
+
+        uint32 setId = proto->ItemSet;
+        if (!setId)
+            return;
+
+        ItemSetEntry const* itemSet = sItemSetStore.LookupEntry(setId);
+        if (!itemSet)
+            return;
+
+        uint8 setItemCount = 0;
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            if (_equips[i] && _equips[i]->GetTemplate()->ItemSet == setId)
+                ++setItemCount; //same at equip and unequip
+
+        for (uint8 i = 0; i != MAX_ITEM_SET_SPELLS; ++i)
+        {
+            if (!itemSet->SetSpellID[i])
+                continue;
+            if (itemSet->SetThreshold[i] != setItemCount)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itemSet->SetSpellID[i]);
+            if (!spellInfo)
+                continue;
+
+            //TC_LOG_ERROR("entities.player", "ApplyItemSetBonusesB: %s's %s, %s (%u), %s (%u), icount %u",
+            //    me->GetName().c_str(), apply ? "apply" : "remove", itemSet->name[0], setId, spellInfo->SpellName[0], spellInfo->Id, uint32(setItemCount));
+
+            if (apply)
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(me, spellInfo->Id, args);
+            }
+            else
+                me->RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
+        }
+        return;
+    }
+
+    //no item means all (init, reset, reset (lvl change))
+    std::list<uint32> itemSets;
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        uint32 setId = proto->ItemSet;
+        if (!setId)
+            continue;
+
+        ItemSetEntry const* itemSet = sItemSetStore.LookupEntry(setId);
+        if (!itemSet)
+            continue;
+
+        itemSets.push_back(setId);
+    }
+
+    itemSets.sort();
+    itemSets.unique();
+    for (std::list<uint32>::const_iterator itr = itemSets.begin(); itr != itemSets.end(); ++itr)
+    {
+        ItemSetEntry const* itemSet = sItemSetStore.LookupEntry(*itr);
+        uint8 setItemCount = 0;
+        for (uint8 k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+            if (_equips[k] && _equips[k]->GetTemplate()->ItemSet == *itr)
+                ++setItemCount;
+
+        for (uint8 j = 0; j != MAX_ITEM_SET_SPELLS; ++j)
+        {
+            if (!itemSet->SetSpellID[j])
+                continue;
+            if (itemSet->SetThreshold[j] > setItemCount)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(itemSet->SetSpellID[j]);
+            if (!spellInfo)
+                continue;
+
+            //TC_LOG_ERROR("entities.player", "ApplyItemSetBonusesB (all): %s's %s, %s (%u), %s (%u), c %u, req %u",
+            //    me->GetName().c_str(), apply ? "apply" : "remove", itemSet->name[0], *itr, spellInfo->SpellName[0], spellInfo->Id, uint32(setItemCount), itemSet->SetThreshold[j]);
+
+            if (apply)
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(me, spellInfo->Id, args);
+            }
+            else
+                me->RemoveAurasDueToSpell(spellInfo->Id);           // un-apply spell (item set case)
+        }
+    }
+}
+
+void bot_ai::ApplyItemsSpells()
+{
+    for (uint8 slot = BOT_SLOT_MAINHAND; slot != BOT_INVENTORY_SIZE; ++slot)
+    {
+        if (Item* item = _equips[slot])
+        {
+            ApplyItemEquipSpells(item, true); //item template spells
+            ApplyItemEquipEnchantmentSpells(item); //item enchants
+        }
+    }
+
+    ApplyItemSetBonuses(nullptr, true); //item set bonuses
+}
+//stats bonuses from equipment
+inline float bot_ai::_getBotStat(uint8 slot, BotStatMods stat) const
+{
+    return float(_stats[slot][stat]);
+}
+
+float bot_ai::_getTotalBotStat(BotStatMods stat) const
+{
+    int32 value = 0;
+    for (uint8 slot = BOT_SLOT_MAINHAND; slot != BOT_INVENTORY_SIZE; ++slot)
+        value += _stats[slot][stat];
+
+    uint8 lvl = me->GetLevel();
+    float fval = float(value);
+
+    switch (stat)
+    {
+        case BOT_STAT_MOD_STRENGTH:
+            fval += me->GetTotalStatValue(STAT_STRENGTH);
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    //Vitality, Strength of Arms
+                    if (lvl >= 45 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+                        fval *= 1.06f;
+                    if (lvl >= 40 && _spec == BOT_SPEC_WARRIOR_ARMS)
+                        fval *= 1.04f;
+                    //Improved Berserker Stance part 1 (all stances)
+                    if (lvl >= 45 && _spec == BOT_SPEC_WARRIOR_FURY/* && GetBotStance() == WARRIOR_BERSERKER_STANCE*/)
+                        fval *= 1.2f;
+                    break;
+                case BOT_CLASS_PALADIN:
+                    //Divine Strength
+                    if (lvl >= 10)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    //Ravenous Dead part 1
+                    //Endless Winter part 1
+                    //Veteran of the Third War part 1
+                    //Abomination's might part 2
+                    if (lvl >= 56)
+                        fval *= 1.03f;
+                    if (lvl >= 58)
+                        fval *= 1.04f;
+                    if (lvl >= 59 && _spec == BOT_SPEC_DK_BLOOD)
+                        fval *= 1.06f;
+                    if (lvl >= 60 && _spec == BOT_SPEC_DK_BLOOD)
+                        fval *= 1.02f;
+                    //Frost Presence passive / Improved Frost Presence
+                    if (lvl >= 61 && GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE && _spec == BOT_SPEC_DK_FROST)
+                        fval *= 1.08f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_AGILITY:
+            fval += me->GetTotalStatValue(STAT_AGILITY);
+            switch (_botclass)
+            {
+                case BOT_CLASS_HUNTER:
+                    //Combat Experience, Lightning Reflexes
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_MARKSMANSHIP)
+                        fval *= 1.04f;
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_SURVIVAL)
+                        fval *= 1.15f;
+                    //Hunting Party
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_SURVIVAL)
+                        fval *= 1.03f;
+                    break;
+                case BOT_CLASS_ROGUE:
+                    //Sinister Calling
+                    if (lvl >= 45 && _spec == BOT_SPEC_ROGUE_SUBTLETY)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_STAMINA:
+            fval += me->GetTotalStatValue(STAT_STAMINA);
+            switch (_botclass)
+            {
+                case BOT_CLASS_WARRIOR:
+                    //Vitality, Strength of Arms
+                    if (lvl >= 45 && _spec == BOT_SPEC_WARRIOR_PROTECTION)
+                        fval *= 1.09f;
+                    if (lvl >= 40 && _spec == BOT_SPEC_WARRIOR_ARMS)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_PALADIN:
+                    //Combat Expertise, Sacred Duty
+                    if (lvl >= 45 && _spec == BOT_SPEC_PALADIN_PROTECTION)
+                        fval *= 1.06f;
+                    if (lvl >= 35 && _spec == BOT_SPEC_PALADIN_PROTECTION)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_HUNTER:
+                    //Survivalist
+                    if (lvl >= 20)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_ROGUE:
+                    //Lightning Reflexes part 2
+                    if (lvl >= 25 && _spec == BOT_SPEC_ROGUE_COMBAT)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_PRIEST:
+                    //Improved Power Word: Shield
+                    if (lvl >= 15)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                    //Veteran of the Third War part 2
+                    if (lvl >= 59 && _spec == BOT_SPEC_DK_BLOOD)
+                        fval *= 1.03f;
+                    break;
+                case BOT_CLASS_WARLOCK:
+                    //Demonic Embrace: 10% stam bonus
+                    if (lvl >= 10)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    if (GetBotStance() == DRUID_BEAR_FORM)
+                    {
+                        //Bear form: stamina bonus base 25%
+                        //Heart of the Wild: 10% stam bonus for bear
+                        fval *= 1.25f;
+                        if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                            fval *= 1.1f;
+                    }
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.06f;
+                    if (lvl >= 10)
+                        fval *= 1.02f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_INTELLECT:
+            fval += me->GetTotalStatValue(STAT_INTELLECT);
+            switch (_botclass)
+            {
+                case BOT_CLASS_PALADIN:
+                    //Divine Intellect
+                    if (lvl >= 15)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_HUNTER:
+                    //Combat Experience
+                    if (lvl >= 35 && _spec == BOT_SPEC_HUNTER_MARKSMANSHIP)
+                        fval *= 1.04f;
+                    break;
+                case BOT_CLASS_MAGE:
+                    //Arcane Mind
+                    if (lvl >= 30 && _spec == BOT_SPEC_MAGE_ARCANE)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_PRIEST:
+                    //Mental Strength
+                    if (lvl >= 30 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+                        fval *= 1.15f;
+                    break;
+                case BOT_CLASS_SHAMAN:
+                    //Ancestral Knowledge
+                    if (lvl >= 10)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    //Furor (Moonkin Form)
+                    if (GetBotStance() == DRUID_MOONKIN_FORM)
+                        fval *= 1.1f;
+                    //Heart of the Wild: ferals only (tanks included)
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.2f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case BOT_STAT_MOD_SPIRIT:
+            fval += me->GetTotalStatValue(STAT_SPIRIT);
+            switch (_botclass)
+            {
+                case BOT_CLASS_PRIEST:
+                    //Spirit of Redemption part 1
+                    if (lvl >= 30 && _spec == BOT_SPEC_PRIEST_HOLY)
+                        fval *= 1.05f;
+                    //Enlightenment part 1
+                    if (lvl >= 35 && _spec == BOT_SPEC_PRIEST_DISCIPLINE)
+                        fval *= 1.06f;
+                    break;
+                case BOT_CLASS_MAGE:
+                    //Student of the Mind
+                    if (lvl >= 20)
+                        fval *= 1.1f;
+                    break;
+                case BOT_CLASS_DRUID:
+                    //Survival of the Fittest, Improved Mark of the Wild
+                    if (lvl >= 35 && _spec == BOT_SPEC_DRUID_FERAL)
+                        fval *= 1.08f;
+                    else if (lvl >= 10)
+                        fval *= 1.02f;
+                    //Living Spirit
+                    if (lvl >= 40 && _spec == BOT_SPEC_DRUID_RESTORATION)
+                        fval *= 1.15f;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        default:
+            break;
+    }
+
+    return fval;
+}
+
+inline float bot_ai::_getRatingMultiplier(CombatRating cr) const
+{
+    GtCombatRatingsEntry const* Rating = sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL + (me->GetLevel()-1));
+    GtOCTClassCombatRatingScalarEntry const* classRating = sGtOCTClassCombatRatingScalarStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_RATING + cr + 1);
+    if (!Rating || !classRating)
+        return 1.0f;
+
+    return classRating->Data / Rating->Data;
+}
+
+float bot_ai::_getStatScore(uint8 stat) const
+{
+    static const float fone = 1.0f;
+    static const float fzero = 0.0f;
+
+    float tankMod = IsTank() ? fone : fzero;
+    float healMod = HasRole(BOT_ROLE_HEAL) ? fone : fzero;
+    float castMod = IsCastingClass(_botclass) ? fone : fzero;
+    float spiritMod = (_botclass == BOT_CLASS_PRIEST || _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK || (_botclass == BOT_CLASS_DRUID && _spec != BOT_SPEC_DRUID_FERAL)) ? fone : fzero;
+    float dpsMod = HasRole(BOT_ROLE_DPS) ? fone : fzero;
+    float meleeMod = !HasRole(BOT_ROLE_RANGED) ? fone : fzero;
+    float manaMod = (_botclass == BOT_CLASS_DRUID || me->GetPowerType() == POWER_MANA) ? fone : fzero;
+
+    switch (stat)
+    {
+        case BOT_STAT_MOD_MANA:
+            return 0.1f * manaMod;
+        case BOT_STAT_MOD_HEALTH:
+            return 0.1f;
+        case BOT_STAT_MOD_AGILITY:
+            return _botclass == BOT_CLASS_ROGUE ? 1.2f * dpsMod * meleeMod : (_botclass == BOT_CLASS_HUNTER ? 1.0f : 0.5f) * dpsMod;
+        case BOT_STAT_MOD_STRENGTH:
+            return (IsMeleeClass(_botclass) ? 1.0f : 0.5f) * dpsMod * meleeMod;
+        case BOT_STAT_MOD_INTELLECT:
+            return 1.0f * castMod;
+        case BOT_STAT_MOD_SPIRIT:
+            return 1.0f * spiritMod;
+        case BOT_STAT_MOD_STAMINA:
+            return IsTank() ? 2.0f : 1.0f;
+        case BOT_STAT_MOD_DEFENSE_SKILL_RATING:
+            return 2.0f * tankMod;
+        case BOT_STAT_MOD_DODGE_RATING:
+        case BOT_STAT_MOD_PARRY_RATING:
+            return 2.0f * tankMod;
+        case BOT_STAT_MOD_BLOCK_RATING:
+            return CanBlock() ? 2.0f : 0.0f * tankMod;
+        case BOT_STAT_MOD_BLOCK_VALUE:
+            return CanBlock() ? 0.67f : 0.0f * tankMod;
+        case BOT_STAT_MOD_HIT_TAKEN_RATING:
+        case BOT_STAT_MOD_CRIT_TAKEN_RATING:
+            return 1.0f * tankMod;
+        case BOT_STAT_MOD_HIT_TAKEN_MELEE_RATING:
+        case BOT_STAT_MOD_HIT_TAKEN_RANGED_RATING:
+        case BOT_STAT_MOD_HIT_TAKEN_SPELL_RATING:
+        case BOT_STAT_MOD_CRIT_TAKEN_MELEE_RATING:
+        case BOT_STAT_MOD_CRIT_TAKEN_RANGED_RATING:
+        case BOT_STAT_MOD_CRIT_TAKEN_SPELL_RATING:
+            return 0.4f * tankMod;
+        case BOT_STAT_MOD_ARMOR:
+            return 0.05f * tankMod;
+        case BOT_STAT_MOD_HIT_MELEE_RATING:
+        case BOT_STAT_MOD_HIT_RANGED_RATING:
+        case BOT_STAT_MOD_HIT_SPELL_RATING:
+            return 1.0f * dpsMod;
+        case BOT_STAT_MOD_CRIT_MELEE_RATING:
+        case BOT_STAT_MOD_CRIT_RANGED_RATING:
+        case BOT_STAT_MOD_CRIT_SPELL_RATING:
+        case BOT_STAT_MOD_HASTE_MELEE_RATING:
+        case BOT_STAT_MOD_HASTE_RANGED_RATING:
+        case BOT_STAT_MOD_HASTE_SPELL_RATING:
+        case BOT_STAT_MOD_HIT_RATING:
+        case BOT_STAT_MOD_CRIT_RATING:
+        case BOT_STAT_MOD_HASTE_RATING:
+            return HasRole(BOT_ROLE_DPS|BOT_ROLE_HEAL) ? 1.0f : 0.0f;
+        case BOT_STAT_MOD_EXPERTISE_RATING:
+            return 2.0f * dpsMod * meleeMod;
+        case BOT_STAT_MOD_ATTACK_POWER:
+            return ((IsMeleeClass(_botclass) || _botclass == BOT_CLASS_HUNTER) ? 0.43f : 0.1f) * dpsMod;
+        case BOT_STAT_MOD_RANGED_ATTACK_POWER:
+            switch (_botclass)
+            {
+                case BOT_CLASS_HUNTER: case BOT_CLASS_DARK_RANGER: case BOT_CLASS_SEA_WITCH:    return 0.43f * dpsMod;
+                case BOT_CLASS_PRIEST: case BOT_CLASS_MAGE: case BOT_CLASS_WARLOCK:             return 0.15f * dpsMod;
+                default:                                                                        return 0.0f;
+            }
+        case BOT_STAT_MOD_FERAL_ATTACK_POWER:
+            return _spec == BOT_SPEC_DRUID_FERAL ? 0.43f : 0.0f;
+        case BOT_STAT_MOD_SPELL_HEALING_DONE:
+            return 1.25f * healMod;
+        case BOT_STAT_MOD_SPELL_DAMAGE_DONE:
+            return 1.25f * dpsMod * castMod;
+        case BOT_STAT_MOD_MANA_REGENERATION:
+            return _botclass == BOT_CLASS_SPHYNX ? 0.0f : 1.2f * manaMod;
+        case BOT_STAT_MOD_ARMOR_PENETRATION_RATING:
+            return 2.0f * dpsMod * meleeMod;
+        case BOT_STAT_MOD_SPELL_POWER:
+            return 1.25f * castMod;
+        case BOT_STAT_MOD_HEALTH_REGEN:
+            return 0.33f * tankMod;
+        case BOT_STAT_MOD_SPELL_PENETRATION:
+            return 1.2f * castMod * dpsMod;
+        case BOT_STAT_MOD_DAMAGE_MIN:
+        case BOT_STAT_MOD_DAMAGE_MAX:
+            return ((IsMeleeClass(_botclass) || _botclass == BOT_CLASS_HUNTER) ? 0.33f : 0.0f) * dpsMod;
+        case BOT_STAT_MOD_RESIST_HOLY:
+        case BOT_STAT_MOD_RESIST_FIRE:
+        case BOT_STAT_MOD_RESIST_NATURE:
+        case BOT_STAT_MOD_RESIST_FROST:
+        case BOT_STAT_MOD_RESIST_SHADOW:
+        case BOT_STAT_MOD_RESIST_ARCANE:
+            return IsTank() ? 1.25f : 0.25f;
+        default:
+            return 0.0f;
+    }
+}
+
+float bot_ai::_getItemGearScore(Item const* item, uint8 forslot) const
+{
+    if (!item)
+        return 0.0f;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return 0.0f;
+
+    //TC_LOG_ERROR("scripts", "_getItemGearScore for %u - %s", item->GetEntry(), proto->Name1.c_str());
+
+    ItemStatBonus istats = {};
+    //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+    //    TC_LOG_ERROR("scripts", "_getItemGearScore at %u %i", uint32(i), istats[i]);
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+
+    uint32 ssd_level = me->GetLevel();
+    if (ssd && ssd_level > ssd->Maxlevel)
+        ssd_level = ssd->Maxlevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val      = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatID[i] < 0)
+                continue;
+            statType = ssd->StatID[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Bonus[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        istats[statType] += val;
+    }
+
+    istats[BOT_STAT_MOD_RESIST_HOLY] += proto->HolyRes;
+    istats[BOT_STAT_MOD_RESIST_FIRE] += proto->FireRes;
+    istats[BOT_STAT_MOD_RESIST_NATURE] += proto->NatureRes;
+    istats[BOT_STAT_MOD_RESIST_FROST] += proto->FrostRes;
+    istats[BOT_STAT_MOD_RESIST_SHADOW] += proto->ShadowRes;
+    istats[BOT_STAT_MOD_RESIST_ARCANE] += proto->ArcaneRes;
+
+    istats[BOT_STAT_MOD_ARMOR] += proto->Armor;
+    istats[BOT_STAT_MOD_BLOCK_VALUE] += proto->Block;
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    if (item->GetEntry() != einfo->ItemEntry[forslot])
+    {
+        if (ssv)
+        {
+            float average = ssv->getDPSMod(proto->ScalingStatValue) * proto->Delay / 1000.0f;
+            istats[BOT_STAT_MOD_DAMAGE_MIN] += 0.7f * average;
+            istats[BOT_STAT_MOD_DAMAGE_MIN] += 1.3f * average;
+        }
+        else
+        {
+            istats[BOT_STAT_MOD_DAMAGE_MIN] += proto->Damage[0].DamageMin + proto->Damage[1].DamageMin;
+            istats[BOT_STAT_MOD_DAMAGE_MAX] += proto->Damage[0].DamageMax + proto->Damage[1].DamageMax;
+        }
+
+        if (_botclass == BOT_CLASS_DRUID)
+        {
+            int32 dpsMod = 0;
+            int32 feral_bonus = 0;
+
+            if (ssv)
+            {
+                dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+                feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+            }
+
+            feral_bonus += proto->getFeralBonus(dpsMod);
+            if (feral_bonus)
+                istats[BOT_STAT_MOD_FERAL_ATTACK_POWER] += feral_bonus;
+        }
+    }
+
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+    {
+        EnchantmentSlot eslot = EnchantmentSlot(i);
+        uint32 enchant_id = item->GetEnchantmentId(eslot);
+        if (!enchant_id)
+            continue;
+
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        uint32 enchant_display_type;
+        uint32 enchant_amount;
+        uint32 enchant_spell_id;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            enchant_display_type = pEnchant->Effect[s];
+            enchant_amount = pEnchant->EffectPointsMin[s];
+            enchant_spell_id = pEnchant->EffectArg[s];
+
+            switch (enchant_display_type)
+            {
+                case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                    istats[BOT_STAT_MOD_DAMAGE_MIN] += enchant_amount;
+                    istats[BOT_STAT_MOD_DAMAGE_MAX] += enchant_amount;
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                    if (!enchant_amount)
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            for (uint8 k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->Enchantment[k] == enchant_id)
+                                {
+                                    enchant_amount = uint32((item_rand->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    istats[BOT_STAT_MOD_RESISTANCE_START + enchant_spell_id] += enchant_amount;
+                    break;
+                case ITEM_ENCHANTMENT_TYPE_STAT:
+                {
+                    if (!enchant_amount)
+                    {
+                        ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand_suffix)
+                        {
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand_suffix->Enchantment[k] == enchant_id)
+                                {
+                                    enchant_amount = uint32((item_rand_suffix->AllocationPct[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+
+                    switch (enchant_spell_id)
+                    {
+                        case ITEM_MOD_MANA:
+                        case ITEM_MOD_HEALTH:
+                        case ITEM_MOD_AGILITY:
+                        case ITEM_MOD_STRENGTH:
+                        case ITEM_MOD_INTELLECT:
+                        case ITEM_MOD_SPIRIT:
+                        case ITEM_MOD_STAMINA:
+                        case ITEM_MOD_DEFENSE_SKILL_RATING:
+                        case ITEM_MOD_DODGE_RATING:
+                        case ITEM_MOD_PARRY_RATING:
+                        case ITEM_MOD_BLOCK_RATING:
+                        case ITEM_MOD_HIT_MELEE_RATING:
+                        case ITEM_MOD_HIT_RANGED_RATING:
+                        case ITEM_MOD_HIT_SPELL_RATING:
+                        case ITEM_MOD_CRIT_MELEE_RATING:
+                        case ITEM_MOD_CRIT_RANGED_RATING:
+                        case ITEM_MOD_CRIT_SPELL_RATING:
+                        case ITEM_MOD_HASTE_MELEE_RATING:
+                        case ITEM_MOD_HASTE_RANGED_RATING:
+                        case ITEM_MOD_HASTE_SPELL_RATING:
+                        case ITEM_MOD_HIT_RATING:
+                        case ITEM_MOD_CRIT_RATING:
+                        case ITEM_MOD_HASTE_RATING:
+                        case ITEM_MOD_RESILIENCE_RATING:
+                        case ITEM_MOD_EXPERTISE_RATING:
+                        case ITEM_MOD_ATTACK_POWER:
+                        case ITEM_MOD_RANGED_ATTACK_POWER:
+                        case ITEM_MOD_MANA_REGENERATION:
+                        case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                        case ITEM_MOD_SPELL_POWER:
+                        case ITEM_MOD_HEALTH_REGEN:
+                        case ITEM_MOD_SPELL_PENETRATION:
+                        case ITEM_MOD_BLOCK_VALUE:
+                            istats[enchant_spell_id] += enchant_amount;
+                            break;
+                        default:
+                            break;
+                    }
+                    break;
+                }
+            }
+        }
+    }
+
+    //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+    //    TC_LOG_ERROR("scripts", "_getItemGearScore total %u %i", uint32(i), istats[i]);
+
+    //stats are fetched, not calculate
+    float itemScore = 0.0f;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        itemScore += istats[i] * _getStatScore(i);
+
+    //TC_LOG_ERROR("scripts", "_getItemGearScore total score %.3f", itemScore);
+    return itemScore;
+}
+
+void bot_ai::_saveStats()
+{
+    NpcBotStats stats;
+    stats.entry = me->GetEntry();
+    stats.maxhealth = me->GetMaxHealth();
+    stats.maxpower = me->GetMaxPower(_botclass == BOT_CLASS_DRUID ? POWER_MANA : me->GetPowerType());
+    stats.strength = GetTotalBotStat(BOT_STAT_MOD_STRENGTH);
+    stats.agility = GetTotalBotStat(BOT_STAT_MOD_AGILITY);
+    stats.stamina = GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+    stats.intellect = GetTotalBotStat(BOT_STAT_MOD_INTELLECT);
+    stats.spirit = GetTotalBotStat(BOT_STAT_MOD_SPIRIT);
+    stats.armor = me->GetArmor();
+    stats.defense = me->GetDefenseSkillValue();
+    stats.resHoly = me->GetResistance(SPELL_SCHOOL_HOLY) + resistbonus[SPELL_SCHOOL_HOLY-1];
+    stats.resFire = me->GetResistance(SPELL_SCHOOL_FIRE) + resistbonus[SPELL_SCHOOL_FIRE-1];
+    stats.resNature = me->GetResistance(SPELL_SCHOOL_NATURE) + resistbonus[SPELL_SCHOOL_NATURE-1];
+    stats.resFrost = me->GetResistance(SPELL_SCHOOL_FROST) + resistbonus[SPELL_SCHOOL_FROST-1];
+    stats.resShadow = me->GetResistance(SPELL_SCHOOL_SHADOW) + resistbonus[SPELL_SCHOOL_SHADOW-1];
+    stats.resArcane = me->GetResistance(SPELL_SCHOOL_ARCANE) + resistbonus[SPELL_SCHOOL_ARCANE-1];
+    stats.blockPct = me->GetUnitBlockChance(BASE_ATTACK, me);
+    stats.dodgePct = me->GetUnitDodgeChance(BASE_ATTACK, me);
+    stats.parryPct = me->GetUnitParryChance(BASE_ATTACK, me);
+    stats.critPct = crit + me->GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT) + me->GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
+    stats.attackPower = me->GetTotalAttackPowerValue(BASE_ATTACK);
+    stats.spellPower = me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);
+    stats.spellPen = spellpen;
+    stats.hastePct = std::max<float>(haste, 0.f);
+    stats.hitBonusPct = std::max<float>(hit, 0.f);
+    stats.expertise = expertise;
+    stats.armorPenPct = me->GetCreatureArmorPenetrationCoef();
+
+    BotDataMgr::SaveNpcBotStats(&stats);
+}
+
+//!Copied from Player::CastItemUseSpell
+void bot_ai::_castBotItemUseSpell(Item const* item, SpellCastTargets const& targets/*, uint8 cast_count, uint32 glyphIndex*/)
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    // use triggered flag only for items with many spell casts and for not first cast
+    uint8 count = 0;
+
+    // item spells casted at use
+    SpellInfo const* spellInfo;
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+        if (!spellData.SpellId || spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_USE)
+            continue;
+
+        spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        Spell* spell = new Spell(me, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+        //spell->m_CastItem = item; // DO NOT TAKE ITEM
+        //spell->m_cast_count = cast_count;                   // set count of casts
+        //spell->m_glyphIndex = glyphIndex;                   // glyph index
+        spell->prepare(targets);
+        ++count;
+    }
+
+    // Item enchantments spells casted at use
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->Effect[s] != ITEM_ENCHANTMENT_TYPE_USE_SPELL)
+                continue;
+
+            spellInfo = sSpellMgr->GetSpellInfo(pEnchant->EffectArg[s]);
+            if (!spellInfo)
+                continue;
+
+            Spell* spell = new Spell(me, spellInfo, (count > 0) ? TRIGGERED_FULL_MASK : TRIGGERED_NONE);
+            //spell->m_CastItem = item; // DO NOT TAKE ITEM
+            //spell->m_cast_count = cast_count;               // set count of casts
+            //spell->m_glyphIndex = glyphIndex;               // glyph index
+            spell->prepare(targets);
+            ++count;
+        }
+    }
+}
+
+Item* bot_ai::GetEquipsByGuid(ObjectGuid itemGuid) const
+{
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        if (Item* item = _equips[i])
+            if (item->GetGUID() == itemGuid)
+                return item;
+    }
+
+    return nullptr;
+}
+
+uint32 bot_ai::GetEquipDisplayId(uint8 slot) const
+{
+    uint32 displayId = 0;
+    if (_equips[slot])
+    {
+        NpcBotTransmogData const* transmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+        if (transmogData && BotMgr::IsTransmogEnabled() &&
+            (_equips[slot]->GetTemplate()->ItemId == transmogData->transmogs[slot].first || BotMgr::TransmogUseEquipmentSlots()))
+        {
+            uint32 item_id = transmogData->transmogs[slot].second;
+            if (ItemTemplate const* proto = item_id ? sObjectMgr->GetItemTemplate(item_id) : nullptr)
+            {
+                displayId = proto->DisplayInfoID;
+            }
+            else if (item_id != 0)
+            {
+                TC_LOG_ERROR("scripts", "bot_ai::GetEquipDisplayId(): ivalid item Id %u for bot %u %s slot %u",
+                    item_id, me->GetEntry(), me->GetName().c_str(), uint32(slot));
+            }
+        }
+        if (!displayId)
+            displayId = _equips[slot]->GetTemplate()->DisplayInfoID;
+    }
+
+    return displayId;
+}
+
+bool bot_ai::UnEquipAll(ObjectGuid receiver)
+{
+    bool suc = true;
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        if (!(i <= BOT_SLOT_RANGED ? _resetEquipment(i, receiver) : _unequip(i, receiver)))
+        {
+            suc = false;
+            break;
+        }
+    }
+
+    return suc;
+}
+
+bool bot_ai::HasRealEquipment() const
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo, "Trying to call HasRealEquipment for bot with no equip info!");
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        if (Item const* item = GetEquips(i))
+        {
+            if (i > BOT_SLOT_RANGED || einfo->ItemEntry[i] != item->GetEntry())
+                return true;
+        }
+    }
+
+    return false;
+}
+
+float bot_ai::GetAverageItemLevel() const
+{
+    float sum = 0.f;
+    uint32 count = 0;
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        if (_equips[i] && !(/*i == BOT_SLOT_TABARD || */i == BOT_SLOT_OFFHAND || i == BOT_SLOT_RANGED || i == BOT_SLOT_BODY))
+        {
+            if (ItemTemplate const* itemProto = _equips[i]->GetTemplate())
+            {
+                ++count;
+                sum += itemProto->GetItemLevelIncludingQuality();
+            }
+        }
+    }
+
+    return !count ? 0.f : (sum / float(count));
+}
+/////////
+//ROLES//
+/////////
+GossipOptionIcon bot_ai::GetRoleIcon(uint32 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+uint32 bot_ai::GetRoleString(uint32 role)
+{
+    switch (role)
+    {
+        case BOT_ROLE_TANK:                 return BOT_TEXT_TANK;
+        case BOT_ROLE_TANK_OFF:             return BOT_TEXT_TANK_OFF;
+        case BOT_ROLE_DPS:                  return BOT_TEXT_DPS;
+        case BOT_ROLE_HEAL:                 return BOT_TEXT_HEAL;
+        case BOT_ROLE_RANGED:               return BOT_TEXT_RANGED;
+        case BOT_ROLE_GATHERING_MINING:     return BOT_TEXT_MINER;
+        case BOT_ROLE_GATHERING_HERBALISM:  return BOT_TEXT_HERBALIST;
+        case BOT_ROLE_GATHERING_SKINNING:   return BOT_TEXT_SKINNER;
+        case BOT_ROLE_GATHERING_ENGINEERING:return BOT_TEXT_ENGINEER;
+        case BOT_ROLE_AUTOLOOT:             return BOT_TEXT_LOOTING;
+        case BOT_ROLE_AUTOLOOT_POOR:        return BOT_TEXT_POOR;
+        case BOT_ROLE_AUTOLOOT_COMMON:      return BOT_TEXT_COMMON;
+        case BOT_ROLE_AUTOLOOT_UNCOMMON:    return BOT_TEXT_UNCOMMON;
+        case BOT_ROLE_AUTOLOOT_RARE:        return BOT_TEXT_RARE;
+        case BOT_ROLE_AUTOLOOT_EPIC:        return BOT_TEXT_EPIC;
+        case BOT_ROLE_AUTOLOOT_LEGENDARY:   return BOT_TEXT_LEGENDARY;
+        default:                            return BOT_TEXT_UNKNOWN;
+    }
+}
+
+void bot_ai::ToggleRole(uint32 role, bool force)
+{
+    if (!force && roleTimer > lastdiff)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    if (HasRole(role))
+    {
+        //linked roles
+        if (role & BOT_ROLE_TANK)
+            role |= BOT_ROLE_TANK_OFF;
+
+        _roleMask &= ~role;
+    }
+    else
+    {
+        //linked roles
+        if (role & BOT_ROLE_TANK_OFF)
+            role |= BOT_ROLE_TANK;
+
+        _roleMask |= role;
+    }
+
+    BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_ROLES, &_roleMask);
+
+    //Update passives
+    shouldUpdateStats = true;
+}
+
+uint32 bot_ai::DefaultRolesForClass(uint8 m_class)
+{
+    uint32 roleMask = BOT_ROLE_DPS;
+
+    if (!bot_ai::IsMeleeClass(m_class))
+        roleMask |= BOT_ROLE_RANGED;
+    if (bot_ai::IsHealingClass(m_class))
+        roleMask |= BOT_ROLE_HEAL;
+
+    return roleMask;
+}
+
+bool bot_ai::IsTank(Unit const* unit) const
+{
+    if (!unit || unit == me)
+        return HasRole(BOT_ROLE_TANK);
+
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINTANK;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool bot_ai::IsOffTank(Unit const* unit) const
+{
+    if (!unit || unit == me)
+        return HasRole(BOT_ROLE_TANK_OFF);
+
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK_OFF);
+
+    //Unused part
+    if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINASSIST;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool bot_ai::CCed(Unit const* target, bool root)
+{
+    return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && (target->HasUnitState(UNIT_STATE_ROOT) || target->IsFrozen() || target->IsRooted())) : true;
+}
+//AI initialization common
+//Called at ai reset, level change (spawned = true)
+void bot_ai::DefaultInit()
+{
+    //only once
+    if (spawned) return;
+    spawned = true;
+
+    if (!firstspawn)
+    {
+        me->RemoveAllAurasExceptType(SPELL_AURA_CONTROL_VEHICLE);
+        RemoveItemClassEnchants(); //clear rogue poisons / shaman ecnhants
+        ApplyItemsSpells(); //restore item equip spells
+    }
+
+    //bot needs to be either directly controlled by player of have pvp flag to be a valid assist target (buffs, heals, etc.)
+    me->SetPvP(master->IsPvP());
+    me->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+    if (sWorld->IsFFAPvPRealm())
+        me->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+    else if (IAmFree())
+        me->SetByteFlag(UNIT_FIELD_BYTES_2, 1, 0);
+
+    if (firstspawn)
+        InitRace();
+
+    InitSpec();
+    InitRoles();
+    SetStats(true); // Class passives included
+
+    if (!IsTempBot())
+        ApplyRacials();
+
+    if (firstspawn)
+    {
+        firstspawn = false;
+        ASSERT(!me->GetBotAI());
+        ASSERT(!me->GetBotPetAI());
+        me->SetBotAI(this);
+
+        if (!IsTempBot())
+        {
+            InitFaction();
+            InitOwner();
+            InitEquips();
+        }
+    }
+}
+
+void bot_ai::ApplyRacials()
+{
+    uint8 myrace = me->GetRace();
+    switch (myrace)
+    {
+        case RACE_HUMAN:
+            RefreshAura(20598); //Human Spirit
+            RefreshAura(20864); //Mace Specialization
+            RefreshAura(20597); //Sword Specialization
+            //RefreshAura(58985); //Perception pointless
+            if (firstspawn)
+                InitSpellMap(RACIAL_EVERY_MAN_FOR_HIMSELF, true, false);
+            break;
+        case RACE_ORC:
+            RefreshAura(20573); //Hardiness
+            RefreshAura(20574); //Axe Specialization
+            //Blood Fury
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        case RACE_DWARF:
+            RefreshAura(20595); //Gun Specialization
+            RefreshAura(59224); //Mace Specialization
+            RefreshAura(20596); //Frost Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_STONEFORM, true, false);
+            break;
+        case RACE_NIGHTELF:
+            RefreshAura(20583); //Nature Resistance
+            RefreshAura(20582); //Quickness
+            InitSpellMap(RACIAL_SHADOWMELD, true, false);
+            break;
+        case RACE_UNDEAD_PLAYER:
+            RefreshAura(20579); //Shadow Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_WILL_OF_THE_FORSAKEN, true, false);
+            //cannibalize is skipped
+            break;
+        case RACE_TAUREN:
+            RefreshAura(20550); //Endurance
+            RefreshAura(20551); //Nature Resistance
+            if (firstspawn)
+                InitSpellMap(RACIAL_WARSTOMP, true, false);
+            break;
+        case RACE_GNOME:
+            RefreshAura(20552); //Arcane Resistance
+            RefreshAura(20591); //Expansive Mind
+            if (firstspawn)
+                InitSpellMap(RACIAL_ESCAPE_ARTIST, true, false);
+            break;
+        case RACE_TROLL:
+            RefreshAura(20557); //Beast Slaying
+            RefreshAura(20558); //Thrown Specialization
+            RefreshAura(26290); //Bow Specialization
+            RefreshAura(58943); //Da Voodoo Shuffle
+            RefreshAura(20555); //Regeneration
+            if (firstspawn)
+                InitSpellMap(RACIAL_BERSERKING, true, false);
+            break;
+        case RACE_BLOODELF:
+            RefreshAura(822); //Magic Resistance
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        case RACE_DRAENEI:
+            RefreshAura(6562); //Heroic Presence (28878 is not present)
+            RefreshAura(20579); //Shadow Resistance (universal since creatures do not lose cast time on damage anyways)
+            if (firstspawn)
+                InitSpellMap(RaceSpellForClass(myrace, _botclass), true, false);
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "bot_ai::ApplyRacePassives(): unknown race %u for bot %s (%u)", uint32(me->GetRace()), me->GetName().c_str(), me->GetEntry());
+            return;
+    }
+}
+
+void bot_ai::InitFaction()
+{
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData, "bot_ai::InitFaction(): data not found!");
+
+    uint32 faction = npcBotData->faction;
+
+    //if (faction == 14)
+    //    faction = 35;
+
+    me->SetFaction(faction);
+    if (botPet)
+        botPet->SetFaction(faction);
+    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->faction = faction;
+}
+
+void bot_ai::InitRace()
+{
+    NpcBotExtras const* npcBotExtras = BotDataMgr::SelectNpcBotExtras(me->GetEntry());
+    ASSERT(npcBotExtras, "bot_ai::InitRace: extra data not found!");
+
+    me->SetByteValue(UNIT_FIELD_BYTES_0, 0, npcBotExtras->race); //set race
+}
+
+void bot_ai::InitOwner()
+{
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData, "bot_ai::InitOwner(): data not found!");
+
+    _ownerGuid = npcBotData->owner;
+}
+
+void bot_ai::InitRoles()
+{
+    if (IsTempBot())
+    {
+        _roleMask = BOT_ROLE_DPS;
+        return;
+    }
+    else if (IAmFree())
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+        {
+            if (_botclass != BOT_CLASS_DRUID || _spec == BOT_SPEC_DRUID_BALANCE)
+                _roleMask |= BOT_ROLE_RANGED;
+        }
+        //if (IsHealingClass(_botclass))
+        //    _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData, "bot_ai::InitRoles(): data not found!");
+
+    _roleMask = npcBotData->roles;
+}
+
+void bot_ai::InitSpec()
+{
+    uint8 spec;
+    if (_botclass >= BOT_CLASS_EX_START)
+        spec = BOT_SPEC_DEFAULT;
+    else if (IAmFree())
+    {
+        std::vector<uint8> specs;
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR: //arms, fury
+                specs.push_back(BOT_SPEC_WARRIOR_ARMS);
+                specs.push_back(BOT_SPEC_WARRIOR_FURY);
+                break;
+            case BOT_CLASS_PALADIN: //retri
+                specs.push_back(BOT_SPEC_PALADIN_RETRIBUTION);
+                break;
+            case BOT_CLASS_HUNTER: //any
+                specs.push_back(BOT_SPEC_HUNTER_BEASTMASTERY);
+                specs.push_back(BOT_SPEC_HUNTER_MARKSMANSHIP);
+                specs.push_back(BOT_SPEC_HUNTER_SURVIVAL);
+                break;
+            case BOT_CLASS_ROGUE: //any
+                specs.push_back(BOT_SPEC_ROGUE_ASSASINATION);
+                specs.push_back(BOT_SPEC_ROGUE_COMBAT);
+                specs.push_back(BOT_SPEC_ROGUE_SUBTLETY);
+                break;
+            case BOT_CLASS_PRIEST: //shadow
+                specs.push_back(BOT_SPEC_PRIEST_SHADOW);
+                break;
+            case BOT_CLASS_DEATH_KNIGHT: //any
+                specs.push_back(BOT_SPEC_DK_BLOOD);
+                specs.push_back(BOT_SPEC_DK_FROST);
+                specs.push_back(BOT_SPEC_DK_UNHOLY);
+                break;
+            case BOT_CLASS_SHAMAN: //elem, enh
+                specs.push_back(BOT_SPEC_SHAMAN_ELEMENTAL);
+                specs.push_back(BOT_SPEC_SHAMAN_ENHANCEMENT);
+                break;
+            case BOT_CLASS_MAGE: //fire, frost
+                specs.push_back(BOT_SPEC_MAGE_FIRE);
+                specs.push_back(BOT_SPEC_MAGE_FROST);
+                break;
+            case BOT_CLASS_WARLOCK: //affli, destr
+                specs.push_back(BOT_SPEC_WARLOCK_AFFLICTION);
+                specs.push_back(BOT_SPEC_WARLOCK_DESTRUCTION);
+                break;
+            case BOT_CLASS_DRUID: //balance, feral
+                specs.push_back(BOT_SPEC_DRUID_BALANCE);
+                specs.push_back(BOT_SPEC_DRUID_FERAL);
+                break;
+            default:
+                break;
+        }
+
+        if (specs.size() == 1)
+            spec = specs.front();
+        else if (specs.size() <= 3)
+        {
+            uint32 rand = urand(1,100);
+            if (specs.size() == 2)
+                spec = rand <= 50 ? specs[0] : specs[1];
+            else
+                spec = rand <= 33 ? specs[0] : rand <= 67 ? specs[1] : specs[2];
+        }
+        else
+            ASSERT(false, "bot_ai::InitSpec(): FIXME more than 3 specs to choose from!");
+    }
+    else
+    {
+        NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+        ASSERT(npcBotData, "bot_ai::InitSpec(): data not found!");
+
+        spec = npcBotData->spec;
+    }
+
+    //TC_LOG_ERROR("entities.unit", "bot_ai::InitSpec(): bot %u class %u spec: %u", me->GetEntry(), uint32(_botclass), uint32(spec));
+
+    if (spec < BOT_SPEC_BEGIN || spec > BOT_SPEC_END)
+    {
+        TC_LOG_ERROR("entities.unit", "bot_ai::InitSpec(): spec (%u) is out of range for bot %u! Falling to default (1)...",
+            uint32(spec), me->GetEntry());
+
+        spec = BOT_SPEC_DEFAULT;
+    }
+
+    SetSpec(spec, false);
+}
+
+void bot_ai::SetSpec(uint8 spec, bool activate)
+{
+    ASSERT(spec >= BOT_SPEC_BEGIN && spec <= BOT_SPEC_END);
+
+    _spec = spec;
+
+    if (activate)
+    {
+        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_SPEC, &spec);
+
+        UnsummonAll();
+        removeShapeshiftForm();
+        //from DefaultInit
+        me->RemoveAllAurasExceptType(SPELL_AURA_CONTROL_VEHICLE);
+        //RemoveItemClassEnchants();
+        ApplyItemsSpells();
+        ApplyRacials();
+        //from SetStats
+        //InitPowers();
+        InitSpells();
+        ApplyClassPassives();
+        InitHeals();
+
+        me->SetPower(POWER_MANA, 0);
+        me->SetPower(POWER_RAGE, 0);
+        me->SetPower(POWER_ENERGY, 0);
+    }
+}
+
+uint8 bot_ai::DefaultSpecForClass(uint8 m_class)
+{
+    uint8 spec = urand(1,3);
+    switch (m_class)
+    {
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+            spec += (m_class-1) * 3;
+            break;
+        case BOT_CLASS_DRUID:
+            spec += (m_class-2) * 3;
+            break;
+        default:
+            spec = uint8(BOT_SPEC_DEFAULT);
+            break;
+    }
+
+    return spec;
+}
+
+uint32 bot_ai::TextForSpec(uint8 spec)
+{
+    switch (spec)
+    {
+        case BOT_SPEC_WARRIOR_ARMS:         return BOT_TEXT_SPEC_ARMS;
+        case BOT_SPEC_WARRIOR_FURY:         return BOT_TEXT_SPEC_FURY;
+        case BOT_SPEC_WARRIOR_PROTECTION:   return BOT_TEXT_SPEC_PROTECTION;
+        case BOT_SPEC_PALADIN_HOLY:         return BOT_TEXT_SPEC_HOLY;
+        case BOT_SPEC_PALADIN_PROTECTION:   return BOT_TEXT_SPEC_PROTECTION;
+        case BOT_SPEC_PALADIN_RETRIBUTION:  return BOT_TEXT_SPEC_RETRIBUTION;
+        case BOT_SPEC_HUNTER_BEASTMASTERY:  return BOT_TEXT_SPEC_BEASTMASTERY;
+        case BOT_SPEC_HUNTER_MARKSMANSHIP:  return BOT_TEXT_SPEC_MARKSMANSHIP;
+        case BOT_SPEC_HUNTER_SURVIVAL:      return BOT_TEXT_SPEC_SURVIVAL;
+        case BOT_SPEC_ROGUE_ASSASINATION:   return BOT_TEXT_SPEC_ASSASINATION;
+        case BOT_SPEC_ROGUE_COMBAT:         return BOT_TEXT_SPEC_COMBAT;
+        case BOT_SPEC_ROGUE_SUBTLETY:       return BOT_TEXT_SPEC_SUBTLETY;
+        case BOT_SPEC_PRIEST_DISCIPLINE:    return BOT_TEXT_SPEC_DISCIPLINE;
+        case BOT_SPEC_PRIEST_HOLY:          return BOT_TEXT_SPEC_HOLY;
+        case BOT_SPEC_PRIEST_SHADOW:        return BOT_TEXT_SPEC_SHADOW;
+        case BOT_SPEC_DK_BLOOD:             return BOT_TEXT_SPEC_BLOOD;
+        case BOT_SPEC_DK_FROST:             return BOT_TEXT_SPEC_FROST;
+        case BOT_SPEC_DK_UNHOLY:            return BOT_TEXT_SPEC_UNHOLY;
+        case BOT_SPEC_SHAMAN_ELEMENTAL:     return BOT_TEXT_SPEC_ELEMENTAL;
+        case BOT_SPEC_SHAMAN_ENHANCEMENT:   return BOT_TEXT_SPEC_ENHANCEMENT;
+        case BOT_SPEC_SHAMAN_RESTORATION:   return BOT_TEXT_SPEC_RESTORATION;
+        case BOT_SPEC_MAGE_ARCANE:          return BOT_TEXT_SPEC_ARCANE;
+        case BOT_SPEC_MAGE_FIRE:            return BOT_TEXT_SPEC_FIRE;
+        case BOT_SPEC_MAGE_FROST:           return BOT_TEXT_SPEC_FROST;
+        case BOT_SPEC_WARLOCK_AFFLICTION:   return BOT_TEXT_SPEC_AFFLICTION;
+        case BOT_SPEC_WARLOCK_DEMONOLOGY:   return BOT_TEXT_SPEC_DEMONOLOGY;
+        case BOT_SPEC_WARLOCK_DESTRUCTION:  return BOT_TEXT_SPEC_DESTRUCTION;
+        case BOT_SPEC_DRUID_BALANCE:        return BOT_TEXT_SPEC_BALANCE;
+        case BOT_SPEC_DRUID_FERAL:          return BOT_TEXT_SPEC_FERAL;
+        case BOT_SPEC_DRUID_RESTORATION:    return BOT_TEXT_SPEC_RESTORATION;
+        case BOT_SPEC_DEFAULT: default:     return BOT_TEXT_SPEC_UNKNOWN;
+    }
+}
+
+bool bot_ai::IsValidSpecForClass(uint8 m_class, uint8 spec)
+{
+    switch (m_class)
+    {
+        case BOT_CLASS_WARRIOR:
+            switch (spec)
+            {
+                case BOT_SPEC_WARRIOR_ARMS:
+                case BOT_SPEC_WARRIOR_FURY:
+                case BOT_SPEC_WARRIOR_PROTECTION:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_PALADIN:
+            switch (spec)
+            {
+                case BOT_SPEC_PALADIN_HOLY:
+                case BOT_SPEC_PALADIN_PROTECTION:
+                case BOT_SPEC_PALADIN_RETRIBUTION:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_HUNTER:
+            switch (spec)
+            {
+                case BOT_SPEC_HUNTER_BEASTMASTERY:
+                case BOT_SPEC_HUNTER_MARKSMANSHIP:
+                case BOT_SPEC_HUNTER_SURVIVAL:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_ROGUE:
+            switch (spec)
+            {
+                case BOT_SPEC_ROGUE_ASSASINATION:
+                case BOT_SPEC_ROGUE_COMBAT:
+                case BOT_SPEC_ROGUE_SUBTLETY:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_PRIEST:
+            switch (spec)
+            {
+                case BOT_SPEC_PRIEST_DISCIPLINE:
+                case BOT_SPEC_PRIEST_HOLY:
+                case BOT_SPEC_PRIEST_SHADOW:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_DEATH_KNIGHT:
+            switch (spec)
+            {
+                case BOT_SPEC_DK_BLOOD:
+                case BOT_SPEC_DK_FROST:
+                case BOT_SPEC_DK_UNHOLY:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_SHAMAN:
+            switch (spec)
+            {
+                case BOT_SPEC_SHAMAN_ELEMENTAL:
+                case BOT_SPEC_SHAMAN_ENHANCEMENT:
+                case BOT_SPEC_SHAMAN_RESTORATION:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_MAGE:
+            switch (spec)
+            {
+                case BOT_SPEC_MAGE_ARCANE:
+                case BOT_SPEC_MAGE_FIRE:
+                case BOT_SPEC_MAGE_FROST:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_WARLOCK:
+            switch (spec)
+            {
+                case BOT_SPEC_WARLOCK_AFFLICTION:
+                case BOT_SPEC_WARLOCK_DEMONOLOGY:
+                case BOT_SPEC_WARLOCK_DESTRUCTION:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_DRUID:
+            switch (spec)
+            {
+                case BOT_SPEC_DRUID_BALANCE:
+                case BOT_SPEC_DRUID_FERAL:
+                case BOT_SPEC_DRUID_RESTORATION:
+                    return true;
+                default:
+                    break;
+            }
+            break;
+        case BOT_CLASS_BM:
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+        case BOT_CLASS_NECROMANCER:
+        case BOT_CLASS_SEA_WITCH:
+            return spec == BOT_SPEC_DEFAULT;
+        default:
+            break;
+    }
+    return false;
+}
+
+void bot_ai::InitEquips()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo, "Trying to spawn bot with no equip info!");
+
+    NpcBotData const* npcBotData = BotDataMgr::SelectNpcBotData(me->GetEntry());
+    ASSERT(npcBotData, "bot_ai::InitEquips(): data not found!");
+
+    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+    //        0            1                2      3         4        5      6             7                 8           9           10    11    12         13
+    //"SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid, itemEntry, owner_guid "
+    //  "FROM item_instance WHERE guid IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_SYNCH
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        stmt->setUInt32(i, npcBotData->equips[i]);
+
+    PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+
+    Field* fields2;
+    uint32 itemId;
+    uint32 itemGuidLow;
+    Item* item;
+
+    if (!iiresult) //blank bot - fill with standard items
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            itemId = einfo->ItemEntry[i];
+            if (!itemId)
+                continue;
+
+            item = Item::CreateItem(itemId, 1, nullptr);
+            ASSERT(item, "Failed to init standard Item for bot!");
+            _equips[i] = item;
+        }
+    }
+    else
+    {
+        do
+        {
+            fields2 = iiresult->Fetch();
+            itemGuidLow = fields2[11].GetUInt32();
+            itemId = fields2[12].GetUInt32();
+            item = new Item;
+            ASSERT(item->LoadFromDB(itemGuidLow, ObjectGuid::Empty, fields2, itemId));
+            //gonna find where to store our new item
+            bool found = false;
+            for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (npcBotData->equips[i] == itemGuidLow && !_equips[i])
+                {
+                    _equips[i] = item;
+                    found = true;
+                    break;
+                }
+            }
+            ASSERT(found);
+            //ItemTemplate const* proto = item->GetTemplate();
+            //TC_LOG_ERROR("entities.player", "minion_ai::InitEquips(): bot %s (id: %u): found item: for slot %u: %s (id: %u, guidLow: %u)",
+            //    me->GetName().c_str(), me->GetEntry(), i, proto->Name1.c_str(), itemId, itemGuidLow);
+
+        } while (iiresult->NextRow());
+    }
+
+    //visualize
+    for (uint8 i = BOT_SLOT_MAINHAND; i <= BOT_SLOT_RANGED; ++i)
+    {
+        if (CanChangeEquip(i) && _equips[i])
+        {
+            NpcBotTransmogData const* transmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+            if (einfo->ItemEntry[i] != _equips[i]->GetEntry() && transmogData && BotMgr::IsTransmogEnabled() && (transmogData->transmogs[i].first == _equips[i]->GetEntry() || BotMgr::TransmogUseEquipmentSlots()))
+                me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, transmogData->transmogs[i].second);
+            else
+                me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, _equips[i]->GetEntry());
+        }
+        else if (einfo->ItemEntry[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+    }
+
+    //apply weapons' parameters
+    if (Item const* MH = _equips[BOT_SLOT_MAINHAND])
+    {
+        itemId = MH->GetEntry();
+        if (einfo->ItemEntry[0] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (RespectEquipsAttackTime())
+                    me->SetAttackTime(BASE_ATTACK, proto->Delay);
+                ApplyItemBonuses(BOT_SLOT_MAINHAND);
+            }
+        }
+    }
+    if (Item const* OH = _equips[BOT_SLOT_OFFHAND])
+    {
+        itemId = OH->GetEntry();
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (einfo->ItemEntry[1] != itemId)
+                ApplyItemBonuses(BOT_SLOT_OFFHAND);
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (RespectEquipsAttackTime())
+                    me->SetAttackTime(OFF_ATTACK, proto->Delay);
+                me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+    }
+    if (Item const* RH = _equips[BOT_SLOT_RANGED])
+    {
+        itemId = RH->GetEntry();
+        if (einfo->ItemEntry[2] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON)
+                    if (RespectEquipsAttackTime())
+                        me->SetAttackTime(RANGED_ATTACK, proto->Delay);
+
+                ApplyItemBonuses(BOT_SLOT_RANGED);
+            }
+        }
+    }
+
+    for (uint8 i = BOT_SLOT_RANGED + 1; i != BOT_INVENTORY_SIZE; ++i)
+        ApplyItemBonuses(i);
+
+    ApplyItemSetBonuses(nullptr, true);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        if (_equips[i] == nullptr && einfo->ItemEntry[i] != 0)
+        {
+            if (i == BOT_SLOT_OFFHAND && !_canUseOffHand())
+                continue;
+
+            //if bot has no equips but equip template then use those
+            item = Item::CreateItem(einfo->ItemEntry[i], 1, nullptr);
+            ASSERT(item, "Failed to init standard Item for bot point 2!");
+            _equips[i] = item;
+
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+            if (i == BOT_SLOT_OFFHAND)
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                {
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        me->SetAttackTime(OFF_ATTACK, _botclass == BOT_CLASS_ROGUE ? 1400 : 1800);
+                        me->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void bot_ai::FindMaster()
+{
+    //totally free
+    if (!_ownerGuid)
+        return;
+    if (!_atHome || _evadeMode)
+        return;
+
+    //delay
+    if (checkMasterTimer > lastdiff)
+        return;
+
+    checkMasterTimer = urand(1000, 3000);
+
+    //already have master
+    if (!IAmFree())
+        return;
+    if (IsDuringTeleport())
+        return;
+
+    if (Player* player = ObjectAccessor::FindPlayerByLowGUID(_ownerGuid))
+    {
+        //prevent bot being screwed up because of wrong flags
+        if (player->IsGameMaster() || player->GetSession()->isLogingOut() || player->GetSession()->PlayerLogout())
+            return;
+
+        if (!SetBotOwner(player))
+            return; //fail
+
+        //if (!IsTempBot())
+        //    BotWhisper("Hey...", master);
+    }
+}
+
+bool bot_ai::IAmFree() const
+{
+    if (!_ownerGuid)
+        return true;
+    if (_ownerGuid != master->GetGUID().GetRawValue())
+        return true;
+    //if (!me->HasUnitTypeMask(UNIT_MASK_MINION))
+    //    return true;
+
+    return false;
+    //return (!_ownerGuid || _ownerGuid != master->GetGUID() || !me->HasUnitTypeMask(UNIT_MASK_MINION));
+    //        //has owner   and   //owner is found          and        //bound to owner
+}
+
+//UTILITIES
+void bot_ai::_AddItemTemplateLink(Player const* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ':';
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+// |TInterface\\Icons\\INV_<iconName>:<iconSize>|t|color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:suffix_factor:reporter_level|h[name]|h|r
+// |TInterface\\Icons\\INV_Misc_Staff_01:16|t|cffa335ee|Hitem:812:0:0:0:0:0:0:0:70|h[Glowing Brightwood Staff]|h|r
+void bot_ai::_AddItemLink(Player const* forPlayer, Item const* item, std::ostringstream &str, bool addIcon) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+    //ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    //uint32 bpoints = 0;
+    std::string name = proto->Name1;
+    std::string suffix = "";
+
+    //icon
+    if (addIcon)
+    {
+        ItemDisplayInfoEntry const* itemDisplayEntry = sItemDisplayInfoStore.LookupEntry(item->GetTemplate()->DisplayInfoID);
+        if (itemDisplayEntry)
+            str << "|TInterface\\Icons\\" << itemDisplayEntry->InventoryIcon << ":16|t";
+    }
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ':';
+
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ':';
+    //gems 3
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_ITEM_PROTO_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 0: g1 = eId;   break;
+            case 1: g2 = eId;   break;
+            case 2: g3 = eId;   break;
+        }
+    }
+    str << g1 << ':' << g2 << ':' << g3 << ':';
+    //always zero
+    str << 0 << ':';
+    //random property
+    str << item->GetItemRandomPropertyId() << ':';
+    str << item->GetItemSuffixFactor() << ':';
+
+    //reporter level
+    str << uint32(me->GetLevel());
+
+    //name
+    _LocalizeItem(forPlayer, name, suffix, item);
+
+    str << "|h[" << name;
+    if (suffix.length() > 0)
+        str << ' ' << suffix;
+    str <<"]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::_AddItemLink(): %s", str.str().c_str());
+}
+//Unused
+void bot_ai::_AddQuestLink(Player const* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+//Unsused
+void bot_ai::_AddWeaponSkillLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+//|cff71d5ff|Hspell:21563|h[Command]|h|r
+void bot_ai::_AddSpellLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color/* = true*/) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|c";
+
+    if (color)
+    {
+        switch (GetFirstSchoolInMask(spellInfo->GetSchoolMask()))
+        {
+            case SPELL_SCHOOL_NORMAL:       str << "ffffff00"; break; //YELLOW
+            case SPELL_SCHOOL_HOLY:         str << "ffffe680"; break; //LIGHT YELLOW
+            case SPELL_SCHOOL_FIRE:         str << "ffff8000"; break; //ORANGE
+            case SPELL_SCHOOL_NATURE:       str << "ff4dff4d"; break; //GREEN
+            case SPELL_SCHOOL_FROST:        str << "ff80ffff"; break; //LIGHT BLUE
+            case SPELL_SCHOOL_SHADOW:       str << "ff8080ff"; break; //DARK BLUE
+            case SPELL_SCHOOL_ARCANE:       str << "ffff80ff"; break; //LIGHT PURPLE
+            default:                        str << "ffffffff"; break; //UNK WHITE
+        }
+    }
+    else
+        str << "ffffffff"; //default white
+
+    str << "|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+//Unused
+void bot_ai::_AddProfessionLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUID().GetCounter() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->DisplayName[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player const* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeItem(Player const* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(item->GetEntry());
+    if (loc > 0 && itemInfo && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+
+    int32 randomPropId = item->GetItemRandomPropertyId();
+    //TC_LOG_ERROR("entities.player", "bot_ai::_LocalizeItem(): randomPropId = %i", randomPropId);
+    if (!randomPropId)
+        return;
+
+    if (randomPropId > 0)
+    {
+        if (ItemRandomPropertiesEntry const* item_rand = sItemRandomPropertiesStore.LookupEntry(randomPropId))
+        {
+            std::array<char const*, 16> const& suffs = item_rand->Name;
+            //if (suffs)
+            {
+                //for (uint8 i = 0; i != MAX_LOCALES; ++i)
+                //    TC_LOG_ERROR("entities.player", "bot_ai::_LocalizeItem(): rand prop suffix for loc %u = %s", i, suffs[i]);
+                suffix = suffs[loc];
+            }
+        }
+    }
+    else
+    {
+        if (ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(-randomPropId))
+        {
+            std::array<char const*, 16> const& suffs = item_rand->Name;
+            //if (suffs)
+            {
+                //for (uint8 i = 0; i != MAX_LOCALES; ++i)
+                //    TC_LOG_ERROR("entities.player", "bot_ai::_LocalizeItem(): rand suff suffix for loc %u = %s", i, suffs[i]);
+                suffix = suffs[loc];
+            }
+        }
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player const* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player const* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player const* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+void bot_ai::_LocalizeSpell(Player const* forPlayer, std::string &spellName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    std::wstring wnamepart;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(entry);
+    if (!spellInfo)
+    {
+        spellName = LocalizedNpcText(forPlayer, BOT_TEXT_UNKNOWN);
+        return;
+    }
+
+    std::string title = spellInfo->SpellName[loc];
+    if (Utf8FitTo(title, wnamepart))
+        spellName = title;
+    else
+        spellName = spellInfo->SpellName[sWorld->GetDefaultDbcLocale()];
+}
+
+void bot_ai::BotJump(Position const* pos)
+{
+    ++_jumpCount;
+
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(*pos, me->GetExactDist2d(pos->m_positionX, pos->m_positionY), 10.0f);
+
+    //float dx = pos->m_positionX - me->m_positionX;
+    //float dy = pos->m_positionY - me->m_positionY;
+    //float fdx = fabs(dx); float fdy = fabs(dy);
+    //float divider = fdx > 400 || fdy > 400 ? 5.0f : fdx > 200 || fdy > 200 ? 3.0f : fdx > 100 || fdy > 100 ? 2.0f : 1.5f;
+    //dx = dx / divider + me->m_positionX;
+    //dy = dy / divider + me->m_positionY;
+    //float z = me->GetMap()->GetHeight(dx, dy, std::max<float>(me->m_positionZ, pos->m_positionZ));
+
+    //if (z > INVALID_HEIGHT)
+    //    me->GetMotionMaster()->MoveJump(dx, dy, z, me->GetExactDist2d(dx, dy), 10.0f);
+}
+
+bool bot_ai::UpdateImpossibleChase(Unit const* target)
+{
+    if (_chaseTimer > lastdiff || me->isMoving() || !IAmFree())
+        return false;
+
+    if (JumpingOrFalling())
+        return false;
+
+    if (!me->IsWithinDist(target, HasRole(BOT_ROLE_RANGED) ? 75 : 50) || (me->GetDistance(target) < (HasRole(BOT_ROLE_RANGED) ? 35 : 10)))
+    {
+        ResetChaseTimer(target);
+        BotMovement(BOT_MOVE_POINT, target, nullptr, false);
+        //me->GetMotionMaster()->MovePoint(me->GetMapId(), *target, false);
+        return true;
+    }
+
+    if (_jumpCount >= 3)
+    {
+        me->AttackStop();
+        Evade();
+        return true;
+    }
+
+    ResetChaseTimer(target);
+    if (!HasRole(BOT_ROLE_RANGED))
+        BotJump(target);
+    return true;
+}
+
+void bot_ai::ResetChaseTimer(Position const* /*pos*/)
+{
+    _chaseTimer = 30000;//std::max<uint32>(5000, me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 400);
+    //me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 1000 / me->GetSpeed(MOVE_WALK);
+}
+
+void bot_ai::ResetChase(Position const* pos)
+{
+    if (!IAmFree())
+        return;
+
+    ResetChaseTimer(pos);
+    _jumpCount = 0;
+}
+
+void bot_ai::ResetEngageTimer(uint32 delay)
+{
+    _engageTimer = delay;
+}
+
+void bot_ai::OnStartAttack(Unit const* u)
+{
+    if (u->GetGUID() != _lastTargetGuid)
+    {
+        ResetChase(u);
+        _lastTargetGuid = u->GetGUID();
+    }
+}
+
+bool bot_ai::StartAttack(Unit const* u, bool force)
+{
+    if (HasBotCommandState(BOT_COMMAND_ATTACK) && !force)
+        return false;
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    OnStartAttack(u);
+    return true;
+}
+
+void bot_ai::JustEnteredCombat(Unit* u)
+{
+    _atHome = false;
+
+    //clear gossip during combat. See CheckAuras() for restore
+    if (me->HasNpcFlag(UNIT_NPC_FLAG_GOSSIP))
+        me->RemoveNpcFlag(UNIT_NPC_FLAG_GOSSIP);
+
+    _evadeMode = false;
+    AbortTeleport();
+
+    ResetChase(u);
+}
+//killer may be NULL
+void bot_ai::JustDied(Unit*)
+{
+    AbortTeleport();
+    AbortAwaitStateRemoval();
+    KillEvents(false);
+    CancelAllOrders();
+
+    if (me->GetVehicle())
+        me->ExitVehicle();
+
+    if (me->GetTransport())
+    {
+        me->ClearUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+        me->GetTransport()->RemovePassenger(me);
+    }
+
+    if (IsTempBot())
+    {
+        //TC_LOG_ERROR("entities.player", "Unsummoning temp bot %s (%s), owner: %s (%s)...",
+        //    me->GetName().c_str(), me->GetGUID().ToString().c_str(), master->GetName().c_str(), master->GetGUID().ToString().c_str());
+
+        if (!IAmFree())
+            master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_UNSUMMON);
+
+        me->AddObjectToRemoveList();
+        return;
+    }
+    else if (!IAmFree())
+    {
+        if (Group* gr = master->GetGroup())
+            if (gr->IsMember(me->GetGUID()))
+                gr->SendUpdate();
+    }
+
+    _reviveTimer = IAmFree() ? 180000 : 60000; //3min/1min
+    _atHome = false;
+    _evadeMode = false;
+    spawned = false;
+    _botAwaitState = BOT_AWAIT_NONE;
+
+    ++_deathsCount;
+}
+
+void bot_ai::KilledUnit(Unit* u)
+{
+    ++_killsCount;
+    if (u->IsControlledByPlayer() || u->IsPvP())
+        ++_pvpKillsCount;
+    if (u->isType(TYPEMASK_PLAYER))
+        ++_playerKillsCount;
+}
+
+void bot_ai::MoveInLineOfSight(Unit* /*u*/)
+{
+}
+
+void bot_ai::AttackStart(Unit* /*u*/)
+{
+}
+
+void bot_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+    {
+        if (Creature* cre = victim->ToCreature())
+        {
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(master);
+
+            //controlled case is handled in Unit::DealDamage
+            if (IAmFree())
+                cre->LowerPlayerDamageReq(cre->GetHealth() < damage ?  cre->GetHealth() : damage);
+        }
+    }
+
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        ResetChase(victim);
+}
+void bot_ai::OnBotSpellStart(SpellInfo const* spellInfo)
+{
+    OnClassSpellStart(spellInfo);
+}
+//This function is called after Spell::SendSpellCooldown() and Spell::DoAllEffects...() call
+void bot_ai::OnBotSpellGo(Spell const* spell, bool ok)
+{
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+
+    if (ok)
+    {
+        if (CanBotAttackOnVehicle())
+        {
+            //Set cooldown
+            if (!curInfo->IsCooldownStartedOnEvent() && !curInfo->IsPassive())
+            {
+                uint32 rec = curInfo->RecoveryTime;
+                uint32 catrec = curInfo->CategoryRecoveryTime;
+
+                if (rec > 0 || (!spell->GetCastTime() && curInfo->CalcCastTime()))
+                    ApplyBotSpellCooldownMods(curInfo, rec);
+                if (catrec > 0 && !(curInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
+                    ApplyBotSpellCategoryCooldownMods(curInfo, catrec);
+
+                SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+                SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+            }
+
+            if (curInfo->Id == PVPTRINKET)
+                SetSpellCooldown(PVPTRINKET, 120000);
+            if (IsPotionSpell(curInfo->Id))
+                StartPotionTimer();
+            if (curInfo->Id == ACTIVATE_SPEC)
+                SetSpec(_newspec);
+
+            OnClassSpellGo(curInfo);
+        }
+
+        if (me->GetVehicleCreatureBase() && me->GetVehicleCreatureBase()->HasSpell(curInfo->Id))
+        {
+            //delay next cast to allow cp to proc
+            if (curInfo->AttributesEx & (SPELL_ATTR1_REQ_COMBO_POINTS1|SPELL_ATTR1_REQ_COMBO_POINTS2))
+                GC_Timer = std::max<uint32>(2000, curInfo->StartRecoveryTime);
+            else if (curInfo->Speed > 0.0f)
+                GC_Timer = std::max<uint32>(1500, curInfo->StartRecoveryTime);
+            else
+                GC_Timer = curInfo->StartRecoveryTime;
+        }
+    }
+
+    if (HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) &&
+        !_orders.empty() && _orders.front()._type == BOT_ORDER_SPELLCAST &&
+        _orders.front().params.spellCastParams.baseSpell == curInfo->GetFirstRankSpell()->Id)
+    {
+        if (DEBUG_BOT_ORDERS)
+            TC_LOG_ERROR("entities.player", "doCast(): ordered spell %u by %s was %s!",
+                curInfo->Id, me->GetName().c_str(), ok ? "successful" : "unsuccessful");
+        CompleteOrder(_orders.front());
+    }
+}
+
+void bot_ai::OnBotOwnerSpellGo(Spell const* spell, bool ok)
+{
+    if (!ok)
+        return;
+
+    SpellInfo const* spellInfo = spell->GetSpellInfo();
+
+    if (spellInfo->IsPassive())
+        return;
+
+    //TC_LOG_ERROR("entities.player", "OnBotOwnerSpellGo(): %u by %s", spellInfo->Id, master->GetName().c_str());
+
+    if (spell->m_targets.HasDst() && HasBotAwaitState(BOT_AWAIT_SEND) && (me->GetTransport() == master->GetTransport()))
+    {
+        EventRemoveBotAwaitState(BOT_AWAIT_SEND);
+
+        Position const* spell_dest = spell->m_targets.GetDstPos();
+        if (me->GetExactDist(spell_dest) <= 70.f)
+        {
+            SetBotCommandState(BOT_COMMAND_STAY);
+            BotMovement(BOT_MOVE_POINT, spell_dest, nullptr, false);
+            if (botPet)
+            {
+                botPet->GetBotPetAI()->SetBotCommandState(BOT_COMMAND_STAY);
+                botPet->GetMotionMaster()->MovePoint(me->GetMapId(), *spell_dest, false);
+            }
+            BotWhisper("Moving to position!");
+        }
+        else
+            BotWhisper("Position is too far away!");
+    }
+
+    if (master->GetVehicle() && me->GetVehicle() && !master->HasSpell(spellInfo->Id) && !spell->m_targets.GetGOTargetGUID())
+    {
+        //if (((spellInfo->AttributesCu & SPELL_ATTR0_CU_DIRECT_DAMAGE) || spellInfo->HasAura(SPELL_AURA_PERIODIC_DAMAGE)) &&
+        //    (spell->m_targets.GetTargetMask() & TARGET_FLAG_UNIT) && spell->m_targets.GetUnitTargetGUID() && !me->GetVehicleBase()->GetTarget() &&
+        //    spell->m_targets.GetUnitTargetGUID() != master->GetVehicleBase()->GetGUID())
+        //{
+        //    //master->GetVehicleBase()->SetTarget(spell->m_targets.GetUnitTargetGUID());
+        //    me->GetVehicleBase()->SetTarget(spell->m_targets.GetUnitTargetGUID());
+        //    SetBotCommandState(BOT_COMMAND_ATTACK);
+        //    //hack
+        //    if (!me->GetVehicleBase()->GetVictim())
+        //    {
+        //        if (Unit* target = ObjectAccessor::GetUnit(*me->GetVehicleBase(), spell->m_targets.GetUnitTargetGUID()))
+        //            me->GetVehicleBase()->Attack(target, false);
+        //    }
+        //}
+
+        Vehicle const* veh = me->GetVehicle();
+        if (veh && veh->GetBase()->GetTypeId() == TYPEID_UNIT && curVehStrat == BOT_VEH_STRAT_GENERIC &&
+            veh->GetBase()->ToCreature()->HasSpell(spellInfo->Id))
+        {
+            SpellCastTargets targets;
+            if (spell->m_targets.HasDst())
+            {
+                targets.SetDst(spell->m_targets);
+                veh->GetBase()->ToCreature()->BotStopMovement();
+                float destangle = veh->GetBase()->GetAbsoluteAngle(spell->m_targets.GetDstPos());
+                if (veh->GetBase()->GetTransport())
+                    destangle = Position::NormalizeOrientation(destangle - veh->GetBase()->GetTransport()->GetOrientation());
+                veh->GetBase()->SetFacingTo(destangle);
+                //force orientation (inconsistent with SetFacingTo)
+                veh->GetBase()->SetOrientation(destangle);
+            }
+            if (spell->m_targets.GetSpeed() != 0)
+                targets.SetSpeed(spell->m_targets.GetSpeed());
+            if (spell->m_targets.GetElevation() != 0)
+                targets.SetElevation(spell->m_targets.GetElevation());
+            if (spell->m_targets.GetUnitTargetGUID())
+            {
+                if (Unit* target = ObjectAccessor::GetUnit(*veh->GetBase(), spell->m_targets.GetUnitTargetGUID()))
+                {
+                    targets.SetUnitTarget(target);
+                    veh->GetBase()->SetFacingTo(me->GetAbsoluteAngle(target));
+                }
+            }
+
+            //bug: gameobject damage is not sent to players (not visible in log)
+            //tempfix: set bot as original caster
+            Spell* vehspell = new Spell(veh->GetBase(), spellInfo, TRIGGERED_NONE/*, me->GetGUID()*/);
+            vehspell->prepare(targets);
+        }
+    }
+}
+
+void bot_ai::OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotSpellMap::const_iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        if (HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) &&
+            !_orders.empty() && _orders.front()._type == BOT_ORDER_SPELLCAST &&
+            _orders.front().params.spellCastParams.baseSpell == itr->first)
+        {
+            if (DEBUG_BOT_ORDERS)
+                TC_LOG_ERROR("entities.player", "doCast(): ordered spell %u was interrupted!", info->Id);
+            CompleteOrder(_orders.front());
+        }
+
+        itr->second->cooldown += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+
+    GC_Timer = 0; //reset global cooldown since cast is canceled
+}
+
+void bot_ai::CastBotItemCombatSpell(DamageInfo const& damageInfo)
+{
+    Unit* target = damageInfo.GetVictim();
+    if (!target || !target->IsAlive() || target == me)
+        return;
+
+    if (!me->CanUseAttackType(damageInfo.GetAttackType()))
+        return;
+
+    Item* item;
+    ItemTemplate const* proto;
+    int8 slot;
+    //int8 id = 1;
+    //EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        //skip standard items
+        //if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+        //    continue;
+
+        proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        // Additional check for weapons
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            // offhand item cannot proc from main hand hit etc
+            switch (damageInfo.GetAttackType())
+            {
+                case BASE_ATTACK:   slot = BOT_SLOT_MAINHAND;   break;
+                case OFF_ATTACK:    slot = BOT_SLOT_OFFHAND;    break;
+                case RANGED_ATTACK: slot = BOT_SLOT_RANGED;     break;
+                default:            slot = -1;                  break;
+            }
+            if (slot != i)
+                continue;
+        }
+
+        CastBotItemCombatSpell(damageInfo, item, proto);
+    }
+}
+
+void bot_ai::CastBotItemCombatSpell(DamageInfo const& damageInfo, Item* item, ItemTemplate const* proto)
+{
+    //TODO: custom spell triggers maybe?
+
+    // Can do effect if any damage done to target
+    bool canTrigger = (damageInfo.GetHitMask() & (PROC_HIT_NORMAL | PROC_HIT_CRITICAL | PROC_HIT_ABSORB)) != 0;
+    if (canTrigger)
+    {
+        for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = proto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            // wrong triggering type
+            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "WORLD: unknown Item spellid %i", spellData.SpellId);
+                continue;
+            }
+
+            float chance = (float)spellInfo->ProcChance;
+
+            if (spellData.SpellPPMRate)
+            {
+                uint32 WeaponSpeed = me->GetAttackTime(damageInfo.GetAttackType());
+                chance = me->GetPPMProcChance(WeaponSpeed, spellData.SpellPPMRate, spellInfo);
+            }
+            else if (chance > 100.0f)
+                chance = me->GetWeaponProcChance();
+
+            if (roll_chance_f(chance))
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(damageInfo.GetVictim(), spellInfo->Id, args);
+            }
+        }
+    }
+
+    // item combat enchantments
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->Effect[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                continue;
+
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+            if (entry && entry->HitMask)
+            {
+                // Check hit/crit/dodge/parry requirement
+                if ((entry->HitMask & damageInfo.GetHitMask()) == 0)
+                    continue;
+            }
+            else
+            {
+                // Can do effect if any damage done to target
+                if (!canTrigger)
+                    continue;
+            }
+
+            // check if enchant procs only on white hits
+            if (entry && (entry->AttributesMask & ENCHANT_PROC_ATTR_WHITE_HIT) && damageInfo.GetSpellInfo())
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->EffectArg[s]);
+            if (!spellInfo)
+                continue;
+
+            float chance = pEnchant->EffectPointsMin[s] != 0 ? float(pEnchant->EffectPointsMin[s]) : me->GetWeaponProcChance();
+            if (entry)
+            {
+                if (entry->ProcsPerMinute)
+                {
+                    chance = entry->ProcsPerMinute;
+                    //handle SPELLMOD_PROC_PER_MINUTE spellmods
+                    //Envenom
+                    if (_spec == BOT_SPEC_ROGUE_ASSASINATION && me->HasAuraTypeWithFamilyFlags(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_ROGUE, 0x800000))
+                        chance *= 1.75f;
+                    //Improved Poisons
+                    if (_spec == BOT_SPEC_ROGUE_ASSASINATION && me->GetLevel() >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x2000))
+                        chance *= 1.5f;
+
+                    chance = me->GetPPMProcChance(proto->Delay, chance, spellInfo);
+                }
+                else if (entry->Chance)
+                    chance = (float)entry->Chance;
+            }
+
+            // Apply SPELLMOD_CHANCE_OF_SUCCESS spell mods
+            //Envenom
+            if (_spec == BOT_SPEC_ROGUE_ASSASINATION && me->HasAuraTypeWithFamilyFlags(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_ROGUE, 0x800000))
+                chance += 15.f;
+            //Improved Poisons
+            if (_spec == BOT_SPEC_ROGUE_ASSASINATION && me->GetLevel() >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x10000))
+                chance += 20.f;
+
+            // Shiv has 100% chance to apply the poison
+            if (me->FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
+                chance = 100.0f;
+
+            if (roll_chance_f(chance))
+            {
+                CastSpellExtraArgs args(item);
+                me->CastSpell(spellInfo->IsPositive() ? me : damageInfo.GetVictim(), spellInfo->Id, args);
+            }
+        }
+    }
+}
+//ORDERS
+bool bot_ai::AddOrder(BotOrder&& order)
+{
+    if (_orders.size() >= MAX_BOT_ORDERS_QUEUE_SIZE)
+    {
+        TC_LOG_ERROR("scripts", "bot_ai::AddOrder: orders limit reached for %s (%u)!", me->GetName().c_str(), uint32(_orders.size()));
+        return false;
+    }
+
+    _orders.push(std::move(order));
+    return true;
+}
+void bot_ai::CancelOrder(BotOrder const& order)
+{
+    if (_orders.empty())
+    {
+        TC_LOG_ERROR("scripts", "bot_ai::CancelOrder: %s orders are empty while trying to remove order type %u!",
+            me->GetName().c_str(), uint32(order._type));
+        return;
+    }
+    if (_orders.front()._type != order._type)
+    {
+        TC_LOG_ERROR("scripts", "bot_ai::CancelOrder: %s front order (type %u) is different from cur order (type %u)!",
+            me->GetName().c_str(), uint32(_orders.front()._type), uint32(order._type));
+        return;
+    }
+
+    RemoveBotCommandState(BOT_COMMAND_ISSUED_ORDER);
+    _orders.pop();
+}
+void bot_ai::CompleteOrder(BotOrder const& order)
+{
+    if (_orders.empty())
+    {
+        TC_LOG_ERROR("scripts", "bot_ai::CompleteOrder: %s orders are empty while trying to remove order type %u!",
+            me->GetName().c_str(), uint32(order._type));
+        return;
+    }
+    if (_orders.front()._type != order._type)
+    {
+        TC_LOG_ERROR("scripts", "bot_ai::CompleteOrder: %s front order (type %u) is different from cur order (type %u)!",
+            me->GetName().c_str(), uint32(_orders.front()._type), uint32(order._type));
+        return;
+    }
+
+    RemoveBotCommandState(BOT_COMMAND_ISSUED_ORDER);
+    _orders.pop();
+}
+void bot_ai::CancelAllOrders()
+{
+    RemoveBotCommandState(BOT_COMMAND_ISSUED_ORDER);
+    while (!_orders.empty())
+        _orders.pop();
+}
+void bot_ai::_ProcessOrders()
+{
+    if (HasBotCommandState(BOT_COMMAND_ISSUED_ORDER))
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    if (_orders.empty())
+        return;
+
+    ordersTimer = 500;
+
+    BotOrder const& order = _orders.front();
+    Unit* target = nullptr;
+    switch (order._type)
+    {
+        case BOT_ORDER_SPELLCAST:
+        {
+            if (CCed(me))
+                break;
+
+            SetBotCommandState(BOT_COMMAND_ISSUED_ORDER);
+
+            ObjectGuid guid(order.params.spellCastParams.targetGuid);
+            if (guid == me->GetGUID())
+                target = me;
+            else if (guid == master->GetGUID())
+                target = master;
+            else if (guid != 0)
+            {
+                if (!IAmFree())
+                    target = master->GetBotMgr()->GetBot(guid);
+                if (!target)
+                    target = ObjectAccessor::GetUnit(*me, guid);
+            }
+            else
+            {
+                TC_LOG_ERROR("scripts", "bot_ai:_ProcessOrders: invalid spellCastParams.targetGuid " UI64FMTD "!", order.params.spellCastParams.targetGuid);
+                CancelOrder(order);
+                return;
+            }
+
+            if (!target || !target->IsInWorld())
+            {
+                TC_LOG_ERROR("scripts", "bot_ai:_ProcessOrders: target " UI64FMTD " not found!", order.params.spellCastParams.targetGuid);
+                CancelOrder(order);
+                return;
+            }
+
+            if (IsCasting())
+                me->InterruptNonMeleeSpells(false);
+
+            doCast(target, _spells[order.params.spellCastParams.baseSpell]->spellId);
+            break;
+        }
+        default:
+            TC_LOG_ERROR("scripts", "bot_ai:_ProcessOrders: invalid order type %u!", uint32(order._type));
+            CancelOrder(order);
+            return;
+    }
+}
+bool bot_ai::IsLastOrder(BotOrderTypes order_type, uint32 param1) const
+{
+    if (!_orders.empty())
+    {
+        BotOrder const& order = _orders.front();
+        if (order_type == order._type)
+        {
+            switch (order_type)
+            {
+                case BOT_ORDER_SPELLCAST:
+                    if (order.params.spellCastParams.baseSpell == param1)
+                        return true;
+                    break;
+                default:
+                    TC_LOG_ERROR("scripts", "bot_ai:IsLastOrder: invalid order type %u!", uint32(order_type));
+                    break;
+            }
+        }
+    }
+
+    return false;
+}
+//VEHICLES
+//helpers
+bool bot_ai::HasAuraTypeWithValueAtLeast(AuraType auratype, int32 minvalue, Unit const* unit) const
+{
+    if (!unit)
+        unit = me;
+
+    Unit::AuraEffectList const& mTotalAuraList = unit->GetAuraEffectsByType(auratype);
+    for (Unit::AuraEffectList::const_iterator i = mTotalAuraList.begin(); i != mTotalAuraList.end(); ++i)
+        if (minvalue >= (*i)->GetAmount())
+            return true;
+
+    return false;
+}
+//strats - opponent is always valid
+void bot_ai::DoSkytalonVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+
+    Creature* drake = me->GetVehicleCreatureBase();
+    Unit* target = nullptr;
+    uint32 drakespell = 0;
+    uint32 drakePower = drake->GetPower(POWER_ENERGY);
+
+    //finishers
+    uint8 finishComboPoints;
+    uint32 finishPower;
+    if (GetHealthPCT(drake) <= (40 + 40*drake->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+        HasAuraTypeWithValueAtLeast(SPELL_AURA_PERIODIC_DAMAGE, drake->GetMaxHealth() / 16, drake))
+    {
+        finishComboPoints = 3;
+        finishPower = 25;
+    }
+    //if (HasRole(BOT_ROLE_HEAL))
+    //{
+    //    finishComboPoints = 4;
+    //    finishPower = 50;
+    //}
+    else
+    {
+        finishComboPoints = 4;
+        finishPower = 50;
+    }
+
+    if (vehcomboPoints >= finishComboPoints && (Rand() < 75 + 40*(vehcomboPoints >= 5 || drakePower < finishPower)))
+    {
+        if (drakePower >= finishPower)
+        {
+            if (GetHealthPCT(drake) < 60 && !drake->HasAuraEffect(drake->m_spells[4], EFFECT_0))
+            {
+                drakespell = drake->m_spells[4]; //flame shield
+                target = drake;
+            }
+            else if (HasRole(BOT_ROLE_HEAL))
+            {
+                drakespell = drake->m_spells[3]; //life burst
+                bool cast = false;
+                //find damaged target
+                if (master->GetVehicle() && GetHealthPCT(master->GetVehicleBase()) < 90 && master->GetVehicleBase()->GetDistance(drake) < 60)
+                    cast = true;
+                else if (GetHealthPCT(drake) < 90)
+                    cast = true;
+                else
+                {
+                    if (Group const* gr = master->GetGroup())
+                    {
+                        BotMap const* map;
+                        bool Bots = false;
+                        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            Player const* p = itr->GetSource();
+                            if (!p || me->GetMap() != p->FindMap()) continue;
+                            if (p->HaveBot() && !Bots) Bots = true;
+                            if (p->GetVehicle() && GetHealthPCT(p->GetVehicleBase()) < 90 &&
+                                p->GetVehicleBase()->GetDistance(drake) < 60)
+                            {
+                                cast = true;
+                                break;
+                            }
+                        }
+                        if (!cast && Bots)
+                        {
+                            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                            {
+                                Player const* p = itr->GetSource();
+                                if (!p || me->GetMap() != p->FindMap() || !p->HaveBot()) continue;
+
+                                map = p->GetBotMgr()->GetBotMap();
+                                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                                {
+                                    if (bitr->second && bitr->second->GetVehicle() &&
+                                        GetHealthPCT(bitr->second->GetVehicleBase()) < 90 &&
+                                        bitr->second->GetVehicleBase()->GetDistance(drake) < 60)
+                                    {
+                                        cast = true;
+                                        break;
+                                    }
+                                }
+                            }
+                        }
+                    }
+                }
+                if (cast)
+                    target = drake;
+            }
+            else
+            {
+                drakespell = drake->m_spells[1]; //engulf in flames
+                target = opponent;
+            }
+        }
+    }
+    else if (drakePower >= 35)
+    {
+        if (HasRole(BOT_ROLE_DPS))
+        {
+            drakespell = drake->m_spells[0]; //flame spike
+            target = opponent;
+        }
+        else if (HasRole(BOT_ROLE_HEAL))
+        {
+            drakespell = drake->m_spells[2]; //revivify
+            //bots won't care about target they have cp on so choose randomly
+            std::list<Unit*> targets1;
+            BotMap const* map;
+            Group const* gr = master->GetGroup();
+            if (gr)
+            {
+                bool Bots = false;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player const* p = itr->GetSource();
+                    if (!p || me->GetMap() != p->FindMap()) continue;
+                    if (p->HaveBot() && !Bots)
+                        Bots = true;
+                    Unit* u = p->GetVehicleBase();
+                    if (u && u->IsAlive() && !u->HasUnitState(UNIT_STATE_ISOLATED) && drake->GetDistance(u) < 60.f &&
+                        !(GetHealthPCT(u) > 95 && !IsTank(p)) &&
+                        (GetHealthPCT(u) < 95 || (u->IsInCombat() && !u->getAttackers().empty())))
+                        targets1.push_back(u);
+                }
+                if (Bots)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* p = itr->GetSource();
+                        if (!p || me->GetMap() != p->FindMap() || !p->HaveBot()) continue;
+
+                        map = p->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                        {
+                            Unit* u = bitr->second ? bitr->second->GetVehicleBase() : nullptr;
+                            if (u && u->IsAlive() && !u->HasUnitState(UNIT_STATE_ISOLATED) && drake->GetDistance(u) < 60.f &&
+                                !(GetHealthPCT(u) > 95 && !IsTank(bitr->second)) &&
+                                (GetHealthPCT(u) < 95 || (u->IsInCombat() && !u->getAttackers().empty())))
+                                targets1.push_back(u);
+                        }
+                    }
+                }
+            }
+            else
+            {
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    Unit* u = itr->second ? itr->second->GetVehicleBase() : nullptr;
+                    if (u && u->IsAlive() && !u->HasUnitState(UNIT_STATE_ISOLATED) && drake->GetDistance(u) < 60.f &&
+                        !(GetHealthPCT(u) > 95 && !IsTank(itr->second)) &&
+                        (GetHealthPCT(u) < 95 || (u->IsInCombat() && !u->getAttackers().empty())))
+                        targets1.push_back(u);
+                }
+            }
+
+            uint8 minhppct = 0;
+            for (std::list<Unit*>::const_iterator ci = targets1.begin(); ci != targets1.end(); ++ci)
+                if (uint8 hppct = GetHealthPCT(*ci))
+                    if (minhppct == 0 || minhppct > hppct)
+                        minhppct = hppct;
+
+            if (minhppct <= 75)
+                targets1.remove_if(BOTAI_PRED::HpPctAboveExclude(float(minhppct + 10)));
+
+            if (!targets1.empty())
+                target = Trinity::Containers::SelectRandomContainerElement(targets1);
+
+            if (target && drakePower < 80)
+                if (Aura const* revi = target->GetAura(57090, drake->GetGUID())) //revivify
+                    if (revi->GetStackAmount() >= 5 && revi->GetDuration() >= 4000)
+                        target = nullptr;
+        }
+    }
+
+    //if (!HasRole(BOT_ROLE_TANK|BOT_ROLE_HEAL) && drake->GetMap()->IsRaid() && target && target->GetVictim() == drake)
+    //    target = nullptr;
+
+    if (!target)
+        return;
+
+    if (!drakespell)
+    {
+        TC_LOG_ERROR("scripts", "DoSkytalonVehicleStrats no spell for role mask %u cp %u, power %u, target %s",
+            GetBotRoles(), uint32(vehcomboPoints), drakePower, target->GetName().c_str());
+        return;
+    }
+
+    //TC_LOG_ERROR("scripts", "DoSkytalonVehicleStrats %u on %s", drakespell, target->GetName().c_str());
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    drake->BotStopMovement();
+    drake->SetInFront(target);
+    drake->CastSpell(target, drakespell);
+}
+void bot_ai::DoRubyDrakeVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+
+    Creature* drake = me->GetVehicleCreatureBase();
+    ASSERT(drake);
+    Unit* target = nullptr;
+    uint32 drakespell = 0;
+
+    //IS TANK
+    //50232 Searing Wrath
+    //50241 Evasive Charges
+    //50240 Evasive Maneuvers
+    //50253 Martyr
+
+    Aura const* evas = drake->GetAura(50241); //Evasive Charges
+    uint8 vehicles = LivingVehiclesCount();
+    //bool eregos = opponent->GetEntry() == CREATURE_BOSS_EREGOS_N || opponent->GetEntry() == CREATURE_BOSS_EREGOS_H;
+
+    bool finalEncounter = master->GetInstanceScript() && master->GetInstanceScript()->GetBossState(2) == DONE; //DATA_UROM
+
+    if (vehicles > 1 && evas)
+    {
+        bool canManeuver = !drake->HasAuraType(SPELL_AURA_MOD_ATTACKER_SPELL_HIT_CHANCE) && evas->GetStackAmount() >= 5 &&
+            !drake->HasSpellCooldown(50240);
+        bool canMartyr = !drake->HasAuraType(SPELL_AURA_SPELL_MAGNET) &&
+            !drake->HasSpellCooldown(50253);
+
+        if ((!finalEncounter || canMartyr) && canManeuver)
+        {
+            drakespell = drake->m_spells[1]; //Evasive Maneuvers
+            target = drake;
+        }
+        else if (finalEncounter && canMartyr)
+        {
+            drakespell = drake->m_spells[2]; //Martyr
+            target = drake;
+        }
+    }
+    if (!target)
+    {
+        drakespell = drake->m_spells[0]; //Searing Wrath
+        target = opponent;
+    }
+
+    if (!target)
+        return;
+
+    if (!drakespell)
+    {
+        TC_LOG_ERROR("scripts", "DoRubyDrakeVehicleStrats no spell for target %s", target->GetName().c_str());
+        return;
+    }
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    drake->BotStopMovement();
+    drake->SetInFront(target);
+    drake->CastSpell(target, drakespell);
+}
+void bot_ai::DoEmeraldDrakeVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    Creature* drake = me->GetVehicleCreatureBase();
+    Unit const* mmover = master->GetVehicle() ? master->GetVehicleBase() : master;
+    Unit* target = nullptr;
+    uint32 drakespell = 0;
+
+    //IS HEALER
+    //50328 Leeching Poison
+    //50341 Touch the Nightmare
+    //50344 Dream Funnel
+
+    uint8 drakeHpPct = GetHealthPCT(drake);
+
+    //canceling channel
+    if (IsCasting(drake))
+    {
+        bool interrupt = false;
+        if (drakeHpPct <= 30)
+            interrupt = true;
+        else if (mmover->isMoving() && drake->GetDistance(mmover) >= 75.f && !mmover->HasInArc(float(M_PI) / 2, drake))
+            interrupt = true;
+        else if (Spell const* funnel = drake->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+            if (ObjectGuid guid = funnel->m_targets.GetUnitTargetGUID())
+                if (Unit const* tar = ObjectAccessor::GetUnit(*drake, guid))
+                    if (GetHealthPCT(tar) > 95)
+                        interrupt = true;
+
+        if (interrupt)
+            drake->InterruptNonMeleeSpells(false);
+        else
+            return;
+    }
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+
+    Aura const* pois = opponent->GetAura(50328, drake->GetGUID()); //Leeching Poison
+    Aura const* rift = opponent->GetAura(49592); //Temporal Rift
+    uint8 vehicles = LivingVehiclesCount();
+    bool eregos = opponent->GetEntry() == CREATURE_BOSS_EREGOS_N || opponent->GetEntry() == CREATURE_BOSS_EREGOS_H;
+
+    bool finalEncounter = master->GetInstanceScript() && master->GetInstanceScript()->GetBossState(2) == DONE; //DATA_UROM
+    bool canheal = finalEncounter && vehicles > 1 && (!eregos || drake->GetDistance(mmover) < 30.f) &&
+        drakeHpPct >= (eregos ? 70 : 50) - (pois ? 5 * pois->GetStackAmount() : 0);
+
+    if (canheal && Rand() < 90)
+    {
+        drakespell = drake->m_spells[2]; //Dream Funnel
+        std::list<Unit*> targets1;
+        BotMap const* map;
+        Group const* gr = master->GetGroup();
+        if (gr)
+        {
+            bool Bots = false;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* p = itr->GetSource();
+                if (!p || me->GetMap() != p->FindMap()) continue;
+                if (p->HaveBot() && !Bots)
+                    Bots = true;
+                Unit* u = p->GetVehicleBase();
+                if (u && u->IsAlive() && !u->HasUnitState(UNIT_STATE_ISOLATED) && drake->GetDistance(u) < 60.f &&
+                    GetHealthPCT(u) <= (IsTank(p) ? 50 : 35) + (rift ? 15 : 0))
+                    targets1.push_back(u);
+            }
+            if (Bots)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player const* p = itr->GetSource();
+                    if (!p || me->GetMap() != p->FindMap() || !p->HaveBot()) continue;
+
+                    map = p->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                    {
+                        Unit* u = bitr->second ? bitr->second->GetVehicleBase() : nullptr;
+                        if (u && u != drake && u->IsAlive() && !u->HasUnitState(UNIT_STATE_ISOLATED) && drake->GetDistance(u) < 60.f &&
+                            GetHealthPCT(u) <= (IsTank(bitr->second) ? 50 : 35) + (rift ? 15 : 0))
+                            targets1.push_back(u);
+                    }
+                }
+            }
+        }
+        else
+        {
+            map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Unit* u = itr->second ? itr->second->GetVehicleBase() : nullptr;
+                if (u && u != drake && u->IsAlive() && !u->HasUnitState(UNIT_STATE_ISOLATED) && drake->GetDistance(u) < 60.f &&
+                    GetHealthPCT(u) <= (IsTank(itr->second) ? 50 : 35) + (rift ? 15 : 0))
+                    targets1.push_back(u);
+            }
+        }
+
+        uint8 minhppct = 0;
+        for (std::list<Unit*>::const_iterator ci = targets1.begin(); ci != targets1.end(); ++ci)
+            if (uint8 hppct = GetHealthPCT(*ci))
+                if (minhppct == 0 || minhppct > hppct)
+                    minhppct = hppct;
+
+        if (minhppct <= 50)
+            targets1.remove_if(BOTAI_PRED::HpPctAboveExclude(float(minhppct + 20)));
+
+        if (!targets1.empty())
+            target = Trinity::Containers::SelectRandomContainerElement(targets1);
+    }
+    if (!target)
+    {
+        drakespell = drake->m_spells[1]; //Touch the Nightmare
+        if (!drake->HasSpellCooldown(drakespell))
+        {
+            if ((eregos && drakeHpPct >= ((opponent->GetHealth() < (rift ? 50000u : 25000u)) ? 31 : 80)) ||
+                (drakeHpPct >= 90 && Rand() < 50 && !opponent->HasAura(drakespell)))
+                target = opponent;
+        }
+    }
+    if (!target)
+    {
+        drakespell = drake->m_spells[0]; //Leeching Poison
+        if (!pois || pois->GetStackAmount() < 3 || pois->GetDuration() < 4000)
+            target = opponent;
+        else
+        {
+            //random target
+            std::list<Unit*> targets;
+            Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(drake, drake, 60.f);
+            Trinity::UnitListSearcher <Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(drake, targets, check);
+            //drake->VisitNearbyObject(60.f, searcher);
+            Cell::VisitAllObjects(drake, searcher, 60.f);
+            targets.remove_if(BOTAI_PRED::UnitExclude(opponent));
+            targets.remove_if(BOTAI_PRED::UnitCombatStateExclude(false));
+            targets.remove_if(BOTAI_PRED::AuraedTargetExcludeByCaster(drakespell, drake->GetGUID(), 3));
+            targets.remove_if(BOTAI_PRED::AuraedTargetExclude(49836, 5)); //Shock Charge 1-shots
+
+            if (!targets.empty())
+                target = Trinity::Containers::SelectRandomContainerElement(targets);
+        }
+    }
+
+    if (!target)
+        return;
+
+    if (!drakespell)
+    {
+        TC_LOG_ERROR("scripts", "DoEmeraldDrakeVehicleStrats no spell for target %s", target->GetName().c_str());
+        return;
+    }
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    drake->BotStopMovement();
+    drake->SetInFront(target);
+    drake->CastSpell(target, drakespell);
+}
+void bot_ai::DoAmberDrakeVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+
+    Creature* drake = me->GetVehicleCreatureBase();
+    ASSERT(drake);
+    Unit const* mmover = master->GetVehicle() ? master->GetVehicleBase() : master;
+    Unit* target = nullptr;
+    uint32 drakespell = 0;
+
+    //IS DPS
+    //49840 Shock Lance
+    //49838 Stop Time
+    //49592 Temporal Rift
+    //49836 Shock Charge
+
+    Aura const* shoc = opponent->GetAura(49836, drake->GetGUID()); //Shock Charge
+
+    //canceling channel
+    if (IsCasting(drake))
+    {
+        bool interrupt = false;
+
+        if (mmover->isMoving() && drake->GetDistance(mmover) >= 60.f && !mmover->HasInArc(float(M_PI) / 2, drake))
+            interrupt = true;
+        else if (shoc && shoc->GetStackAmount() >= 10)
+            interrupt = true;
+
+        if (interrupt)
+            drake->InterruptNonMeleeSpells(false);
+        else
+            return;
+    }
+
+    Aura const* rift = opponent->GetAura(49592); //Temporal Rift
+    uint8 vehicles = LivingVehiclesCount();
+    bool eregos = opponent->GetEntry() == CREATURE_BOSS_EREGOS_N || opponent->GetEntry() == CREATURE_BOSS_EREGOS_H;
+
+    bool finalEncounter = master->GetInstanceScript() && master->GetInstanceScript()->GetBossState(2) == DONE; //DATA_UROM
+
+    if (eregos && !drake->HasSpellCooldown(drake->m_spells[1]) && IsCasting(opponent) &&
+        opponent->HasAuraType(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK) && opponent->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2)
+    {
+        drakespell = drake->m_spells[1]; //Stop Time
+        target = drake;
+    }
+    if (!target && shoc && shoc->GetStackAmount() >= 5)
+    {
+        drakespell = drake->m_spells[0]; //Shock Lance
+        if (eregos && shoc->GetStackAmount() >= 10 && (rift || shoc->GetDuration() < 25000 || Rand() < 30))
+            target = opponent;
+        else
+        {
+            //random 1-shot target
+            std::list<Unit*> targets;
+            Trinity::AnyUnfriendlyUnitInObjectRangeCheck check(drake, drake, 60.f);
+            Trinity::UnitListSearcher <Trinity::AnyUnfriendlyUnitInObjectRangeCheck> searcher(drake, targets, check);
+            //drake->VisitNearbyObject(60.f, searcher);
+            Cell::VisitAllObjects(drake, searcher, 60.f);
+            targets.remove_if(BOTAI_PRED::UnitExclude(opponent));
+
+            if (!targets.empty())
+                target = Trinity::Containers::SelectRandomContainerElement(targets);
+        }
+    }
+    if (!target)
+    {
+        if (finalEncounter && vehicles > 1)
+        {
+            drakespell = drake->m_spells[2]; //Temporal Rift
+            target = opponent;
+        }
+        else
+        {
+            drakespell = drake->m_spells[0]; //Shock Lance
+            target = opponent;
+        }
+    }
+
+    if (!target)
+        return;
+
+    if (!drakespell)
+    {
+        TC_LOG_ERROR("scripts", "DoAmberDrakeVehicleStrats no spell for target %s", target->GetName().c_str());
+        return;
+    }
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    drake->BotStopMovement();
+    drake->SetInFront(target);
+    drake->CastSpell(target, drakespell);
+}
+void bot_ai::DoArgentMountVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 200; //at least this delay
+
+    Creature* mount = me->GetVehicleCreatureBase();
+
+    //Tounament spells
+    //62544 Thrust
+    //62575 Shield-Breaker
+    //62960 Charge
+    //62552 Defend
+    //64077 Refresh Mount
+
+    //ToC5 spells
+    //68505 Thrust
+    //62575 Shield-Breaker
+    //68282 Charge
+    //62552 Defend
+
+    if (!mount->HasSpellCooldown(mount->m_spells[3])) //Defend
+    {
+        Aura const* myde = mount->GetAura(mount->m_spells[3]);
+        if (!myde || myde->GetStackAmount() < myde->GetSpellInfo()->StackAmount || myde->GetDuration() <= 8000)
+        {
+            mount->CastSpell(mount, mount->m_spells[3]);
+            return;
+        }
+    }
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+
+    //Unit const* mmover = master->GetVehicle() ? master->GetVehicleBase() : master;
+    Unit* target = nullptr;
+    uint32 mountspell = 0;
+
+    if (mount->GetDistance(opponent) > 5.f)
+    {
+        //Defend
+        AuraEffect const* def = opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN,SPELLFAMILY_GENERIC, 2007, EFFECT_0);
+        if (!def)
+            def = opponent->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN,SPELLFAMILY_GENERIC, 2007, EFFECT_2);
+        if ((!def || def->GetBase()->GetStackAmount() < 2) && !mount->HasSpellCooldown(mount->m_spells[2]))
+        {
+            mountspell = mount->m_spells[2]; //Charge
+            target = opponent;
+        }
+        else
+        {
+            mountspell = mount->m_spells[1]; //Shield-Breaker
+            target = opponent;
+        }
+    }
+    else
+    {
+        mountspell = mount->m_spells[0]; //Thrust
+        target = opponent;
+    }
+
+    if (!target)
+        return;
+
+    if (!mountspell)
+    {
+        TC_LOG_ERROR("scripts", "DoArgentMountVehicleStrats no spell for target %s", target->GetName().c_str());
+        return;
+    }
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    mount->BotStopMovement();
+    mount->SetInFront(target);
+    mount->CastSpell(target, mountspell);
+}
+void bot_ai::DoDemolisherVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+}
+void bot_ai::DoSiegeEngineVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+}
+void bot_ai::DoChopperVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+}
+void bot_ai::DoGenericVehicleStrats(uint32 diff)
+{
+    if (GC_Timer > diff)
+        return;
+
+    GC_Timer = 350; //at least this delay
+
+    if (!CheckVehicleAttackTarget(curVehStrat))
+        return;
+}
+void bot_ai::DoVehicleStrats(BotVehicleStrats strat, uint32 diff)
+{
+    if (curVehStrat != strat)
+    {
+        //TC_LOG_ERROR("scripts", "DoVehicleStrats doing strat %u", uint32(strat));
+        curVehStrat = strat;
+    }
+
+    //if (!master->GetVehicle() || me->GetVehicle()->GetCreatureEntry() != master->GetVehicle()->GetCreatureEntry())
+    //{
+    //    TC_LOG_ERROR("scripts", "DoVehicleStrats cannot do strats: master not on vehicle or on different one");
+    //    return;
+    //}
+
+    switch (strat)
+    {
+        case BOT_VEH_STRAT_WYRMREST_SKYTALON:
+            DoSkytalonVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_RUBY_DRAKE:
+            DoRubyDrakeVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_EMERALD_DRAKE:
+            DoEmeraldDrakeVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_AMBER_DRAKE:
+            DoAmberDrakeVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_TOC5_MOUNT:
+            DoArgentMountVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_ULDUAR_DEMOLISHER:
+            DoDemolisherVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_ULDUAR_SIEGEENGINE:
+            DoSiegeEngineVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_ULDUAR_CHOPPER:
+            DoChopperVehicleStrats(diff);
+            break;
+        case BOT_VEH_STRAT_GENERIC:
+            DoGenericVehicleStrats(diff);
+            break;
+        default:
+            TC_LOG_ERROR("scripts", "Unhandled vehicle strat %u", uint32(strat));
+            break;
+    }
+}
+void bot_ai::DoVehicleActions(uint32 diff)
+{
+    if (!me->GetVehicle())
+        return;
+
+    //choose strat
+    BotVehicleStrats strat;
+    switch (me->GetVehicleBase()->GetEntry())
+    {
+        case CREATURE_NEXUS_SKYTALON_1:
+        case CREATURE_EOE_SKYTALON_N:
+        case CREATURE_EOE_SKYTALON_H:
+            strat = BOT_VEH_STRAT_WYRMREST_SKYTALON;
+            break;
+        case CREATURE_OCULUS_DRAKE_RUBY:
+            strat = BOT_VEH_STRAT_RUBY_DRAKE;
+            break;
+        case CREATURE_OCULUS_DRAKE_EMERALD:
+            strat = BOT_VEH_STRAT_EMERALD_DRAKE;
+            break;
+        case CREATURE_OCULUS_DRAKE_AMBER:
+            strat = BOT_VEH_STRAT_AMBER_DRAKE;
+            break;
+        //case CREATURE_TOC_STEED_QUELDOREI:
+        //case CREATURE_TOC_NIGHTSABER:
+        //case CREATURE_TOC_STEED_STORMWIND:
+        //case CREATURE_TOC_MECHANOSTRIDER:
+        //case CREATURE_TOC_RAM:
+        //case CREATURE_TOC_ELEKK:
+        //case CREATURE_TOC_HAWKSTRIDER_SUNREAVER:
+        //case CREATURE_TOC_RAPTOR:
+        //case CREATURE_TOC_WARHORSE:
+        //case CREATURE_TOC_WOLF:
+        //case CREATURE_TOC_HAWKSTRIDER_SILVERMOON:
+        //case CREATURE_TOC_KODO:
+        case CREATURE_TOC5_WARHORSE:
+        case CREATURE_TOC5_BATTLEWORG:
+            strat = BOT_VEH_STRAT_TOC5_MOUNT;
+            break;
+        /*
+        case CREATURE_ULDUAR_DEMOLISHER:
+            strat = BOT_VEH_STRAT_ULDUAR_DEMOLISHER;
+            break;
+        case CREATURE_ULDUAR_SIEGE_ENGINE:
+            strat = BOT_VEH_STRAT_ULDUAR_SIEGEENGINE;
+            break;
+        case CREATURE_ULDUAR_CHOPPER:
+        case CREATURE_ULDUAR_CHOPPER1:
+            strat = BOT_VEH_STRAT_ULDUAR_CHOPPER;
+            break;
+        */
+        default:
+            strat = BOT_VEH_STRAT_GENERIC;
+            if (curVehStrat != strat)
+                TC_LOG_DEBUG("scripts", "bot_ai DoVehicleActions: %s has to use generic strat for vehicle creature %s (%u)",
+                me->GetName().c_str(), me->GetVehicleBase()->GetName().c_str(), me->GetVehicleBase()->GetEntry());
+            break;
+    }
+
+    DoVehicleStrats(strat, diff);
+}
+bool bot_ai::CheckVehicleAttackTarget(BotVehicleStrats strat)
+{
+    opponent = _getVehicleTarget(strat);
+
+    if (!opponent)
+    {
+        if (me->GetVehicleBase()->GetTarget())
+        {
+            me->GetVehicleBase()->AttackStop();
+            me->GetVehicleBase()->SetTarget(ObjectGuid::Empty);
+        }
+        else if (!master->GetVehicle() && me->GetVehicleBase()->GetDistance(master) < ((Rand() < 25) ? 35 : 15))
+        {
+            //if (VehicleSeatEntry const* seat = me->GetVehicle()->GetSeatForPassenger(me))
+            //{
+                //if (seat->CanEnterOrExit())
+                    me->ExitVehicle();
+                    //me->BotStopMovement();
+            //}
+        }
+
+        return false;
+    }
+
+    if (opponent->GetGUID() != me->GetVehicleBase()->GetTarget())
+    {
+        me->GetVehicleBase()->SetTarget(opponent->GetGUID());
+        SetBotCommandState(BOT_COMMAND_ATTACK);
+        me->GetVehicleBase()->Attack(opponent, false);
+    }
+
+    return true;
+}
+
+bool bot_ai::HasVehicleRoleOverride(uint32 role) const
+{
+    if (Creature const* veh = me->GetVehicleCreatureBase())
+    {
+        switch (veh->GetEntry())
+        {
+            case CREATURE_NEXUS_SKYTALON_1:
+            case CREATURE_EOE_SKYTALON_N:
+            case CREATURE_EOE_SKYTALON_H:
+            case CREATURE_OCULUS_DRAKE_RUBY:
+            case CREATURE_OCULUS_DRAKE_EMERALD:
+            case CREATURE_OCULUS_DRAKE_AMBER:
+            //case CREATURE_TOC_STEED_QUELDOREI:
+            //case CREATURE_TOC_NIGHTSABER:
+            //case CREATURE_TOC_STEED_STORMWIND:
+            //case CREATURE_TOC_MECHANOSTRIDER:
+            //case CREATURE_TOC_RAM:
+            //case CREATURE_TOC_ELEKK:
+            //case CREATURE_TOC_HAWKSTRIDER_SUNREAVER:
+            //case CREATURE_TOC_RAPTOR:
+            //case CREATURE_TOC_WARHORSE:
+            //case CREATURE_TOC_WOLF:
+            //case CREATURE_TOC_HAWKSTRIDER_SILVERMOON:
+            //case CREATURE_TOC_KODO:
+            case CREATURE_TOC5_WARHORSE:
+            case CREATURE_TOC5_BATTLEWORG:
+            case CREATURE_ULDUAR_DEMOLISHER:
+                switch (role)
+                {
+                    case BOT_ROLE_RANGED:
+                        return true;
+                    default:
+                        break;
+                }
+                break;
+            default:
+                break;
+        }
+    }
+
+    return false;
+}
+float bot_ai::GetVehicleAttackDistanceOverride() const
+{
+    if (Creature const* veh = me->GetVehicleCreatureBase())
+    {
+        switch (veh->GetEntry())
+        {
+            case CREATURE_NEXUS_SKYTALON_1:
+            case CREATURE_EOE_SKYTALON_N:
+            case CREATURE_EOE_SKYTALON_H:
+            case CREATURE_OCULUS_DRAKE_RUBY:
+            case CREATURE_OCULUS_DRAKE_EMERALD:
+            case CREATURE_OCULUS_DRAKE_AMBER:
+                return 30.f;
+            //case CREATURE_TOC_STEED_QUELDOREI:
+            //case CREATURE_TOC_NIGHTSABER:
+            //case CREATURE_TOC_STEED_STORMWIND:
+            //case CREATURE_TOC_MECHANOSTRIDER:
+            //case CREATURE_TOC_RAM:
+            //case CREATURE_TOC_ELEKK:
+            //case CREATURE_TOC_HAWKSTRIDER_SUNREAVER:
+            //case CREATURE_TOC_RAPTOR:
+            //case CREATURE_TOC_WARHORSE:
+            //case CREATURE_TOC_WOLF:
+            //case CREATURE_TOC_HAWKSTRIDER_SILVERMOON:
+            //case CREATURE_TOC_KODO:
+            case CREATURE_TOC5_WARHORSE:
+            case CREATURE_TOC5_BATTLEWORG:
+                return 15.f;
+            case CREATURE_ULDUAR_DEMOLISHER:
+                return 40.f;
+            default:
+                break;
+        }
+    }
+
+    return 0.0f;
+}
+uint8 bot_ai::LivingVehiclesCount(uint32 entry) const
+{
+    if (IAmFree())
+        return 0;
+
+    uint8 count = 0;
+    if (master->GetVehicle())
+        ++count;
+    BotMap const* map = master->GetBotMgr()->GetBotMap();
+    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        if (itr->second && itr->second->GetVehicle() && (!entry || entry == itr->second->GetVehicleBase()->GetEntry()))
+            ++count;
+
+    return count;
+}
+//GLOBAL UPDATE
+//opponent unsafe
+bool bot_ai::GlobalUpdate(uint32 diff)
+{
+    if (BotDataMgr::AllBotsLoaded() == false)
+        return false;
+
+    //db saves with cd
+    //  1) disabled spells
+    if (_saveDisabledSpells && _saveDisabledSpellsTimer <= diff)
+    {
+        _saveDisabledSpells = false;
+        _saveDisabledSpellsTimer = 5000;
+
+        NpcBotData* npcBotData = const_cast<NpcBotData*>(BotDataMgr::SelectNpcBotData(me->GetEntry()));
+        BotDataMgr::UpdateNpcBotData(me->GetEntry(), NPCBOT_UPDATE_DISABLED_SPELLS, &npcBotData->disabled_spells);
+    }
+
+    ReduceCD(diff);
+
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+
+        //send stats update for group frames
+        if (me->IsInWorld() && !IAmFree())
+        {
+            if (Group const* gr = master->GetGroup())
+            {
+                if (gr->IsMember(me->GetGUID()))
+                {
+                    WorldPacket data;
+                    BuildGrouUpdatePacket(&data);
+
+                    Player* member;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        member = itr->GetSource();
+                        if (member/* && !member->IsWithinDist(me, member->GetSightRange(), false)*/)
+                            member->GetSession()->SendPacket(&data);
+                    }
+                }
+            }
+
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != master->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //vehicle enter delayed
+            if (shouldEnterVehicle && master->IsInWorld() && me->IsAlive() &&/* !HasBotCommandState(BOT_COMMAND_MASK_UNMOVING) &&*/
+                !me->GetVehicle() && master->GetVehicle() && !CCed(me, true) && !IsCasting())
+            {
+                shouldEnterVehicle = false;
+                AfterBotOwnerEnterVehicle();
+            }
+
+            //walk mode check
+            if (HasBotCommandState(BOT_COMMAND_WALK) != me->IsWalking())
+                me->SetWalk(!me->IsWalking());
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+
+    if (ordersTimer <= diff)
+        _ProcessOrders();
+
+    //if (me->HasInvisibilityAura() || me->HasStealthAura())
+    //    return false;
+
+    //Check current cast state: interrupt casts that became pointless
+    if (me->HasUnitState(UNIT_STATE_CASTING) && !HasBotCommandState(BOT_COMMAND_ISSUED_ORDER) && urand(1,100) <= 75)
+    {
+        bool interrupt;
+        Unit const* target;
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_MAX_SPELL; ++i)
+        {
+            interrupt = false;
+            Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+
+            SpellInfo const* info = spell->GetSpellInfo();
+            if (!info->CastTimeEntry)
+                continue;
+
+            if (info->Id == SHOOT_WAND && me->isMoving())
+                interrupt = true;
+            else
+            {
+                // not interrupted yet, next checks require target, ensure validity
+                // kidna expensive but prevents invalid targets
+                if (spell->m_targets.GetObjectTargetGUID().IsAnyTypeCreature())
+                    spell->m_targets.Update(me);
+                target = spell->m_targets.GetUnitTarget();
+                if (!target)
+                    continue;
+            }
+
+            if (!interrupt && !info->IsPositive())
+            {
+                if (!target->IsAlive() && info->Id != SPELL_CORPSE_EXPLOSION && info->Id != SPELL_RAISE_DEAD)
+                    interrupt = true;
+                else if ((info->Mechanic == MECHANIC_POLYMORPH || info->Mechanic == MECHANIC_SHACKLE ||
+                    info->Mechanic == MECHANIC_DISORIENTED || info->Mechanic == MECHANIC_SLEEP ||
+                    info->Mechanic == MECHANIC_CHARM || info->Mechanic == MECHANIC_BANISH ||
+                    info->Mechanic == MECHANIC_STUN || info->Mechanic == MECHANIC_FREEZE) &&
+                    info->GetFirstRankSpell()->Id != 710 && info->GetFirstRankSpell()->Id != SPELL_SLEEP &&
+                    !target->getAttackers().empty() && !IsCasting(target))
+                    interrupt = true; //useless control (except banish, checked inside class ai)
+                else if (target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !IsCasting(target) &&
+                    (info->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) && _botclass != BOT_CLASS_MAGE)
+                    interrupt = true; //useless control breaks immediately (skip glyphed poly)
+                else if (info->DmgClass == SPELL_DAMAGE_CLASS_MAGIC && !(info->Attributes & SPELL_ATTR0_ABILITY) &&
+                    !(info->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                    !(info->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
+                    (target->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS) > 60 ||
+                    target->GetTotalAuraModifierByMiscMask(SPELL_AURA_REFLECT_SPELLS_SCHOOL, info->GetSchoolMask()) > 60))
+                    interrupt = true; // reflect
+                else if (
+                    info->Id != 64382 && //shattering throw
+                    info->Id != 32375 && //mass dispel
+                    info->GetFirstRankSpell()->Id != 710 && //banish
+                    target->IsImmunedToSpell(info, me))
+                    interrupt = true; // immune
+                else if (i != CURRENT_CHANNELED_SPELL && //channeled targeted spells will be interrupted in Spell::update()
+                    spell->GetCastTime() < spell->GetTimer() * 3 && // >=33% cast time remains
+                    !me->IsWithinLOSInMap(target))
+                    interrupt = true; //LoS
+                else if (info->Id == 64382 && !target->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD))
+                    interrupt = true; //Shattering Throw wasting
+            }
+            if (!interrupt && !(target == master && me->GetDistance(target) < INTERACTION_DISTANCE) &&
+                info->HasEffect(SPELL_EFFECT_HEAL) && GetHealthPCT(target) > 90 && !IsPointedHealTarget(target))
+            {
+                bool isAreaSpell = false;
+                for (uint8 j = 0; j != 3 && isAreaSpell == false; ++j)
+                {
+                    if (info->_effects[j].IsEffect() && info->_effects[j].TargetA.GetTarget())
+                    {
+                        if (info->_effects[j].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY ||
+                            info->_effects[j].TargetA.GetSelectionCategory() == TARGET_SELECT_CATEGORY_AREA)
+                            isAreaSpell = true;
+                        if (!isAreaSpell)
+                        {
+                            switch (info->_effects[j].TargetA.GetTarget())
+                            {
+                            case TARGET_UNIT_CASTER_AREA_PARTY:
+                            case TARGET_DEST_CHANNEL_TARGET:
+                                isAreaSpell = true;
+                                break;
+                            case TARGET_UNIT_TARGET_CHAINHEAL_ALLY:
+                                //Healing Wave falls under TARGET_UNIT_TARGET_CHAINHEAL_ALLY
+                                if (info->GetFirstRankSpell()->Id == 331)
+                                    break;
+                                isAreaSpell = true;
+                                break;
+                            default:
+                                break;
+                            }
+                        }
+                        break;
+                    }
+                }
+
+                if (isAreaSpell == false)
+                {
+                    if (!IsTank(target) || target->getAttackers().empty() ||
+                        spell->GetTimer() * 4 <= spell->GetCastTime()) //<=25% cast time remains
+                        interrupt = true;
+                }
+            }
+            if (!interrupt && (info->HasEffect(SPELL_EFFECT_RESURRECT) || info->HasEffect(SPELL_EFFECT_RESURRECT_NEW)) &&
+                (target->IsAlive() || (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->IsResurrectRequested())))
+                interrupt = true;
+            if (!interrupt && checkAurasTimer <= diff && me->GetMap()->IsDungeon() && !CCed(me, true) && IsWithinAoERadius(*me))
+                interrupt = true;
+
+            if (interrupt)
+            {
+                me->InterruptSpell(CurrentSpellTypes(i));
+                GC_Timer = 0;
+                break;
+            }
+        }
+    }
+
+    if (_updateTimerEx1 <= diff && !IAmFree())
+    {
+        _updateTimerEx1 = urand(2000, 2500);
+
+        //Ex1-timed updates
+
+        //DEBUG
+        /*
+        Sometimes bots are affected by zone (instance) scripts
+        Good example is CoT: Battle for Mount Hyjal
+        */
+        //Faction
+        //ensure master is not controlled
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(master->GetRace());
+        uint32 fac = rEntry ? rEntry->FactionID : 0;
+        if (me->GetFaction() != master->GetFaction() && master->GetFaction() == fac)
+        {
+            //std::ostringstream msg;
+            //msg << "Something changed my faction (now " << me->GetFaction() << "), changing back to " << fac << "!";
+            //BotWhisper(msg.str().c_str());
+            me->SetFaction(fac);
+        }
+        //Visibility
+        if (!me->IsVisible() && master->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making visible...");
+            me->SetVisible(true);
+        }
+        if (me->IsVisible() && !master->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making invisible...");
+            me->SetVisible(false);
+        }
+        //Phase
+        if (me->GetPhaseMask() != master->GetPhaseMask())
+        {
+            //BotWhisper("Somehow we are not is same phase! Fixing that...");
+            me->SetPhaseMask(master->GetPhaseMask(), true);
+        }
+        //Vehicle state
+        //if (me->GetVehicle() && !master->GetVehicle())
+        //{
+        //    BotWhisper("Somehow i'm still in the vehicle! Exiting...");
+        //    OnBotOwnerExitVehicle(nullptr);
+        //}
+        ////Vehicle speed
+        //if (me->GetVehicle() && master->GetVehicle() && me->GetVehicleBase()->GetTypeId() == TYPEID_UNIT &&
+        //    (me->GetVehicleBase()->ToCreature()->GetCreatureTemplate()->InhabitType & INHABIT_AIR) &&
+        //    me->GetVehicleBase()->GetSpeed(MOVE_FLIGHT) != master->GetVehicleBase()->GetSpeed(MOVE_FLIGHT))
+        //{
+        //    me->GetVehicleBase()->SetSpeed(MOVE_FLIGHT, master->GetVehicleBase()->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+        //    me->GetVehicleBase()->SetSpeed(MOVE_RUN, master->GetVehicleBase()->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+        //}
+        //Transport state
+        if (me->GetTransport() != master->GetTransport())
+        {
+            if (master->GetTransport())
+            {
+                if (me->GetDistance2d(master) < 20.f)
+                {
+                    master->GetTransport()->AddPassenger(me);
+                    me->m_movementInfo.transport.pos.Relocate(master->GetTransOffset());
+                    me->Relocate(GetAbsoluteTransportPosition(master));
+                    me->AddUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+                }
+            }
+            else
+            {
+                me->ClearUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+                me->GetTransport()->RemovePassenger(me);
+            }
+        }
+        //Model size / Combat reach
+        if (me->GetDisplayId() == me->GetNativeDisplayId())
+        {
+            me->SetFloatValue(UNIT_FIELD_BOUNDINGRADIUS, DEFAULT_PLAYER_BOUNDING_RADIUS * me->GetObjectScale());
+            me->SetFloatValue(UNIT_FIELD_COMBATREACH,  DEFAULT_PLAYER_COMBAT_REACH * me->GetObjectScale());
+
+            //debug: restore offhand visual if needed
+            if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + BOT_SLOT_OFFHAND) == 0 && _canUseOffHand())
+            {
+                int8 id = 1;
+                EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+                if (CanChangeEquip(BOT_SLOT_OFFHAND) && _equips[BOT_SLOT_OFFHAND])
+                {
+                    NpcBotTransmogData const* transmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+                    if (einfo->ItemEntry[BOT_SLOT_OFFHAND] != _equips[BOT_SLOT_OFFHAND]->GetEntry() &&
+                        transmogData && BotMgr::IsTransmogEnabled() && (transmogData->transmogs[BOT_SLOT_OFFHAND].first == _equips[BOT_SLOT_OFFHAND]->GetEntry() || BotMgr::TransmogUseEquipmentSlots()))
+                        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + BOT_SLOT_OFFHAND, transmogData->transmogs[BOT_SLOT_OFFHAND].second);
+                    else
+                        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + BOT_SLOT_OFFHAND, _equips[BOT_SLOT_OFFHAND]->GetEntry());
+                }
+                else
+                {
+                    me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + BOT_SLOT_OFFHAND, einfo->ItemEntry[BOT_SLOT_OFFHAND]);
+                }
+            }
+        }
+        //end DEBUG
+
+        //Check if moving through air
+        //if (me->IsInWorld() && !JumpingFlyingOrFalling() &&
+        //    !me->HasUnitMovementFlag((MOVEMENTFLAG_ONTRANSPORT)|(MOVEMENTFLAG_DISABLE_GRAVITY)|(MOVEMENTFLAG_ROOT)|(MOVEMENTFLAG_SWIMMING)))
+        //{
+        //    //skip case such as moving back up from abyss (movement glitches)
+        //    float x,y,z;
+        //    if (!me->GetMotionMaster()->GetDestination(x,y,z) || z < me->GetPositionZ())
+        //    {
+        //        float groundz = me->GetMap()->GetHeight(me->GetPhaseMask(), me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(), true, MAX_FALL_DISTANCE);
+        //        if (groundz > INVALID_HEIGHT)
+        //        {
+        //            me->GetMotionMaster()->MoveFall();
+        //        }
+        //        else if (GetBotCommandState() != BOT_COMMAND_STAY && !me->isMoving())
+        //        {
+        //            SetBotCommandState(BOT_COMMAND_ABANDON); //reset movement after
+        //        }
+        //    }
+        //}
+
+        //Zone / Area / WMOArea
+        if (me->IsInWorld())
+        {
+            uint32 newzone, newarea;
+            me->GetZoneAndAreaId(newzone, newarea);
+
+            if (_lastZoneId != newzone)
+                _OnZoneUpdate(newzone, newarea); // also updates area
+            else// if (_lastAreaId != newarea)
+                _OnAreaUpdate(newarea);
+
+            if (_wmoAreaUpdateTimer <= diff)
+                _UpdateWMOArea();
+        }
+
+        //Gathering
+        if (me->IsInWorld() && HasRole(BOT_ROLE_MASK_GATHERING) && !me->IsInCombat() && !master->IsInCombat() && !master->IsMounted() && !CCed(me) &&
+            master->GetLootGUID().IsEmpty() && !me->isMoving() && !master->isMoving() && master->IsStandState() && !Feasting() && !IsCasting() && !IsCasting(master) &&
+            !HasBotCommandState(BOT_COMMAND_MASK_UNMOVING) && !me->GetVehicle())
+        {
+            //TC_LOG_ERROR("spells", "bot_ai:UpdateEx by %s, found free master, my skills: %u:", me->GetName().c_str(), uint32(_roleMask & BOT_ROLE_MASK_GATHERING));
+            std::list<WorldObject*> woList;
+            NearbyObjectBySkillCheck check(master, INTERACTION_DISTANCE - 1.0f, (_roleMask & BOT_ROLE_MASK_GATHERING));
+            Trinity::WorldObjectListSearcher<NearbyObjectBySkillCheck> searcher(me, woList, check, GRID_MAP_TYPE_MASK_CREATURE|GRID_MAP_TYPE_MASK_GAMEOBJECT);
+            Cell::VisitAllObjects(me, searcher, 20.f);
+            //me->VisitNearbyObject(20.f, searcher);
+            //TC_LOG_ERROR("spells", "bot_ai:UpdateEx: list is %s", woList.empty() ? "empty" : "not empty");
+            if (!woList.empty())
+            {
+                WorldObject* wo = nullptr;
+                float minangle = float(M_PI);
+                for (WorldObject* wob : woList)
+                {
+                    float angle = me->GetAbsoluteAngle(wob);
+                    if (me->GetDistance(wob) <= INTERACTION_DISTANCE * 0.5f && angle < minangle)
+                    {
+                        minangle = angle;
+                        wo = wob;
+                    }
+                }
+
+                wo = wo ? wo : Trinity::Containers::SelectRandomContainerElement(woList);
+                //TC_LOG_ERROR("spells", "bot_ai:UpdateEx: processing %s", wo->GetName().c_str());
+                if (me->GetDistance(wo) <= INTERACTION_DISTANCE * 0.5f && me->HasInArc(float(M_PI), wo))
+                {
+                    //cosmetic
+                    CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+                    me->CastSpell(wo->GetTypeId() == TYPEID_UNIT ? wo->ToUnit() : me, SPELL_COMBAT_SPECIAL_2H_ATTACK, args);
+
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                        wo->ToUnit()->SetDynamicFlag(UNIT_DYNFLAG_LOOTABLE);
+
+                    master->SendLoot(wo->GetGUID(), LOOT_SKINNING);
+
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                        wo->ToUnit()->RemoveUnitFlag(UNIT_FLAG_SKINNABLE);
+
+                    _updateTimerEx1 = urand(1500, 2100);
+                }
+                else
+                {
+                    std::ostringstream msg;
+                    std::string name = wo->GetName();
+                    if (wo->GetTypeId() == TYPEID_UNIT)
+                    {
+                        _LocalizeCreature(master, name, wo->GetEntry());
+                        msg << name << "..."; // TODO
+                    }
+                    else
+                    {
+                        _LocalizeGameObject(master, name, wo->GetEntry());
+                        msg << name << "!";
+                    }
+                    BotWhisper(msg.str().c_str());
+
+                    if (me->GetDistance(wo) > INTERACTION_DISTANCE * 0.5f)
+                    {
+                        Position pos;
+                        wo->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, CONTACT_DISTANCE, wo->GetAbsoluteAngle(me));
+                        BotMovement(BOT_MOVE_POINT, &pos, nullptr, false);
+                        //me->GetMotionMaster()->MovePoint(me->GetMapId(), pos, false);
+                    }
+                    else
+                    {
+                        me->SetFacingTo(me->GetAbsoluteAngle(wo));
+                        _updateTimerEx1 = urand(1500, 1800);
+                    }
+                }
+            }
+        }
+
+        //Looting
+        if (me->IsInWorld() && HasRole(BOT_ROLE_AUTOLOOT) && HasRole(BOT_ROLE_MASK_LOOTING) &&
+            !me->GetVictim() && !master->IsMounted() && !CCed(me) && !Feasting() && !IsCasting() &&
+            !HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        {
+            //TC_LOG_ERROR("scripts", "bot_ai Looting by %s, my mask: %u:", me->GetName().c_str(), uint32(_roleMask & BOT_ROLE_MASK_LOOTING));
+            std::list<Unit*> crList;
+            NearbyLootableCreatureCheck check(master, std::min(30.f, std::max(5.f, sWorld->getFloatConfig(CONFIG_GROUP_XP_DISTANCE) - 10.f)));
+            Trinity::UnitListSearcher<NearbyLootableCreatureCheck> searcher(me, crList, check);
+            Cell::VisitAllObjects(me, searcher, 40.f);
+            //me->VisitNearbyObject(40.f, searcher);
+            for (std::list<Unit*>::iterator itr = crList.begin(); itr != crList.end();)
+            {
+                if (!_canLootCreature((*itr)->ToCreature()))
+                {
+                    //TC_LOG_ERROR("scripts", "bot_ai Looting: cannot loot %s (%u)", (*itr)->GetName().c_str(), (*itr)->GetGUIDLow());
+                    crList.erase(itr++);
+                    continue;
+                }
+                ++itr;
+            }
+
+            if (!crList.empty())
+            {
+                Unit* un = Trinity::Containers::SelectRandomContainerElement(crList);
+
+                std::ostringstream msg;
+                std::string name = un->GetName();
+                _LocalizeCreature(master, name, un->GetEntry());
+                msg << LocalizedNpcText(master, BOT_TEXT_LOOTING) << ' ' << name;
+                BotWhisper(msg.str().c_str());
+
+                _autoLootCreature(un->ToCreature());
+
+                if (crList.size() > 1)
+                    _updateTimerEx1 = urand(400, 600);
+                /*//TC_LOG_ERROR("scripts", "bot_ai Looting: processing %s", un->GetName().c_str());
+                if (me->GetDistance(un) < INTERACTION_DISTANCE + 2.f)
+                {
+                    //TC_LOG_ERROR("scripts", "bot_ai Looting: looting %s", un->GetName().c_str());
+                    _autoLootCreature(un->ToCreature());
+                    _updateTimerEx1 = urand(500, 1000);
+                }
+                else
+                {
+                    //TC_LOG_ERROR("scripts", "bot_ai Looting: moving towards %s", un->GetName().c_str());
+                    Position pos;
+                    un->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0.f, CONTACT_DISTANCE, un->GetAbsoluteAngle(me));
+                    me->GetMotionMaster()->MovePoint(me->GetMapId(), pos, false);
+                }*/
+            }
+        }
+    }
+
+    if (!IsTempBot())
+        Regenerate();
+
+    //update flags
+    if (!me->IsInCombat() && !_evadeMode && _atHome)
+    {
+        if (!me->HasNpcFlag(UNIT_NPC_FLAG_GOSSIP))
+            me->SetNpcFlag(UNIT_NPC_FLAG_GOSSIP);
+        if (me->HasUnitFlag(UNIT_FLAG_PET_IN_COMBAT))
+            me->RemoveUnitFlag(UNIT_FLAG_PET_IN_COMBAT);
+    }
+
+    if (!me->GetVictim())
+        Evade();
+
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return false;
+
+    if (!IsTempBot())
+        _updateRations(); //safe
+
+    CheckAttackState();
+
+    if (checkAurasTimer <= lastdiff)
+    {
+        checkAurasTimer += uint32(__rand + __rand + (IAmFree() ? 1000 : 40 * (1 + master->GetNpcBotsCount())));
+
+        //group demand
+        if (!IAmFree() && HasRole(BOT_ROLE_PARTY) && (!master->GetGroup() || !master->GetGroup()->IsMember(me->GetGUID())))
+        {
+            //TC_LOG_ERROR("entities.player", "CheckAuras(): adding %s to group", me->GetName().c_str());
+            master->GetBotMgr()->AddBotToGroup(me);
+        }
+
+        Unit* mover = me->GetVehicle() ? me->GetVehicleBase() : me;
+        if (!HasBotCommandState(BOT_COMMAND_MASK_UNCHASE) && !CCed(mover, true) &&
+            (IAmFree() || master->GetBotMgr()->GetBotAllowCombatPositioning()) &&
+            (!mover->isMoving() || Rand() < 50) && !IsCasting(mover) && !IsShootingWand(mover))
+        {
+            if (Unit* victim = CanBotAttackOnVehicle() ? me->GetVictim() : mover->GetTarget() ? ObjectAccessor::GetUnit(*mover, mover->GetTarget()) : nullptr)
+            {
+                //TC_LOG_ERROR("scripts", "GetInPos prepare by %s", me->GetName().c_str());
+                if (!IAmFree() && master->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+                    master->GetBotMgr()->GetBotExactAttackRange() == 0 && !GetVehicleAttackDistanceOverride() &&
+                    !(!IAmFree() && !GetAoeSpots().empty()))
+                {
+                    GetInPosition(true, victim);
+                }
+                else if (!HasRole(BOT_ROLE_RANGED) && !HasVehicleRoleOverride(BOT_ROLE_RANGED) &&
+                    !(!IAmFree() && !GetAoeSpots().empty()))
+                {
+                    if (me->GetDistance(victim) > 1.5f)
+                        GetInPosition(true, victim);
+                }
+                else
+                {
+                    //TC_LOG_ERROR("scripts", "%s calculates attack pos to attack %s", me->GetName().c_str(), victim->GetName().c_str());
+                    bool force = false;
+                    CalculateAttackPos(victim, attackpos, force);
+                    if (mover->GetExactDist2d(&attackpos) > (force ? 0.1f : 4.f))
+                    {
+                        //TC_LOG_ERROR("scripts", "%s moving to x %.2f y %.2f z %.2f to attack %s",
+                        //    me->GetName().c_str(), attackpos.m_positionX, attackpos.m_positionY, attackpos.m_positionZ, victim->GetName().c_str());
+                        GetInPosition(true, victim, &attackpos);
+                    }
+                }
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == master->GetPhaseMask())
+            SetStats(false);
+        else if (_powersTimer <= lastdiff && !IsTempBot())
+        {
+            _powersTimer += REGEN_CD; //do not mistake for regen, this is only for updating max health/mana
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (_atHome && Rand() < 10)
+            _atHome = false;
+    }
+
+    if (Wait())
+        return false;
+
+    FindMaster();
+
+    GenerateRand();
+
+    if (CanBotAttackOnVehicle())
+        BreakCC(diff);
+
+    if (!me->GetVehicle() && CCed(me))
+        return false;
+
+    //opponent unsafe
+    if (!IAmFree() && (!opponent || !master->GetBotMgr()->GetBotAllowCombatPositioning()) && !HasBotCommandState(BOT_COMMAND_STAY) &&
+        (!me->GetVehicle() || (!CCed(me->GetVehicleBase(), true) && !me->GetVehicleBase()->GetTarget())))
+    {
+        Unit* mover = me->GetVehicle() ? me->GetVehicleBase() : me;
+
+        if (!master->IsAlive())
+        {
+            //If ghost move to corpse, else move to dead player
+            if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            {
+                Corpse const* corpse = master->GetCorpse();
+                if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) &&
+                    !IsCasting() && !IsShootingWand() && me->GetDistance(corpse) > 5)
+                    BotMovement(BOT_MOVE_POINT, corpse);
+                    //me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+            }
+            else
+            {
+                if (!HasBotCommandState(BOT_COMMAND_FOLLOW) || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                    SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+            }
+        }
+        else if (!IsCasting(mover) && (!IsShootingWand(mover) || Rand() < 10))
+        {
+            _calculatePos(movepos);
+            float maxdist = std::max<float>(master->GetBotMgr()->GetBotFollowDist() *
+                ((master->m_movementInfo.GetMovementFlags() & MOVEMENTFLAG_FORWARD) ? 0.125f : master->isMoving() ? 0.03125f : 0.25f), 3.f);
+            Position destPos;
+            if (me->isMoving())
+                me->GetMotionMaster()->GetDestination(destPos.m_positionX, destPos.m_positionY, destPos.m_positionZ);
+            else
+                destPos = me->GetPosition();
+
+            if (!HasBotCommandState(BOT_COMMAND_FOLLOW) || destPos.GetExactDist(&movepos) > maxdist)
+                SetBotCommandState(BOT_COMMAND_FOLLOW, true, &movepos);
+        }
+    }
+
+    if (!IsCasting() && !IsShootingWand())
+    {
+        if ((me->IsInCombat() && !me->IsSitState() && CanBotAttackOnVehicle()) || !CanSheath())
+        {
+            if (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_DARK_RANGER || _botclass == BOT_CLASS_SEA_WITCH)
+            {
+                if (me->GetSheath() != SHEATH_STATE_RANGED)
+                    me->SetSheath(SHEATH_STATE_RANGED);
+            }
+            else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                me->SetSheath(SHEATH_STATE_MELEE);
+        }
+        else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+        {
+            if (me->GetSheath() == SHEATH_STATE_RANGED)
+                me->SetSheath(SHEATH_STATE_MELEE);
+            else
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+    }
+
+    _updateMountedState();
+    _updateStandState();
+
+    return true;
+}
+
+void bot_ai::CommonTimers(uint32 diff)
+{
+    Events.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (checkAurasTimer > diff)     checkAurasTimer -= diff;
+    if (waitTimer > diff)           waitTimer -= diff;
+    if (roleTimer > diff)           roleTimer -= diff;
+    if (ordersTimer > diff)         ordersTimer -= diff;
+    if (checkMasterTimer > diff)    checkMasterTimer -= diff;
+
+    if (_powersTimer > diff)        _powersTimer -= diff;
+    if (_chaseTimer > diff)         _chaseTimer -= diff;
+    if (_engageTimer > diff)        _engageTimer -= diff;
+
+    if (_potionTimer > diff && (_potionTimer < POTION_CD || !me->IsInCombat())) _potionTimer -= diff;
+
+    if (IAmFree())
+        UpdateReviveTimer(diff);
+
+    if (me->IsInWorld() &&
+        _wmoAreaUpdateTimer > diff) _wmoAreaUpdateTimer -= diff;
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+    if (_updateTimerEx1 > diff)     _updateTimerEx1 -= diff;
+
+    if (_saveDisabledSpellsTimer > diff) _saveDisabledSpellsTimer -= diff;
+}
+
+void bot_ai::UpdateReviveTimer(uint32 diff)
+{
+    if (me->IsAlive())
+        return;
+
+    if (_reviveTimer > diff)        _reviveTimer -= diff;
+    else
+    {
+        if (IAmFree())
+            BotMgr::ReviveBot(me);
+        else
+            if (_reviveTimer > 0)   _reviveTimer = 0;
+    }
+}
+
+void bot_ai::Evade()
+{
+    if (_atHome && !_evadeMode)
+        return;
+    //if (me->IsInCombat())
+    //    return;
+    if (me->GetVictim())
+        return;
+    if (IsCasting())
+        return;
+    if (CCed(me, true))
+        return;
+
+    _atHome = true;
+
+    if (!IAmFree() || IsTempBot())
+    {
+        _evadeMode = false;
+        return;
+    }
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    if (mapid != me->GetMapId() || _evadeCount >= 3 || me->GetDistance(pos) > 1000.f)
+    {
+        //TeleportHome();
+
+        if (!teleHomeEvent || !teleHomeEvent->IsActive())
+        {
+            teleHomeEvent = new TeleportHomeEvent(this);
+            Events.AddEvent(teleHomeEvent, Events.CalculateTime(std::chrono::seconds(5)));
+
+            //if bot has been removed manually and while in dungeon
+            if (mapid != me->GetMapId())
+            {
+                teleHomeEvent->ScheduleAbort();
+                teleHomeEvent->Execute(0,0);
+            }
+        }
+        _evadeMode = false;
+        return;
+    }
+
+    float dist = me->GetDistance(pos);
+    if (dist > 1.5f)
+    {
+        if (!_evadeMode)
+            ++_evadeCount;
+        else if (Rand() < 4 && fabs(me->GetPositionZ() - pos.GetPositionZ()) > 30.f && !me->HasInArc(float(M_PI)*0.5f, &pos))
+            ++_evadeCount;
+        else if (me->isMoving() && Rand() > 10)
+            return;
+
+        _evadeMode = true;
+
+        //me->BotStopMovement();
+
+        bool farpoint = true;
+        if (dist > 50)
+        {
+            float dx = pos.m_positionX - me->m_positionX;
+            float dy = pos.m_positionY - me->m_positionY;
+            float fdx = fabs(dx); float fdy = fabs(dy);
+            float divider =
+                fdx > 900  || fdy > 900  ?  60.0f :
+                fdx > 600  || fdy > 600  ?  30.0f :
+                fdx > 400  || fdy > 400  ?  20.0f :
+                fdx > 200  || fdy > 200  ?  10.0f :
+                fdx > 100  || fdy > 100  ?   7.0f : 3.0f;
+            dx = dx / divider + me->m_positionX;
+            dy = dy / divider + me->m_positionY;
+            float z = me->GetMap()->GetHeight(dx, dy, me->m_positionZ);
+
+            if (z > INVALID_HEIGHT && fabs(me->m_positionZ - z) > 0.05f)
+            {
+                Position position;
+                position.Relocate(dx, dy, z + 0.1f);
+                BotMovement(BOT_MOVE_POINT, &position);
+                //me->GetMotionMaster()->MovePoint(mapid, dx, dy, z + 0.1f, true);
+                farpoint = false;
+            }
+        }
+
+        if (farpoint)
+            BotMovement(BOT_MOVE_POINT, &pos);
+            //me->GetMotionMaster()->MovePoint(mapid, pos);
+
+        return;
+    }
+
+    if (me->isMoving())
+        return;
+
+    _evadeMode = false;
+    _evadeCount = 0;
+
+    me->SetFacingTo(pos.GetOrientation());
+    me->SetFaction(me->GetCreatureTemplate()->faction);
+}
+//TeleportHome() ONLY CALLED THROUGH EVENTPROCESSOR
+void bot_ai::TeleportHome()
+{
+    ASSERT(teleHomeEvent);
+    //ASSERT(IAmFree());
+
+    AbortTeleport();
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    Map* map = sMapMgr->CreateBaseMap(mapid);
+    ASSERT(map && !map->Instanceable());
+    BotMgr::TeleportBot(me, map, &pos);
+
+    spawned = false;
+    _evadeCount = 0;
+}
+//FinishTeleport(uint32, float, float, float, float) ONLY CALLED THROUGH EVENTPROCESSOR
+bool bot_ai::FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/)
+{
+    ASSERT(teleFinishEvent);
+    //ASSERT(!IAmFree());
+    ASSERT(!me->IsInWorld());
+
+    AbortTeleport();
+
+    //1) Cannot teleport: master disappeared - return home
+    if (IAmFree()/* || master->GetSession()->isLogingOut()*/)
+    {
+        uint16 mapid;
+        Position pos;
+        GetHomePosition(mapid, &pos);
+
+        teleHomeEvent = new TeleportHomeEvent(this);
+        Events.AddEvent(teleHomeEvent, Events.CalculateTime(std::chrono::milliseconds(0))); //make sure event will be deleted
+        if (teleHomeEvent->IsActive())
+            teleHomeEvent->ScheduleAbort(); //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+        _evadeMode = false;
+
+        return false;
+    }
+
+    Map* map = master->FindMap();
+    //2) Cannot teleport: map not found or forbidden - delay teleport
+    if (!map || !master->IsAlive() || master->GetBotMgr()->RestrictBots(me, true))
+    {
+        //ChatHandler ch(master->GetSession());
+        //ch.PSendSysMessage("Your bot %s cannot teleport to you. Restricted bot access on this map...", me->GetName().c_str());
+        teleFinishEvent = new TeleportFinishEvent(this);
+        Events.AddEvent(teleFinishEvent, Events.CalculateTime(std::chrono::seconds(5)));
+        return false;
+    }
+
+    me->SetMap(map);
+    if (master->GetTransport())
+    {
+        master->GetTransport()->AddPassenger(me);
+        me->m_movementInfo.transport.pos.Relocate(master->GetTransOffset());
+        me->Relocate(GetAbsoluteTransportPosition(master));
+        me->AddUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+    }
+    else
+    {
+        Position destpos;
+        _calculatePos(destpos);
+        me->Relocate(destpos);
+    }
+
+    map->AddToMap(me);
+    me->BotStopMovement();
+    //bot->SetAI(oldAI);
+    //me->IsAIEnabled = true;
+    canUpdate = true;
+
+    //master->m_Controlled.insert(me);
+    if (me->IsAlive())
+    {
+        CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+        me->CastSpell(me, COSMETIC_TELEPORT_EFFECT, args);
+    }
+    //me->CastSpell(me, HONORLESS_TARGET, true);
+
+    //update group member online state
+    if (Group* gr = master->GetGroup())
+        if (gr->IsMember(me->GetGUID()))
+            gr->SendUpdate();
+
+    //map hooks
+    if (InstanceScript* iscr = master->GetInstanceScript())
+        iscr->OnNPCBotEnter(me);
+
+    return true;
+}
+
+void bot_ai::AbortTeleport()
+{
+    if (teleHomeEvent)
+    {
+        if (teleHomeEvent->IsActive())
+            teleHomeEvent->ScheduleAbort();
+        teleHomeEvent = nullptr;
+    }
+
+    if (teleFinishEvent)
+    {
+        if (teleFinishEvent->IsActive())
+            teleFinishEvent->ScheduleAbort();
+        teleFinishEvent = nullptr;
+    }
+}
+
+void bot_ai::GetHomePosition(uint16& mapid, Position* pos) const
+{
+    CreatureData const* data = me->GetCreatureData();
+    mapid = data->mapId;
+    pos->Relocate(data->spawnPoint.GetPositionX(), data->spawnPoint.GetPositionY(), data->spawnPoint.GetPositionZ(), data->spawnPoint.GetOrientation());
+}
+
+void bot_ai::KillEvents(bool force)
+{
+    Events.KillAllEvents(force);
+}
+
+void bot_ai::OnBotEnterVehicle(Vehicle const* vehicle)
+{
+    if (VehicleSeatEntry const* seat = vehicle->GetSeatForPassenger(me))
+    {
+        UnsummonAll();
+        if (seat->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL)
+        {
+            vehicle->GetBase()->SetFaction(master->GetFaction());
+            //vehicle->GetBase()->SetOwnerGUID(master->GetGUID());
+            vehicle->GetBase()->SetCreator(master);
+            vehicle->GetBase()->SetUnitFlag(UNIT_FLAG_POSSESSED);
+            vehicle->GetBase()->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            vehicle->GetBase()->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            ASSERT(vehicle->GetBase()->SetCharmedBy(me, CHARM_TYPE_VEHICLE));
+            vehicle->GetBase()->SetControlledByPlayer(true);
+
+            vehcomboPoints = 0;
+            //flight mode
+            switch (vehicle->GetBase()->GetEntry())
+            {
+                case CREATURE_NEXUS_SKYTALON_1:
+                case CREATURE_EOE_SKYTALON_N:
+                case CREATURE_EOE_SKYTALON_H:
+                case CREATURE_OCULUS_DRAKE_RUBY:
+                case CREATURE_OCULUS_DRAKE_EMERALD:
+                case CREATURE_OCULUS_DRAKE_AMBER:
+                    vehicle->GetBase()->SetCanFly(true);
+                    vehicle->GetBase()->SetDisableGravity(true);
+                    vehicle->GetBase()->m_movementInfo.SetMovementFlags(MOVEMENTFLAG_FLYING);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (Unit* oVeh = master->GetVehicleBase())
+        {
+            ////Set hp and mana percent to avoid abuse
+            //vehicle->GetBase()->SetHealth(vehicle->GetBase()->GetMaxHealth() * oVeh->GetHealthPct() / 100.f + 0.5f);
+            //if (oVeh->GetPowerType() == POWER_MANA)
+            //{
+            //    float mpPct = oVeh->GetPower(POWER_MANA) * 100.f / oVeh->GetMaxPower(POWER_MANA);
+            //    vehicle->GetBase()->SetPower(POWER_MANA, vehicle->GetBase()->GetMaxPower(POWER_MANA) * mpPct / 100.f + 0.5f);
+            //}
+            //speed
+            if (vehicle->GetBase()->GetTypeId() == TYPEID_UNIT &&
+                (vehicle->GetBase()->ToCreature()->GetCreatureTemplate()->Movement.Flight == CreatureFlightMovementType::CanFly))
+            {
+                //hack to use vehicle speed
+                vehicle->GetBase()->RemoveAurasByType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED);
+                vehicle->GetBase()->RemoveAurasByType(SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS);
+                vehicle->GetBase()->RemoveAurasByType(SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK);
+                vehicle->GetBase()->RemoveAurasByType(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK);
+                vehicle->GetBase()->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED, true);
+                vehicle->GetBase()->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_VEHICLE_SPEED_ALWAYS, true);
+                vehicle->GetBase()->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FLIGHT_SPEED_NOT_STACK, true);
+                vehicle->GetBase()->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK, true);
+                vehicle->GetBase()->SetSpeed(MOVE_FLIGHT, oVeh->GetSpeedRate(MOVE_FLIGHT) * 1.17f);
+                vehicle->GetBase()->SetSpeed(MOVE_RUN, oVeh->GetSpeedRate(MOVE_FLIGHT) * 1.17f);
+                vehicle->GetBase()->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DECREASE_SPEED, true);
+                vehicle->GetBase()->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SPEED_SLOW_ALL, true);
+            }
+        }
+    }
+}
+
+void bot_ai::OnBotExitVehicle(Vehicle const* vehicle)
+{
+    if (VehicleSeatEntry const* seat = vehicle->GetSeatForPassenger(me))
+    {
+        if (seat->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL)
+        {
+            vehicle->GetBase()->SetControlledByPlayer(false);
+            vehicle->GetBase()->RemoveCharmedBy(me);
+            vehicle->GetBase()->RestoreFaction();
+            //vehicle->GetBase()->SetOwnerGUID(ObjectGuid::Empty);
+            vehicle->GetBase()->SetCreator(nullptr);
+            vehicle->GetBase()->RemoveUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            if (vehicle->GetBase()->GetTypeId() == TYPEID_UNIT)
+                vehicle->GetBase()->RemoveUnitFlag(UNIT_FLAG_POSSESSED);
+            vehicle->GetBase()->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+
+            curVehStrat = BOT_VEH_STRAT_NONE;
+            if (vehicle->GetBase()->IsSummon())
+                vehicle->GetBase()->ToCreature()->DespawnOrUnsummon(1ms);
+        }
+    }
+}
+
+void bot_ai::AfterBotOwnerEnterVehicle()
+{
+    if (!me->GetVehicle() && master->GetVehicleCreatureBase() && master->GetVehicleCreatureBase()->m_spells[0] &&
+        master->GetVehicleBase()->IsControlledByPlayer())
+    {
+        VehicleSeatEntry const* seat = master->GetVehicle()->GetSeatForPassenger(master);
+        if (seat && seat->CanEnterOrExit())
+        {
+            uint32 creEntry = 0;
+            uint32 vehEntry;
+
+            ChooseVehicleForEncounter(creEntry, vehEntry);
+            if (!creEntry)
+            {
+                TC_LOG_DEBUG("scripts", "OnBotOwnerEnterVehicle: no vehicle selected for bot master veh %s!",
+                    master->GetVehicleCreatureBase()->GetName().c_str());
+                return;
+            }
+            Unit* veh = SpawnVehicle(creEntry, vehEntry);
+            ASSERT(veh);
+
+            removeShapeshiftForm();
+            //me->BotStopMovement();
+
+            //DO NOT use spellclick here, this is undefined behaviour if target selection is not explicit
+            //veh->HandleSpellClick(me);
+            switch (creEntry) //select vehicle ride spell
+            {
+                //TODO
+            case CREATURE_EOE_SKYTALON_N:
+            case CREATURE_EOE_SKYTALON_H:
+                me->CastSpell(veh, 56071); //Ride Red Dragon Buddy
+                break;
+            case CREATURE_OCULUS_DRAKE_RUBY:
+            case CREATURE_OCULUS_DRAKE_EMERALD:
+            case CREATURE_OCULUS_DRAKE_AMBER:
+            {
+                me->EnterVehicle(veh); //cannot cast ride spell (49464, 49346, 49460) due to targeting (TARGET_UNIT_NEARBY_ENTRY)
+                CastSpellExtraArgs args(true);
+                args.SetOriginalCaster(me->GetGUID());
+                veh->CastSpell(veh, 66667, args); //Gear Scaling
+                break;
+            }
+            //case CREATURE_TOC_STEED_QUELDOREI:
+            //case CREATURE_TOC_NIGHTSABER:
+            //case CREATURE_TOC_STEED_STORMWIND:
+            //case CREATURE_TOC_MECHANOSTRIDER:
+            //case CREATURE_TOC_RAM:
+            //case CREATURE_TOC_ELEKK:
+            //case CREATURE_TOC_HAWKSTRIDER_SUNREAVER:
+            //case CREATURE_TOC_RAPTOR:
+            //case CREATURE_TOC_WARHORSE:
+            //case CREATURE_TOC_WOLF:
+            //case CREATURE_TOC_HAWKSTRIDER_SILVERMOON:
+            //case CREATURE_TOC_KODO:
+            //    me->CastSpell(veh, 63151); //Ride Vehicle
+            //    break;
+            case CREATURE_TOC5_WARHORSE:
+            case CREATURE_TOC5_BATTLEWORG:
+                me->CastSpell(veh, 67830); //Ride Vehicle
+                break;
+            default:
+                me->EnterVehicle(veh);
+                break;
+            }
+            return;
+        }
+    }
+
+    //TC_LOG_ERROR("scripts", "OnBotOwnerEnterVehicle: master not in vehicle or no veh found for bot %s!", me->GetName().c_str());
+}
+
+void bot_ai::OnBotOwnerEnterVehicle(Vehicle const* /*vehicle*/)
+{
+    shouldEnterVehicle = true;
+}
+
+void bot_ai::OnBotOwnerExitVehicle(Vehicle const* /*vehicle*/)
+{
+    shouldEnterVehicle = false;
+    if (me->GetVehicle())
+    {
+        if (me->GetMapId() == 631) // Icecrown Citadel
+        {
+            me->ExitVehicle();
+            me->BotStopMovement();
+        }
+    }
+}
+
+Unit* bot_ai::SpawnVehicle(uint32 creEntry, uint32 vehEntry)
+{
+    ASSERT(sObjectMgr->GetCreatureTemplate(creEntry));
+    if (vehEntry != 0)
+        ASSERT(sVehicleStore.LookupEntry(vehEntry));
+
+    Map* map = me->GetMap();
+    float x, y, z, o;
+    TempSummon* vc;
+    if (!me->GetTransport())
+    {
+        o = master->GetOrientation();
+        me->GetClosePoint(x, y, z, me->GetCombatReach());
+        vc = new TempSummon(nullptr, me, false);
+        ASSERT(vc->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, master->GetPhaseMask(), creEntry, Position(x,y,z,o), nullptr, vehEntry, true));
+        vc->SetTempSummonType(TEMPSUMMON_CORPSE_DESPAWN);
+        vc->InitStats(0);
+        ASSERT(map->AddToMap(vc->ToCreature()));
+        vc->InitSummon(); //not needed really
+    }
+    else
+    {
+        if (master->GetVehicle())
+            o = master->GetVehicleBase()->GetTransOffsetO();
+        else
+            o = master->GetTransOffsetO();
+        x = me->GetTransOffsetX();
+        y = me->GetTransOffsetY();
+        z = me->GetTransOffsetZ();
+        Position vehpos(x, y, z, o);
+        me->GetTransport()->CalculatePassengerPosition(x, y, z, &o);
+        vc = new TempSummon(nullptr, me, false);
+        ASSERT(vc->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, master->GetPhaseMask(), creEntry, Position(x,y,z,o), nullptr, vehEntry, true));
+
+        //vc->SetTransport(me->GetTransport());
+        //vc->AddUnitMovementFlag(MOVEMENTFLAG_ONTRANSPORT);
+        //vc->m_movementInfo.transport.guid = GetGUID();
+        me->GetTransport()->AddPassenger(vc);
+
+        vc->m_movementInfo.transport.pos.Relocate(vehpos);
+        vc->Relocate(x, y, z, o);
+        vc->SetHomePosition(x, y, z, o);
+        vc->SetTransportHomePosition(vehpos);
+
+        vc->AddUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+        vc->InitStats(0);
+        ASSERT(map->AddToMap(vc->ToCreature()));
+        vc->InitSummon(); //not needed really
+        vc->SetTempSummonType(TEMPSUMMON_CORPSE_DESPAWN);
+        //vc = me->GetTransport()->SummonPassenger(creEntry, vehpos, TEMPSUMMON_CORPSE_DESPAWN);
+    }
+
+    return vc;
+}
+
+void bot_ai::ChooseVehicleForEncounter(uint32 &creEntry, uint32 &vehEntry) const
+{
+    Vehicle* mVeh = master->GetVehicle();
+    ASSERT_NODEBUGINFO(mVeh);
+    ASSERT_NODEBUGINFO(mVeh->GetBase()->GetTypeId() == TYPEID_UNIT);
+
+    vehEntry = 0; // will be chosen at creature spawn
+    switch (mVeh->GetBase()->GetEntry())
+    {
+        //TODO
+        case CREATURE_NEXUS_SKYTALON_1:
+        case CREATURE_EOE_SKYTALON_N:
+        case CREATURE_EOE_SKYTALON_H:
+        case CREATURE_ULDUAR_DEMOLISHER:
+        case CREATURE_ULDUAR_SIEGE_ENGINE:
+        case CREATURE_ULDUAR_CHOPPER:
+        case CREATURE_ULDUAR_CHOPPER1:
+        //case CREATURE_TOC_STEED_QUELDOREI:
+        //case CREATURE_TOC_HAWKSTRIDER_SUNREAVER:
+        case CREATURE_TOC5_WARHORSE:
+        case CREATURE_TOC5_BATTLEWORG:
+            creEntry = mVeh->GetBase()->GetEntry();
+            break;
+        case CREATURE_OCULUS_DRAKE_RUBY:
+        case CREATURE_OCULUS_DRAKE_EMERALD:
+        case CREATURE_OCULUS_DRAKE_AMBER:
+            creEntry = (HasRole(BOT_ROLE_TANK)/* && mVeh->GetBase()->GetEntry() != CREATURE_OCULUS_DRAKE_RUBY*/) ? CREATURE_OCULUS_DRAKE_RUBY :
+                (HasRole(BOT_ROLE_HEAL)/* && mVeh->GetBase()->GetEntry() != CREATURE_OCULUS_DRAKE_EMERALD*/) ? CREATURE_OCULUS_DRAKE_EMERALD :
+                CREATURE_OCULUS_DRAKE_AMBER;
+            break;
+        //case CREATURE_TOC_NIGHTSABER:
+        //case CREATURE_TOC_STEED_STORMWIND:
+        //case CREATURE_TOC_MECHANOSTRIDER:
+        //case CREATURE_TOC_RAM:
+        //case CREATURE_TOC_ELEKK:
+        //case CREATURE_TOC_RAPTOR:
+        //case CREATURE_TOC_WARHORSE:
+        //case CREATURE_TOC_WOLF:
+        //case CREATURE_TOC_HAWKSTRIDER_SILVERMOON:
+        //case CREATURE_TOC_KODO:
+        //    switch (GetPlayerRace())
+        //    {
+        //        case RACE_HUMAN:         creEntry = CREATURE_TOC_STEED_STORMWIND;        break;
+        //        case RACE_ORC:           creEntry = CREATURE_TOC_WOLF;                   break;
+        //        case RACE_DWARF:         creEntry = CREATURE_TOC_RAM;                    break;
+        //        case RACE_NIGHTELF:      creEntry = CREATURE_TOC_NIGHTSABER;             break;
+        //        case RACE_UNDEAD_PLAYER: creEntry = CREATURE_TOC_WARHORSE;               break;
+        //        case RACE_TAUREN:        creEntry = CREATURE_TOC_KODO;                   break;
+        //        case RACE_GNOME:         creEntry = CREATURE_TOC_MECHANOSTRIDER;         break;
+        //        case RACE_TROLL:         creEntry = CREATURE_TOC_RAPTOR;                 break;
+        //        case RACE_BLOODELF:      creEntry = CREATURE_TOC_HAWKSTRIDER_SILVERMOON; break;
+        //        case RACE_DRAENEI:       creEntry = CREATURE_TOC_ELEKK;                  break;
+        //        default:                 creEntry = CREATURE_TOC_STEED_QUELDOREI;        break;
+        //    }
+        //    break;
+        case CREATURE_ICC_GUNSHIPCANNON_ALLIANCE:
+        case CREATURE_ICC_GUNSHIPCANNON_HORDE:
+            //limited amount of cannons
+            if (!IsTank() && HasRole(BOT_ROLE_DPS) &&
+                master->GetBotMgr()->GetNpcBotsCountByVehicleEntry(mVeh->GetBase()->GetEntry()) <
+                std::max<uint8>(master->GetBotMgr()->GetNpcBotsCount() / 2, 8))
+                creEntry = mVeh->GetBase()->GetEntry();
+            break;
+        case CREATURE_ICC_MUTATED_ABOMINATION1:
+        case CREATURE_ICC_MUTATED_ABOMINATION2:
+        case CREATURE_ICC_MUTATED_ABOMINATION3:
+        case CREATURE_ICC_MUTATED_ABOMINATION4:
+        case CREATURE_ICC_MUTATED_ABOMINATION5:
+        case CREATURE_ICC_MUTATED_ABOMINATION6:
+        case CREATURE_ICC_MUTATED_ABOMINATION7:
+        case CREATURE_ICC_MUTATED_ABOMINATION8:
+            //no abomination bots
+            break;
+        default:
+            if (VehicleSeatEntry const* seat = mVeh->GetSeatForPassenger(master))
+            {
+                if (seat->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL)
+                {
+                    //can use generic strat for that
+                    creEntry = mVeh->GetBase()->GetEntry();
+                    break;
+                }
+            }
+
+            TC_LOG_ERROR("scripts", "ChooseVehicleForEncounter: unhandled master vehicle creature %s (%u)",
+                master->GetVehicleBase()->GetName().c_str(), master->GetVehicleBase()->GetEntry());
+            return;
+    }
+
+    if (creEntry && creEntry != mVeh->GetBase()->GetEntry())
+    {
+        CreatureTemplate const* cProto = sObjectMgr->GetCreatureTemplate(creEntry);
+        ASSERT_NODEBUGINFO(cProto);
+        vehEntry = cProto->VehicleId;
+        ASSERT_NODEBUGINFO(sVehicleStore.LookupEntry(vehEntry));
+    }
+}
+
+Position bot_ai::GetAbsoluteTransportPosition(WorldObject const* object)
+{
+    if (!object->GetTransport())
+        return object->GetPosition();
+
+    Position p = object->GetTransport()->GetPosition();
+    Position t = object->GetTransOffset();
+    t.m_positionX += p.m_positionX;
+    t.m_positionY += p.m_positionY;
+    t.m_positionZ += p.m_positionZ;
+    t.SetOrientation(Position::NormalizeOrientation(t.GetOrientation() + p.GetOrientation()));
+
+    return t;
+}
+
+int32 bot_ai::GetBotResistanceBonus(SpellSchoolMask mask) const
+{
+    int32 resist = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        if ((mask & (1 << i)) && (resist == 0 || resist > resistbonus[i-1]))
+            resist = resistbonus[i-1];
+
+    return resist;
+}
+
+MeleeHitOutcome bot_ai::BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    if (GetNextAttackMeleeOutCome() != MELEE_HIT_CRUSHING)
+        return GetNextAttackMeleeOutCome();
+    return me->RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void bot_ai::BotJumpInPlaceInFrontOf(Position const* pos, float speedXY, float maxHeight)
+{
+    float sign = (me->GetPositionX() < pos->GetPositionX()) ? 1.f : -1.f;
+    float x = me->GetPositionX() + 0.14f * sign;
+    sign = (me->GetPositionY() < pos->GetPositionY()) ? 1.f : -1.f;
+    float y = me->GetPositionY() + 0.14f * sign;
+    float z = me->GetPositionZ() - 0.01f;
+    //float floorz = Map::GetHeight(x, y, z, true, 5.f);
+    speedXY = std::max<float>(speedXY, speedXY / me->m_modAttackSpeedPct[BASE_ATTACK]);
+
+    //me->AttackStop();
+    //me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(x, y, z, me->GetOrientation(), speedXY, maxHeight);
+}
+
+void bot_ai::BuildGrouUpdatePacket(WorldPacket* data)
+{
+    uint32 mask = GROUP_UPDATE_FULL;
+
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
+        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
+        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
+
+    uint32 byteCount = 0;
+    for (uint8 i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
+        if (mask & (1 << i))
+            byteCount += GroupUpdateLength[i];
+
+    data->Initialize(SMSG_PARTY_MEMBER_STATS, size_t(8) + 4u + byteCount);
+    *data << me->GetGUID().WriteAsPacked();
+    *data << uint32(mask);
+
+    if (mask & GROUP_UPDATE_FLAG_STATUS)
+    {
+        uint16 playerStatus = MEMBER_STATUS_ONLINE;
+        if (me->IsPvP())
+            playerStatus |= MEMBER_STATUS_PVP;
+
+        if (!me->IsAlive())
+            playerStatus |= MEMBER_STATUS_DEAD;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            playerStatus |= MEMBER_STATUS_PVP_FFA;
+
+        *data << uint16(playerStatus);
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
+        *data << uint32(me->GetHealth());
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
+        *data << uint32(me->GetMaxHealth());
+
+    Powers powerType = me->GetPowerType();
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
+        *data << uint8(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
+        *data << uint16(me->GetPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
+        *data << uint16(me->GetMaxPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_LEVEL)
+        *data << uint16(me->GetLevel());
+
+    if (mask & GROUP_UPDATE_FLAG_ZONE)
+        *data << uint16(me->GetZoneId());
+
+    if (mask & GROUP_UPDATE_FLAG_POSITION)
+    {
+        *data << uint16(me->GetPositionX());
+        *data << uint16(me->GetPositionY());
+    }
+
+    //TODO: ...?
+    //if (mask & GROUP_UPDATE_FLAG_AURAS)
+    //{
+    //    uint64 auramask = player->GetAuraUpdateMaskForRaid();
+    //    *data << uint64(auramask);
+    //    for (uint32 i = 0; i < MAX_AURAS_GROUP_UPDATE; ++i)
+    //    {
+    //        if (auramask & (uint64(1) << i))
+    //        {
+    //            AuraApplication const* aurApp = player->GetVisibleAura(i);
+    //            *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+    //            *data << uint8(1);
+    //        }
+    //    }
+    //}
+
+    if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    {
+        if (Vehicle* veh = me->GetVehicle())
+            *data << uint32(veh->GetVehicleInfo()->SeatID[me->m_movementInfo.transport.seat]);
+        else
+            *data << uint32(0);
+    }
+}
+
+//DPS TRACKER
+uint32 bot_ai::GetDPSTaken(Unit const* u) const
+{
+    return IAmFree() ? 0 : master->GetBotMgr()->GetDPSTaken(u);
+}
+int32 bot_ai::GetHPSTaken(Unit const* u) const
+{
+    return IAmFree() ? 0 : master->GetBotMgr()->GetHPSTaken(u);
+}
+//Health per second
+int32 bot_ai::GetHPS(Unit const* u) const
+{
+    return IAmFree() ? 0 : GetHPSTaken(u) - GetDPSTaken(u);
+}
+//Health percent per second
+int32 bot_ai::GetHPPCTPS(Unit const* u) const
+{
+    return int32(GetHPS(u) * 100.f / float(u->GetMaxHealth()));
+}
+//%health unit is going to have after x ms
+//0-100
+uint8 bot_ai::GetExpectedHPPCT(Unit const* u, uint32 mseconds) const
+{
+    if (IAmFree())
+        return GetHealthPCT(u);
+
+    int32 pct = int32(GetHealthPCT(u)) + int32(GetHPPCTPS(u) * (mseconds * 0.001f));
+
+    if (pct > 100)
+        pct = 100;
+    else if (pct < 0)
+        pct = 0;
+
+    return uint8(pct);
+}
+
+//Moved from header
+bool bot_ai::IsChanneling(Unit const* u/* = nullptr*/) const
+{
+    if (!u)
+        u = me;
+    return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+}
+bool bot_ai::IsCasting(Unit const* u/* = nullptr*/) const
+{
+    if (!u)
+        u = me;
+    return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true, false, false));
+}
+bool bot_ai::JumpingFlyingOrFalling() const
+{
+    return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW);
+}
+bool bot_ai::JumpingOrFalling() const
+{
+    return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_FALLING_SLOW);
+}
+bool bot_ai::Jumping() const
+{
+    return me->HasUnitState(UNIT_STATE_JUMPING);
+}
+
+bool bot_ai::IsInContactWithWater() const
+{
+    return me->IsInWorld() &&
+        (me->GetMap()->GetLiquidStatus(me->GetPhaseMask(), me->GetPositionX(), me->GetPositionY(), me->GetPositionZ(),
+            MAP_LIQUID_TYPE_WATER | MAP_LIQUID_TYPE_OCEAN) & MAP_LIQUID_STATUS_IN_CONTACT);
+}
+
+bool bot_ai::IsTempBot() const
+{
+    return me->GetEntry() == BOT_ENTRY_MIRROR_IMAGE_BM;
+}
+
+uint32 bot_ai::GetLostHP(Unit const* unit)
+{
+    return unit->GetMaxHealth() - unit->GetHealth();
+}
+uint8 bot_ai::GetHealthPCT(Unit const* u)
+{
+    if (!u || !u->IsAlive() || u->GetMaxHealth() <= 1)
+        return 100;
+    return uint8(((float(u->GetHealth()))/u->GetMaxHealth()) * 100);
+}
+uint8 bot_ai::GetManaPCT(Unit const* u)
+{
+    if (!u || !u->IsAlive() || u->GetMaxPower(POWER_MANA) <= 1)
+        return 100;
+    return (u->GetPower(POWER_MANA)*10/(1 + u->GetMaxPower(POWER_MANA)/10));
+}
+
+MeleeHitOutcome bot_ai::GetNextAttackMeleeOutCome() const
+{
+    return MELEE_HIT_CRUSHING;
+}
+
+uint8 bot_ai::GetBotStance() const
+{
+    return BOT_STANCE_NONE;
+}
+
+uint8 bot_ai::GetPlayerClass() const
+{
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_BM:
+                return BOT_CLASS_WARRIOR;
+            case BOT_CLASS_SPHYNX:
+                return BOT_CLASS_WARLOCK;
+            case BOT_CLASS_ARCHMAGE:
+                return BOT_CLASS_MAGE;
+            case BOT_CLASS_DREADLORD:
+                return BOT_CLASS_PALADIN;
+            case BOT_CLASS_SPELLBREAKER:
+                return BOT_CLASS_PALADIN;
+            case BOT_CLASS_DARK_RANGER:
+                return BOT_CLASS_HUNTER;
+            case BOT_CLASS_NECROMANCER:
+                return BOT_CLASS_WARLOCK;
+            case BOT_CLASS_SEA_WITCH:
+                return BOT_CLASS_MAGE;
+            default:
+                TC_LOG_ERROR("entities.unit", "GetPlayerClass: %s has unknown Ex bot class %u!", me->GetName().c_str(), _botclass);
+                return BOT_CLASS_PALADIN;
+        }
+    }
+
+    return _botclass;
+}
+uint8 bot_ai::GetPlayerRace() const
+{
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_BM:
+                return RACE_ORC;
+            case BOT_CLASS_SPHYNX:
+                return RACE_UNDEAD_PLAYER;
+            case BOT_CLASS_ARCHMAGE:
+                return RACE_HUMAN;
+            case BOT_CLASS_DREADLORD:
+                return RACE_UNDEAD_PLAYER;
+            case BOT_CLASS_SPELLBREAKER:
+                return RACE_BLOODELF;
+            case BOT_CLASS_DARK_RANGER:
+                return RACE_BLOODELF;
+            case BOT_CLASS_NECROMANCER:
+                return RACE_HUMAN;
+            case BOT_CLASS_SEA_WITCH:
+                return RACE_TROLL;
+            default:
+                TC_LOG_ERROR("entities.unit", "GetPlayerRace: %s has unknown Ex bot class %u!", me->GetName().c_str(), _botclass);
+                return RACE_HUMAN;
+        }
+    }
+
+    return me->GetRace();
+}
+
+uint8 bot_ai::GetBotComboPoints() const
+{
+    return me->GetVehicle() ? vehcomboPoints : uint8(GetAIMiscValue(BOTAI_MISC_COMBO_POINTS));
+}
+
+float bot_ai::GetBotAmmoDPS() const
+{
+    if (CanUseAmmo())
+    {
+        for (int8 i = MAX_AMMO_LEVEL - 1; i >= 0; --i)
+            if (me->GetLevel() >= AmmoDPSForLevel[i][0])
+                return float(AmmoDPSForLevel[i][1]);
+
+        return float(AmmoDPSForLevel[0][1]);
+    }
+
+    return 0.0f;
+}
+
+uint32 bot_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case BOT_PET_IMP:
+            return ORIGINAL_ENTRY_IMP;
+        case BOT_PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        case BOT_PET_SUCCUBUS:
+            return ORIGINAL_ENTRY_SUCCUBUS;
+        case BOT_PET_FELHUNTER:
+            return ORIGINAL_ENTRY_FELHUNTER;
+        case BOT_PET_FELGUARD:
+            return ORIGINAL_ENTRY_FELGUARD;
+        case BOT_PET_WATER_ELEMENTAL:
+            return ORIGINAL_ENTRY_WATER_ELEMENTAL;
+        case BOT_PET_GHOUL:
+            //doesn't have pet template
+            //return ORIGINAL_ENTRY_GHOUL;
+        case BOT_PET_SHADOWFIEND:
+            //return ORIGINAL_ENTRY_SHADOWFIEND;
+        case BOT_PET_SPIRIT_WOLF:
+            //return ORIGINAL_ENTRY_SPIRIT_WOLF;
+        case BOT_PET_FORCE_OF_NATURE:
+            //return ORIGINAL_ENTRY_FORCE_OF_NATURE;
+        default:
+            return ORIGINAL_ENTRY_HUNTER_PET;
+    }
+}
+
+bool bot_ai::IsPetMelee(uint32 entry)
+{
+    switch (entry)
+    {
+        case BOT_PET_IMP:
+        case BOT_PET_WATER_ELEMENTAL:
+        case BOT_PET_AWATER_ELEMENTAL:
+            return false;
+        default:
+            return true;
+    }
+}
+
+bool bot_ai::IsMeleeClass(uint8 m_class)
+{
+    return
+        (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN ||
+        m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_BM || m_class == BOT_CLASS_DREADLORD ||
+        m_class == BOT_CLASS_SPELLBREAKER);
+}
+bool bot_ai::IsTankingClass(uint8 m_class)
+{
+    return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN ||
+        m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_SPHYNX || m_class == BOT_CLASS_SPELLBREAKER);
+}
+bool bot_ai::IsBlockingClass(uint8 m_class)
+{
+    return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_SHAMAN ||
+        m_class == BOT_CLASS_SPELLBREAKER);
+}
+bool bot_ai::IsCastingClass(uint8 m_class)
+{
+    //Class can benefit from spellpower
+    return (m_class == CLASS_PALADIN || m_class == CLASS_PRIEST || m_class == CLASS_SHAMAN ||
+        m_class == CLASS_MAGE || m_class == CLASS_WARLOCK || m_class == CLASS_DRUID ||
+        m_class == BOT_CLASS_SPHYNX || m_class == BOT_CLASS_ARCHMAGE || m_class == BOT_CLASS_DREADLORD ||
+        m_class == BOT_CLASS_SPELLBREAKER || m_class == BOT_CLASS_DARK_RANGER || m_class == BOT_CLASS_NECROMANCER ||
+        m_class == BOT_CLASS_SEA_WITCH);
+}
+bool bot_ai::IsHealingClass(uint8 m_class)
+{
+    return
+        (m_class == BOT_CLASS_PRIEST || m_class == BOT_CLASS_DRUID ||
+        m_class == BOT_CLASS_SHAMAN || m_class == BOT_CLASS_PALADIN ||
+        m_class == BOT_CLASS_SPHYNX);
+}
+bool bot_ai::IsHumanoidClass(uint8 m_class)
+{
+    return m_class != BOT_CLASS_SPHYNX;
+}
+bool bot_ai::IsHeroExClass(uint8 m_class)
+{
+    return m_class == BOT_CLASS_BM || m_class == BOT_CLASS_ARCHMAGE || m_class == BOT_CLASS_DREADLORD ||
+        m_class == BOT_CLASS_DARK_RANGER || m_class == BOT_CLASS_SEA_WITCH;
+}
+bool bot_ai::IsMelee() const
+{
+    return !IsRanged() && HasRole(BOT_ROLE_DPS|BOT_ROLE_TANK);
+}
+bool bot_ai::IsRanged() const
+{
+    return HasRole(BOT_ROLE_RANGED) || HasVehicleRoleOverride(BOT_ROLE_RANGED);
+}
+
+bool bot_ai::IsShootingWand(Unit const* u) const
+{
+    if (!u) u = me;
+
+    Spell const* spell = u->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL);
+    return spell && spell->GetSpellInfo()->Id == SHOOT_WAND;
+}
+
+void bot_ai::StartPotionTimer()
+{
+    _potionTimer = POTION_CD;
+}
+
+bool bot_ai::CanBlock() const
+{
+    return me->CanUseAttackType(OFF_ATTACK) &&
+        (_botclass == BOT_CLASS_SPELLBREAKER || !(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK));
+}
+bool bot_ai::CanParry() const
+{
+    if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && me->CanUseAttackType(BASE_ATTACK))
+    {
+        switch (_botclass)
+        {
+            case BOT_CLASS_SPHYNX:
+            case BOT_CLASS_SPELLBREAKER:
+            case BOT_CLASS_SEA_WITCH:
+                return true;
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_HUNTER:
+                return me->GetLevel() >= 10;
+            case BOT_CLASS_SHAMAN:
+                return me->GetLevel() >= 30;
+            case BOT_CLASS_DEATH_KNIGHT:
+                return me->GetLevel() >= 55;
+            default:
+                break;
+        }
+    }
+    return false;
+}
+bool bot_ai::CanDodge() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanCrit() const
+{
+    return _botclass != BOT_CLASS_BM;
+}
+bool bot_ai::CanMiss() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanSheath() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanSit() const
+{
+    return _botclass < BOT_CLASS_EX_START || _botclass == BOT_CLASS_DARK_RANGER;
+}
+bool bot_ai::CanEat() const
+{
+    return _botclass != BOT_CLASS_SPHYNX;
+}
+bool bot_ai::CanDrink() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanRegenInCombat() const
+{
+    return _botclass == BOT_CLASS_SPHYNX;
+}
+bool bot_ai::CanMount() const
+{
+    switch (_botclass)
+    {
+        case BOT_CLASS_BM:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_DARK_RANGER:
+        case BOT_CLASS_NECROMANCER:
+            return true;
+        default:
+            return _botclass < BOT_CLASS_EX_START;
+    }
+}
+bool bot_ai::CanUseAmmo() const
+{
+    if ((_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_DARK_RANGER ||
+        _botclass == BOT_CLASS_SEA_WITCH) &&
+        _equips[BOT_SLOT_RANGED])
+    {
+        ItemTemplate const* ranged = _equips[BOT_SLOT_RANGED]->GetTemplate();
+        if (ranged->Class == ITEM_CLASS_WEAPON &&
+            (ranged->SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+            ranged->SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW ||
+            ranged->SubClass == ITEM_SUBCLASS_WEAPON_GUN))
+            return true;
+    }
+    return false;
+}
+
+bool bot_ai::RespectEquipsAttackTime() const
+{
+    return _botclass < BOT_CLASS_EX_START;
+}
+bool bot_ai::CanChangeEquip(uint8 slot) const
+{
+    return (_botclass != BOT_CLASS_BM && _botclass != BOT_CLASS_ARCHMAGE &&
+        _botclass != BOT_CLASS_DREADLORD && _botclass != BOT_CLASS_SPELLBREAKER &&
+        _botclass != BOT_CLASS_DARK_RANGER && _botclass != BOT_CLASS_NECROMANCER &&
+        _botclass != BOT_CLASS_SEA_WITCH) ||
+        slot > BOT_SLOT_RANGED;
+}
+bool bot_ai::CanDisplayNonWeaponEquipmentChanges() const
+{
+    return (_botclass < BOT_CLASS_EX_START || _botclass == BOT_CLASS_ARCHMAGE);
+}
+bool bot_ai::IsValidTransmog(uint8 slot, ItemTemplate const* source) const
+{
+    ASSERT(slot < BOT_TRANSMOG_INVENTORY_SIZE);
+
+    if (!CanChangeEquip(slot))
+        return false;
+
+    Item const* item = _equips[slot];
+    if (!item)
+        return false;
+
+    ItemTemplate const* target = item->GetTemplate();
+
+    if (target->ItemId == source->ItemId)
+        return false;
+    if (target->Class != source->Class)
+        return false;
+
+    switch (target->InventoryType)
+    {
+        case INVTYPE_RELIC:
+        case INVTYPE_NECK:
+        case INVTYPE_FINGER:
+        case INVTYPE_TRINKET:
+        case INVTYPE_THROWN:
+            return false;
+        default:
+            break;
+    }
+    switch (source->InventoryType)
+    {
+        case INVTYPE_RELIC:
+        case INVTYPE_NECK:
+        case INVTYPE_FINGER:
+        case INVTYPE_TRINKET:
+        case INVTYPE_THROWN:
+        case INVTYPE_BAG:
+        case INVTYPE_AMMO:
+        case INVTYPE_QUIVER:
+        case INVTYPE_NON_EQUIP:
+            return false;
+        default:
+            break;
+    }
+
+    if (target->SubClass != source->SubClass)
+    {
+        if (target->Class == ITEM_CLASS_WEAPON && !BotMgr::MixWeaponClasses())
+            return false;
+        if (target->Class == ITEM_CLASS_ARMOR && !BotMgr::MixArmorClasses())
+            return false;
+    }
+
+    if (target->InventoryType != source->InventoryType)
+    {
+        if (target->Class == ITEM_CLASS_ARMOR)
+        {
+            if (!((target->InventoryType == INVTYPE_ROBE || target->InventoryType == INVTYPE_CHEST) &&
+                (source->InventoryType == INVTYPE_ROBE || source->InventoryType == INVTYPE_CHEST)))
+                return false;
+        }
+        if (target->Class == ITEM_CLASS_WEAPON && !BotMgr::MixWeaponInventoryTypes())
+            return false;
+    }
+
+    NpcBotTransmogData const* transmogData = BotDataMgr::SelectNpcBotTransmogs(me->GetEntry());
+    if (transmogData && transmogData->transmogs[slot].second == source->ItemId)
+        return false;
+
+    return true;
+}
+
+bool bot_ai::OnGossipHello(Player* player)
+{
+    return OnGossipHello(player, 0);
+}
+bool bot_ai::OnGossipSelect(Player* player, uint32 /*menuId*/, uint32 gossipListId)
+{
+    uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+    uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+    return OnGossipSelect(player, me, sender, action);
+}
+bool bot_ai::OnGossipSelectCode(Player* player, uint32 /*menuId*/, uint32 gossipListId, char const* code)
+{
+    uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+    uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+    return OnGossipSelectCode(player, me, sender, action, code);
+}
+
+bool bot_ai::IsDamagingSpell(SpellInfo const* spellInfo)
+{
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellInfo->_effects[i].IsEffect())
+        {
+            switch (spellInfo->_effects[i].Effect)
+            {
+                case SPELL_EFFECT_WEAPON_DAMAGE:
+                case SPELL_EFFECT_WEAPON_DAMAGE_NOSCHOOL:
+                case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+                case SPELL_EFFECT_WEAPON_PERCENT_DAMAGE:
+                case SPELL_EFFECT_SCHOOL_DAMAGE:
+                case SPELL_EFFECT_ENVIRONMENTAL_DAMAGE:
+                case SPELL_EFFECT_HEALTH_LEECH:
+                    return true;
+                default:
+                    break;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool bot_ai::IsImmunedToMySpellEffect(Unit const* unit, SpellInfo const* spellInfo, SpellEffIndex index) const
+{
+    return unit->IsImmunedToSpellEffect(spellInfo, spellInfo->GetEffect(index), me);
+}
+
+bool bot_ai::IsBotCustomSpell(uint32 spellId)
+{
+    return BotCustomSpells.find(spellId) != BotCustomSpells.end();
+}
+
+void bot_ai::InitBotCustomSpells()
+{
+    static std::map<uint32, SpellInfo> spellInfoBackups;
+
+    if (spellInfoBackups.empty())
+    {
+        for (uint32 spellId : { SPELL_COMBAT_SPECIAL_2H_ATTACK, SPELL_TRANSPARENCY_50, SPELL_NETHERWALK, SPELL_MIRROR_IMAGE_BM,
+            SPELL_SHADOW_BLAST, SPELL_SHADOW_BOLT1, SPELL_ATTACK_MELEE_RANDOM, SHADOWFURY_VISUAL, SPELL_DEVOUR_MAGIC, SPELL_DRAIN_MANA, SPELL_REPLENISH_MANA, SPELL_REPLENISH_HEALTH,
+            SPELL_BRILLIANCE_AURA, SPELL_FIREBALL, SPELL_BLIZZARD, SPELL_SUMMON_WATER_ELEMENTAL, SPELL_WATERBOLT,
+            SPELL_VAMPIRIC_AURA, SPELL_TRIGGERED_HEAL, SPELL_SLEEP, SPELL_CARRION_SWARM, SPELL_INFERNO, SPELL_INFERNO_METEOR_VISUAL,
+            SPELL_STEAL_MAGIC, SPELL_FEEDBACK,
+            SPELL_BLACK_ARROW, SPELL_DRAIN_LIFE, SPELL_SILENCE,
+            SPELL_SHADOW_BOLT2, SPELL_RAISE_DEAD, SPELL_UNHOLY_FRENZY, SPELL_CRIPPLE, SPELL_CORPSE_EXPLOSION,
+            SPELL_FORKED_LIGHTNING, SPELL_FORKED_LIGHTNING_EFFECT, SPELL_FROST_ARROW, SPELL_FROST_ARROW_EFFECT, SPELL_MANA_SHIELD, SPELL_TORNADO,
+            SPELL_TORNADO_EFFECT, SPELL_TORNADO_EFFECT2, SPELL_TORNADO_EFFECT3, SPELL_SHOOT_BOW
+        })
+        {
+            spellInfoBackups.insert({ spellId, *sSpellMgr->GetSpellInfo(spellId) });
+        }
+    }
+
+    BotCustomSpells.clear();
+
+    if (BotMgr::IsClassEnabled(BOT_CLASS_BM))
+    {
+        //BotCustomSpells.insert(SPELL_COMBAT_SPECIAL_2H_ATTACK); //exclusive
+        BotCustomSpells.insert(SPELL_TRANSPARENCY_50);//3.1
+        BotCustomSpells.insert(SPELL_NETHERWALK);//3
+        BotCustomSpells.insert(SPELL_MIRROR_IMAGE_BM);//4
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_SPHYNX))
+    {
+        BotCustomSpells.insert(SPELL_SHADOW_BLAST);//5
+        BotCustomSpells.insert(SPELL_SHADOW_BOLT1);//6
+        //BotCustomSpells.insert(SPELL_ATTACK_MELEE_RANDOM);//7 //exclusive
+        //BotCustomSpells.insert(SHADOWFURY_VISUAL);//8 //exclusive
+        BotCustomSpells.insert(SPELL_DEVOUR_MAGIC);//9
+        BotCustomSpells.insert(SPELL_DRAIN_MANA);//10
+        BotCustomSpells.insert(SPELL_REPLENISH_MANA);//11
+        BotCustomSpells.insert(SPELL_REPLENISH_HEALTH);//12
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_ARCHMAGE))
+    {
+        BotCustomSpells.insert(SPELL_BRILLIANCE_AURA);//13
+        BotCustomSpells.insert(SPELL_FIREBALL);//14
+        BotCustomSpells.insert(SPELL_BLIZZARD);//15
+        BotCustomSpells.insert(SPELL_SUMMON_WATER_ELEMENTAL);//16
+        BotCustomSpells.insert(SPELL_WATERBOLT);//17
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_DREADLORD))
+    {
+        BotCustomSpells.insert(SPELL_VAMPIRIC_AURA);//18
+        //BotCustomSpells.insert(SPELL_TRIGGERED_HEAL);//19 //exclusive
+        BotCustomSpells.insert(SPELL_SLEEP);//20
+        BotCustomSpells.insert(SPELL_CARRION_SWARM);//21
+        BotCustomSpells.insert(SPELL_INFERNO);//22
+        //BotCustomSpells.insert(SPELL_INFERNO_METEOR_VISUAL);//23 //exclusive
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_SPELLBREAKER))
+    {
+        //BotCustomSpells.insert(SPELL_STEAL_MAGIC);//24 //exclusive
+        BotCustomSpells.insert(SPELL_FEEDBACK);//25
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_DARK_RANGER))
+    {
+        //BotCustomSpells.insert(SPELL_BLACK_ARROW);//26 //exclusive
+        //BotCustomSpells.insert(SPELL_DRAIN_LIFE);//27 //exclusive
+        //BotCustomSpells.insert(SPELL_SILENCE);//28 //exclusive
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_NECROMANCER))
+    {
+        BotCustomSpells.insert(SPELL_SHADOW_BOLT2);//29
+        BotCustomSpells.insert(SPELL_RAISE_DEAD);//30
+        BotCustomSpells.insert(SPELL_UNHOLY_FRENZY);//31
+        BotCustomSpells.insert(SPELL_CRIPPLE);//32
+        BotCustomSpells.insert(SPELL_CORPSE_EXPLOSION);//33
+        //BotCustomSpells.insert(SPELL_BLOOD_CURSE);//34 //NIY
+    }
+    if (BotMgr::IsClassEnabled(BOT_CLASS_SEA_WITCH))
+    {
+        BotCustomSpells.insert(SPELL_FORKED_LIGHTNING);//35
+        BotCustomSpells.insert(SPELL_FORKED_LIGHTNING_EFFECT);//36
+        BotCustomSpells.insert(SPELL_FROST_ARROW);//37
+        BotCustomSpells.insert(SPELL_FROST_ARROW_EFFECT);//38
+        BotCustomSpells.insert(SPELL_MANA_SHIELD);//39
+        BotCustomSpells.insert(SPELL_TORNADO);//40
+        BotCustomSpells.insert(SPELL_TORNADO_EFFECT);//41
+        BotCustomSpells.insert(SPELL_TORNADO_EFFECT2);//42
+        //BotCustomSpells.insert(SPELL_TORNADO_EFFECT3);//43 //exclusive
+        BotCustomSpells.insert(SPELL_SHOOT_BOW);//44
+    }
+
+    uint32 trig;
+    SpellInfo* trigInfo;
+    uint32 spellId;
+    SpellInfo* sinfo;
+
+    //BLADEMASTER
+    if (BotMgr::IsClassEnabled(BOT_CLASS_BM))
+    {
+        //2) SPELL_COMBAT_SPECIAL_2H_ATTACK
+        spellId = SPELL_COMBAT_SPECIAL_2H_ATTACK; //44079
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+        sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD;
+        //2) END SPELL_COMBAT_SPECIAL_2H_ATTACK
+
+        //3) WINDWALK
+        //3.1) TRANSPARENCY
+        trig = SPELL_TRANSPARENCY_50; //44816
+        trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+
+        trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+        trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+        trigInfo->AuraInterruptFlags =
+            AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+            AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+        trigInfo->CasterAuraStateNot = 0;
+        //3.1) END TRANSPARENCY
+
+        spellId = SPELL_NETHERWALK; //31599
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellLevel = 0;
+        sinfo->MaxLevel = 0;
+        sinfo->RecoveryTime = 5000;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 75 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+        sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY);
+        sinfo->AttributesEx &= ~SPELL_ATTR1_DONT_REFRESH_DURATION_ON_RECAST;
+        sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+        sinfo->AttributesEx2 |= SPELL_ATTR2_UNK1;
+        sinfo->AuraInterruptFlags =
+            AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+            AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+        sinfo->CasterAuraStateNot = 0;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[0].BasePoints = 100;
+        sinfo->_effects[0].RealPointsPerLevel = 2.5f;
+        sinfo->_effects[0].ValueMultiplier = 1.0f;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+        sinfo->_effects[0].Amplitude = 0;
+        sinfo->_effects[0].TriggerSpell = 0;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[1].BasePoints = 10;
+        sinfo->_effects[1].RealPointsPerLevel = 0.5f;
+        sinfo->_effects[1].ValueMultiplier = 1.0f;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[1].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+        sinfo->_effects[1].Amplitude = 0;
+        sinfo->_effects[1].TriggerSpell = 0;
+        sinfo->_effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+        sinfo->_effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+        sinfo->_effects[2].BasePoints = 0;
+        sinfo->_effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[2].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[2].ApplyAuraName = SPELL_AURA_NONE;
+        sinfo->_effects[2].Amplitude = 0;
+        sinfo->_effects[2].TriggerSpell = trig;
+        sinfo->_effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+        //3) END WINDWALK
+
+        //4) MIRROR IMAGE (BLADEMASTER)
+        spellId = SPELL_MIRROR_IMAGE_BM; //69936
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+        sinfo->RecoveryTime = 8000;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 125 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+        sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+        //sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[0].MiscValue = 0;
+        sinfo->_effects[0].MiscValueB = 0;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+        //4) END MIRROR IMAGE (BLADEMASTER)
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_COMBAT_SPECIAL_2H_ATTACK, SPELL_TRANSPARENCY_50, SPELL_NETHERWALK, SPELL_MIRROR_IMAGE_BM })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    //SPHYNX
+    if (BotMgr::IsClassEnabled(BOT_CLASS_SPHYNX))
+    {
+        //5) SHADOW BLAST (SPLASH ATTACK)
+        //TODO: balance
+        spellId = SPELL_SHADOW_BLAST; //38085
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SpellLevel = 60;
+        sinfo->MaxLevel = 83;
+        sinfo->ManaCost = BASE_MANA_SPHYNX / 16;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = nullptr;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT | TARGET_FLAG_DEST_LOCATION;
+        //sinfo->MaxAffectedTargets = 1000;
+        //sinfo->Attributes |= SPELL_ATTR0_HIDE_IN_COMBAT_LOG | SPELL_ATTR0_HIDDEN_CLIENTSIDE | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        sinfo->Attributes &= ~(SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION);
+        //sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        sinfo->_effects[0].BasePoints = 300;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 0.f;
+        sinfo->_effects[0].DamageMultiplier = 0.75f;
+        sinfo->_effects[0].RealPointsPerLevel = 50.f;
+        //sinfo->_effects[0].ValueMultiplier = 1.f;
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_SCHOOL_DAMAGE;
+        sinfo->_effects[1].BasePoints = 50;
+        sinfo->_effects[1].BonusMultiplier = 1.0f;
+        sinfo->_effects[1].DamageMultiplier = 0.5f;
+        sinfo->_effects[1].DieSides = /*17*/25;
+        sinfo->_effects[1].RealPointsPerLevel = 30.f;
+        //sinfo->_effects[1].ValueMultiplier = 1.f;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[1].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+        sinfo->_effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_12_YARDS);
+        //5) END SHADOW BLAST (SPLASH ATTACK)
+
+        //6) SHADOW BOLT (BASE ATTACK)
+        spellId = SPELL_SHADOW_BOLT1; //16408
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+        sinfo->SpellLevel = 60;
+        sinfo->MaxLevel = 83;
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = nullptr;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        //sinfo->Attributes |= SPELL_ATTR0_HIDE_IN_COMBAT_LOG | SPELL_ATTR0_HIDDEN_CLIENTSIDE | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        //sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+        sinfo->_effects[0].BasePoints = 200;
+        sinfo->_effects[0].DieSides = /*12*/25;
+        sinfo->_effects[0].BonusMultiplier = 1.15f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 10.f;
+        //sinfo->_effects[0].ValueMultiplier = 1.f;
+        //6) END SHADOW BOLT (BASE ATTACK)
+
+        //7) ATTACK ANIMATION
+        spellId = SPELL_ATTACK_MELEE_RANDOM; //42902
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+        //7) END ATTACK ANIMATION
+
+        //8) SPLASH ANIMATION
+        spellId = SHADOWFURY_VISUAL; //48582
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellLevel = 0;
+        sinfo->MaxLevel = 0;
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //100 yds
+        sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+        sinfo->MaxAffectedTargets = 1;
+        sinfo->Stances = 0;
+        sinfo->Speed = 0.f;
+        sinfo->Attributes |= SPELL_ATTR0_CASTABLE_WHILE_DEAD | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY;
+        sinfo->AttributesEx |= SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE | SPELL_ATTR1_NO_THREAT;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD | SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_USABLE_WHILE_STUNNED | SPELL_ATTR5_USABLE_WHILE_CONFUSED | SPELL_ATTR5_USABLE_WHILE_FEARED;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].BasePoints = 1;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].ValueMultiplier = 0.f;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].DamageMultiplier = 0.f;
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+        //8) END SPLASH ANIMATION
+
+        //9) DEVOUR MAGIC
+        spellId = SPELL_DEVOUR_MAGIC; //17012
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->InterruptFlags = 0xF;
+        sinfo->SpellLevel = 0;
+        sinfo->MaxLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->RecoveryTime = 7000;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(4); //1000ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(5); //40 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+        //sinfo->MaxAffectedTargets = 100;
+        sinfo->Attributes |= SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY;
+        sinfo->AttributesEx |= SPELL_ATTR1_NO_THREAT;
+        //sinfo->Attributes &= ~(SPELL_ATTR0_HIDE_IN_COMBAT_LOG);
+        //sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DISPEL;
+        sinfo->_effects[0].BasePoints = 2;
+        sinfo->_effects[0].MiscValue = DISPEL_MAGIC;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ALLY);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS);
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_DISPEL;
+        sinfo->_effects[1].BasePoints = 2;
+        sinfo->_effects[1].MiscValue = DISPEL_CURSE;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ALLY);
+        sinfo->_effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS);
+
+        sinfo->_effects[2].Effect = SPELL_EFFECT_DISPEL;
+        sinfo->_effects[2].BasePoints = 2;
+        sinfo->_effects[2].MiscValue = DISPEL_MAGIC;
+        sinfo->_effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+        sinfo->_effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_20_YARDS);
+        //9) END DEVOUR MAGIC
+
+        //10) DRAIN MANA
+        spellId = SPELL_DRAIN_MANA; //25755
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellLevel = 0;
+        sinfo->MaxLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->RecoveryTime = 0;//60000;
+        //sinfo->PowerType = POWER_MANA;
+        //sinfo->ManaCost = 0;
+        //sinfo->ManaCostPercentage = 0;
+        //sinfo->ManaCostPerlevel = 0;
+        sinfo->Speed = 0.f;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(4); //1000ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(5); //40 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        //sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+
+        //sinfo->_effects[0].Effect = SPELL_EFFECT_POWER_DRAIN;
+        sinfo->_effects[0].BasePoints = 999999;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ANY);
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        //10) END DRAIN MANA
+
+        //11) REPLENISH MANA
+        spellId = SPELL_REPLENISH_MANA; //33394
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SpellLevel = 0;
+        sinfo->RecoveryTime = 3000;
+        sinfo->CategoryEntry = nullptr;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->CastTimeEntry = nullptr;//sSpellCastTimesStore.LookupEntry(2); //250ms
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->MaxAffectedTargets = 100;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_IS_REPLENISHMENT | SPELL_ATTR0_HIDE_IN_COMBAT_LOG;
+        sinfo->AttributesEx |= SPELL_ATTR1_DRAIN_ALL_POWER/* | SPELL_ATTR1_CANT_TARGET_SELF*/;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_NO_DONE_BONUS;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_NOT_CHECK_SELFCAST_POWER;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_DONT_TURN_DURING_CAST;
+        sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+        sinfo->_effects[0].BasePoints = 3;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].ValueMultiplier = 0.f;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].DamageMultiplier = 0.f;
+        sinfo->_effects[0].TriggerSpell = SPELL_TRIGGERED_ENERGIZE;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_SRC_CASTER);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_SRC_AREA_ALLY);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_25_YARDS);
+        //11) END REPLENISH MANA
+
+        //12) REPLENISH HEALTH
+        spellId = SPELL_REPLENISH_HEALTH; //34756
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SpellLevel = 0;
+        sinfo->RecoveryTime = 3000;
+        sinfo->CategoryEntry = nullptr;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->CastTimeEntry = nullptr;//sSpellCastTimesStore.LookupEntry(2); //250ms
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->MaxAffectedTargets = 100;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_IS_REPLENISHMENT | SPELL_ATTR0_HIDE_IN_COMBAT_LOG;
+        sinfo->AttributesEx |= SPELL_ATTR1_DRAIN_ALL_POWER/* | SPELL_ATTR1_CANT_TARGET_SELF*/;
+        sinfo->AttributesEx &= ~(SPELL_ATTR1_CANT_TARGET_SELF);
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_NO_DONE_BONUS;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_NOT_CHECK_SELFCAST_POWER;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_DONT_TURN_DURING_CAST;
+        sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+        sinfo->_effects[0].BasePoints = 3;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].ValueMultiplier = 0.f;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].DamageMultiplier = 0.f;
+        sinfo->_effects[0].TriggerSpell = SPELL_TRIGGERED_HEAL;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_SRC_CASTER);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_SRC_AREA_ALLY);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_25_YARDS);
+        //12) END REPLENISH HEALTH
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_SHADOW_BLAST, SPELL_SHADOW_BOLT1, SPELL_ATTACK_MELEE_RANDOM, SHADOWFURY_VISUAL, SPELL_DEVOUR_MAGIC, SPELL_DRAIN_MANA, SPELL_REPLENISH_MANA, SPELL_REPLENISH_HEALTH })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    //ARCHMAGE
+    if (BotMgr::IsClassEnabled(BOT_CLASS_ARCHMAGE))
+    {
+        //13) BRILLIANCE AURA
+        spellId = SPELL_BRILLIANCE_AURA; //1234
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellLevel = 0;
+        sinfo->MaxLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //0 yds
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_PASSIVE;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_DONT_REMOVE_IN_ARENA;
+        sinfo->AttributesEx7 |= SPELL_ATTR7_CONSOLIDATED_RAID_BUFF;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_POWER_REGEN_PERCENT;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[0].BasePoints = 100;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[1].BasePoints = 10;
+        sinfo->_effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+        //for stacking rule
+        /*
+        sinfo->_effects[2].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[2].ApplyAuraName = SPELL_AURA_DUMMY;
+        sinfo->_effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[2].BasePoints = 1;
+        sinfo->_effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+        */
+        //13) END BRILLIANCE AURA
+
+        //14) FIREBALL (MAIN_ATTACK)
+        //TODO: balance
+        spellId = SPELL_FIREBALL; //9488
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellLevel = 20;
+        sinfo->BaseLevel = 20;
+        sinfo->MaxLevel = 81;
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = nullptr;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_FIRE | SPELL_SCHOOL_MASK_ARCANE;
+        //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        //sinfo->MaxAffectedTargets = 1000;
+        sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_ABILITY | SPELL_ATTR0_CASTABLE_WHILE_MOUNTED;
+        sinfo->Attributes &= ~(SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION);
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        sinfo->_effects[0].BasePoints = 15;
+        sinfo->_effects[0].DieSides = 9;
+        sinfo->_effects[0].BonusMultiplier = 0.5f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 15.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        //14) END FIREBALL (MAIN ATTACK)
+
+        //15) BLIZZARD
+        //TODO: balance
+        spellId = SPELL_BLIZZARD; //15783
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        sinfo->SpellLevel = 20;
+        sinfo->BaseLevel = 20;
+        sinfo->MaxLevel = 0;
+        sinfo->ManaCost = 75 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = nullptr;
+        sinfo->RecoveryTime = 6000;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+        ///sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+        //sinfo->MaxAffectedTargets = 1000;
+        sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_ABILITY | SPELL_ATTR0_CASTABLE_WHILE_MOUNTED;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS | SPELL_ATTR2_UNK22;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+
+        sinfo->_effects[0].BasePoints = 26;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 1.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 15.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_13_YARDS);
+        sinfo->_effects[0].Amplitude = 1000;
+        //15) END BLIZZARD
+
+        //16) SUMMON WATER ELEMENTAL (dummy spell)
+        spellId = SPELL_SUMMON_WATER_ELEMENTAL; //35593
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        sinfo->SpellLevel = 20;
+        sinfo->BaseLevel = 20;
+        sinfo->MaxLevel = 0;
+        sinfo->RecoveryTime = 20000;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 125 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        //sinfo->_effects[0].BasePoints = 1;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+        //16) END SUMMON WATER ELEMENTAL
+
+        //17) WATERBOLT (MAIN_ATTACK)
+        //TODO: balance, we only have 1 of 3 possible elementals so boost damage
+        spellId = SPELL_WATERBOLT; //72898
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_GENERIC;
+        sinfo->SpellLevel = 20;
+        sinfo->BaseLevel = 20;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(5); //2000ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        sinfo->_effects[0].BasePoints = 25;
+        sinfo->_effects[0].DieSides = 20;
+        sinfo->_effects[0].BonusMultiplier = 1.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 25.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        //17) END WATERBOLT (MAIN ATTACK)
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_BRILLIANCE_AURA, SPELL_FIREBALL, SPELL_BLIZZARD, SPELL_SUMMON_WATER_ELEMENTAL, SPELL_WATERBOLT })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    //DREADLORD
+    if (BotMgr::IsClassEnabled(BOT_CLASS_DREADLORD))
+    {
+        //18) VAMPIRIC AURA
+        spellId = SPELL_VAMPIRIC_AURA; //20810
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->ProcFlags = PROC_FLAG_DONE_MELEE_AUTO_ATTACK | PROC_FLAG_DONE_SPELL_MELEE_DMG_CLASS;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+        sinfo->SpellLevel = 0;
+        sinfo->BaseLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //0 yds
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_PASSIVE;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_DONT_REMOVE_IN_ARENA;
+        sinfo->AttributesEx7 |= SPELL_ATTR7_CONSOLIDATED_RAID_BUFF;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_CRIT_DAMAGE_BONUS;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[0].BasePoints = 5;
+        sinfo->_effects[0].MiscValue = SPELL_SCHOOL_MASK_NORMAL;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AREA_AURA_RAID;
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_PROC_TRIGGER_SPELL;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[1].BasePoints = 1;
+        sinfo->_effects[1].TriggerSpell = SPELL_TRIGGERED_HEAL;
+        sinfo->_effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+
+        //for stacking rule
+        /*
+        sinfo->_effects[2].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[2].ApplyAuraName = SPELL_AURA_DUMMY;
+        sinfo->_effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[2].BasePoints = 1;
+        sinfo->_effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+        */
+        //18) END VAMPIRIC AURA
+
+        //19) VAMPIRIC HEAL
+        spellId = SPELL_TRIGGERED_HEAL; //25155
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->Attributes &= ~(SPELL_ATTR0_NOT_SHAPESHIFT);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_NO_THREAT;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_DISABLE_PROC | SPELL_ATTR3_CAN_PROC_WITH_TRIGGERED | SPELL_ATTR3_NO_DONE_BONUS;
+
+        sinfo->_effects[0].BasePoints = 1;
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        //19) END VAMPIRIC HEAL
+
+        //20) SLEEP
+        spellId = SPELL_SLEEP; //20663
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->InterruptFlags = 0xF;
+        sinfo->SpellLevel = 0;
+        sinfo->BaseLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->Dispel = DISPEL_MAGIC;
+        sinfo->Mechanic = MECHANIC_SLEEP;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+        sinfo->RecoveryTime = 6000;
+        //sinfo->StartRecoveryCategory = 133;
+        //sinfo->StartRecoveryTime = 1000;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(3); //60000ms
+        sinfo->ManaCost = 50 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->AuraInterruptFlags = AURA_INTERRUPT_FLAG_DIRECT_DAMAGE;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes &= ~(SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_HEARTBEAT_RESIST_CHECK);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        //sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        //sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_STUN;
+        //sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        //sinfo->_effects[0].BasePoints = 1;
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_MOD_RESISTANCE_PCT;
+        sinfo->_effects[1].MiscValue = SPELL_SCHOOL_MASK_NORMAL;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[1].BasePoints = -100;
+        //20) END SLEEP
+
+        //21) CARRION SWARM
+        //TODO: balance
+        spellId = SPELL_CARRION_SWARM; //34240
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+        sinfo->SpellLevel = 40;
+        sinfo->BaseLevel = 40;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->RecoveryTime = 10000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 110 * 5;
+        //sinfo->MaxAffectedTargets = 1000;
+        //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT/* | SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS*/;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        //sinfo->_effects[0].Effect = SPELL_EFFECT_SCHOOL_DAMAGE;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CONE_ENEMY_104);
+        sinfo->_effects[0].BasePoints = 425;
+        sinfo->_effects[0].DieSides = 150;
+        sinfo->_effects[0].BonusMultiplier = 2.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 37.5f; //2000 avg at 80
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_40_YARDS);
+        //21) END CARRION SWARM
+
+        //22) INFERNO (dummy summon)
+        spellId = SPELL_INFERNO; //12740
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SpellLevel = 60;
+        sinfo->BaseLevel = 60;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+        sinfo->RecoveryTime = 180000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 175 * 5;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+        sinfo->Attributes &= ~(SPELL_ATTR0_ABILITY);
+        sinfo->AttributesEx |= /*SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE | */SPELL_ATTR1_NO_THREAT;
+        //sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+        sinfo->_effects[0].BasePoints = 1;
+        //22) END INFERNO
+
+        //23) INFERNO VISUAL (dummy summon)
+        spellId = SPELL_INFERNO_METEOR_VISUAL; //5739
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+
+        //sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+        //23) END INFERNO VISUAL
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_VAMPIRIC_AURA, SPELL_TRIGGERED_HEAL, SPELL_SLEEP, SPELL_CARRION_SWARM, SPELL_INFERNO, SPELL_INFERNO_METEOR_VISUAL })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    //SPELL BREAKER
+    if (BotMgr::IsClassEnabled(BOT_CLASS_SPELLBREAKER))
+    {
+        //24) STEAL MAGIC
+        spellId = SPELL_STEAL_MAGIC; //30036
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_PALADIN;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(34); //25 yds
+        sinfo->RecoveryTime = 2000;
+        sinfo->ManaCost = 75 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_POSSESSED_FRIENDS;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ANY);
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        //24) END STEAL MAGIC
+
+        //25) FEEDBACK
+        spellId = SPELL_FEEDBACK; //32897
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_PALADIN;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+        sinfo->SpellLevel = 0;
+        sinfo->BaseLevel = 0;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(13); //50000 yds
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes &= ~(SPELL_ATTR0_NOT_SHAPESHIFT);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_UNAFFECTED_BY_SCHOOL_IMMUNE;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_POWER_BURN;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        //25) END FEEDBACK
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_STEAL_MAGIC, SPELL_FEEDBACK })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    // DARK RANGER
+    if (BotMgr::IsClassEnabled(BOT_CLASS_DARK_RANGER))
+    {
+        //26) BLACK ARROW
+        //TODO: balance
+        spellId = SPELL_BLACK_ARROW; //20733
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        //sinfo->SpellFamilyFlags[0] = 0x0;
+        sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+        //sinfo->SpellFamilyFlags[2] = 0x0;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_RANGED;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_PACIFY;
+        sinfo->Dispel = DISPEL_NONE;
+        sinfo->Mechanic = MECHANIC_NONE;
+        sinfo->SpellLevel = 40;
+        sinfo->BaseLevel = 40;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //5-30 yds
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(85); //18 sec
+        sinfo->RecoveryTime = 3000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 6 * 5 * 2; //need to increase cost since ability is not autocast, has cd and deals more damage
+        sinfo->MaxAffectedTargets = 1;
+        sinfo->AuraInterruptFlags = AURA_INTERRUPT_FLAG_CHANGE_MAP;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK;
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS/* | SPELL_ATTR2_CANT_CRIT*/;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_WEAPON_PERCENT_DAMAGE;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].BasePoints = 150;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 1.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        sinfo->_effects[0].RadiusEntry = nullptr;
+
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_PERIODIC_DAMAGE;
+        sinfo->_effects[1].BasePoints = 100;
+        sinfo->_effects[1].DieSides = 0;
+        sinfo->_effects[1].BonusMultiplier = 2.f;
+        sinfo->_effects[1].DamageMultiplier = 1.f;
+        sinfo->_effects[1].RealPointsPerLevel = 10.f;
+        sinfo->_effects[1].ValueMultiplier = 1.f;
+        sinfo->_effects[1].RadiusEntry = nullptr;
+        sinfo->_effects[1].Amplitude = 2000;
+        //26) END BLACK ARROW
+
+        //27) DRAIN LIFE
+        //TODO: balance
+        spellId = SPELL_DRAIN_LIFE; //17238
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_MAGIC;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_SILENCE;
+        sinfo->Dispel = DISPEL_NONE;
+        sinfo->Mechanic = MECHANIC_NONE;
+        sinfo->SpellLevel = 40;
+        sinfo->BaseLevel = 40;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->CastTimeEntry = nullptr;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(85); //18 sec
+        sinfo->RecoveryTime = 5000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 75 * 5;
+        sinfo->MaxAffectedTargets = 1;
+        sinfo->AuraInterruptFlags = 0x0;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK;
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_NO_INITIAL_AGGRO | SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_START_PERIODIC_AT_APPLY;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_PERIODIC_LEECH;
+        sinfo->_effects[0].BasePoints = 45;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 1.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 6.f;
+        sinfo->_effects[0].ValueMultiplier = 2.f;
+        sinfo->_effects[0].RadiusEntry = nullptr;
+        sinfo->_effects[0].Amplitude = 1000;
+        //27) END DRAIN LIFE
+
+        //28) SILENCE
+        //TODO: balance
+        spellId = SPELL_SILENCE; //29943
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_SILENCE;
+        sinfo->Dispel = DISPEL_MAGIC;
+        sinfo->Mechanic = MECHANIC_SILENCE;
+        sinfo->SpellLevel = 60;
+        sinfo->BaseLevel = 60;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(2); //250ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(85); //18 sec
+        sinfo->RecoveryTime = 15000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 75 * 5;
+        sinfo->MaxAffectedTargets = 5;
+        sinfo->AuraInterruptFlags = 0x0;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT | TARGET_FLAG_DEST_LOCATION;
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_CANT_BE_REDIRECTED;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_SILENCE;
+        sinfo->_effects[0].BasePoints = 1;
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_15_YARDS);
+        //28) END SILENCE
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_BLACK_ARROW, SPELL_DRAIN_LIFE, SPELL_SILENCE })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    // NECROMANCER
+    if (BotMgr::IsClassEnabled(BOT_CLASS_NECROMANCER))
+    {
+        //29) SHADOW BOLT (MAIN_ATTACK)
+        //TODO: balance
+        spellId = SPELL_SHADOW_BOLT2; //17509
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SpellLevel = 20;
+        sinfo->BaseLevel = 20;
+        sinfo->MaxLevel = 82;
+        sinfo->ManaCost = 0;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->CastTimeEntry = nullptr;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+
+        sinfo->_effects[0].BasePoints = 15;
+        sinfo->_effects[0].DieSides = 9;
+        sinfo->_effects[0].BonusMultiplier = 0.5f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 12.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        //29) END SHADOW BOLT (MAIN_ATTACK)
+
+        //30) RAISE DEAD
+        spellId = SPELL_RAISE_DEAD; //34011
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW;
+        sinfo->InterruptFlags = 0xF;
+        sinfo->SpellLevel = 20;
+        sinfo->BaseLevel = 20;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(34); //25 yds
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //500ms
+        sinfo->RecoveryTime = 8000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 50 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_CORPSE_ENEMY;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ANY);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        sinfo->_effects[2].Effect = SPELL_EFFECT_NONE;
+        //30) END RAISE DEAD
+
+        //31) UNHOLY FRENZY
+        spellId = SPELL_UNHOLY_FRENZY; //52499
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW;
+        sinfo->SpellLevel = 30;
+        sinfo->BaseLevel = 30;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(22); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 sec //22 - 45 sec
+        sinfo->RecoveryTime = 2000; //original 1000
+        sinfo->CategoryEntry = nullptr;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 50 * 5;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_CANT_BE_REDIRECTED;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_ATTACKSPEED;
+        sinfo->_effects[0].BasePoints = 75;
+        sinfo->_effects[1].Amplitude = 1000;
+        sinfo->_effects[1].BasePoints = 1;
+        //31) END UNHOLY FRENZY
+
+        //32) CRIPPLE
+        spellId = SPELL_CRIPPLE; //50379
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+        sinfo->Dispel = DISPEL_CURSE; //TODO: check if works
+        sinfo->SpellLevel = 50;
+        sinfo->BaseLevel = 50;
+        sinfo->MaxLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(0); //0ms
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(3); //60 sec
+        sinfo->RecoveryTime = 10000;
+        sinfo->CategoryEntry = nullptr;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 175 * 5;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REFLECTED | SPELL_ATTR1_CANT_BE_REDIRECTED;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        //32) END CRIPPLE
+
+        //33) CORPSE EXPLOSION
+        spellId = SPELL_CORPSE_EXPLOSION; //61614
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_WARLOCK;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_NONE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_SHADOW;
+        sinfo->TargetCreatureType = 0x0000037F;
+        sinfo->InterruptFlags = 0xF;
+        sinfo->SpellLevel = 40;
+        sinfo->BaseLevel = 40;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(21); //-1
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(110); //750ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(3); //20 yds
+        sinfo->RecoveryTime = 1500;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 100 * 5;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_CORPSE_ENEMY;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ANY);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_10_YARDS);
+        sinfo->_effects[0].SpellClassMask[0] = 0;
+        sinfo->_effects[0].BasePoints = 1;
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        //33) END CORPSE EXPLOSION
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_SHADOW_BOLT2, SPELL_RAISE_DEAD, SPELL_UNHOLY_FRENZY, SPELL_CRIPPLE, SPELL_CORPSE_EXPLOSION })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    //SEA WITCH
+    if (BotMgr::IsClassEnabled(BOT_CLASS_SEA_WITCH))
+    {
+        //35) FORKED LIGHTNING
+        spellId = SPELL_FORKED_LIGHTNING; //63541
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_NATURE | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_SILENCE;
+        sinfo->InterruptFlags = 0x9;
+        sinfo->SpellLevel = 3;
+        sinfo->BaseLevel = 3;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(110); //750ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(4); //30 yds
+        sinfo->RecoveryTime = 11000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 110 * 5;
+        sinfo->MaxAffectedTargets = 2;
+        sinfo->Speed = 1000.f;
+        sinfo->AttributesEx |= SPELL_ATTR1_NO_THREAT;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_DONT_TURN_DURING_CAST;
+        //sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_INVISIBLE;
+
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CONE_ENEMY_24);
+        //sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_CONE_ENEMY_24);
+        sinfo->_effects[0].RadiusEntry = nullptr;//sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_50_YARDS);
+        sinfo->_effects[0].BasePoints = 1;
+        sinfo->_effects[0].DieSides = 49;
+        sinfo->_effects[0].BonusMultiplier = 2.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 20.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        //35) END FORKED LIGHTNING
+
+        //36) FORKED LIGHTNING EFFECT
+        spellId = SPELL_FORKED_LIGHTNING_EFFECT; //50900
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_NATURE | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->Dispel = DISPEL_MAGIC;
+        sinfo->Mechanic = MECHANIC_STUN;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(39); //2000ms
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //instant
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //100 yds
+        sinfo->ManaCost = 0;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx5 |= SPELL_ATTR5_DONT_TURN_DURING_CAST;
+        sinfo->AttributesEx6 |= SPELL_ATTR6_CAN_TARGET_INVISIBLE;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_STUN;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].RadiusEntry = nullptr;
+        //36) END FORKED LIGHTNING EFFECT
+
+        //37) FROST ARROW
+        spellId = SPELL_FROST_ARROW; //38942
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        //sinfo->SpellFamilyFlags[0] = 0x0;
+        sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+        //sinfo->SpellFamilyFlags[2] = 0x0;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_RANGED;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_PACIFY;
+        sinfo->Dispel = DISPEL_NONE;
+        sinfo->Mechanic = MECHANIC_NONE;
+        sinfo->SpellLevel = 3;
+        sinfo->BaseLevel = 3;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(110); //750ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(35); //0-35 yds
+        sinfo->DurationEntry = nullptr;
+        sinfo->RecoveryTime = 0;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 750;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 10 * 5;
+        sinfo->MaxAffectedTargets = 1;
+        sinfo->AuraInterruptFlags = AURA_INTERRUPT_FLAG_CHANGE_MAP;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE;
+        sinfo->Attributes &= ~(SPELL_ATTR0_REQ_AMMO);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS/* | SPELL_ATTR2_CANT_CRIT*/;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+        sinfo->AttributesEx4 &= ~(SPELL_ATTR4_INHERIT_CRIT_FROM_AURA);
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_WEAPON_DAMAGE;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].BasePoints = 10;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 0.5f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 2.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        sinfo->_effects[0].RadiusEntry = nullptr;
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        //37) END FROST ARROW
+
+        //38) FROST ARROW EFFECT
+        spellId = SPELL_FROST_ARROW_EFFECT; //56095
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_GENERIC;
+        //sinfo->SpellFamilyFlags[0] = 0x0;
+        sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+        //sinfo->SpellFamilyFlags[2] = 0x0;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_FROST | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->Dispel = DISPEL_MAGIC;
+        sinfo->Mechanic = MECHANIC_SNARE;
+        sinfo->Attributes &= ~(SPELL_ATTR0_CAST_TRACK_TARGET);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_IGNORE_RESISTANCES;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_SPEED_SLOW_ALL;
+        sinfo->_effects[0].Mechanic = MECHANIC_SLOW_ATTACK;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[0].BasePoints = -30;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 1.f;
+        sinfo->_effects[0].DamageMultiplier = 1.f;
+        sinfo->_effects[0].RealPointsPerLevel = 0.f;
+        sinfo->_effects[0].ValueMultiplier = 1.f;
+        sinfo->_effects[0].RadiusEntry = nullptr;
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_MOD_DECREASE_SPEED;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        sinfo->_effects[1].BasePoints = -30;
+        sinfo->_effects[1].DieSides = 0;
+        sinfo->_effects[1].BonusMultiplier = 1.f;
+        sinfo->_effects[1].DamageMultiplier = 1.f;
+        sinfo->_effects[1].RealPointsPerLevel = 0.f;
+        sinfo->_effects[1].ValueMultiplier = 1.f;
+        sinfo->_effects[1].RadiusEntry = nullptr;
+        //38) END FROST ARROW EFFECT
+
+        //39) MANA SHIELD
+        spellId = SPELL_MANA_SHIELD; //35064
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->Dispel = DISPEL_NONE;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_NONE;
+        sinfo->SpellLevel = 0;
+        sinfo->BaseLevel = 0;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(21); //-1
+        sinfo->RecoveryTime = 10000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_DISABLED_WHILE_ACTIVE;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+        sinfo->AttributesEx4 |= SPELL_ATTR4_NOT_STEALABLE;
+
+        sinfo->_effects[0].BasePoints = 1000000000;
+        sinfo->_effects[0].ValueMultiplier = 10.f;
+        //39) END MANA SHIELD
+
+        //40) TORNADO
+        spellId = SPELL_TORNADO; //34695
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_NATURE | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->InterruptFlags = 0x9;
+        sinfo->SpellLevel = 60;
+        sinfo->BaseLevel = 60;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = nullptr;
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(15); //4000ms
+        //sinfo->RangeEntry = sSpellRangeStore.LookupEntry(5); //40 yds
+        sinfo->RecoveryTime = 120000;
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 1500;
+        sinfo->ManaCost = 250 * 5;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_OUTDOORS_ONLY;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT | SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+        sinfo->AttributesEx3 &= ~(SPELL_ATTR3_ONLY_TARGET_PLAYERS);
+        sinfo->AttributesEx4 = 0;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DEST);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[0].RadiusEntry = nullptr;
+        sinfo->_effects[0].BasePoints = 1;
+        sinfo->_effects[0].TriggerSpell = 0;
+        sinfo->_effects[0].Amplitude = 0;
+        sinfo->_effects[1].Effect = SPELL_EFFECT_NONE;
+        //40) END TORNADO
+
+        //41) TORNADO EFFECT
+        spellId = SPELL_TORNADO_EFFECT; //21990
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        //sinfo->SpellFamilyFlags[0] = 0x0;
+        sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+        //sinfo->SpellFamilyFlags[2] = 0x0;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_NATURE | SPELL_SCHOOL_MASK_ARCANE;
+        sinfo->Dispel = DISPEL_MAGIC;
+        sinfo->Mechanic = MECHANIC_NONE; //MECHANIC_KNOCKOUT
+        sinfo->InterruptFlags = 0x0;
+        sinfo->SpellLevel = 60;
+        sinfo->BaseLevel = 60;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(29); //12000ms
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //0ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(2); //5 yds
+        sinfo->RecoveryTime = 3000;
+        //sinfo->StartRecoveryCategory = 133;
+        //sinfo->StartRecoveryTime = 1500;
+        //sinfo->ManaCost = 250 * 5;
+        sinfo->MaxAffectedTargets = 1;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_ABILITY | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_OUTDOORS_ONLY;
+        sinfo->Attributes &= ~(SPELL_ATTR0_HEARTBEAT_RESIST_CHECK);
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CANT_CRIT | SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT | SPELL_ATTR3_NO_DONE_BONUS;
+        sinfo->AttributesEx3 &= ~(SPELL_ATTR3_ONLY_TARGET_PLAYERS);
+        sinfo->AttributesEx4 = 0;
+        sinfo->AttributesEx5 = 0;
+
+        //sinfo->_effects[0].Effect = SPELL_EFFECT_DUMMY;
+        //sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        //sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        //sinfo->_effects[0].RadiusEntry = nullptr;
+        //sinfo->_effects[0].BasePoints = 1;
+        //sinfo->_effects[0].TriggerSpell = 0;
+        //sinfo->_effects[0].Amplitude = 0;
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_MOD_RESISTANCE_PCT;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[1].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[1].BasePoints = -100;
+        sinfo->_effects[1].MiscValue = SPELL_SCHOOL_MASK_ALL;
+        sinfo->_effects[2].Effect = SPELL_EFFECT_APPLY_AURA;
+        sinfo->_effects[2].ApplyAuraName = SPELL_AURA_PERIODIC_DAMAGE;
+        sinfo->_effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[2].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[2].BasePoints = 212;
+        sinfo->_effects[2].DieSides = 183;
+        sinfo->_effects[2].RealPointsPerLevel = 35.f;
+        sinfo->_effects[2].BonusMultiplier = 0.25f;
+        sinfo->_effects[2].Amplitude = 1500;
+        //41) END TORNADO EFFECT
+
+        //42) TORNADO EFFECT2
+        spellId = SPELL_TORNADO_EFFECT2; //34683
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        //sinfo->SpellFamilyFlags[0] = 0x0;
+        //sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+        //sinfo->SpellFamilyFlags[2] = 0x0;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_NATURE | SPELL_SCHOOL_MASK_ARCANE;
+        //sinfo->Dispel = DISPEL_MAGIC;
+        //sinfo->Mechanic = MECHANIC_DISORIENTED;
+        sinfo->ProcFlags = 0;
+        sinfo->InterruptFlags = 0x0;
+        sinfo->SpellLevel = 60;
+        sinfo->BaseLevel = 60;
+        sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = nullptr;
+        //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //0ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(7); //10 yds
+        sinfo->RecoveryTime = 4500;
+        //sinfo->StartRecoveryCategory = 133;
+        //sinfo->StartRecoveryTime = 1500;
+        //sinfo->ManaCost = 250 * 5;
+        sinfo->MaxAffectedTargets = 1;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_OUTDOORS_ONLY;
+        sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx4 = 0;
+        sinfo->AttributesEx5 = 0;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_SCHOOL_DAMAGE;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        //sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_10_YARDS);
+        sinfo->_effects[0].BasePoints = 541;
+        sinfo->_effects[0].DieSides = 215;
+        sinfo->_effects[0].RealPointsPerLevel = 40.f;
+        sinfo->_effects[0].BonusMultiplier = 0.5f;
+        //42) END TORNADO EFFECT2
+
+        //43) TORNADO EFFECT3
+        spellId = SPELL_TORNADO_EFFECT3; //39261
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        //sinfo->SpellFamilyFlags[0] = 0x0;
+        //sinfo->SpellFamilyFlags[1] = 0x4; //custom, not present in db
+        //sinfo->SpellFamilyFlags[2] = 0x0;
+        sinfo->SchoolMask = SPELL_SCHOOL_MASK_NATURE | SPELL_SCHOOL_MASK_ARCANE;
+        //sinfo->Dispel = DISPEL_NONE;
+        //sinfo->Mechanic = MECHANIC_DISORIENTED;
+        //sinfo->ProcFlags = 0;
+        //sinfo->InterruptFlags = 0x0;
+        sinfo->SpellLevel = 0;
+        sinfo->BaseLevel = 0;
+        //sinfo->MaxTargetLevel = 0;
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(21); //-1
+        //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //0ms
+        //sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //self
+        //sinfo->RecoveryTime = 4500;
+        //sinfo->StartRecoveryCategory = 133;
+        //sinfo->StartRecoveryTime = 1500;
+        //sinfo->ManaCost = 250 * 5;
+        //sinfo->MaxAffectedTargets = 1;
+        //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE | SPELL_ATTR0_OUTDOORS_ONLY;
+        sinfo->AttributesEx |= SPELL_ATTR1_NO_THREAT;
+        sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS;
+        sinfo->AttributesEx3 |= SPELL_ATTR3_IGNORE_HIT_RESULT;
+        sinfo->AttributesEx4 = 0;
+        sinfo->AttributesEx5 = 0;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_APPLY_AREA_AURA_ENEMY;
+        //sinfo->_effects[0].ApplyAuraName = SPELL_AURA_MOD_DECREASE_SPEED;
+        //sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_SRC_CASTER);
+        //sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_SRC_AREA_ENEMY);
+        sinfo->_effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_5_YARDS);
+        //sinfo->_effects[0].BasePoints = -50;
+        sinfo->_effects[1].Effect = SPELL_EFFECT_APPLY_AREA_AURA_ENEMY;
+        sinfo->_effects[1].ApplyAuraName = SPELL_AURA_MOD_DECREASE_SPEED;
+        sinfo->_effects[1].TargetA = SpellImplicitTargetInfo(TARGET_SRC_CASTER);
+        sinfo->_effects[1].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_SRC_AREA_ENEMY);
+        sinfo->_effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_5_YARDS);
+        sinfo->_effects[1].BasePoints = -60;
+        //sinfo->AttributesCu &= ~(SPELL_ATTR0_CU_NEGATIVE_EFF1);
+        //43) END TORNADO EFFECT3
+
+        //44) SHOOT
+        spellId = SPELL_SHOOT_BOW; //41188
+        sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        sinfo->SpellFamilyName = SPELLFAMILY_MAGE;
+        sinfo->DmgClass = SPELL_DAMAGE_CLASS_RANGED;
+        sinfo->PreventionType = SPELL_PREVENTION_TYPE_PACIFY;
+        sinfo->SpellLevel = 1;
+        sinfo->BaseLevel = 1;
+        sinfo->CategoryEntry = sSpellCategoryStore.LookupEntry(76);
+        sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(110); //750ms
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(35); //0-35 yds
+        sinfo->StartRecoveryCategory = 133;
+        sinfo->StartRecoveryTime = 750;
+        sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT;
+        sinfo->Attributes |= SPELL_ATTR0_IMPOSSIBLE_DODGE_PARRY_BLOCK/* | SPELL_ATTR0_DONT_AFFECT_SHEATH_STATE*/;
+        sinfo->Attributes &= ~(SPELL_ATTR0_REQ_AMMO/* | SPELL_ATTR0_ABILITY*/ | SPELL_ATTR0_CAST_TRACK_TARGET | SPELL_ATTR0_LEVEL_DAMAGE_CALCULATION | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY);
+        sinfo->AttributesEx |= SPELL_ATTR1_CANT_BE_REDIRECTED | SPELL_ATTR1_CANT_BE_REFLECTED;
+        sinfo->AttributesEx &= ~(SPELL_ATTR1_CHANNEL_TRACK_TARGET | SPELL_ATTR1_NO_THREAT);
+        sinfo->AttributesEx2 |= SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS;
+        sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+        sinfo->AttributesEx3 |= SPELL_ATTR3_UNK15;
+
+        sinfo->_effects[0].Effect = SPELL_EFFECT_WEAPON_PERCENT_DAMAGE;
+        sinfo->_effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_TARGET_ENEMY);
+        sinfo->_effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->_effects[0].BasePoints = 100;
+        sinfo->_effects[0].DieSides = 0;
+        sinfo->_effects[0].BonusMultiplier = 1.f;
+        //44) END SHOOT
+    }
+    else
+    {
+        for (uint32 spellId : { SPELL_FORKED_LIGHTNING, SPELL_FORKED_LIGHTNING_EFFECT, SPELL_FROST_ARROW, SPELL_FROST_ARROW_EFFECT, SPELL_MANA_SHIELD, SPELL_TORNADO,
+            SPELL_TORNADO_EFFECT, SPELL_TORNADO_EFFECT2, SPELL_TORNADO_EFFECT3, SPELL_SHOOT_BOW })
+            *const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId)) = spellInfoBackups.at(spellId);
+    }
+
+    TC_LOG_INFO("server.loading", "Re-Loading Spell Proc conditions...");
+    sSpellMgr->LoadSpellProcs();
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 000000000..2d42b5140
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,712 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "botcommon.h"
+
+#include "CreatureAI.h"
+#include "EventProcessor.h"
+#include "ItemDefines.h"
+#include "Position.h"
+
+#include <tuple>
+
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+*/
+
+class TeleportHomeEvent;
+class TeleportFinishEvent;
+class AwaitStateRemovalEvent;
+
+enum CombatRating : uint8;
+enum GossipOptionIcon : uint8;
+enum MeleeHitOutcome : uint8;
+
+struct CleanDamage;
+struct CalcDamageInfo;
+struct ItemTemplate;
+struct PlayerClassLevelInfo;
+struct SpellNonMeleeDamage;
+
+class Aura;
+class DamageInfo;
+class Item;
+class Spell;
+class SpellCastTargets;
+class Unit;
+class Vehicle;
+
+class bot_ai : public CreatureAI
+{
+    public:
+        virtual ~bot_ai();
+
+        bool canUpdate;
+
+        void InitializeAI() override { Reset(); }
+        //void Reset() override { }
+
+        void JustDied(Unit*) override;
+        void KilledUnit(Unit* u) override;
+        void AttackStart(Unit* u) override;
+        void JustEnteredCombat(Unit* u) override;
+        void MoveInLineOfSight(Unit* u) override;
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override;
+        //void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override { }
+        void ReceiveEmote(Player* player, uint32 emote) override;
+        //void EnterEvadeMode(EvadeReason/* why*/ = EVADE_REASON_OTHER) override { }
+        //void LeavingWorld() override { }
+        void OnSpellStart(SpellInfo const* spellInfo) override { OnBotSpellStart(spellInfo); }
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        virtual void OnBotDamageTaken(Unit* /*attacker*/, uint32 /*damage*/, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* /*spellInfo*/) {}
+        virtual void OnBotDamageDealt(Unit* /*victim*/, uint32 /*damage*/, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* /*spellInfo*/) {}
+        virtual void OnBotDispelDealt(Unit* /*dispelled*/, uint8 /*num*/) {}
+
+        bool OnGossipHello(Player* player) override;
+        bool OnGossipSelect(Player* player, uint32 menuId, uint32 gossipListId) override;
+        bool OnGossipSelectCode(Player* player, uint32 menuId, uint32 gossipListId, char const* code) override;
+
+        virtual void OnBotEnterVehicle(Vehicle const* /*vehicle*/);
+        virtual void OnBotExitVehicle(Vehicle const* /*vehicle*/);
+        virtual void AfterBotOwnerEnterVehicle();
+        virtual void OnBotOwnerEnterVehicle(Vehicle const* /*vehicle*/);
+        virtual void OnBotOwnerExitVehicle(Vehicle const* /*vehicle*/);
+
+        Unit* SpawnVehicle(uint32 creEntry, uint32 vehEntry);
+        void ChooseVehicleForEncounter(uint32 &creEntry, uint32 &vehEntry) const;
+
+        static Position GetAbsoluteTransportPosition(WorldObject const* object);
+
+        static const std::string& LocalizedNpcText(Player const* forPlayer, uint32 textId);
+
+        bool OnGossipHello(Player* player, uint32 option);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code);
+
+        Creature* GetBotsPet() const { return botPet; }
+
+        void Evade();
+
+        EventProcessor* GetEvents() { return &Events; }
+        ObjectGuid::LowType GetBotOwnerGuid() const { return _ownerGuid; }
+        Player* GetBotOwner() const { return master; }
+        bool SetBotOwner(Player* newowner);
+        void CheckOwnerExpiry();
+        uint8 GetBotClass() const { return _botclass; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        virtual void UpdateDeadAI(uint32 /*diff*/) {}
+        void ReturnHome() { _atHome = false; }
+        void CommonTimers(uint32 diff);
+        void ResetBotAI(uint8 resetType);
+        void KillEvents(bool force);
+        bool CanRespawn() { return IAmFree(); }
+        void BotMovement(BotMovementType type, Position const* pos, Unit* target = nullptr, bool generatePath = true) const;
+        bool CanBotMoveVehicle() const;
+        void SetBotCommandState(uint8 st, bool force = false, Position* newpos = nullptr);
+        void RemoveBotCommandState(uint8 st);
+        bool HasBotCommandState(uint8 st) const { return (m_botCommandState & st); }
+        void SetBotAwaitState(uint8 state);
+        inline void RemoveBotAwaitState(uint8 state) { _botAwaitState &= ~state; }
+        inline bool HasBotAwaitState(uint8 state) const { return !!(_botAwaitState & state); }
+        void EventRemoveBotAwaitState(uint8 state);
+        void AbortAwaitStateRemoval();
+        uint8 GetBotCommandState() const { return m_botCommandState; }
+        bool IsInBotParty(Unit const* unit) const;
+        bool IsInBotParty(ObjectGuid guid) const;
+        bool CanBotAttack(Unit const* target, int8 byspell = 0, bool secondary = false) const;
+        bool CanBotAttackOnVehicle() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool iscrit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool iscrit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const;
+        void ApplyBotSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const;
+        void ApplyBotSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const;
+        void ApplyBotSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const;
+        void ApplyBotSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const;
+        void ApplyBotEffectMods(WorldObject const* wtarget, SpellInfo const* spellInfo, uint8 effIndex, float& value) const;
+        void ApplyBotThreatMods(SpellInfo const* spellInfo, float& threat) const;
+        void ApplyBotEffectValueMultiplierMods(SpellInfo const* spellInfo, SpellEffIndex effIndex, float& multiplier) const;
+        virtual uint8 GetBotStance() const;
+        uint32 GetBotRoles() const { return _roleMask; }
+        bool HasRole(uint32 role) const { return _roleMask & role; }
+        GossipOptionIcon GetRoleIcon(uint32 role) const;
+        static uint32 GetRoleString(uint32 role);
+        void ToggleRole(uint32 role, bool force);
+        static uint32 DefaultRolesForClass(uint8 m_class);
+        bool IsTank(Unit const* unit = nullptr) const;
+        bool IsOffTank(Unit const* unit = nullptr) const;
+
+        uint32 GetLastZoneId() const { return _lastZoneId; }
+        bool IsInHeroicOrRaid() const;
+
+        bool IAmFree() const;
+
+        static bool CCed(Unit const* target, bool root = false);
+
+        void TeleportHome();
+        bool FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/);
+
+        bool IsDuringTeleport() const { return teleFinishEvent || teleHomeEvent; }
+        void SetTeleportFinishEvent(TeleportFinishEvent* tfevent) { ASSERT(!teleFinishEvent); teleFinishEvent = tfevent; }
+        void AbortTeleport();
+
+        uint8 GetPlayerClass() const;
+        uint8 GetPlayerRace() const;
+
+        bool IsTempBot() const;
+
+        void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        void UpdateHealth() { doHealth = true; }
+        void UpdateMana() { doMana = true; }
+
+        //float GetHitRating() const { return hit; }
+        int32 GetHaste() const { return haste; }
+        float GetBotParryChance() const { return parry; }
+        float GetBotDodgeChance() const { return dodge; }
+        float GetBotBlockChance() const { return block; }
+        float GetBotCritChance() const { return crit; }
+        float GetBotMissChance() const { return -hit; }
+        float GetBotDamageTakenMod(bool magic) const { return magic ? dmg_taken_mag : dmg_taken_phy; }
+        uint32 GetBotExpertise() const { return expertise; }
+        uint32 GetBotSpellPenetration() const { return spellpen; }
+        uint32 GetBotSpellPower() const { return spellpower; }
+        uint32 GetBotDefense() const { return defense; }
+        uint32 GetShieldBlockValue() const { return blockvalue; }
+        int32 GetBotResistanceBonus(SpellSchoolMask mask) const;
+        int32 GetBotResistanceBonus(uint8 school) const { return (school > SPELL_SCHOOL_NORMAL && school < MAX_SPELL_SCHOOL) ? resistbonus[school-1] : 0; }
+        bool CanBlock() const;
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+        bool CanSheath() const;
+        bool CanSit() const;
+        virtual bool CanEat() const;
+        bool CanDrink() const;
+        bool CanRegenInCombat() const;
+        bool CanMount() const;
+        bool CanUseAmmo() const;
+        bool RespectEquipsAttackTime() const;
+        bool CanChangeEquip(uint8 slot) const;
+        bool CanDisplayNonWeaponEquipmentChanges() const;
+        bool IsValidTransmog(uint8 slot, ItemTemplate const* source) const;
+        virtual bool CanSeeEveryone() const { return false; }
+        virtual float GetBotArmorPenetrationCoef() const { return armor_pen; }
+        virtual uint32 GetAIMiscValue(uint32 /*data*/) const { return 0; }
+        virtual void SetAIMiscValue(uint32 /*data*/, uint32 /*value*/) {}
+        uint8 GetBotComboPoints() const;
+        float GetBotAmmoDPS() const;
+
+        MeleeHitOutcome BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        float GetTotalBotStat(BotStatMods stat) const { return _getTotalBotStat(stat); }
+
+        Item* GetEquips(uint8 slot) const { return _equips[slot]; }
+        Item* GetEquipsByGuid(ObjectGuid itemGuid) const;
+        uint32 GetEquipDisplayId(uint8 slot) const;
+        bool UnEquipAll(ObjectGuid receiver);
+        bool HasRealEquipment() const;
+        float GetAverageItemLevel() const;
+
+        void CastBotItemCombatSpell(DamageInfo const& damageInfo);
+        void CastBotItemCombatSpell(DamageInfo const& damageInfo, Item* item, ItemTemplate const* proto);
+        void OnBotSpellStart(SpellInfo const* spellInfo);
+        void OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        void OnBotSpellGo(Spell const* spell, bool ok = true);
+        void OnBotOwnerSpellGo(Spell const* spell, bool ok = true);
+        void OnOwnerVehicleDamagedBy(Unit* attacker);
+        virtual void OnClassSpellStart(SpellInfo const* /*spellInfo*/) {}
+        virtual void OnClassSpellGo(SpellInfo const* /*spell*/) {}
+
+        static void InitBotCustomSpells();
+        static bool IsBotCustomSpell(uint32 spellId);
+
+        uint32 GetReviveTimer() const { return _reviveTimer; }
+        void SetReviveTimer(uint32 newtime) { _reviveTimer = newtime; }
+        void UpdateReviveTimer(uint32 diff);
+
+        uint32 GetEngageTimer() const { return _engageTimer; }
+        void ResetEngageTimer(uint32 delay);
+
+        bool HasSpell(uint32 basespell) const;
+        uint32 GetBaseSpell(std::string_view spell_name, LocaleConstant locale) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+        void ReleaseSpellCooldown(uint32 basespell);
+
+        virtual void SpendRunes(SpellInfo const* /*spellInfo*/, bool /*didHit*/) {}
+
+        void ReInitFaction() { InitFaction(); }
+        void ReinitOwner() { InitOwner(); }
+        void SetSpec(uint8 spec, bool activate = true);
+        uint8 GetSpec() const { return _spec; }
+        static uint8 DefaultSpecForClass(uint8 m_class);
+        static uint32 TextForSpec(uint8 spec);
+        static bool IsValidSpecForClass(uint8 m_class, uint8 spec);
+
+        static bool IsMeleeClass(uint8 m_class);
+        static bool IsTankingClass(uint8 m_class);
+        static bool IsBlockingClass(uint8 m_class);
+        static bool IsCastingClass(uint8 m_class);
+        static bool IsHealingClass(uint8 m_class);
+        static bool IsHumanoidClass(uint8 m_class);
+        static bool IsHeroExClass(uint8 m_class);
+
+        AoeSpotsVec const& GetAoeSpots() const;
+        static void CalculateAoeSpots(Unit const* unit, AoeSpotsVec& spots);
+        void CalculateAoeSafeSpots(Unit* target, float maxdist, AoeSafeSpotsVec& safespots) const;
+
+        //Pet stuff
+        static uint32 GetPetOriginalEntry(uint32 entry);
+        static bool IsPetMelee(uint32 entry);
+        virtual uint8 GetPetPositionNumber(Creature const* /*summon*/) const { return 0; }
+
+        Unit* HelpFindStunTarget(float dist = 20) const { return FindStunTarget(dist); }
+        Unit* HelpFindCastingTarget(float maxdist = 10, float mindist = 0, uint32 spellId = 0, uint8 minHpPct = 0) const { return FindCastingTarget(maxdist, mindist, spellId, minHpPct); }
+        Unit* HelpFindAOETarget(float dist, WorldObject const* src) const { return FindAOETarget(dist, src); }
+        void HelpGetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, uint8 CCoption, WorldObject const* source = nullptr) const { GetNearbyTargetsList(targets, maxdist, CCoption, source); }
+
+        bool IsPointedTarget(Unit const* target, uint8 targetFlags) const;
+        bool IsPointedHealTarget(Unit const* target) const;
+        bool IsPointedTankingTarget(Unit const* target) const;
+        bool IsPointedDPSTarget(Unit const* target) const;
+        bool IsPointedRangedDPSTarget(Unit const* target) const;
+        bool IsPointedNoDPSTarget(Unit const* target) const;
+        bool IsPointedAnyAttackTarget(Unit const* target) const;
+
+        static bool IsDamagingSpell(SpellInfo const* spellInfo);
+
+        bool IsImmunedToMySpellEffect(Unit const* unit, SpellInfo const* spellInfo, SpellEffIndex index) const;
+
+    protected:
+        explicit bot_ai(Creature* creature);
+
+        virtual void ReduceCD(uint32 /*diff*/) {}
+        bool GlobalUpdate(uint32 diff);
+
+        virtual bool HealTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+
+        void BuffAndHealGroup(uint32 diff);
+        void ResurrectGroup(uint32 REZZ);
+        void CureGroup(uint32 cureSpell, uint32 diff);
+        void SetStats(bool force);
+        void DefaultInit();
+        void InitUnitFlags(); // call only in constructor
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        //void RemoveAllSpells();
+        void EnableAllSpells();
+        void SpellTimers(uint32 diff);
+        static uint32 RaceSpellForClass(uint8 myrace, uint8 myclass);
+
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        virtual bool HasAbilitiesSpecifics() const { return false; }
+        virtual void FillAbilitiesSpecifics(Player const* /*player*/, std::list<std::string> &/*specList*/) {}
+
+        virtual std::vector<uint32> const* GetDamagingSpellsList() const { return nullptr; }
+        virtual std::vector<uint32> const* GetCCSpellsList() const       { return nullptr; }
+        virtual std::vector<uint32> const* GetHealingSpellsList() const  { return nullptr; }
+        virtual std::vector<uint32> const* GetSupportSpellsList() const  { return nullptr; }
+
+        uint32 GetDPSTaken(Unit const* u) const;
+        int32 GetHPSTaken(Unit const* u) const;
+        int32 GetHPS(Unit const* u) const;
+        int32 GetHPPCTPS(Unit const* u) const;
+        uint8 GetExpectedHPPCT(Unit const* u, uint32 mseconds) const;
+
+        void RefreshAura(uint32 spellId, int8 count = 1, Unit* target = nullptr) const;
+        bool CheckAttackTarget();
+        void MoveBehind(Unit const* target) const;
+
+        void OnStartAttack(Unit const* u);
+        bool StartAttack(Unit const* u, bool force = false);
+
+        virtual void BreakCC(uint32 diff);
+        void CheckRacials(uint32 diff);
+
+        void DrinkPotion(bool mana);
+        bool IsPotionReady() const;
+        uint32 GetPotion(bool mana) const;
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false);
+        bool doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags);
+        SpellCastResult CheckBotCast(Unit const* victim, uint32 spellId) const;
+        virtual bool removeShapeshiftForm() { return true; }
+
+        bool CanRemoveReflectSpells(Unit const* target, uint32 spellId) const;
+
+        bool IsMelee() const;
+        bool IsRanged() const;
+
+        bool IsShootingWand(Unit const* u = nullptr) const;
+
+        bool IsChanneling(Unit const* u = nullptr) const;
+        bool IsCasting(Unit const* u = nullptr) const;
+        bool JumpingFlyingOrFalling() const;
+        bool JumpingOrFalling() const;
+        bool Jumping() const;
+        bool IsInContactWithWater() const;
+
+        float CalcSpellMaxRange(uint32 spellId, bool enemy = true) const;
+
+        static bool IsPeriodicDynObjAOEDamage(SpellInfo const* spellInfo);
+        bool IsWithinAoERadius(Position const& pos) const;
+
+        float InitAttackRange(float origRange, bool ranged) const;
+        void CalculateAttackPos(Unit* target, Position &pos, bool& force) const;
+        void GetInPosition(bool force, Unit* newtarget, Position* pos = nullptr);
+        bool AdjustTankingPosition(Unit const* mytarget) const;
+        virtual float GetSpellAttackRange(bool longRange) const { return longRange ? 25.f : 15.f; }
+        virtual void CheckAttackState();
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void OnSpellHitTarget(Unit* /*target*/, SpellInfo const* spell);
+
+        //Searchers
+        WorldObject* GetNearbyRezTarget(float dist = 30) const;
+        Unit* FindImmunityShieldDispelTarget(float dist = 30) const;
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, ObjectGuid caster = ObjectGuid::Empty, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist, uint32 spellId, bool unattacked = true) const;
+        Unit* FindRootTarget(float dist, uint32 spellId) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, uint32 spellId = 0, uint8 minHpPct = 0) const;
+        Unit* FindAOETarget(float dist, WorldObject const* src = nullptr) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = nullptr, float splashdist = 4) const;
+        Unit* FindSplashTarget(float dist, Unit* To, float splashdist, uint8 minTargets) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        Unit* FindDistantTauntTarget(float maxdist = 30, bool ally = false) const;
+        Unit* FindDrainTarget(float maxdist = 30) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, uint8 CCoption, WorldObject const* source = nullptr) const;
+        void GetNearbyTargetsInConeList(std::list<Unit*> &targets, float maxdist = 10) const;
+        void GetNearbyFriendlyTargetsList(std::list<Unit*> &targets, float maxdist = 30) const;
+
+        //Bot specific player-like mods hooks
+        //todo remove &damage ApplyClassDamageMultiplierMelee (uint&, CalcDamageInfo&)
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMeleeSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& /*heal*/, SpellInfo const* /*spellInfo*/, DamageEffectType /*damagetype*/, uint32 /*stack*/) const {}
+        virtual void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const {}
+        virtual void ApplyClassSpellCostMods(SpellInfo const* /*spellInfo*/, int32& /*cost*/) const {}
+        virtual void ApplyClassSpellCastTimeMods(SpellInfo const* /*spellInfo*/, int32& /*casttime*/) const {}
+        virtual void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellCategoryCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& /*cooldown*/) const {}
+        virtual void ApplyClassSpellRadiusMods(SpellInfo const* /*spellInfo*/, float& /*radius*/) const {}
+        virtual void ApplyClassSpellRangeMods(SpellInfo const* /*spellInfo*/, float& /*maxrange*/) const {}
+        virtual void ApplyClassSpellMaxTargetsMods(SpellInfo const* /*spellInfo*/, uint32& /*targets*/) const {}
+        virtual void ApplyClassSpellChanceOfSuccessMods(SpellInfo const* /*spellInfo*/, float& /*chance*/) const {}
+        virtual void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* /*spellInfo*/, uint8 /*effIndex*/, float& /*value*/) const {}
+        virtual void ApplyClassThreatMods(SpellInfo const* /*spellInfo*/, float& /*threat*/) const {}
+        virtual void ApplyClassEffectValueMultiplierMods(SpellInfo const* /*spellInfo*/, SpellEffIndex /*effIndex*/, float& /*multiplier*/) const {}
+
+        virtual void InitPowers() {}
+        virtual void InitSpells() = 0;
+        virtual void ApplyClassPassives() const = 0;
+        virtual void InitHeals() {}
+
+        void Regenerate();
+        void RegenerateEnergy();
+        bool Feasting() const;
+        uint32 GetRation(bool drink) const;
+
+        bool Wait();
+        uint16 Rand() const;
+        void GenerateRand() const;
+
+        static uint32 GetLostHP(Unit const* unit);
+        static uint8 GetHealthPCT(Unit const* u);
+        static uint8 GetManaPCT(Unit const* u);
+
+        virtual MeleeHitOutcome GetNextAttackMeleeOutCome() const;
+
+        //event helpers
+        void BotJumpInPlaceInFrontOf(Position const* pos, float speedXY, float maxHeight);
+
+        void BuildGrouUpdatePacket(WorldPacket* data);
+
+        void BotSay(const std::string &text, Player const* target = nullptr) const;
+        void BotWhisper(const std::string &text, Player const* target = nullptr) const;
+        void BotYell(const std::string &text, Player const* target = nullptr) const;
+        void BotSay(std::string&& text, Player const* target = nullptr) const;
+        void BotWhisper(std::string&& text, Player const* target = nullptr) const;
+        void BotYell(std::string&& text, Player const* target = nullptr) const;
+
+        void ReportSpellCast(uint32 spellId, const std::string& followedByString, Player const* target) const;
+
+        void ApplyItemBonuses(uint8 slot);
+
+        bool HasAuraTypeWithValueAtLeast(AuraType auratype, int32 minvalue, Unit const* unit = nullptr) const;
+
+        void DoSkytalonVehicleStrats(uint32 diff);
+        void DoRubyDrakeVehicleStrats(uint32 diff);
+        void DoEmeraldDrakeVehicleStrats(uint32 diff);
+        void DoAmberDrakeVehicleStrats(uint32 diff);
+        void DoArgentMountVehicleStrats(uint32 diff);
+        void DoDemolisherVehicleStrats(uint32 diff);
+        void DoSiegeEngineVehicleStrats(uint32 diff);
+        void DoChopperVehicleStrats(uint32 diff);
+        void DoGenericVehicleStrats(uint32 diff);
+        void DoVehicleStrats(BotVehicleStrats strat, uint32 diff);
+        void DoVehicleActions(uint32 diff);
+        bool CheckVehicleAttackTarget(BotVehicleStrats /*strat*/);
+        bool HasVehicleRoleOverride(uint32 role) const;
+        float GetVehicleAttackDistanceOverride() const;
+        uint8 LivingVehiclesCount(uint32 entry = 0) const;
+
+        bool ProcessImmediateNonAttackTarget();
+
+        Player* master;
+        Player* _prevRRobin;
+        Unit* opponent;
+        Unit* disttarget;
+        Creature* botPet;
+        EventProcessor Events;
+        ObjectGuid aftercastTargetGuid;
+        uint32 GC_Timer;
+
+        uint8 _botclass;
+        uint8 _spec, _newspec;
+
+        BotVehicleStrats curVehStrat;
+        uint8 vehcomboPoints;
+        bool shouldEnterVehicle;
+
+    private:
+        void FindMaster();
+
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate() const;
+        void _OnManaRegenUpdate() const;
+
+        void _UpdateWMOArea();
+        void _OnZoneUpdate(uint32 zoneId, uint32 areaId);
+        void _OnAreaUpdate(uint32 areaId);
+
+        void RemoveItemBonuses(uint8 slot);
+        void RemoveItemEnchantments(Item const* item);
+        void RemoveItemEnchantment(Item const* item, EnchantmentSlot eslot);
+        void RemoveItemClassEnchants();
+        void ApplyItemEnchantments(Item* item, uint8 slot);
+        void ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEquipSpells(Item* item, bool apply);
+        void ApplyItemEquipEnchantmentSpells(Item* item);
+        void ApplyItemSetBonuses(Item* item, bool apply);
+        void ApplyItemsSpells();
+
+        bool IsPotionSpell(uint32 spellId) const;
+        void StartPotionTimer();
+
+        void BotJump(Position const* pos);
+        bool UpdateImpossibleChase(Unit const* target);
+        void ResetChaseTimer(Position const* pos);
+        void ResetChase(Position const* pos);
+
+        void ApplyRacials();
+        void InitRoles();
+        void InitSpec();
+        void InitEquips();
+        void InitOwner();
+        void InitFaction();
+        void InitRace();
+
+        bool _canCureTarget(Unit const* target, uint32 cureSpell) const;
+        void _getBotDispellableAuraList(Unit const* target, uint32 dispelMask, std::list<Aura const*> &dispelList) const;
+        void _calculatePos(Position& pos) const;
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        void _updateEquips(uint8 slot, Item* item);
+
+        uint32 _getLootQualityMask() const;
+        uint32 _getLootQualityThreshold() const;
+        bool _canLootItemForPlayer(Player* player, Creature* creature, uint8 slot) const;
+        bool _canLootCreatureForPlayer(Player* player, Creature* creature, uint32 lootQualityMask, uint32 lootThreshold) const;
+        bool _canLootCreature(Creature* creature) const;
+        void _autoLootCreatureGold(Creature* creature) const;
+        void _autoLootCreatureItems(Player* receiver, Creature* creature, uint32 lootQualityMask, uint32 lootThreshold) const;
+        void _autoLootCreature(Creature* creature);
+
+        bool _canUseOffHand() const;
+        bool _canUseRanged() const;
+        bool _canUseRelic() const;
+        bool _canEquip(Item const* newItem, uint8 slot, bool ignoreItemLevel = false) const;
+        bool _unequip(uint8 slot, ObjectGuid receiver);
+        bool _equip(uint8 slot, Item* newItem, ObjectGuid receiver);
+        bool _resetEquipment(uint8 slot, ObjectGuid receiver);
+
+        void _castBotItemUseSpell(Item const* item, SpellCastTargets const& targets/*, uint8 cast_count = 0, uint32 glyphIndex = 0*/);
+
+        std::tuple<Unit*, Unit*> _getTargets(bool byspell, bool ranged, bool &reset) const;
+        Unit* _getVehicleTarget(BotVehicleStrats strat) const;
+        void _listAuras(Player const* player, Unit const* unit) const;
+        bool _checkImmunities(Unit const* target, SpellInfo const* spellInfo) const;
+        static float _getAttackDistance(float distance) { return distance*0.72f; }
+        void _extendAttackRange(float& dist) const;
+
+        //for moved
+        void GetHomePosition(uint16& mapid, Position* pos) const;
+
+        //utilities
+        void _AddItemTemplateLink(Player const* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player const* forPlayer, Item const* item, std::ostringstream &str, bool addIcon = true) const;
+        void _AddQuestLink(Player const* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color = true) const;
+        void _AddProfessionLink(Player const* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player const* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeItem(Player const* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const;
+        void _LocalizeQuest(Player const* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player const* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player const* forPlayer, std::string &gameobjectName, uint32 entry) const;
+        void _LocalizeSpell(Player const* forPlayer, std::string &spellName, uint32 entry) const;
+
+        float _getBotStat(uint8 slot, BotStatMods stat) const;
+        float _getTotalBotStat(BotStatMods stat) const;
+        float _getRatingMultiplier(CombatRating cr) const;
+
+        float _getStatScore(uint8 stat) const;
+        float _getItemGearScore(Item const* item, uint8 forslot) const;
+
+        void _saveStats();
+
+        PlayerClassLevelInfo* _classinfo;
+        SpellInfo const* m_botSpellInfo;
+        Position movepos, attackpos;
+
+        uint8 m_botCommandState;
+        uint8 _botAwaitState;
+
+        //stats
+        float hit, parry, dodge, block, crit, dmg_taken_phy, dmg_taken_mag, armor_pen;
+        uint32 expertise, spellpower, spellpen, defense, blockvalue;
+        int32 haste, resistbonus[6];
+
+        //timers
+        uint32 _reviveTimer, _powersTimer, _chaseTimer, _engageTimer, _potionTimer;
+        uint32 lastdiff, checkAurasTimer, checkMasterTimer, roleTimer, ordersTimer, regenTimer, _updateTimerMedium, _updateTimerEx1;
+        uint32 _wmoAreaUpdateTimer;
+        uint32 waitTimer;
+        //save timers
+        uint32 _saveDisabledSpellsTimer;
+
+        uint32 _lastZoneId, _lastAreaId, _lastWMOAreaId;
+
+        uint8 _jumpCount, _evadeCount;
+        uint32 _roleMask;
+        ObjectGuid::LowType _ownerGuid;
+        ObjectGuid _lastTargetGuid;
+        bool doHealth, doMana, shouldUpdateStats;
+        bool feast_health, feast_mana;
+        bool spawned;
+        bool firstspawn;
+        bool _evadeMode;
+        bool _atHome;
+
+        float _energyFraction;
+
+        //counters (this session)
+        uint16 _deathsCount;
+        uint16 _killsCount;
+        uint16 _pvpKillsCount;
+        uint16 _playerKillsCount;
+
+        //save flags
+        bool _saveDisabledSpells;
+
+        TeleportHomeEvent* teleHomeEvent;
+        TeleportFinishEvent* teleFinishEvent;
+        AwaitStateRemovalEvent* awaitStateRemEvent;
+
+        struct BotSpell
+        {
+            BotSpell() : spellId(0), cooldown(0), enabled(true) {}
+            BotSpell(BotSpell const&) = delete;
+            BotSpell(BotSpell&&) = delete;
+            BotSpell& operator=(BotSpell const&) = delete;
+            BotSpell& operator=(BotSpell&&) = delete;
+            uint32 spellId;
+            uint32 cooldown;
+            bool enabled;
+        };
+
+        typedef int32 ItemStatBonus[MAX_BOT_ITEM_MOD];
+        ItemStatBonus _stats[BOT_INVENTORY_SIZE];
+        Item* _equips[BOT_INVENTORY_SIZE];
+
+    public:
+        typedef std::unordered_map<uint32 /*firstrankspellid*/, BotSpell* /*spell*/> BotSpellMap;
+        BotSpellMap const& GetSpellMap() const { return _spells; }
+
+    private:
+        BotSpellMap _spells;
+
+    public:
+        //much simplier than SmartAI I guess...
+        struct BotOrder
+        {
+            friend class bot_ai;
+
+            enum { ORDERS_PARAMS_MAX_SIZE = sizeof(uint64) + sizeof(uint32) };
+            union
+            {
+                char whole[ORDERS_PARAMS_MAX_SIZE];
+                struct
+                {
+                    uint64 targetGuid;
+                    uint32 baseSpell;
+                } spellCastParams;
+            } params;
+
+            explicit BotOrder(BotOrderTypes order_type) : _type(order_type)
+            {
+                memset(params.whole, 0, ORDERS_PARAMS_MAX_SIZE);
+            }
+            BotOrder(BotOrder&&) noexcept = default;
+
+            BotOrder(BotOrder const&) = delete;
+            BotOrder& operator=(BotOrder const&) = delete;
+            BotOrder& operator=(BotOrder&&) = delete;
+
+        private:
+            BotOrderTypes _type;
+        };
+
+        bool HasOrders() const { return !_orders.empty(); }
+        bool IsLastOrder(BotOrderTypes order_type, uint32 param1) const;
+        std::size_t GetOrdersCount() const { return _orders.size(); }
+        bool AddOrder(BotOrder&& order);
+        void CancelOrder(BotOrder const& order);
+        void CompleteOrder(BotOrder const& order);
+        void CancelAllOrders();
+
+    private:
+        void _ProcessOrders();
+
+        typedef std::queue<BotOrder> OrdersQueue;
+        OrdersQueue _orders;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_archmage_ai.cpp b/src/server/game/AI/NpcBots/bot_archmage_ai.cpp
new file mode 100644
index 000000000..962808e2a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_archmage_ai.cpp
@@ -0,0 +1,393 @@
+#include "bot_ai.h"
+#include "botspell.h"
+#include "bottraits.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "TemporarySummon.h"
+#include "World.h"
+/*
+Archmage NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Archmage (Warcraft III tribute)
+Abilities:
+1) Fireball: main attack, single target, no mana cost
+2) Blizzard: typical blizzard
+3) Summon Water Elemental: summons a water elemental to attack archmage's enemies
+Complete - 75%
+TODO: mass tele
+*/
+
+enum ArchmageBaseSpells
+{
+    MAIN_ATTACK_1           = SPELL_FIREBALL,
+    BLIZZARD_1              = SPELL_BLIZZARD,
+    SUMMON_WATER_ELEMENTAL_1= SPELL_SUMMON_WATER_ELEMENTAL
+};
+enum ArchmagePassives
+{
+    BRILLIANCE_AURA         = SPELL_BRILLIANCE_AURA
+};
+enum ArchmageSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+
+    SUMMON_ELEM_COST        = 125 * 5,
+
+    ARCHMAGE_MOUNTID        = 2402
+};
+
+static const uint32 Archmage_spells_damage_arr[] =
+{ MAIN_ATTACK_1, BLIZZARD_1 };
+
+static const uint32 Archmage_spells_support_arr[] =
+{ SUMMON_WATER_ELEMENTAL_1 };
+
+static const std::vector<uint32> Archmage_spells_damage(FROM_ARRAY(Archmage_spells_damage_arr));
+static const std::vector<uint32> Archmage_spells_support(FROM_ARRAY(Archmage_spells_support_arr));
+
+class archmage_bot : public CreatureScript
+{
+public:
+    archmage_bot() : CreatureScript("archmage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new archmage_botAI(creature);
+    }
+
+    struct archmage_botAI : public bot_ai
+    {
+        archmage_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_ARCHMAGE;
+
+            InitUnitFlags();
+
+            //archmage immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_BLOCK_SPELL_FAMILY, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INTERRUPT, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void AttackStart(Unit*) override { }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+
+            checkAuraTimer = 10000;
+
+            if (!me->HasAura(BRILLIANCE_AURA, me->GetGUID()))
+                RefreshAura(BRILLIANCE_AURA);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!me->IsMounted() && !me->GetVehicle())
+                me->Mount(ARCHMAGE_MOUNTID);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            CheckAura(diff);
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < SUMMON_ELEM_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            //pet is killed or unreachable
+            if (IsSpellReady(SUMMON_WATER_ELEMENTAL_1, diff, false) && me->GetPower(POWER_MANA) >= SUMMON_ELEM_COST && !IsCasting() &&
+                (IAmFree() || master->IsInCombat()/* || !master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING)*/) &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+            {
+                me->CastSpell(me, GetSpell(SUMMON_WATER_ELEMENTAL_1), false);
+                return;
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (GC_Timer > diff)
+                return;
+
+            //Blizzard
+            if (IsSpellReady(BLIZZARD_1, diff) && !JumpingOrFalling() && Rand() < 50)
+            {
+                if (Unit* blizztarget = FindAOETarget(CalcSpellMaxRange(BLIZZARD_1)))
+                {
+                    if (doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                        return;
+                }
+
+                SetSpellCooldown(BLIZZARD_1, 1000); //fail
+            }
+
+            if (IsSpellReady(MAIN_ATTACK_1, diff) && CanAffectVictimAny(mytar, SPELL_SCHOOL_FIRE, SPELL_SCHOOL_ARCANE))
+            {
+                if (doCast(mytar, GetSpell(MAIN_ATTACK_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (iscrit)
+                pctbonus *= 1.333f;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == BLIZZARD_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->_effects[0].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == BLIZZARD_1)
+                GC_Timer = uint32(me->GetAttackTime(BASE_ATTACK) * me->m_modAttackSpeedPct[BASE_ATTACK]);
+
+            if (baseId == MAIN_ATTACK_1)
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+
+            if (baseId == SUMMON_WATER_ELEMENTAL_1)
+                SummonBotPet();
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_AWATER_ELEMENTAL;
+
+            Position pos;
+
+            //water elemetal 1 minute duration
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN, std::chrono::minutes(IAmFree() ? 60 : 1));
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 2, me->GetOrientation());
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, SUMMON_WATER_ELEMENTAL_1);
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_AWATER_ELEMENTAL;
+                default:
+                    return 0;
+            }
+        }
+
+        void CheckAttackState() override
+        {
+        }
+
+        void OnBotEnterVehicle(Vehicle const* vehicle) override
+        {
+            me->Dismount();
+            bot_ai::OnBotEnterVehicle(vehicle);
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            checkAuraTimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(MAIN_ATTACK_1, true, false);
+            InitSpellMap(BLIZZARD_1, true, false);
+            InitSpellMap(SUMMON_WATER_ELEMENTAL_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case BLIZZARD_1:
+                case SUMMON_WATER_ELEMENTAL_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Archmage_spells_damage;
+        }
+        //std::vector<uint32> const* GetCCSpellsList() const override
+        //{
+        //    return &Archmage_spells_cc;
+        //}
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Archmage_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Archmage_spells_support;
+        }
+
+    private:
+
+        uint32 checkAuraTimer;
+    };
+};
+
+void AddSC_archmage_bot()
+{
+    new archmage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_bm_ai.cpp b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
new file mode 100644
index 000000000..e96772fe9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
@@ -0,0 +1,934 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "Log.h"
+#include "MotionMaster.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "TemporarySummon.h"
+/*
+Blademaster NpcBot (by Trickerer onlysuffering@gmail.com)
+DISABLED: movement mechanics incompatibility
+Complete - 75%
+TODO: BLADESTORM, Convert illusions to bot_pet_ai
+*/
+
+#define MAX_ILLUSION_POSITIONS 4
+#define MIRROR_IMAGE_DURATION 90000
+
+enum BlademasterBaseSpells
+{
+    WINDWALK_1                              = SPELL_NETHERWALK,
+    MIRROR_IMAGE_1                          = SPELL_MIRROR_IMAGE_BM,
+    CRITICAL_STRIKE_1                       = SPELL_CRITICAL_STRIKE
+};
+enum BlademasterPassives
+{
+//Talents
+//other
+};
+enum BlademasterSpecial
+{
+    NPC_MIRROR_IMAGE_BM                     = 70552,
+    TRANSPARENCY                            = SPELL_TRANSPARENCY_50,
+    BLACK_COLOR                             = SPELL_VERTEX_COLOR_BLACK,
+    STUN_FREEZE                             = SPELL_STUN_FREEZE_ANIM,
+
+    MIRROR_COST                             = 125 * 5
+};
+
+static const uint32 Blademaster_spells_support_arr[] =
+{ MIRROR_IMAGE_1, WINDWALK_1 };
+
+static const std::vector<uint32> Blademaster_spells_support(FROM_ARRAY(Blademaster_spells_support_arr));
+
+class blademaster_bot : public CreatureScript
+{
+public:
+    blademaster_bot() : CreatureScript("blademaster_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new blademaster_botAI(creature);
+    }
+
+    struct blademaster_botAI : public bot_ai
+    {
+    private:
+        //DelayedMeleeDamageEvent - Blademaster
+        //deals critical damage, resets attack timer and sends fake log
+        class DelayedMeleeDamageEvent : public BasicEvent
+        {
+            public:
+                DelayedMeleeDamageEvent(Creature* bot, ObjectGuid targetGuid, bool windwalk) :
+                  _bot(bot), _targetGuid(targetGuid), _windwalk(windwalk), _dinfo(nullptr) { }
+
+                void SetDamageInfo(CalcDamageInfo* dinfo)
+                {
+                    _dinfo = dinfo;
+                }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->CriticalStrikeFinish(_targetGuid, _dinfo, _windwalk);
+
+                    if (_dinfo)
+                        delete _dinfo;
+                    return true;
+                }
+
+            private:
+                Creature* _bot;
+                ObjectGuid _targetGuid;
+                bool _windwalk;
+                CalcDamageInfo* _dinfo;
+                DelayedMeleeDamageEvent(DelayedMeleeDamageEvent const&);
+        };
+
+        class EventTerminateEvent : public BasicEvent
+        {
+            public:
+                EventTerminateEvent(Creature* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->TerminateEvent();
+                    return true;
+                }
+
+            private:
+                Creature* _bot;
+                EventTerminateEvent(EventTerminateEvent const&);
+        };
+
+        class IllusionUnsummonEvent : public BasicEvent
+        {
+            public:
+                IllusionUnsummonEvent(Creature const* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->UnsummonAll();
+
+                    return true;
+                }
+
+            private:
+                Creature const* _bot;
+                IllusionUnsummonEvent(IllusionUnsummonEvent const&);
+        };
+
+        class DelayedIllusionSummonEvent : public BasicEvent
+        {
+            public:
+                DelayedIllusionSummonEvent(Creature const* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->MirrorImageFinish();
+
+                    return true;
+                }
+
+            private:
+                Creature const* _bot;
+                DelayedIllusionSummonEvent(DelayedIllusionSummonEvent const&);
+        };
+
+        class DisappearEvent : public BasicEvent
+        {
+            public:
+                DisappearEvent(Creature* bot) : _bot(bot) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    (dynamic_cast<blademaster_botAI*>(_bot->GetAI()))->MirrorImageMid();
+
+                    return true;
+                }
+
+            private:
+                Creature* _bot;
+                DisappearEvent(DisappearEvent const&);
+        };
+
+        void _calcIllusionPositions()
+        {
+            float x = me->m_positionX;
+            float y = me->m_positionY;
+            float z = me->m_positionZ;
+            float o = me->GetOrientation();
+
+            //X     X
+            //   C
+            //X     X
+            //
+            //C - caster (Blademaster)
+            //X - new positions (1-3 illusions + blademaster)
+
+            float dist = 3.f; //not too far - 3 for x and y seems to be way to go
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                _illusPos[i].m_positionX = x + ((i <= 1) ? +dist : -dist); // +2+2-2-2
+                _illusPos[i].m_positionY = y + (!(i & 1) ? +dist : -dist); // +2-2+2-2
+                _illusPos[i].m_positionZ = z;
+                me->UpdateAllowedPositionZ(_illusPos[i].m_positionX, _illusPos[i].m_positionY, _illusPos[i].m_positionZ);
+                _illusPos[i].SetOrientation(o);
+            }
+        }
+
+    public:
+        blademaster_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_BM;
+
+            InitUnitFlags();
+
+            //Blademaster cannot be disarmed
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+        }
+
+        void IllusionsCheck(uint32 diff)
+        {
+            if (!me->IsAlive())
+                return;
+            if (Illusions_Check_Timer > diff)
+                return;
+
+            Illusions_Check_Timer = 250;
+
+            if (_illusionGuids.empty())
+                return;
+
+            for (std::list<ObjectGuid>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                Creature* ill = ObjectAccessor::GetCreature(*me, *itr);
+                if (!ill)
+                {
+                    TC_LOG_ERROR("entities.player", "bm_bot::IllusionsCheck(): unit %s is not found in world!", (*itr).ToString().c_str());
+                    continue;
+                }
+
+                ill->SetCanModifyStats(false);
+                float hpct = ill->GetHealthPct();
+                float mpct = (float(ill->GetPower(POWER_MANA)) * 100.f) / float(ill->GetMaxPower(POWER_MANA));
+
+                ill->SetMaxHealth(me->GetMaxHealth());
+                ill->SetHealth(uint32(0.5f + float(ill->GetMaxHealth()) * hpct / 100.f));
+                ill->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                ill->SetPower(POWER_MANA, uint32(0.5f + float(ill->GetMaxPower(POWER_MANA)) * mpct / 100.f));
+                ill->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                ill->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+                ill->m_modAttackSpeedPct[BASE_ATTACK] = me->m_modAttackSpeedPct[BASE_ATTACK];
+            }
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            //custom
+            if (_dmdevent)
+                return false;
+            if (IsTempBot()) //Illusion etc.
+                return false;
+
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            IllusionsCheck(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady() && !IsTempBot())
+            {
+                if (me->GetPower(POWER_MANA) < MIRROR_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            //CheckRacials(diff);
+
+            CheckWindWalk(diff);
+            CheckMirrorImage(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void AttackStart(Unit*) override { }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        bool CanEat() const override { return Windwalk_Timer <= GetLastDiff() && !illusion_Fade; }
+        bool CanSeeEveryone() const override { return Windwalk_Timer > GetLastDiff(); }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (IsSpellReady(WINDWALK_1, diff) && !IsTank(me) && Rand() < 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+        }
+
+        void DoBMMeleeAttackIfReady()
+        {
+            //Copied from UnitAI::DoMeleeAttackIfReady() with modifications
+            //cannot attack while casting or jumping
+            if (me->HasUnitState(UNIT_STATE_CASTING) || _dmdevent)
+                return;
+
+            Unit* victim = me->GetVictim();
+            //Make sure our attack is ready and we aren't currently casting before checking distance
+            if (me->isAttackReady() && me->IsWithinMeleeRange(victim))
+            {
+                if (!CCed(me, true) && !JumpingFlyingOrFalling())
+                {
+                    //Windwalk strike
+                    if (Windwalk_Timer > GetLastDiff())
+                    {
+                        CriticalStrike(victim, true);
+                        return;
+                    }
+                    //Critical Strike: 15% to deal x2,x3, etc... damage
+                    else if (criticalStikeMult >= 2 && !CCed(me, true) && roll_chance_f(15.f))
+                    {
+                        CriticalStrike(victim);
+                        return;
+                    }
+                }
+
+                DoMeleeAttackIfReady();
+                return;
+            }
+        }
+
+        void CheckAttackState() override
+        {
+            if (me->GetVictim())
+            {
+                if (HasRole(BOT_ROLE_DPS))
+                    DoBMMeleeAttackIfReady();
+            }
+        }
+
+        void CheckWindWalk(uint32 diff)
+        {
+            if (!IsSpellReady(WINDWALK_1, diff) || Windwalk_Timer > GetLastDiff() || illusion_Fade || IsCasting() ||
+                Rand() > (10 + 20 * (me->IsInCombat() || master->IsInCombat())))
+                return;
+
+            if (!IAmFree() && master->isMoving())
+            {
+                if (me->GetDistance(master) > 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+
+                return;
+            }
+
+            if (!IsTank(me))
+            {
+                //unit to strike
+                Unit* u = IsMelee() ? me->GetVictim() : nullptr;
+
+                if ((u && u->isMoving() && me->GetDistance(u) > 18 &&
+                    (u->GetVictim() != me || u->getAttackers().size() > uint8(u->IsControlledByPlayer() ? 0 : 1))) ||
+                    me->getAttackers().size() > 2)
+                {
+                    if (doCast(me, GetSpell(WINDWALK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckMirrorImage(uint32 diff)
+        {
+            //only for controlled bot
+            //if (IAmFree())
+            //    return;
+            if (!IsSpellReady(MIRROR_IMAGE_1, diff) || !me->IsInCombat() || !illusionsCount || illusion_Fade ||
+                !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 20)
+                return;
+
+            uint8 pct = GetHealthPCT(me);
+            uint8 size = uint8(me->getAttackers().size());
+            if (!size)
+                return;
+
+            if (pct > 25 && (size > 3 || pct < (80 + size * 5)))
+                if (doCast(me, GetSpell(MIRROR_IMAGE_1)))
+                    return;
+        }
+
+        void MirrorImageStart()
+        {
+            if (!illusionsCount)
+                return;
+
+            ASSERT(!illusion_Fade);
+            illusion_Fade = true;
+
+            //OKAY
+
+            //destroy existing illusions if any
+            UnsummonAll();
+            //mirror image renders BM invulnerable for a short period of time,
+            //removing all but passive auras
+            Unit::AuraMap const auras = me->GetOwnedAuras(); //copy
+            for (Unit::AuraMap::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            {
+                Aura* aura = iter->second;
+                if (aura->GetSpellInfo()->Attributes & SPELL_ATTR0_PASSIVE)
+                    continue;
+                if (aura->GetId() == SPELL_BURNING_BLADE_BLADEMASTER)
+                    continue;
+                AuraApplication* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+                if (!aurApp)
+                    continue;
+                me->RemoveAura(aurApp, AURA_REMOVE_BY_DEFAULT);
+            }
+
+            me->BotStopMovement();
+            me->AttackStop();
+            me->HandleEmoteCommand(EMOTE_ONESHOT_NONE);
+            me->AddAura(BLACK_COLOR, me);//color
+            me->AddAura(STUN_FREEZE, me);//stop/immunity
+
+            //prepare to disappear
+            DisappearEvent* devent = new DisappearEvent(me);
+            Events.AddEvent(devent, Events.CalculateTime(std::chrono::milliseconds(300))); //immediatelly (almost)
+        }
+
+        void MirrorImageMid()
+        {
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+            {
+                me->RemoveAura(BLACK_COLOR);
+                me->RemoveAura(STUN_FREEZE);
+                illusion_Fade = false;
+                return;
+            }
+            //disappear
+            me->SetPhaseMask(0, true);
+
+            //INVISIBLE!
+            //EVENT
+            DelayedIllusionSummonEvent* disevent = new DelayedIllusionSummonEvent(me);
+            Events.AddEvent(disevent, Events.CalculateTime(std::chrono::milliseconds(1250))); //1000 ms disappear time + 250 ms buffer
+        }
+
+        void MirrorImageFinish()
+        {
+            illusion_Fade = false;
+            me->RemoveAura(BLACK_COLOR);
+            me->RemoveAura(STUN_FREEZE);
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+                return;
+
+            _calcIllusionPositions();
+
+            std::set<uint8> usedposs;
+
+            for (uint8 i = 0; i != illusionsCount; ++i)
+            {
+                Creature* illusion = me->SummonCreature(NPC_MIRROR_IMAGE_BM, *me, TEMPSUMMON_MANUAL_DESPAWN);
+                if (!illusion)
+                    continue;
+
+                if (!IAmFree())
+                    master->GetBotMgr()->AddBot(illusion, false);
+
+                illusion->SetCreator(master); //TempSummon* Map::SummonCreature()
+                illusion->SetOwnerGUID(me->GetGUID());
+
+                //copy visuals
+                //illusion->SetEntry(me->GetEntry());
+                illusion->UpdateEntry(me->GetEntry());
+                illusion->SetFaction(me->GetFaction());
+                illusion->SetLevel(me->GetLevel());
+                illusion->SetDisplayId(me->GetDisplayId());
+                illusion->SetNativeDisplayId(me->GetDisplayId());
+                illusion->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0));
+
+                //copy stats
+                illusion->SetCanModifyStats(false);
+                illusion->SetMaxHealth(me->GetMaxHealth());
+                illusion->SetHealth(me->GetHealth());
+                illusion->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                illusion->SetPower(POWER_MANA, me->GetPower(POWER_MANA));
+                illusion->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                illusion->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+                illusion->m_modAttackSpeedPct[BASE_ATTACK] = me->m_modAttackSpeedPct[BASE_ATTACK];
+
+                illusion->BotStopMovement();
+                while (true)
+                {
+                    //move illusion to a random corner
+                    uint8 j = urand(0, MAX_ILLUSION_POSITIONS - 1);
+                    if (usedposs.find(j) == usedposs.end())
+                    {
+                        illusion->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[j]);
+                        //illusion->Relocate(_illusPos[j]);
+                        usedposs.insert(j);
+                        break;
+                    }
+                }
+
+                illusion->GetBotAI()->SetBotCommandState(BOT_COMMAND_COMBATRESET);
+
+                _illusionGuids.push_back(illusion->GetGUID());
+            }
+
+            SetBotCommandState(BOT_COMMAND_COMBATRESET);
+
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                if (usedposs.find(i) == usedposs.end())
+                {
+                    //me->BotStopMovement();
+                    me->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[i]);
+                    //me->Relocate(_illusPos[i]);
+                    //usedposs.insert(i);
+                    break;
+                }
+            }
+
+            uint8 counter = 0;
+            uint8 r = urand(0, uint8(_illusionGuids.size() - 1));
+            uint32 phaseMask = IAmFree() ? PHASEMASK_NORMAL : master->GetPhaseMask();
+
+            for (std::list<ObjectGuid>::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (Creature* illusion = ObjectAccessor::GetCreature(*me, *itr))
+                    illusion->SetPhaseMask(phaseMask, true);
+
+                if (counter == r)
+                    me->SetPhaseMask(phaseMask, true);
+                else
+                    ++counter;
+            }
+
+            me->GetCombatManager().EndAllPvECombat();
+
+            if (me->GetPhaseMask() != phaseMask)
+                me->SetPhaseMask(phaseMask, true);
+
+            //me->setAttackTimer(BASE_ATTACK, 3000);
+            //waitTimer += 800;
+            SetSpellCooldown(MIRROR_IMAGE_1, 8000);
+
+            //EVENT
+            IllusionUnsummonEvent* unsevent = new IllusionUnsummonEvent(me);
+            Events.AddEvent(unsevent, Events.CalculateTime(std::chrono::milliseconds(MIRROR_IMAGE_DURATION)));
+        }
+
+        void CriticalStrike(Unit* target, bool windwalk = false)
+        {
+            //Okay critical strike must have jump and strike animation, doing delayed damage
+            _dmdevent = new DelayedMeleeDamageEvent(me, target->GetGUID(), windwalk);
+
+            //hack temp attack damage calc
+            float mindam = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float maxdam = me->GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+
+            if (windwalk)
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * 1.5f);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * 1.5f);
+                me->RemoveAura(GetSpell(WINDWALK_1));
+                me->RemoveAura(TRANSPARENCY);
+            }
+            else
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * criticalStikeMult);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * criticalStikeMult);
+            }
+
+            CalcDamageInfo* dinfo = new CalcDamageInfo();
+            me->CalculateMeleeDamage(target, dinfo, BASE_ATTACK);
+
+            me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam);
+            me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam);
+
+            _dmdevent->SetDamageInfo(dinfo);
+            Events.AddEvent(_dmdevent, Events.CalculateTime(std::chrono::milliseconds(250)));
+
+            BotJumpInPlaceInFrontOf(target, 0.25f, 4.1f); //jump - DO NOT CHANGE
+            me->CastSpell(target, SPELL_COMBAT_SPECIAL_2H_ATTACK, true); //strike anim
+            me->resetAttackTimer(BASE_ATTACK);
+        }
+
+        void CriticalStrikeFinish(ObjectGuid targetGuid, CalcDamageInfo* calcdinfo, bool /*windwalk*/)
+        {
+            EventTerminateEvent* etevent = new EventTerminateEvent(me);
+            Events.AddEvent(etevent, Events.CalculateTime(std::chrono::milliseconds(750)));
+
+            if (!me->IsInWorld() || !me->IsAlive() || CCed(me))
+            {
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            Unit* target = ObjectAccessor::GetUnit(*me, targetGuid);
+            if (!target || !target->IsAlive())
+            {
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            if (target->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //target became immune
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_IMMUNE);
+                target->PlayDistanceSound(SOUND_ABSORB_GET_HIT);
+                Windwalk_Timer = 0;
+                return;
+            }
+            else if (!CanSeeEveryone() && !me->CanSeeOrDetect(target, false, false))
+            {
+                //target disappeared
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_MISS/*SPELL_MISS_EVADE*/);
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            target->PlayDistanceSound(SOUND_AXE_2H_IMPACT_FLESH_CRIT);
+
+            DamageInfo dinfo(*calcdinfo, 0);
+
+            me->SendSpellNonMeleeDamageLog(target, CRITICAL_STRIKE_1,
+                dinfo.GetDamage() + dinfo.GetAbsorb() + dinfo.GetResist() + dinfo.GetBlock(),
+                SPELL_SCHOOL_MASK_NORMAL, dinfo.GetAbsorb(), dinfo.GetResist(), false, dinfo.GetBlock(), true, false);
+            CleanDamage cl(0, 0, BASE_ATTACK, MELEE_HIT_CRIT);
+            Unit::DealDamage(me, target, dinfo.GetDamage(), &cl);
+            Unit::ProcSkillsAndAuras((Unit*)me, calcdinfo->Target, calcdinfo->ProcAttacker, calcdinfo->ProcVictim, 0, 0, calcdinfo->HitInfo, nullptr, &dinfo, nullptr);
+            me->AtTargetAttacked(target, false);
+
+            me->resetAttackTimer(BASE_ATTACK);
+            Windwalk_Timer = 0;
+        }
+
+        void TerminateEvent()
+        { _dmdevent = nullptr; }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const override
+        {
+            return _dmdevent ? MELEE_HIT_NORMAL : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        float GetBotArmorPenetrationCoef() const override
+        {
+            return 80.0f + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(WINDWALK_1))
+            {
+                Windwalk_Timer = 30000; //TODO:
+                me->RemoveMovementImpairingAuras(true);
+                me->PlayDistanceSound(SOUND_FREEZE_IMPACT_WINDWALK, !IAmFree() ? master : nullptr);
+
+                uint32 dur = 30000;
+                if (Aura* aura = me->GetAura(spellId))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+                if (Aura* aura = me->GetAura(TRANSPARENCY))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+
+                if (GetHealthPCT(me) < 25 || !HasRole(BOT_ROLE_DPS))
+                    me->AttackStop();
+
+                //SpellEffectSanctuary
+                me->GetCombatManager().SuppressPvPCombat();
+                Unit::AttackerSet const& attackers = me->getAttackers();
+                for (Unit::AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+                {
+                    if (!(*itr)->CanSeeOrDetect(me))
+                        (*(itr++))->AttackStop();
+                    else
+                        ++itr;
+                }
+
+                me->m_lastSanctuaryTime = getMSTime();
+            }
+
+            if (spellId == GetSpell(MIRROR_IMAGE_1))
+            {
+                MirrorImageStart();
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Illusions deal no damage
+            if (IsTempBot())
+            {
+                //manually add threat as if damage was done
+                if (victim->GetTypeId() == TYPEID_UNIT)
+                    victim->GetThreatManager().AddThreat(me, float(damage + damage));
+
+                damage = 0;
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            //illusions take twice as much damage
+            if (IsTempBot())
+            {
+                damage *= 2;
+                //return;
+            }
+            if (illusion_Fade)
+            {
+                damage = 0;
+                return;
+            }
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void JustDied(Unit* u) override
+        {
+            TerminateEvent();
+
+            if (IsTempBot())
+                if (me->GetCreatorGUID().IsCreature())
+                    if (Unit* bot = ObjectAccessor::GetUnit(*me, me->GetCreatorGUID()))
+                        if (bot->ToCreature()->IsNPCBot())
+                            bot->ToCreature()->OnBotDespawn(me);
+
+            bot_ai::JustDied(u);
+
+            if (!IsTempBot())
+                UnsummonAll();
+        }
+
+        void OnBotDespawn(Creature* summon) override
+        {
+            if (!summon)
+                return;
+
+            for (std::list<ObjectGuid>::iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (*itr == summon->GetGUID())
+                {
+                    _illusionGuids.erase(itr);
+                    return;
+                }
+            }
+        }
+
+        void UnsummonAll() override
+        {
+            while (!_illusionGuids.empty())
+            {
+                std::list<ObjectGuid>::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = ObjectAccessor::GetCreature(*me, *itr))
+                    illusion->AI()->JustDied(nullptr);
+                else
+                    _illusionGuids.erase(itr);
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case CRITICAL_STRIKE_1:
+                    return criticalStikeMult;
+                case MIRROR_IMAGE_1:
+                    return illusionsCount;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            _dmdevent = nullptr;
+            Windwalk_Timer = 0;
+            criticalStikeMult = 1;
+            illusionsCount = 0;
+            illusion_Fade = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (Windwalk_Timer > diff)          Windwalk_Timer -= diff;
+            if (Illusions_Check_Timer > diff)   Illusions_Check_Timer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+            me->SetMaxPower(POWER_MANA, 75);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+
+ /*Special*/lvl >= 10 ? InitSpellMap(WINDWALK_1) : RemoveSpell(WINDWALK_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(MIRROR_IMAGE_1) : RemoveSpell(MIRROR_IMAGE_1);
+
+            criticalStikeMult =
+                lvl < 10 ? 1 :
+                lvl < 30 ? 2 :
+                lvl < 50 ? 3 :
+                lvl < 82 ? 4 : 5;
+
+            illusionsCount =
+                lvl < 20 ? 0 :
+                lvl < 40 ? 1 :
+                lvl < 70 ? 2 : 3;
+        }
+
+        void ApplyClassPassives() const override
+        {
+            RefreshAura(SPELL_BURNING_BLADE_BLADEMASTER);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case WINDWALK_1:
+                case MIRROR_IMAGE_1:
+                    return true;
+                default:
+                    break;
+            }
+
+            return false;
+        }
+
+        //std::vector<uint32> const* GetDamagingSpellsList() const override
+        //{
+        //    return &Blademaster_spells_damage;
+        //}
+        //std::vector<uint32> const* GetCCSpellsList() const override
+        //{
+        //    return &Blademaster_spells_cc;
+        //}
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Blademaster_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Blademaster_spells_support;
+        }
+
+    private:
+        DelayedMeleeDamageEvent* _dmdevent;
+        std::list<ObjectGuid> _illusionGuids;
+        Position _illusPos[MAX_ILLUSION_POSITIONS];
+
+        uint32 Windwalk_Timer;
+        uint32 Illusions_Check_Timer;
+        uint8 criticalStikeMult;
+        uint8 illusionsCount;
+        bool illusion_Fade;
+    };
+};
+
+void AddSC_blademaster_bot()
+{
+    new blademaster_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp b/src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp
new file mode 100644
index 000000000..1ae489247
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_dark_ranger_ai.cpp
@@ -0,0 +1,608 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botspell.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "TemporarySummon.h"
+/*
+Dark Ranger NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+A former ranger of Quel'thalas forcibly raised from the dead (Warcraft III tribute)
+Specifics:
+Spell damage taken reduced by 35%, partially immune to control effects, leather/cloth armor,
+deals physical/spellshadow damage, spell power bonus: 50% intellect. Main attribute: Agility
+Abilities:
+1) Silence. Silences an enemy and up to 4 nearby targets for 8 seconds, 15 seconds cooldown
+2) Black Arrow. Fires a cursed arrow dealing 150% weapon damage and additional spellshadow damage over time.
+If affected target dies from Dark Ranger\'s damage, a Dark Minion will spawn from the corpse
+(maximum 5 Minions, 80 seconds duration, only works on humanoids, beasts and dragonkin),
+skeleton level depends on level of the killed unit
+Deals five times more damage if target is under 20% health
+3) Drain Life. Drains health from an enemy every second for 5 seconds (6 ticks),
+healing Dark Ranger for 200% of the drained amount
+4) Charm NIY
+5ex) Auto Shot. A hunter auto shot ability since dark ranger is purely ranged and only uses bows.
+Complete - 75%
+TODO: Charm
+*/
+
+enum DarkRangerBaseSpells
+{
+    AUTO_SHOT_1                         = 75,
+    BLACK_ARROW_1                       = SPELL_BLACK_ARROW,
+    DRAIN_LIFE_1                        = SPELL_DRAIN_LIFE,
+    SILENCE_1                           = SPELL_SILENCE
+};
+enum DarkRangerPassives
+{
+};
+enum DarkRangerSpecial
+{
+    DRAINLIFE_COST                      = 75 * 5,
+    MAX_MINIONS                         = 5,
+
+    SPELL_SPAWN_ANIM                    = 25035,
+    SPELL_BLOODY_EXPLOSION              = 36599,
+    SPELL_THREAT_MOD                    = 31745, //Salvation
+
+    MODEL_BLOODY_BONES                  = 25538
+};
+
+static const uint32 Darkranger_spells_damage_arr[] =
+{ BLACK_ARROW_1, DRAIN_LIFE_1 };
+
+static const uint32 Darkranger_spells_cc_arr[] =
+{ SILENCE_1 };
+
+static const std::vector<uint32> Darkranger_spells_damage(FROM_ARRAY(Darkranger_spells_damage_arr));
+static const std::vector<uint32> Darkranger_spells_cc(FROM_ARRAY(Darkranger_spells_cc_arr));
+
+class dark_ranger_bot : public CreatureScript
+{
+public:
+    dark_ranger_bot() : CreatureScript("dark_ranger_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new dark_ranger_botAI(creature);
+    }
+
+    struct dark_ranger_botAI : public bot_ai
+    {
+        dark_ranger_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DARK_RANGER;
+
+            InitUnitFlags();
+
+            //dark ranger immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_RANGED, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void KilledUnit(Unit* u) override
+        {
+            bot_ai::KilledUnit(u);
+
+            if (u->GetGUID() == _blackArrowKillGUID)
+            {
+                //black arrow affection -> spawn skeleton (launch)
+                SummonBotPet(u);
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (Rand() > 55)
+                return;
+
+            if (IsSpellReady(SILENCE_1, diff))
+            {
+                Unit* target = FindCastingTarget(CalcSpellMaxRange(SILENCE_1), 0, SILENCE_1);
+                if (target && doCast(target, GetSpell(SILENCE_1)))
+                    return;
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            CheckDrainLife(diff);
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < DRAINLIFE_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 30)
+                    DrinkPotion(false);
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+
+                if (!IAmFree() && me->IsStandState() && !me->isMoving() && !master->isMoving() && !me->IsMounted() &&
+                    !me->IsInCombat() && !master->IsInCombat() && Rand() < 10 && me->GetDistance(master) < 15 &&
+                    !me->HasStealthAura() && !me->HasInvisibilityAura() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                    _minions.empty())
+                {
+                    me->CastSpell(me, RACIAL_SHADOWMELD, true);
+                }
+
+                return;
+            }
+
+            if (IsCasting())
+                return;
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            Counter(diff);
+
+            CheckBlackArrow(diff);
+
+            MoveBehind(mytar);
+
+            float dist = me->GetDistance(mytar);
+            float maxRangeLong = 30.f;
+
+            bool inpostion = !mytar->HasAuraType(SPELL_AURA_MOD_CONFUSE) || dist > maxRangeLong - 15.f;
+
+            //Auto Shot
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == AUTO_SHOT_1 && (shot->m_targets.GetUnitTarget() != mytar || !inpostion))
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (HasRole(BOT_ROLE_DPS)/* && dist > 5*/ && dist < maxRangeLong)
+            {
+                if (doCast(mytar, AUTO_SHOT_1))
+                {}
+            }
+
+            //RANGED SECTION
+            if (dist > maxRangeLong)
+                return;
+
+            //Black Arrow
+            if (IsSpellReady(BLACK_ARROW_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                (Rand() < 20 || !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x4, 0x0, me->GetGUID())))
+            {
+                if (doCast(mytar, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+        }
+
+        void CheckDrainLife(uint32 diff)
+        {
+            if (!IsSpellReady(DRAIN_LIFE_1, diff) || !HasRole(BOT_ROLE_DPS) || GetHealthPCT(me) > 70 || Rand() > 80 ||
+                IsCasting())
+                return;
+
+            Unit* target = me->GetVictim();
+            if (!target)
+                target = FindAffectedTarget(GetSpell(BLACK_ARROW_1), me->GetGUID(), 30);
+
+            if (target && doCast(target, GetSpell(DRAIN_LIFE_1)))
+                return;
+        }
+
+        void CheckBlackArrow(uint32 diff)
+        {
+            if (!IsSpellReady(BLACK_ARROW_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 30)
+                return;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsList(targets, 50, 0);
+            targets.remove_if(BOTAI_PRED::AuraedTargetExcludeByCaster(BLACK_ARROW_1, me->GetGUID()));
+            if (Unit* target = !targets.empty() ? Trinity::Containers::SelectRandomContainerElement(targets) : nullptr)
+            {
+                if (doCast(target, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*iscrit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f;
+            //Black Arrow on targets < 20% hp (only direct damage)
+            if (baseId == BLACK_ARROW_1 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+                pctbonus *= 5.f;
+
+            damage = int32(damage * pctbonus + flat_mod);
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*iscrit*/) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f;
+            //if (iscrit)
+            //{
+            //    //!!!spell damage is not yet critical and will be multiplied by 1.5
+            //    //so we should put here bonus damage mult /1.5
+            //    //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+            //    if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+            //        pctbonus *= 1.16f;
+            //}
+            ////Trap Mastery part 2: 30% bonus damage for Immolation Trap, Explosive Trap and Black Arrow
+            //if (lvl >= 15 && (baseId == IMMOLATION_TRAP_AURA_1 || baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+            //    pctbonus *= 1.3f;
+            //Black Arrow on targets < 20% hp (only direct damage)
+            //if (baseId == BLACK_ARROW_1 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+            //    pctbonus *= 5.f;
+
+            damage = int32(fdamage * pctbonus + flat_mod);
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Drain Life scaling from health pool: 2%
+            if (baseId == DRAIN_LIFE_1 && effIndex == EFFECT_0)
+                value += float(me->GetMaxHealth()) * 0.02f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Rapid Killing: use up buff manually
+            //if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            //{
+            //    if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+            //        if (rapi->IsAffectedOnSpell(spellInfo))
+            //            me->RemoveAura(RAPID_KILLING_BUFF);
+            //}
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (target == me)
+                return;
+
+            //uint32 baseId = spell->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+
+            //if (baseId == HUNTERS_MARK_1)
+            //{
+            //    //DarkRanger's Mark helper
+            //    if (AuraEffect* mark = target->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+            //    {
+            //        //Glyph of DarkRanger's Mark: +20% effect
+            //        //Improved DarkRanger's Mark: +30% effect
+            //        if (lvl >= 15)
+            //            mark->ChangeAmount(mark->GetAmount() + mark->GetAmount() / 2);
+            //        else if (lvl >= 10)
+            //            mark->ChangeAmount(mark->GetAmount() * 13 / 10);
+            //    }
+            //}
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* spellInfo) override
+        {
+            //black arrow affection -> spawn skeleton (mark)
+            if (damage && me->IsAlive() && victim->GetTypeId() == TYPEID_UNIT && damage >= victim->GetHealth() &&
+                (victim->GetCreatureType() == CREATURE_TYPE_BEAST ||
+                victim->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                victim->GetCreatureType() == CREATURE_TYPE_HUMANOID) &&
+                ((spellInfo && spellInfo->GetFirstRankSpell()->Id == BLACK_ARROW_1) ||
+                victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x4, 0x0, me->GetGUID())))
+                _blackArrowKillGUID = victim->GetGUID();
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            uint8 i = 0;
+            for (Summons::const_iterator citr = _minions.begin(); citr != _minions.end(); ++citr)
+            {
+                if ((*citr)->GetGUID() == summon->GetGUID())
+                    return i;
+                ++i;
+            }
+            return 0;
+        }
+
+        void SummonBotPet(Unit* from)
+        {
+            if (_minions.size() >= MAX_MINIONS)
+            {
+                //TC_LOG_ERROR("entities.player", "bot_dranger_ai::SummonBotPet(): max minions");
+                Unit* u = nullptr;
+                //try 1: by minimal level
+                uint8 minlevel = me->GetLevel();
+                for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+                {
+                    if ((*itr)->GetLevel() < minlevel)
+                    {
+                        minlevel = (*itr)->GetLevel();
+                        u = *itr;
+                    }
+                }
+                //try 2: by minimal duration
+                if (!u)
+                {
+                    uint32 minduration = 0;
+                    for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+                    {
+                        if ((*itr)->GetAI()->GetData(BOTPETAI_MISC_DURATION) > minduration)
+                        {
+                            minduration = (*itr)->GetAI()->GetData(BOTPETAI_MISC_DURATION);
+                            u = *itr;
+                        }
+                    }
+                }
+                //if (u)
+                //    TC_LOG_ERROR("entities.player", "bot_dranger_ai::SummonBotPet(): found minion to erase(1)");
+                //try 3: last resort
+                if (!u)
+                    u = *(_minions.begin());
+                //if (u)
+                //    TC_LOG_ERROR("entities.player", "bot_dranger_ai::SummonBotPet(): found minion to erase(2)");
+
+                u->ToTempSummon()->UnSummon();
+            }
+
+            //addition: change unit's modelid
+            if (!from->IsPet() && !from->IsVehicle() &&
+                !from->ToCreature()->isWorldBoss() &&
+                !from->ToCreature()->IsDungeonBoss())
+            {
+                from->CastSpell(from, SPELL_BLOODY_EXPLOSION, true);
+                from->SetDisplayId(MODEL_BLOODY_BONES);
+            }
+
+            uint32 rank = from->ToCreature()->GetCreatureTemplate()->rank;
+            uint32 entry = (rank == CREATURE_ELITE_NORMAL) ? BOT_PET_DARK_MINION : BOT_PET_DARK_MINION_ELITE;
+
+            uint8 maxLevel = std::min<uint8>(from->GetLevel(), me->GetLevel());
+
+            Position pos = from->GetPosition();
+
+            Creature* myPet = me->SummonCreature(entry, pos, TEMPSUMMON_MANUAL_DESPAWN);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, BLACK_ARROW_1);
+
+            //dark minion immunities
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            //heal
+            myPet->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_HEAL, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_HEAL_PCT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_PERIODIC_HEAL, true);
+
+            //myPet->CastSpell(myPet, SPELL_BLOODY_EXPLOSION, true);
+            myPet->CastSpell(myPet, SPELL_SPAWN_ANIM, true);
+            if (Aura* stun = myPet->AddAura(SUMMONING_DISORIENTATION, myPet))
+            {
+                stun->SetDuration(1500);
+                stun->SetMaxDuration(1500);
+            }
+
+            myPet->GetAI()->SetData(BOTPETAI_MISC_MAXLEVEL, maxLevel);
+            _minions.insert(myPet);
+        }
+
+        void UnsummonAll() override
+        {
+            while (!_minions.empty())
+                (*_minions.begin())->ToTempSummon()->UnSummon();
+            //for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+            //    (*itr)->ToTempSummon()->UnSummon();
+
+            //_minions.clear();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all darkranger bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (_minions.find(summon) != _minions.end())
+                _minions.erase(summon);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(BLACK_ARROW_1) - 5.f : 15.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_DARK_MINION;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            //for (uint8 i = 0; i != MAX_SPELL_SCHOOL; ++i)
+            //    me->m_threatModifier[1] = 0.0f;
+
+            _blackArrowKillGUID = ObjectGuid::Empty;
+
+            DefaultInit();
+
+            //threat mod
+            if (Aura* threat = me->AddAura(SPELL_THREAT_MOD, me))
+                threat->GetEffect(0)->ChangeAmount(-100);
+        }
+
+        void ReduceCD(uint32 /*diff*/) override
+        {
+            //if (trapTimer > diff)                   trapTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            //uint8 lvl = me->GetLevel();
+            InitSpellMap(AUTO_SHOT_1);
+            InitSpellMap(BLACK_ARROW_1);
+            InitSpellMap(DRAIN_LIFE_1);
+            InitSpellMap(SILENCE_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Darkranger_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Darkranger_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Darkranger_spells_heal;
+        //}
+        //std::vector<uint32> const* GetSupportSpellsList() const override
+        //{
+        //    return &Darkranger_spells_support;
+        //}
+    private:
+        ObjectGuid _blackArrowKillGUID;
+        typedef std::set<Unit*> Summons;
+        Summons _minions;
+    };
+};
+
+void AddSC_dark_ranger_bot()
+{
+    new dark_ranger_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 000000000..351bf66d6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,2112 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "DBCStores.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Log.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+#include "World.h"
+/*
+Death Knight NpcBot by Trickerer onlysuffering@gmail.com
+Complete - around 85%
+Note: Rune system adapted from TC
+TODO: pet related
+Notes: raise dead / army of the dead not working off the bat, summon garg crash, dancing rune weapon crash, need ai workarounds
+*/
+
+enum DeathKnightBaseSpells
+{
+    BLOOD_STRIKE_1                      = 45902,
+    ICY_TOUCH_1                         = 45477,
+    PLAGUE_STRIKE_1                     = 45462,
+    DEATH_STRIKE_1                      = 49998,
+    OBLITERATE_1                        = 49020,
+    RUNE_STRIKE_1                       = 56815,
+    HEART_STRIKE_1                      = 55050,
+    FROST_STRIKE_1                      = 49143,
+    SCOURGE_STRIKE_1                    = 55090,
+
+    BLOOD_BOIL_1                        = 48721,
+    DEATH_AND_DECAY_1                   = 43265,
+    HOWLING_BLAST_1                     = 49184,
+
+    DEATH_COIL_1                        = 47541,
+    DEATH_GRIP_1                        = 49576,
+    PESTILENCE_1                        = 50842,
+    MIND_FREEZE_1                       = 47528,
+    STRANGULATE_1                       = 47476,
+    CHAINS_OF_ICE_1                     = 45524,
+    ICEBOUND_FORTITUDE_1                = 48792,
+    DARK_COMMAND_1                      = 56222,
+    ANTI_MAGIC_SHELL_1                  = 48707,
+    ARMY_OF_THE_DEAD_1                  = 42650,
+
+    PATH_OF_FROST_1                     = 3714,
+    HORN_OF_WINTER_1                    = 57330,
+    EMPOWER_RUNE_WEAPON_1               = 47568,
+    BLOOD_TAP_1                         = 45529,
+
+    RUNE_TAP_1                          = 48982,
+    LICHBORNE_1                         = 49039,
+    //CE
+    MARK_OF_BLOOD_1                     = 49005,
+    DEATHCHILL_1                        = 49796,
+    HYSTERIA_1                          = 49016,
+    HUNGERING_COLD_1                    = 49203,
+    ANTI_MAGIC_ZONE_1                   = 48707,
+    VAMPIRIC_BLOOD_1                    = 55233,
+    UNBREAKABLE_ARMOR_1                 = 51271,
+    BONE_SHIELD_1                       = 49222,
+
+    BLOOD_PRESENCE_1                    = 48266,
+    FROST_PRESENCE_1                    = 48263,
+    UNHOLY_PRESENCE_1                   = 48265//unused
+};
+enum DeathKnightPassives
+{
+//Talents
+    BUTCHERY                            = 49483,//rank 2
+    TOUGHNESS                           = 49789,//rank 5
+    BLADED_ARMOR                        = 49393,//rank 5
+    SCENT_OF_BLOOD                      = 49509,//rank 3
+    TWO_HANDED_WEAPON_SPECIALIZATION    = 55108,//rank 2
+    ICY_TALONS                          = 50887,//rank 5
+    ANNIHILATION                        = 51473,//rank 3
+    NECROSIS1                           = 51459,
+    NECROSIS2                           = 51462,
+    NECROSIS3                           = 51463,
+    NECROSIS4                           = 51464,
+    NECROSIS5                           = 51465,
+    SPELL_DEFLECTION                    = 49497,//rank 3
+    VENDETTA                            = 55136,//rank 3
+    KILLING_MACHINE                     = 51130,//rank 5
+    CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+    ON_A_PALE_HORSE_A                   = 51970,//rank 2
+    ON_A_PALE_HORSE_B                   = 51986,//rank 2
+    BLOOD_CAKED_BLADE1                  = 49219,
+    BLOOD_CAKED_BLADE2                  = 49627,
+    BLOOD_CAKED_BLADE3                  = 49628,
+    FRIGID_DREADPLATE                   = 51109,//rank 3
+    UNHOLY_BLIGHT                       = 49194,
+    DIRGE                               = 51206,//rank 2
+    BLOODY_VENGEANCE1                   = 48988,
+    BLOODY_VENGEANCE2                   = 49503,
+    BLOODY_VENGEANCE3                   = 49504,
+    ABOMINATIONS_MIGHT                  = 53138,//rank 2
+    IMPROVED_ICY_TALONS                 = 55610,
+    DESECRATION                         = 55667,//rank 2
+    //BLOODWORMS                          = 49543,//rank 3
+    IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+    DESOLATION                          = 66817,//rank 5
+    IMPROVED_UNHOLY_PRESENCE            = 50392,//rank 2
+    THREAT_OF_THASSARIAN                = 66192,//rank 3
+    CRYPT_FEVER                         = 49632,//rank 3
+    WILL_OF_THE_NECROPOLIS              = 52286,//rank 3
+    ACCLIMATION                         = 50152,//rank 3
+    WANDERING_PLAGUE                    = 49655,//rank 3
+    EBON_PLAGUEBRINGER                  = 51161,//rank 3
+
+//Other
+    //GLYPH_DANCING_RUNE_WEAPON           = 63330,
+    GLYPH_DISEASE                       = 63334,
+    GLYPH_CHAINS_OF_ICE                 = 58620,
+    GLYPH_UNHOLY_BLIGHT                 = 63332,
+    CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+
+    ITEM_DEATH_KNIGHT_T8_MELEE_4P       = 64736,
+    ITEM_DEATH_KNIGHT_T9_MELEE_4P       = 67118,
+
+//Special
+    FROST_FEVER                         = 59921,
+    BLOOD_PLAGUE                        = 59879,
+    RUNE_STRIKE_PASSIVE                 = 56816,//rune strike activation req aura
+    RUNIC_POWER_MASTERY                 = 49455//rank 1
+};
+enum DeathKnightSpecial
+{
+    FROST_FEVER_AURA                    = 55095,
+    BLOOD_PLAGUE_AURA                   = 55078,
+    CRYPT_FEVER_AURA                    = 50510,//rank 3
+    EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+    BLADE_BARRIER_BUFF                  = 64859,//rank 5
+    KILLING_MACHINE_BUFF                = 51124,
+    RIME_BUFF                           = 59052,//Freezing Fog
+    ITEM_DEATH_KNIGHT_T10_TANK_4P_BUFF  = 70654,//Blood Armor
+    ITEM_DEATH_KNIGHT_T10_MELEE_4P_BUFF = 70657,//Advantage
+
+    CHILBLAINS_DEBUFF                   = 50436,//Icy Clutch rank 3
+
+    BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+    //UNHOLY_BLIGHT_AURA                  = 50536,
+
+    DEATH_STRIKE_HEAL                   = 45470,
+    DEATH_COIL_HEAL                     = 47633,
+    DEATH_COIL_DAMAGE                   = 47632,
+
+    GLYPH_HEART_STRIKE_DEBUFF           = 58617, //50% move slow
+    GLYPH_RUNE_TAP_HEAL                 = 59754,
+    GLYPH_SCOURGE_STRIKE_EFFECT         = 69961
+};
+
+static const uint32 Deathknight_spells_damage_arr[] =
+{ BLOOD_BOIL_1, BLOOD_STRIKE_1, DEATH_AND_DECAY_1, DEATH_COIL_1,DEATH_STRIKE_1,
+FROST_STRIKE_1, HEART_STRIKE_1, HOWLING_BLAST_1, HUNGERING_COLD_1, ICY_TOUCH_1,
+OBLITERATE_1, PESTILENCE_1, PLAGUE_STRIKE_1, RUNE_STRIKE_1, SCOURGE_STRIKE_1 };
+
+static const uint32 Deathknight_spells_cc_arr[] =
+{ DEATH_GRIP_1, CHAINS_OF_ICE_1, MIND_FREEZE_1, STRANGULATE_1 };
+
+static const uint32 Deathknight_spells_support_arr[] =
+{ ANTI_MAGIC_SHELL_1, ANTI_MAGIC_ZONE_1, ARMY_OF_THE_DEAD_1, BLOOD_TAP_1, BONE_SHIELD_1,DARK_COMMAND_1, DEATHCHILL_1,
+DEATH_COIL_1, EMPOWER_RUNE_WEAPON_1, HORN_OF_WINTER_1, HUNGERING_COLD_1,HYSTERIA_1, ICEBOUND_FORTITUDE_1,
+LICHBORNE_1, MARK_OF_BLOOD_1, PATH_OF_FROST_1, PESTILENCE_1, RUNE_TAP_1,UNBREAKABLE_ARMOR_1, VAMPIRIC_BLOOD_1 };
+
+static const std::vector<uint32> Deathknight_spells_damage(FROM_ARRAY(Deathknight_spells_damage_arr));
+static const std::vector<uint32> Deathknight_spells_cc(FROM_ARRAY(Deathknight_spells_cc_arr));
+static const std::vector<uint32> Deathknight_spells_support(FROM_ARRAY(Deathknight_spells_support_arr));
+
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    int32 Cooldown;
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    struct death_knight_botAI : public bot_ai
+    {
+/*
+        bool OnGossipHello(Player* player) override
+        {
+            return OnGossipHello(player, 0);
+        }
+
+        bool OnGossipSelect(Player* player, uint32 sender, uint32 action) override
+        {
+            return OnGossipSelect(player, me, sender, action);
+        }
+
+        bool OnGossipSelectCode(Player* player, uint32 sender, uint32 action, char const* code) override
+        {
+            return OnGossipSelectCode(player, me, sender, action, code);
+        }
+*/
+        death_knight_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DEATH_KNIGHT;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            if (!HaveRunes(spellId))
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void SpendRunes(SpellInfo const* spellInfo, bool didHit) override
+        {
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src || (src->NoRuneCost() && src->NoRunicPowerGain()))
+                return;
+
+            //Freezing Fog
+            if (rimeProcTimer > GetLastDiff() && spellInfo->Id == HOWLING_BLAST_1)
+            {
+                for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                    runeCost[i] = 0;
+            }
+            else
+            {
+                for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                    runeCost[i] = src->RuneCost[i];
+            }
+
+            runeCost[RUNE_DEATH] = 0;
+
+            //debug 1
+            //std::ostringstream str;
+            //str << "Casted " << spellInfo->SpellName[0] << " cost"
+            //    << " " << runeCost[0] << " " << runeCost[1] << " " << runeCost[2] << " " << runeCost[3];
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes[i].CurrentRune;
+                if (runeCost[rune] > 0 && _runes[i].Cooldown <= 0)
+                    if (SpendRune(rune, didHit))
+                        runeCost[rune]--;
+            }
+
+            runeCost[RUNE_DEATH] = runeCost[RUNE_BLOOD] + runeCost[RUNE_UNHOLY] + runeCost[RUNE_FROST];
+
+            if (runeCost[RUNE_DEATH] > 0)
+            {
+                for (uint8 i = 0; i != MAX_RUNES && runeCost[RUNE_DEATH] > 0; ++i)
+                {
+                    if (_runes[i].CurrentRune == RUNE_DEATH && _runes[i].Cooldown <= 0)
+                        if (SpendRune(RUNE_DEATH, didHit))
+                            runeCost[RUNE_DEATH]--;
+                }
+            }
+
+            //debug 2
+            //uint32 runesLeft[NUM_RUNE_TYPES] = { 0,0,0,0 };
+            //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            //    for (uint8 j = 0; j != MAX_RUNES; ++j)
+            //        if (_runes[j].CurrentRune == i && _runes[j].Cooldown <= 0)
+            //            runesLeft[i]++;
+            //str << " left" << " " << runesLeft[0] << " " << runesLeft[1] << " " << runesLeft[2] << " " << runesLeft[3];
+            //BotWhisper(str.str().c_str());
+
+            me->ModifyPower(POWER_RUNIC_POWER, int32(src->RunicPower * runicpowerIncomeMult));
+
+            //BladeBarrier
+            if (/*src->RuneCost[RUNE_BLOOD] > 0 && */GetCooledRunesCount(RUNE_BLOOD) > 1)
+                me->CastSpell(me, BLADE_BARRIER_BUFF, true);
+
+            //Item - Death Knight T10 Melee 4P Bonus
+            if (me->GetLevel() >= 80 && GetCooledRunesCount() == MAX_RUNES)
+                me->CastSpell(me, ITEM_DEATH_KNIGHT_T10_MELEE_4P_BUFF, true);
+        }
+
+        void getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            if (me->FindCurrentSpellBySpellId(RUNE_STRIKE_1))
+                runicpower = std::max<int32>(runicpower - 200, 0);
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        uint8 GetBotStance() const override { return _presence; }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20 || IsCasting() || Feasting())
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRunes(PATH_OF_FROST_1)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK)))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || Rand() > 35)
+                return;
+
+            Unit* target = nullptr;
+
+            if (master->GetVictim() && master->IsInCombat() && IsMeleeClass(master->GetClass()) &&
+                GetHealthPCT(master) > 60 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true) &&
+                !master->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                target = master;
+
+            if (IAmFree())
+                return;
+
+            if (!target)
+            {
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* player = itr->GetSource();
+                        if (!player || player == master || player->IsBeingTeleported() ||
+                            me->GetMap() != player->FindMap())
+                            continue;
+
+                        if (IsMeleeClass(player->GetClass()) && player->GetVictim() && GetHealthPCT(player) > 60 &&
+                            me->GetDistance(player) < 30 && player->getAttackers().empty() && !CCed(player, true) &&
+                            !player->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                        {
+                            target = player;
+                            break;
+                        }
+
+                        if (!player->HaveBot())
+                            continue;
+
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (IsMeleeClass(bot->GetBotClass()) && bot->GetVictim() &&
+                                bot->GetBotAI()->HasRole(BOT_ROLE_DPS) && !bot->GetBotAI()->HasRole(BOT_ROLE_RANGED) &&
+                                GetHealthPCT(bot) > 60 && me->GetDistance(bot) < 30 && !CCed(bot, true) &&
+                                !bot->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                            {
+                                target = bot;
+                                break;
+                            }
+                        }
+
+                        if (target)
+                            break;
+                    }
+                }
+            }
+
+            if (!target && me->GetVictim() && HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED) &&
+                GetHealthPCT(me) > 60 && me->getAttackers().empty() && !CCed(me, true) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_DEATHKNIGHT, 0x20000000, 0x0, 0x0))
+                target = me;
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    ReportSpellCast(HYSTERIA_1, LocalizedNpcText(target->ToPlayer(), BOT_TEXT__ON_YOU), target->ToPlayer());
+                //if (target != master)
+                //{
+                //    std::string hystmsg = "Hysteria on " + (target == me ? "myself" : target->GetName()) + "!";
+                //    BotWhisper(hystmsg.c_str());
+                //}
+
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 1000); //fail
+        }
+
+        void CheckAntiMagic(uint32 diff)
+        {
+            if (!me->GetVictim() || !me->GetVictim()->HasUnitState(UNIT_STATE_CASTING) || Rand() > 40)
+                return;
+
+            Spell const* spell = me->GetVictim()->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (!spell || spell->GetTimer() >= 1000 || !spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                return;
+
+            Unit const* u = spell->m_targets.GetUnitTarget();
+            if (!u || (IAmFree() ? (u != me) : !(master->GetGroup() && master->GetGroup()->IsMember(spell->m_targets.GetObjectTargetGUID()))))
+                return;
+
+            if (u == me && IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) && runicpower >= rcost(ANTI_MAGIC_SHELL_1))
+            {
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                {
+                    getpower();
+                    return;
+                }
+            }
+
+            if (Rand() > 20)
+                return;
+
+            u = ObjectAccessor::GetUnit(*me, spell->m_targets.GetObjectTargetGUID());
+            if (u && !u->isMoving() && me->GetDistance(u) < 4 && IsSpellReady(ANTI_MAGIC_ZONE_1, diff, false) &&
+                HaveRunes(ANTI_MAGIC_ZONE_1) &&
+                !u->GetAuraEffect(SPELL_AURA_SCHOOL_ABSORB, SPELLFAMILY_DEATHKNIGHT, 0x20000, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(ANTI_MAGIC_ZONE_1)))
+                    return;
+            }
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30)
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (_presence == newpresence)
+            {
+                presencetimer = 5000;
+                return;
+            }
+
+            if (newpresence == DEATH_KNIGHT_FROST_PRESENCE && HaveRunes(FROST_PRESENCE_1))
+            {
+                if (doCast(me, FROST_PRESENCE_1))
+                    return;
+            }
+            else if (newpresence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRunes(BLOOD_PRESENCE_1))
+            {
+                if (doCast(me, BLOOD_PRESENCE_1))
+                    return;
+            }
+
+            presencetimer = 1000; //fail
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) && Rand() < 45 &&
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                    return;
+            }
+
+            bot_ai::BreakCC(diff);
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (Rand() > 35)
+                return;
+
+            if (IsSpellReady(STRANGULATE_1, diff) && me->IsInCombat() && HaveRunes(STRANGULATE_1))
+            {
+                Unit* u = FindCastingTarget(CalcSpellMaxRange(STRANGULATE_1), 0, STRANGULATE_1);
+                if (u && doCast(u, GetSpell(STRANGULATE_1)))
+                    return;
+            }
+
+            Unit* target = me->GetVictim();
+            if (IsSpellReady(MIND_FREEZE_1, diff, false) && target && me->GetDistance(target) < 5 &&
+                runicpower >= rcost(MIND_FREEZE_1) && target->IsNonMeleeSpellCast(false,false,true))
+            {
+                if (doCast(me->GetVictim(), GetSpell(MIND_FREEZE_1)))
+                    getpower();
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (me->IsAlive())
+            {
+                if (runicpowertimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (me->GetPower(POWER_RUNIC_POWER) > uint32(30.f * runicpowerLossMult))
+                            me->SetPower(POWER_RUNIC_POWER, me->GetPower(POWER_RUNIC_POWER) - uint32(30.f * runicpowerLossMult)); //-3 runic power every 2 sec
+                        else if (me->GetPower(POWER_RUNIC_POWER) > 0)
+                            me->SetPower(POWER_RUNIC_POWER, 0);
+                    }
+                    runicpowertimer = 2000;
+                }
+                if (runicpowertimer2 <= diff)
+                {
+                    if (me->IsInCombat())
+                    {
+                        if (me->GetPower(POWER_RUNIC_POWER) < me->GetMaxPower(POWER_RUNIC_POWER))
+                            me->SetPower(POWER_RUNIC_POWER, me->GetPower(POWER_RUNIC_POWER) + int32(20.f * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                        else if (me->GetPower(POWER_RUNIC_POWER) < me->GetMaxPower(POWER_RUNIC_POWER))
+                            me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                    }
+                    runicpowertimer2 = 5000;
+                }
+                getpower();
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            //pet is killed or unreachable
+            if (GC_Timer <= diff && petSummonTimer <= diff && !me->IsInCombat() && !me->IsMounted() && !me->GetVictim() && !IsCasting() && Rand() < 25 &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+                SummonBotPet();
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 40)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+            CheckPresence(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            Counter(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff) && Rand() < 25 &&
+                ((me->IsInCombat() && runicpower <= 900) ||
+                !me->GetAuraEffect(SPELL_AURA_MOD_STAT, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x40000000, 0x0)))
+            {
+                if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                    return;
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRunes(BONE_SHIELD_1) && Rand() < 25 + 65 * IsTank())
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || bone->GetDuration() < 10000)
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                        return;
+                }
+            }
+
+            CheckHysteria(diff);
+            CheckAntiMagic(diff);
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            //BLOOD TAP
+            if (IsSpellReady(BLOOD_TAP_1, diff, false) && Rand() < 65)
+            {
+                if (doCast(me, GetSpell(BLOOD_TAP_1)))
+                    getpower();
+            }
+
+            //ICEBOUND FORTITUDE
+            if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && Rand() < 50 && runicpower >= rcost(ICEBOUND_FORTITUDE_1) &&
+                GetHealthPCT(me) < std::min<uint32>(60, 35 + uint8(me->getAttackers().size()) * 5) + 20 * IsTank())
+            {
+                if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                {
+                    if (!IAmFree())
+                        ReportSpellCast(ICEBOUND_FORTITUDE_1, LocalizedNpcText(master, BOT_TEXT__USED), master);
+
+                    getpower();
+                }
+            }
+
+            //SELFHEAL
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 50 && (IsTank() || Rand() < 75))
+            {
+                if (HaveRunes(VAMPIRIC_BLOOD_1) || (IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false) && doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1))))
+                {
+                    if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                    {
+                        if (!IAmFree())
+                            ReportSpellCast(VAMPIRIC_BLOOD_1, LocalizedNpcText(master, BOT_TEXT__USED), master);
+
+                        return;
+                    }
+                }
+            }
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff, false) && GetHealthPCT(me) < 65 && Rand() < 50 && HaveRunes(RUNE_TAP_1))
+            {
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                    return;
+            }
+            //LICHBORNE + DEATH COIL
+            if ((me->GetCreatureType() == CREATURE_TYPE_UNDEAD || IsSpellReady(LICHBORNE_1, diff, false)) &&
+                IsSpellReady(DEATH_COIL_1, diff) && Rand() < 45 && GetHealthPCT(me) < 80 && runicpower >= rcost(DEATH_COIL_1))
+            {
+                if (me->GetCreatureType() == CREATURE_TYPE_UNDEAD || doCast(me, GetSpell(LICHBORNE_1)))
+                {
+                    if (doCast(me, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+            //END SELFHEAL
+
+            //EMPOWER RUNE WEAPON
+            if (IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false) && Rand() < 50 &&
+                GetCooledRunesCount() >= 5 && GetTotalRunesCooldown() >= (RUNE_BASE_COOLDOWN * 5) / 2)
+            {
+                if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                {
+                    //BotWhisper("ERW used!");
+                }
+            }
+
+            float dist = me->GetDistance(mytar);
+            Unit const* u = mytar->GetVictim();
+
+            //MARK OF BLOOD
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && u && Rand() < 55 && dist < 30 && HaveRunes(MARK_OF_BLOOD_1) &&
+                IsInBotParty(u) && GetHealthPCT(u) < 75 && u->GetDistance(mytar) < 10 &&
+                mytar->GetHealth() > me->GetMaxHealth() / 4 * (1 + mytar->getAttackers().size()) &&
+                (u == me || IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                !mytar->GetDummyAuraEffect(SPELLFAMILY_DEATHKNIGHT, 2285, 0))
+            {
+                if (doCast(mytar, GetSpell(MARK_OF_BLOOD_1)))
+                    return;
+            }
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && u && u != me && dist < 30 &&
+                mytar->GetTypeId() == TYPEID_UNIT && !mytar->IsControlledByPlayer() && Rand() < 50 &&
+                !CCed(mytar) && !mytar->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                (IsTank() || (!IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80)) &&
+                IsInBotParty(u))
+            {
+                if (doCast(mytar, GetSpell(DARK_COMMAND_1)))
+                    return;
+            }
+            //DARK COMMAND 2 (distant)
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && !IAmFree() && u == me && Rand() < 30 && IsTank() &&
+                (IsOffTank() || master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK_OFF) == 0) &&
+                !(me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())))
+            {
+                if (Unit* tUnit = FindDistantTauntTarget())
+                {
+                    if (doCast(tUnit, GetSpell(DARK_COMMAND_1)))
+                        return;
+                }
+            }
+
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && mytar->GetVictim() != me) ||
+            //    (mytar->GetVictim() == me && mytar->ToPlayer() && mytar->IsNonMeleeSpellCast(false)) &&
+            //    Rand() < 75)
+            //{
+            //    if (doCast(mytar, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+
+            //UNBREAKABLE ARMOR
+            if (IsSpellReady(UNBREAKABLE_ARMOR_1, diff, false) && dist < 10 && HaveRunes(UNBREAKABLE_ARMOR_1) &&
+                (IsTank() || !me->getAttackers().empty() || mytar->GetMaxHealth() > me->GetMaxHealth() || Rand() < 35))
+            {
+                if (doCast(me, GetSpell(UNBREAKABLE_ARMOR_1)))
+                {}
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //CHAINS OF ICE
+            if (IsSpellReady(CHAINS_OF_ICE_1, diff) && Rand() < 65 && dist < CalcSpellMaxRange(CHAINS_OF_ICE_1) && mytar->isMoving() &&
+                !(mytar->GetTypeId() == TYPEID_UNIT && (mytar->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_SNARE-1)))) &&
+                HaveRunes(CHAINS_OF_ICE_1) && !CCed(mytar, true) && (!u || (!IsTank(u) && IsInBotParty(u))) &&
+                !mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(mytar, GetSpell(CHAINS_OF_ICE_1)))
+                    return;
+            }
+
+            //HUNGERING COLD
+            if (IsSpellReady(HUNGERING_COLD_1, diff) && Rand() < 30 && runicpower >= rcost(HUNGERING_COLD_1))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 0);
+                if (targets.size() >= 3)
+                {
+                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                        return;
+                }
+            }
+
+            //Diseases in general
+            bool noDiseases = (mytar->GetTypeId() == TYPEID_UNIT && (mytar->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_INFECTED-1))));
+            AuraEffect const* blop = noDiseases ? nullptr : mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0, me->GetGUID());
+            AuraEffect const* frof = noDiseases ? nullptr : mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x4000000, 0x0, me->GetGUID());
+
+            auto [can_do_frost, can_do_shadow, can_do_physical] = CanAffectVictimBools(mytar, SPELL_SCHOOL_FROST, SPELL_SCHOOL_SHADOW, SPELL_SCHOOL_NORMAL);
+
+            //DISEASE SECTION
+
+            //PESTILENCE
+            if (IsSpellReady(PESTILENCE_1, diff) && can_do_shadow && blop && frof && dist < 5 && HaveRunes(PESTILENCE_1))
+            {
+                if (blop->GetBase()->GetDuration() < 5000 || frof->GetBase()->GetDuration() < 5000)
+                {
+                    if (doCast(mytar, GetSpell(PESTILENCE_1)))
+                        return;
+                }
+
+                if (Rand() < 35 + 65 * me->GetMap()->IsDungeon())
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 13.f, 0, mytar);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        //check existing blop and frof
+                        if (!(*itr)->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0, me->GetGUID()) ||
+                            !(*itr)->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x4000000, 0x0, me->GetGUID()))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(mytar, GetSpell(PESTILENCE_1)))
+                        return;
+                }
+            }
+            //ICY TOUCH
+            if (IsSpellReady(ICY_TOUCH_1, diff) && can_do_frost && !noDiseases && (!frof || frof->GetBase()->GetMaxDuration() < 3000) &&
+                dist < CalcSpellMaxRange(ICY_TOUCH_1) && HaveRunes(ICY_TOUCH_1))
+            {
+                if (doCast(mytar, GetSpell(ICY_TOUCH_1)))
+                    return;
+            }
+            //HOWLING BLAST
+            if (IsSpellReady(HOWLING_BLAST_1, diff) && can_do_frost && (rimeProcTimer > diff || Rand() < 70) &&
+                (!u || mytar->IsControlledByPlayer() || rimeProcTimer > diff ||
+                (u && u != me && IsTank(u) && u->getAttackers().size() > 2)) &&
+                dist < CalcSpellMaxRange(HOWLING_BLAST_1) && HaveRunes(HOWLING_BLAST_1))
+            {
+                if (u && u->getAttackers().size() > 4 &&
+                    IsSpellReady(DEATHCHILL_1, diff, false) && doCast(me, GetSpell(DEATHCHILL_1)))
+                {/* BotWhisper("Deathchill used!"); */}
+                if (doCast(mytar, GetSpell(HOWLING_BLAST_1)))
+                    return;
+            }
+
+            //END DISEASE SECTION
+
+            //MELEE SECTION
+
+            //FROST STRIKE
+            if (IsSpellReady(FROST_STRIKE_1, diff) && can_do_frost && Rand() < 90 && dist < 5 &&
+                runicpower >= rcost(FROST_STRIKE_1) &&
+                (runicpower >= 1000 || !GetSpell(OBLITERATE_1) || !HaveRunes(OBLITERATE_1)))
+            {
+                if (doCast(mytar, GetSpell(FROST_STRIKE_1)))
+                    return;
+            }
+            //BLOOD BOIL
+            if (IsSpellReady(BLOOD_BOIL_1, diff) && can_do_shadow && IsTank() && Rand() < 25 && HaveRunes(BLOOD_BOIL_1))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 1);
+                if (targets.size() >= 4)
+                    if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                        return;
+            }
+            //DEATH AND DECAY
+            if (IsSpellReady(DEATH_AND_DECAY_1, diff) && can_do_shadow && Rand() < (10 + 30 * IsTank()) && dist < 8 &&
+                HaveRunes(DEATH_AND_DECAY_1))
+            {
+                if (Unit* target = FindAOETarget(10))
+                {
+                    if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                        return;
+                }
+            }
+            //DEATH COIL
+            if (IsSpellReady(DEATH_COIL_1, diff) && can_do_shadow && Rand() < 50 && (dist > 6 || !GetSpell(FROST_STRIKE_1)) &&
+                (dist < (IAmFree() ? 30 : 15)) && runicpower > 2 * rcost(DEATH_COIL_1))
+            {
+                if (doCast(mytar, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            MoveBehind(mytar);
+
+            if (!can_do_physical || dist > 5)
+                return;
+
+            //PLAGUE STRIKE
+            if (IsSpellReady(PLAGUE_STRIKE_1, diff) && !noDiseases && (!blop || blop->GetBase()->GetDuration() < 3000) &&
+                HaveRunes(PLAGUE_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(PLAGUE_STRIKE_1)))
+                    return;
+            }
+
+            //DISEASE SECTION
+
+            //DEATH STRIKE
+            if (IsSpellReady(DEATH_STRIKE_1, diff) && blop && frof && Rand() < 60 &&
+                GetHealthPCT(me) < (80 - (10*(blop != nullptr) + 10*(frof != nullptr))) &&
+                (!me->GetMap()->IsDungeon() || mytar->IsControlledByPlayer()) && HaveRunes(DEATH_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(DEATH_STRIKE_1)))
+                    return;
+            }
+            //OBLITERATE
+            if (IsSpellReady(OBLITERATE_1, diff) && (noDiseases || (blop && frof)) && HaveRunes(OBLITERATE_1))
+            {
+                //DEATHCHILL
+                if (IsSpellReady(DEATHCHILL_1, diff, false) && doCast(me, GetSpell(DEATHCHILL_1)))
+                {/* BotWhisper("Deathchill used!"); */}
+                if (doCast(mytar, GetSpell(OBLITERATE_1)))
+                    return;
+            }
+            //HEART STRIKE - splash
+            if (IsSpellReady(HEART_STRIKE_1, diff) && (noDiseases || (blop && frof)) && (IsTank() || Rand() < 40) &&
+                HaveRunes(HEART_STRIKE_1) && FindSplashTarget())
+            {
+                if (doCast(mytar, GetSpell(HEART_STRIKE_1)))
+                    return;
+            }
+            //BLOOD STRIKE
+            if (IsSpellReady(BLOOD_STRIKE_1, diff) && (noDiseases || (blop && frof)) && HaveRunes(BLOOD_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(BLOOD_STRIKE_1)))
+                    return;
+            }
+            //SCOURGE STRIKE unused
+            //if (IsSpellReady(SCOURGE_STRIKE_1, diff) && (noDiseases || (blop && frof)) && HaveRunes(SCOURGE_STRIKE_1))
+            //{
+            //    if (doCast(mytar, GetSpell(SCOURGE_STRIKE_1)))
+            //        return;
+            //}
+
+            //END DISEASE SECTION
+
+            //RUNE STRIKE tank
+            if (IsSpellReady(RUNE_STRIKE_1, diff, false) && (IsTank() || runicpower >= 800) &&
+                me->HasAuraState(AURA_STATE_DEFENSE) && !me->GetCurrentSpell(CURRENT_MELEE_SPELL) &&
+                runicpower >= rcost(RUNE_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(RUNE_STRIKE_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damageinfo.Damages[0].Damage);
+            float pctbonus = 0.0f;
+
+            //Blood Gorged part 1 (white attacks): 10% bonus damage for all attacks
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 64 && me->HasAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT))
+                pctbonus += 0.1f;
+
+            damageinfo.Damages[0].Damage = uint32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+            if (baseId == PLAGUE_STRIKE_1)
+                crit_chance += 10.f;
+            //Scourge / Oblit Crit Up (60134): 5% additional critical chance for Scourge Strike and Obliterate
+            if (lvl >= 80 && (baseId == SCOURGE_STRIKE_1 || baseId == OBLITERATE_1))
+                crit_chance += 5.f;
+
+            //Killing Machine
+            if (AuraEffect const* mach = me->GetAuraEffect(KILLING_MACHINE_BUFF, 0))
+                if (mach->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+            //Deathchill
+            if (AuraEffect const* chil = me->GetAuraEffect(DEATHCHILL_1, 0))
+                if (chil->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+
+            //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+            if (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1 || baseId == SCOURGE_STRIKE_1 || baseId == OBLITERATE_1)
+                crit_chance += 9.f;
+            //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+            if (baseId == PLAGUE_STRIKE_1 || baseId == SCOURGE_STRIKE_1)
+                crit_chance += 6.f;
+            //Rime (part 1): 15% additional critical chance for Icy Touch and Obliterate
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 60 && (baseId == ICY_TOUCH_1 || baseId == OBLITERATE_1))
+                crit_chance += 15.f;
+            //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 62 && baseId == DEATH_STRIKE_1)
+                crit_chance += 6.f;
+
+            //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+            if (baseId == RUNE_STRIKE_1)
+                crit_chance += 10.f;
+
+            //Item - Death Knight T8 Melee 2P Bonus: 8% additional critical chance for Death Coil and Frost Strike
+            if (lvl >= 80 &&
+                (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE ||
+                baseId == DEATH_COIL_HEAL || baseId == FROST_STRIKE_1))
+                crit_chance += 8.f;
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 63 &&
+                    (baseId == BLOOD_BOIL_1 || baseId == BLOOD_STRIKE_1 || baseId == DEATH_STRIKE_1 || baseId == HEART_STRIKE_1))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike, Howling Blast and Obliterate
+                if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 63 &&
+                    (baseId == BLOOD_STRIKE_1 || baseId == FROST_STRIKE_1 ||
+                    baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (baseId == PLAGUE_STRIKE_1 || baseId == SCOURGE_STRIKE_1)
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Increased Blood Strike Damage (52394): 90 bonus damage for Blood Strike and Heart Strike
+            if (lvl >= 70 && (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Copy of Increased Blood Strike Damage (60825): 90 bonus damage for Blood Strike and Heart Strike
+            if (lvl >= 80 && (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Increased Scourge Strike Damage (54809): 91 bonus damage for Scourge Strike
+            if (lvl >= 80 && baseId == SCOURGE_STRIKE_1)
+                fdamage += 91.f;
+
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 57)
+            {
+                if (baseId == PLAGUE_STRIKE_1)
+                    pctbonus += 0.3f;
+                else if (baseId == SCOURGE_STRIKE_1)
+                    pctbonus += 0.2f;
+            }
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 59)
+            {
+                if (baseId == BLOOD_STRIKE_1)
+                    pctbonus += 0.15f;
+                else if (baseId == HEART_STRIKE_1)
+                    pctbonus += 0.45f;
+                else if (baseId == BLOOD_BOIL_1)
+                    pctbonus += 0.3f;
+            }
+            //Merciless Combat (melee): 12% bonus damage for Icy Touch, Howling Blast, Obliterate and Frost Strike on targets with less than 35% hp
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 60 &&
+                (baseId == ICY_TOUCH_1 || baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1 || baseId == FROST_STRIKE_1) &&
+                damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.12f;
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 62 && baseId == DEATH_STRIKE_1)
+                pctbonus += 0.3f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 62 && (baseId == BLOOD_STRIKE_1 || baseId == FROST_STRIKE_1))
+                pctbonus += 0.1f;
+            //Blood Gorged part 1 (melee): 10% bonus damage for all spells
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 64 && me->HasAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 15% damage bonus on targets affected with Frost Fever
+            if ((_spec == BOT_SPEC_DK_FROST) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_RANGED_HASTE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x0, 0x2))
+                pctbonus += 0.15f;
+            //Rage of Rivendare (melee): 10% damage bonus on targets affected with Blood Plague
+            if ((_spec == BOT_SPEC_DK_UNHOLY) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.1f;
+
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets
+            if (baseId == BLOOD_STRIKE_1 && damageinfo.target->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                pctbonus += 0.2f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (baseId == DEATH_STRIKE_1 && runicpower >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<int32>(runicpower, 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (baseId == OBLITERATE_1)
+                pctbonus += 0.25f;
+            //Glyph of Plague Strike: 20% bonus damage for Plague Strike
+            if (baseId == PLAGUE_STRIKE_1)
+                pctbonus += 0.2f;
+
+            //Item - Death Knight T8 Tank 2P Bonus
+            if (lvl >= 80 && baseId == RUNE_STRIKE_1)
+                pctbonus += 0.1f;
+            //Item - Death Knight T8 DPS Relic
+            if (lvl >= 80 && baseId == FROST_STRIKE_1)
+                fdamage += 380.f;
+            //Item - Death Knight T9 Tank 2P Bonus
+            if (lvl >= 80 && (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1))
+                pctbonus += 0.05f;
+            //Item - Death Knight T10 Melee 2P Bonus part 1
+            if (lvl >= 80 && baseId == OBLITERATE_1)
+                pctbonus += 0.1f;
+            //Item - Death Knight T10 Melee 2P Bonus part 2
+            if (lvl >= 80 && baseId == HEART_STRIKE_1)
+                pctbonus += 0.07f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Runic Focus (class passive): 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Blood Strike, Frost Strike, Howling Blast and Obliterate
+                if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 63 &&
+                    (baseId == BLOOD_STRIKE_1 || baseId == FROST_STRIKE_1 ||
+                    baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1))
+                    pctbonus += 0.45f / 1.5f;
+            }
+
+            //Improved Icy Touch part 1: 15% bonus damage for Icy Touch
+            if (baseId == ICY_TOUCH_1)
+                pctbonus += 0.15f;
+            //Black Ice: 10% bonus damage for Shadow and Frost spells
+            if (spellInfo->GetSchoolMask() & (SPELL_SCHOOL_MASK_FROST|SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Morbidity part 1: 15% damage bonus for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE)
+                pctbonus += 0.15f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike on diseased targets
+            if ((_spec == BOT_SPEC_DK_FROST) &&
+                lvl >= 59 && (baseId == ICY_TOUCH_1 || baseId == HOWLING_BLAST_1 || baseId == FROST_STRIKE_1) &&
+                IsDiseased(damageinfo.target))
+                pctbonus += 0.2f;
+            //Impurity: 20% bonus (from attack power) damage for all spells
+            if ((_spec == BOT_SPEC_DK_UNHOLY) && lvl >= 59)
+                if (SpellBonusEntry const* bonus = sSpellMgr->GetSpellBonusData(spellInfo->Id))
+                    if (bonus->ap_bonus > 0.f)
+                        fdamage += bonus->ap_bonus * 0.2f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast, Obliterate and Frost Strike on targets with less than 35% hp
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 60 &&
+                (baseId == ICY_TOUCH_1 || baseId == HOWLING_BLAST_1 || baseId == OBLITERATE_1 || baseId == FROST_STRIKE_1) &&
+                damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.12f;
+            //Blood Gorged part 1 (spell): 10% bonus damage for all spells
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 64 && me->HasAuraState(AURA_STATE_HEALTH_ABOVE_75_PERCENT))
+                pctbonus += 0.1f;
+            //Tundra Stalker (spell): 15% damage bonus on targets affected with Frost Fever
+            if ((_spec == BOT_SPEC_DK_FROST) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_RANGED_HASTE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x0, 0x2))
+                pctbonus += 0.15f;
+            //Rage of Rivendare (spell): 10% damage bonus on targets affected with Blood Plague
+            if ((_spec == BOT_SPEC_DK_UNHOLY) &&
+                lvl >= 64 && damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.1f;
+
+            //Glyph of Dark Death part 1: 15% damage bonus for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE)
+                pctbonus += 0.15f;
+            //Glyph of Icy Touch: 20% damage bonus for Frost Fever
+            if (baseId == FROST_FEVER || baseId == FROST_FEVER_AURA)
+                pctbonus += 0.2f;
+
+            //Item - Death Knight T8 DPS Relic
+            if (lvl >= 80 && baseId == DEATH_COIL_DAMAGE)
+                fdamage += 113.f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (baseId == ICY_TOUCH_1)
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_DAMAGE)
+                fdamage += 80.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //pct mods
+            //Morbidity part 2: 15% bonus healing for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_HEAL)
+                pctbonus += 0.15f;
+            //Improved Rune Tap part 1: 100% bonus healing for Rune Tap
+            if (lvl >= 58 && baseId == RUNE_TAP_1)
+                pctbonus += 1.f;
+            //Improved Death Strike (part 3): 50% bonus healing for Death Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 62 && baseId == DEATH_STRIKE_HEAL)
+                pctbonus += 0.5f;
+
+            //Glyph of Dark Death part 2: 15% bonus healing for Death Coil
+            if (baseId == DEATH_COIL_1 || baseId == DEATH_COIL_HEAL)
+                pctbonus += 0.15f;
+            //Glyph of Rune Tap part 1: 10% bonus healing for Rune Tap
+            if (baseId == RUNE_TAP_1)
+                pctbonus += 0.1f;
+
+            //flat mods
+            //Improved Prayer of Mending: 100 additional heal for Prayer of Mending
+            //if (baseId == PRAYER_OF_MENDING_HEAL)
+            //    flat_mod += 100;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Endless Winter part 2 -100% Runic Power cost for Mind Freeze
+            if (lvl >= 58 && baseId == MIND_FREEZE_1)
+                pctbonus += 1.f;
+
+            //Glyph of Blood Tap: -100% Health cost for Blood Tap
+            if (baseId == BLOOD_TAP_1)
+                pctbonus += 1.f;
+
+            //flat mods
+            //Glyph of Frost Strike: -8 Runic Power cost for Frost Strike
+            if (baseId == FROST_STRIKE_1)
+                flatbonus += 80;
+            //Glyph of Hungering Cold: -40 Runic Power cost for Hungering Cold
+            if (lvl >= 60 && baseId == HUNGERING_COLD_1)
+                flatbonus += 400;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            //if (lvl >= 45 && (baseId == INNER_FOCUS_1 || baseId == POWER_INFUSION_1 || baseId == PAIN_SUPPRESSION_1))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Unholy Command: -10 sec cooldown for Dark Command
+            if (lvl >= 56 && baseId == DARK_COMMAND_1)
+                timebonus += 10000;
+            //Improved Rune Tap part 2: -30 sec cooldown for Rune Tap
+            if (lvl >= 57 && baseId == RUNE_TAP_1)
+                timebonus += 30000;
+
+            //Glyph of Strangulate: -20 sec cooldown for Strangulate
+            if (baseId == STRANGULATE_1)
+                timebonus += 20000;
+
+            //Item - Death Knight T9 Tank 2P Bonus
+            if (lvl >= 80 && (baseId == UNBREAKABLE_ARMOR_1 || baseId == VAMPIRIC_BLOOD_1 || baseId == BONE_SHIELD_1))
+                timebonus += 10000;
+            //Strangulate Cooldown Reduction: -5 sec cooldown for Strangulate
+            if (baseId == STRANGULATE_1)
+                timebonus += 5000;
+
+            //Empower Rune Weapon Cooldown Reduction For Bot: -3 min
+            if (baseId == EMPOWER_RUNE_WEAPON_1)
+                timebonus += 180000;
+
+            cooldown = int32(std::max<float>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0.f));
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            //if (lvl >= 45 && baseId == PENANCE_1)
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Morbidity part 2
+            if (baseId == DEATH_AND_DECAY_1)
+                timebonus += 15000;
+
+            //Item - Death Knight T9 Tank 2P Bonus
+            if (lvl >= 80 && baseId == DARK_COMMAND_1)
+                timebonus += 2000;
+
+            cooldown = int32(std::max<float>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0.f));
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unholy Presence
+            if (_presence == DEATH_KNIGHT_UNHOLY_PRESENCE &&
+                ((spellInfo->SpellFamilyFlags[0] & 0xFFDFFE7F) ||
+                (spellInfo->SpellFamilyFlags[0] & 0x480B11F7) ||
+                (spellInfo->SpellFamilyFlags[0] & 0x20)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Corpse Explosion
+            if (spellInfo->SpellFamilyFlags[1] & 0x20)
+                flatbonus += 5.f;
+            //Glyph of Pestilence
+            if (baseId == PESTILENCE_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Holy Reach: +20% range for Holy Spells
+            //if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x100080))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Icy Reach: +10 yd range for Icy Touch, Chains of Ice and Howling Blast
+            if (baseId == ICY_TOUCH_1 || baseId == CHAINS_OF_ICE_1 || baseId == HOWLING_BLAST_1)
+                flatbonus += 10.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Rune Tap part 2
+            if (baseId == RUNE_TAP_1)
+                me->CastSpell(me, GLYPH_RUNE_TAP_HEAL, true);
+
+            //Empower Rune Weapon: rune activation helper
+            if (baseId == EMPOWER_RUNE_WEAPON_1)
+                ActivateAllRunes();
+
+            //Improved Chains of Ice (62142): convert frost rune into death rune
+            if (lvl >= 80 && baseId == CHAINS_OF_ICE_1)
+            {
+                ConvertRune(RUNE_FROST);
+            }
+            //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+            if (lvl >= 57 && (baseId == DEATH_STRIKE_1 || baseId == OBLITERATE_1))
+            {
+                ConvertRune(RUNE_UNHOLY);
+                ConvertRune(RUNE_FROST);
+            }
+            //Reaping: Blood Strike and Pestilence convert Blood Rune to Death Rune
+            if ((_spec == BOT_SPEC_DK_UNHOLY) && lvl >= 60 && (baseId == BLOOD_STRIKE_1 || baseId == PESTILENCE_1))
+            {
+                ConvertRune(RUNE_BLOOD);
+                //Blood of the North (part 2): same effect
+                if (lvl >= 62)
+                    ConvertRune(RUNE_BLOOD);
+            }
+            //Rime: consume buff
+            if (baseId == HOWLING_BLAST_1 && rimeProcTimer > GetLastDiff() && me->HasAura(RIME_BUFF))
+                me->RemoveAurasDueToSpell(RIME_BUFF);
+            //Blood Tap
+            if (baseId == BLOOD_TAP_1)
+            {
+                ConvertRune(RUNE_BLOOD);
+
+                //Item - Death Knight T10 Tank 4P Bonus: Blood Armor (12% damage reduce)
+                if (lvl >= 80)
+                    me->CastSpell(me, ITEM_DEATH_KNIGHT_T10_TANK_4P_BUFF, true);
+            }
+
+            //stances
+            if (spellInfo->GetCategory() == 47)
+            {
+                presencetimer = 1000;
+
+                if (baseId == BLOOD_PRESENCE_1)
+                    _presence = DEATH_KNIGHT_BLOOD_PRESENCE;
+                else if (baseId == FROST_PRESENCE_1)
+                    _presence = DEATH_KNIGHT_FROST_PRESENCE;
+                else if (baseId == UNHOLY_PRESENCE_1)
+                    _presence = DEATH_KNIGHT_UNHOLY_PRESENCE;
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //consume buffs (not on spell go)
+            //Killing Machine
+            //Deathchill
+            AuraEffect const* mach = me->GetAuraEffect(KILLING_MACHINE_BUFF, 0);
+            AuraEffect const* chil = me->GetAuraEffect(DEATHCHILL_1, 0);
+            if (mach && mach->IsAffectedOnSpell(spell))
+                me->RemoveAurasDueToSpell(KILLING_MACHINE_BUFF);
+            else if (chil && chil->IsAffectedOnSpell(spell))
+                me->RemoveAurasDueToSpell(DEATHCHILL_1);
+
+            //Icy Touch tanking helper (TODO: remove this hack after threat mods implementation)
+            //emulating passive mod +600% threat generated by Icy Touch while in Frost Presence
+            if (baseId == ICY_TOUCH_1 && _presence == DEATH_KNIGHT_FROST_PRESENCE && target->CanHaveThreatList())
+            {
+                if (SpellThreatEntry const* threatEntry = sSpellMgr->GetSpellThreatEntry(spellId))
+                {
+                    int32 baseThreat = 0;
+                    if (threatEntry->apPctMod != 0x0)
+                        baseThreat += int32(threatEntry->apPctMod * me->GetTotalAttackPowerValue(BASE_ATTACK));
+                    baseThreat += threatEntry->flatMod;
+
+                    if (baseThreat)
+                        target->GetThreatManager().AddThreat(me, baseThreat * 6.f, spell);
+                }
+            }
+
+            //Improved Icy Touch part 2: 6% increased effect (flat)
+            if (baseId == FROST_FEVER_AURA)
+            {
+                if (Aura const* feve = target->GetAura(spellId, me->GetGUID()))
+                {
+                    if (AuraEffect* fev1 = feve->GetEffect(1))
+                        fev1->ChangeAmount(fev1->GetAmount() - 6);
+                    if (AuraEffect* fev2 = feve->GetEffect(2))
+                        fev2->ChangeAmount(fev2->GetAmount() - 6);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown
+            if ((_spec == BOT_SPEC_DK_FROST) && baseId == OBLITERATE_1 && urand(1,100) <= 15)
+            {
+                ResetSpellCooldown(HOWLING_BLAST_1);
+                me->CastSpell(me, RIME_BUFF, true);
+            }
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (8 for bot)
+            if (baseId == HORN_OF_WINTER_1)
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 480000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    target->AddAura(44755, target); //snowflakes
+            }
+            //Epidemic: 6 sec bonus duration for DK Diseases
+            if (baseId == FROST_FEVER_AURA || baseId == BLOOD_PLAGUE_AURA ||
+                baseId == CRYPT_FEVER_AURA || baseId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 6000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Chilblains: proc Icy Clutch
+            if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 61 && baseId == FROST_FEVER_AURA)
+                me->CastSpell(target, CHILBLAINS_DEBUFF, true);
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike
+            if ((_spec == BOT_SPEC_DK_BLOOD) &&
+                (baseId == BLOOD_STRIKE_1 || baseId == HEART_STRIKE_1) && GetSpell(DEATH_COIL_1) && urand(1,100) <= 15)
+                me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+            //Glyph of Heart Strike
+            if (baseId == HEART_STRIKE_1)
+                me->CastSpell(target, GLYPH_HEART_STRIKE_DEBUFF, true);
+            //Glyph of Howling Blast
+            if (lvl >= 60 && baseId == HOWLING_BLAST_1)
+                me->CastSpell(target, FROST_FEVER_AURA, true);
+            //Glyph of Scourge Strike
+            if (baseId == SCOURGE_STRIKE_1)
+                me->CastSpell(target, GLYPH_SCOURGE_STRIKE_EFFECT, true);
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint32 spellId = spell->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Rime helper (Freezing Fog)
+            if (baseId == RIME_BUFF)
+            {
+                rimeProcTimer = 15000;
+            }
+
+            //Improved Blood Presence
+            if ((_spec == BOT_SPEC_DK_BLOOD) && lvl >= 61 && baseId == BLOOD_PRESENCE_1)
+            {
+                if (AuraEffect* pres = me->GetAuraEffect(spellId, 1))
+                    pres->ChangeAmount(pres->GetAmount() + 10);
+            }
+            if (baseId == ANTI_MAGIC_SHELL_1)
+            {
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    //Glyph of Anti-Magic Shell: 2 sec increased duration
+                    uint32 dur = shell->GetDuration() + 2000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                    //Magic Suppression part 2
+                    if (AuraEffect* shab = shell->GetEffect(0))
+                        shab->ChangeAmount(int32(shab->GetAmount() * 1.25f));
+                }
+            }
+            if (baseId == VAMPIRIC_BLOOD_1)
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* bloo = me->GetAura(spellId))
+                {
+                    uint32 dur = bloo->GetDuration() + 5000;
+                    bloo->SetDuration(dur);
+                    bloo->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == BONE_SHIELD_1)
+            {
+                //Glyph of Bone Shield: 1 bonus charge (1 for bot, 3 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+            }
+            if (baseId == ICEBOUND_FORTITUDE_1)
+            {
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    //Icebound Duration Increase: + 3 sec duration
+                    uint32 dur = fort->GetDuration() + 3000;
+
+                    //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration
+                    if ((_spec == BOT_SPEC_DK_FROST) && lvl >= 63)
+                        dur += 6000;
+
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+
+                    if (AuraEffect* eff2 = fort->GetEffect(EFFECT_2))
+                    {
+                        //calc correct amount
+                        int32 amount = eff2->GetAmount() - int32(0.15f * (std::max<int32>(0, GetBotDefense() - lvl*5)));
+                        //Glyph of Icebound Fortitude
+                        amount = std::min<int32>(amount, -40);
+                        //Increased Icebound Fortitude Mitigation (54803)
+                        if (lvl >= 70)
+                            amount -= 2;
+                        eff2->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (baseId == UNBREAKABLE_ARMOR_1)
+            {
+                if (AuraEffect* armo = me->GetAuraEffect(spellId, 0))
+                    armo->ChangeAmount(armo->GetAmount() + 5); //25 +20% = 30
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (_presence == DEATH_KNIGHT_FROST_PRESENCE || _presence == DEATH_KNIGHT_UNHOLY_PRESENCE)
+                {
+                    if (int32 bp0 = int32(damage / 25)) //4%
+                    {
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(bp0);
+                        me->CastSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, args);
+                    }
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* /*summon*/) const override
+        {
+            //TODO: garg, aod, drw
+            return 0;
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_GHOUL;
+
+            Position pos;
+
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_CORPSE_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0.f, float(me->GetOrientation() + M_PI / 2.f));
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all hunter bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+            {
+                petSummonTimer = 30000;
+                botPet = nullptr;
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_GHOUL;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            petSummonTimer = 5000;
+
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+
+            rimeProcTimer = 0;
+
+            _presence = BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+
+            DefaultInit();
+            InitRunes();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (rimeProcTimer > diff)               rimeProcTimer -= diff;
+
+            if (petSummonTimer > diff)              petSummonTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, 1300);
+            //RefreshAura(RUNIC_POWER_MASTERY);
+            //if (AuraEffect* mast = me->GetAuraEffect(RUNIC_POWER_MASTERY, 0))
+            //{
+            //    //Runic Power Mastery rank 2
+            //    mast->ChangeAmount(1300);
+            //}
+
+            if (botPet && botPet->GetPowerType() != POWER_ENERGY)
+                botPet->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_ENERGY);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isBloo = _spec == BOT_SPEC_DK_BLOOD;
+            bool isFros = _spec == BOT_SPEC_DK_FROST;
+            bool isUnho = _spec == BOT_SPEC_DK_UNHOLY;
+
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+            InitSpellMap(BLOOD_TAP_1);
+
+  /*Talent*/lvl >= 57 ? InitSpellMap(RUNE_TAP_1) : RemoveSpell(RUNE_TAP_1);
+  /*Talent*/lvl >= 59 && isBloo ? InitSpellMap(MARK_OF_BLOOD_1) : RemoveSpell(MARK_OF_BLOOD_1);
+  /*Talent*/lvl >= 61 && isBloo ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+  /*Talent*/lvl >= 62 && isBloo ? InitSpellMap(VAMPIRIC_BLOOD_1) : RemoveSpell(VAMPIRIC_BLOOD_1);
+  /*Talent*/lvl >= 63 && isBloo ? InitSpellMap(HEART_STRIKE_1) : RemoveSpell(HEART_STRIKE_1);
+
+  /*Talent*/lvl >= 57 ? InitSpellMap(LICHBORNE_1) : RemoveSpell(LICHBORNE_1);
+  /*Talent*/lvl >= 59 && isFros ? InitSpellMap(DEATHCHILL_1) : RemoveSpell(DEATHCHILL_1);
+  /*Talent*/lvl >= 61 && isFros ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+  /*Talent*/lvl >= 62 && isFros ? InitSpellMap(UNBREAKABLE_ARMOR_1) : RemoveSpell(UNBREAKABLE_ARMOR_1);
+  /*Talent*/lvl >= 63 && isFros ? InitSpellMap(FROST_STRIKE_1) : RemoveSpell(FROST_STRIKE_1);
+  /*Talent*/lvl >= 65 && isFros ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+
+  /*Talent*/lvl >= 61 && isUnho ? InitSpellMap(ANTI_MAGIC_ZONE_1) : RemoveSpell(ANTI_MAGIC_ZONE_1);
+  /*Talent*/lvl >= 62 && isUnho ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+  /*Talent*/lvl >= 63 && isUnho ? InitSpellMap(SCOURGE_STRIKE_1) : RemoveSpell(SCOURGE_STRIKE_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            InitSpellMap(UNHOLY_PRESENCE_1, true);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isBloo = _spec == BOT_SPEC_DK_BLOOD;
+            bool isFros = _spec == BOT_SPEC_DK_FROST;
+            bool isUnho = _spec == BOT_SPEC_DK_UNHOLY;
+
+            RefreshAura(BUTCHERY, level >= 55 ? 1 : 0);
+            RefreshAura(BLADED_ARMOR, level >= 56 ? 1 : 0);
+            RefreshAura(SCENT_OF_BLOOD, level >= 56 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, level >= 56 ? 1 : 0);
+            RefreshAura(SPELL_DEFLECTION, isBloo && level >= 58 ? 1 : 0);
+            RefreshAura(VENDETTA, isBloo && level >= 58 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE3, isBloo && level >= 62 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE2, isBloo && level >= 61 && level < 62 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE1, isBloo && level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(ABOMINATIONS_MIGHT, isBloo && level >= 60 ? 1 : 0);
+            //RefreshAura(BLOODWORMS, isBloo && level >= 61 ? 1 : 0);
+            RefreshAura(IMPROVED_BLOOD_PRESENCE, isBloo && level >= 61 ? 1 : 0);
+            RefreshAura(WILL_OF_THE_NECROPOLIS, isBloo && level >= 63 ? 1 : 0);
+
+            RefreshAura(TOUGHNESS, level >= 55 ? 1 : 0);
+            RefreshAura(ICY_TALONS, level >= 57 ? 1 : 0);
+            RefreshAura(ANNIHILATION, level >= 57 ? 1 : 0);
+            RefreshAura(KILLING_MACHINE, isFros && level >= 58 ? 1 : 0);
+            RefreshAura(CHILL_OF_THE_GRAVE, isFros && level >= 58 ? 1 : 0);
+            RefreshAura(FRIGID_DREADPLATE, isFros && level >= 59 ? 1 : 0);
+            RefreshAura(IMPROVED_ICY_TALONS, isFros && level >= 60 ? 1 : 0);
+            RefreshAura(THREAT_OF_THASSARIAN, isFros && level >= 62 ? 1 : 0);
+            RefreshAura(ACCLIMATION, isFros && level >= 63 ? 1 : 0);
+
+            RefreshAura(NECROSIS5, isUnho && level >= 62 ? 1 : 0);
+            RefreshAura(NECROSIS4, isUnho && level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(NECROSIS3, isUnho && level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(NECROSIS2, isUnho && level >= 58 && level < 59 ? 1 : 0);
+            RefreshAura(NECROSIS1, isUnho && level >= 57 && level < 58 ? 1 : 0);
+            RefreshAura(ON_A_PALE_HORSE_A, isUnho && level >= 58 ? 1 : 0);
+            RefreshAura(ON_A_PALE_HORSE_B, isUnho && level >= 58 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE3, isUnho && level >= 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE2, isUnho && level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE1, isUnho && level >= 58 && level < 59 ? 1 : 0);
+            RefreshAura(UNHOLY_BLIGHT, isUnho && level >= 59 ? 1 : 0);
+            RefreshAura(DIRGE, isUnho && level >= 59 ? 1 : 0);
+            RefreshAura(DESECRATION, isUnho && level >= 60 ? 1 : 0);
+            RefreshAura(DESOLATION, isUnho && level >= 61 ? 1 : 0);
+            RefreshAura(IMPROVED_UNHOLY_PRESENCE, isUnho && level >= 61 ? 1 : 0);
+            RefreshAura(CRYPT_FEVER, isUnho && level >= 62 ? 1 : 0);
+            RefreshAura(WANDERING_PLAGUE, isUnho && level >= 63 ? 1 : 0);
+            RefreshAura(EBON_PLAGUEBRINGER, isUnho && level >= 63 ? 1 : 0);
+
+            //RefreshAura(GLYPH_DANCING_RUNE_WEAPON, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_DISEASE);
+            RefreshAura(GLYPH_CHAINS_OF_ICE);
+            RefreshAura(GLYPH_UNHOLY_BLIGHT, level >= 60 ? 1 : 0);
+
+            RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH);
+            RefreshAura(ITEM_DEATH_KNIGHT_T8_MELEE_4P, level >= 80 ? 1 : 0);
+            RefreshAura(ITEM_DEATH_KNIGHT_T9_MELEE_4P, level >= 80 ? 1 : 0);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+            RefreshAura(RUNE_STRIKE_PASSIVE);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Deathknight_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Deathknight_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Deathknight_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Deathknight_spells_support;
+        }
+
+    private:
+        BotRuneInfo _runes[MAX_RUNES];
+
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2;
+        uint32 rimeProcTimer;
+/*misc*/int32 runicpower;
+/*misc*/int32 runeCost[NUM_RUNE_TYPES];
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 _presence;
+        //Pet
+        uint32 petSummonTimer;
+
+        bool HaveRunes(uint32 spellId)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            return (spellInfo && HaveRunes(spellInfo));
+        }
+
+        bool HaveRunes(SpellInfo const* spellInfo)
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src || src->NoRuneCost())
+                return true;
+
+            //Freezing Fog
+            if (rimeProcTimer > GetLastDiff() && spellInfo->Id == HOWLING_BLAST_1)
+                return true;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runeCost[i] = src->RuneCost[i];
+
+            runeCost[RUNE_DEATH] = MAX_RUNES;
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes[i].CurrentRune;
+                if (runeCost[rune] > 0 && _runes[i].Cooldown <= 0)
+                    runeCost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runeCost[i] > 0)
+                    runeCost[RUNE_DEATH] += runeCost[i];
+
+            if (runeCost[RUNE_DEATH] > MAX_RUNES)
+                return false;
+
+            return true;
+        }
+
+        bool SpendRune(uint8 runetype, bool didHit)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes[i].CurrentRune == runetype && _runes[i].Cooldown <= 0)
+                {
+                    _runes[i].CurrentRune = _runes[i].BaseRune;
+                    uint32 cooldown = didHit ? RUNE_BASE_COOLDOWN : RUNE_MISS_COOLDOWN;
+
+                    //Improved Unholy Presence
+                    if (_presence == DEATH_KNIGHT_UNHOLY_PRESENCE)
+                        cooldown -= 1000;
+
+                    _runes[i].Cooldown += cooldown;
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes[i].BaseRune == runetype && _runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint8 GetCooledRunesCount() const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint32 GetTotalRunesCooldown() const
+        {
+            uint32 totalCd = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                totalCd += std::max<int32>(_runes[i].Cooldown, 0);
+
+            return totalCd;
+        }
+
+        void ConvertRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes[i].CurrentRune == runetype)
+                {
+                    _runes[i].CurrentRune = RUNE_DEATH;
+                    return;
+                }
+            }
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                _runes[i].Cooldown = std::min<int32>(_runes[i].Cooldown, me->IsInCombat() ? -1 : 0);
+        }
+
+        void InitRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes[i].BaseRune = runeSlotTypes[i];
+                _runes[i].CurrentRune = _runes[i].BaseRune;
+                _runes[i].Cooldown = 0;
+            }
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                int32 &cd = _runes[i].Cooldown;
+                if (me->IsInCombat())
+                {
+                    //RGP
+                    if (cd != 0)
+                    {
+                        if (cd >= int32(-2500 + diff))
+                            cd -= diff;
+                        else if (cd != -2500)
+                            cd = -2500;
+                        //ensurance
+                        if (!cd)
+                            --cd;
+                    }
+                }
+                else
+                {
+                    if (cd >= int32(diff))
+                        cd -= diff;
+                    else if (cd)
+                        cd = 0;
+                }
+            }
+        }
+
+        bool IsDiseased(Unit const* unit) const
+        {
+            static const AuraType botDiseaseAuraTypes[] =
+            {
+                SPELL_AURA_PERIODIC_DAMAGE, // Frost Fever and Blood Plague
+                SPELL_AURA_LINKED,          // Crypt Fever and Ebon Plague
+                SPELL_AURA_NONE
+            };
+
+            for (AuraType const* itr = botDiseaseAuraTypes; *itr != SPELL_AURA_NONE; ++itr)
+            {
+                Unit::AuraEffectList const& disAuras = unit->GetAuraEffectsByType(*itr);
+                for (Unit::AuraEffectList::const_iterator ditr = disAuras.begin(); ditr != disAuras.end(); ++ditr)
+                {
+                    // Get auras with disease dispel type by caster
+                    if ((*ditr)->GetSpellInfo()->Dispel == DISPEL_DISEASE)
+                        return true;
+                }
+            }
+
+            return false;
+        }
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp b/src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp
new file mode 100644
index 000000000..411e37700
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_dreadlord_ai.cpp
@@ -0,0 +1,543 @@
+#include "bot_ai.h"
+#include "botspell.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "TemporarySummon.h"
+/*
+Dreadlord NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Incredibly powerful demon who wields power of darkness and mental domination
+Specifics:
+High armor, high resistances, partially immune to control effects, damage taken speeds up spells recharge, plate armor,
+deals melee/spellshadow damage, bonus damage to CCed units, spell power bonus: 200% strength.
+Abilities:
+1) Carrion Swarm. Sends a horde of bats combined with chaotic magic to damage enemies in frontal cone, 10 seconds cooldown.
+2) Sleep. Puts the enemy target to sleep for 60 seconds (15 seconds on players) and allows next physical attack
+on that target to bypass armor, removed by direct damage, 6 seconds cooldown.
+3) Vampiric Aura. Increases physical critical damage by 5% and heals party and raid members within 40 yards for a
+percentage (100% for Dreadlord and 25% for everyone else) of damage done by physical attacks and Carrion Swarm, no threat.
+4) Summon Infernal Servant. Calls an infernal down from the sky dealing damage and stunning enemy units, lasts 180 seconds, 180 seconds cooldown.
+Complete - 100%
+TODO:
+*/
+
+enum DreadlordBaseSpells
+{
+    CARRION_SWARM_1         = SPELL_CARRION_SWARM,
+    SLEEP_1                 = SPELL_SLEEP,
+    INFERNO_1               = SPELL_INFERNO
+};
+enum DreadlordPassives
+{
+    VAMPIRIC_AURA           = SPELL_VAMPIRIC_AURA,
+};
+enum DreadlordSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+
+    CARRION_COST            = 110 * 5,
+    SLEEP_COST              = 50 * 5,
+    INFERNAL_COST           = 175 * 5,
+
+    DAMAGE_CD_REDUCTION     = 250,//ms
+    INFERNO_SPAWN_DELAY     = 650,//ms
+
+    IMMOLATION              = 39007
+};
+
+static const uint32 Dreadlord_spells_damage_arr[] =
+{ CARRION_SWARM_1, INFERNO_1 };
+
+static const uint32 Dreadlord_spells_cc_arr[] =
+{ SLEEP_1 };
+
+static const uint32 Dreadlord_spells_support_arr[] =
+{ INFERNO_1 };
+
+static const std::vector<uint32> Dreadlord_spells_damage(FROM_ARRAY(Dreadlord_spells_damage_arr));
+static const std::vector<uint32> Dreadlord_spells_cc(FROM_ARRAY(Dreadlord_spells_cc_arr));
+static const std::vector<uint32> Dreadlord_spells_support(FROM_ARRAY(Dreadlord_spells_support_arr));
+
+class dreadlord_bot : public CreatureScript
+{
+public:
+    dreadlord_bot() : CreatureScript("dreadlord_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new dreadlord_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct dreadlord_botAI : public bot_ai
+    {
+    private:
+        //DelayedPetSpawnEvent - Dreadlord
+        //Impact anim, spawn, linked effects
+        class DelayedPetSpawnEvent : public BasicEvent
+        {
+            public:
+                DelayedPetSpawnEvent(Creature const* bot, Position const* pos) : _bot(bot), _pos(pos) { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    ((dreadlord_botAI*)_bot->AI())->SummonBotPet(_pos);
+                    return true;
+                }
+
+            private:
+                Creature const* _bot;
+                Position const* _pos;
+                DelayedPetSpawnEvent(DelayedPetSpawnEvent const&);
+        };
+
+    public:
+        dreadlord_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DREADLORD;
+
+            InitUnitFlags();
+
+            //dreadlord immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+
+            checkAuraTimer = 10000;
+
+            if (!me->HasAura(VAMPIRIC_AURA, me->GetGUID()))
+                RefreshAura(VAMPIRIC_AURA);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            //if (!me->IsInCombat())
+            //    DoNonCombatActions(diff);
+
+            CheckAura(diff);
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < CARRION_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            if (IsCasting())
+                return;
+
+            if (IsSpellReady(INFERNO_1, diff) && !botPet && me->IsInCombat() &&
+                me->GetPower(POWER_MANA) >= INFERNAL_COST && Rand() < 60)
+            {
+                Unit* target = FindAOETarget(CalcSpellMaxRange(INFERNO_1));
+
+                if (target)
+                    _infernoPos = target->GetPosition();
+                else
+                    me->GetNearPoint(me, _infernoPos.m_positionX, _infernoPos.m_positionY, _infernoPos.m_positionZ, 5.f, 0.f);
+
+                me->CastSpell(_infernoPos, GetSpell(INFERNO_1), false);
+                return;
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            CheckSleep(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(CARRION_SWARM_1, diff) && me->GetPower(POWER_MANA) >= CARRION_COST && Rand() < 80)
+            {
+                bool cast = false;
+                if (me->HasInArc(float(M_PI)/2, mytar) && me->GetDistance(mytar) < 25 &&
+                    (IsTank() || GetManaPCT(me) > 60 || me->getAttackers().empty() || GetHealthPCT(me) < 50 ||
+                    mytar->HasAura(SLEEP_1)))
+                {
+                    cast = true;
+                }
+
+                if (!cast)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsInConeList(targets, 25); //real radius is 30
+                    if (targets.size() > 1)
+                    {
+                        cast = true;
+                    }
+                }
+
+                if (cast && doCast(me, GetSpell(CARRION_SWARM_1)))
+                    return;
+            }
+        }
+
+        void CheckSleep(uint32 diff)
+        {
+            if (!IsSpellReady(SLEEP_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            //fleeing/casting/solo enemy
+            Unit* u = me->GetVictim();
+            if (u && IsSpellReady(CARRION_SWARM_1, diff, false) && !CCed(u) && me->GetDistance(u) < CalcSpellMaxRange(SLEEP_1) &&
+                (u->IsNonMeleeSpellCast(false,false, true) || (u->IsInCombat() && u->getAttackers().size() == 1)))
+            {
+                if (doCast(u, GetSpell(SLEEP_1)))
+                    return;
+            }
+
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(SLEEP_1), 0, SLEEP_1))
+            {
+                if (doCast(target, GetSpell(SLEEP_1)))
+                    return;
+            }
+
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(SLEEP_1)))
+            {
+                if (doCast(target, GetSpell(SLEEP_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            float pctbonus = 1.0f;
+
+            //150% damage on CCed units
+            if (CCed(damageinfo.Target))
+                pctbonus *= 1.5f;
+
+            damageinfo.Damages[0].Damage = uint32(damageinfo.Damages[0].Damage * pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (iscrit)
+                pctbonus *= 1.333f;
+
+            //double damage on CCed units
+            if (CCed(damageinfo.target))
+                pctbonus *= 2.f;
+
+            if (baseId == CARRION_SWARM_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->_effects[0].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == CARRION_SWARM_1)
+            {
+                me->resetAttackTimer();
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+            }
+
+            if (baseId == INFERNO_1)
+            {
+                me->CastSpell(_infernoPos, SPELL_INFERNO_METEOR_VISUAL, true);
+                DelayedPetSpawnEvent* spawnEvent = new DelayedPetSpawnEvent(me, &_infernoPos);
+                Events.AddEvent(spawnEvent, Events.CalculateTime(std::chrono::milliseconds(INFERNO_SPAWN_DELAY)));
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* spellInfo) override
+        {
+            //Carrion swarm heal
+            if (damage && victim != me && spellInfo && spellInfo->GetFirstRankSpell()->Id == CARRION_SWARM_1)
+            {
+                int32 basepoints0 = std::min<uint32>(damage, victim->GetHealth());
+                //TC_LOG_ERROR("entities.unit", "OnBotDamageDealt(drl): %s on %s base val %i (%s),",
+                //    me->GetName().c_str(), victim->GetName().c_str(), int32(damage), spellInfo->SpellName[0]);
+                CastSpellExtraArgs args(true);
+                args.AddSpellBP0(basepoints0);
+                me->CastSpell(me, SPELL_TRIGGERED_HEAL, args);
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (damage)
+            {
+                BotSpellMap const& spells = GetSpellMap();
+                for (BotSpellMap::const_iterator itr = spells.begin(); itr != spells.end(); ++itr)
+                {
+                    //not affected if pet is alive
+                    if (botPet && itr->first == INFERNO_1)
+                        continue;
+
+                    uint32& cooldown = itr->second->cooldown;
+                    if (!cooldown)
+                        continue;
+
+                    cooldown = cooldown > DAMAGE_CD_REDUCTION ? cooldown - DAMAGE_CD_REDUCTION : 0;
+                }
+            }
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet(Position const* sPos)
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_INFERNAL;
+
+            //Position pos;
+
+            Creature* myPet = me->SummonCreature(entry, *sPos, TEMPSUMMON_CORPSE_TIMED_DESPAWN, std::chrono::milliseconds(2000));
+            //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+            //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //immune
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, INFERNO_1);
+            //dreadlord immunities
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+
+            //myPet->SetMeleeDamageSchool(SPELL_SCHOOL_FIRE);
+
+            //infernal is immune to magic
+            //myPet->ApplySpellImmune(0, IMMUNITY_DAMAGE, SPELL_SCHOOL_MASK_MAGIC, true);
+            myPet->CastSpell(myPet, SPELL_INFERNO_EFFECT, true); //damage, stun
+            //myPet->CastSpell(myPet, SPELL_INFERNO_IMPACT_EXPLOSION, true); //visual
+            myPet->CastSpell(myPet, IMMOLATION, true);
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_INFERNAL;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            checkAuraTimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(CARRION_SWARM_1, true, false);
+            InitSpellMap(SLEEP_1, true, false);
+            InitSpellMap(INFERNO_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case CARRION_SWARM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Dreadlord_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Dreadlord_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Dreadlord_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Dreadlord_spells_support;
+        }
+
+    private:
+        uint32 checkAuraTimer;
+        Position _infernoPos;
+    };
+};
+
+void AddSC_dreadlord_bot()
+{
+    new dreadlord_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 000000000..293acd5af
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,2936 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "Group.h"
+#include "Log.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+#include "World.h"
+/*
+Druid NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 85-90%
+TODO: Resolve remaining bugs with wrong power type after death
+TODO2: PvP behaviour revamp (again, it's like 5th time?)
+*/
+
+#define MAX_TREANTS 3
+
+enum DruidBaseSpells
+{
+    MARK_OF_THE_WILD_1                  = 1126,
+    THORNS_1                            = 467,
+    HEALING_TOUCH_1                     = 5185,
+    REGROWTH_1                          = 8936,
+    REJUVENATION_1                      = 774,
+    LIFEBLOOM_1                         = 33763,
+    NOURISH_1                           = 50464,
+    WILD_GROWTH_1                       = 48438,
+    SWIFTMEND_1                         = 18562,
+    TRANQUILITY_1                       = 740,
+    REVIVE_1                            = 50769,
+    REBIRTH_1                           = 20484,
+    BEAR_FORM_1                         = 5487,
+    SWIPE_BEAR_1                        = 779,
+    MANGLE_BEAR_1                       = 33878,
+    BASH_1                              = 5211,
+    MAUL_1                              = 6807,
+    FERAL_CHARGE_BEAR_1                 = 16979,
+    CHALLENGING_ROAR_1                  = 5209,
+    ENRAGE_1                            = 5229,
+    FRENZIED_REGENERATION_1             = 22842,
+    GROWL_1                             = 6795,
+    LACERATE_1                          = 33745,
+    SURVIVAL_INSTINCTS_1                = 61336,
+    FAERIE_FIRE_FERAL_1                 = 16857,//chains threat and damage spell regardless of bot feral form
+    BERSERK_1                           = 50334,
+    CAT_FORM_1                          = 768,
+    CLAW_1                              = 1082,
+    RAKE_1                              = 1822,
+    SHRED_1                             = 5221,
+    MANGLE_CAT_1                        = 33876,
+    RIP_1                               = 1079,
+    FEROCIOUS_BITE_1                    = 22568,
+    POUNCE_1                            = 9005,
+    RAVAGE_1                            = 6785,
+    MAIM_1                              = 22570,
+    SWIPE_CAT_1                         = 62078,
+    SAVAGE_ROAR_1                       = 52610,
+    FERAL_CHARGE_CAT_1                  = 49376,
+    COWER_1                             = 8998,
+    DASH_1                              = 1850,
+    TIGERS_FURY_1                       = 5217,
+    PROWL_1                             = 5215,
+    MOONFIRE_1                          = 8921,
+    STARFIRE_1                          = 2912,
+    WRATH_1                             = 5176,
+    HURRICANE_1                         = 16914,
+    FAERIE_FIRE_NORMAL_1                = 770,
+    INSECT_SWARM_1                      = 5570,
+    TYPHOON_1                           = 50516,
+    STARFALL_1                          = 48505,
+    MOONKIN_FORM_1                      = 24858,
+    TREE_OF_LIFE_FORM_1                 = 33891,
+    TRAVEL_FORM_1                       = 783,
+    AQUATIC_FORM_1                      = 1066,
+    //FLIGHT_FORM_1                       = 0,//niy
+    ABOLISH_POISON_1                    = 2893,//manual use only
+    CURE_POISON_1                       = 8946,
+    REMOVE_CURSE_1                      = 2782,
+    ENTANGLING_ROOTS_1                  = 339,
+    CYCLONE_1                           = 33786,
+    HIBERNATE_1                         = 2637,
+    BARKSKIN_1                          = 22812,
+    NATURES_GRASP_1                     = 16689,
+    INNERVATE_1                         = 29166,
+    NATURES_SWIFTNESS_1                 = 17116
+};
+enum DruidPassives
+{
+//Talents
+    OMEN_OF_CLARITY                     = 16864,//clearcast
+    NATURESGRACE                        = 61346,//rank 3
+    NATURAL_PERFECTION1                 = 33881,
+    NATURAL_PERFECTION2                 = 33882,
+    NATURAL_PERFECTION3                 = 33883,
+    LIVING_SEED1                        = 48496,
+    LIVING_SEED2                        = 48499,
+    LIVING_SEED3                        = 48500,
+    REVITALIZE1                         = 48539,
+    REVITALIZE2                         = 48544,
+    REVITALIZE3                         = 48545,
+    NATURALIST                          = 17073,//rank 5
+    IMPROVED_MARK_OF_THE_WILD           = 17051,//rank 2
+    FUROR                               = 17061,//rank 5
+    INTENSITY                           = 17108,//rank 3
+    LIVING_SPIRIT                       = 34153,//rank 3
+    GIFT_OF_THE_EARTHMOTHER             = 51183,//rank 5
+    ECLIPSE                             = 48525,//rank 3
+    EARTH_AND_MOON                      = 48511,//rank 3
+    SURVIVAL_OF_THE_FITTEST             = 33856,//rank 3
+    DREAMSTATE                          = 33956,//rank 3
+    BALANCE_OF_POWER                    = 33596,//rank 2
+    IMPROVED_MOONKIN_FORM               = 48396,//rank 3
+    OWLKIN_FRENZY                       = 48393,//rank 3 NOT REFRESHAURABLE
+    FERAL_SWIFTNESS                     = 24866,//rank 2 NOT REFRESHAURABLE
+    PRIMAL_PRECISION                    = 48410,//rank 2 expertise only, refund handled in Spell.cpp
+    NATURAL_REACTION                    = 57881,//rank 3 NOT REFRESHAURABLE
+    IMPROVED_LEADER_OF_THE_PACK         = 34300,//rank 2
+    PRIMAL_TENACITY                     = 33957,//rank 3
+    PREDATORY_INSTINCTS                 = 33867,//rank 3 NOT REFRESHAURABLE
+    KING_OF_THE_JUNGLE                  = 48495,//rank 3
+    PRIMAL_GORE                         = 63503,//rank 1
+//Glyphs
+    GLYPH_NOURISH                       = 62971,
+    GLYPH_SWIFTMEND                     = 54824,//no consumption
+    GLYPH_INNERVATE                     = 54832,//self regen
+    GLYPH_RAPID_REJUVENATION            = 71013,
+    GLYPH_REGROWTH                      = 54743,
+    GLYPH_REJUVENATION                  = 54754,
+    GLYPH_FRENZIED_REGENERATION         = 54810,
+    GLYPH_BARKSKIN                      = 63057,
+    GLYPH_RAKE                          = 54821,
+    GLYPH_SHRED                         = 54815,
+//other
+    T10_RESTO_P4_BONUS                  = 70664,//rejuve jump
+    T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+    T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+
+    T8_BALANCE_P4_BONUS                 = 64824,//insect swarm periodic starfire instacast trigger
+    T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+    T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+    T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+
+    T10_FERAL_P4_BONUS                  = 70726,//rake crit, enraged defense
+    T8_FERAL_P2_BONUS                   = 64752,//periodic clearcast trigger
+};
+enum DruidSpecial
+{
+    STARFALL_DAMAGE_AOE_4               = 53190,//for radius mods
+    //STARFALL_DAMAGE_DIRECT_4            = 53195,
+    STARFALL_DUMMY_AOE_4                = 53198,//for radius mods
+
+    HURRICANE_DAMAGE_1                  = 42231,
+    //TRANQUILITY_HEAL_1                  = 44203,
+    //TYPHOON_DAMAGE_1                    = 61391,
+
+    SAVAGE_ROAR_BUFF                    = 62071,//hidden buff
+    PREDATORS_SWIFTNESS_BUFF            = 69369,
+    LEADER_OF_THE_PACK_BUFF             = 24932,
+    NURTURING_INSTINCT_BUFF             = 47180,//rank 2 hidden NOT REFRESHAURABLE
+    SURVIVAL_OF_THE_FITTEST_BUFF        = 62069,//hidden buff
+    SAVAGE_DEFENSE_PASSIVE              = 62600,//class passive lvl 40
+    SAVAGE_DEFENSE_BUFF                 = 62606,
+    MASTER_SHAPESHIFTER_BEAR_BUFF       = 48418,
+    MASTER_SHAPESHIFTER_CAT_BUFF        = 48420,
+    MASTER_SHAPESHIFTER_MOONKIN_BUFF    = 48421,
+    MASTER_SHAPESHIFTER_TREE_BUFF       = 48422,
+    //NATURESGRACEBUFF                    = 16886,
+    ECLIPSE_SOLAR_BUFF                  = 48517,// from Starfire to Wrath
+    ECLIPSE_LUNAR_BUFF                  = 48518,// from Wrath to Starfire
+    ELUNES_WRATH_BUFF                   = 64823,//Starfire instacast
+    OMEN_OF_CLARITY_BUFF                = 16870,
+
+    //FERAL_CHARGE_EFFECT_BEAR_ROOT       = 45334,
+    //FERAL_CHARGE_EFFECT_CAT_DAZE        = 50259,
+    INFECTED_WOUNDS_EFFECT              = 58181,//rank 3
+    PRIMAL_FURY_EFFECT_ENERGIZE         = 16959,//5 rage
+
+    FORCE_OF_NATURE_1                   = 33831 //not casted
+};
+
+static const uint32 Druid_spells_damage_arr[] =
+{ FAERIE_FIRE_FERAL_1, CLAW_1, FEROCIOUS_BITE_1, MAIM_1, MANGLE_CAT_1, POUNCE_1, RAKE_1, RAVAGE_1, RIP_1, SHRED_1,
+SWIPE_CAT_1, LACERATE_1, MANGLE_BEAR_1, MAUL_1,SWIPE_BEAR_1, ENTANGLING_ROOTS_1, HURRICANE_1, INSECT_SWARM_1,
+MOONFIRE_1, STARFALL_1, STARFIRE_1, TYPHOON_1, THORNS_1 };
+
+static const uint32 Druid_spells_cc_arr[] =
+{ BASH_1, CYCLONE_1, ENTANGLING_ROOTS_1, FERAL_CHARGE_BEAR_1, HIBERNATE_1, MAIM_1, POUNCE_1, TYPHOON_1 };
+
+static const uint32 Druid_spells_heal_arr[] =
+{ HEALING_TOUCH_1, LIFEBLOOM_1, NOURISH_1, REGROWTH_1, REJUVENATION_1, SWIFTMEND_1, TRANQUILITY_1, WILD_GROWTH_1 };
+
+static const uint32 Druid_spells_support_arr[] =
+{ ABOLISH_POISON_1, BARKSKIN_1, BERSERK_1, CHALLENGING_ROAR_1, COWER_1, CURE_POISON_1, DASH_1, ENRAGE_1,
+FAERIE_FIRE_NORMAL_1, FAERIE_FIRE_FERAL_1, FERAL_CHARGE_BEAR_1, FERAL_CHARGE_CAT_1, FRENZIED_REGENERATION_1,
+GROWL_1, INNERVATE_1, MARK_OF_THE_WILD_1, NATURES_GRASP_1, NATURES_SWIFTNESS_1, PROWL_1, REMOVE_CURSE_1,
+REBIRTH_1, REVIVE_1, SAVAGE_ROAR_1, SURVIVAL_INSTINCTS_1, THORNS_1, TIGERS_FURY_1 };
+
+static const std::vector<uint32> Druid_spells_damage(FROM_ARRAY(Druid_spells_damage_arr));
+static const std::vector<uint32> Druid_spells_cc(FROM_ARRAY(Druid_spells_cc_arr));
+static const std::vector<uint32> Druid_spells_heal(FROM_ARRAY(Druid_spells_heal_arr));
+static const std::vector<uint32> Druid_spells_support(FROM_ARRAY(Druid_spells_support_arr));
+
+static float rageLossMult;
+
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new bot_druid_ai(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct bot_druid_ai : public bot_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_DRUID;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { removeShapeshiftForm(); UnsummonAll(); bot_ai::JustDied(u); }
+
+        uint8 GetBotStance() const override
+        {
+            return _form;
+        }
+
+        bool removeShapeshiftForm() override
+        {
+            BotStances myform = _form;
+            _form = BOT_STANCE_NONE;
+            //ShapeshiftForm form = me->GetShapeshiftForm();
+            //if (form != FORM_NONE)
+            {
+                switch (myform/*form*/)
+                {
+                    //case FORM_DIREBEAR:
+                    //case FORM_BEAR:
+                    case DRUID_BEAR_FORM:
+                        if (IsRegenActive())
+                            return false;
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_BEAR_BUFF);
+                        me->RemoveAurasDueToSpell(NATURAL_REACTION);
+                        me->RemoveAurasDueToSpell(SURVIVAL_OF_THE_FITTEST_BUFF);
+                        me->RemoveAurasDueToSpell(SAVAGE_DEFENSE_PASSIVE);
+                        break;
+                    //case FORM_CAT:
+                    case DRUID_CAT_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(FERAL_SWIFTNESS);
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_CAT_BUFF);
+                        me->RemoveAurasDueToSpell(NURTURING_INSTINCT_BUFF);
+                        me->RemoveAurasDueToSpell(PREDATORY_INSTINCTS);
+                        break;
+                    //case FORM_MOONKIN:
+                    case DRUID_MOONKIN_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(MOONKIN_FORM_1));
+                        me->RemoveAurasDueToSpell(GetSpell(OWLKIN_FRENZY));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_MOONKIN_BUFF);
+                        break;
+                    //case FORM_TREE:
+                    case DRUID_TREE_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(TREE_OF_LIFE_FORM_1));
+                        me->RemoveAurasDueToSpell(MASTER_SHAPESHIFTER_TREE_BUFF);
+                        break;
+                    //case FORM_TRAVEL:
+                    case DRUID_TRAVEL_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(TRAVEL_FORM_1));
+                        break;
+                    //case FORM_AQUA:
+                    case DRUID_AQUATIC_FORM:
+                        me->RemoveAurasDueToSpell(GetSpell(AQUATIC_FORM_1));
+                        break;
+                    //case FORM_FLIGHT:
+                    //case FORM_FLIGHT_EPIC:
+                    default:
+                        break;
+                }
+
+                if (me->GetPowerType() != POWER_MANA)
+                {
+                    //TC_LOG_ERROR("entities.player", "druid_bot::removeShapeshiftForm(): still has poweType %u!", uint32(me->GetPowerType()));
+                    me->SetPowerType(POWER_MANA);
+                }
+                if (me->GetShapeshiftForm() != FORM_NONE)
+                {
+                    //TC_LOG_ERROR("entities.player", "druid_bot::removeShapeshiftForm(): still speshifted into %u!", uint32(me->GetShapeshiftForm()));
+                    me->RemoveAurasByType(SPELL_AURA_MOD_SHAPESHIFT, me->GetGUID(), nullptr, false);
+                }
+
+                setStats(BOT_STANCE_NONE);
+            }
+            return true;
+        }
+
+        //bool IsMelee() const
+        //{
+        //    return bot_ai::IsMelee() && (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM);
+        //}
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            if (_form == DRUID_BEAR_FORM && HasRole(BOT_ROLE_RANGED) && IsSpellReady(BASH_1, GetLastDiff(), false))
+                return;
+            GetInPosition(force, u);
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!gPlayer || GC_Timer > diff || IAmFree()) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            if (Rand() > 30 + 50 * (me->GetMap()->IsRaid())) return false;
+
+            Group const* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false) && !HasRole(BOT_ROLE_DPS);
+            if (!tranq && !growt) return false;
+
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = nullptr;
+            std::list<Unit*> groupUnits;
+            for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                    continue;
+                if (tPlayer->IsAlive() && me->GetDistance(tPlayer) < 40)
+                {
+                    if (growt)
+                        groupUnits.push_back(tPlayer);
+                    if (tranq && GetHealthPCT(tPlayer) < 80)
+                    {
+                        if (GetHealthPCT(tPlayer) < pct)
+                        {
+                            pct = GetHealthPCT(tPlayer);
+                            healTarget = tPlayer;
+                        }
+                        ++LHPcount;
+                        if (LHPcount > 2) break;
+                    }
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->IsAlive() && bot->GetDistance(me) < 40)
+                        {
+                            if (growt)
+                                groupUnits.push_back(bot);
+                            if (tranq && GetHealthPCT(bot) < 80)
+                            {
+                                if (GetHealthPCT(bot) < pct)
+                                {
+                                    pct = GetHealthPCT(bot);
+                                    healTarget = bot;
+                                }
+                                ++LHPcount;
+                                if (LHPcount > 2) break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+                return true;
+
+            healTarget = nullptr;
+            for (std::list<Unit*>::const_iterator i = groupUnits.begin(); i != groupUnits.end(); ++i)
+            {
+                LHPcount = 0;
+                Unit* gUnit = *i;
+
+                for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap())
+                        continue;
+                    if (tPlayer->IsAlive() && !tPlayer->isPossessed() && !tPlayer->IsCharmed() &&
+                        gUnit->GetDistance(tPlayer) < 15 && (GetLostHP(tPlayer) > 2000 || GetHealthPCT(tPlayer) < 90))
+                        ++LHPcount;
+
+                    if (tPlayer->HaveBot())
+                    {
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (bot && bot->IsInWorld() && bot->IsAlive())
+                            {
+                                if (gUnit->GetDistance(bot) < 15 && (GetLostHP(bot) > 2000 || GetHealthPCT(bot) < 90))
+                                    ++LHPcount;
+                            }
+                        }
+                    }
+
+                    if (LHPcount >= 3)
+                        break;
+                }
+
+                if (LHPcount >= 3)
+                {
+                    healTarget = gUnit;
+                    break;
+                }
+            }
+
+            if (LHPcount >= 3 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+                return true;
+
+            return false;
+        }
+
+        //Powers
+        //rage
+        void getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(MAUL_1)))
+                rage = std::max<int32>(rage - 150, 0);
+        }
+
+        //energy
+        void getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+        }
+
+        //all
+        int32 acost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        bool IsRegenActive() const
+        {
+            return me->IsAlive() && me->IsInCombat() && rage > 100 && GetHealthPCT(me) < 90 &&
+                me->GetAuraEffect(SPELL_AURA_PERIODIC_DUMMY, SPELLFAMILY_DRUID, 0x0, 0x40000000, 0x0);
+        }
+
+        void CheckBarkskin(uint32 diff)
+        {
+            if (!me->IsAlive())
+                return;
+            if (me->GetVehicle())
+                return;
+            //No GCD
+            if (IsSpellReady(BARKSKIN_1, diff, false) && !IsCasting() && !me->getAttackers().empty() &&
+                Rand() < (25 + 20 * me->getAttackers().size()) &&
+                GetHealthPCT(me) < (IsTank() ? 67 : 70 + 25 * me->getAttackers().size()))
+            {
+                if (doCast(me, GetSpell(BARKSKIN_1)))
+                {}
+            }
+        }
+
+        void CheckHibery(uint32 diff)
+        {
+            if (hiberyCheckTimer <= diff)
+            {
+                hibery = FindAffectedTarget(GetSpell(HIBERNATE_1), me->GetGUID());
+                hiberyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHibernate(uint32 diff)
+        {
+            if (!(_form == DRUID_MOONKIN_FORM || _form == BOT_STANCE_NONE))
+                return;
+            //Skip Tranquility, Hurricane
+            if (GC_Timer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            if (hibery == false && IsSpellReady(HIBERNATE_1, diff))
+            {
+                if (Unit* target = FindStunTarget(30))
+                {
+                    if (doCast(target, GetSpell(HIBERNATE_1)))
+                        return;
+                }
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!(_form == DRUID_MOONKIN_FORM || _form == BOT_STANCE_NONE))
+                return;
+            //Skip Tranquility, Hurricane
+            if (GC_Timer > diff || Rand() > 35 || IsChanneling() || (HasRole(BOT_ROLE_HEAL) && IsCasting()))
+                return;
+
+            if (IsSpellReady(CYCLONE_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(20, 0, CYCLONE_1))
+                {
+                    bool cast = false;
+                    for (uint8 i = CURRENT_GENERIC_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    {
+                        Spell const* spell = target->GetCurrentSpell(CurrentSpellTypes(i));
+                        if (spell && spell->GetTimer() > 1500 &&
+                            (IAmFree() ? (spell->m_targets.GetUnitTarget() == me) : (master->GetGroup() && master->GetGroup()->IsMember(spell->m_targets.GetObjectTargetGUID()))))
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                    if (cast)
+                    {
+                        me->InterruptNonMeleeSpells(false);
+                        if (doCast(target, GetSpell(CYCLONE_1)))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (me->GetPowerType() == POWER_RAGE && me->IsAlive())
+            {
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat() &&
+                        !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x00080000)
+                    /*!HasAuraName(me, ENRAGE_1)*/)
+                    {
+                        if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                }
+                getrage();
+            }
+            else if (me->GetPowerType() == POWER_ENERGY)
+                getenergy();
+
+            CheckHibery(diff);
+            CheckBarkskin(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (me->GetPowerType() == POWER_MANA && GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 35)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (me->IsInCombat())
+                CheckBattleRez(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (HasRole(BOT_ROLE_RANGED) || !me->IsInCombat() || !me->GetVictim() ||
+                (_form != DRUID_BEAR_FORM && (_form != DRUID_CAT_FORM || !me->GetMap()->IsRaid())))
+                BuffAndHealGroup(diff);
+            if (_form != DRUID_BEAR_FORM && _form != DRUID_CAT_FORM)
+            {
+                CureGroup(GetSpell(CURE_POISON_1), diff);
+                CureGroup(GetSpell(REMOVE_CURSE_1), diff);
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            CheckTravelForm(diff);
+
+            if (!CheckAttackTarget())
+            {
+                if (!me->IsInCombat() && Rand() < 5 && me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+                    me->RemoveAurasDueToSpell(PROWL_1);
+                return;
+            }
+
+            CheckHibernate(diff);
+            Counter(diff);
+
+            if (IsCasting())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, bot_ai::IsMelee());
+
+            //NOT all forms abilities (prioritized)
+            //Cat Instaheal
+            if (_form == DRUID_CAT_FORM && GC_Timer <= diff && Rand() < 60 &&
+                HasRole(BOT_ROLE_HEAL) && GetHealthPCT(me) < 45 &&
+                (me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x80000, 0x0) ||/*me->HasAura(PREDATORS_SWIFTNESS_BUFF)*/
+                (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && doCast(me, GetSpell(NATURES_SWIFTNESS_1)))))
+            {
+                //TODO maybe istant spells if clearcast?
+                //heal myself with instant
+                //Healing Touch has same reqs
+                if ((GetSpell(REGROWTH_1) && !me->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0x0, 0x0) &&
+                    doCast(me, GetSpell(REGROWTH_1))) || doCast(me, GetSpell(HEALING_TOUCH_1)))
+                {
+                    Position pos;
+                    mytar->GetNearPoint(me, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 15.f, mytar->GetAbsoluteAngle(me));
+                    GetInPosition(true, mytar, &pos);
+                    return;
+                }
+            }
+            //Roots
+            if (_form != DRUID_BEAR_FORM && _form != DRUID_TREE_FORM && Rand() < 35 &&
+                (HasRole(BOT_ROLE_DPS) || IAmFree()) && IsSpellReady(ENTANGLING_ROOTS_1, diff) &&
+                (_form != DRUID_CAT_FORM || IAmFree() || me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x80000, 0x0)
+                /*me->HasAura(PREDATORS_SWIFTNESS_BUFF)*/))
+                CheckRoots();
+
+            //ALL forms abilities
+            //Nature's Grasp (no shapeshift)
+            if (IsSpellReady(NATURES_GRASP_1, diff) && HasRole(BOT_ROLE_DPS) && HasRole(BOT_ROLE_RANGED) && Rand() < 70 &&
+                !me->getAttackers().empty())
+            {
+                if (doCast(me, GetSpell(NATURES_GRASP_1)))
+                    return;
+            }
+            //Survival Instincts
+            //No GCD, bear is lvl 10, SI is lvl 20
+            //Shapeshift into bear if needed
+            if (IsSpellReady(SURVIVAL_INSTINCTS_1, diff, false) && Rand() < 75 &&
+                (GetHealthPCT(me) < (30 + 20 * (me->getAttackers().size() > 1))) &&
+                (_form == DRUID_BEAR_FORM || (GC_Timer <= diff && doCast(me, GetSpell(BEAR_FORM_1)))))
+            {
+                if (doCast(me, SURVIVAL_INSTINCTS_1))
+                    if (!IAmFree())
+                        ReportSpellCast(SURVIVAL_INSTINCTS_1, LocalizedNpcText(master, BOT_TEXT__USED), master);
+            }
+            //Bash
+            //Assuming Furor is present which is lvl 10
+            //Shapeshift into bear if needed
+            //bear is lvl 10, bash is lvl 14
+            //Retreat is triggered only if hit (SpellHitTarget)
+            if (IsSpellReady(BASH_1, diff) && !CCed(mytar, !mytar->IsNonMeleeSpellCast(false,false,true)) &&
+                mytar->IsWithinMeleeRange(me))
+            {
+                if (_form == DRUID_BEAR_FORM && rage >= acost(BASH_1))
+                {
+                    if (doCast(mytar, GetSpell(BASH_1)))
+                        return;
+                }
+                else if (_form != DRUID_BEAR_FORM && mytar->GetVictim() == me && Rand() < 25)
+                {
+                    if (doCast(me, GetSpell(BEAR_FORM_1)))
+                        return;
+                }
+            }
+
+            //Main mode
+            //Choose form. Mode should be selected considering bot_ai::CheckAttackTarget() positioning selection
+            //1 Tanking mode
+            if (IsTank() && GetSpell(BEAR_FORM_1))
+            {
+                if (_form == DRUID_BEAR_FORM ||
+                    (GC_Timer <= diff && doCast(me, GetSpell(BEAR_FORM_1))))
+                    doBearActions(mytar, diff);
+            }
+            //2 Melee (tanking cat impossible: cat lvl 20, bear lvl 10)
+            else if (bot_ai::IsMelee())
+            {
+                //if lvl < 20 then bot gonna just melee its targets
+                if (_form == DRUID_CAT_FORM ||
+                    (IsSpellReady(CAT_FORM_1, diff) && doCast(me, GetSpell(CAT_FORM_1))))
+                    doCatActions(mytar, diff);
+            }
+            //3 Ranged dps
+            else if (HasRole(BOT_ROLE_DPS))
+            {
+                //pure dps goes moonkin
+                if (_form == DRUID_MOONKIN_FORM ||
+                    ((!GetSpell(MOONKIN_FORM_1) || HasRole(BOT_ROLE_HEAL)) && GC_Timer <= diff && removeShapeshiftForm()) ||
+                    HasRole(BOT_ROLE_HEAL) ||
+                    (IsSpellReady(MOONKIN_FORM_1, diff) && doCast(me, GetSpell(MOONKIN_FORM_1))))
+                    doBalanceActions(mytar, diff);
+            }
+            //4 Healer
+            else if (HasRole(BOT_ROLE_HEAL))
+            {
+                //pure healer goes tree
+                if (_form == DRUID_TREE_FORM ||
+                    ((!GetSpell(TREE_OF_LIFE_FORM_1) || HasRole(BOT_ROLE_DPS)) && GC_Timer <= diff && removeShapeshiftForm()) ||
+                    HasRole(BOT_ROLE_DPS) ||
+                    (IsSpellReady(TREE_OF_LIFE_FORM_1, diff) && doCast(me, GetSpell(TREE_OF_LIFE_FORM_1))))
+                {/*do nothing*/} //not a mistake
+            }
+        }
+
+        void doBearActions(Unit* mytar, uint32 diff)
+        {
+            //debug
+            if (me->GetPowerType() != POWER_RAGE || (me->GetShapeshiftForm() != FORM_BEAR && me->GetShapeshiftForm() != FORM_DIREBEAR))
+                return;
+
+            //Enrage
+            if (IsSpellReady(ENRAGE_1, diff, false) && me->IsInCombat() && (rage < 400 || IsTank()) && Rand() < 40)
+            {
+                if (doCast(me, GetSpell(ENRAGE_1)))
+                    getrage();
+            }
+            //Frenzied Regeneration
+            if (IsSpellReady(FRENZIED_REGENERATION_1, diff) && rage > 700 && GetHealthPCT(me) < 70 && Rand() < 40)
+            {
+                if (doCast(me, GetSpell(FRENZIED_REGENERATION_1)))
+                    return;
+            }
+
+            float dist = me->GetDistance(mytar);
+            //GROWL //No GCD
+            Unit* u = mytar->GetVictim();
+            if (IsSpellReady(GROWL_1, diff, false) && u && u != me && Rand() < 40 && dist < 30 &&
+                mytar->GetTypeId() == TYPEID_UNIT && !mytar->IsControlledByPlayer() &&
+                !CCed(mytar) && !mytar->HasAuraType(SPELL_AURA_MOD_TAUNT) && IsInBotParty(u) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80) || IsTank()))
+            {
+                if (doCast(mytar, GetSpell(GROWL_1)))
+                    return;
+            }
+            //GROWL 2 (distant)
+            if (IsSpellReady(GROWL_1, diff, false) && !IAmFree() && u == me &&  Rand() < 20 &&IsTank() &&
+                (IsOffTank() || master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK_OFF) == 0) &&
+                !(me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())))
+            {
+                if (Unit* tUnit = FindDistantTauntTarget())
+                {
+                    if (doCast(tUnit, GetSpell(GROWL_1)))
+                        return;
+                }
+            }
+            //Challenging Roar
+            if (IsSpellReady(CHALLENGING_ROAR_1, diff) &&
+                !(u == me && me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())) &&
+                rage >= acost(CHALLENGING_ROAR_1))
+            {
+                u = mytar->GetVictim();
+                if (u && u != me && !IsTank(u) && IsInBotParty(u) && !CCed(mytar) && dist <= 10 && Rand() < 25 &&
+                    (!IsTankingClass(u->GetClass()) || IsTank()))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_ROAR_1)))
+                        return;
+                }
+                if (IsTank() && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f, 1);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(me, GetSpell(CHALLENGING_ROAR_1)))
+                        return;
+                }
+            }
+
+            if (!CanAffectVictimAny(mytar, SPELL_SCHOOL_NORMAL))
+                return;
+
+            //Feral Charge
+            if (IsSpellReady(FERAL_CHARGE_BEAR_1, diff, false) && rage >= acost(FERAL_CHARGE_BEAR_1) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !CCed(mytar, true) && dist > 9 && dist < 25)
+            {
+                if (doCast(mytar, GetSpell(FERAL_CHARGE_BEAR_1)))
+                    return;
+            }
+
+            //Faerie Fire (Feral, Bear)
+            if (IsSpellReady(FAERIE_FIRE_FERAL_1, diff) && me->IsInCombat() && Rand() < 35 && dist < CalcSpellMaxRange(FAERIE_FIRE_FERAL_1) &&
+                !mytar->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400))
+            {
+                if (doCast(mytar, GetSpell(FAERIE_FIRE_FERAL_1)))
+                    return;
+            }
+
+            //range check (melee) to prevent fake casts
+            if (dist > 5) return;
+
+            //Berserk (Bear)
+            if (IsSpellReady(BERSERK_1, diff) && !HasRole(BOT_ROLE_HEAL) && rage > 400 && Rand() < 40 &&
+                me->getAttackers().size() > 2)
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+
+            //BOT_ROLE_DPS is checked in Attack(uin32)
+            //if (!HasRole(BOT_ROLE_DPS)) return;
+
+            //frenzied regeneration check
+            //we don't need to spend too much rage if regening
+            bool isRegenActive = IsRegenActive();
+
+            //Mangle (Bear)
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && rage >= acost(MANGLE_BEAR_1) + 200*isRegenActive)
+            {
+                if (me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40) ||
+                    (Rand() < 30 && !mytar->GetAuraEffect(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT, SPELLFAMILY_DRUID, 0x0, 0x40, 0x0)))
+                {
+                    if (doCast(mytar, GetSpell(MANGLE_BEAR_1)))
+                        return;
+                }
+            }
+            //Swipe (Bear)
+            if (IsSpellReady(SWIPE_BEAR_1, diff) && rage >= acost(SWIPE_BEAR_1) + 200*isRegenActive &&
+                IsTank() && Rand() < 70)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 5);
+                if (targets.size() > 2)
+                    if (doCast(mytar, GetSpell(SWIPE_BEAR_1)))
+                        return;
+            }
+            //Lacerate
+            if (IsSpellReady(LACERATE_1, diff) && rage >= acost(LACERATE_1) + 200*isRegenActive &&
+                mytar->GetHealth() > me->GetMaxHealth() * 2 && Rand() < 45)
+            {
+                bool cast = rage >= 600;
+                if (!cast)
+                {
+                    AuraApplication const* lacera = mytar->GetAuraApplicationOfRankedSpell(LACERATE_1);
+                    cast = (!lacera || lacera->GetBase()->GetStackAmount() < 5 || lacera->GetBase()->GetDuration() < 6000);
+                }
+
+                if (cast && doCast(mytar, GetSpell(LACERATE_1)))
+                    return;
+            }
+
+            //skip if maul is active
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //Maul //No GCD
+            if (IsSpellReady(MAUL_1, diff, false) && rage >= acost(MAUL_1) + 200 + 200*isRegenActive)
+            {
+                if (doCast(mytar, GetSpell(MAUL_1)))
+                    return;
+            }
+        }
+
+        void doCatActions(Unit* mytar, uint32 diff)
+        {
+            //debug
+            if (me->GetPowerType() != POWER_ENERGY || me->GetShapeshiftForm() != FORM_CAT)
+                return;
+
+            //Prowl (for Cooldown handling see bot_ai::ReleaseSpellCooldown)
+            if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && Rand() < 50 && me->GetDistance(mytar) < 28)
+            {
+                if (doCast(me, GetSpell(PROWL_1)))
+                {}
+            }
+
+            if (!CanAffectVictimAny(mytar, SPELL_SCHOOL_NORMAL))
+                return;
+
+            //Faerie Fire (Feral, Cat)
+            if (IsSpellReady(FAERIE_FIRE_FERAL_1, diff) && me->IsInCombat() && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                Rand() < 35 && me->GetDistance(mytar) < 30 &&
+                !mytar->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400))
+            {
+                if (doCast(mytar, GetSpell(FAERIE_FIRE_FERAL_1)))
+                    return;
+            }
+
+            if (!JumpingOrFalling() && !CCed(me, true))
+            {
+                //leap here
+                //Feral Charge (Cat)
+                if (IsSpellReady(FERAL_CHARGE_CAT_1, diff, false) && energy >= acost(FERAL_CHARGE_CAT_1) && !me->GetMap()->IsDungeon() &&
+                    !HasBotCommandState(BOT_COMMAND_STAY) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && Rand() < 65 &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_DRUID, 0x0, 0x0, 0x8) &&//not dashing
+                    me->GetDistance(mytar) > 10 && me->GetDistance(mytar) < 25)
+                {
+                    if (doCast(mytar, GetSpell(FERAL_CHARGE_CAT_1)))
+                        return; //no gcd but jump time
+                }
+
+                //Dash (no GCD)
+                if (IsSpellReady(DASH_1, diff, false) &&
+                    (me->HasAuraType(SPELL_AURA_MOD_STEALTH) || (me->IsInCombat() && !IsSpellReady(FERAL_CHARGE_CAT_1, diff, false))) &&
+                    Rand() < 85 && me->GetDistance(mytar) > 15)
+                {
+                    if (doCast(me, GetSpell(DASH_1)))
+                    {}
+                }
+                //Savage Roar
+                if (IsSpellReady(SAVAGE_ROAR_1, diff) && comboPoints >= 1 && (me->IsInCombat() || mytar->IsInCombat()) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && energy >= acost(SAVAGE_ROAR_1) &&
+                    !me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_DRUID, 0, 0x10000000, 0))
+                {
+                    if (doCast(mytar, GetSpell(SAVAGE_ROAR_1)))
+                        return;
+                }
+            }
+
+            MoveBehind(mytar);
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(mytar) > 5)
+                return;
+
+            //Cower
+            if (mytar->CanHaveThreatList())
+            {
+                if (IsSpellReady(COWER_1, diff) && mytar->GetVictim() == me && energy >= acost(COWER_1) &&
+                    int32(mytar->GetThreatManager().GetThreatListSize()) > 1 &&
+                    int32(mytar->getAttackers().size()) > 1 && Rand() < 45)
+                {
+                    if (doCast(mytar, GetSpell(COWER_1)))
+                        return;
+                }
+            }
+            //Tiger's Fury (no GCD) cannot use while Berserk is active
+            if (IsSpellReady(TIGERS_FURY_1, diff, false) && mytar->GetHealth() > me->GetHealth() / 4 &&
+                (me->GetLevel() < 55 || energy <= 40) && Rand() < 40 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+            {
+                if (doCast(me, GetSpell(TIGERS_FURY_1)))
+                    getenergy();
+            }
+            //Berserk can be used After Tiger's Fury without dispelling it
+            //Berserk (Cat)
+            if (IsSpellReady(BERSERK_1, diff) && !HasRole(BOT_ROLE_HEAL) && (!me->HasAuraType(SPELL_AURA_MOD_STEALTH) || energy >= 40) && Rand() < 50 &&
+                (mytar->GetTypeId() == TYPEID_PLAYER || mytar->GetHealth() + 5000 > me->GetHealth()))
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+
+            //Openers
+            if (me->HasAuraType(SPELL_AURA_MOD_STEALTH))
+            {
+                uint32 opener =
+                    GetSpell(POUNCE_1) &&
+                    !mytar->HasAuraType(SPELL_AURA_MOD_STUN) &&
+                    mytar->GetDiminishing(DIMINISHING_OPENING_STUN) < DIMINISHING_LEVEL_3 &&
+                    (mytar->GetTypeId() == TYPEID_PLAYER || (!IAmFree() && master->GetNpcBotsCount() > 1)) ? POUNCE_1 :
+                    GetSpell(RAVAGE_1) ? RAVAGE_1 :
+                    GetSpell(SHRED_1) ? SHRED_1 : 0;
+
+                //all opener spells disabled
+                if (!opener)
+                {
+                    me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                    return;
+                }
+
+                if (opener != POUNCE_1 && mytar->HasInArc(float(M_PI), me))
+                    return;
+
+                //We do not check combo points amount
+                if (IsSpellReady(opener, diff) && energy >= acost(opener))
+                {
+                    if (doCast(mytar, GetSpell(opener)))
+                        return;
+                }
+
+                return;
+            }
+
+            //Finishers
+            if (comboPoints > 0)
+            {
+                //Maim
+                if (IsSpellReady(MAIM_1, diff) && !CCed(mytar) && energy >= acost(MAIM_1) &&
+                    (comboPoints >= 4 || mytar->IsNonMeleeSpellCast(false,false,true)))
+                {
+                    if (doCast(mytar, GetSpell(MAIM_1)))
+                        return;
+                }
+                //Ferocious Bite
+                if (IsSpellReady(FEROCIOUS_BITE_1, diff) && (comboPoints >= 4 || mytar->GetHealth() < me->GetMaxHealth() / 4) &&
+                    energy >= acost(FEROCIOUS_BITE_1) && Rand() < (50 + comboPoints * 20))
+                {
+                    if (doCast(mytar, GetSpell(FEROCIOUS_BITE_1)))
+                        return;
+                }
+                //Rip
+                if (IsSpellReady(RIP_1, diff) && (comboPoints < 4 || !GetSpell(FEROCIOUS_BITE_1)) &&
+                    energy >= acost(RIP_1) && mytar->GetHealth() > me->GetMaxHealth() / 4 &&
+                    Rand() < (50 + 40 * (mytar->GetTypeId() == TYPEID_PLAYER && IsMeleeClass(mytar->GetClass()))) &&
+                    !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x800000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (doCast(mytar, GetSpell(RIP_1)))
+                        return;
+                }
+            }
+
+            //Combo points generating
+            //Swipe (Cat)
+            if (IsSpellReady(SWIPE_CAT_1, diff) && me->getAttackers().empty() && energy >= acost(SWIPE_CAT_1) && Rand() < (35 + 100 * (me->GetMap()->IsDungeon())))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 5);
+                if (targets.size() > 2)
+                    if (doCast(mytar, GetSpell(SWIPE_CAT_1)))
+                        return;
+            }
+            //Shred
+            if (IsSpellReady(SHRED_1, diff) && comboPoints < 4 && energy >= acost(SHRED_1) && Rand() < 85 &&
+                !mytar->HasInArc(float(M_PI), me))
+            {
+                if (doCast(mytar, GetSpell(SHRED_1)))
+                    return;
+            }
+            //Mangle (Cat)
+            if (IsSpellReady(MANGLE_CAT_1, diff) && comboPoints < 5 && energy >= acost(MANGLE_CAT_1) &&
+                (Rand() < 20 || !mytar->GetAuraEffect(SPELL_AURA_MOD_MECHANIC_DAMAGE_TAKEN_PERCENT, SPELLFAMILY_DRUID, 0x0, 0x400, 0x0)))
+            {
+                if (doCast(mytar, GetSpell(MANGLE_CAT_1)))
+                    return;
+            }
+            //Rake
+            if (IsSpellReady(RAKE_1, diff) && comboPoints < 3 && energy >= acost(RAKE_1) && Rand() < 60 &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x1000, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(RAKE_1)))
+                    return;
+            }
+            //Claw
+            if (IsSpellReady(CLAW_1, diff) && comboPoints < 5 && Rand() < 50 && (!GetSpell(SHRED_1) || mytar->HasInArc(float(M_PI), me)) &&
+                energy >= acost(CLAW_1))
+            {
+                if (doCast(mytar, GetSpell(CLAW_1)))
+                    return;
+            }
+        }
+
+        void doBalanceActions(Unit* mytar, uint32 diff)
+        {
+            //debug
+            if (me->GetPowerType() != POWER_MANA)
+                return;
+
+            MoveBehind(mytar);
+
+            if (HasRole(BOT_ROLE_HEAL) && GetManaPCT(me) < 25)
+                return;
+
+            //BOT_ROLE_DPS is checked in Attack(uint32)
+
+            float dist = me->GetDistance(mytar);
+            if (dist > CalcSpellMaxRange(WRATH_1))
+                return;
+
+            auto [can_do_nature, can_do_arcane] = CanAffectVictimBools(mytar, SPELL_SCHOOL_NATURE, SPELL_SCHOOL_ARCANE);
+            if (!can_do_nature && !can_do_arcane)
+                return;
+
+            //spell reflections
+            if (IsSpellReady(FAERIE_FIRE_NORMAL_1, diff) && can_do_nature && CanRemoveReflectSpells(mytar, FAERIE_FIRE_NORMAL_1) &&
+                doCast(mytar, FAERIE_FIRE_NORMAL_1))
+                return;
+
+            //Starfall
+            if (IsSpellReady(STARFALL_1, diff) && Rand() < 40)
+            {
+                bool cast = (mytar->GetTypeId() == TYPEID_PLAYER || me->getAttackers().size() > 1);
+                if (!cast)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 30.f, 0);
+                    if (targets.size() > 3)
+                        cast = true;
+                }
+
+                if (cast && doCast(me, GetSpell(STARFALL_1)))
+                    return;
+
+                SetSpellCooldown(STARFALL_1, 1500); //fail
+            }
+            //Hurricane
+            if (IsSpellReady(HURRICANE_1, diff) && !JumpingOrFalling() && Rand() < 50)
+            {
+                if (Unit* target = FindAOETarget(CalcSpellMaxRange(HURRICANE_1)))
+                {
+                    if (doCast(target, GetSpell(HURRICANE_1)))
+                        return;
+                }
+                SetSpellCooldown(HURRICANE_1, 1000); //fail
+            }
+            //Typhoon
+            if (IsSpellReady(TYPHOON_1, diff) && Rand() < 75)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 25);
+                if (targets.size() > 2)
+                    if (doCast(me, GetSpell(TYPHOON_1)))
+                        return;
+
+                SetSpellCooldown(TYPHOON_1, 1000); //fail
+            }
+
+            if (IsSpellReady(FORCE_OF_NATURE_1, diff))
+            {
+                SummonBotPet(mytar);
+                SetSpellCooldown(FORCE_OF_NATURE_1, 180000);
+                return;
+            }
+
+            //Faerie Fire (non-feral): moonkin or non-shapeshifted
+            if (IsSpellReady(FAERIE_FIRE_NORMAL_1, diff) && can_do_nature && mytar->getAttackers().size() > 2 && Rand() < 50 &&
+                dist < CalcSpellMaxRange(FAERIE_FIRE_NORMAL_1) &&
+                !mytar->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_DRUID, 0x400)
+                /*!HasAuraName(mytar, FAERIE_FIRE_ANY)*/)
+            {
+                if (doCast(mytar, GetSpell(FAERIE_FIRE_NORMAL_1)))
+                    return;
+            }
+
+            Unit const* u = mytar->GetVictim();
+            //Insect Swarm
+            if (IsSpellReady(INSECT_SWARM_1, diff) && can_do_nature && u && mytar->GetDistance(u) < 8 && Rand() < 30 &&
+                dist < CalcSpellMaxRange(INSECT_SWARM_1) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x200000, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(mytar, INSECT_SWARM_1, me->GetGUID())*/)
+            {
+                if (doCast(mytar, GetSpell(INSECT_SWARM_1)))
+                    return;
+            }
+
+            if (IsSpellReady(MOONFIRE_1, diff) && can_do_arcane && Rand() < 60 && dist < CalcSpellMaxRange(MOONFIRE_1) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DRUID, 0x2, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(mytar, MOONFIRE_1, me->GetGUID())*/)
+            {
+                if (doCast(mytar, GetSpell(MOONFIRE_1)))
+                    return;
+            }
+            //TODO: balance starfire/wrath frequency based on mana effeciency
+            if (IsSpellReady(STARFIRE_1, diff) && can_do_arcane && dist < CalcSpellMaxRange(STARFIRE_1))
+            {
+                AuraEffect const* eclipeLunar = me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_DRUID, 0x0, 0x0, 0x4000);
+                int32 rand = 30 + 100 * (eclipeLunar && eclipeLunar->GetBase()->GetDuration() > 3000);
+
+                if (Rand() < rand && doCast(mytar, GetSpell(STARFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(WRATH_1, diff) && can_do_nature)
+            {
+                if (doCast(mytar, GetSpell(WRATH_1)))
+                    return;
+            }
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (GC_Timer <= diff && Rand() < 35 && GetManaPCT(me) > 15 &&
+                (me->IsPolymorphed() || me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                uint32 sshift;
+                switch (_form)
+                {
+                    case DRUID_BEAR_FORM:
+                        sshift = IsTank() && !me->getAttackers().empty() &&
+                            (!me->GetVictim() || me->GetDistance(me->GetVictim()) < 5) ? 0 :
+                            GetSpell(BEAR_FORM_1); break;
+                    case DRUID_CAT_FORM:     sshift = GetSpell(CAT_FORM_1);         break;
+                    case DRUID_MOONKIN_FORM: sshift = GetSpell(MOONKIN_FORM_1);     break;
+                    case DRUID_TREE_FORM:    sshift = GetSpell(TREE_OF_LIFE_FORM_1);break;
+                    //case DRUID_FLIGHT_FORM:  sshift = GetSpell(FLIGHT_FORM_1);      break;
+                    case DRUID_TRAVEL_FORM:  sshift = GetSpell(TRAVEL_FORM_1);      break;
+                    case DRUID_AQUATIC_FORM: sshift = GetSpell(AQUATIC_FORM_1);     break;
+                    case BOT_STANCE_NONE:    sshift = GetSpell(TRAVEL_FORM_1);      break;
+                    default:                 sshift = 0;                            break;
+                }
+                if (sshift && doCast(me, sshift))
+                {
+                    GetInPosition(false, nullptr);
+                    return;
+                }
+            }
+            if (IsSpellReady(BERSERK_1, diff) && Rand() < 10 && me->HasAuraWithMechanic(1<<MECHANIC_FEAR))
+            {
+                if (doCast(me, GetSpell(BERSERK_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            bool pointed = IsPointedHealTarget(target);
+            if (hp > 95 && !(pointed && me->GetMap()->IsRaid()) &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * 2;
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * 2;
+            if (xppct >= 95 && hp >= 25 && !pointed)
+                return false;
+
+            if (IsTank() && xppct > 25)
+                return false;
+            if (hp > 50 && !IsTank(target) && (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM))
+                return false; //do not waste heal if in feral or so
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && Rand() < 80 &&
+                (me->IsInCombat() || target->IsInCombat()) &&//may just revive
+                hp <= 20 && xppct <= 0 && xphploss > _heals[HEALING_TOUCH_1] / 2 &&
+                (target->GetTypeId() == TYPEID_PLAYER || IsTank(target) || target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)))
+                {
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        return true;
+                }
+            }
+            if (IsSpellReady(NOURISH_1, diff) && xppct <= 65 && xphploss > _heals[REJUVENATION_1])
+            {
+                static uint8 minHots = 2;
+                uint8 hots = 0;
+                Unit::AuraEffectList const& effectList = target->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+                for (Unit::AuraEffectList::const_iterator itr = effectList.begin(); itr != effectList.end(); ++itr)
+                {
+                    AuraEffect const* eff = *itr;
+                    if (eff->GetCasterGUID() != me->GetGUID())
+                        continue;
+                    SpellInfo const* spellInfo = eff->GetSpellInfo();
+                    if (spellInfo->SpellFamilyName != SPELLFAMILY_DRUID)
+                        continue;
+                    //rejuv,regro,lifeb,wildg
+                    if (!((spellInfo->SpellFamilyFlags[0] & 0x50) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                        continue;
+                    hots += eff->GetBase()->GetStackAmount();
+                    if (hots >= minHots)
+                        break;
+                }
+                if (hots >= minHots && doCast(target, GetSpell(NOURISH_1)))
+                    return true;
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false) && !HasRole(BOT_ROLE_DPS|BOT_ROLE_TANK) && hp < 60 &&
+                (xppct <= 15 || int32(GetLostHP(target)) > _heals[REJUVENATION_1]) &&
+                //rejuv,regro
+                target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x50, 0x0, 0x0, me->GetGUID())
+                /*(HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1))*/)
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                    return true;
+            }
+            //maintain HoTs
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+            if (IsSpellReady(REGROWTH_1, diff) && Rand() < 80 && (tanking || xphploss > _heals[REGROWTH_1]) &&
+                (xppct <= 45 || !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x40, 0x0, 0x0, me->GetGUID()))
+                /*!HasAuraName(target, REGROWTH_1, me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                    return true;
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) && xppct >= 40 && hp < 75 + 10 * tanking)
+            {
+                AuraEffect const* bloom = target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x0, 0x10, 0x0, me->GetGUID());
+                //Aura const* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetBase()->GetStackAmount() < 3 ||
+                    (bloom->GetBase()->GetDuration() < 2000 && !target->getAttackers().empty())) &&
+                    doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (IsSpellReady(HEALING_TOUCH_1, diff) && (xppct > 15 || !GetSpell(REGROWTH_1)) &&
+                xphploss > _heals[HEALING_TOUCH_1] &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+                return true;
+            if (IsSpellReady(REJUVENATION_1, diff) && xppct > 45 &&
+                (tanking || xphploss > _heals[REJUVENATION_1]) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_DRUID, 0x10, 0x0, 0x0, me->GetGUID())
+                /*!HasAuraName(target, REJUVENATION_1, me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                    return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_DRUID, 0x40000)
+                    /*!HasAuraName(target, MARK_OF_THE_WILD_1)*/)
+                    if (doCast(target, MARK_OF_THE_WILD))
+                        return true;
+            }
+            if (uint32 THORNS = GetSpell(THORNS_1))
+            {
+                if (IsTank(target) &&
+                    !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_DAMAGE_SHIELD, SPELLFAMILY_DRUID, 0x100)
+                    /*!HasAuraName(target, THORNS_1)*/)
+                    if (doCast(target, THORNS))
+                        return true;
+            }
+
+            return false;
+        }
+
+        void CheckTravelForm(uint32 diff)
+        {
+            if (!IsSpellReady(TRAVEL_FORM_1, diff) || !HasBotCommandState(BOT_COMMAND_FOLLOW) || Rand() > 15 || !me->IsInCombat() ||
+                me->GetShapeshiftForm() == FORM_TRAVEL || me->GetVictim() || me->IsMounted() || IAmFree() || IsCasting() ||
+                me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING | MOVEMENTFLAG_FLYING))
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 30))
+            {
+                if (doCast(me, GetSpell(TRAVEL_FORM_1)))
+                    return;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            ResurrectGroup(GetSpell(REVIVE_1));
+
+            if (!IAmFree() && HasBotCommandState(BOT_COMMAND_FOLLOW) && !master->IsMounted() && Rand() < 35)
+            {
+                int32 dist = int32(me->GetDistance(master));
+                if (me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+                {
+                    if (_form != DRUID_AQUATIC_FORM && dist > 30 && GetSpell(AQUATIC_FORM_1) &&
+                        doCast(me, GetSpell(AQUATIC_FORM_1)))
+                        return;
+                }
+                //if (me->HasUnitMovementFlag(MOVEMENTFLAG_FLYING))
+                //{
+                //    if (_form != DRUID_AQUATIC_FORM && dist > 30 && GetSpell(AQUATIC_FORM_1) &&
+                //        doCast(me, GetSpell(AQUATIC_FORM_1)))
+                //        return;
+                //}
+                else if (_form != DRUID_TRAVEL_FORM && dist > 30 && GetSpell(TRAVEL_FORM_1))
+                {
+                    if (doCast(me, GetSpell(TRAVEL_FORM_1)))
+                        return;
+                }
+                else if (_form == DRUID_AQUATIC_FORM)
+                    removeShapeshiftForm();
+            }
+        }
+
+        void doInnervate(uint32 diff)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 25)
+                return;
+            if (_form != BOT_STANCE_NONE && _form != DRUID_MOONKIN_FORM && _form != DRUID_TREE_FORM &&
+                (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            static uint8 minmanaval = 30;
+            Unit* iTarget = nullptr;
+
+            if (master->IsInCombat() && master->GetPowerType() == POWER_MANA &&
+                GetManaPCT(master) < minmanaval && !master->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                iTarget = master;
+            else if (me->IsInCombat() && me->GetPowerType() == POWER_MANA &&
+                GetManaPCT(me) < minmanaval && !me->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                iTarget = me;
+
+            if (!IAmFree())
+            {
+                Group const* group = master->GetGroup();
+                if (!iTarget && !group) //first check master's bots
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Creature* bot = itr->second;
+                        if (!bot || !bot->IsInCombat() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                        if (bot->GetPowerType() != POWER_MANA) continue;
+                        if (bot->GetBotClass() == BOT_CLASS_HUNTER || bot->GetBotClass() == BOT_CLASS_WARLOCK ||
+                            bot->GetBotClass() == BOT_CLASS_SPHYNX || bot->GetBotClass() == BOT_CLASS_SPELLBREAKER ||
+                            bot->GetBotClass() == BOT_CLASS_NECROMANCER) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+                if (!iTarget && group) //cycle through player members...
+                {
+                    for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == nullptr || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || !tPlayer->IsAlive()) continue;
+                        if (tPlayer->GetPowerType() != POWER_MANA) continue;
+                        if (me->GetExactDist(tPlayer) > 30) continue;
+                        if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                        {
+                            iTarget = tPlayer;
+                            break;
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+                if (!iTarget && group) //... and their bots.
+                {
+                    for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* tPlayer = itr->GetSource();
+                        if (tPlayer == nullptr || !tPlayer->HaveBot()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInCombat() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                            if (bot->GetPowerType() != POWER_MANA) continue;
+                            if (bot->GetBotClass() == BOT_CLASS_HUNTER || bot->GetBotClass() == BOT_CLASS_WARLOCK ||
+                                bot->GetBotClass() == BOT_CLASS_SPHYNX || bot->GetBotClass() == BOT_CLASS_SPELLBREAKER ||
+                                bot->GetBotClass() == BOT_CLASS_NECROMANCER) continue;
+                            if (me->GetExactDist(bot) > 30) continue;
+                            if (GetManaPCT(bot) < minmanaval && !bot->GetAuraEffect(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_DRUID, 0x0, 0x1000, 0x0))
+                            {
+                                iTarget = bot;
+                                break;
+                            }
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+            }
+
+            if (iTarget && doCast(iTarget, INNERVATE_1))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    ReportSpellCast(INNERVATE_1, LocalizedNpcText(iTarget->ToPlayer(), BOT_TEXT__ON_YOU), iTarget->ToPlayer());
+
+                if (!IAmFree() && iTarget != master)
+                {
+                    std::string msg = iTarget == me ? LocalizedNpcText(master, BOT_TEXT__ON_MYSELF) : (LocalizedNpcText(master, BOT_TEXT__ON_) + iTarget->GetName() + '!');
+                    ReportSpellCast(INNERVATE_1, msg, master);
+                }
+
+                return;
+            }
+
+            SetSpellCooldown(INNERVATE_1, 1500); //fail
+        }
+
+        void CheckRoots()
+        {
+            if (uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1))
+            {
+                if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60))
+                    return;
+                if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                    if (doCast(target, ENTANGLING_ROOTS))
+                        return;
+            }
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || IAmFree() || me->IsMounted() ||
+                IsTank() || IsCasting() || Rand() > 20) return;
+
+            Group const* gr = master->GetGroup();
+            std::list<Unit*> targets;
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->IsResurrectRequested()) return; //resurrected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30 && !HasBotCommandState(BOT_COMMAND_STAY))
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    BotWhisper(LocalizedNpcText(master, BOT_TEXT_REZZING_YOU));
+                    return;
+                }
+            }
+            else
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    Unit* target = tPlayer;
+                    if (!tPlayer || tPlayer->IsAlive()) continue;
+                    if (tPlayer->IsResurrectRequested()) continue; //resurrected
+                    if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                        target = (Unit*)tPlayer->GetCorpse();
+                    if (!target || !target->IsInWorld()) continue;
+                    if (master->GetMap() != target->FindMap()) continue;
+                    if (me->GetDistance(target) > 100) continue;
+                    targets.push_back(target);
+                }
+            }
+
+            BotMap const* botMap = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = botMap->begin(); itr != botMap->end(); ++itr)
+            {
+                Creature* bot = itr->second;
+                if (bot && bot->IsInWorld() && !bot->IsAlive() && IsTank(bot) && me->GetDistance(bot) < 80)
+                    targets.push_back(bot);
+            }
+
+            if (Unit* targetOrCorpse = !targets.empty() ? Trinity::Containers::SelectRandomContainerElement(targets) : nullptr)
+            {
+                if (me->GetExactDist(targetOrCorpse) > 30 && !HasBotCommandState(BOT_COMMAND_STAY))
+                {
+                    me->GetMotionMaster()->MovePoint(targetOrCorpse->GetMapId(), *targetOrCorpse);
+                    return;
+                }
+                else if (!targetOrCorpse->IsWithinLOSInMap(me))
+                    me->Relocate(*targetOrCorpse);
+
+                if (doCast(targetOrCorpse, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    if (targetOrCorpse->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper(LocalizedNpcText(targetOrCorpse->ToPlayer(), BOT_TEXT_REZZING_YOU), targetOrCorpse->ToPlayer());
+                    if (targetOrCorpse != master)
+                    {
+                        std::string rezstr = LocalizedNpcText(master, BOT_TEXT_REZZING_) + targetOrCorpse->GetName();
+                        if (targetOrCorpse->GetTypeId() == TYPEID_UNIT)
+                            rezstr += " (" + LocalizedNpcText(master, BOT_TEXT_BOT_TANK) + ')';
+                        BotWhisper(rezstr);
+                    }
+                    return;
+                }
+            }
+        }
+
+        void setStats(BotStances form)
+        {
+            _form = form;
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    if (me->GetPowerType() != POWER_RAGE)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_RAGE");
+                        me->SetPowerType(POWER_RAGE);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_BEAR_BUFF, me->GetLevel() >= 20);
+                    if (_spec == BOT_SPEC_DRUID_FERAL)
+                    {
+                        RefreshAura(NATURAL_REACTION, me->GetLevel() >= 35);
+                        RefreshAura(SURVIVAL_OF_THE_FITTEST_BUFF, me->GetLevel() >= 35);
+                        RefreshAura(SAVAGE_DEFENSE_PASSIVE, me->GetLevel() >= 40);
+                    }
+                    break;
+                case DRUID_CAT_FORM:
+                    if (me->GetPowerType() != POWER_ENERGY)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_ENERGY");
+                        me->SetPowerType(POWER_ENERGY);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_CAT_BUFF, me->GetLevel() >= 20);
+                    RefreshAura(FERAL_SWIFTNESS, me->GetLevel() >= 20); //talents ignore forms for creatures so put that here
+                    if (_spec == BOT_SPEC_DRUID_FERAL)
+                    {
+                        RefreshAura(NURTURING_INSTINCT_BUFF, me->GetLevel() >= 30);
+                        RefreshAura(PREDATORY_INSTINCTS, me->GetLevel() >= 45);
+                    }
+                    break;
+                case DRUID_MOONKIN_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (moonkin)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_MOONKIN_BUFF, me->GetLevel() >= 20);
+                    RefreshAura(OWLKIN_FRENZY, me->GetLevel() >= 45);
+                    break;
+                case DRUID_TREE_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (tree)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    RefreshAura(MASTER_SHAPESHIFTER_TREE_BUFF, me->GetLevel() >= 20);
+                    break;
+                case DRUID_TRAVEL_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (travel)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    break;
+                case DRUID_AQUATIC_FORM:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (aquatic)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    break;
+                //case DRUID_FLIGHT_FORM:
+                //    if (me->GetPowerType() != POWER_MANA)
+                //    {
+                //        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (flight)");
+                //        me->SetPowerType(POWER_MANA);
+                //    }
+                //    break;
+                case BOT_STANCE_NONE:
+                    if (me->GetPowerType() != POWER_MANA)
+                    {
+                        //TC_LOG_ERROR("entities.player", "druid_bot::setStats(): has to set powerType to POWER_MANA (deshape)");
+                        me->SetPowerType(POWER_MANA);
+                    }
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "druid_bot::setStats(): NYI form %u", uint32(form));
+                    setStats(BOT_STANCE_NONE);
+                    return;
+            }
+
+            SetShouldUpdateStats();
+            SetStats(false);
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.HitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Primal Fury (white attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 25 && _form == DRUID_BEAR_FORM)
+                    me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+                //Predatory Instincts (part 1): 10% additional crit damage bonus for melee attacks in Cat form
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 45 && _form == DRUID_CAT_FORM)
+                    pctbonus += 0.05f;
+            }
+
+            damageinfo.Damages[0].Damage = uint32(damageinfo.Damages[0].Damage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                ////Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                //if (lvl >= 21)
+                //    pctbonus += 0.25f;
+            }
+
+            //Feral Aggression: 15% bonus damage for Ferocious Bite
+            if (lvl >= 10 && baseId == FEROCIOUS_BITE_1)
+                pctbonus += 0.15f;
+            //Feral Instinct: 30% bonus damage for Swipe (Bear)
+            if (lvl >= 15 && baseId == SWIPE_BEAR_1)
+                pctbonus += 0.3f;
+            //Savage Fury: 20% bonus damage for Claw, Rake, Mangle (Cat), Mangle (Bear) and Maul
+            if (lvl >= 15 &&
+                (baseId == CLAW_1 ||
+                baseId == RAKE_1 ||
+                baseId == MANGLE_CAT_1 ||
+                baseId == MANGLE_BEAR_1 ||
+                baseId == MAUL_1))
+                pctbonus += 0.2f;
+            //Rend and Tear: 20% bonus damage on bleeding targets for Maul and Shred
+            if ((_spec == BOT_SPEC_DRUID_FERAL) &&
+                lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) &&
+                (baseId == MAUL_1 || baseId == SHRED_1))
+                pctbonus += 0.2f;
+            //Glyph of Mangle: 10% bonus damage for Mangle (all)
+            if (lvl >= 50 && (baseId == MANGLE_BEAR_1 || baseId == MANGLE_CAT_1))
+                pctbonus += 0.1f;
+
+            //Primal Fury (yellow attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+            //Primal Fury (yellow attacks): 100% to gain 1 combo point at crit in Cat Form
+            if (_form == DRUID_BEAR_FORM && iscrit && lvl >= 25)
+                me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+            if (_form == DRUID_CAT_FORM &&
+                (baseId == CLAW_1 || baseId == MANGLE_CAT_1 || baseId == POUNCE_1 ||
+                baseId == RAKE_1 || baseId == RAVAGE_1 || baseId == SHRED_1))
+                primalFuryProc = iscrit && lvl >= 25;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Nature's bounty: 25% additional critical chance for Regrowth and Nourish
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 35 && (baseId == REGROWTH_1 || baseId == NOURISH_1))
+                crit_chance += 25.f;
+            //Rend and Tear (part 2): 25% additional critical chance on bleeding targets for Ferocious Bite (handled in Unit.cpp)
+            //if (lvl >= 55 && victim->HasAuraState(AURA_STATE_BLEEDING) && baseId == FEROCIOUS_BITE_1)
+            //    crit_chance += 25.f;
+            //Improved Moonfire
+            if (lvl >= 15 && baseId == MOONFIRE_1)
+                crit_chance += 10.f;
+            //Nature's Majesty: 4% additional critical chance for Wrath, Starfire, Starfall, Nourish and Healing Touch
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x25) || (spellInfo->SpellFamilyFlags[1] & 0x2800000)))
+                crit_chance += 4.f;
+            //Eclipse (Lunar): 40% additional critical chance for Starfire
+            if (lvl >= 50 && baseId == STARFIRE_1 && me->HasAura(ECLIPSE_LUNAR_BUFF))
+                crit_chance += 40.f;
+            //Natural Perfection: 3% additional critical chance for all spells
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 40)
+                crit_chance += 3.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Vengeance: 100% additional crit damage bonus for Starfire, Starfall, Moonfire and Wrath
+                if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x7) || (spellInfo->SpellFamilyFlags[1] & 0x800000)))
+                    pctbonus += 0.333f;
+            }
+            //Genesis: 5% bonus damage for Dots
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x6002D2) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.05f;
+            //Improved Insect Swarm: SpellEffects.cpp, Unit.cpp
+            //Brambles: 75% bonus damage for Throns and Entangling Roots (Thorns are handled in Unit.cpp)
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x200))
+                pctbonus += 0.75f;
+            //Moonfury: 10% bonus damage for Starfire, Moonfire and Wrath
+            if (lvl >= 35 && (spellInfo->SpellFamilyFlags[0] & 0x7))
+                pctbonus += 0.1f;
+            //Glyph of Focus (part 1): 10% bonus damage for Starfall
+            if (lvl >= 70 && (spellInfo->SpellFamilyFlags[1] & 0x800000))
+                pctbonus += 0.1f;
+            //Wrath of Cenarius: 20%/10% Increased spellpower bonus for Starfire/Wrath
+            if ((_spec == BOT_SPEC_DRUID_BALANCE) && lvl >= 45)
+            {
+                if (baseId == STARFIRE_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+                if (baseId == WRATH_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+            //Eclipse (Solar): 40% bonus damage for Wrath
+            if (lvl >= 50 && baseId == WRATH_1 && me->HasAura(ECLIPSE_SOLAR_BUFF))
+                pctbonus += 0.4f;
+            //Gale Winds: 30% bonus damage for Hurricane and Typhoon
+            if ((_spec == BOT_SPEC_DRUID_BALANCE) &&
+                lvl >= 50 && ((spellInfo->SpellFamilyFlags[0] & 0x400000) || (spellInfo->SpellFamilyFlags[1] & 0x1000000)))
+                pctbonus += 0.3f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Genesis: 5% bonus healing for Hots
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x6002D2) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.05f;
+            //Improved Rejuvenation: 15% bonus healing for Rejuvenation
+            if (lvl >= 25 && baseId == REJUVENATION_1)
+                pctbonus += 0.15f;
+            //Improved Rejuvenation (17114,17115): 27% bonus healing for Rejuvenation
+            //if (baseId == REJUVENATION_1)
+            //    pctbonus += 0.27f;
+            //Gift of Nature: 10% bonus healing for all spells
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 30)
+                pctbonus += 0.1f;
+            //Empowered Touch: 40% bonus (from spellpower) for Healing Touch and 20% bonus (from spellpower) for Nourish
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 35)
+            {
+                if (baseId == HEALING_TOUCH_1)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+                else if (baseId == NOURISH_1)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Rejuvenation: 20% bonus healing for healing over time effects
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) &&
+                lvl >= 45 && ((spellInfo->SpellFamilyFlags[0] & 0xD0) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Clearcasting: -100% mana/rage/energy cost for any spell
+            if (AuraEffect const* eff = me->GetAuraEffect(OMEN_OF_CLARITY_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //percent mods
+            //Tree of Life Passive (5420) (activates when learned):
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) &&
+                lvl >= 50 && ((spellInfo->SpellFamilyFlags[0] & 0x50) || (spellInfo->SpellFamilyFlags[1] & 0x4000010)))
+                pctbonus += 0.5f;
+            //Glyph of the Wild:
+            if (lvl >= 15 && baseId == MARK_OF_THE_WILD_1)
+                pctbonus += 0.5f;
+            //Natural Shapeshifter:
+            if (lvl >= 15 &&
+                spellInfo->_effects[0].Effect == SPELL_EFFECT_APPLY_AURA &&
+                spellInfo->_effects[0].ApplyAuraName == SPELL_AURA_MOD_SHAPESHIFT)
+                pctbonus += 0.3f;
+            //King of the Jungle part 3:
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0xC0000000))
+                pctbonus += 0.6f;
+            //Tranquil Spirit:
+            if (lvl >= 25 &&
+                (baseId == HEALING_TOUCH_1 || baseId == NOURISH_1 || baseId == TRANQUILITY_1))
+                pctbonus += 0.1f;
+            //Moonglow:
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x77) || (spellInfo->SpellFamilyFlags[1] & 0x2800000)))
+                pctbonus += 0.09f;
+            //Berserk part 2:
+            if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 60 && _form == DRUID_CAT_FORM &&
+                //((spellInfo->SpellFamilyFlags[0] & 0x839000) ||
+                //(spellInfo->SpellFamilyFlags[1] & 0x30000480) ||
+                //(spellInfo->SpellFamilyFlags[2] & 0x40420)) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Shredding Attacks:
+            if (lvl >= 25)
+            {
+                if (spellInfo->SpellFamilyFlags[0] & 0x8000)
+                    flatbonus += 18;
+                else if (spellInfo->SpellFamilyFlags[1] & 0x100)
+                    flatbonus += 20;
+            }
+            //Ferocity:
+            if (lvl >= 10)
+            {
+                if ((spellInfo->SpellFamilyFlags[0] & 0x800) || (spellInfo->SpellFamilyFlags[1] & 0x100040))
+                    flatbonus += 50;
+                else if ((spellInfo->SpellFamilyFlags[0] & 0x1000) ||
+                    (spellInfo->SpellFamilyFlags[1] & 0x400) ||
+                    (spellInfo->SpellFamilyFlags[2] & 0x40400))
+                    flatbonus += 5;
+            }
+            //Improved Mangle part 2:
+            if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 50 && (spellInfo->SpellFamilyFlags[1] & 0x400))
+                flatbonus += 6;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Elune's Wrath: -100% cast time for Starfire
+            AuraEffect const* elun = me->GetAuraEffect(ELUNES_WRATH_BUFF, 0);
+            //Predator's Swiftness: -100% cast time
+            AuraEffect const* pred = me->GetAuraEffect(PREDATORS_SWIFTNESS_BUFF, 0);
+            //Nature's Swiftness: -100% cast time
+            AuraEffect const* natu = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0);
+            if ((elun && elun->IsAffectedOnSpell(spellInfo)) ||
+                (pred && pred->IsAffectedOnSpell(spellInfo)) ||
+                (natu && natu->IsAffectedOnSpell(spellInfo)))
+                pctbonus += 1.0f;
+
+            //pct mods
+            //Celestial Focus: 3% haste
+            if (lvl >= 25)
+                pctbonus += 0.03f;
+
+            //flat mods
+            //Starlight Wrath: -0.5 sec cast time for Wrath and Starfire
+            if (lvl >= 10 && (baseId == WRATH_1 || baseId == STARFIRE_1))
+                timebonus += 500;
+            //Naturalist: -0.5 sec cast time for Healing Touch
+            if (lvl >= 15 && baseId == HEALING_TOUCH_1)
+                timebonus += 500;
+            //Regrowth bonus (ids:21872,46834): -0.2 x2 sec cast time for Regrowth
+            if (lvl >= 68 && baseId == REGROWTH_1)
+                timebonus += 400;
+
+            casttime = std::max<int32>(int32((float(casttime) * (1.0f - pctbonus)) - timebonus), 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Improved Tranquility: -60% cooldown for Tanquility
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && lvl >= 30 && baseId == TRANQUILITY_1)
+                pctbonus += 0.6f;
+
+            //flat mods
+            //Glyph of Turn Evil: +8 sec cooldown for Turn Evil (3 sec for bots)
+            //if (lvl >= 24 && spellId == GetSpell(TURN_EVIL_1))
+            //    timebonus -= 3000;
+
+            cooldown = std::max<int32>(int32((float(cooldown) * (1.0f - pctbonus)) - timebonus), 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Dash: -20% cooldown for Dash
+            if (lvl >= 16 && baseId == DASH_1)
+                pctbonus += 0.2f;
+            //Berserk part 1:
+            if (lvl >= 60 && _form == DRUID_BEAR_FORM && (spellInfo->SpellFamilyFlags[1] & 0x40) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                pctbonus += 1.0f;
+
+            //flat mods
+            //Genesis Rebirth Bonus (26106): -5 min cooldown for Rebirth
+            if (baseId == REBIRTH_1)
+                timebonus += 300000;
+            //Improved Mangle part 1: -1.5 sec cooldown for Mangle (Bear)
+            if (lvl >= 50 && baseId == MANGLE_BEAR_1)
+                timebonus += 1500;
+            //Brutal Impact: -30 sec cooldown for Bash
+            if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 30 && baseId == BASH_1)
+                timebonus += 30000;
+            //Glyph of Typhoon: -3 sec cooldown for Typhoon
+            if (lvl >= 70 && baseId == TYPHOON_1)
+                timebonus += 3000;
+            //Starfall: increase cooldown for bots
+            if (baseId == STARFALL_1)
+                timebonus -= 90000; //x2
+
+            cooldown = std::max<int32>(int32((float(cooldown) * (1.0f - pctbonus)) - timebonus), 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct bonus
+            //Gift of the Earthmother part 2:
+            if (lvl >= 55 && baseId == LIFEBLOOM_1)
+                pctbonus += 0.1f;
+
+            //flat bonus
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Starfall
+            if (spellId == STARFALL_DUMMY_AOE_4)
+                flatbonus -= 10.f; //20 = 36 talented - 18 glyphed + 2 custom
+            if (spellId == STARFALL_DAMAGE_AOE_4)
+                flatbonus += 4.f; //5 nominal + 4 custom
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Nature's Reach: +20% range for Balance Spells and Faerie Fire (Feral)
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x600707) || (spellInfo->SpellFamilyFlags[1] & 0x1821220)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Curse of Exhaustion: +5 yd range for Curse of Exhaustion
+            //if (lvl >= 70 && baseId == CURSE_OF_EXHAUSTION_1)
+            //    flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Maul: + 1 target
+            if (spellInfo->SpellFamilyFlags[0] & 0x800)
+                bonusTargets += 1;
+            //Glyph of Wild Growth: + 1 target
+            if (spellInfo->SpellFamilyFlags[1] & 0x4000000)
+                bonusTargets += 1;
+            //Berserk: + 2 Mangle (Bear) targets
+            if ((spellInfo->SpellFamilyFlags[1] & 0x40) &&
+                me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_DRUID, 0x0, 0x0, 0x40))
+                bonusTargets += 2;
+
+            targets = targets + bonusTargets;
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            //Improved Leader of the Pack: chance
+            if (baseId == LEADER_OF_THE_PACK_BUFF && effIndex == EFFECT_1)
+                value += 4.f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Nature's Swiftness: notify master
+            if (baseId == NATURES_SWIFTNESS_1)
+            {
+                if (!IAmFree())
+                    ReportSpellCast(NATURES_SWIFTNESS_1, LocalizedNpcText(master, BOT_TEXT__USED), master);
+            }
+
+            //On next attack spells cooldown handle
+            //if (baseId == MAUL_1)
+            //    SetSpellCooldown(baseId, me->getAttackTimer(BASE_ATTACK) - 250);
+
+            //Handle clearcasting
+            //Notes: bugged with hurricane (periodic)
+            if (AuraEffect const* eff = me->GetAuraEffect(OMEN_OF_CLARITY_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo) && !spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(HURRICANE_DAMAGE_1)))
+                    me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF);
+
+            //Elune's Wrath: -100% takes priority since only Starfire
+            AuraEffect const* elun = me->GetAuraEffect(ELUNES_WRATH_BUFF, 0);
+            //Predator's Swiftness takes priority since duration
+            AuraEffect const* pred = me->GetAuraEffect(PREDATORS_SWIFTNESS_BUFF, 0);
+            //Nature's Swiftness
+            AuraEffect const* natu = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0);
+            if (elun && elun->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(ELUNES_WRATH_BUFF);
+            else if (pred && pred->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(PREDATORS_SWIFTNESS_BUFF);
+            else if (natu && natu->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (_form == DRUID_CAT_FORM)
+            {
+                //Combo point generating
+                if (baseId == CLAW_1 || baseId == MANGLE_CAT_1 || baseId == POUNCE_1 ||
+                    baseId == RAKE_1 || baseId == RAVAGE_1 || baseId == SHRED_1)
+                {
+                    comboPoints++;
+                    //debug
+                    //TC_LOG_ERROR("entities.player", "druid_bot CP GEN: %s adds 1, now %u", spell->SpellName[0], uint32(comboPoints));
+                    if (primalFuryProc)
+                    {
+                        comboPoints++;
+                        //debug
+                        //TC_LOG_ERROR("entities.player", "druid_bot CP EX: now %u", uint32(comboPoints));
+                    }
+                    if (comboPoints > 5)
+                    {
+                        comboPoints = 5;
+                        //debug
+                        //TC_LOG_ERROR("entities.player", "druid_bot CP NOR: now %u", uint32(comboPoints));
+                    }
+                }
+                //Combo point spending
+                //else if (baseId == FEROCIOUS_BITE_1 || baseId == MAIM_1 || baseId == RIP_1 || baseId == SAVAGE_ROAR_1)
+                else if (spell->NeedsComboPoints())
+                {
+                    //debug
+                    //TC_LOG_ERROR("entities.player", "druid_bot CP SPEND1: %u to 0", uint32(comboPoints));
+                    if (lvl >= 25 && comboPoints > 0)
+                    {
+                        if (urand(1,100) <= uint32(comboPoints * 20))
+                        {
+                            me->CastSpell(me, PREDATORS_SWIFTNESS_BUFF, true);
+                            //debug
+                            //TC_LOG_ERROR("entities.player", "druid_bot CP SPEND1: PS proc!");
+                        }
+                    }
+                    comboPoints = 0;
+                }
+
+                //Maim helper
+                if (baseId == MAIM_1)
+                    MoveBehind(target);
+            }
+
+            //Hibernate helper
+            if (spellId == GetSpell(HIBERNATE_1))
+            {
+                hibery = true;
+                hiberyCheckTimer = 2000;
+            }
+
+            //Bash desperate use (ranged): retreat
+            //Only if hit
+            if (baseId == BASH_1 && HasRole(BOT_ROLE_RANGED) && !HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+            {
+                //if (GC_Timer <= lastdiff && GetSpell(TRAVEL_FORM_1))
+                //    doCast(me, GetSpell(TRAVEL_FORM_1));
+                GetInPosition(true, target);
+            }
+
+            //Infected Wound: handle proc
+            if (baseId == SHRED_1 || baseId == MAUL_1 || baseId == MANGLE_BEAR_1 || baseId == MANGLE_CAT_1)
+            {
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 45)
+                {
+                    CastSpellExtraArgs args(true);
+                    args.SetOriginalCaster(me->GetGUID());
+                    target->CastSpell(target, INFECTED_WOUNDS_EFFECT, args);
+                }
+            }
+
+            //Brutal Impact: +1 sec duration for Bash and Pounce stun
+            if (baseId == BASH_1 || baseId == POUNCE_1)
+            {
+                if (Aura* stu = target->GetAura(spellId))
+                {
+                    //1 extra second on creatures
+                    uint32 dur = stu->GetDuration() + target->GetTypeId() == TYPEID_PLAYER ? 1000 : 2000;
+                    stu->SetDuration(dur);
+                    stu->SetMaxDuration(dur);
+                }
+            }
+
+            //Glyph of Starfire: Increase max duration of Moonfire and refresh
+            if (baseId == STARFIRE_1 && GetSpell(MOONFIRE_1))
+            {
+                if (lvl >= 20)
+                {
+                    if (Aura* aur = target->GetAura(GetSpell(MOONFIRE_1), me->GetGUID()))
+                    {
+                        //extra 9 sec base + 3 sec Nature's Splendor
+                        if (aur->GetMaxDuration() < spell->GetMaxDuration() + 12000)
+                        {
+                            aur->SetDuration(aur->GetDuration() + 3000);
+                            aur->SetMaxDuration(aur->GetMaxDuration() + 3000);
+                        }
+                    }
+                }
+            }
+            //Nature's Splendor: Increased duraion for
+            //Moonfire (3 sec), Rejuvenation (3 sec, let 6), Regrowth (6 sec, let 9),
+            //Insect Swarm (2 sec) and Lifebloom (2 sec)
+            if (baseId == MOONFIRE_1 || baseId == REJUVENATION_1 || baseId == REGROWTH_1 ||
+                baseId == INSECT_SWARM_1 || baseId == LIFEBLOOM_1)
+            {
+                if (lvl >= 20)
+                {
+                    if (Aura* aur = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = aur->GetDuration();
+
+                        switch (baseId)
+                        {
+                            case MOONFIRE_1:
+                                dur += 3000;
+                                break;
+                            case REJUVENATION_1:
+                                dur += 6000;
+                                break;
+                            case REGROWTH_1:
+                                dur += 9000;
+                                break;
+                            case INSECT_SWARM_1:
+                            case LIFEBLOOM_1:
+                                dur += 2000;
+                                break;
+                            default:
+                                break;
+                        }
+
+                        aur->SetDuration(dur);
+                        aur->SetMaxDuration(dur);
+                    }
+                }
+            }
+
+            if (baseId == THORNS_1)
+            {
+                //30 min duration for Thorns
+                if (Aura* thorn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 30 * MINUTE * IN_MILLISECONDS;
+                    thorn->SetDuration(dur);
+                    thorn->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == MARK_OF_THE_WILD_1)
+            {
+                //1 hour duration for Mark of the Wild
+                if (Aura* mark = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    mark->SetDuration(dur);
+                    mark->SetMaxDuration(dur);
+
+                    //Improved Mark of the Wild: +40% effect
+                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        if (AuraEffect* app = mark->GetEffect(i))
+                            app->ChangeAmount((app->GetAmount() * 14) / 10);
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Savage Roar duration
+            if (spellId == SAVAGE_ROAR_BUFF || spellId == SAVAGE_ROAR_1)
+            {
+                if (Aura* sav = me->GetAura(spellId))
+                {
+                    uint32 dur = sav->GetDuration() + 6000;
+                    sav->SetDuration(dur);
+                    sav->SetMaxDuration(dur);
+                }
+                //Glyph of Savage Roar: 3% increase (20 for bot)
+                if (spellId == SAVAGE_ROAR_BUFF)
+                {
+                    AuraEffect* sav = me->GetAuraEffect(spellId, EFFECT_0);
+                    if (sav)
+                        sav->ChangeAmount(sav->GetAmount() + 20);
+                }
+            }
+
+            //Glyph of Berserk: duration
+            if (baseId == BERSERK_1)
+            {
+                if (Aura* ber = me->GetAura(spellId))
+                {
+                    uint32 dur = ber->GetDuration() + 5000;
+                    ber->SetDuration(dur);
+                    ber->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Survival Instincts
+            if (lvl >= 20 && spellId == SURVIVAL_INSTINCTS_1)
+            {
+                AuraEffect* sur = me->GetAuraEffect(spellId, EFFECT_0);
+                if (sur)
+                    sur->ChangeAmount(sur->GetAmount() + 15);
+            }
+            //Starfall: duration
+            if (baseId == STARFALL_1)
+            {
+                if (Aura* sta = me->GetAura(spellId))
+                {
+                    uint32 dur = sta->GetDuration() * 3;
+                    sta->SetDuration(dur);
+                    sta->SetMaxDuration(dur);
+                }
+            }
+            //Predatoe's Swiftness: duration
+            if (spellId == PREDATORS_SWIFTNESS_BUFF)
+            {
+                if (Aura* swi = me->GetAura(spellId))
+                {
+                    swi->SetDuration(15000);
+                    swi->SetMaxDuration(15000);
+                }
+            }
+            //Eclipse (helper): cooldown
+            if (spellId == ECLIPSE_SOLAR_BUFF || spellId == ECLIPSE_LUNAR_BUFF)
+                SetSpellCooldown(spellId, 30000);
+            //Improved Leader of the Pack: handle SPELLMOD_EFFECT_2 MOVED to effect mods
+            /*
+            if (spellId == LEADER_OF_THE_PACK_BUFF)
+            {
+                AuraEffect* lea = me->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                if (lea)
+                    lea->ChangeAmount(lea->GetAmount() + 4);
+            }
+            */
+            //Improved Barkskin: 10% additional damage reduction
+            if ((_spec == BOT_SPEC_DRUID_RESTORATION) && baseId == BARKSKIN_1)
+            {
+                AuraEffect* bar = me->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                if (bar)
+                    bar->ChangeAmount(bar->GetAmount() - 10);
+            }
+
+            //Forms helper
+            if (baseId == BEAR_FORM_1)
+                setStats(DRUID_BEAR_FORM);
+            else if (baseId == CAT_FORM_1)
+                setStats(DRUID_CAT_FORM);
+            else if (baseId == MOONKIN_FORM_1)
+                setStats(DRUID_MOONKIN_FORM);
+            else if (baseId == TREE_OF_LIFE_FORM_1)
+                setStats(DRUID_TREE_FORM);
+            else if (baseId == TRAVEL_FORM_1)
+                setStats(DRUID_TRAVEL_FORM);
+            else if (baseId == AQUATIC_FORM_1)
+                setStats(DRUID_AQUATIC_FORM);
+            //else if (baseId == FLIGHT_FORM_1)
+            //    setStats(DRUID_FLIGHT_FORM);
+
+            //Cat Form: delay prowl just a little bit
+            if (baseId == CAT_FORM_1 && GetSpell(PROWL_1) && GetSpellCooldown(PROWL_1) < 300)
+                SetSpellCooldown(PROWL_1, 300);
+
+            //Leader of the Pack helper
+            if (baseId == CAT_FORM_1 || baseId == BEAR_FORM_1)
+            {
+                if ((_spec == BOT_SPEC_DRUID_FERAL) && lvl >= 40)
+                    me->CastSpell(me, LEADER_OF_THE_PACK_BUFF, true);
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(WRATH_1) : 20.f;
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                if (_treants[i] == summon->GetGUID())
+                    return i;
+
+            return 0;
+        }
+
+        void SummonBotPet(Unit* target)
+        {
+            //if (botPet)
+            //    UnsummonAll();
+
+            uint32 entry = BOT_PET_FORCE_OF_NATURE;
+
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+            {
+                //Position pos;
+
+                //30 sec duration
+                Creature* myPet = me->SummonCreature(entry, (me->GetDistance(target) < 36.f ? *target : *me), TEMPSUMMON_MANUAL_DESPAWN);
+                //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+                //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+                myPet->SetCreator(master);
+                myPet->SetOwnerGUID(me->GetGUID());
+                myPet->SetFaction(master->GetFaction());
+                myPet->SetControlledByPlayer(!IAmFree());
+                myPet->SetPvP(me->IsPvP());
+                myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+                myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+                myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, FORCE_OF_NATURE_1);
+                //botPet = myPet;
+
+                myPet->Attack(target, true);
+                if (!HasBotCommandState(BOT_COMMAND_STAY))
+                    myPet->GetMotionMaster()->MoveChase(target);
+            }
+        }
+
+        void JustSummoned(Creature* summon) override
+        {
+            if (summon->GetEntry() == BOT_PET_FORCE_OF_NATURE)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                {
+                    if (!_treants[i])
+                    {
+                        _treants[i] = summon->GetGUID();
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Druid_bot:JustSummoned() treants array is full");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+            if (summon->GetEntry() == BOT_PET_FORCE_OF_NATURE)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                {
+                    if (_treants[i] == summon->GetGUID())
+                    {
+                        _treants[i] = ObjectGuid::Empty;
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Druid_bot:SummonedCreatureDespawn() treant is not found in array");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void UnsummonAll() override
+        {
+            //if (botPet)
+            //    botPet->ToTempSummon()->UnSummon();
+
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+            {
+                if (_treants[i])
+                    if (Unit* tr = ObjectAccessor::GetUnit(*me, _treants[i]))
+                        tr->ToTempSummon()->UnSummon();
+            }
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_COMBO_POINTS:
+                    return comboPoints;
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_FORCE_OF_NATURE;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+            for (uint8 i = 0; i != MAX_TREANTS; ++i)
+                _treants[i] = ObjectGuid::Empty;
+
+            //_form = BOT_STANCE_NONE;
+            rage = 0;
+            removeShapeshiftForm();
+
+            energy = 0;
+            comboPoints = 0;
+            primalFuryProc = false;
+
+            hibery = false;
+            hiberyCheckTimer = 0;
+
+            me->SetMaxPower(POWER_ENERGY, 100); //for regeneration
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (ragetimer > diff)                   ragetimer -= diff;
+
+            if (hiberyCheckTimer > diff)            hiberyCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            switch (me->GetShapeshiftForm())
+            {
+                case FORM_BEAR:
+                case FORM_DIREBEAR:
+                    me->SetPowerType(POWER_RAGE);
+                    break;
+                case FORM_CAT:
+                    me->SetPowerType(POWER_ENERGY);
+                    break;
+                default:
+                    me->SetPowerType(POWER_MANA);
+                    break;
+            }
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isBala = _spec == BOT_SPEC_DRUID_BALANCE;
+            bool isFera = _spec == BOT_SPEC_DRUID_FERAL;
+            bool isRest = _spec == BOT_SPEC_DRUID_RESTORATION;
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(MAUL_1);
+            InitSpellMap(CHALLENGING_ROAR_1);
+            InitSpellMap(ENRAGE_1);
+            InitSpellMap(FRENZIED_REGENERATION_1);
+            InitSpellMap(GROWL_1);
+            InitSpellMap(LACERATE_1);
+            InitSpellMap(SURVIVAL_INSTINCTS_1);
+            InitSpellMap(FAERIE_FIRE_FERAL_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+            InitSpellMap(POUNCE_1);
+            InitSpellMap(RAVAGE_1);
+            InitSpellMap(RIP_1);
+            InitSpellMap(FEROCIOUS_BITE_1);
+            InitSpellMap(MAIM_1);
+            InitSpellMap(SWIPE_CAT_1);
+            InitSpellMap(SAVAGE_ROAR_1);
+            InitSpellMap(TIGERS_FURY_1);
+            InitSpellMap(COWER_1);
+            InitSpellMap(DASH_1);
+  /*custom*/lvl >= 22 ? InitSpellMap(PROWL_1) : RemoveSpell(PROWL_1); //base lvl 20
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_NORMAL_1);
+            InitSpellMap(TRAVEL_FORM_1);
+            InitSpellMap(AQUATIC_FORM_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(ABOLISH_POISON_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+            InitSpellMap(CYCLONE_1);
+            InitSpellMap(HIBERNATE_1);
+            InitSpellMap(BARKSKIN_1);
+            InitSpellMap(NATURES_GRASP_1);
+            InitSpellMap(INNERVATE_1);
+
+     /*tal*/lvl >= 30 && isBala ? InitSpellMap(INSECT_SWARM_1) : RemoveSpell(INSECT_SWARM_1);
+     /*tal*/lvl >= 40 && isBala ? InitSpellMap(MOONKIN_FORM_1) : RemoveSpell(MOONKIN_FORM_1);
+     /*tal*/lvl >= 50 && isBala ? InitSpellMap(TYPHOON_1) : RemoveSpell(TYPHOON_1);
+     /*tal*/lvl >= 50 && isBala ? InitSpellMap(FORCE_OF_NATURE_1) : RemoveSpell(FORCE_OF_NATURE_1); //not casted
+     /*tal*/lvl >= 60 && isBala ? InitSpellMap(STARFALL_1) : RemoveSpell(STARFALL_1);
+
+     /*tal*/lvl >= 30 && isFera ? InitSpellMap(FERAL_CHARGE_BEAR_1) : RemoveSpell(FERAL_CHARGE_BEAR_1);
+     /*tal*/lvl >= 30 && isFera ? InitSpellMap(FERAL_CHARGE_CAT_1) : RemoveSpell(FERAL_CHARGE_CAT_1);
+     /*tal*/lvl >= 50 && isFera ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+     /*tal*/lvl >= 50 && isFera ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+     /*tal*/lvl >= 60 && isFera ? InitSpellMap(BERSERK_1) : RemoveSpell(BERSERK_1);
+
+     /*tal*/lvl >= 30 && isRest ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+     /*tal*/lvl >= 40 && isRest ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+     /*tal*/lvl >= 50 && isRest ? InitSpellMap(TREE_OF_LIFE_FORM_1) : RemoveSpell(TREE_OF_LIFE_FORM_1);
+     /*tal*/lvl >= 60 && isRest ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isBala = _spec == BOT_SPEC_DRUID_BALANCE;
+            bool isFera = _spec == BOT_SPEC_DRUID_FERAL;
+            bool isRest = _spec == BOT_SPEC_DRUID_RESTORATION;
+
+            RefreshAura(NATURESGRACE, level >= 20 ? 1 : 0);
+            RefreshAura(DREAMSTATE, isBala && level >= 35 ? 1 : 0);
+            RefreshAura(BALANCE_OF_POWER, isBala && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_MOONKIN_FORM, isBala && level >= 40 ? 1 : 0);
+            RefreshAura(ECLIPSE, isBala && level >= 50 ? 1 : 0);
+            RefreshAura(EARTH_AND_MOON, isBala && level >= 55 ? 1 : 0);
+
+            RefreshAura(PRIMAL_PRECISION, isFera && level >= 25 ? 1 : 0);
+            RefreshAura(SURVIVAL_OF_THE_FITTEST, isFera && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_LEADER_OF_THE_PACK, isFera && level >= 40 ? 1 : 0);
+            RefreshAura(PRIMAL_TENACITY, isFera && level >= 40 ? 1 : 0);
+            RefreshAura(KING_OF_THE_JUNGLE, isFera && level >= 50 ? 1 : 0);
+            RefreshAura(PRIMAL_GORE, isFera && level >= 55 ? 1 : 0);
+
+            RefreshAura(IMPROVED_MARK_OF_THE_WILD, level >= 10 ? 1 : 0);
+            RefreshAura(FUROR, level >= 10 ? 1 : 0);
+            RefreshAura(NATURALIST, level >= 15 ? 1 : 0);
+            RefreshAura(INTENSITY, level >= 20 ? 1 : 0);
+            RefreshAura(OMEN_OF_CLARITY, level >= 20 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION3, isRest && level >= 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION2, isRest && level >= 43 && level < 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION1, isRest && level >= 41 && level < 43 ? 1 : 0);
+            RefreshAura(LIVING_SEED3, isRest && level >= 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED2, isRest && level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED1, isRest && level >= 46 && level < 48 ? 1 : 0);
+            RefreshAura(REVITALIZE3, isRest && level >= 55 ? 1 : 0);
+            RefreshAura(REVITALIZE2, isRest && level >= 53 && level < 55 ? 1 : 0);
+            RefreshAura(REVITALIZE1, isRest && level >= 51 && level < 53 ? 1 : 0);
+            RefreshAura(GIFT_OF_THE_EARTHMOTHER, isRest && level >= 55 ? 1 : 0);
+
+            RefreshAura(GLYPH_NOURISH, level >= 80 ? 1 : 0);
+            RefreshAura(GLYPH_SWIFTMEND, level >= 45 ? 1 : 0);
+            RefreshAura(GLYPH_INNERVATE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_RAPID_REJUVENATION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REGROWTH, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REJUVENATION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_FRENZIED_REGENERATION, level >= 36 ? 1 : 0);
+            RefreshAura(GLYPH_BARKSKIN, level >= 44 ? 1 : 0);
+            RefreshAura(GLYPH_RAKE, level >= 24 ? 1 : 0);
+            RefreshAura(GLYPH_SHRED, level >= 22 ? 1 : 0);
+            RefreshAura(T10_RESTO_P4_BONUS, level >= 80 ? 1 : 0);
+            RefreshAura(T9_RESTO_P4_BONUS, level >= 80 ? 1 : 0);
+            RefreshAura(T8_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T9_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T8_FERAL_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_FERAL_P4_BONUS, level >= 80 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case HURRICANE_1:
+                case INNERVATE_1:
+                case ABOLISH_POISON_1:
+                case NATURES_GRASP_1:
+                case BARKSKIN_1:
+                case BEAR_FORM_1:
+                case CAT_FORM_1:
+                case TRAVEL_FORM_1:
+                    return true;
+                case AQUATIC_FORM_1:
+                    return me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && me->IsUnderWater();
+                case TYPHOON_1:
+                case STARFALL_1:
+                case MOONKIN_FORM_1:
+                    return (GetBotRoles() & BOT_ROLE_MASK_MAIN) == (BOT_ROLE_DPS|BOT_ROLE_RANGED);
+                case TREE_OF_LIFE_FORM_1:
+                    return ((GetBotRoles() & BOT_ROLE_MASK_MAIN) & ~BOT_ROLE_RANGED) == BOT_ROLE_HEAL;
+                case SURVIVAL_INSTINCTS_1:
+                case FRENZIED_REGENERATION_1:
+                case ENRAGE_1:
+                case CHALLENGING_ROAR_1:
+                    return _form == DRUID_BEAR_FORM;
+                case TIGERS_FURY_1:
+                case DASH_1:
+                case PROWL_1:
+                    return _form == DRUID_CAT_FORM;
+                case BERSERK_1:
+                    return (_form == DRUID_BEAR_FORM || _form == DRUID_CAT_FORM) &&
+                        (((GetBotRoles() & BOT_ROLE_MASK_MAIN) & BOT_ROLE_TANK) || (GetBotRoles() & BOT_ROLE_MASK_MAIN) == BOT_ROLE_DPS);
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Druid_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Druid_spells_cc;
+        }
+        std::vector<uint32> const* GetHealingSpellsList() const override
+        {
+            return &Druid_spells_heal;
+        }
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Druid_spells_support;
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, NOURISH_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, NOURISH_1));
+                _heals[NOURISH_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[NOURISH_1] = 0;
+
+            if (InitSpell(me, REGROWTH_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, REGROWTH_1));
+                _heals[REGROWTH_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[REGROWTH_1] = 0;
+
+            if (InitSpell(me, HEALING_TOUCH_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HEALING_TOUCH_1));
+                _heals[HEALING_TOUCH_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[HEALING_TOUCH_1] = 0;
+
+            if (InitSpell(me, REJUVENATION_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, REJUVENATION_1));
+                _heals[REJUVENATION_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), DOT, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[REJUVENATION_1] = 0;
+        }
+
+    private:
+        //Treants
+        ObjectGuid _treants[MAX_TREANTS];
+        //Timers/other
+/*Form*/BotStances _form;
+/*Misc*/mutable bool primalFuryProc;
+/*Misc*/uint8 comboPoints;
+/*Misc*/uint32 ragetimer;
+        bool hibery;
+        uint32 hiberyCheckTimer;
+/*Misc*/int32 rage, energy;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 000000000..86e868e67
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,2379 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+#include "World.h"
+/*
+Hunter NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - around 95%
+TODO: Master's Call
+*/
+
+enum HunterBaseSpells
+{
+    AUTO_SHOT_1                         = 75,
+    ARCANE_SHOT_1                       = 3044,
+    TRANQ_SHOT_1                        = 19801,
+    BLACK_ARROW_1                       = 3674,
+    SILENCING_SHOT_1                    = 34490,
+    CHIMERA_SHOT_1                      = 53209,
+    AIMED_SHOT_1                        = 19434,
+    STEADY_SHOT_1                       = 56641,
+    EXPLOSIVE_SHOT_1                    = 53301,
+    KILL_SHOT_1                         = 53351,
+    MULTISHOT_1                         = 2643,
+    VOLLEY_1                            = 1510,
+    SCATTER_SHOT_1                      = 19503,
+    CONCUSSIVE_SHOT_1                   = 5116,
+    DISTRACTING_SHOT_1                  = 20736,
+    SERPENT_STING_1                     = 1978,
+    SCORPID_STING_1                     = 3043,
+    VIPER_STING_1                       = 3034,
+    RAPID_FIRE_1                        = 3045,
+    FLARE_1                             = 1543,
+    TRUESHOT_AURA_1                     = 19506,
+    WYVERN_STING_1                      = 19386,
+    WING_CLIP_1                         = 2974,
+    RAPTOR_STRIKE_1                     = 2973,
+    MONGOOSE_BITE_1                     = 1495,
+    COUNTERATTACK_1                     = 19306,
+    DISENGAGE_1                         = 781,
+    IMMOLATION_TRAP_1                   = 13795,
+    FREEZING_TRAP_1                     = 1499,
+    FROST_TRAP_1                        = 13809,
+    EXPLOSIVE_TRAP_1                    = 13813,
+    FREEZING_ARROW_1                    = 60192,
+    SNAKE_TRAP_1                        = 34600,//NIY
+    HUNTERS_MARK_1                      = 1130,
+    SCARE_BEAST_1                       = 1513,
+    FEIGN_DEATH_1                       = 5384,
+    READINESS_1                         = 23989,
+    DETERRENCE_1                        = 19263,
+    MISDIRECTION_1                      = 34477,
+    MEND_PET_1                          = 136,
+
+    ASPECT_OF_THE_MONKEY_1              = 13163,
+    ASPECT_OF_THE_HAWK_1                = 13165,
+    ASPECT_OF_THE_CHEETAH_1             = 5118,
+    ASPECT_OF_THE_VIPER_1               = 34074,
+    ASPECT_OF_THE_BEAST_1               = 13161,//NIY
+    ASPECT_OF_THE_PACK_1                = 13159,
+    ASPECT_OF_THE_WILD_1                = 20043,
+    ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+};
+
+enum HunterPassives
+{
+//Talents
+    SUREFOOTED                          = 24283,//rank 3
+    ENTRAPMENT                          = 19388,//rank 3
+    RAPID_KILLING                       = 34949,//rank 2
+    IMPROVED_MEND_PET                   = 19573,//rank 2
+    LOCK_AND_LOAD                       = 56344,//rank 3
+    CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+    PIERCING_SHOTS                      = 53238,//rank 3
+    EXPOSE_WEAKNESS                     = 34503,//rank 3
+    THRILL_OF_THE_HUNT                  = 34499,//rank 3
+    MASTER_MARKSMAN                     = 34489,//rank 5
+    MASTER_TACTICIAN1                   = 34506,
+    MASTER_TACTICIAN2                   = 34507,
+    MASTER_TACTICIAN3                   = 34508,
+    MASTER_TACTICIAN4                   = 34838,
+    MASTER_TACTICIAN5                   = 34839,
+    NOXIOUS_STINGS                      = 53297,//rank 3
+    WILD_QUIVER                         = 53217,//rank 3
+    SNIPER_TRAINING                     = 53304,//rank 3
+
+    GLYPH_RAPTOR_STRIKE                 = 63086,
+    GLYPH_ASPECT_OF_THE_VIPER           = 56851,
+    GLYPH_FREEZING_TRAP                 = 56845,
+    GLYPH_EXPLOSIVE_TRAP                = 63068,
+
+    HUNTER_T8_P2                        = 67150,//serpent sting crits
+    HUNTER_T10_P2                       = 70727,//autoshot 15% dmg proc
+    HUNTER_T10_P4                       = 70730 //sting 20% ap proc
+};
+
+enum HunterSpecial
+{
+    ASPECT_NONE                         = 0,
+    ASPECT_MONKEY                       = 1,
+    ASPECT_HAWK                         = 2,
+    ASPECT_CHEETAH                      = 3,
+    ASPECT_VIPER                        = 4,
+    ASPECT_BEAST                        = 5,
+    ASPECT_PACK                         = 6,
+    ASPECT_WILD                         = 7,
+    ASPECT_DRAGONHAWK                   = 8,
+
+    SPECIFIC_ASPECT_MONKEY              = 0x001,
+    SPECIFIC_ASPECT_HAWK                = 0x002,
+    SPECIFIC_ASPECT_CHEETAH             = 0x004,
+    SPECIFIC_ASPECT_VIPER               = 0x008,
+    SPECIFIC_ASPECT_BEAST               = 0x010,
+    SPECIFIC_ASPECT_PACK                = 0x020,
+    SPECIFIC_ASPECT_WILD                = 0x040,
+    SPECIFIC_ASPECT_DRAGONHAWK          = 0x080,
+    SPECIFIC_ASPECT_MY_ASPECT           = 0x100,
+    //SPECIFIC_ASPECT_ALL_AREA_AUTOUSE    = (SPECIFIC_ASPECT_PACK),
+
+    IMPROVED_CONCUSSION                 = 28445,
+    IMPROVED_WING_CLIP_NORMAL           = 47168,
+    IMPROVED_WING_CLIP_EX               = 35963,
+
+    VOLLEY_DAMAGE_1                     = 42243,//rank 1
+    //EXPLOSIVE_TRAP_DAMAGE_1             = 13812,//same as EXPLOSIVE_TRAP_AURA_1
+
+    QUICK_SHOTS_BUFF                    = 6150,
+    RAPID_KILLING_BUFF                  = 35099,//rank 2
+    LOCK_AND_LOAD_BUFF                  = 56453,//rank 3
+    SNIPER_TRAINING_BUFF                = 64420,//rank 3
+    RAPID_RECUPERATION_BUFF             = 54227,//rank 2, rapid fire, hidden
+    RAPID_RECUPERATION_BUFF2            = 58882,//rapid killing, 6 sec
+    IMPROVED_STEADY_SHOT_BUFF           = 53220,
+
+    FROST_TRAP_AURA                     = 13810,
+    FREEZING_TRAP_AURA_1                = 3355,
+    IMMOLATION_TRAP_AURA_1              = 13797,
+    EXPLOSIVE_TRAP_AURA_1               = 13812,//same as EXPLOSIVE_TRAP_DAMAGE_1
+    WYVERN_STING_DOT_AURA_1             = 24131,
+    FREEZING_ARROW_AURA                 = 60210,
+    EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA  = 53352,
+
+    ASPECT_OF_THE_DRAGONHAWK_MONKEY     = 61848, //linked, hidden
+
+    GLYPH_OF_ARCANE_SHOT_ENERGIZE       = 61389,
+    RAPID_RECUPERATION_ENERGIZE         = 58883,//rapid killing
+    RAPID_RECUPERATION_ENERGIZE_PCT_1   = 64180,//rank 1, 2%
+
+    GIFT_OF_NAARU_HUNTER                = 59543,
+
+    SPIRIT_BOND_PET                     = 24529,
+    KINDRED_SPIRITS_PET                 = 57475,
+    //INTIMIDATION_1                      = 24394,
+    BESTIAL_WRATH_1                     = 19574,
+    //BEAST_WITHIN_1                      = 34471,
+
+    GO_FOR_THE_THROAT_ENERGIZE          = 34953,
+    FRENZY_BUFF                         = 19615
+};
+//talent tiers 20-32-44-56-68-80
+
+static const uint32 Hunter_spells_damage_arr[] =
+{ AIMED_SHOT_1, ARCANE_SHOT_1, BLACK_ARROW_1, COUNTERATTACK_1, CHIMERA_SHOT_1, EXPLOSIVE_SHOT_1, EXPLOSIVE_TRAP_1,
+IMMOLATION_TRAP_1, KILL_SHOT_1, MONGOOSE_BITE_1, MULTISHOT_1, RAPTOR_STRIKE_1, SCATTER_SHOT_1, SERPENT_STING_1,
+STEADY_SHOT_1, VOLLEY_1, WYVERN_STING_1 };
+
+static const uint32 Hunter_spells_cc_arr[] =
+{ CONCUSSIVE_SHOT_1, FREEZING_ARROW_1, FREEZING_TRAP_1, FROST_TRAP_1, SCARE_BEAST_1, SCATTER_SHOT_1,
+SILENCING_SHOT_1, WING_CLIP_1, WYVERN_STING_1 };
+
+static const uint32 Hunter_spells_support_arr[] =
+{ /*ASPECT_OF_THE_BEAST_1, */ASPECT_OF_THE_MONKEY_1, ASPECT_OF_THE_HAWK_1, ASPECT_OF_THE_DRAGONHAWK_1,
+ASPECT_OF_THE_CHEETAH_1, ASPECT_OF_THE_PACK_1, ASPECT_OF_THE_VIPER_1, ASPECT_OF_THE_WILD_1,
+DETERRENCE_1, DISENGAGE_1, DISTRACTING_SHOT_1, FEIGN_DEATH_1, FLARE_1, HUNTERS_MARK_1, MEND_PET_1,
+MISDIRECTION_1, RAPID_FIRE_1, READINESS_1, SCORPID_STING_1, /*SNAKE_TRAP_1, */TRANQ_SHOT_1, VIPER_STING_1 };
+
+static const std::vector<uint32> Hunter_spells_damage(FROM_ARRAY(Hunter_spells_damage_arr));
+static const std::vector<uint32> Hunter_spells_cc(FROM_ARRAY(Hunter_spells_cc_arr));
+static const std::vector<uint32> Hunter_spells_support(FROM_ARRAY(Hunter_spells_support_arr));
+
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new hunter_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct hunter_botAI : public bot_ai
+    {
+        hunter_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_HUNTER;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { aspectTimer = 0; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { Aspect = 0; UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckAspects(uint32 diff)
+        {
+            if (aspectTimer > diff || me->IsMounted() || Feasting() || IsCasting() || Rand() > 55)
+                return;
+
+            aspectTimer = urand(5000, 10000);
+
+            if (Aspect == ASPECT_VIPER && GetManaPCT(me) < 50)
+                return;
+
+            uint32 ASPECT_OF_THE_MONKEY = GetSpell(ASPECT_OF_THE_MONKEY_1);
+            uint32 ASPECT_OF_THE_HAWK = GetSpell(ASPECT_OF_THE_HAWK_1);
+            uint32 ASPECT_OF_THE_CHEETAH = GetSpell(ASPECT_OF_THE_CHEETAH_1);
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            //uint32 ASPECT_OF_THE_BEAST = GetSpell(ASPECT_OF_THE_BEAST_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            uint32 ASPECT_OF_THE_WILD = GetSpell(ASPECT_OF_THE_WILD_1);
+            uint32 ASPECT_OF_THE_DRAGONHAWK = GetSpell(ASPECT_OF_THE_DRAGONHAWK_1);
+
+            std::map<uint32 /*baseid*/, uint32 /*curid*/> idMap;
+            uint32 mask = _getAspectsMask(idMap);
+
+            if (Aspect == ASPECT_WILD) //manual
+            {
+                if (idMap[ASPECT_OF_THE_WILD_1] != ASPECT_OF_THE_WILD)
+                    if (doCast(me, ASPECT_OF_THE_WILD))
+                        return;
+                return;
+            }
+
+            if (ASPECT_OF_THE_VIPER && GetManaPCT(me) < 20)
+            {
+                if (doCast(me, ASPECT_OF_THE_VIPER))
+                    return;
+                return;
+            }
+
+            if (IAmFree())
+            {
+                if (ASPECT_OF_THE_DRAGONHAWK && Aspect != ASPECT_DRAGONHAWK)
+                    if (doCast(me, ASPECT_OF_THE_DRAGONHAWK))
+                        return;
+                return;
+            }
+
+            //Group const* gr = master->GetGroup();
+            //choose movement aspect first
+            if (!master->GetBotMgr()->IsPartyInCombat())
+            {
+                if (!(mask & SPECIFIC_ASPECT_PACK))
+                {
+                    uint32 movFlags;
+                    if (ASPECT_OF_THE_PACK)
+                    {
+                        movFlags = master->m_movementInfo.GetMovementFlags();
+                        if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)))
+                        {
+                            if (doCast(me, ASPECT_OF_THE_PACK))
+                                return;
+                        }
+                    }
+                    if (ASPECT_OF_THE_CHEETAH && Aspect != ASPECT_CHEETAH)
+                    {
+                        movFlags = me->m_movementInfo.GetMovementFlags();
+                        if ((movFlags & MOVEMENTFLAG_FORWARD) && !(movFlags & (MOVEMENTFLAG_FALLING_FAR)) &&
+                            me->GetDistance(master) > 20)
+                        {
+                            if (doCast(me, ASPECT_OF_THE_CHEETAH))
+                                return;
+                        }
+                    }
+                }
+
+                return;
+            }
+            else if (Aspect == ASPECT_PACK)
+            {
+                me->RemoveAurasDueToSpell(ASPECT_OF_THE_PACK_1, me->GetGUID());
+                Aspect = ASPECT_NONE;
+            }
+            //else if (Aspect == ASPECT_CHEETAH)
+            //{
+            //    me->RemoveAurasDueToSpell(ASPECT_OF_THE_CHEETAH_1, me->GetGUID());
+            //    Aspect = ASPECT_NONE;
+            //}
+
+            if ((Aspect == ASPECT_DRAGONHAWK && idMap[ASPECT_OF_THE_DRAGONHAWK_1] == ASPECT_OF_THE_DRAGONHAWK) ||
+                (!ASPECT_OF_THE_DRAGONHAWK && ((Aspect == ASPECT_HAWK && idMap[ASPECT_OF_THE_HAWK_1] == ASPECT_OF_THE_HAWK) ||
+                Aspect == ASPECT_MONKEY)))
+                return;
+
+            if (ASPECT_OF_THE_DRAGONHAWK &&
+                (Aspect != ASPECT_DRAGONHAWK || idMap[ASPECT_OF_THE_DRAGONHAWK_1] != ASPECT_OF_THE_DRAGONHAWK))
+            {
+                if (doCast(me, ASPECT_OF_THE_DRAGONHAWK))
+                    return;
+                return;
+            }
+            if (ASPECT_OF_THE_HAWK && (!IsTank() || (!ASPECT_OF_THE_MONKEY && !ASPECT_OF_THE_DRAGONHAWK)) &&
+                (Aspect != ASPECT_HAWK || idMap[ASPECT_OF_THE_HAWK_1] != ASPECT_OF_THE_HAWK))
+            {
+                if (doCast(me, ASPECT_OF_THE_HAWK))
+                    return;
+                return;
+            }
+            if (ASPECT_OF_THE_MONKEY && Aspect != ASPECT_MONKEY)
+            {
+                if (doCast(me, ASPECT_OF_THE_MONKEY))
+                    return;
+                return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = nullptr;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(SCATTER_SHOT_1), 0, SCATTER_SHOT_1);
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(WYVERN_STING_1), 5, WYVERN_STING_1);
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+            //if (!target && IsSpellReady(FREEZING_ARROW_1, diff))
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW_1);
+            //    if (target && doCast(target, GetSpell(FREEZING_ARROW_1)))
+            //        return;
+            //}
+            //if (!target && IsSpellReady(SCARE_BEAST_1, diff))
+            //{
+            //    target = FindCastingTarget(30, 0, SCARE_BEAST_1);
+            //    if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+            //        return;
+            //}
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(CalcSpellMaxRange(SILENCING_SHOT_1), 5, SILENCING_SHOT_1);
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+
+            for (Unit* mtar : { opponent, disttarget })
+            {
+                if (mtar && mtar->GetVictim() == me && mtar->GetDistance(me) < 10 &&
+                    !mtar->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && mtar->getAttackers().size() <= 1)
+                {
+                    if (doCast(mtar, GetSpell(SCATTER_SHOT_1)))
+                    {
+                        GetInPosition(true, nullptr);
+                        return;
+                    }
+                }
+            }
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(SCATTER_SHOT_1)))
+            {
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(CalcSpellMaxRange(WYVERN_STING_1)))
+            {
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with frosty traps
+            if (!IsSpellReady(FREEZING_ARROW_1, diff) || Rand() > 35)
+                return;
+
+            if (Unit* target = FindStunTarget(25))
+            {
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                    return;
+            }
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (trapTimer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            trapTimer = urand(1000, 2000);
+
+            //trap summon spell is 2yd radius
+            std::list<Unit*> targets;
+            GetNearbyTargetsInConeList(targets, 4);
+            if (targets.empty())
+                return;
+
+            //frost trap, freezing trap, freezing arrow: cat 411
+            if (IsSpellReady(FROST_TRAP_1, diff) && !IsTank())
+            {
+                //uint8 movingCount = 0;
+                //for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                //{
+                //    if ((*itr)->isMoving() || ((*itr)->GetVictim() && !IsTank((*itr)->GetVictim())))
+                //    {
+                //        if (++movingCount >= 2)
+                        //if (targets.size() > 1)
+                //        {
+                            if (doCast(me, GetSpell(FROST_TRAP_1)))
+                                return;
+                //            break;
+                //        }
+                //    }
+                //}
+            }
+            //only if taming beast (or manual)
+            if (IsSpellReady(FREEZING_TRAP_1, diff) && !HasRole(BOT_ROLE_DPS) && !IAmFree() &&
+                master->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE_PCT, SPELLFAMILY_GENERIC, 255, 2))
+            {
+                if (doCast(me, GetSpell(FREEZING_TRAP_1)))
+                    return;
+            }
+            //black arrow, immolation trap, explosive trap: cat 1250
+            if (IsSpellReady(EXPLOSIVE_TRAP_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (targets.size() > 1)
+                {
+                    if (doCast(me, GetSpell(EXPLOSIVE_TRAP_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(IMMOLATION_TRAP_1, diff) && HasRole(BOT_ROLE_DPS) && !(*targets.begin())->IsControlledByPlayer())
+            {
+                if (targets.size() > 1)
+                {
+                    if (doCast(me, GetSpell(IMMOLATION_TRAP_1)))
+                        return;
+                }
+            }
+            //snake trap: cat 1249
+            //if (IsSpellReady(SNAKE_TRAP_1, diff) && HasRole(BOT_ROLE_DPS) && (*targets.begin())->IsControlledByPlayer())
+            //{
+            //    if (doCast(me, GetSpell(SNAKE_TRAP_1)))
+            //        return;
+            //}
+        }
+
+        void CheckMendPet(uint32 diff)
+        {
+            if (!IsSpellReady(MEND_PET_1, diff) || checkMendTimer > diff || Rand() > 75 ||
+                !botPet || !botPet->IsAlive() || GetHealthPCT(botPet) > 80 ||
+                me->GetDistance(botPet) > CalcSpellMaxRange(MEND_PET_1, false) || IsCasting())
+                return;
+
+            checkMendTimer = urand(2000, 4000);
+
+            Aura const* mend = botPet->GetAura(GetSpell(MEND_PET_1));
+            if (!mend || mend->GetDuration() < 3000)
+            {
+                if (doCast(me, GetSpell(MEND_PET_1)))
+                    return;
+            }
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 25)
+                return;
+
+            if (FindAffectedTarget(GetSpell(SCARE_BEAST_1), me->GetGUID(), 60))
+            {
+                SetSpellCooldown(SCARE_BEAST_1, 2000);
+                return;
+            }
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1)))
+                    return;
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void doDefend(uint32 diff)
+        {
+            if (IsTank() || Rand() > 55)
+                return;
+
+            bool feignReady = IsSpellReady(FEIGN_DEATH_1, diff, false);
+            bool deterReady = IsSpellReady(DETERRENCE_1, diff, false);
+            if (!feignReady && !deterReady)
+                return;
+
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                        cast = true;
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast)
+                return;
+
+            if (feignReady && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                    return;
+            }
+
+            if (deterReady)
+            {
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                    return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff) || Rand() > 20)
+                return;
+
+            //First check current target
+            for (Unit* mtar : { opponent, disttarget })
+            {
+                if (mtar && me->GetDistance(mtar) > 5 && me->GetDistance(mtar) < CalcSpellMaxRange(TRANQ_SHOT_1) &&
+                    !mtar->IsImmunedToSpell(sSpellMgr->GetSpellInfo(TRANQ_SHOT_1), me))
+                {
+                    AuraApplication const* aurApp;
+                    SpellInfo const* spellInfo;
+                    Unit::AuraMap const& auras = mtar->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        spellInfo = itr->second->GetSpellInfo();
+                        if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                        if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                        //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                        aurApp = itr->second->GetApplicationOfTarget(mtar->GetGUID());
+                        if (aurApp && aurApp->IsPositive())
+                        {
+                            if (doCast(mtar, GetSpell(TRANQ_SHOT_1)))
+                                return;
+                        }
+                    }
+                }
+            }
+
+            Unit* target = FindTranquilTarget(5, CalcSpellMaxRange(TRANQ_SHOT_1));
+            if (target && doCast(target, GetSpell(TRANQ_SHOT_1)))
+                return;
+        }
+
+        void CheckMisdirect(uint32 diff)
+        {
+            if (!IsSpellReady(MISDIRECTION_1, diff) || misdirectionTimer > diff || IAmFree() ||
+                !master->GetGroup() || Rand() > 20)
+                return;
+
+            misdirectionTimer = urand(3000, 6000);
+
+            //find tank
+            //stacks
+            std::list<Unit*> tanks;
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsAlive() && player->IsInCombat() && IsTank(player) && player->GetVictim())
+                    tanks.push_back(player);
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    if (bitr->second == me)
+                        continue;
+                    if (!gr->IsMember(bitr->second->GetGUID()))
+                        continue;
+
+                    Unit* u = bitr->second;
+                    if (u->IsInWorld() && u->IsAlive() && u->IsInCombat() && IsTank(u) &&
+                        (u->GetVictim() || !u->getAttackers().empty()))
+                        tanks.push_back(u);
+                }
+            }
+
+            if (tanks.empty())
+                return;
+
+            Unit* target = tanks.size() == 1 ? *tanks.begin() : Trinity::Containers::SelectRandomContainerElement(tanks);
+            if (doCast(target, GetSpell(MISDIRECTION_1)))
+                return;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            //pet is killed or unreachable
+            if (GC_Timer <= diff && !me->IsInCombat() && !me->IsMounted() && !me->GetVictim() && !IsCasting() && Rand() < 25 &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+                SummonBotPet();
+
+            //Scare Beast interrupt
+            Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (spell && spell->GetSpellInfo()->Id == GetSpell(SCARE_BEAST_1))
+            {
+                if (spell->m_targets.GetUnitTarget() &&
+                    spell->m_targets.GetUnitTarget()->HasAuraType(SPELL_AURA_MOD_FEAR))
+                    me->InterruptSpell(CURRENT_GENERIC_SPELL);
+            }
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 10)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (IsSpellReady(TRUESHOT_AURA_1, diff) && Rand() < 5 &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_RANGED_ATTACK_POWER_PCT, SPELLFAMILY_HUNTER, 0x0, 0x200000, 0x0, me->GetGUID()))
+            {
+                if (doCast(me, GetSpell(TRUESHOT_AURA_1)))
+                    return;
+            }
+
+            CheckMendPet(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckScare(diff);
+
+            //Deterrence check
+            if (me->HasUnitFlag(UNIT_FLAG_PACIFIED) && !IsCasting())
+            {
+                if (!me->isMoving())
+                    GetInPosition(true, nullptr);
+                return;
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            if (IsCasting())
+                return;
+
+            CheckFlare(diff);
+            CheckReadiness(diff);
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            Counter(diff);
+            CheckTranquil(diff);
+
+            MoveBehind(mytar);
+
+            float dist = me->GetDistance(mytar);
+            float maxRangeLong = me->GetLevel() >= 10 ? 51.f : 45.f;
+            float maxRangeNormal = me->GetLevel() >= 10 ? 41.f : 35.f;
+
+            bool inposition = !mytar->HasAuraType(SPELL_AURA_MOD_CONFUSE) || dist > maxRangeNormal - 15.f;
+
+            //Auto Shot
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == AUTO_SHOT_1 && (shot->m_targets.GetUnitTarget() != mytar || !inposition))
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (HasRole(BOT_ROLE_DPS) && dist > 5 && dist < maxRangeNormal)
+            {
+                if (doCast(mytar, AUTO_SHOT_1))
+                {}
+            }
+
+            CheckScatter(diff);
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //TRAPS
+            CheckTraps(diff);
+
+            auto [can_do_nature, can_do_fire, can_do_arcane, can_do_shadow, can_do_normal] =
+                CanAffectVictimBools(mytar, SPELL_SCHOOL_NATURE, SPELL_SCHOOL_FIRE, SPELL_SCHOOL_ARCANE, SPELL_SCHOOL_SHADOW, SPELL_SCHOOL_NORMAL);
+
+            //scatter pvp
+            if (IsSpellReady(SCATTER_SHOT_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) &&
+                mytar->GetTypeId() == TYPEID_PLAYER && dist < 10 && Rand() < 60)
+            {
+                if (doCast(mytar, GetSpell(SCATTER_SHOT_1)))
+                {
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    GetInPosition(true, mytar);
+                    return;
+                }
+            }
+
+            //DISENGAGE
+            if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() && Rand() < 70 &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !me->getAttackers().empty() && me->GetDistance(*me->getAttackers().begin()) < 5 &&
+                me->HasInArc(float(M_PI), *me->getAttackers().begin()))
+            {
+                if (doCast(me, GetSpell(DISENGAGE_1)))
+                    return;
+            }
+
+            MoveBehind(mytar);
+
+            //MELEE SECTION
+            if (dist < 5)
+            {
+                if (!can_do_normal)
+                    return;
+
+                //MONGOOSE BITE
+                if (IsSpellReady(MONGOOSE_BITE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    if (doCast(mytar, GetSpell(MONGOOSE_BITE_1)))
+                        return;
+                }
+                //COUNTERATTACK
+                if (IsSpellReady(COUNTERATTACK_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                    me->HasReactive(REACTIVE_HUNTER_PARRY) && Rand() < 90)
+                {
+                    if (doCast(mytar, GetSpell(COUNTERATTACK_1)))
+                        return;
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || mytar->isMoving()) &&
+                    Rand() < 80 && !CCed(mytar, true) && !mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                {
+                    if (doCast(mytar, GetSpell(WING_CLIP_1)))
+                        return;
+                }
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 40 &&
+                    !me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                {
+                    if (doCast(mytar, GetSpell(RAPTOR_STRIKE_1)))
+                        return;
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK //100 yd range so don't check it
+            if (IsSpellReady(HUNTERS_MARK_1, diff) && can_do_arcane && Rand() < 65 &&
+                !mytar->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STALKED, SPELLFAMILY_HUNTER, 0x400))
+            {
+                if (doCast(mytar, GetSpell(HUNTERS_MARK_1)))
+                    return;
+            }
+
+            CheckMisdirect(diff);
+
+            //attack range check 1
+            if (dist > maxRangeLong)
+                return;
+
+            //KILL SHOT
+            if (IsSpellReady(KILL_SHOT_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) &&
+                mytar->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+            {
+                if (doCast(mytar, GetSpell(KILL_SHOT_1)))
+                    return;
+            }
+
+            //attack range check 2
+            if (dist > maxRangeNormal)
+                return;
+
+            if (!inposition && me->getAttackers().empty())
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && can_do_arcane && Rand() < 35 &&
+                !CCed(mytar, true) && !mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(mytar, GetSpell(CONCUSSIVE_SHOT_1)))
+                    return;
+            }
+            //DISTRACTING SHOT
+            Unit const* u = mytar->GetVictim();
+            if (IsSpellReady(DISTRACTING_SHOT_1, diff) && can_do_arcane && u && u != me && IsTank() && !CCed(mytar) &&
+                IsInBotParty(u) && Rand() < 75 && (!IsTank(u) || (dist > 25 && GetHealthPCT(u) < 25)))
+            {
+                if (doCast(mytar, GetSpell(DISTRACTING_SHOT_1)))
+                    return;
+            }
+            //MULTI-SHOT shares cd with aimed shot
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
+            {
+                if (Rand() < 30 || !GetSpell(STEADY_SHOT_1) || FindSplashTarget(maxRangeNormal))
+                {
+                    if (doCast(mytar, GetSpell(MULTISHOT_1)))
+                        return;
+                }
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !JumpingOrFalling() && Rand() < 75)
+            {
+                if (Unit* target = FindAOETarget(maxRangeNormal))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                        return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && can_do_normal && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 55 &&
+                (mytar->GetHealth() > me->GetMaxHealth() * (1 + mytar->getAttackers().size()) ||
+                mytar->GetTypeId() == TYPEID_PLAYER) &&
+                !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RANGED_HASTE, SPELLFAMILY_HUNTER, 0x20))
+            {
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                {}
+            }
+            //BLACK ARROW
+            //Black Arrow shares cooldown with fire traps
+            if (IsSpellReady(BLACK_ARROW_1, diff) && can_do_shadow && HasRole(BOT_ROLE_DPS) &&
+                mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size()))
+            {
+                if (doCast(mytar, GetSpell(BLACK_ARROW_1)))
+                    return;
+            }
+            //CHIMERA SHOT: no viper
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && can_do_nature && HasRole(BOT_ROLE_DPS))
+            {
+                //Serpent
+                if (mytar->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (doCast(mytar, GetSpell(CHIMERA_SHOT_1)))
+                        return;
+                }
+                //Scorpid
+                else if (mytar->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0, me->GetGUID()))
+                {
+                    if (!mytar->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                        (mytar->GetTypeId() == TYPEID_PLAYER || mytar->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID)))
+                    {
+                        if (doCast(mytar, GetSpell(CHIMERA_SHOT_1)))
+                            return;
+                    }
+                }
+
+                SetSpellCooldown(CHIMERA_SHOT_1, 500); //fail
+            }
+            //STING
+            if (GetSpellCooldown(SERPENT_STING_1) <= diff && can_do_nature && stingTimer <= diff && Rand() < 60)
+            {
+                uint32 STING = 0;
+                AuraEffect const* sting = nullptr;
+                if (!STING && GetSpell(SCORPID_STING_1) && mytar->GetTypeId() == TYPEID_UNIT &&
+                    mytar->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)
+                {
+                    sting = mytar->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0);
+                    if (!sting || sting->GetBase()->GetCasterGUID() == me->GetGUID())
+                        STING = SCORPID_STING_1;
+                }
+                //VIPER STING: pvp only
+                if (!STING && GetSpell(VIPER_STING_1) && mytar->GetTypeId() == TYPEID_PLAYER &&
+                    mytar->GetPowerType() == POWER_MANA && mytar->GetHealth() > me->GetMaxHealth()/2 &&
+                    mytar->GetMaxPower(POWER_MANA) > me->GetMaxPower(POWER_MANA))
+                {
+                    sting = mytar->GetAuraEffect(SPELL_AURA_PERIODIC_MANA_LEECH, SPELLFAMILY_HUNTER, 0x0, 0x80, 0x0, me->GetGUID());
+                    if (!sting)
+                        STING = VIPER_STING_1;
+                }
+                if (!STING && GetSpell(SERPENT_STING_1) && HasRole(BOT_ROLE_DPS) &&
+                    mytar->GetHealth() > me->GetMaxHealth()/2 * (1 + mytar->getAttackers().size()))
+                {
+                    sting = mytar->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID());
+                    if (!sting)
+                        STING = SERPENT_STING_1;
+                }
+
+                if (sting && sting->GetBase()->GetCasterGUID() == me->GetGUID() &&
+                    sting->GetBase()->GetDuration() >= 3000)
+                {
+                    stingTimer = 3000;
+                }
+                else
+                {
+                    if (STING && doCast(mytar, GetSpell(STING)))
+                    {
+                        stingTimer = 8000;
+                        return;
+                    }
+                }
+            }
+            //EXPLOSIVE SHOT: replaces Arcane Shot at 60
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && can_do_fire && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(mytar, GetSpell(EXPLOSIVE_SHOT_1)))
+                    return;
+            }
+            //ARCANE SHOT: shares cd with Explosive Shot
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && can_do_arcane && HasRole(BOT_ROLE_DPS) && !GetSpell(EXPLOSIVE_SHOT_1))
+            {
+                if (doCast(mytar, GetSpell(ARCANE_SHOT_1)))
+                    return;
+            }
+            //AIMED SHOT shares cd with multishot
+            if (IsSpellReady(AIMED_SHOT_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(mytar, GetSpell(AIMED_SHOT_1)))
+                    return;
+            }
+            //STEADY SHOT
+            if (IsSpellReady(STEADY_SHOT_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(mytar, GetSpell(STEADY_SHOT_1)))
+                    return;
+            }
+        }
+
+        void CheckFlare(uint32 diff)
+        {
+            if (!IsSpellReady(FLARE_1, diff) || flareTimer > diff || me->IsMounted() || Rand() > 25)
+                return;
+
+            flareTimer = urand(2000, 4000);
+
+            Unit* attacker = me->GetVictim();
+            if (attacker)
+            {
+                if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                    attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                    attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                {
+                    if (doCast(attacker, GetSpell(FLARE_1)))
+                        return;
+                }
+            }
+
+            if (IAmFree())
+            {
+                Unit::AttackerSet const& b_attackers = me->getAttackers();
+                if (b_attackers.empty())
+                    return;
+
+                for (Unit::AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (me->GetDistance(attacker) > 15)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(me, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+
+                return;
+            }
+
+            attacker = master->GetVictim();
+            if (attacker && me->GetDistance(attacker) < 30)
+            {
+                if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                    attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                    attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                {
+                    if (doCast(attacker, GetSpell(FLARE_1)))
+                        return;
+                }
+            }
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (me->GetDistance(master) > 30)
+                    return;
+
+                Unit::AttackerSet const& m_attackers = master->getAttackers();
+                if (m_attackers.empty())
+                    return;
+
+                for (Unit::AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
+                {
+                    attacker = *itr;
+                    if (master->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(urand(1,100) <= 50 ? master : attacker, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (tPlayer == nullptr) continue;
+                if (me->GetMap() != tPlayer->FindMap()) continue;
+                if (!tPlayer->IsAlive()) continue;
+                if (me->GetDistance(tPlayer) > 30) continue;
+                attacker = tPlayer->GetVictim();
+                if (attacker && me->GetDistance(attacker) < 30)
+                {
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(attacker, GetSpell(FLARE_1)))
+                            return;
+                    }
+                }
+                Unit::AttackerSet const& p_attackers = tPlayer->getAttackers();
+                if (p_attackers.empty())
+                    continue;
+
+                for (Unit::AttackerSet::const_iterator bitr = p_attackers.begin(); bitr != p_attackers.end(); ++bitr)
+                {
+                    attacker = *bitr;
+                    if (tPlayer->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                        continue;
+
+                    if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                        attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                        attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                    {
+                        if (doCast(urand(1,100) <= 50 ? tPlayer : attacker, GetSpell(FLARE_1)))
+                            return;
+
+                        break;
+                    }
+                }
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* gPlayer = itr->GetSource();
+                if (gPlayer == nullptr) continue;
+                if (me->GetMap() != gPlayer->FindMap()) continue;
+                if (!gPlayer->HaveBot())
+                    continue;
+
+                BotMap const* map = gPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    Unit* u = bitr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->IsTotem() || me->GetDistance(u) > 30)
+                        continue;
+
+                    attacker = u->GetVictim();
+                    if (attacker && me->GetDistance(attacker) < 30)
+                    {
+                        if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                            attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                            attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                        {
+                            if (doCast(attacker, GetSpell(FLARE_1)))
+                                return;
+                        }
+                    }
+                    Unit::AttackerSet const& u_attackers = u->getAttackers();
+                    if (u_attackers.empty())
+                        continue;
+
+                    for (Unit::AttackerSet::const_iterator aitr = u_attackers.begin(); aitr != u_attackers.end(); ++aitr)
+                    {
+                        attacker = *aitr;
+                        if (u->GetDistance(attacker) > 15 || me->GetDistance(attacker) > 30)
+                            continue;
+
+                        if ((attacker->GetTypeId() == TYPEID_PLAYER ? attacker->GetClass() == CLASS_ROGUE :
+                            attacker->ToCreature()->GetBotClass() == BOT_CLASS_ROGUE) ||
+                            attacker->HasInvisibilityAura() || attacker->HasStealthAura())
+                        {
+                            if (doCast(urand(1,100) <= 50 ? u : attacker, GetSpell(FLARE_1)))
+                                return;
+
+                            break;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckReadiness(uint32 diff)
+        {
+            if (!IsSpellReady(READINESS_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 30)
+                return;
+
+            //mainly used for rapid fire cd reset
+            bool cast = me->GetVictim() && !IsSpellReady(RAPID_FIRE_1, diff, false);
+
+            if (cast && doCast(me, GetSpell(READINESS_1)))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Explosive Shot: 4% additional critical chance for Explosive Shot
+            if (lvl >= 60 && (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA))
+                crit_chance += 4.f;
+            //Point of No Escape: 6% additional critical chance on targets affected by frosty traps
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 50)
+            {
+                if (victim->GetAuraEffect(SPELL_AURA_MOD_CRIT_CHANCE_FOR_CASTER, SPELLFAMILY_HUNTER, 0x18, 0x0, 0x0, me->GetGUID()))
+                    crit_chance += 6.f;
+            }
+            //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 50 && baseId == KILL_SHOT_1)
+                crit_chance += 15.f;
+            //Improved Steady Shot (37505): 5% additional critical chance for Steady Shot
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+                crit_chance += 5.f;
+            //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+            if (lvl >= 40 && baseId == AIMED_SHOT_1)
+                crit_chance += 10.f;
+            //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 40 && (baseId == AIMED_SHOT_1 || baseId == MULTISHOT_1))
+                crit_chance += 12.f;
+            //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+            if (lvl >= 15 && (baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1 || baseId == EXPLOSIVE_SHOT_1 ||
+                baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA))
+                crit_chance += 4.f;
+            //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+            if (lvl >= 10 && (baseId == RAPTOR_STRIKE_1 || baseId == MONGOOSE_BITE_1 || baseId == COUNTERATTACK_1))
+                crit_chance += 20.f;
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            ////do nothing with autoshot
+            //if (baseId == AUTO_SHOT_1)
+            //    return;
+
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && baseId != AUTO_SHOT_1)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 55 &&
+                    (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1 ||
+                    baseId == KILL_SHOT_1 || baseId == CHIMERA_SHOT_1))
+                    pctbonus += 0.05f;
+            }
+
+            //Improved Tracking: 5% bonus damage versus tracked types (all for bots)
+            if (lvl >= 10)
+                pctbonus += 0.05f;
+            //Focused Fire: 2% bonus damage while pet is active
+            if (lvl >= 15 && botPet)
+                pctbonus += 0.02f;
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 35)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && baseId == ARCANE_SHOT_1)
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1))
+            {
+                if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+                    if (rapi->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.2f;
+            }
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 30 && (spellInfo->SpellFamilyFlags[0] & 0x23000))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 55 && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_RANGED_ATTACK_POWER_ATTACKER_BONUS, SPELLFAMILY_HUNTER, 0x400, 0x0, 0x0/*, me->GetGUID()*/))
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot, Explosive Trap, Immolation Trap and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 25 &&
+                (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA ||
+                baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == IMMOLATION_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.06f;
+            //Ferocious Inspiration part 2: 9% bonus damage for Arcane Shot and Steady Shot
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) &&
+                lvl >= 40 && (baseId == ARCANE_SHOT_1 || baseId == STEADY_SHOT_1))
+                pctbonus += 0.09f;
+            //Improved Steady Shot (38392): 10% bonus damage for Steady Shot
+            if (lvl >= 50 && baseId == STEADY_SHOT_1)
+                pctbonus += 0.1f;
+            //Glyph of Steady Shot: 10% bonus damage for Steady Shot if affected by Serpent Sting
+            if (lvl >= 62 && baseId == STEADY_SHOT_1 && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0/*, me->GetGUID()*/))
+                pctbonus += 0.1f;
+            //The Beast Within part 1: 10% bonus damage for all abilities
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) && lvl >= 50)
+                pctbonus += 0.1f;
+            //Sniper Training part 2: 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 50 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x20000) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x8000001) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x200)))
+            {
+                if (Aura const* snip = me->GetAura(SNIPER_TRAINING_BUFF))
+                {
+                    if (snip->GetEffect(0)->IsAffectedOnSpell(spellInfo) ||
+                        snip->GetEffect(1)->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.06f;
+                }
+            }
+            //Improved Steady Shot part 1: 15% bonus damage for Steady Shot, Aimed Shot, Arcane Arrow and Chimera Shot
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 0))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.15f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*iscrit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (iscrit)
+            //{
+            //    //!!!spell damage is not yet critical and will be multiplied by 1.5
+            //    //so we should put here bonus damage mult /1.5
+            //    //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+            //    if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+            //        pctbonus += 0.16f;
+            //}
+            //Trap Mastery part 2: 30% bonus damage for Immolation Trap, Explosive Trap and Black Arrow
+            if (lvl >= 15 && (baseId == IMMOLATION_TRAP_AURA_1 || baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.3f;
+            //T.N.T: 6% bonus damage for Explosive Shot, Explosive Trap, Immolation Trap and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 25 &&
+                (baseId == EXPLOSIVE_SHOT_1 || baseId == EXPLOSIVE_SHOT_PERIODIC_DUMMY_AURA ||
+                baseId == EXPLOSIVE_TRAP_AURA_1 || baseId == IMMOLATION_TRAP_AURA_1 || baseId == BLACK_ARROW_1))
+                pctbonus += 0.06f;
+            //The Beast Within part 1: 10% bonus damage for all abilities
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) && lvl >= 50)
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flat_mod);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //100% mods
+            //Improved Hunter's Mark: -100% mana cost for Hunter's Mark
+            if (lvl >= 15 && baseId == HUNTERS_MARK_1)
+                pctbonus += 1.0f;
+            //Lock and Load: mana cost
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            }
+
+            //Improved Mend Pet: -20% mana cost for Mend Pet
+            //Improved Mend Pet (23560) part 3
+            if (lvl >= 25 && baseId == MEND_PET_1)
+                pctbonus += 0.5f;
+            //Efficiency: -15% mana cost for Stings and Shots
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 25 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x7FA00) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x88801081) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x1)))
+                pctbonus += 0.15f;
+            //Resourcefulness: -60% mana cost for Traps, melee spells and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 35 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0xDE) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x84000)))
+                pctbonus += 0.6f;
+            //Glyph of Volley: -20% mana cost for Volley
+            if (lvl >= 40 && baseId == VOLLEY_1)
+                pctbonus += 0.2f;
+            //Master Marksman: -25% mana cost for Steady Shot, Aimed Shot and Chimera Shot
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) &&
+                lvl >= 45 && (baseId == STEADY_SHOT_1 || baseId == AIMED_SHOT_1 || baseId == CHIMERA_SHOT_1))
+                pctbonus += 0.25f;
+            //Improved Steady Shot part 2: -20% mana cost for Steady Shot, Aimed Shot, Arcane Arrow and Chimera Shot
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 1))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.2f;
+            }
+
+            //flat mods
+            //!1 rage = 10 pts!
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            //if (lvl >= 10 && baseId == HEROIC_STRIKE_1)
+            //    flatbonus += 30;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Survival Tactics: -4 sec cooldown for Disengage
+            //Glyph of Disengage: -5 sec cooldown for Disengage
+            if (lvl >= 20 && baseId == DISENGAGE_1)
+                timebonus += (_spec == BOT_SPEC_HUNTER_SURVIVAL) ? 9000 : 5000;
+            //Glyph of Feign Death: -5 sec cooldown for Feign Death
+            //Improved Feign Death (24432): -2 sec cooldown for Feign Death
+            if (lvl >= 30 && baseId == FEIGN_DEATH_1)
+                timebonus += 7000;
+            //Tranquilizing Shot Cooldown reduction (61255): -2 sec cooldown for Tranquilizing Shot
+            if (lvl >= 60 && baseId == TRANQ_SHOT_1)
+                timebonus += 2000;
+            //Glyph of Deterrence: -10 sec cooldown for Deterrence
+            if (lvl >= 60 && baseId == DETERRENCE_1)
+                timebonus += 10000;
+            //Glyph of Chimera Shot: -1 sec cooldown for Chimera Shot
+            if (lvl >= 60 && baseId == CHIMERA_SHOT_1)
+                timebonus += 1000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Lock and Load: cooldown
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            }
+
+            //Rapid Killing part 1: -2 min cooldown for Rapid Fire
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && baseId == RAPID_FIRE_1)
+                timebonus += 120000;
+            //Glyph of Aimed Shot: -2 sec cooldown for Aimed Shot
+            if (baseId == AIMED_SHOT_1)
+                timebonus += 2000;
+            //Glyph of Multi-Shot: -1 sec cooldown for Multi-Shot
+            //Improved Multi-Shot (44292): -1 sec cooldown for Multi-Shot
+            if (baseId == MULTISHOT_1)
+                timebonus += 2000;
+            //Trap Cooldown (37481): -4 sec cd for Traps
+            //Trap Cooldown Reduction: -2 sec cd for Traps
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                timebonus += 6000;
+            //Resourcefulness: -6 sec cd for Traps and Black Arrow
+            if ((_spec == BOT_SPEC_HUNTER_SURVIVAL) && lvl >= 35 && (spellInfo->SpellFamilyFlags[0] & 0x80))
+                timebonus += 6000;
+            //Catlike Reflexes part 3: -30 sec cd for Kill Command
+            if ((_spec == BOT_SPEC_HUNTER_BEASTMASTERY) && lvl >= 40 && (spellInfo->SpellFamilyFlags[1] & 0x800))
+                timebonus += 30000;
+            //Glyph of Kill Shot: -6 sec cooldown for Kill Shot
+            if (lvl >= 40 && baseId == KILL_SHOT_1)
+                timebonus += 6000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Frost Trap
+            if (baseId == FROST_TRAP_AURA)
+                flatbonus += 2.f;
+            //Glyph of the Pack
+            if (baseId == ASPECT_OF_THE_PACK_1)
+                flatbonus += 15.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Improved Mend Pet (23560) part 1
+            if (lvl >= 25 && baseId == MEND_PET_1)
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Hawk Eye: +6 yd range for Ranged Abilities
+            if (lvl >= 10 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x7FA01) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x88801081) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x401)))
+                flatbonus += 6.f;
+            //Glyph of Scatter Shot
+            if (lvl >= 20 && baseId == SCATTER_SHOT_1)
+                flatbonus += 3.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+
+            //Improved Aspect of the Hawk: 10% chance
+            if (lvl >= 10 && (baseId == ASPECT_OF_THE_HAWK_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_1))
+                chance += 10.f;
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            //Improved Mend Pet (23560) part 2
+            if (baseId == MEND_PET_1 && effIndex == EFFECT_0)
+                pctbonus *= 1.1f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Rapid Killing: use up buff manually
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* rapi = me->GetAuraEffect(RAPID_KILLING_BUFF, 0))
+                    if (rapi->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAura(RAPID_KILLING_BUFF);
+            }
+            //Glyph of Arcane Shot
+            if (baseId == ARCANE_SHOT_1)
+            {
+                Unit const* victim = me->GetVictim();
+                if (victim &&
+                    (victim->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_HUNTER, 0x4000, 0x0, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_PERIODIC_MANA_LEECH, SPELLFAMILY_HUNTER, 0x0, 0x80, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_MOD_HIT_CHANCE, SPELLFAMILY_HUNTER, 0x8000, 0x0, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_MOD_STUN, SPELLFAMILY_HUNTER, 0x0, 0x1000, 0x0, me->GetGUID()) ||
+                    victim->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_HUNTER, 0x0, 0x100, 0x0, me->GetGUID())))
+                {
+                    int32 cost = spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+                    CastSpellExtraArgs args(true);
+                    args.AddSpellBP0(cost);
+                    me->CastSpell(me, GLYPH_OF_ARCANE_SHOT_ENERGIZE, args);
+                }
+            }
+            //Lock and Load: consume charge
+            if (baseId == ARCANE_SHOT_1 || baseId == EXPLOSIVE_SHOT_1)
+            {
+                AuraEffect const* lock = me->GetAuraEffect(LOCK_AND_LOAD_BUFF, 0);
+                if (lock && lock->IsAffectedOnSpell(spellInfo))
+                    lock->GetBase()->DropCharge();
+            }
+            if (baseId == READINESS_1)
+            {
+                SpellInfo const* cdInfo;
+                BotSpellMap const& myspells = GetSpellMap();
+                for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                {
+                    if (itr->first == spellInfo->Id || itr->first == BESTIAL_WRATH_1 || itr->first == GIFT_OF_NAARU_HUNTER)
+                        continue;
+                    if (itr->second->spellId != 0 && itr->second->cooldown > 0)
+                    {
+                        cdInfo = sSpellMgr->GetSpellInfo(itr->first);
+                        if (cdInfo && cdInfo->SpellFamilyName == SPELLFAMILY_HUNTER && cdInfo->GetRecoveryTime() > 0)
+                            ResetSpellCooldown(itr->first);
+                    }
+                }
+            }
+            //Improved Steady Shot: consume buff
+            if (baseId == AIMED_SHOT_1 || baseId == ARCANE_SHOT_1 || baseId == CHIMERA_SHOT_1)
+            {
+                if (AuraEffect const* stea = me->GetAuraEffect(IMPROVED_STEADY_SHOT_BUFF, 0))
+                    if (stea->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(IMPROVED_STEADY_SHOT_BUFF);
+            }
+
+            //Aspect helper
+            switch (baseId)
+            {
+                case ASPECT_OF_THE_MONKEY_1:
+                    Aspect = ASPECT_MONKEY;
+                    break;
+                case ASPECT_OF_THE_HAWK_1:
+                    Aspect = ASPECT_HAWK;
+                    break;
+                case ASPECT_OF_THE_CHEETAH_1:
+                    Aspect = ASPECT_CHEETAH;
+                    break;
+                case ASPECT_OF_THE_VIPER_1:
+                    Aspect = ASPECT_VIPER;
+                    break;
+                case ASPECT_OF_THE_BEAST_1:
+                    Aspect = ASPECT_BEAST;
+                    break;
+                case ASPECT_OF_THE_PACK_1:
+                    Aspect = ASPECT_PACK;
+                    break;
+                case ASPECT_OF_THE_WILD_1:
+                    Aspect = ASPECT_WILD;
+                    break;
+                case ASPECT_OF_THE_DRAGONHAWK_1:
+                    Aspect = ASPECT_DRAGONHAWK;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (target == me)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == HUNTERS_MARK_1)
+            {
+                //Hunter's Mark helper
+                if (AuraEffect* mark = target->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                {
+                    //Glyph of Hunter's Mark: +20% effect
+                    //Improved Hunter's Mark: +30% effect
+                    if (lvl >= 15)
+                        mark->ChangeAmount(mark->GetAmount() + mark->GetAmount() / 2);
+                    else if (lvl >= 10)
+                        mark->ChangeAmount(mark->GetAmount() * 13 / 10);
+                }
+            }
+            //Improved Stings part 1: +30% damage
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 25 && (baseId == SERPENT_STING_1 || baseId == WYVERN_STING_DOT_AURA_1))
+            {
+                if (AuraEffect* stin = target->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    stin->ChangeAmount(stin->GetAmount() * 13 / 10);
+                }
+            }
+            //Improved Stings part 2: +30% effect: not working?
+            //Trap Mastery part 1
+            if (lvl >= 15 && (baseId == FROST_TRAP_AURA || baseId == FREEZING_TRAP_AURA_1))
+            {
+                if (Aura* freez = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    int32 dur = freez->GetDuration() * 13 / 10;
+                    freez->SetDuration(dur);
+                    freez->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 16 && baseId == IMMOLATION_TRAP_AURA_1)
+            {
+                if (AuraEffect* immo = target->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    //Glyph of Immolation Trap: -6 sec duration, +100% effect
+                    immo->ChangeAmount(immo->GetAmount() * 2);
+                    int32 dur = immo->GetBase()->GetDuration() - 6000;
+                    immo->GetBase()->SetDuration(dur);
+                    immo->GetBase()->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 15 && baseId == SERPENT_STING_1)
+            {
+                if (Aura* sting = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    //Glyph of Serpent Sting: +6 sec duration
+                    //Improved Serpent Sting (24467): +3 sec duration
+                    int32 dur = sting->GetDuration() + 6000;
+                    if (lvl >= 60)
+                        dur += 3000;
+                    sting->SetDuration(dur);
+                    sting->SetMaxDuration(dur);
+                }
+            }
+            if (lvl >= 30 && baseId == WING_CLIP_1)
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (lvl >= 10 && baseId == CONCUSSIVE_SHOT_1)
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spell->Id, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && lvl >= 50 && baseId == STEADY_SHOT_1)
+            {
+                //Improved Steady Shot: 15% chance
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(me, IMPROVED_STEADY_SHOT_BUFF, true);
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Feign Death should always clear combat on bots
+            if (baseId == FEIGN_DEATH_1 && me->GetMap()->IsDungeon())
+                me->CombatStop(false, false);
+
+            //Rapid Recuperation (Rapid Killing) hackfix: trigger 2% energize
+            if (baseId == RAPID_RECUPERATION_ENERGIZE)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_ENERGIZE_PCT_1, true);
+            }
+            //Rapid Recuperation (Rapid Fire): match duration
+            if (baseId == RAPID_RECUPERATION_BUFF && GetSpell(RAPID_FIRE_1))
+            {
+                if (Aura const* rapi = me->GetAura(GetSpell(RAPID_FIRE_1)))
+                {
+                    if (Aura* recu = me->GetAura(spell->Id))
+                    {
+                        uint32 dur = rapi->GetDuration();
+                        recu->SetDuration(dur);
+                        recu->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Rapid Recuperation (Rapid Fire)
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && baseId == RAPID_FIRE_1 && me->GetLevel() >= 45)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_BUFF, true);
+            }
+            //Rapid Recuperation (Rapid Killing)
+            if ((_spec == BOT_SPEC_HUNTER_MARKSMANSHIP) && baseId == RAPID_KILLING_BUFF && me->GetLevel() >= 45)
+            {
+                me->CastSpell(me, RAPID_RECUPERATION_BUFF2, true);
+            }
+            if (baseId == RAPID_FIRE_1 && lvl >= 26)
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                //Glyph of Rapid Fire: +8% haste
+                if (AuraEffect* rapi = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    rapi->ChangeAmount(rapi->GetAmount() + 8);
+
+                    uint32 dur = rapi->GetBase()->GetDuration() + 4000;
+                    rapi->GetBase()->SetDuration(dur);
+                    rapi->GetBase()->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == QUICK_SHOTS_BUFF)
+            {
+                if (AuraEffect* quic = me->GetAuraEffect(QUICK_SHOTS_BUFF, 0))
+                {
+                    //base 15% haste
+                    int32 newAmount = quic->GetAmount() + 15;
+                    //Glyph of the Hawk: +6% effect flat
+                    if (lvl >= 15)
+                        newAmount += 6;
+
+                    quic->ChangeAmount(newAmount);
+                }
+            }
+            if ((baseId == ASPECT_OF_THE_CHEETAH_1 || baseId == ASPECT_OF_THE_PACK_1) && caster == me && lvl >= 20)
+            {
+                //Pathfinding: +8% increased effect
+                if (AuraEffect* spee = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    spee->ChangeAmount(spee->GetAmount() + 8);
+                }
+            }
+            if ((baseId == ASPECT_OF_THE_MONKEY_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_MONKEY) && lvl >= 15)
+            {
+                //Improved Aspect of The Monkey: +6% dodge chance
+                if (AuraEffect* monk = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                {
+                    monk->ChangeAmount(monk->GetAmount() + 6);
+                }
+            }
+            //Aspect Mastery
+            if (lvl >= 20)
+            {
+                if (baseId == ASPECT_OF_THE_VIPER_1)
+                {
+                    if (AuraEffect* vipe = me->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                    {
+                        //part 1: 10% reduced damage penalty
+                        vipe->ChangeAmount(vipe->GetAmount() + 10);
+                    }
+                }
+                if (baseId == ASPECT_OF_THE_MONKEY_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_MONKEY)
+                {
+                    if (AuraEffect* monk = me->GetAuraEffect(spell->Id, 1, me->GetGUID()))
+                    {
+                        //part 2: 5% reduced damage
+                        monk->ChangeAmount(monk->GetAmount() - 5);
+                    }
+                }
+                if (baseId == ASPECT_OF_THE_HAWK_1 || baseId == ASPECT_OF_THE_DRAGONHAWK_1)
+                {
+                    if (AuraEffect* hawk = me->GetAuraEffect(spell->Id, 0, me->GetGUID()))
+                    {
+                        //part 3: 30% attack power bonus
+                        hawk->ChangeAmount(hawk->GetAmount() * 13 / 10);
+                    }
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* /*spellInfo*/) override
+        {
+            if (botPet && victim != me && victim != botPet && damage > 0 && cleanDamage && cleanDamage->hitOutCome == MELEE_HIT_CRIT &&
+                (damagetype == DIRECT_DAMAGE || damagetype == SPELL_DIRECT_DAMAGE) && me->GetLevel() >= 20)
+            {
+                //Go for the Throat: energize pet
+                me->EnergizeBySpell(botPet, GO_FOR_THE_THROAT_ENERGIZE, 50, POWER_FOCUS);
+                //Frenzy hack: proc from hunter's crits
+                if (me->GetLevel() >= 35)
+                    botPet->CastSpell(botPet, FRENZY_BUFF, true);
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            if (me->GetLevel() < 10)
+                return;
+
+            if (myPetType == BOT_PET_INVALID) //disabled
+                return;
+
+            if (petSummonTimer > GetLastDiff())
+                return;
+
+            uint32 entry;
+
+            if (myPetType)
+                entry = myPetType;
+            else if (!IAmFree())
+            {
+                if ((master->GetGroup() && master->GetGroup()->isRaidGroup()) || master->GetNpcBotsCount() >= 10)
+                    entry = BOT_PET_WOLF; //raid pet
+                else if (!IsMeleeClass(master->GetClass()))
+                    entry = urand(BOT_PET_TENACITY_START, BOT_PET_TENACITY_END);
+                else if (sWorld->IsFFAPvPRealm() || sWorld->IsPvPRealm())
+                    entry = urand(BOT_PET_CUNNING_START, BOT_PET_CUNNING_END);
+                else
+                    entry = urand(BOT_PET_HUNTER_START, BOT_PET_HUNTER_END_GENERAL);
+            }
+            else
+                entry = urand(BOT_PET_HUNTER_START, BOT_PET_HUNTER_END_GENERAL);
+
+            //ensurance
+            if (entry < BOT_PET_HUNTER_START || entry > BOT_PET_HUNTER_END_EXOTIC ||
+                (entry >= BOT_PET_EXOTIC_START && _spec != BOT_SPEC_HUNTER_BEASTMASTERY))
+                entry = 0;
+
+            myPetType = entry;
+
+            //try next time
+            if (!myPetType)
+                return;
+
+            petSummonTimer = 10000;
+            ResetSpellCooldown(KINDRED_SPIRITS_PET);
+            ResetSpellCooldown(SPIRIT_BOND_PET);
+
+            Position pos;
+
+            me->CastSpell(me, CALL_PET_VISUAL, true);
+            Creature* myPet = me->SummonCreature(myPetType, *me, TEMPSUMMON_CORPSE_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, me->GetOrientation() + M_PI / 2);
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //fix scale
+            switch (myPetType)
+            {
+                case BOT_PET_RAVAGER:
+                case BOT_PET_WASP:
+                case BOT_PET_TEROMOTH:
+                case BOT_PET_SCORPID:
+                case BOT_PET_TURTLE:
+                case BOT_PET_BEAR:
+                case BOT_PET_WARPSTALKER:
+                case BOT_PET_COREHOUND:
+                    myPet->SetObjectScale(0.75f);
+                    break;
+                case BOT_PET_CHIMAERA:
+                    myPet->SetObjectScale(0.67f);
+                    break;
+                case BOT_PET_RAPTOR:
+                case BOT_PET_DEVILSAUR:
+                case BOT_PET_RHINO:
+                    myPet->SetObjectScale(0.5f);
+                    break;
+                default:
+                    break;
+            }
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all hunter bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+            {
+                petSummonTimer = 10000;
+                botPet = nullptr;
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(AUTO_SHOT_1) : 25.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return myPetType;
+                case BOTAI_MISC_PET_AVAILABLE_1:
+                    return BOT_PET_WOLF;
+                case BOTAI_MISC_PET_AVAILABLE_2:
+                    return BOT_PET_CUNNING_START;
+                case BOTAI_MISC_PET_AVAILABLE_3:
+                    return BOT_PET_FEROCITY_START;
+                case BOTAI_MISC_PET_AVAILABLE_4:
+                    return BOT_PET_TENACITY_START;
+                case BOTAI_MISC_PET_AVAILABLE_5:
+                    return me->GetLevel() >= 80 ? BOT_PET_SILITHID : 0;
+                case BOTAI_MISC_PET_AVAILABLE_6:
+                    return me->GetLevel() >= 80 ? BOT_PET_CHIMAERA : 0;
+                case BOTAI_MISC_PET_AVAILABLE_7:
+                    return me->GetLevel() >= 80 ? BOT_PET_SPIRITBEAST : 0;
+                case BOTAI_MISC_PET_AVAILABLE_8:
+                    return me->GetLevel() >= 80 ? BOT_PET_COREHOUND : 0;
+                case BOTAI_MISC_PET_AVAILABLE_9:
+                    return me->GetLevel() >= 80 ? BOT_PET_DEVILSAUR : 0;
+                case BOTAI_MISC_PET_AVAILABLE_10:
+                    return me->GetLevel() >= 80 ? BOT_PET_RHINO : 0;
+                case BOTAI_MISC_PET_AVAILABLE_11:
+                    return me->GetLevel() >= 80 ? BOT_PET_WORM : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    myPetType = value;
+                    UnsummonAll();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            myPetType = 0;
+
+            trapTimer = 0;
+            stingTimer = 0;
+            aspectTimer = 0;
+            flareTimer = 0;
+            misdirectionTimer = 0;
+            checkMendTimer = 0;
+
+            petSummonTimer = 5000;
+
+            Aspect = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (trapTimer > diff)                   trapTimer -= diff;
+            if (stingTimer > diff)                  stingTimer -= diff;
+            if (aspectTimer > diff)                 aspectTimer -= diff;
+            if (flareTimer > diff)                  flareTimer -= diff;
+            if (misdirectionTimer > diff)           misdirectionTimer -= diff;
+            if (checkMendTimer > diff)              checkMendTimer -= diff;
+
+            if (petSummonTimer > diff)              petSummonTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+
+            if (botPet && botPet->GetPowerType() != POWER_FOCUS)
+                botPet->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_FOCUS);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            //bool isBeas = _spec == BOT_SPEC_HUNTER_BEASTMASTERY;
+            bool isMark = _spec == BOT_SPEC_HUNTER_MARKSMANSHIP;
+            bool isSurv = _spec == BOT_SPEC_HUNTER_SURVIVAL;
+
+            InitSpellMap(AUTO_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+            InitSpellMap(TRANQ_SHOT_1);
+            InitSpellMap(STEADY_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SERPENT_STING_1);
+            InitSpellMap(SCORPID_STING_1);
+            InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(FLARE_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(MONGOOSE_BITE_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(IMMOLATION_TRAP_1);
+            InitSpellMap(FREEZING_TRAP_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(EXPLOSIVE_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+            InitSpellMap(DETERRENCE_1);
+            InitSpellMap(MISDIRECTION_1);
+            InitSpellMap(MEND_PET_1);
+
+            InitSpellMap(ASPECT_OF_THE_MONKEY_1);
+            InitSpellMap(ASPECT_OF_THE_HAWK_1);
+            InitSpellMap(ASPECT_OF_THE_CHEETAH_1);
+            InitSpellMap(ASPECT_OF_THE_VIPER_1);
+            //InitSpellMap(ASPECT_OF_THE_BEAST_1);
+            InitSpellMap(ASPECT_OF_THE_PACK_1);
+            InitSpellMap(ASPECT_OF_THE_WILD_1);
+            InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+
+  /*Talent*/lvl >= (isMark ? 20 : 70) ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+  /*Talent*/lvl >= 30 && isMark ? InitSpellMap(READINESS_1) : RemoveSpell(READINESS_1);
+  /*Talent*/lvl >= 40 && isMark ? InitSpellMap(TRUESHOT_AURA_1) : RemoveSpell(TRUESHOT_AURA_1);
+  /*Talent*/lvl >= 50 && isMark ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 && isMark ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+
+  /*Talent*/lvl >= (isSurv ? 20 : isMark ? 70 : 99) ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+  /*Talent*/lvl >= 30 && isSurv ? InitSpellMap(COUNTERATTACK_1) : RemoveSpell(COUNTERATTACK_1);
+  /*Talent*/lvl >= 40 && isSurv ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+  /*Talent*/lvl >= 50 && isSurv ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+  /*Talent*/lvl >= 60 && isSurv ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isBeas = _spec == BOT_SPEC_HUNTER_BEASTMASTERY;
+            bool isMark = _spec == BOT_SPEC_HUNTER_MARKSMANSHIP;
+            bool isSurv = _spec == BOT_SPEC_HUNTER_SURVIVAL;
+
+            RefreshAura(IMPROVED_MEND_PET, isBeas && level >= 25 ? 1 : 0);
+
+            RefreshAura(RAPID_KILLING, isMark && level >= 20 ? 1 : 0);
+            RefreshAura(CONCUSSIVE_BARRAGE, isMark && level >= 30 ? 1 : 0);
+            RefreshAura(PIERCING_SHOTS, isMark && level >= 40 ? 1 : 0);
+            //RefreshAura(TRUESHOT_AURA, isMark && level >= 40 ? 1 : 0);
+            RefreshAura(MASTER_MARKSMAN, isMark && level >= 45 ? 1 : 0);
+            RefreshAura(WILD_QUIVER, isMark && level >= 50 ? 1 : 0);
+
+            RefreshAura(SUREFOOTED, level >= 15 ? 1 : 0);
+            RefreshAura(ENTRAPMENT, isSurv && level >= 15 ? 1 : 0);
+            RefreshAura(LOCK_AND_LOAD, isSurv && level >= 25 ? 1 : 0);
+            RefreshAura(EXPOSE_WEAKNESS, isSurv && level >= 40 ? 1 : 0);
+            RefreshAura(THRILL_OF_THE_HUNT, isSurv && level >= 40 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN5, isSurv && level >= 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN4, isSurv && level >= 49 && level < 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN3, isSurv && level >= 48 && level < 49 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN2, isSurv && level >= 47 && level < 48 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN1, isSurv && level >= 46 && level < 47 ? 1 : 0);
+            RefreshAura(NOXIOUS_STINGS, isSurv && level >= 45 ? 1 : 0);
+            RefreshAura(SNIPER_TRAINING, isSurv && level >= 50 ? 1 : 0);
+
+            RefreshAura(GLYPH_RAPTOR_STRIKE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_ASPECT_OF_THE_VIPER, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_FREEZING_TRAP, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_EXPLOSIVE_TRAP, level >= 34 ? 1 : 0);
+
+            RefreshAura(HUNTER_T8_P2, level >= 70 ? 1 : 0);
+            RefreshAura(HUNTER_T10_P2, level >= 75 ? 1 : 0);
+            RefreshAura(HUNTER_T10_P4, level >= 80 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                //case RAPID_FIRE_1:
+                case FLARE_1:
+                case MEND_PET_1:
+                case IMMOLATION_TRAP_1:
+                case FREEZING_TRAP_1:
+                case FROST_TRAP_1:
+                case EXPLOSIVE_TRAP_1:
+                case VOLLEY_1:
+                //case ASPECT_OF_THE_MONKEY_1:
+                //case ASPECT_OF_THE_HAWK_1:
+                //case ASPECT_OF_THE_CHEETAH_1:
+                //case ASPECT_OF_THE_VIPER_1:
+                //case ASPECT_OF_THE_BEAST_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_WILD_1:
+                //case ASPECT_OF_THE_DRAGONHAWK_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(Player const* player, std::list<std::string> &specList) override
+        {
+            uint32 textId;
+            switch (Aspect)
+            {
+                case ASPECT_MONKEY:     textId = BOT_TEXT_MONKEY;       break;
+                case ASPECT_HAWK:       textId = BOT_TEXT_HAWK;         break;
+                case ASPECT_CHEETAH:    textId = BOT_TEXT_CHEETAH;      break;
+                case ASPECT_VIPER:      textId = BOT_TEXT_VIPER;        break;
+                case ASPECT_BEAST:      textId = BOT_TEXT_BEAST;        break;
+                case ASPECT_PACK:       textId = BOT_TEXT_PACK;         break;
+                case ASPECT_WILD:       textId = BOT_TEXT_WILD;         break;
+                case ASPECT_DRAGONHAWK: textId = BOT_TEXT_DRAGONHAWK;   break;
+                default:                textId = BOT_TEXT_NOASPECT;     break;
+            }
+            specList.push_back(LocalizedNpcText(player, BOT_TEXT_ASPECT) + ": " + LocalizedNpcText(player, textId));
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Hunter_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Hunter_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Hunter_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Hunter_spells_support;
+        }
+
+    private:
+        uint32 trapTimer, stingTimer, aspectTimer, flareTimer, misdirectionTimer, checkMendTimer;
+        uint8 Aspect;
+        //Pet
+        uint32 myPetType;
+        uint32 petSummonTimer;
+
+        //Scans target for hunter's aspects
+        //returns applied aspects mask
+        //used for finding out which aspects target lacks
+        uint32 _getAspectsMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            uint32 baseId;
+            bool isAspect;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                isAspect = true;
+                baseId = itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    //case ASPECT_OF_THE_MONKEY_1:
+                    //    mask |= SPECIFIC_ASPECT_MONKEY;
+                    //    break;
+                    case ASPECT_OF_THE_HAWK_1:
+                        mask |= SPECIFIC_ASPECT_HAWK;
+                        break;
+                    //case ASPECT_OF_THE_CHEETAH_1:
+                    //    mask |= SPECIFIC_ASPECT_CHEETAH;
+                    //    break;
+                    //case ASPECT_OF_THE_VIPER_1:
+                    //    mask |= SPECIFIC_ASPECT_VIPER;
+                    //    break;
+                    //case ASPECT_OF_THE_BEAST_1:
+                    //    mask |= SPECIFIC_ASPECT_BEAST;
+                    //    break;
+                    case ASPECT_OF_THE_PACK_1:
+                        mask |= SPECIFIC_ASPECT_PACK;
+                        break;
+                    case ASPECT_OF_THE_WILD_1:
+                        mask |= SPECIFIC_ASPECT_WILD;
+                        break;
+                    case ASPECT_OF_THE_DRAGONHAWK_1:
+                        mask |= SPECIFIC_ASPECT_DRAGONHAWK;
+                        break;
+                    default:
+                        isAspect = false; //next aura
+                        break;
+                }
+
+                if (isAspect)
+                {
+                    idMap[baseId] = itr->first;
+                    if (itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                        mask |= SPECIFIC_ASPECT_MY_ASPECT;
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 000000000..d18b0ddf4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,1843 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottraits.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Mage NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 90-95%
+TODO: slow (pvp), mana shield
+*/
+
+enum MageBaseSpells
+{
+    DAMPENMAGIC_1                       = 604,
+    AMPLIFYMAGIC_1                      = 1008,//manual use only
+    ARCANEINTELLECT_1                   = 1459,
+    ARCANEMISSILES_1                    = 5143,
+    ARCANE_BLAST_1                      = 30451,
+    POLYMORPH_1                         = 118,
+    COUNTERSPELL_1                      = 2139,
+    SPELLSTEAL_1                        = 30449,
+    EVOCATION_1                         = 12051,
+    BLINK_1                             = 1953,
+    REMOVE_CURSE_1                      = 475,
+    INVISIBILITY_1                      = 66,
+    SCORCH_1                            = 2948,
+    BLAST_WAVE_1                        = 11113,
+    DRAGON_BREATH_1                     = 31661,
+    FIRE_BLAST_1                        = 2136,
+    PYROBLAST_1                         = 11366,
+    LIVING_BOMB_1                       = 44457,
+    FLAMESTRIKE_1                       = 2120,
+    COMBUSTION_1                        = 11129,
+    FROSTFIRE_BOLT_1                    = 44614,
+    FIREBALL_1                          = 133,
+    FROSTBOLT_1                         = 116,
+    FROST_NOVA_1                        = 122,
+    CONE_OF_COLD_1                      = 120,
+    BLIZZARD_1                          = 10,
+    FROST_ARMOR_1                       = 168,
+    ICE_ARMOR_1                         = 7302,
+    MOLTEN_ARMOR_1                      = 30482,
+    ICE_BARRIER_1                       = 11426,
+    ICE_BLOCK_1                         = 45438,
+    FOCUS_MAGIC_1                       = 54646,
+    PRESENCE_OF_MIND_1                  = 12043,
+    ARCANE_POWER_1                      = 12042,
+    SLOW_FALL_1                         = 130,
+    ICE_LANCE_1                         = 30455,
+    ICY_VEINS_1                         = 12472,
+    COLD_SNAP_1                         = 11958,
+    DEEP_FREEZE_1                       = 44572,
+    FROST_WARD_1                        = 6143,
+    FIRE_WARD_1                         = 543,
+    MIRROR_IMAGE_1                      = 55342,
+    //Special
+    ARCANE_MISSILES_DAMAGE_1            = 7268,
+    BLIZZARD_DAMAGE_1                   = 42208,
+    LIVING_BOMB_DAMAGE_1                = 44461,
+    CONJURE_MANA_GEM_1                  = 759,
+    MANA_GEM_1                          = 5405,
+    RITUAL_OF_REFRESHMENT_1             = 43987,
+
+    SUMMON_WATER_ELEMENTAL_1            = 31687
+};
+
+enum MagePassives
+{
+//Talents
+    FROSTBITE1                          = 11071,
+    FROSTBITE2                          = 12496,
+    FROSTBITE3                          = 12497,
+    ARCANE_CONCENTRATION                = 12577,//rank 5, clearcast
+    IGNITE                              = 12848,//rank 5
+    BURNING_DETERMINATION               = 54749,//rank 2
+    FROST_WARDING                       = 28332,//rank 2
+    IMPROVED_COUNTERSPELL1              = 11255,
+    IMPROVED_COUNTERSPELL2              = 12598,
+    ARCANE_MEDITATION                   = 18464,//rank 3
+    TORMENT_THE_WEAK                    = 55340,//rank 3
+    IMPACT                              = 12358,//rank 3
+    IMPROVED_BLIZZARD                   = 12488,//rank 3
+    IMPROVED_SCORCH                     = 12873,//rank 3
+    MOLTEN_SHIELDS                      = 13043,//rank 2
+    MASTER_OF_ELEMENTS                  = 29076,//rank 3
+    SHATTER1                            = 11170,
+    SHATTER2                            = 12982,
+    SHATTER3                            = 12983,
+    ARCANE_POTENCY1                     = 31571,
+    ARCANE_POTENCY2                     = 31572,
+    BLAZING_SPEED                       = 31642,//rank 2
+    WINTERS_CHILL1                      = 11180,
+    WINTERS_CHILL2                      = 28592,
+    WINTERS_CHILL3                      = 28593,
+    ARCANE_EMPOWERMENT                  = 31583,//rank 3
+    INCANTERS_ABSORPTION1               = 44394,
+    INCANTERS_ABSORPTION2               = 44395,
+    INCANTERS_ABSORPTION3               = 44396,
+    MISSILE_BARRAGE                     = 54490,//rank 5
+    PYROMANIAC                          = 34296,//rank 3
+    SHATTERED_BARRIER                   = 54787,//rank 2
+    //ARCTIC_WINDS                        = 31678,//rank 5
+    FINGERS_OF_FROST                    = 44545,//rank 2
+    FIRESTARTER1                        = 44442,
+    FIRESTARTER2                        = 44443,
+    HOT_STREAK                          = 44448,//rank 3
+    BRAIN_FREEZE1                       = 44546,
+    BRAIN_FREEZE2                       = 44548,
+    BRAIN_FREEZE3                       = 44549,
+
+    GLYPH_POLYMORPH                     = 56375,
+    GLYPG_REMOVE_CURSE                  = 56364,
+    GLYPH_ICY_VEINS                     = 56374,
+    GLYPH_LIVING_BOMB                   = 63091,
+    GLYPH_ICE_LANCE                     = 56377
+};
+enum MageSpecial
+{
+    ARCANE_CONCENTRATION_BUFF           = 12536,
+    IMPACT_BUFF                         = 64343,
+    FIRESTARTER_BUFF                    = 54741,
+    ARCANE_POTENCY_BUFF1                = 57529,
+    ARCANE_POTENCY_BUFF2                = 57531,
+    COMBUSTION_BUFF                     = 28682,
+    BRAIN_FREEZE_BUFF                   = 57761,
+    HOT_STREAK_BUFF                     = 48108,
+    FINGERS_OF_FROST_BUFF               = 44544,
+    ARCANE_BLAST_DEBUFF                 = 36032,
+    MISSILE_BARRAGE_BUFF                = 44401,
+    IMPROVED_BLIZZARD_CHILL             = 12486,//rank 3
+    FROSTBITE_TRIGGERED                 = 12494,
+    WINTERS_CHILL_TRIGGERED             = 12579,
+    IGNITE_TRIGGERED                    = 12654
+};
+
+static const uint32 Mage_spells_damage_arr[] =
+{ ARCANEMISSILES_1, ARCANE_BLAST_1, BLAST_WAVE_1, BLIZZARD_1, CONE_OF_COLD_1, DEEP_FREEZE_1, DRAGON_BREATH_1, FIREBALL_1,
+FIRE_BLAST_1, FLAMESTRIKE_1, FROSTBOLT_1, FROSTFIRE_BOLT_1, FROST_NOVA_1, ICE_LANCE_1, LIVING_BOMB_1, PYROBLAST_1,
+SCORCH_1 };
+
+static const uint32 Mage_spells_cc_arr[] =
+{ COUNTERSPELL_1, DRAGON_BREATH_1, DEEP_FREEZE_1, FROST_NOVA_1, POLYMORPH_1 };
+
+static const uint32 Mage_spells_support_arr[] =
+{ AMPLIFYMAGIC_1, ARCANEINTELLECT_1, BLINK_1, COMBUSTION_1, DAMPENMAGIC_1, EVOCATION_1, FIRE_WARD_1, FROST_WARD_1,
+FROST_ARMOR_1, FOCUS_MAGIC_1, ICE_BARRIER_1, ICE_BLOCK_1, ICY_VEINS_1, INVISIBILITY_1, ICE_ARMOR_1, MOLTEN_ARMOR_1,
+SLOW_FALL_1, SPELLSTEAL_1, REMOVE_CURSE_1, CONJURE_MANA_GEM_1, RITUAL_OF_REFRESHMENT_1, SUMMON_WATER_ELEMENTAL_1,
+COLD_SNAP_1, PRESENCE_OF_MIND_1, ARCANE_POWER_1 };
+
+static const std::vector<uint32> Mage_spells_damage(FROM_ARRAY(Mage_spells_damage_arr));
+static const std::vector<uint32> Mage_spells_cc(FROM_ARRAY(Mage_spells_cc_arr));
+static const std::vector<uint32> Mage_spells_support(FROM_ARRAY(Mage_spells_support_arr));
+
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new mage_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct mage_botAI : public bot_ai
+    {
+        mage_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void JustEnteredCombat(Unit* u) override { canFrostWard = false; canFireWard = false; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void Counter(uint32 diff)
+        {
+            //skip if evocation, blizzard
+            if (IsChanneling() || Rand() > 30)
+                return;
+
+            if (IsSpellReady(COUNTERSPELL_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(COUNTERSPELL_1), 0, COUNTERSPELL_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(DEEP_FREEZE_1, diff) && me->HasAuraType(SPELL_AURA_ABILITY_IGNORE_AURASTATE))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(DEEP_FREEZE_1), 0, DEEP_FREEZE_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(DEEP_FREEZE_1)))
+                        return;
+                }
+            }
+            if (IsSpellReady(FIRE_BLAST_1, diff) && me->HasAura(IMPACT_BUFF))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(FIRE_BLAST_1), 0, FIRE_BLAST_1))
+                {
+                    me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(FIRE_BLAST_1)))
+                        return;
+                }
+            }
+            if (!IsCasting() && IsSpellReady(POLYMORPH_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(POLYMORPH_1), 0, POLYMORPH_1, 75))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(SPELLSTEAL_1), true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                return;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting() || Rand() > 25)
+                return;
+
+            //slow fall
+            if (GetSpell(SLOW_FALL_1) && !IAmFree())
+            {
+                Player* fPlayer = nullptr;
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        Player* pl = ref->GetSource();
+                        if (pl && pl->IsAlive() && pl->FindMap() == me->GetMap() && pl->GetDistance(me) < 30 &&
+                            pl->IsFalling() && pl->m_movementInfo.fallTime > 1000 &&
+                            !pl->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                        {
+                            fPlayer = pl;
+                            break;
+                        }
+                    }
+                }
+                else if (master->IsAlive() && master->GetDistance(me) < 30 && master->IsFalling() &&
+                    master->m_movementInfo.fallTime > 1000 && !master->HasAuraType(SPELL_AURA_FEATHER_FALL))
+                    fPlayer = master;
+
+                if (fPlayer && doCast(fPlayer, GetSpell(SLOW_FALL_1)))
+                    return;
+            }
+
+            //ARMOR
+            uint32 MOLTENARMOR = HasRole(BOT_ROLE_DPS) ? GetSpell(MOLTEN_ARMOR_1) : GetSpell(ICE_ARMOR_1);
+            uint32 ICEARMOR = GetSpell(ICE_ARMOR_1) ? GetSpell(ICE_ARMOR_1) : GetSpell(FROST_ARMOR_1);
+            uint32 ARMOR = !MOLTENARMOR ? ICEARMOR : (me->GetMap()->IsDungeon() || !ICEARMOR) ? MOLTENARMOR : ICEARMOR;
+            if (ARMOR && !me->HasAura(ARMOR))
+            {
+                if (doCast(me, ARMOR))
+                    return;
+            }
+
+            if (GetSpell(CONJURE_MANA_GEM_1))
+            {
+                if (manaGemCharges == 0 &&
+                    doCast(me, GetSpell(CONJURE_MANA_GEM_1)))
+                    return;
+            }
+            if (GetSpell(DAMPENMAGIC_1))
+            {
+                if (!me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELLFAMILY_MAGE, 0x2000)
+                    /*!HasAuraName(me, DAMPENMAGIC_1)*/ &&
+                    doCast(me, GetSpell(DAMPENMAGIC_1)))
+                    return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (GetSpell(ARCANEINTELLECT_1) && target->GetMaxPower(POWER_MANA) > 1 &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_MAGE, 0x400)
+                /*!HasAuraName(target, ARCANEINTELLECT_1)*/)
+            {
+                if (doCast(target, GetSpell(ARCANEINTELLECT_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            CheckPoly(diff);
+            CheckBlink(diff);
+            CheckIceBlock(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            CheckPots(diff);
+
+            CheckRacials(diff);
+
+            CheckShield(diff);
+            CureGroup(GetSpell(REMOVE_CURSE_1), diff);
+            CheckWard(diff);
+
+            CheckFocusMagic(diff);
+            BuffAndHealGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //pet
+            if ((!botPet || !botPet->IsAlive()) &&
+                IsSpellReady(SUMMON_WATER_ELEMENTAL_1, diff) && !IsCasting() && (IAmFree() || master->IsInCombat()))
+                if (doCast(me, GetSpell(SUMMON_WATER_ELEMENTAL_1)))
+                    return;
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            CheckPolymorph(diff);//this should go AFTER getting target
+
+            Counter(diff);
+            CheckSpellSteal(diff);
+            CheckColdSnap(diff);
+
+            if (IsCasting())
+                return;
+
+            if (me->HasInvisibilityAura())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+
+            float dist = me->GetDistance(mytar);
+
+            //COMBUSTION (no GCD)
+            if (IsSpellReady(COMBUSTION_1, diff, false) && GetManaPCT(me) > 20 &&
+                (mytar->GetMaxHealth() > master->GetMaxHealth() * 4 ||
+                master->getAttackers().size() > 1 || b_attackers.size() > 1) &&
+                Rand() < 45 &&
+                !me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x04000000, 0x0)
+                /*!HasAuraName(me, COMBUSTION_1)*/)
+            {
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                    return;
+            }
+            //ICY VEINS (no GCD)
+            if (IsSpellReady(ICY_VEINS_1, diff, false) && GetManaPCT(me) > 20 &&
+                (mytar->GetMaxHealth() > master->GetMaxHealth() * 2 ||
+                (mytar->GetTypeId() == TYPEID_UNIT && mytar->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)) &&
+                Rand() < 45)
+            {
+                if (doCast(me, GetSpell(ICY_VEINS_1)))
+                    return;
+            }
+            //ARCANE POWER (no GCD, not with PoM)
+            if (IsSpellReady(ARCANE_POWER_1, diff, false) && GetManaPCT(me) > 50 &&
+                (mytar->GetMaxHealth() > master->GetMaxHealth() * 2 ||
+                (mytar->GetTypeId() == TYPEID_UNIT && mytar->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)) &&
+                Rand() < 75 && !me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x20, 0x0))
+            {
+                if (doCast(me, GetSpell(ARCANE_POWER_1)))
+                    return;
+            }
+            //PRESENCE OF MIND (no GCD, not with AP)
+            if (IsSpellReady(PRESENCE_OF_MIND_1, diff, false) && GetManaPCT(me) > 10 && Rand() < 35 &&
+                !me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x80000, 0x0))
+            {
+                if (doCast(me, GetSpell(PRESENCE_OF_MIND_1)))
+                    return;
+            }
+            //DAMAGE
+            //Cheap check
+            if (GC_Timer > diff) //!ensure none spells below ignore GCD!
+                return;
+            //NOVAS
+            if ((IsSpellReady(FROST_NOVA_1, diff) || IsSpellReady(BLAST_WAVE_1, diff)) && Rand() < 85)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 8.5f, 1); //both are radius 10 yd
+                if (!targets.empty())
+                {
+                    bool oneOnOne = (*targets.begin()) == mytar;
+                    //Frost Nova
+                    if (IsSpellReady(FROST_NOVA_1, diff) && (targets.size() > 1 || oneOnOne))
+                    {
+                        if (doCast(me, GetSpell(FROST_NOVA_1)))
+                        {
+                            GetInPosition(true, mytar);
+                            return;
+                        }
+                    }
+                    //Blast Wave
+                    else if (IsSpellReady(BLAST_WAVE_1, diff) && (targets.size() > 1 || oneOnOne))
+                    {
+                        if (doCast(me, GetSpell(BLAST_WAVE_1)))
+                            return;
+                    }
+                }
+            }
+            //CONES
+            if (/*fbCasted && */(IsSpellReady(CONE_OF_COLD_1, diff) || IsSpellReady(DRAGON_BREATH_1, diff)) && Rand() < 65)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 8); //both are radius 10 yd
+                if (!targets.empty())
+                {
+                    //Cone of Cold
+                    if (IsSpellReady(CONE_OF_COLD_1, diff))
+                    {
+                        if (doCast(me, GetSpell(CONE_OF_COLD_1)))
+                            return;
+                    }
+                    //Dragon's Breath
+                    else if (IsSpellReady(DRAGON_BREATH_1, diff))
+                    {
+                        if (doCast(me, GetSpell(DRAGON_BREATH_1)))
+                            return;
+                    }
+                }
+            }
+
+            auto [can_do_frost, can_do_fire, can_do_arcane] = CanAffectVictimBools(mytar, SPELL_SCHOOL_FROST, SPELL_SCHOOL_FIRE, SPELL_SCHOOL_ARCANE);
+
+            //spell reflections: Ice Lance instant / Frostbolt Rank 1
+            if (IsSpellReady(ICE_LANCE_1, diff) && can_do_frost && dist < CalcSpellMaxRange(ICE_LANCE_1) && CanRemoveReflectSpells(mytar, ICE_LANCE_1) &&
+                doCast(mytar, ICE_LANCE_1))
+                return;
+            else if (IsSpellReady(FROSTBOLT_1, diff) && can_do_frost && dist < CalcSpellMaxRange(FROSTBOLT_1) && CanRemoveReflectSpells(mytar, FROSTBOLT_1) &&
+                doCast(mytar, FROSTBOLT_1))
+                return;
+
+            //Pyroblast TODO: PoM
+            if (IsSpellReady(PYROBLAST_1, diff) && can_do_fire && dist < CalcSpellMaxRange(PYROBLAST_1) &&
+                ((mytar->IsPolymorphed() && (b_attackers.size() < 2 || (*b_attackers.begin()) == mytar)) ||
+                me->HasAura(HOT_STREAK_BUFF) || (me->HasAura(PRESENCE_OF_MIND_1) && (GetSpec() != BOT_SPEC_MAGE_ARCANE || !GetSpell(ARCANE_BLAST_1)))))
+            {
+                if (doCast(mytar, GetSpell(PYROBLAST_1)))
+                    return;
+            }
+            //Scorch
+            if (IsSpellReady(SCORCH_1, diff) && can_do_fire && GetSpec() == BOT_SPEC_MAGE_FIRE && dist < CalcSpellMaxRange(SCORCH_1) && me->GetLevel() >= 25 &&
+                !mytar->GetAuraEffect(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, SPELLFAMILY_MAGE, 0x0, 0x2000, 0x0))
+            {
+                if (doCast(mytar, GetSpell(SCORCH_1)))
+                    return;
+            }
+            //Living Bomb
+            if ((!mytar->IsControlledByPlayer() || fbCasted) && IsSpellReady(LIVING_BOMB_1, diff) && can_do_fire && dist < CalcSpellMaxRange(LIVING_BOMB_1) &&
+                mytar->GetHealth() > me->GetHealth() / 2 * mytar->getAttackers().size() &&
+                Rand() < 115 && !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_MAGE, 0x0, 0x20000, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(LIVING_BOMB_1)))
+                    return;
+            }
+            //Fire Blast (do not waste mana in raids)
+            if (IsSpellReady(FIRE_BLAST_1, diff) && can_do_fire && dist < CalcSpellMaxRange(FIRE_BLAST_1) &&
+                mytar->GetHealth() < me->GetMaxHealth()*4 && (fbCasted || mytar->GetHealth() < me->GetMaxHealth() / 4) &&
+                Rand() < (30 + 40*fbCasted + 80*(!mytar->IsFrozen() && !mytar->HasUnitState(UNIT_STATE_STUNNED) && me->HasAura(IMPACT_BUFF))))
+            {
+                if (doCast(mytar, GetSpell(FIRE_BLAST_1)))
+                    return;
+            }
+            //Deep Freeze (damage only)
+            if (fbCasted && IsSpellReady(DEEP_FREEZE_1, diff) && can_do_frost && dist < CalcSpellMaxRange(DEEP_FREEZE_1) && Rand() < 30 &&
+                IsImmunedToMySpellEffect(mytar, sSpellMgr->GetSpellInfo(DEEP_FREEZE_1), EFFECT_0) && (mytar->IsFrozen() || me->HasAuraType(SPELL_AURA_ABILITY_IGNORE_AURASTATE)))
+            {
+                if (doCast(mytar, GetSpell(DEEP_FREEZE_1)))
+                    return;
+            }
+            //Flamestrike (instant cast only)
+            if (/*fbCasted && */IsSpellReady(FLAMESTRIKE_1, diff) && can_do_fire && dist < CalcSpellMaxRange(FLAMESTRIKE_1) && Rand() < 80 &&
+                me->HasAura(FIRESTARTER_BUFF))
+            {
+                if (doCast(mytar, GetSpell(FLAMESTRIKE_1)))
+                    return;
+            }
+            //Blizzard
+            if (IsSpellReady(BLIZZARD_1, diff) && !JumpingOrFalling() && Rand() < 50)
+            {
+                if (Unit* blizztarget = FindAOETarget(CalcSpellMaxRange(BLIZZARD_1)))
+                {
+                    if (doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                        return;
+                }
+
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Ice Lance (no cd, only GCD)
+            if (fbCasted && (!me->GetMap()->IsDungeon() || mytar->IsControlledByPlayer()) &&
+                IsSpellReady(ICE_LANCE_1, diff) && can_do_frost && dist < CalcSpellMaxRange(ICE_LANCE_1) &&
+                (mytar->IsFrozen() || me->HasAuraType(SPELL_AURA_ABILITY_IGNORE_AURASTATE)))
+            {
+                if (doCast(mytar, GetSpell(ICE_LANCE_1)))
+                    return;
+            }
+            //Fireball or Frostfire Bolt (instant cast or combustion use up)
+            if (/*fbCasted && */IsSpellReady(FROSTFIREBOLT, diff) && (can_do_frost | can_do_fire) && dist < CalcSpellMaxRange(FROSTFIREBOLT) && Rand() < 150 &&
+                ((((CCed(mytar, true) || b_attackers.empty()) && me->HasAura(COMBUSTION_BUFF)) || me->HasAura(BRAIN_FREEZE_BUFF)) ||
+                !GetSpell(FROSTBOLT_1))) //level 1-3
+            {
+                if (doCast(mytar, GetSpell(FROSTFIREBOLT)))
+                    return;
+            }
+            //Main rotation
+            //Arcane Missiles (arcane spec only)
+            if (IsSpellReady(ARCANEMISSILES_1, diff) && can_do_arcane && _spec == BOT_SPEC_MAGE_ARCANE && dist < CalcSpellMaxRange(ARCANEMISSILES_1) &&
+                (me->GetLevel() < 45 || ((arcaneBlastStack >= 3 ||
+                sSpellMgr->GetSpellInfo(ARCANE_BLAST_1)->CalcPowerCost(me, SPELL_SCHOOL_MASK_ARCANE) > int(me->GetPower(POWER_MANA))) &&
+                me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x2, 0x0))))
+            {
+                if (doCast(mytar, GetSpell(ARCANEMISSILES_1)))
+                    return;
+            }
+            if (IsSpellReady(ARCANE_BLAST_1, diff) && can_do_arcane && _spec == BOT_SPEC_MAGE_ARCANE && dist < CalcSpellMaxRange(ARCANE_BLAST_1) &&
+                (arcaneBlastStack < 4 || !me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x2, 0x0)))
+            {
+                if (doCast(mytar, GetSpell(ARCANE_BLAST_1)))
+                    return;
+            }
+            if (IsSpellReady(FROSTFIREBOLT, diff) && (can_do_frost | can_do_fire) && (_spec == BOT_SPEC_MAGE_FIRE ||
+                (_spec == BOT_SPEC_MAGE_FROST && (FROSTFIREBOLT == FROSTFIRE_BOLT_1 || !GetSpell(FROSTBOLT_1)))) &&
+                dist < CalcSpellMaxRange(FROSTFIREBOLT))
+            {
+                if (doCast(mytar, GetSpell(FROSTFIREBOLT)))
+                    return;
+            }
+            if (IsSpellReady(FROSTBOLT_1, diff) && can_do_frost && _spec == BOT_SPEC_MAGE_FROST && dist < CalcSpellMaxRange(FROSTBOLT_1))
+            {
+                if (doCast(mytar, GetSpell(FROSTBOLT_1)))
+                    return;
+            }
+
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == SHOOT_WAND && shot->m_targets.GetUnitTarget() != mytar)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (IsSpellReady(SHOOT_WAND, diff) && me->GetDistance(mytar) < 30 && GetEquips(BOT_SLOT_RANGED) &&
+                doCast(mytar, SHOOT_WAND))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                poly = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPolymorph(uint32 diff)
+        {
+            if (poly == false && IsSpellReady(POLYMORPH_1, diff) && !IsCasting())
+            {
+                if (Unit* target = FindPolyTarget(CalcSpellMaxRange(POLYMORPH_1)))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+            if (Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff) && GetManaPCT(me) < 15 && uint8(me->getAttackers().size()) < (shielded ? 3 : 1))
+                {
+                    if (doCast(me, GetSpell(EVOCATION_1)))
+                        return;
+                }
+                if (manaGemCharges > 0 && GetManaPCT(me) < 50 && IsSpellReady(MANA_GEM_1, diff, false))
+                {
+                    if (doCast(me, GetSpell(MANA_GEM_1)))
+                        return;
+                }
+                if (IsPotionReady() && GetManaPCT(me) < 40)
+                    DrinkPotion(true);
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (!me->IsAlive())
+                return;
+            if (me->GetVehicle())
+                return;
+            if (HasBotCommandState(BOT_COMMAND_STAY) || me->IsMounted())
+                return;
+            if (!IsSpellReady(BLINK_1, diff) || IsCasting() || Rand() > 70)
+                return;
+
+            if (!IAmFree())
+            {
+                if (!me->IsInCombat() && me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 35) &&
+                    me->HasInArc(float(M_PI)*0.67f, master))
+                {
+                    if (doCast(me, GetSpell(BLINK_1)))
+                        return;
+                }
+            }
+            if (me->IsInCombat() && !me->getAttackers().empty() && HasRole(BOT_ROLE_RANGED))
+            {
+                bool cast = me->HasAuraWithMechanic((1<<MECHANIC_STUN)|(1<<MECHANIC_ROOT));
+                Unit* u = nullptr;
+                if (!cast)
+                {
+                    u = me->SelectNearestTarget(7);
+                    cast = (u && u->GetVictim() == me && u->IsWithinLOSInMap(me));
+                }
+                if (!cast)
+                {
+                    u = (*me->getAttackers().begin());
+                    cast = (u && (!CCed(u, true) || me->getAttackers().size() > 1) && u->GetDistance(me) < 5.f &&
+                        u->IsWithinLOSInMap(me));
+                }
+                if (cast)
+                {
+                    if (u)
+                    {
+                        //turn away from target
+                        me->AttackStop();
+                        //me->SetFacingTo(me->GetAbsoluteAngle(u) + M_PI);
+                        me->SetOrientation(me->GetAbsoluteAngle(u) + M_PI);
+                    }
+                    if (doCast(me, GetSpell(BLINK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckFocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || IAmFree() || me->GetLevel() < 20 || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUS_MAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 3))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group const* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->GetPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                        target = master;
+                }
+                else
+                {
+                    for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->IsAlive()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->GetPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    //damaging bots
+                    if (!target)
+                    {
+                        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || !cre->IsAlive() ||
+                                    cre->GetPowerType() != POWER_MANA || cre->GetBotAI()->HasRole(BOT_ROLE_TANK) ||
+                                    cre->GetBotClass() == BOT_CLASS_BM || cre->GetBotClass() == BOT_CLASS_HUNTER ||
+                                    cre->GetBotClass() == BOT_CLASS_SPELLBREAKER || cre->GetBotClass() == BOT_CLASS_DARK_RANGER ||
+                                    cre->GetBotClass() == BOT_CLASS_SEA_WITCH)
+                                    continue;
+                                if (cre->GetBotAI()->HasRole(BOT_ROLE_DPS) && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    //any bot
+                    if (!target)
+                    {
+                        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || !cre->IsAlive() ||
+                                    cre->GetPowerType() != POWER_MANA || cre->GetBotAI()->HasRole(BOT_ROLE_TANK) ||
+                                    cre->GetBotClass() == BOT_CLASS_BM || cre->GetBotClass() == BOT_CLASS_HUNTER ||
+                                    cre->GetBotClass() == BOT_CLASS_SPELLBREAKER || cre->GetBotClass() == BOT_CLASS_DARK_RANGER ||
+                                    cre->GetBotClass() == BOT_CLASS_SEA_WITCH)
+                                    continue;
+                                if (me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000; //fail
+        }
+
+        void CheckIceBlock(uint32 diff)
+        {
+            if (!me->IsAlive() || GC_Timer > diff || me->GetVehicle() || !GetSpell(ICE_BLOCK_1) || Rand() > 60 || IsTank())
+                return;
+
+            if (iceblockCheckTimer <= diff)
+            {
+                if (me->getAttackers().empty() && (!me->IsInCombat() || (GetManaPCT(me) > 45 && GetHealthPCT(me) > 80)))
+                {
+                    me->RemoveAurasDueToSpell(GetSpell(ICE_BLOCK_1));
+                    return;
+                }
+                iceblockCheckTimer = std::numeric_limits<uint32>::max();
+            }
+
+            if (!IsSpellReady(ICE_BLOCK_1, diff))
+                return;
+
+            if (me->IsInCombat() && !me->getAttackers().empty() &&
+                (CCed(me, true) || me->getAttackers().size() > 2 || GetHealthPCT(me) < 40))
+            {
+                if (doCast(me, GetSpell(ICE_BLOCK_1)))
+                    return;
+            }
+        }
+
+        void CheckColdSnap(uint32 diff)
+        {
+            if (!IsSpellReady(COLD_SNAP_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 50)
+                return;
+
+            //TODO: recheck priorities
+            uint32 needFactor = 0;
+            uint32 cooldown;
+            cooldown = GetSpellCooldown(FROST_NOVA_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 220;  //0-100 x3
+            cooldown = GetSpellCooldown(ICE_BLOCK_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 2400; //0-100 x3
+            cooldown = shielded ? 0 : GetSpellCooldown(ICE_BARRIER_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 240;  //0-100 x3
+            cooldown = GetSpellCooldown(FROST_WARD_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 300;  //0-100 x2
+            cooldown = GetSpellCooldown(ICY_VEINS_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 1500; //0-100 x2
+            cooldown = (botPet && botPet->IsAlive()) ? 0 : GetSpellCooldown(SUMMON_WATER_ELEMENTAL_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1500; //0-100
+            cooldown = GetSpellCooldown(DEEP_FREEZE_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 240;  //0-100
+            cooldown = GetSpellCooldown(CONE_OF_COLD_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 80;   //0-100
+            //0-1600
+
+            if (needFactor >= 700 && doCast(me, GetSpell(COLD_SNAP_1)))
+                return;
+        }
+
+        void CheckShield(uint32 diff)
+        {
+            //TODO: Mana Shield
+            if (!GetSpell(ICE_BARRIER_1))
+                return;
+
+            if (shieldCheckTimer <= diff)
+            {
+                shieldCheckTimer = 1500;
+                shielded = me->GetTotalAuraModifierByMiscValue(SPELL_AURA_SCHOOL_ABSORB, 127) > 0;
+                shielded = shielded ? shielded : me->HasAura(GetSpell(ICE_BARRIER_1));
+            }
+
+            if (shielded || !IsSpellReady(ICE_BARRIER_1, diff) || IsCasting())
+                return;
+
+            if ((me->IsInCombat() && me->GetMap()->Instanceable()) ||
+                !me->getAttackers().empty() || GetHealthPCT(me) < 90)
+            {
+                if (doCast(me, GetSpell(ICE_BARRIER_1)))
+                    return;
+            }
+        }
+
+        void CheckWard(uint32 diff)
+        {
+            if ((!me->IsInCombat() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                !IsSpellReady(FROST_WARD_1, diff) || IsCasting())
+                return;
+
+            uint32 FROSTWARD = canFrostWard ? GetSpell(FROST_WARD_1) : 0;
+            uint32 FIREWARD = canFireWard ? GetSpell(FIRE_WARD_1) : 0;
+
+            if (FIREWARD && doCast(me, FIREWARD))
+                return;
+
+            if (FROSTWARD && doCast(me, FROSTWARD))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Shatter
+            //SHATTER IS HANDLED IN Unit::isSpCrit()
+
+            //Arcane Potency: 15%/30% additional crit chance for All spells
+            if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                crit_chance += 30.f;
+            else if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                crit_chance += 15.f;
+
+            //Combustion: 10% additional critical chance for fire spells per stack
+            if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                    crit_chance += float(combustion->GetStackAmount() * 10);
+
+            //Incineration: 6% additional crit chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+            if (lvl >= 10 &&
+                (baseId == FIRE_BLAST_1 || baseId == SCORCH_1 ||
+                baseId == ARCANE_BLAST_1 || baseId == CONE_OF_COLD_1))
+                crit_chance += 6.f;
+            //World In Flames: 6% additional critical chance for Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+            if (lvl >= 15 &&
+                (baseId == FLAMESTRIKE_1 || baseId == PYROBLAST_1 ||
+                baseId == BLAST_WAVE_1 || baseId == DRAGON_BREATH_1 ||
+                baseId == BLIZZARD_DAMAGE_1/* || spellId == ARCANEXPLOSION*/ ||
+                baseId == LIVING_BOMB_1 || baseId == LIVING_BOMB_DAMAGE_1))
+                crit_chance += 6.f;
+            //Improved Scorch part 1: 3% additional critical chance for Scorch, Fireball and Frostfire Bolt
+            if (lvl >= 20 && (baseId == SCORCH_1 || baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1))
+                crit_chance += 3.f;
+            //Critical Mass: 6% additional critical chance for Fire spells
+            if ((_spec == BOT_SPEC_MAGE_FIRE) && lvl >= 30 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                crit_chance += 6.f;
+            //Winter's chill part 1: 3% additional crit chance for Frostbolt
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 35 && baseId == FROSTBOLT_1)
+                crit_chance += 3.f;
+
+            //Glyph of Frostfire Bolt part 2: 2% additional critical chance for Frostfire Bolt
+            if (/*lvl >= 75 && */baseId == FROSTFIRE_BOLT_1)
+                crit_chance += 2.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Burnout: 50% additional crit damage bonus for All spells
+                //well it's gonna be a little too much eh? skipped
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.334f;
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 55)
+                    pctbonus += 0.334f;
+                //Combustion: 50% additional crit damage bonus for Fire spells
+                if ((SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()) && me->HasAura(COMBUSTION_1))
+                    pctbonus += 0.334f;
+            }
+
+            //Spell Impact: 6% bonus damage for Arcne Explosion, Arcane Blast, Scorch, Fireball, Ice Lance and Cone of Cold
+            if (lvl >= 20 &&
+                (/*baseId == ARCANE_EXPLOSION_1 || */baseId == SCORCH_1 ||
+                baseId == ARCANE_BLAST_1 || baseId == FIREBALL_1 ||
+                baseId == ICE_LANCE_1 || baseId == CONE_OF_COLD_1))
+                pctbonus += 0.06f;
+            //Piercing Ice: 6% bonus damage for Frost spells
+            if (lvl >= 20 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.06f;
+            //Playing with Fire part 1: 3% bonus damage for all spells
+            if ((_spec == BOT_SPEC_MAGE_FIRE) && lvl >= 30)
+                pctbonus += 0.03f;
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 30 && baseId == CONE_OF_COLD_1)
+                pctbonus += 0.35f;
+            //Arcane Instability part 1: 3% bonus damage for all spells
+            if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 35)
+                pctbonus += 0.03f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if ((_spec == BOT_SPEC_MAGE_FIRE) && lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+            //Arcane Empowerment part 1,2: 45% / 9% bonus damage (from spellpower) for Arcane Missiles / Arcane Blast
+            if (_spec == BOT_SPEC_MAGE_ARCANE && lvl >= 40)
+            {
+                if (baseId == ARCANE_MISSILES_DAMAGE_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.45f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+                else if (baseId == ARCANE_BLAST_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.09f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+            //Arcane Power: +20% bonus damage
+            if (AuraEffect const* pow = me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x80000, 0x0))
+                if (pow->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 0.2f;
+            //Molten Fury: 12% bonus damage for All spells against target with less than 35% hp
+            if ((_spec == BOT_SPEC_MAGE_FIRE) &&
+                lvl >= 40 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.12f;
+            //Arctic Winds part 1: 5% bonus damage for Frost spells
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 40 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                pctbonus += 0.05f;
+            //Empowered Fire part 1: 15% bonus damage (from spellpower) for Fireball, Frostfire Bolt and Pyroblast
+            if ((_spec == BOT_SPEC_MAGE_FIRE) &&
+                lvl >= 45 && (baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1 || baseId == PYROBLAST_1))
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Empowered Frostbolt part 1: 10% of spellpower to Frostbolt damage
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 45 && baseId == FROSTBOLT_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Chilled to the Bone part 1: 5% bonus damage for Frostbolt, Frostfire Bolt and Ice Lance
+            if ((_spec == BOT_SPEC_MAGE_FROST) &&
+                lvl >= 55 && (baseId == FROSTBOLT_1 || baseId == FROSTFIRE_BOLT_1 || baseId == ICE_LANCE_1))
+                pctbonus += 0.05f;
+
+            //Glyph of Frostfire Bolt part 1: 2% bonus damage for Frostfire Bolt
+            if (/*lvl >= 75 && */baseId == FROSTFIRE_BOLT_1)
+                pctbonus += 0.02f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Firestarter part 2: -100% mana cost for Flamestrike
+            if (baseId == FLAMESTRIKE_1)
+                if (me->HasAura(FIRESTARTER_BUFF))
+                    pctbonus += 1.0f;
+            //Brain Freeze buff: -100% mana cost for Fireball and Frostfire Bolt while active
+            //we can check spellFamilyFlags or just use ids, going easy way here
+            if (baseId == FROSTFIRE_BOLT_1 || baseId == FIREBALL_1)
+                if (me->HasAura(BRAIN_FREEZE_BUFF))
+                    pctbonus += 1.0f;
+            //Clearcasting: -100% mana cost for damaging spells
+            if (AuraEffect const* eff = me->GetAuraEffect(ARCANE_CONCENTRATION_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+            //Missile Barrage: -100% mana cost for Arcane Missiles
+            if (baseId == ARCANEMISSILES_1)
+                if (me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x2, 0x0))
+                    pctbonus += 1.0f;
+
+            //pct mods
+            //Precision part 1: -3% mana cost for All spells
+            if (lvl >= 15)
+                pctbonus += 0.03f;
+            //Frost Channeling: -10% mana cost for all spells
+            if (lvl >= 25)
+                pctbonus += 0.1f;
+            //Improved Blink part 1: -50% mana cost for Blink
+            if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 30 && baseId == BLINK_1)
+                pctbonus += 0.5f;
+
+            //Arcane Blast: +175% mana cost for Arcane Blast (per stack)
+            if (baseId == ARCANE_BLAST_1)
+                if (AuraEffect const* bla = me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_MAGE, 0x0, 0x0, 0xC))
+                    pctbonus += -1.75f * bla->GetBase()->GetStackAmount();
+            //Arcane Power: +20% mana cost
+            if (AuraEffect const* pow = me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x80000, 0x0))
+                if (pow->IsAffectedOnSpell(spellInfo))
+                    pctbonus += -0.2f;
+
+            //Glyph of Arcane Intellect: -50% mana cost for Arcane Intellect/Brilliance
+            if (lvl >= 15 && baseId == ARCANEINTELLECT_1)
+                pctbonus += 0.5f;
+            //Glyph of Blast Wave part 1: -15% mana cost for Blast Wave
+            if (lvl >= 70 && baseId == BLAST_WAVE_1)
+                pctbonus += 0.15f;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Firestarter part 1: -100% cast time for Flamestrike
+            if (baseId == FLAMESTRIKE_1)
+                if (me->HasAura(FIRESTARTER_BUFF))
+                    timebonus += casttime;
+            //Brain Freeze: -100% cast time for Fireball and Frostfire Bolt
+            //we can check spellFamilyFlags or just use ids, going easy way here
+            if (baseId == FROSTFIRE_BOLT_1 || baseId == FIREBALL_1)
+                if (me->HasAura(BRAIN_FREEZE_BUFF))
+                    timebonus += casttime;
+            //Hot Streak: -100% cast time for Pyroblast
+            if (baseId == PYROBLAST_1)
+                if (me->HasAura(HOT_STREAK_BUFF))
+                    timebonus += casttime;
+            //Presence of Mind: -100% cast time
+            if (AuraEffect const* eff = me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x20, 0x0))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+
+            //flat mods
+            //Improved Fireball: -0.5 sec cast time for Fireball (Frostfire too for bot)
+            if (lvl >= 10 && (baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1))
+                timebonus += 500;
+            //Improved Frostbolt: -0.5 sec cast time for Frostbolt
+            if (lvl >= 10 && baseId == FROSTBOLT_1)
+                timebonus += 500;
+            //Empowered Frostbolt part 2: -0.2 sec cast time for Frostbolt
+            if (lvl >= 45 && baseId == FROSTBOLT_1)
+                timebonus += 200;
+
+            //Missile Barrage: -2.5 sec channeling time, -0.5 sec for every tick
+            if (baseId == ARCANEMISSILES_1 && me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x2, 0x0))
+                timebonus += casttime / 2;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Ice Floes: -20% cooldown for Frost Nova, Cone of Cold, Ice Block and Icy Veins
+            if (lvl >= 10 &&
+                (baseId == FROST_NOVA_1 || baseId == CONE_OF_COLD_1 || baseId == ICE_BLOCK_1 || baseId == ICY_VEINS_1))
+                pctbonus += 0.2f;
+            //Cold as Ice: -20% cooldown for Ice Barrier, Cold Snap and Summon Water Elemental
+            if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 35 &&
+                (baseId == ICE_BARRIER_1 || baseId == COLD_SNAP_1 || baseId == SUMMON_WATER_ELEMENTAL_1))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Improved Fire Blast: -2 sec cooldown for Fire Blast
+            if (lvl >= 10 && baseId == FIRE_BLAST_1)
+                timebonus += 2000;
+            //Arcane Flows part 2: -2 min cooldown for Evocation
+            if ((_spec == BOT_SPEC_MAGE_ARCANE) && lvl >= 45 && baseId == EVOCATION_1)
+                timebonus += 120000;
+            //Glyph of Water Elemental: -30 sec cooldown for Summon Water Elemental
+            if (lvl >= 50 && baseId == SUMMON_WATER_ELEMENTAL_1)
+                timebonus += 30000;
+
+            ////Pyroblast (special): ensure no double pyroblast casts
+            //if (baseId == PYROBLAST_1)
+            //    timebonus -= 3000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Increased Area (AhnQ set bonus?) 23549
+            if (lvl >= 60 && (spellInfo->SpellFamilyFlags[0] & 0x1084))
+                pctbonus += 0.25f;
+            //Arctic Reach
+            if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x240))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Blink
+            if (lvl >= 20 && baseId == BLINK_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Arctic Reach: +20% range for Frost Spells
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x200A0) || (spellInfo->SpellFamilyFlags[1] & 0x100000)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Magic Attunement: +6 yd range for Arcane Spells
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0xA1006C00) || (spellInfo->SpellFamilyFlags[1] & 0x8010)))
+                flatbonus += 6.f;
+            //Flame Throwing: +6 yd range for Fire Spells
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x400017) || (spellInfo->SpellFamilyFlags[1] & 0x20000)))
+                flatbonus += 6.f;
+
+            //Glyph of Deep Freeze
+            if (lvl >= 60 && baseId == DEEP_FREEZE_1)
+                flatbonus += 10.f;
+
+            //Mage Fire Blast Range Bonus (33066): +6 yd range for Fire Blast
+            if (lvl >= 60 && baseId == FIRE_BLAST_1)
+                flatbonus += 6.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //DEBUG
+            //if (!IAmFree())
+            //{
+            //    std::ostringstream msg;
+            //    msg << "OnClassSpellGo: " << spellInfo->SpellName[0] << " (" << spellId << ")!";
+            //    BotWhisper(msg.str().c_str());
+            //}
+
+            if (baseId == SUMMON_WATER_ELEMENTAL_1)
+                SummonBotPet();
+
+            //Mana gem conjure and use
+            if (baseId == CONJURE_MANA_GEM_1)
+            {
+                //ItemTemplate const* gem = sObjectMgr->GetItemTemplate(spellInfo->_effects[0].ItemType);
+                //ASSERT(gem);
+                //manaGemCharges = uint8(abs(gem->Spells[1].SpellCharges)); //at index 1
+
+                //Do not bother with this crap
+                manaGemCharges = 3;
+            }
+            if (baseId == MANA_GEM_1)
+            {
+                //spell cd is 1 min, item cd is 2 min, correct here
+                SetSpellCooldown(MANA_GEM_1, 120000);
+                manaGemCharges -= 1;
+            }
+
+            //special cases
+            //Pyroblast (special): ensure no double pyroblast casts
+            if (baseId == PYROBLAST_1)
+                SetSpellCooldown(PYROBLAST_1, 3000);
+
+            if (baseId == ICE_BLOCK_1)
+            {
+                //Glyph of Ice Block: reset Frost Nova cd
+                ResetSpellCooldown(FROST_NOVA_1);
+                iceblockCheckTimer = 4000;
+            }
+
+            //check for minor rotation thingy (skip common triggered on-hit spells
+            /*if (spellId != FROSTBITE_TRIGGERED && spellId != WINTERS_CHILL_TRIGGERED && spellId != IGNITE_TRIGGERED &&
+                spellId != ARCANE_CONCENTRATION_BUFF && spellId != ARCANE_POTENCY_BUFF1 && spellId != ARCANE_POTENCY_BUFF2 &&
+                spellId != FIRESTARTER_BUFF && spellId != BRAIN_FREEZE_BUFF && spellId != HOT_STREAK_BUFF)*/
+                fbCasted = (baseId == SCORCH_1 || baseId == FROSTBOLT_1 || baseId == FIREBALL_1 || baseId == FROSTFIRE_BOLT_1);
+
+            //Handle clearcasting
+            if (AuraEffect const* eff = me->GetAuraEffect(ARCANE_CONCENTRATION_BUFF, 0, me->GetGUID()))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                {
+                    //if (int32 cost = spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+                    {
+                        //me->ModifyPower(POWER_MANA, cost > 0 ? cost : 0);
+                        me->RemoveAurasDueToSpell(ARCANE_CONCENTRATION_BUFF);
+                    }
+                    //arcane potency has the same affection (damaging spells only)
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1);
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2);
+                }
+            }
+            //Handle Presence of Mind
+            bool consumed_Pom = false;
+            if (AuraEffect const* eff = me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_MAGE, 0x0, 0x20, 0x0))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                {
+                    me->RemoveAurasDueToSpell(PRESENCE_OF_MIND_1);
+                    consumed_Pom = true;
+                }
+            }
+            if (!consumed_Pom)
+            {
+                //Firestarter
+                if (baseId == FLAMESTRIKE_1)
+                    me->RemoveAurasDueToSpell(FIRESTARTER_BUFF);
+                //Brain Freeze (Fireball!)
+                if (baseId == FROSTFIRE_BOLT_1 || baseId == FIREBALL_1)
+                    me->RemoveAurasDueToSpell(BRAIN_FREEZE_BUFF);
+                //Hot Streak
+                if (baseId == PYROBLAST_1)
+                    me->RemoveAurasDueToSpell(HOT_STREAK_BUFF);
+            }
+            //Handle Cold Snap
+            if (baseId == COLD_SNAP_1)
+            {
+                SpellInfo const* cdInfo;
+                BotSpellMap const& myspells = GetSpellMap();
+                for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                {
+                    if (itr->first == baseId)
+                        continue;
+                    if (itr->second->spellId != 0 && itr->second->cooldown > 0)
+                    {
+                        cdInfo = sSpellMgr->GetSpellInfo(itr->first);
+                        if (cdInfo && cdInfo->SpellFamilyName == SPELLFAMILY_MAGE && cdInfo->GetRecoveryTime() > 0 &&
+                            (cdInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_FROST))
+                            ResetSpellCooldown(itr->first);
+                    }
+                }
+            }
+
+            //Missile Barrage
+            if (baseId == ARCANEMISSILES_1)
+                me->RemoveAurasDueToSpell(MISSILE_BARRAGE_BUFF);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (aftercastTargetGuid != ObjectGuid::Empty)
+            {
+                //only players for now
+                if (!aftercastTargetGuid.IsPlayer())
+                {
+                    aftercastTargetGuid = ObjectGuid::Empty;
+                    return;
+                }
+
+                Player* pTarget = ObjectAccessor::GetPlayer(*me, aftercastTargetGuid);
+                aftercastTargetGuid = ObjectGuid::Empty;
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->_effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->_effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, nullptr, nullptr, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, 0);
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, nullptr, nullptr);
+                                        continue;
+                                    }
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == ARCANEINTELLECT_1)
+            {
+                if (Aura* arc = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    arc->SetDuration(dur);
+                    arc->SetMaxDuration(dur);
+                }
+            }
+
+            //Spells with chill effect
+            //chill amount by spell family mask
+            //00100000 00000000 00000000 chilled (blizzard)
+            //00000200 00000000 00000000 conecold
+            //00000020 00000000 00000000 frbolt
+            //00000000 00001000 00000008 ffbolt
+            //00100220 00001000 00000000 permafrst
+            //00100220 00001000 00000000 cttbn
+            if (spell->SpellFamilyName == SPELLFAMILY_MAGE &&
+                ((spell->SpellFamilyFlags[0] & 0x100220) || (spell->SpellFamilyFlags[1] & 0x1000)))
+            {
+                //frostbolt, cone of cold, blizzard chill, frostfire bolt
+                Aura* chill = target->GetAura(spellId, me->GetGUID());
+                if (chill)
+                {
+                    //Permafrost: chill effects duration + 3 sec
+                    if (lvl >= 15)
+                    {
+                        uint32 dur = chill->GetDuration() + 3000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                    //chill effect is at index 0
+                    AuraEffect* chillEff = chill->GetEffect(0);
+                    if (chillEff)
+                    {
+                        int32 amount = chillEff->GetAmount();
+                        if (lvl >= 15)
+                            amount -= 10; //permafrost
+                        if ((_spec == BOT_SPEC_MAGE_FROST) && lvl >= 55)
+                            amount -= 10; //chilled to the bone
+                        chillEff->ChangeAmount(amount);
+                    }
+                }
+            }
+
+            //Glyph of Ice Barrier: 30% increased effect
+            if (baseId == ICE_BARRIER_1)
+            {
+                shielded = true;
+                if (lvl >= 46)
+                {
+                    AuraEffect* barr = me->GetAuraEffect(spellId, 0);
+                    if (barr)
+                        barr->ChangeAmount(barr->GetAmount() * 1.3f);
+                }
+            }
+
+            //Custom things
+            if (baseId == POLYMORPH_1)
+            {
+                poly = true;
+                polyCheckTimer = 2000;
+            }
+
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                //if (baseId == FROSTBOLT_1 && urand(1,100) <= 10)
+                //    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == ARCANE_BLAST_DEBUFF)
+                if (Aura* blas = me->GetAura(spell->Id))
+                    arcaneBlastStack = blas->GetStackAmount();
+
+            //Ward helper
+            if (spell->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) || spell->HasAura(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                if (!canFrostWard && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_FROST))
+                    canFrostWard = true;
+                if (!canFireWard && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE))
+                    canFireWard = true;
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_WATER_ELEMENTAL;
+
+            Position pos;
+
+            //glyphed: permanent
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_MANUAL_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 2, me->GetOrientation());
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, SUMMON_WATER_ELEMENTAL_1);
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_WATER_ELEMENTAL;
+                default:
+                    return 0;
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(FROSTBOLT_1) : 20.f;
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            iceblockCheckTimer = 0;
+            shieldCheckTimer = 0;
+            arcaneBlastStack = 0;
+            manaGemCharges = 0;
+
+            poly = false;
+            shielded = false;
+            fbCasted = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+            if (iceblockCheckTimer > diff)          iceblockCheckTimer -= diff;
+            if (shieldCheckTimer > diff)            shieldCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            //bool isArca = _spec == BOT_SPEC_MAGE_ARCANE;
+            bool isFire = _spec == BOT_SPEC_MAGE_FIRE;
+            bool isFros = _spec == BOT_SPEC_MAGE_FROST;
+
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(AMPLIFYMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(ARCANE_BLAST_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            InitSpellMap(INVISIBILITY_1);
+            InitSpellMap(SCORCH_1);
+            InitSpellMap(FIRE_BLAST_1);
+            InitSpellMap(FLAMESTRIKE_1);
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROST_NOVA_1);
+            InitSpellMap(CONE_OF_COLD_1);
+            InitSpellMap(BLIZZARD_1);
+            InitSpellMap(FROST_ARMOR_1);
+            InitSpellMap(ICE_ARMOR_1);
+            InitSpellMap(MOLTEN_ARMOR_1);
+            InitSpellMap(ICE_BLOCK_1);
+ /*Special*/InitSpellMap(BLIZZARD_DAMAGE_1); //important
+ /*Special*/InitSpellMap(LIVING_BOMB_DAMAGE_1); //important
+            InitSpellMap(SLOW_FALL_1);
+            InitSpellMap(ICE_LANCE_1);
+            InitSpellMap(FROST_WARD_1);
+            InitSpellMap(FIRE_WARD_1);
+
+ /*Special*/InitSpellMap(CONJURE_MANA_GEM_1);
+ /*Special*/InitSpellMap(MANA_GEM_1);
+
+            InitSpellMap(RITUAL_OF_REFRESHMENT_1); //not casted
+
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUS_MAGIC_1) : RemoveSpell(FOCUS_MAGIC_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(PRESENCE_OF_MIND_1) : RemoveSpell(PRESENCE_OF_MIND_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(ARCANE_POWER_1) : RemoveSpell(ARCANE_POWER_1);
+
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 30 && isFire ? InitSpellMap(BLAST_WAVE_1) : RemoveSpell(BLAST_WAVE_1);
+  /*Talent*/lvl >= 40 && isFire ? InitSpellMap(DRAGON_BREATH_1) : RemoveSpell(DRAGON_BREATH_1);
+  /*Talent*/lvl >= 50 && isFire ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+  /*Talent*/lvl >= 60 && isFire ? InitSpellMap(LIVING_BOMB_1) : RemoveSpell(LIVING_BOMB_1);
+
+  /*Talent*/lvl >= 20 ? InitSpellMap(ICY_VEINS_1) : RemoveSpell(ICY_VEINS_1);
+  /*Talent*/lvl >= 30 && isFros ? InitSpellMap(COLD_SNAP_1) : RemoveSpell(COLD_SNAP_1);
+  /*Talent*/lvl >= 40 && isFros ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+  /*Talent*/lvl >= 50 && isFros ? InitSpellMap(SUMMON_WATER_ELEMENTAL_1) : RemoveSpell(SUMMON_WATER_ELEMENTAL_1);
+  /*Talent*/lvl >= 60 && isFros ? InitSpellMap(DEEP_FREEZE_1) : RemoveSpell(DEEP_FREEZE_1);
+
+            InitSpellMap(FROSTFIRE_BOLT_1);
+            InitSpellMap(FIREBALL_1);
+            FROSTFIREBOLT = GetSpell(FROSTFIRE_BOLT_1) ? FROSTFIRE_BOLT_1 : FIREBALL_1;
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isArca = _spec == BOT_SPEC_MAGE_ARCANE;
+            bool isFire = _spec == BOT_SPEC_MAGE_FIRE;
+            bool isFros = _spec == BOT_SPEC_MAGE_FROST;
+
+            RefreshAura(ARCANE_CONCENTRATION, level >= 15 ? 1 : 0);
+            RefreshAura(ARCANE_MEDITATION, level >= 25 ? 1 : 0); //mana regen 1
+            RefreshAura(TORMENT_THE_WEAK, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL2, isArca && level >= 26 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL1, isArca && level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY2, isArca && level >= 36 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY1, isArca && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(ARCANE_EMPOWERMENT, isArca && level >= 40 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION3, isArca && level >= 42 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION2, isArca && level >= 41 && level < 42 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION1, isArca && level >= 40 && level < 41 ? 1 : 0);
+            RefreshAura(MISSILE_BARRAGE, isArca && level >= 45 ? 1 : 0);
+
+            RefreshAura(IGNITE, level >= 15 ? 1 : 0);
+            RefreshAura(BURNING_DETERMINATION, level >= 15 ? 1 : 0);
+            RefreshAura(IMPACT, level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_SCORCH, level >= 25 ? 1 : 0);
+            RefreshAura(MOLTEN_SHIELDS, level >= 25 ? 1 : 0);
+            RefreshAura(MASTER_OF_ELEMENTS, level >= 25 ? 1 : 0);
+            RefreshAura(BLAZING_SPEED, isFire && level >= 35 ? 1 : 0);
+            RefreshAura(PYROMANIAC, isFire && level >= 40 ? 1 : 0); //mana regen 2
+            RefreshAura(FIRESTARTER2, isFire && level >= 51 ? 1 : 0);
+            RefreshAura(FIRESTARTER1, isFire && level >= 50 && level < 51 ? 1 : 0);
+            RefreshAura(HOT_STREAK, isFire && level >= 50 ? 1 : 0);
+
+            RefreshAura(FROSTBITE3, level >= 12 ? 1 : 0);
+            RefreshAura(FROSTBITE2, level >= 11 && level < 12 ? 1 : 0);
+            RefreshAura(FROSTBITE1, level >= 10 && level < 11 ? 1 : 0);
+            RefreshAura(FROST_WARDING, level >= 15 ? 1 : 0);
+            RefreshAura(IMPROVED_BLIZZARD, level >= 20 ? 1 : 0);
+            RefreshAura(SHATTER3, level >= 27 ? 1 : 0);
+            RefreshAura(SHATTER2, level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(SHATTER1, level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL3, isFros && level >= 37 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL2, isFros && level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL1, isFros && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SHATTERED_BARRIER, isFros && level >= 45 ? 1 : 0);
+            //RefreshAura(ARCTIC_WINDS, isFros && level >= 45 ? 1 : 0); //only miss chance
+            RefreshAura(FINGERS_OF_FROST, isFros && level >= 45 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE3, isFros && level >= 53 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE2, isFros && level >= 51 && level < 52 ? 1 : 0);
+            RefreshAura(BRAIN_FREEZE1, isFros && level >= 50 && level < 51 ? 1 : 0);
+
+            RefreshAura(GLYPH_POLYMORPH, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPG_REMOVE_CURSE, level >= 18 ? 1 : 0);
+            RefreshAura(GLYPH_ICY_VEINS, level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_LIVING_BOMB, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_ICE_LANCE, level >= 66 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case AMPLIFYMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUS_MAGIC_1:
+                case PRESENCE_OF_MIND_1:
+                case ARCANE_POWER_1:
+                case ICE_ARMOR_1:
+                case ICE_BARRIER_1:
+                case COMBUSTION_1:
+                case ICY_VEINS_1:
+                case BLAST_WAVE_1:
+                case FLAMESTRIKE_1:
+                case FROST_NOVA_1:
+                case BLIZZARD_1:
+                case ICE_BLOCK_1:
+                case COLD_SNAP_1:
+                case INVISIBILITY_1:
+                case SLOW_FALL_1:
+                case CONJURE_MANA_GEM_1:
+                case SUMMON_WATER_ELEMENTAL_1:
+                    return true;
+                case FROST_ARMOR_1:
+                    return !GetSpell(ICE_ARMOR_1);
+                //case MANA_GEM_1:
+                //    return manaGemCharges > 0;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Mage_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Mage_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Mage_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Mage_spells_support;
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 FROSTFIREBOLT;
+        //Timers
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer, iceblockCheckTimer, shieldCheckTimer;
+        //Counters
+/*exc.*/uint8 arcaneBlastStack;
+/*exc.*/uint8 manaGemCharges;
+        //Check
+/*exc.*/bool poly, shielded, fbCasted;
+/*exc.*/bool canFrostWard, canFireWard;
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_necromancer_ai.cpp b/src/server/game/AI/NpcBots/bot_necromancer_ai.cpp
new file mode 100644
index 000000000..76f52cfff
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_necromancer_ai.cpp
@@ -0,0 +1,756 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+//#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+//#include "World.h"
+/*
+Necromancer NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Necromancer (Warcraft III / Disablo II tribute)
+Abilities:
+1) Shadow Bolt: main attack, single target, no mana cost
+Complete - 90%
+TODO:
+maximum skeletons for botparty
+fine-tune corpse explosion conditions
+*/
+
+enum NecromancerBaseSpells
+{
+    MAIN_ATTACK_1           = SPELL_SHADOW_BOLT2,
+    RAISE_DEAD_1            = SPELL_RAISE_DEAD,
+    UNHOLY_FRENZY_1         = SPELL_UNHOLY_FRENZY,
+    CRIPPLE_1               = SPELL_CRIPPLE,
+
+    CORPSE_EXPLOSION_1      = SPELL_CORPSE_EXPLOSION,
+    //ATTRACT_1               = SPELL_BLOOD_CURSE
+};
+enum NecromancerSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+
+    RAISE_DEAD_COST         = 50 * 5, // 75 * 5, Reduced to match playstyle (1-2,3?) necromancers
+    UNHOLY_FRENZY_COST      = 50 * 5,
+    CRIPPLE_COST            = 175 * 5,
+    CORPSE_EXPLOSION_COST   = 100 * 5,
+    //ATTRACT_COST            = 200 * 5,
+
+    MAX_MINIONS             = 6,
+
+    SPELL_SPAWN_ANIM        = 25035,
+    SPELL_BLOODY_EXPLOSION  = 36599,
+
+    MODEL_BLOODY_BONES      = 25538,
+
+    CORPSE_EXPLOSION_DAMAGE = 50444, //DK spell
+
+    CE_DAMAGE_PCT_BASE      = 35,
+    CE_DAMAGE_PCT_PER_LEVEL = 1,
+
+    CE_MIN_TARGETS          = 3
+};
+
+static const uint32 Necromancer_spells_damage_arr[] =
+{ /*MAIN_ATTACK_1, */CORPSE_EXPLOSION_1/*, ATTRACT_1*/ };
+
+static const uint32 Necromancer_spells_support_arr[] =
+{ RAISE_DEAD_1, UNHOLY_FRENZY_1, CRIPPLE_1/*, ATTRACT_1*/ };
+
+static const std::vector<uint32> Necromancer_spells_damage(FROM_ARRAY(Necromancer_spells_damage_arr));
+static const std::vector<uint32> Necromancer_spells_support(FROM_ARRAY(Necromancer_spells_support_arr));
+
+class necromancer_bot : public CreatureScript
+{
+public:
+    necromancer_bot() : CreatureScript("necromancer_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new necromancer_botAI(creature);
+    }
+
+    struct necromancer_botAI : public bot_ai
+    {
+        necromancer_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_NECROMANCER;
+
+            InitUnitFlags();
+
+            //necromancer immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_BLOCK_SPELL_FAMILY, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INTERRUPT, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void AttackStart(Unit*) override { }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void CheckCorpseExplosion(uint32 diff)
+        {
+            if (!IsSpellReady(CORPSE_EXPLOSION_1, diff) || _corpseExplosionCheckTimer > diff ||
+                me->GetLevel() < 40 || me->GetPower(POWER_MANA) < CORPSE_EXPLOSION_COST ||  Rand() > 80)
+                return;
+
+            _corpseExplosionCheckTimer = 500;
+
+            SpellInfo const* ceinfo = sSpellMgr->GetSpellInfo(GetSpell(CORPSE_EXPLOSION_1));
+            float ceradius = ceinfo->GetEffect(EFFECT_0).RadiusEntry->Radius;
+            ApplyBotSpellRadiusMods(ceinfo, ceradius);
+
+            //1. Corpse near current target
+            if ((IAmFree() || !master->GetGroup() || master->GetGroup()->GetMembersCount() <= 3) &&
+                me->GetVictim() && me->GetVictim()->GetHealth() <= me->GetMaxHealth() * 3)
+            {
+                auto corpse_pred = [this, mtar = me->GetVictim(), mindist = ceradius](Creature const* c) mutable {
+                    if (_isUsableCorpse(c) && c->GetDistance(mtar) < mindist)
+                    {
+                        mindist = c->GetDistance(mtar);
+                        return true;
+                    }
+                    return false;
+                };
+                Creature* creature = nullptr;
+                Trinity::CreatureLastSearcher searcher(me, creature, corpse_pred);
+                Cell::VisitAllObjects(me, searcher, ceinfo->RangeEntry->RangeMax[0]);
+
+                if (creature)
+                {
+                    if (doCast(creature, GetSpell(CORPSE_EXPLOSION_1)))
+                    {
+                        me->CastSpell(me, MH_ATTACK_ANIM, true);
+                        return;
+                    }
+                }
+            }
+
+            //2. Find a corpse with enough idiots around it (this one in n^2 so open for reviews)
+            {
+                auto corpse_pred = [&, this, me = me, maxmob = std::size_t(CE_MIN_TARGETS-1)](Creature const* c) mutable {
+                    if (_isUsableCorpse(c))
+                    {
+                        std::list<Unit*> units;
+                        NearbyHostileUnitCheck check(me, ceradius, this, 0, c);
+                        Trinity::UnitListSearcher searcher(c, units, check);
+                        Cell::VisitAllObjects(c, searcher, ceradius);
+                        if (units.size() > maxmob)
+                        {
+                            maxmob = units.size();
+                            return true;
+                        }
+                        return false;
+                    }
+                    return false;
+                };
+                std::list<Creature*> corpses;
+                Trinity::CreatureListSearcher searcher(me, corpses, corpse_pred);
+                Cell::VisitAllObjects(me, searcher, ceinfo->RangeEntry->RangeMax[0]);
+
+                if (Creature* corpse = corpses.empty() ? nullptr : corpses.size() == 1 ? corpses.front() :
+                    Trinity::Containers::SelectRandomContainerElement(corpses))
+                {
+                    if (doCast(corpse, GetSpell(CORPSE_EXPLOSION_1)))
+                    {
+                        me->CastSpell(me, MH_ATTACK_ANIM, true);
+                        return;
+                    }
+                }
+            }
+        }
+
+        void CheckRaiseDead(uint32 diff)
+        {
+            if (!IsSpellReady(RAISE_DEAD_1, diff) || _raiseDeadCheckTimer > diff || _minions.size() > MAX_MINIONS - 2 ||
+                me->GetPower(POWER_MANA) < RAISE_DEAD_COST || Rand() > 50)
+                return;
+
+            _raiseDeadCheckTimer = 500;
+
+            auto corpse_pred = [&, me = me, mindist = 25.f](Creature const* c) mutable {
+                if (_isUsableCorpse(c) && c->GetDistance(me) < mindist)
+                {
+                    mindist = c->GetDistance(me);
+                    return true;
+                }
+                return false;
+            };
+            Creature* creature = nullptr;
+            Trinity::CreatureLastSearcher searcher(me, creature, corpse_pred);
+            Cell::VisitAllObjects(me, searcher, 25.f);
+
+            if (creature)
+            {
+                if (doCast(creature, GetSpell(RAISE_DEAD_1)))
+                    return;
+            }
+        }
+
+        void CheckUnholyFrenzy(uint32 diff)
+        {
+            if (!IsSpellReady(UNHOLY_FRENZY_1, diff) || IAmFree() ||
+                me->GetLevel() < 30 || me->GetPower(POWER_MANA) < UNHOLY_FRENZY_COST || Rand() > 35)
+                return;
+
+            static auto frenzy_pred_player = [=](Unit const* pl) -> bool {
+                return (pl->GetVictim() && pl->IsInCombat() && IsMeleeClass(pl->GetClass()) && !IsTank(pl) &&
+                    me->GetDistance(pl) < 30 && pl->GetDistance(pl->GetVictim()) < 15 &&
+                    pl->getAttackers().empty() && !CCed(pl, true) &&
+                    !pl->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && pl->GetHealth() >= me->GetMaxHealth());
+            };
+
+            Unit* target = nullptr;
+
+            //master
+            if (frenzy_pred_player(master))
+                target = master;
+
+            //group (players + bots)
+            if (!target)
+            {
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* player = itr->GetSource();
+                        if (!player || player == master || player->IsBeingTeleported() || me->GetMap() != player->FindMap())
+                            continue;
+
+                        if (frenzy_pred_player(player))
+                        {
+                            target = player;
+                            break;
+                        }
+
+                        if (!player->HaveBot())
+                            continue;
+
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (IsMeleeClass(bot->GetBotClass()) && bot->GetVictim() && !IsTank(bot) &&
+                                bot->GetBotAI()->HasRole(BOT_ROLE_DPS) && !bot->GetBotAI()->HasRole(BOT_ROLE_RANGED) &&
+                                me->GetDistance(bot) < 30 && bot->GetDistance(bot->GetVictim()) < 15 &&
+                                bot->getAttackers().empty() && !CCed(bot, true) &&
+                                !bot->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && bot->GetHealth() >= me->GetMaxHealth())
+                            {
+                                target = bot;
+                                break;
+                            }
+                        }
+
+                        if (target)
+                            break;
+                    }
+                }
+            }
+
+            //minions
+            if (!target && HasRole(BOT_ROLE_DPS) && !_minions.empty())
+            {
+                for (Unit* minion : _minions)
+                {
+                    if (minion->GetVictim() && GetHealthPCT(minion) > 80 && me->GetDistance(minion) < 30 && !CCed(minion, true) &&
+                        !minion->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                    {
+                        target = minion;
+                        break;
+                    }
+                }
+            }
+
+            if (target && doCast(target, GetSpell(UNHOLY_FRENZY_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    ReportSpellCast(UNHOLY_FRENZY_1, LocalizedNpcText(target->ToPlayer(), BOT_TEXT__ON_YOU), target->ToPlayer());
+                return;
+            }
+
+            SetSpellCooldown(UNHOLY_FRENZY_1, 500); //fail
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            //Interrupt corpse-usage spells if no longer usable
+            if (Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+            {
+                if (Unit const* target = spell->m_targets.GetUnitTarget())
+                {
+                    if ((spell->GetSpellInfo()->GetFirstRankSpell()->Id == RAISE_DEAD_1 ||
+                        spell->GetSpellInfo()->GetFirstRankSpell()->Id == CORPSE_EXPLOSION_1) &&
+                        target->GetDisplayId() != target->GetNativeDisplayId())
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                }
+            }
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < CORPSE_EXPLOSION_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            CheckCorpseExplosion(diff);
+            CheckRaiseDead(diff);
+            CheckUnholyFrenzy(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (GC_Timer > diff)
+                return;
+
+            if (!CanAffectVictimAny(mytar, SPELL_SCHOOL_SHADOW, SPELL_SCHOOL_ARCANE))
+                return;
+
+            //Cripple
+            if (IsSpellReady(CRIPPLE_1, diff) && me->GetDistance(mytar) < 30 &&
+                me->GetLevel() >= 50 && me->GetPower(POWER_MANA) >= CRIPPLE_COST &&
+                mytar->GetMaxNegativeAuraModifier(SPELL_AURA_MOD_MELEE_HASTE) >= 0 &&
+                (mytar->GetTypeId() == TYPEID_PLAYER || mytar->GetHealth() > me->GetMaxHealth() * 3))
+            {
+                if (doCast(mytar, GetSpell(CRIPPLE_1)))
+                    return;
+            }
+
+            if (IsSpellReady(MAIN_ATTACK_1, diff) && me->GetDistance(mytar) < 30)
+            {
+                if (doCast(mytar, GetSpell(MAIN_ATTACK_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (iscrit)
+                pctbonus *= 1.333f;
+
+            if (baseId == MAIN_ATTACK_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * (spellInfo->_effects[0].BonusMultiplier - 1.f) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //flat mods
+            //Corpse Explosion radii per level
+            if (lvl > 40 && (baseId == CORPSE_EXPLOSION_1 || baseId == CORPSE_EXPLOSION_DAMAGE))
+                radius += 0.25f * (lvl - 40);
+
+            radius = radius * pctbonus;
+        }
+
+        void ApplyClassEffectMods(WorldObject const* wtarget, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Set damage for Unholy Frenzy: 45 sec 2% per second (out of average max health: bot and target)
+            if (baseId == UNHOLY_FRENZY_1 && effIndex == EFFECT_1)
+            {
+                if (Unit const* target = wtarget ? wtarget->ToUnit() : nullptr)
+                    value = CalculatePct(float((target->GetMaxHealth() + me->GetMaxHealth()) / 2), 2.f);
+            }
+
+            value = value * pctbonus;
+        }
+
+        void ApplyClassThreatMods(SpellInfo const* spellInfo, float& threat) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            if (baseId == CORPSE_EXPLOSION_DAMAGE)
+                threat = 0.f;
+
+            threat = threat * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == RAISE_DEAD_1 || baseId == UNHOLY_FRENZY_1 ||
+                baseId == CRIPPLE_1 || baseId == CORPSE_EXPLOSION_1/* || baseId == ATTRACT_1*/)
+                GC_Timer = uint32(me->GetAttackTime(BASE_ATTACK) * me->m_modAttackSpeedPct[BASE_ATTACK]);
+
+            if (baseId == MAIN_ATTACK_1 || baseId == RAISE_DEAD_1 || baseId == UNHOLY_FRENZY_1 ||
+                baseId == CRIPPLE_1/* || baseId == CORPSE_EXPLOSION_1*//* || baseId == ATTRACT_1*/)
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId != MAIN_ATTACK_1)
+            {
+                if (baseId == CORPSE_EXPLOSION_1)
+                {
+                    ASSERT(!IsInBotParty(target));
+                    target->CastSpell(target, CORPSE_EXPLOSION_VISUAL, true);
+                    target->CastSpell(target, SPELL_BLOODY_EXPLOSION, true);
+                    target->SetDisplayId(MODEL_BLOODY_BONES);
+
+                    //Corpse Explosion damage: progress with level 35 to 75% (base level 40)
+                    int32 fdamage = CalculatePct(target->GetMaxHealth(),
+                        CE_DAMAGE_PCT_BASE + CE_DAMAGE_PCT_PER_LEVEL * (uint32(me->GetLevel()) - spell->BaseLevel));
+
+                    CastSpellExtraArgs args(TRIGGERED_FULL_MASK);
+                    args.AddSpellBP0(fdamage);
+                    me->CastSpell(target, CORPSE_EXPLOSION_DAMAGE, args);
+                }
+
+                if (baseId == RAISE_DEAD_1)
+                {
+                    ASSERT(!IsInBotParty(target));
+                    //Two skeletons
+                    for (uint8 i = 0; i < 2; ++i)
+                        SummonBotPet(target);
+                    //visuals
+                    if (!target->IsPet() && !target->IsVehicle() && !target->ToCreature()->isWorldBoss() && !target->ToCreature()->IsDungeonBoss())
+                    {
+                        target->CastSpell(target, SPELL_BLOODY_EXPLOSION, true);
+                        target->SetDisplayId(MODEL_BLOODY_BONES);
+                    }
+                }
+
+                if (baseId == CRIPPLE_1)
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER || target->GetLevel() > 80)
+                    {
+                        if (Aura* crip = target->GetAura(spell->Id, me->GetGUID()))
+                        {
+                            int32 dur = std::min<int32>(crip->GetMaxDuration(), 10000);
+                            crip->SetDuration(dur);
+                            crip->SetMaxDuration(dur);
+                        }
+                    }
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            uint8 i = 0;
+            for (Summons::const_iterator citr = _minions.begin(); citr != _minions.end(); ++citr)
+            {
+                if ((*citr)->GetGUID() == summon->GetGUID())
+                    return i;
+                ++i;
+            }
+            return 0;
+        }
+
+        void SummonBotPet(Unit* from)
+        {
+            if (_minions.size() >= MAX_MINIONS)
+            {
+                Unit* u = nullptr;
+                //try 1: by minimal level
+                uint8 minlevel = me->GetLevel();
+                for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+                {
+                    if ((*itr)->GetLevel() < minlevel)
+                    {
+                        minlevel = (*itr)->GetLevel();
+                        u = *itr;
+                    }
+                }
+                //try 2: by minimal duration
+                if (!u)
+                {
+                    uint32 minduration = 0;
+                    for (Summons::const_iterator itr = _minions.begin(); itr != _minions.end(); ++itr)
+                    {
+                        if ((*itr)->GetAI()->GetData(BOTPETAI_MISC_DURATION) > minduration)
+                        {
+                            minduration = (*itr)->GetAI()->GetData(BOTPETAI_MISC_DURATION);
+                            u = *itr;
+                        }
+                    }
+                }
+                //try 3: last resort
+                if (!u)
+                    u = *(_minions.begin());
+
+                u->ToTempSummon()->UnSummon();
+            }
+
+            Position pos = from->GetPosition();
+
+            Creature* myPet = me->SummonCreature(BOT_PET_NECROSKELETON, pos, TEMPSUMMON_MANUAL_DESPAWN);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, RAISE_DEAD_1);
+
+            //dark minion immunities
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            //heal
+            myPet->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_HEAL, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_HEAL_PCT, true);
+            myPet->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_PERIODIC_HEAL, true);
+
+            myPet->CastSpell(myPet, SPELL_SPAWN_ANIM, true);
+            if (Aura* stun = myPet->AddAura(SUMMONING_DISORIENTATION, myPet))
+            {
+                stun->SetDuration(1500);
+                stun->SetMaxDuration(1500);
+            }
+
+            myPet->GetAI()->SetData(BOTPETAI_MISC_MAXLEVEL, me->GetLevel());
+            _minions.insert(myPet);
+        }
+
+        void UnsummonAll() override
+        {
+            while (!_minions.empty())
+                (*_minions.begin())->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            if (_minions.find(summon) != _minions.end())
+                _minions.erase(summon);
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_NECROSKELETON;
+                default:
+                    return 0;
+            }
+        }
+
+        void CheckAttackState() override
+        {
+        }
+
+        void OnBotEnterVehicle(Vehicle const* vehicle) override
+        {
+            me->Dismount();
+            bot_ai::OnBotEnterVehicle(vehicle);
+        }
+
+        void Reset() override
+        {
+            _corpseExplosionCheckTimer = 0;
+            _raiseDeadCheckTimer = 0;
+
+            UnsummonAll();
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (_corpseExplosionCheckTimer > diff)          _corpseExplosionCheckTimer -= diff;
+            if (_raiseDeadCheckTimer > diff)                _raiseDeadCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(MAIN_ATTACK_1, true, false);
+            InitSpellMap(RAISE_DEAD_1, true, false);
+            InitSpellMap(UNHOLY_FRENZY_1, true, false);
+            InitSpellMap(CRIPPLE_1, true, false);
+            InitSpellMap(CORPSE_EXPLOSION_1, true, false);
+            //InitSpellMap(ATTRACT_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case UNHOLY_FRENZY_1:
+                    return me->GetLevel() >= 30;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Necromancer_spells_damage;
+        }
+        //std::vector<uint32> const* GetCCSpellsList() const override
+        //{
+        //    return &Necromancer_spells_cc;
+        //}
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Necromancer_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Necromancer_spells_support;
+        }
+
+    private:
+        bool _isUsableCorpse(Creature const* c) const
+        {
+            static const uint32 ViableCreatureTypesMask =
+                (1 << (CREATURE_TYPE_BEAST-1)) | (1 << (CREATURE_TYPE_DRAGONKIN-1)) | (1 << (CREATURE_TYPE_HUMANOID-1));
+
+            return !c->IsAlive() && c->GetDisplayId() == c->GetNativeDisplayId() &&
+                !c->IsVehicle() && !c->isWorldBoss() && !c->IsDungeonBoss() &&
+                ((1 << (c->GetCreatureType()-1)) & ViableCreatureTypesMask) &&
+                !c->IsControlledByPlayer() && !c->IsNPCBot() && c->GetMaxHealth() >= me->GetMaxHealth() / 4;
+        }
+
+        uint32 _corpseExplosionCheckTimer;
+        uint32 _raiseDeadCheckTimer;
+
+        typedef std::set<Unit*> Summons;
+        Summons _minions;
+    };
+};
+
+void AddSC_necromancer_bot()
+{
+    new necromancer_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 000000000..6233c9db3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,2792 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "Creature.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+//#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - Around 95%
+TODO:
+*/
+
+enum PaladinBaseSpells// all orignals
+{
+    FLASH_OF_LIGHT_1                    = 19750,
+    HOLY_LIGHT_1                        = 635,
+    LAY_ON_HANDS_1                      = 633,
+    REDEMPTION_1                        = 7328,
+    HAND_OF_FREEDOM_1                   = 1044,
+    SACRED_SHIELD_1                     = 53601,
+    HOLY_SHOCK_1                        = 20473,
+    CLEANSE_1                           = 4987,
+    HAND_OF_PROTECTION_1                = 1022,
+    HAND_OF_SALVATION_1                 = 1038,
+    HAND_OF_SACRIFICE_1                 = 6940,
+    SEAL_OF_VENGEANCE_1                 = 31801,
+    SEAL_OF_CORRUPTION_1                = 53736,
+    SEAL_OF_COMMAND_1                   = 20375,
+    SEAL_OF_LIGHT_1                     = 20165,
+    SEAL_OF_RIGHTEOUSNESS_1             = 21084,
+    SEAL_OF_WISDOM_1                    = 20166,
+    SEAL_OF_JUSTICE_1                   = 20164,
+    DIVINE_SACRIFICE_1                  = 64205,
+    HAND_OF_RECKONING_1                 = 62124,
+    RIGHTEOUS_DEFENSE_1                 = 31789,
+    DIVINE_PLEA_1                       = 54428,
+    REPENTANCE_1                        = 20066,
+    TURN_EVIL_1                         = 10326,
+    CRUSADER_STRIKE_1                   = 35395,
+    JUDGEMENT_OF_LIGHT_1                = 20271,
+    JUDGEMENT_OF_WISDOM_1               = 53408,
+    JUDGEMENT_OF_JUSTICE_1              = 53407,
+    CONSECRATION_1                      = 26573,
+    HAMMER_OF_JUSTICE_1                 = 853,
+    DIVINE_STORM_1                      = 53385,
+    HAMMER_OF_WRATH_1                   = 24275,
+    EXORCISM_1                          = 879,
+    HOLY_WRATH_1                        = 2812,
+    AVENGING_WRATH_1                    = 31884,
+    RIGHTEOUS_FURY_1                    = 25780,
+    HOLY_SHIELD_1                       = 20925,
+    AVENGERS_SHIELD_1                   = 31935,
+    HAMMER_OF_THE_RIGHTEOUS_1           = 53595,
+    SHIELD_OF_RIGHTEOUSNESS_1           = 53600,
+    BLESSING_OF_MIGHT_1                 = 19740,
+    BLESSING_OF_WISDOM_1                = 19742,
+    BLESSING_OF_KINGS_1                 = 20217,
+    BLESSING_OF_SANCTUARY_1             = 20911,
+    DEVOTION_AURA_1                     = 465,
+    CONCENTRATION_AURA_1                = 19746,
+    FIRE_RESISTANCE_AURA_1              = 19891,
+    FROST_RESISTANCE_AURA_1             = 19888,
+    SHADOW_RESISTANCE_AURA_1            = 19876,
+    RETRIBUTION_AURA_1                  = 7294,
+    CRUSADER_AURA_1                     = 32223,
+
+    DIVINE_INTERVENTION_1               = 19752,
+    AURA_MASTERY_1                      = 31821,
+    DIVINE_FAVOR_1                      = 20216,
+    DIVINE_ILLUMINATION_1               = 31842,
+    BEACON_OF_LIGHT_1                   = 53563,
+
+    DIVINE_PROTECTION_1                 = 498,
+    DIVINE_SHIELD_1                     = 642,
+
+    PURIFY_1                            = 1152
+};
+enum PaladinPassives
+{
+//Talents
+    DIVINE_PURPOSE                      = 31872,
+    JUDGEMENTS_OF_THE_PURE              = 54155,
+    JUDGEMENTS_OF_THE_WISE              = 31878,
+    SACRED_CLEANSING                    = 53553,//rank 3
+    RECKONING1                          = 20177,
+    RECKONING2                          = 20179,
+    RECKONING3                          = 20181,
+    RECKONING4                          = 20180,
+    RECKONING5                          = 20182,
+    VINDICATION1                        = 9452,
+    VINDICATION2                        = 26016,
+    PURSUIT_OF_JUSTICE                  = 26023,//rank 2
+    ART_OF_WAR                          = 53488,//rank 2
+    IMPROVED_LAY_ON_HANDS               = 20235,//rank 2
+    FANATICISM                          = 31881,//rank 3
+    RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+    RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+    RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+    VENGEANCE1                          = 20049,//rank 1
+    VENGEANCE2                          = 20056,//rank 2
+    VENGEANCE3                          = 20057,//rank 3
+    SHEATH_OF_LIGHT1                    = 53501,//rank 1
+    SHEATH_OF_LIGHT2                    = 53502,//rank 2
+    SHEATH_OF_LIGHT3                    = 53503,//rank 3
+    ARDENT_DEFENDER                     = 31852,//rank 3
+    ILLUMINATION                        = 20215,//rank 5
+    INFUSION_OF_LIGHT                   = 53576,//rank 2
+    REDOUBT1                            = 20127,//rank 3
+    REDOUBT2                            = 20130,//rank 3
+    REDOUBT3                            = 20135,//rank 3
+    IMPROVED_RIGHTEOUS_FURY             = 20470,//rank 3
+    SHIELD_OF_THE_TEMPLAR               = 53711,//rank 3
+    IMPROVED_DEVOTION_AURA              = 20140,//rank 3
+    IMPROVED_CONCENTRATION_AURA         = 20256,//rank 3
+    SANCTIFIED_RETRIBUTION              = 31869,
+    SWIFT_RETRIBUTION                   = 53648,//rank 3
+    LIGHTS_GRACE                        = 31836,//rank 3
+    DIVINE_GUARDIAN                     = 53530,//rank 3
+    //COMBAT_EXPERTISE                    = 31860,//rank 3
+    CRUSADE                             = 31868,//rank 3
+    ONE_HANDED_WEAPON_SPECIALIZATION    = 20198,//rank 3
+    TWO_HANDED_WEAPON_SPECIALIZATION    = 20113,//rank 3
+    //JUDGEMENTS_OF_THE_JUST              = 53696,//rank 2
+    GUARDED_BY_THE_LIGHT                = 53585,//rank 2
+    TOUCHED_BY_THE_LIGHT                = 53592,//rank 3
+    HEART_OF_THE_CRUSADER               = 20337,//rank 3
+//Glyphs
+    GLYPH_HOLY_LIGHT                    = 54937,
+    GLYPH_SALVATION                     = 63225,
+//Innate
+    JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE  = 60091,
+//other
+    RECUCED_HOLY_LIGHT_CAST_TIME        = 37189,//not a typo
+    //CLEANSE_HEAL_PASSIVE                = 28787
+};
+
+enum PaladinSpecial
+{
+    NOAURA                              = 0,
+    DEVOTIONAURA                        = 1,
+    CONCENTRATIONAURA                   = 2,
+    FIRERESAURA                         = 3,
+    FROSTRESAURA                        = 4,
+    SHADOWRESAURA                       = 5,
+    RETRIBUTIONAURA                     = 6,
+    CRUSADERAURA                        = 7,
+
+    SPECIFIC_BLESSING_WISDOM            = 0x01,
+    SPECIFIC_BLESSING_KINGS             = 0x02,
+    SPECIFIC_BLESSING_SANCTUARY         = 0x04,
+    SPECIFIC_BLESSING_MIGHT             = 0x08,
+    SPECIFIC_BLESSING_MY_BLESSING       = 0x10,
+
+    SPECIFIC_AURA_DEVOTION              = 0x01,
+    SPECIFIC_AURA_CONCENTRATION         = 0x02,
+    SPECIFIC_AURA_FIRE_RES              = 0x04,
+    SPECIFIC_AURA_FROST_RES             = 0x08,
+    SPECIFIC_AURA_SHADOW_RES            = 0x10,
+    SPECIFIC_AURA_RETRIBUTION           = 0x20,
+    SPECIFIC_AURA_CRUSADER              = 0x40,
+    SPECIFIC_AURA_MY_AURA               = 0x80,
+    SPECIFIC_AURA_ALL_AUTOUSE           = (SPECIFIC_AURA_DEVOTION | SPECIFIC_AURA_CONCENTRATION | SPECIFIC_AURA_RETRIBUTION | \
+                                            SPECIFIC_AURA_FIRE_RES | SPECIFIC_AURA_FROST_RES | SPECIFIC_AURA_SHADOW_RES),
+
+    FLASH_OF_LIGHT_HEAL_PERIODIC        = 66922,
+
+    ENLIGHTENMENT_BUFF                  = 43837,
+    INFUSION_OF_LIGHT_BUFF              = 54149,//rank 2
+    THE_ART_OF_WAR_BUFF                 = 59578,//rank 2
+    //FORBEARANCE_AURA                    = 25771,
+
+    LIGHTS_GRACE_BUFF                   = 31834,
+
+    SEAL_OF_JUSTICE_STUN_AURA           = 20170,
+    JUDGEMENTS_OF_THE_JUST_AURA         = 68055, //melee attack speed reduce
+
+    //JUDGEMENT_OF_LIGHT_AURA             = 20185,
+    JUDGEMENT_OF_WISDOM_AURA            = 20186,
+    //JUDGEMENT_OF_JUSTICE_AURA           = 20184,
+
+    GREATER_BLESSING_OF_MIGHT_1         = 25782,
+    GREATER_BLESSING_OF_WISDOM_1        = 25894,
+    GREATER_BLESSING_OF_KINGS_1         = 25898,
+    GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+    BATTLESHOUT_1                       = 6673,
+
+    HOLY_SHOCK_HEAL_1                   = 25914,
+    ARDENT_DEFENDER_HEAL                = 66235,
+    JUDGEMENT_OF_COMMAND_DAMAGE         = 20467,
+    SPIRITUAL_ATTUNEMENT_ENERGIZE       = 31786,
+    SACRED_SHIELD_AURA_TRIGGERED        = 58597,
+
+    AVENGING_WRATH_MARKER_SPELL         = 61987,
+    IMMUNITY_SHIELD_MARKER_SPELL        = 61988,
+
+    IMPROVED_DEVOTION_AURA_SPELL        = 63514
+};
+
+static const uint32 Paladin_spells_damage_arr[] =
+{ AVENGERS_SHIELD_1, CONSECRATION_1, CRUSADER_STRIKE_1, DIVINE_STORM_1, EXORCISM_1, JUDGEMENT_OF_LIGHT_1,
+JUDGEMENT_OF_WISDOM_1, JUDGEMENT_OF_JUSTICE_1, HAMMER_OF_THE_RIGHTEOUS_1, HAMMER_OF_WRATH_1, HOLY_SHIELD_1,
+HOLY_SHOCK_1, HOLY_WRATH_1, SHIELD_OF_RIGHTEOUSNESS_1 };
+
+static const uint32 Paladin_spells_cc_arr[] =
+{ HAMMER_OF_JUSTICE_1, HOLY_WRATH_1, REPENTANCE_1, TURN_EVIL_1 };
+
+static const uint32 Paladin_spells_heal_arr[] =
+{ BEACON_OF_LIGHT_1, FLASH_OF_LIGHT_1, HOLY_LIGHT_1, HOLY_SHOCK_1, LAY_ON_HANDS_1 };
+
+static const uint32 Paladin_spells_support_arr[] =
+{ /*DEVOTION_AURA_1, CONCENTRATION_AURA_1, FIRE_RESISTANCE_AURA_1, FROST_RESISTANCE_AURA_1, SHADOW_RESISTANCE_AURA_1,
+RETRIBUTION_AURA_1, CRUSADER_AURA_1, */AURA_MASTERY_1, AVENGING_WRATH_1, BLESSING_OF_MIGHT_1, BLESSING_OF_WISDOM_1,
+BLESSING_OF_KINGS_1, BLESSING_OF_SANCTUARY_1, CLEANSE_1, DIVINE_FAVOR_1, DIVINE_ILLUMINATION_1, DIVINE_INTERVENTION_1,
+DIVINE_PLEA_1, DIVINE_PROTECTION_1, DIVINE_SACRIFICE_1, DIVINE_SHIELD_1, HAND_OF_FREEDOM_1, HAND_OF_PROTECTION_1,
+HAND_OF_RECKONING_1, HAND_OF_SACRIFICE_1, HAND_OF_SALVATION_1, HOLY_SHIELD_1, PURIFY_1, REDEMPTION_1,
+RIGHTEOUS_DEFENSE_1, RIGHTEOUS_FURY_1, SACRED_SHIELD_1, SEAL_OF_RIGHTEOUSNESS_1, SEAL_OF_JUSTICE_1, SEAL_OF_LIGHT_1,
+SEAL_OF_WISDOM_1, SEAL_OF_COMMAND_1, SEAL_OF_VENGEANCE_1, SEAL_OF_CORRUPTION_1 };
+
+static const std::vector<uint32> Paladin_spells_damage(FROM_ARRAY(Paladin_spells_damage_arr));
+static const std::vector<uint32> Paladin_spells_cc(FROM_ARRAY(Paladin_spells_cc_arr));
+static const std::vector<uint32> Paladin_spells_heal(FROM_ARRAY(Paladin_spells_heal_arr));
+static const std::vector<uint32> Paladin_spells_support(FROM_ARRAY(Paladin_spells_support_arr));
+
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new paladin_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct paladin_botAI : public bot_ai
+    {
+        paladin_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_PALADIN;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void CheckBeacon(uint32 diff)
+        {
+            if (checkBeaconTimer > diff || !IsSpellReady(BEACON_OF_LIGHT_1, diff) || IAmFree() || !master->GetGroup() ||
+                !HasRole(BOT_ROLE_HEAL|BOT_ROLE_RANGED) || IsCasting() || Rand() > 15)
+                return;
+
+            checkBeaconTimer = urand(2000, 5000);
+
+            if (FindAffectedTarget(GetSpell(BEACON_OF_LIGHT_1), me->GetGUID(), 60, 3))
+                return;
+
+            //find tank
+            //stacks
+            std::list<Unit*> tanks;
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsAlive() && player->IsInCombat() && IsTank(player) &&
+                    (!player->getAttackers().empty() || GetHealthPCT(player) < 90) &&
+                    !player->GetAuraEffect(SPELL_AURA_PERIODIC_TRIGGER_SPELL, SPELLFAMILY_PALADIN, 0x0, 0x1000000, 0x0, me->GetGUID()))
+                    tanks.push_back(player);
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    if (bitr->second == me)
+                        continue;
+                    if (!gr->IsMember(bitr->second->GetGUID()))
+                        continue;
+
+                    Unit* u = bitr->second;
+                    if (u->IsInWorld() && u->IsAlive() && u->IsInCombat() && IsTank(u) &&
+                        (!u->getAttackers().empty() || GetHealthPCT(u) < 90) &&
+                        !u->GetAuraEffect(SPELL_AURA_PERIODIC_TRIGGER_SPELL, SPELLFAMILY_PALADIN, 0x0, 0x1000000, 0x0, me->GetGUID()))
+                        tanks.push_back(u);
+                }
+            }
+
+            if (tanks.empty())
+                return;
+
+            Unit* target = tanks.size() == 1 ? *tanks.begin() : Trinity::Containers::SelectRandomContainerElement(tanks);
+            if (doCast(target, GetSpell(BEACON_OF_LIGHT_1)))
+                return;
+        }
+
+        void CheckSacrifice(uint32 diff)
+        {
+            if (!IsSpellReady(DIVINE_SACRIFICE_1, diff) || IAmFree() || me->IsMounted() ||
+                IsTank() || Feasting() || !CanBlock() || IsCasting() || Rand() > 25 || GetHealthPCT(me) < 60)
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (master->IsAlive() && GetHealthPCT(master) < 75 && me->GetDistance(master) < 30 && !master->getAttackers().empty() &&
+                    !master->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                {
+                    if (doCast(me, GetSpell(DIVINE_SACRIFICE_1)))
+                        return;
+                }
+            }
+            else
+            {
+                uint32 attacked = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player const* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->IsAlive() && me->GetDistance(pl) < 30 && !pl->getAttackers().empty() &&
+                        !pl->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                    {
+                        if (++attacked > 3)
+                            break;
+                    }
+
+                    if (!pl->HaveBot())
+                        continue;
+
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature const* bot = it->second;
+                        if (bot && bot->IsInWorld() && me->GetMap() == bot->FindMap() && bot->IsAlive() &&
+                            !bot->IsTempBot() && me->GetDistance(bot) < 30 && !bot->getAttackers().empty() &&
+                            !bot->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELLFAMILY_PALADIN, 3837, EFFECT_0))
+                        {
+                            if (++attacked > 3)
+                                break;
+                        }
+                    }
+                }
+
+                if (attacked > 3 && doCast(me, GetSpell(DIVINE_SACRIFICE_1)))
+                    return;
+            }
+
+            SetSpellCooldown(DIVINE_SACRIFICE_1, 1000); //fail
+        }
+
+        void CheckHandOfSacrifice(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_SACRIFICE_1, diff) || IAmFree() || me->IsMounted() ||
+                IsTank() || Feasting() || !CanBlock() || IsCasting() || Rand() > 25 || GetHealthPCT(me) < 50)
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                if (master->IsAlive() && me->GetDistance(master) < 30 && !master->getAttackers().empty() &&
+                    (master->getAttackers().size() > 2 || GetHealthPCT(master) < 50) &&
+                    !master->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                {
+                    if (doCast(master, GetSpell(HAND_OF_SACRIFICE_1)))
+                        return;
+                }
+            }
+            else
+            {
+                Unit* u = nullptr;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->IsAlive() && me->GetDistance(pl) < 30 && !pl->getAttackers().empty() &&
+                        (pl->getAttackers().size() > 2 || GetHealthPCT(pl) < 50) &&
+                        !pl->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                    {
+                        u = pl;
+                        break;
+                    }
+
+                    if (!pl->HaveBot())
+                        continue;
+
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot->IsAlive() && me->GetDistance(bot) < 30 && !bot->getAttackers().empty() &&
+                            (bot->getAttackers().size() > 2 || GetHealthPCT(bot) < 50) &&
+                            !bot->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x2000, 0x0, 0x0))
+                        {
+                            u = bot;
+                            break;
+                        }
+                    }
+                }
+
+                if (u && doCast(u, GetSpell(HAND_OF_SACRIFICE_1)))
+                    return;
+            }
+
+            SetSpellCooldown(HAND_OF_SACRIFICE_1, 2000); //fail
+        }
+
+        void ShieldGroup(uint32 diff)
+        {
+            if (checkShieldTimer > diff || !IsSpellReady(SACRED_SHIELD_1, diff) ||
+                me->IsMounted() || Feasting() || IsCasting() || Rand() > 50)
+                return;
+
+            checkShieldTimer = 1500;
+
+            Unit* u = nullptr;
+            if (IAmFree())
+            {
+                u = me;
+                if (u->IsInCombat() && (!u->getAttackers().empty() || u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) &&
+                    !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                {
+                    if (doCast(u, GetSpell(SACRED_SHIELD_1)))
+                    {}
+                }
+
+                return;
+            }
+
+            if (IsTank())
+            {
+                if (Rand() > 15)
+                    return;
+            }
+            else if (!HasRole(BOT_ROLE_HEAL) && Rand() > 10)
+                return;
+
+            if (FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 70, 3))
+                return;
+
+            bool foundTank = false;
+            Group const* gr = master->GetGroup();
+            if (!gr)
+            {
+                u = master;
+                if (u->IsAlive() && u->IsInCombat() && IsTank(u) && me->GetDistance(u) < 30 &&
+                    !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    foundTank = true;
+
+                if (!foundTank)
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        u = itr->second;
+                        if (u != me && IsTank())
+                            continue;
+                        if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                            u->ToCreature()->IsTempBot() || !IsTank(u) || me->GetDistance(u) > 30 ||
+                            u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                            continue;
+
+                        foundTank = true;
+                        break;
+                    }
+                }
+                if (!foundTank)
+                {
+                    for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                    {
+                        u = *itr;
+                        if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                            !IsTank(u) || me->GetDistance(u) > 30 ||
+                            u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                            continue;
+
+                        foundTank = true;
+                        break;
+                    }
+                }
+                if (!foundTank)
+                {
+                    u = master;
+                    if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                        !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                        foundTank = true;
+                }
+
+                if (foundTank && doCast(u, GetSpell(SACRED_SHIELD_1)))
+                    return;
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                    !IsTank(u) || me->GetDistance(u) > 30 ||
+                    u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    continue;
+
+                foundTank = true;
+                break;
+            }
+            if (!foundTank)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap())
+                        continue;
+
+                    if (pl->HaveBot())
+                    {
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                        {
+                            u = bitr->second;
+                            if (u != me && IsTank())
+                                continue;
+                            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                                bitr->second->IsTempBot() || !IsTank(u) || me->GetDistance(u) > 30 ||
+                                u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                                continue;
+
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (!foundTank)
+                    {
+                        for (Unit::ControlList::const_iterator citr = master->m_Controlled.begin(); citr != master->m_Controlled.end(); ++citr)
+                        {
+                            u = *citr;
+                            if (!u || !u->IsPet() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                                !IsTank(u) || me->GetDistance(u) > 30 ||
+                                u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                                continue;
+
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (foundTank)
+                        break;
+                }
+            }
+            if (!foundTank)
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    u = itr->GetSource();
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap())
+                        continue;
+
+                    if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                        !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                    {
+                        foundTank = true;
+                        break;
+                    }
+
+                    if (!u->ToPlayer()->HaveBot())
+                        continue;
+
+                    BotMap const* map = u->ToPlayer()->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        if (it->second->IsTempBot())
+                            continue;
+
+                        u = it->second;
+                        if (u->IsAlive() && u->IsInCombat() && !u->getAttackers().empty() && me->GetDistance(u) < 30 &&
+                            !u->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 0x0, 0x80000, 0x0))
+                        {
+                            foundTank = true;
+                            break;
+                        }
+                    }
+                    if (foundTank)
+                        break;
+                }
+            }
+
+            if (foundTank && u && doCast(u, GetSpell(SACRED_SHIELD_1)))
+                return;
+        }
+
+        void HOPGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_PROTECTION_1, diff) || IAmFree() || me->IsMounted() || Feasting() || IsCasting() ||
+                Rand() > 30)
+                return;
+
+            Unit* u;
+            Player* player = master;
+            Group const* gr = player->GetGroup();
+            if (!gr)
+            {
+                u = player;
+                if (u->IsInWorld() && me->GetMap() == u->FindMap())
+                {
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+
+                for (Unit::ControlList::const_iterator itr = player->m_Controlled.begin(); itr != player->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->isType(TYPEMASK_PLAYER) || !u->ToCreature()->IsNPCBot() || u->ToCreature()->IsTempBot() ||
+                        IsTank(u) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                    IsTank(u) || me->GetDistance(u) > 30)
+                    continue;
+                if (HOPTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        it->second->IsTempBot() || IsTank(u) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOPTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOPTarget(Unit* target, uint32 /*diff*/)
+        {
+            if (target == me ||
+                (target->GetTypeId() == TYPEID_PLAYER ? target->GetClass() == BOT_CLASS_PALADIN :
+                target->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN))
+                return false; //paladins should use their own damn bubble
+            if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 1) ||
+                target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                return false; //immune to physical (hop or smth is present)
+            if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 25))
+                return false; //forbearance
+            if (target->getAttackers().empty())
+                return false; //HOP only saves from physical, these aoe are rare and on bosses they are ultimate anyway
+
+            if (GetHealthPCT(target) < 15 + 5*(uint32)target->getAttackers().size())
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        ReportSpellCast(HAND_OF_PROTECTION_1, LocalizedNpcText(target->ToPlayer(), BOT_TEXT__ON_YOU), target->ToPlayer());
+
+                    if (!IAmFree() && target != master)
+                        ReportSpellCast(HAND_OF_PROTECTION_1, LocalizedNpcText(master, BOT_TEXT__ON_) + target->GetName() + '!', master);
+                }
+                return true;
+            }
+
+            return false;
+        }
+
+        void HOFGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_FREEDOM_1, diff) || me->IsMounted() || Feasting() || IsCasting() || Rand() > 20)
+                return;
+
+            if (IAmFree())
+            {
+                HOFTarget(me, diff);
+                return;
+            }
+
+            Unit* u;
+            Player* player = master;
+            Group const* gr = player->GetGroup();
+            if (!gr)
+            {
+                u = player;
+                if (u->IsInWorld() && me->GetMap() == u->FindMap() &&
+                    HOFTarget(u, diff))
+                    return;
+
+                for (Unit::ControlList::const_iterator itr = player->m_Controlled.begin(); itr != player->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        u->isType(TYPEMASK_PLAYER) || (!u->IsPet() && !u->ToCreature()->IsNPCBot()) ||
+                        u->ToCreature()->IsTempBot() || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOFTarget(u, diff))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || me->GetDistance(u) > 30)
+                    continue;
+                if (HOFTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() ||
+                        it->second->IsTempBot() || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOFTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 /*diff*/)
+        {
+            bool canUnstun = me->GetLevel() >= 35 && _spec == BOT_SPEC_PALADIN_RETRIBUTION;
+            if (target->HasAuraType(SPELL_AURA_MECHANIC_IMMUNITY))
+            {
+                if (target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 11) &&
+                    target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 7))
+                    return false; //immune to root and snares
+                if (canUnstun && target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, 12))
+                    return false; //immune to stuns
+            }
+
+            SpellInfo const* spellInfo;
+            AuraApplication const* app;
+            Unit::AuraApplicationMap const& auras = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                app = i->second;
+                if (!app || app->IsPositive() || app->GetBase()->IsPassive() || app->GetBase()->GetDuration() < 2000)
+                    continue;
+                spellInfo = app->GetBase()->GetSpellInfo();
+                if (spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                if (spellInfo->GetSpellMechanicMaskByEffectMask(app->GetEffectMask()) &
+                    ((1<<MECHANIC_SNARE) | (1<<MECHANIC_ROOT) | (!canUnstun ? 0 : (1<<MECHANIC_STUN))))
+                {
+                    uint32 dispel = spellInfo->Dispel;
+                    uint32 spell;
+                    //Hand of Freedom is level 12, Purify is 8, Cleanse is 42
+                    if (!GetSpell(CLEANSE))
+                        spell = (dispel == DISPEL_DISEASE || dispel == DISPEL_POISON) ?
+                        GetSpell(PURIFY_1) : GetSpell(HAND_OF_FREEDOM_1);
+                    else
+                        spell = (dispel == DISPEL_MAGIC || dispel == DISPEL_DISEASE || dispel == DISPEL_POISON) ?
+                        GetSpell(CLEANSE_1) : GetSpell(HAND_OF_FREEDOM_1);
+
+                    if (doCast(target, spell))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(uint32 diff)
+        {
+            if (!IsSpellReady(HAND_OF_SALVATION_1, diff) || IsCasting() || Rand() > 40)
+                return;
+
+            Unit* u;
+
+            if (me->GetLevel() >= 26 && (IAmFree() || IsTank()))
+            {
+                u = me;
+                if (u->IsInCombat() && !u->getAttackers().empty() &&
+                    GetHealthPCT(u) < std::max<int32>(80 - 5 * u->getAttackers().size(), 25))
+                    if (doCast(u, GetSpell(HAND_OF_SALVATION_1)))
+                    {}
+                return;
+            }
+
+            if (IAmFree())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                 return;
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() ||
+                    IsTank(u) || (IsTankingClass(u->GetClass()) && !me->GetMap()->IsRaid()) || me->GetDistance(u) > 30)
+                    continue;
+
+                if (HOSTarget(u, diff))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* pl = itr->GetSource();
+                if (!pl || !pl->IsInWorld() || me->GetMap() != pl->FindMap() || !pl->HaveBot())
+                    continue;
+
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    u = it->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive() || !u->IsInCombat() || it->second->IsTempBot() ||
+                        IsTank(u) || (IsTankingClass(u->ToCreature()->GetBotClass()) && !me->GetMap()->IsRaid()) || me->GetDistance(u) > 30)
+                        continue;
+                    if (HOSTarget(u, diff))
+                        return;
+                }
+            }
+        }
+
+        bool HOSTarget(Unit* target, uint32 /*diff*/)
+        {
+            if (target->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE, SPELLFAMILY_PALADIN, 0x100))
+                return false;
+
+            Unit::AttackerSet const& t_attackers = target->getAttackers();
+            if (t_attackers.empty())
+                return false;
+
+            for (Unit::AttackerSet::const_iterator iter = t_attackers.begin(); iter != t_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                if ((*iter)->getAttackers().size() < 3) continue; //would be useless
+                if (target->GetDistance((*iter)) < 15)
+                {
+                    if (doCast(target, GetSpell(HAND_OF_SALVATION_1)))
+                        return true;
+
+                    break; //do not try more than once on the same target
+                }
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            bool pointed = IsPointedHealTarget(target);
+            if (hp > 90 && !(pointed && me->GetMap()->IsRaid()) &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+            //try to preserve heal if Divine Plea is active
+            if (hp > 50 && me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x0, 0x1))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * 2.5f;
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * 2.5f;
+            if (xppct >= 95 && hp >= 25 && !pointed)
+                return false;
+
+            //Lay on Hands
+            if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && (target != me || shieldDelayTimer <= diff) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 80 && hp <= 20 && xppct <=0 &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        ReportSpellCast(LAY_ON_HANDS_1, LocalizedNpcText(target->ToPlayer(), BOT_TEXT__ON_YOU), target->ToPlayer());
+
+                    if (!IAmFree() && target != master)
+                    {
+                        std::string msg = target == me ? LocalizedNpcText(master, BOT_TEXT__ON_MYSELF) : (LocalizedNpcText(master, BOT_TEXT__ON_) + target->GetName() + '!');
+                        ReportSpellCast(LAY_ON_HANDS_1, msg, master);
+                    }
+                    return true;
+                }
+            }
+
+            //Holy Shock
+            if (IsSpellReady(HOLY_SHOCK_1, diff, false) && !target->IsCharmed() && !target->isPossessed() &&
+                xphploss > _heals[HOLY_SHOCK_1])
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (hp < 30 && IsSpellReady(DIVINE_FAVOR_1, diff, false) && !target->getAttackers().empty())
+                    if (doCast(me, GetSpell(DIVINE_FAVOR_1)))
+                    {}
+                if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+                    return true;
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            if (IsSpellReady(DIVINE_ILLUMINATION_1, diff, false) && GetManaPCT(me) <= 50 && Rand() < 50 + 50*tanking)
+                if (doCast(me, GetSpell(DIVINE_ILLUMINATION_1)))
+                {}
+
+            //Holy Light
+            if (IsSpellReady(HOLY_LIGHT_1, diff) && (xppct > 15 || !GetSpell(FLASH_OF_LIGHT_1)) &&
+                xphploss > _heals[HOLY_LIGHT_1])
+            {
+                //Aura Mastery
+                if (hp < 60 && _aura == CONCENTRATIONAURA && IsSpellReady(AURA_MASTERY_1, diff, false) && Rand() < 90 &&
+                    ((!me->getAttackers().empty() && (*me->getAttackers().begin())->GetTypeId() == TYPEID_PLAYER) ||
+                    me->GetMap()->Instanceable() || tanking))
+                    if (doCast(me, GetSpell(AURA_MASTERY_1)))
+                    {}
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            }
+            //Flash of Light
+            if (IsSpellReady(FLASH_OF_LIGHT_1, diff) && (tanking || xphploss > _heals[FLASH_OF_LIGHT_1]))
+            {
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_ai::JustDied(u); }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (me->GetLevel() >= 35 && _spec == BOT_SPEC_PALADIN_RETRIBUTION && IsSpellReady(HAND_OF_FREEDOM_1, diff) && Rand() < 30 && me->HasAuraWithMechanic(1<<MECHANIC_STUN))
+            {
+                if (me->IsMounted())
+                    me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+                if (doCast(me, GetSpell(HAND_OF_FREEDOM_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 30)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 60)
+                    DrinkPotion(false);
+            }
+            else if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff) && Rand() < 30 &&
+                !me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+            }
+
+            CheckRacials(diff);
+
+            HOPGroup(diff);
+            CheckBeacon(diff);
+
+            if (me->GetMap()->IsRaid())
+            {
+                CureGroup(GetSpell(CLEANSE), diff);
+                BuffAndHealGroup(diff);
+                CheckHandOfSacrifice(diff);
+                ShieldGroup(diff);
+            }
+            else
+            {
+                BuffAndHealGroup(diff);
+                CheckHandOfSacrifice(diff);
+                ShieldGroup(diff);
+                CureGroup(GetSpell(CLEANSE), diff);
+            }
+
+            CheckSacrifice(diff);
+            HOFGroup(diff);
+            HOSGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckSeal(diff);
+            CheckAura(diff);
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            Repentance(diff);
+            Counter(diff);
+            TurnEvil(diff);
+
+            CheckDivineIntervention(diff);
+            if (!me->IsAlive())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            ResurrectGroup(GetSpell(REDEMPTION_1));
+        }
+
+        void CheckSeal(uint32 diff)
+        {
+            if (checkSealTimer > diff || GC_Timer > diff || me->IsMounted() ||
+                IsCasting() || Feasting() || Rand() > 30)
+                return;
+
+            checkSealTimer = 10000;
+
+            Unit const* victim = me->GetVictim();
+
+            uint32 COMMAND = GetSpell(SEAL_OF_COMMAND_1);
+            uint32 LIGHT = GetSpell(SEAL_OF_LIGHT_1);
+            uint32 RIGHT = GetSpell(SEAL_OF_RIGHTEOUSNESS_1);
+            uint32 WISDOM = GetSpell(SEAL_OF_WISDOM_1);
+            uint32 JUSTICE = GetSpell(SEAL_OF_JUSTICE_1);
+            uint32 VENGEANCE = (me->GetRaceMask() & RACEMASK_ALLIANCE) ? GetSpell(SEAL_OF_VENGEANCE_1) : GetSpell(SEAL_OF_CORRUPTION_1);
+
+            if (VENGEANCE && victim &&
+                (victim->GetMaxHealth() > me->GetMaxHealth() * (2 + victim->getAttackers().size() / 2) ||
+                victim->GetClass() == CLASS_ROGUE))
+                COMMAND = VENGEANCE;
+
+            uint32 SEAL = 0;
+
+            if (IsMelee() && GetManaPCT(me) < 20 && WISDOM)
+                SEAL = WISDOM;
+            else if (IsTank())
+            {
+                if (JUSTICE && me->getAttackers().size() > 1)
+                    JUSTICE = 0;
+                if (JUSTICE && victim)
+                {
+                    Creature const* cre = victim->ToCreature();
+                    if (cre && cre->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL &&
+                        (cre->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_STUN-1))))
+                        JUSTICE = 0;
+                }
+                SEAL = COMMAND ? COMMAND : JUSTICE ? JUSTICE : RIGHT;
+            }
+            else if (HasRole(BOT_ROLE_DPS))
+            {
+                SEAL = WISDOM && HasRole(BOT_ROLE_HEAL) ? WISDOM : COMMAND ? COMMAND : RIGHT;
+            }
+            else if (HasRole(BOT_ROLE_HEAL))
+                SEAL = WISDOM ? WISDOM : LIGHT ? LIGHT : RIGHT;
+
+            if (SEAL && !me->HasAura(SEAL))
+                if (doCast(me, SEAL))
+                    return;
+        }
+
+        void CheckAura(uint32 diff)
+        {
+            if (checkAuraTimer > diff || GC_Timer > diff || IsCasting() ||
+                /*me->GetExactDist(master) > 40 || me->IsMounted() || Feasting() || */Rand() > 20)
+                return;
+
+            checkAuraTimer = urand(3000, 6000);
+
+            //7 paladins in group?
+            uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+            uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+            uint32 FIRE_RESISTANCE_AURA = GetSpell(FIRE_RESISTANCE_AURA_1);
+            uint32 FROST_RESISTANCE_AURA = GetSpell(FROST_RESISTANCE_AURA_1);
+            uint32 SHADOW_RESISTANCE_AURA = GetSpell(SHADOW_RESISTANCE_AURA_1);
+            uint32 RETRIBUTION_AURA = GetSpell(RETRIBUTION_AURA_1);
+            //uint32 CRUSADER_AURA = GetSpell(CRUSADER_AURA_1);
+
+            bool pureHealer = _spec == BOT_SPEC_PALADIN_HOLY;
+            bool isProt = _spec == BOT_SPEC_PALADIN_PROTECTION;
+
+            std::map<uint32 /*baseid*/, uint32 /*curid*/> idMap;
+            uint32 mask = _getAurasMask(idMap);
+
+            //for Aura Mastery allow every pure healer paladin to have their own C aura
+            //SPECIFIC_AURA_MY_AURA check still works so no spam
+            if (pureHealer)
+                mask &= ~SPECIFIC_AURA_CONCENTRATION;
+
+            //if (CRUSADER_AURA && !(mask & SPECIFIC_AURA_CRUSADER) &&
+            //    (master->IsMounted() || me->IsMounted()))
+            //{
+            //    if (doCast(me, CRUSADER_AURA))
+            //        return;
+            //}
+
+            //Has own aura or has all auras
+            if (mask & SPECIFIC_AURA_MY_AURA)
+                return;
+            else if ((mask & SPECIFIC_AURA_ALL_AUTOUSE) == SPECIFIC_AURA_ALL_AUTOUSE)
+                return;
+
+            //TODO: priority?
+            if (DEVOTION_AURA &&
+                (!(mask & SPECIFIC_AURA_DEVOTION) || idMap[DEVOTION_AURA_1] < DEVOTION_AURA) &&
+                (!RETRIBUTION_AURA || IsTank(master) || isProt))
+            {
+                if (doCast(me, DEVOTION_AURA))
+                    return;
+            }
+            if (CONCENTRATION_AURA && !(mask & SPECIFIC_AURA_CONCENTRATION) &&
+                (master->GetClass() == BOT_CLASS_MAGE || master->GetClass() == BOT_CLASS_PRIEST ||
+                master->GetClass() == BOT_CLASS_WARLOCK || master->GetClass() == BOT_CLASS_DRUID ||
+                (!IAmFree() && master->GetClass() == BOT_CLASS_PALADIN) || pureHealer))
+            {
+                if (doCast(me, CONCENTRATION_AURA))
+                    return;
+            }
+            if (RETRIBUTION_AURA &&
+                (!(mask & SPECIFIC_AURA_RETRIBUTION) || idMap[RETRIBUTION_AURA_1] < RETRIBUTION_AURA) &&
+                (IsMeleeClass(master->GetClass()) || IsMelee()))
+            {
+                if (doCast(me, RETRIBUTION_AURA))
+                    return;
+            }
+            if (FIRE_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_FIRE_RES) || idMap[FIRE_RESISTANCE_AURA_1] < FIRE_RESISTANCE_AURA))
+            {
+                if (doCast(me, FIRE_RESISTANCE_AURA))
+                    return;
+            }
+            if (FROST_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_FROST_RES) || idMap[FROST_RESISTANCE_AURA_1] < FROST_RESISTANCE_AURA))
+            {
+                if (doCast(me, FROST_RESISTANCE_AURA))
+                    return;
+            }
+            if (SHADOW_RESISTANCE_AURA &&
+                (!(mask & SPECIFIC_AURA_SHADOW_RES) || idMap[SHADOW_RESISTANCE_AURA_1] < SHADOW_RESISTANCE_AURA))
+            {
+                if (doCast(me, SHADOW_RESISTANCE_AURA))
+                    return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target == me)
+            {
+                if (uint32 rFury = GetSpell(RIGHTEOUS_FURY_1))
+                {
+                    if (IsTank())
+                    {
+                        if (!me->HasAura(rFury) && doCast(me, rFury))
+                            return true;
+                    }
+                    else if (me->HasAura(rFury))
+                        me->RemoveAurasDueToSpell(rFury);
+                }
+            }
+
+            uint32 mask = _getBlessingsMask(target);
+
+            //already has my blessing
+            if (mask & SPECIFIC_BLESSING_MY_BLESSING)
+                return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+
+            bool wisdom = (mask & SPECIFIC_BLESSING_WISDOM);
+            bool kings = (mask & SPECIFIC_BLESSING_KINGS);
+            bool sanctuary = (mask & SPECIFIC_BLESSING_SANCTUARY);
+            bool might = (mask & SPECIFIC_BLESSING_MIGHT);
+
+            if (IsTank(target))
+            {
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->GetMaxPower(POWER_MANA) > 1 && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+
+                return false;
+            }
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->GetClass();
+            else if (Creature* cre = target->ToCreature())
+                Class = cre->GetBotAI() ? cre->GetBotAI()->GetBotClass() : cre->GetClass();
+
+            switch (Class)
+            {
+                case BOT_CLASS_BM:
+                case BOT_CLASS_SPHYNX:
+                case BOT_CLASS_DREADLORD:
+                case BOT_CLASS_SPELLBREAKER:
+                case BOT_CLASS_DARK_RANGER:
+                case BOT_CLASS_NECROMANCER:
+                case BOT_CLASS_SEA_WITCH:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_PRIEST:
+                case CLASS_MAGE:
+                case CLASS_WARLOCK:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                case CLASS_ROGUE:
+                case CLASS_HUNTER:
+                case CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->GetPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->GetMaxPower(POWER_MANA) > 1 && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = nullptr)
+        {
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff) && doCast(target, GetSpell(REPENTANCE_1)))
+                    return;
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                    return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff) ? FindCastingTarget(20, 0, REPENTANCE_1) : nullptr;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            if (!target && IsSpellReady(TURN_EVIL_1, diff))
+            {
+                target = FindCastingTarget(20, 0, TURN_EVIL_1);
+                if (target && doCast(target, GetSpell(TURN_EVIL_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(HOLY_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    return;
+            }
+            if (!target && IsSpellReady(HAMMER_OF_JUSTICE_1, diff, false))
+            {
+                target = FindCastingTarget(10, 0, HAMMER_OF_JUSTICE_1);
+                if (target && doCast(target, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {}
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1)))
+                return;
+            else
+            {
+                for (Unit* mtar : { opponent, disttarget })
+                {
+                    if (mtar && (mtar->GetCreatureTypeMask() & CREATURE_TYPEMASK_DEMON_OR_UNDEAD) && !CCed(mtar) &&
+                        mtar->GetVictim() && !IsTank(mtar->GetVictim()) && mtar->GetVictim() != me &&
+                        GetHealthPCT(me) < 90 &&
+                        doCast(mtar, GetSpell(TURN_EVIL_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckDivineIntervention(uint32 diff)
+        {
+            if (!IsSpellReady(DIVINE_INTERVENTION_1, diff, !IsCasting()) || IAmFree() || IsTank() ||
+                GetManaPCT(me) > 10 || Rand() > 20)
+                return;
+
+            std::list<Unit*> players;
+
+            if (master->IsAlive() && !master->getAttackers().empty() && GetHealthPCT(master) < 15 &&
+                !master->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                players.push_back(master);
+            if (Group const* gr = master->GetGroup())
+            {
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl || pl == master || !pl->IsInWorld() || me->GetMap() != pl->FindMap() ||
+                        !pl->IsAlive() || pl->getAttackers().empty() || GetHealthPCT(pl) > 15 ||
+                        pl->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+                        continue;
+
+                    players.push_back(pl);
+                }
+            }
+
+            if (players.empty())
+                return;
+
+            Unit* target = players.size() == 1 ? players.front() : Trinity::Containers::SelectRandomContainerElement(players);
+            if (doCast(target, GetSpell(DIVINE_INTERVENTION_1)))
+                return;
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            //Divine Shield
+            if (IsSpellReady(DIVINE_SHIELD_1, diff) && shieldDelayTimer <= diff && (IAmFree() || !IsTank()) &&
+                Rand() < 80 && !me->getAttackers().empty() && GetHealthPCT(me) < 25)
+            {
+                if (doCast(me, GetSpell(DIVINE_SHIELD_1)))
+                    return;
+            }
+
+            //Holy shield
+            if (IsSpellReady(HOLY_SHIELD_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && !me->getAttackers().empty() &&
+                !me->HasAuraTypeWithMiscvalue(SPELL_AURA_SCHOOL_IMMUNITY, 127))
+            {
+                if (doCast(me, GetSpell(HOLY_SHIELD_1)))
+                    return;
+            }
+
+            auto [can_do_holy, can_do_normal] = CanAffectVictimBools(mytar, SPELL_SCHOOL_HOLY, SPELL_SCHOOL_NORMAL);
+
+            float dist = me->GetDistance(mytar);
+
+            //HAMMER OF WRATH
+            if (IsSpellReady(HAMMER_OF_WRATH_1, diff) && can_do_holy && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                mytar->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && dist < 30)
+            {
+                if (doCast(mytar, GetSpell(HAMMER_OF_WRATH_1)))
+                    return;
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = mytar->GetVictim();
+            if (IsSpellReady(HAND_OF_RECKONING_1, diff, false) && can_do_holy && u && u != me && dist < 30 &&
+                mytar->GetTypeId() == TYPEID_UNIT && !mytar->IsControlledByPlayer() &&
+                !CCed(mytar) && HasRole(BOT_ROLE_DPS) && !mytar->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80) || IsTank()) &&
+                IsInBotParty(u) && Rand() < 50)
+            {
+                if (doCast(mytar, GetSpell(HAND_OF_RECKONING_1)))
+                    return;
+            }
+            //HAND OF RECKONING 2 (distant)
+            if (IsSpellReady(HAND_OF_RECKONING_1, diff, false) && !IAmFree() && u == me && Rand() < 30 && IsTank() && HasRole(BOT_ROLE_DPS) &&
+                (IsOffTank() || master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK_OFF) == 0) &&
+                !(me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())))
+            {
+                Unit* tUnit = FindDistantTauntTarget();
+                if (tUnit)
+                {
+                    if (doCast(tUnit, GetSpell(HAND_OF_RECKONING_1)))
+                        return;
+                }
+            }
+            //RIGHTEOUS DEFENSE //No GCD
+            if (IsSpellReady(RIGHTEOUS_DEFENSE_1, diff, false) && !IAmFree() && u && u != me && IsTank() &&
+                me->GetDistance(u) < 40 && mytar->GetTypeId() == TYPEID_UNIT && !mytar->IsControlledByPlayer() &&
+                !IsTankingClass(u->GetClass()) && GetHealthPCT(u) < 80 &&
+                !CCed(mytar) && !mytar->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                IsInBotParty(u) && Rand() < 20 + 30 * u->getAttackers().size())
+            {
+                if (doCast(u, GetSpell(RIGHTEOUS_DEFENSE_1)))
+                    return;
+            }
+            //RIGHTEOUS DEFENSE 2 (distant)
+            if (IsSpellReady(RIGHTEOUS_DEFENSE_1, diff, false) && !IAmFree() && u == me && IsTank() && Rand() < 30 &&
+                !(me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())))
+            {
+                Unit* tUnit = FindDistantTauntTarget(40, true);
+                if (tUnit)
+                {
+                    if (doCast(tUnit, GetSpell(RIGHTEOUS_DEFENSE_1)))
+                        return;
+                }
+            }
+            //Divine Plea
+            if (IsSpellReady(DIVINE_PLEA_1, diff) && Rand() < 30 && GetManaPCT(me) < (IsTank() ? 90 : 7) &&
+                !me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+            {
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+            }
+            //Avenging Wrath (tank - big threat, dps - big hp, heal - divine plea counter)
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && can_do_holy && avDelayTimer <= diff &&
+                HasRole(BOT_ROLE_HEAL|BOT_ROLE_DPS) && Rand() < 35 && dist < 30 &&
+                IsTank() ? (mytar->GetTypeId() == TYPEID_UNIT && (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())) :
+                (!HasRole(BOT_ROLE_HEAL) || !HasRole(BOT_ROLE_RANGED)) ? (mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size())) :
+                (me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1) != nullptr))
+            {
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {}
+            }
+            //Avenger's shield
+            if (IsSpellReady(AVENGERS_SHIELD_1, diff) && can_do_holy && CanBlock() &&
+                HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 60)
+            {
+                if (doCast(mytar, GetSpell(AVENGERS_SHIELD_1)))
+                    return;
+            }
+            //Divine Protection tanks only
+            if (IsSpellReady(DIVINE_PROTECTION_1, diff, false) && shieldDelayTimer <= diff && IsTank() && Rand() < 80 &&
+                !me->getAttackers().empty() && GetHealthPCT(me) < 67 - 20*me->HasAuraType(SPELL_AURA_PERIODIC_HEAL))
+            {
+                if (doCast(me, GetSpell(DIVINE_PROTECTION_1)))
+                    return;
+            }
+            //Exorcism (have cast window or instant)
+            if (IsSpellReady(EXORCISM_1, diff) && can_do_holy && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 70 &&
+                ((IsTank() && dist > 12) || (HasRole(BOT_ROLE_RANGED) && !HasRole(BOT_ROLE_HEAL)) ||
+                me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x0, 0x2)))
+            {
+                if (doCast(mytar, GetSpell(EXORCISM_1)))
+                    return;
+            }
+            //Hammer of Justice
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(mytar) && dist < 10 && Rand() < 20 &&
+                mytar->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2 &&
+                !IsImmunedToMySpellEffect(mytar, sSpellMgr->GetSpellInfo(HAMMER_OF_JUSTICE_1), EFFECT_0))
+            {
+                if (doCast(mytar, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    return;
+            }
+            //Judgement
+            if (GetSpellCooldown(JUDGEMENT_OF_LIGHT_1) <= diff && can_do_holy && HasRole(BOT_ROLE_DPS) && Rand() < 120)
+            {
+                uint32 JUDGEMENT = 0;
+
+                if (GetSpell(JUDGEMENT_OF_JUSTICE_1) && mytar->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED) &&
+                    dist < CalcSpellMaxRange(JUDGEMENT_OF_JUSTICE_1))
+                {
+                    //has joj from someone else
+                    bool canCast = true;
+                    Unit::AuraEffectList const& notSpeedAuras = mytar->GetAuraEffectsByType(SPELL_AURA_USE_NORMAL_MOVEMENT_SPEED);
+                    for (Unit::AuraEffectList::const_iterator itr = notSpeedAuras.begin(); itr != notSpeedAuras.end(); ++itr)
+                    {
+                        if ((*itr)->GetCasterGUID() != me->GetGUID() && (*itr)->GetBase()->GetDuration() > 2000)
+                        {
+                            canCast = false;
+                            break;
+                        }
+                    }
+                    if (canCast)
+                    {
+                        //has sprint or something
+                        Unit::AuraEffectList const& speedAuras = mytar->GetAuraEffectsByType(SPELL_AURA_MOD_INCREASE_SPEED);
+                        for (Unit::AuraEffectList::const_iterator itr = speedAuras.begin(); itr != speedAuras.end(); ++itr)
+                        {
+                            if (!(*itr)->GetBase()->IsPassive() &&
+                                (*itr)->GetBase()->GetDuration() > 2000 &&
+                                (*itr)->GetAmount() >= 30)
+                            {
+                                JUDGEMENT = JUDGEMENT_OF_JUSTICE_1;
+                                break;
+                            }
+                        }
+                    }
+                }
+                if (!JUDGEMENT && GetSpell(JUDGEMENT_OF_WISDOM_1) && dist < CalcSpellMaxRange(JUDGEMENT_OF_WISDOM_1))
+                {
+                    //from 35% to 50% mana
+                    AuraEffect const* wisd = mytar->GetAuraEffect(JUDGEMENT_OF_WISDOM_AURA, 0);
+                    //AuraEffect const* wisd = mytar->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_PALADIN, 3014, 0);
+                    uint8 myManaPct = GetManaPCT(me);
+                    if ((!wisd && myManaPct < 35) || (wisd && wisd->GetCasterGUID() == me->GetGUID() && myManaPct < 50))
+                        JUDGEMENT = JUDGEMENT_OF_WISDOM_1;
+                }
+                if (!JUDGEMENT && GetSpell(JUDGEMENT_OF_LIGHT_1) && dist < CalcSpellMaxRange(JUDGEMENT_OF_LIGHT_1))
+                {
+                    JUDGEMENT = JUDGEMENT_OF_LIGHT_1;
+                }
+
+                //Conditional spell unavailable, use any other
+                if (!JUDGEMENT)
+                {
+                    if (GetSpell(JUDGEMENT_OF_WISDOM_1))
+                        JUDGEMENT = JUDGEMENT_OF_WISDOM_1;
+                    else if (GetSpell(JUDGEMENT_OF_LIGHT_1))
+                        JUDGEMENT = JUDGEMENT_OF_LIGHT_1;
+                    else if (GetSpell(JUDGEMENT_OF_JUSTICE_1))
+                        JUDGEMENT = JUDGEMENT_OF_JUSTICE_1;
+                }
+
+                if (JUDGEMENT && doCast(mytar, GetSpell(JUDGEMENT)))
+                    return;
+            }
+            //Consecration
+            if (IsSpellReady(CONSECRATION_1, diff) && can_do_holy && HasRole(BOT_ROLE_DPS) && dist < 5 &&
+                !mytar->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                    return;
+            }
+            //Hammer of the Righteous (1h only)
+            if (IsSpellReady(HAMMER_OF_THE_RIGHTEOUS_1, diff) && can_do_holy && HasRole(BOT_ROLE_DPS) &&
+                dist < 5 && Rand() < 80)
+            {
+                Item const* weapMH = GetEquips(BOT_SLOT_MAINHAND);
+                if (weapMH &&
+                    (weapMH->GetTemplate()->InventoryType == INVTYPE_WEAPON ||
+                    weapMH->GetTemplate()->InventoryType == INVTYPE_WEAPONMAINHAND) &&
+                    doCast(mytar, GetSpell(HAMMER_OF_THE_RIGHTEOUS_1)))
+                    return;
+            }
+            //Shield of Righteousness
+            if (IsSpellReady(SHIELD_OF_RIGHTEOUSNESS_1, diff) && can_do_holy && HasRole(BOT_ROLE_DPS) && CanBlock() &&
+                (IsTank() || IAmFree()) && dist < 5 && Rand() < 90)
+            {
+                if (doCast(mytar, GetSpell(SHIELD_OF_RIGHTEOUSNESS_1)))
+                    return;
+            }
+            //Crusader Strike (2h only)
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && dist < 5 && Rand() < 90)
+            {
+                Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+                if (mh && mh->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                    if (doCast(mytar, GetSpell(CRUSADER_STRIKE_1)))
+                        return;
+            }
+            //Divine Storm (2h only)
+            if (IsSpellReady(DIVINE_STORM_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 40)
+            {
+                Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+                if (mh && mh->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                    if (doCast(me, GetSpell(DIVINE_STORM_1)))
+                        return;
+            }
+            //Holy Wrath
+            if (IsSpellReady(HOLY_WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if ((mytar->GetCreatureType() == CREATURE_TYPE_UNDEAD || mytar->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                    dist < 8.5f && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    return;
+                else
+                {
+                    if (FindUndeadCCTarget(8.5f, HOLY_WRATH_1, false) &&
+                        doCast(me, GetSpell(HOLY_WRATH_1)))
+                        return;
+                }
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Sanctified Light: 6% additional critical chance for Holy Light and Holy Shock
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 30 && (baseId == HOLY_LIGHT_1 || baseId == HOLY_SHOCK_1))
+                crit_chance += 6.f;
+            //Holy Power: 5% additional critical chance for Holy spells
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 35 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 5.f;
+            //Improved Flash of Light (id: 20251): 6% additional critical chance for Flash of Light
+            if (lvl >= 70 && baseId == FLASH_OF_LIGHT_1)
+                crit_chance += 6.f;
+            //Glyph of Flash of Light: 5% additional critical chance for Flash of Light
+            if (lvl >= 20 && baseId == FLASH_OF_LIGHT_1)
+                crit_chance += 5.f;
+            //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 45 && baseId == HAMMER_OF_WRATH_1)
+                crit_chance += 50.f;
+            //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 45 && spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+                crit_chance += 18.f;
+            //Infusion of Light
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 0))
+                    if (infu->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 20.f;
+            }
+            if (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1)
+            {
+                if (AuraEffect const* favo = me->GetAuraEffect(DIVINE_FAVOR_1, 0))
+                    if (favo->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 100.f;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*iscrit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (iscrit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 25 && baseId == EXORCISM_1)
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || baseId == CRUSADER_STRIKE_1 || baseId == DIVINE_STORM_1))
+                pctbonus += 0.1f;
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                baseId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+            //Glyph of Exorcism: 20% bonus damage for Exorcism
+            if (lvl >= 50 && baseId == EXORCISM_1)
+                pctbonus += 0.2f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*iscrit*/) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (iscrit)
+            //{
+            //}
+
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+            //Improved Consecration (id: 38422): 10% bonus damage for Consecration
+            if (lvl >= 20 && spellId == GetSpell(CONSECRATION_1))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Divine Plea: 50% reduced healing for all spells
+            if (/*lvl >= 71 && */me->GetAuraEffect(SPELL_AURA_OBS_MOD_POWER, SPELLFAMILY_PALADIN, 0x0, 0x80004000, 0x1))
+                pctbonus -= 0.5f;
+
+            //Healing Light: 12% bonus healing for Holy Light, Flash of Light and Holy Shock
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 15 && (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1))
+                pctbonus += 0.12f;
+            //Glyph of Seal of Light: 5% bonus healing for all spells
+            if (lvl >= 30 && me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x2000000, 0x0))
+                pctbonus += 0.05f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Benediction: -10% mana cost for Instant spells
+            if (lvl >= 10 && !spellInfo->CalcCastTime())
+                pctbonus += 0.1f;
+            //Blessed Hands: -30% mana cost for Hand spells
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x2110))
+                pctbonus += 0.3f;
+            //Holy Light Cost Reduction (id: 60148): -5% mana cost for Holy Light
+            if (lvl >= 30 && baseId == HOLY_LIGHT_1)
+                pctbonus += 0.05f;
+            //Consecration Discount (id: 37180): -15% mana cost for Consecration
+            if (lvl >= 30 && baseId == CONSECRATION_1)
+                pctbonus += 0.15f;
+            //Glyph of Seal of Wisdom: -5% mana cost for all healing spells (for bot it is all spells)
+            if (lvl >= 15 && me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_PALADIN, 0x0, 0x4000000, 0x0))
+                pctbonus += 0.05f;
+            //Glyph of Shield of Righteous: -80% mana cost for Shield of Righteous
+            if (lvl >= 75 && (spellInfo->SpellFamilyFlags[1] & 0x100000))
+                pctbonus += 0.8f;
+
+            //flat mods
+            //Cleanse Cost Reduced (id: 27847): -25 mana cost for Cleanse
+            if (lvl >= 40 && baseId == CLEANSE_1)
+                flatbonus += 25;
+            //Reduced Holy Light Cost (id: 37739): -34 mana cost for Holy Light
+            if (lvl >= 40 && baseId == HOLY_LIGHT_1)
+                flatbonus += 34;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Turn Evil: -100% cast time for Turn Evil
+            if (lvl >= 24 && baseId == TURN_EVIL_1)
+                timebonus += casttime;
+            if (baseId == FLASH_OF_LIGHT_1 || baseId == EXORCISM_1)
+            {
+                //The Art of War
+                AuraEffect const* arto = me->GetAuraEffect(THE_ART_OF_WAR_BUFF, 0);
+                //Infusion of Light
+                AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 1);
+                if (arto && arto->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+                else if (infu && infu->IsAffectedOnSpell(spellInfo))
+                    timebonus += casttime;
+            }
+
+            //flat mods
+            //Improved Holy Light (id: 24457): -0.1 sec cast time for Holy Light
+            if (lvl >= 40 && baseId == HOLY_LIGHT_1)
+                timebonus += 100;
+            //Recuced Holy Light Cast Time (id: 37189): -0.5 sec cast time for Holy Light (works only for healers)
+            //Light's Grace: -0.5 sec cast time for Holy Light
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* enli = me->GetAuraEffect(ENLIGHTENMENT_BUFF, 0))
+                    if (enli->IsAffectedOnSpell(spellInfo))
+                        timebonus += 500;
+                if (AuraEffect const* grac = me->GetAuraEffect(LIGHTS_GRACE_BUFF, 0))
+                    if (grac->IsAffectedOnSpell(spellInfo))
+                        timebonus += 500;
+            }
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Improved Judgements: -2 sec cooldown for judgements
+            //Judgment Cooldown Reduction (60153): -1 sec cooldown for judgements
+            //Judgement Cooldown Reduction (61776): -1 sec cooldown for judgements
+            if (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (lvl >= 70)
+                    timebonus += 4000;
+                else if (lvl >= 60)
+                    timebonus += 3000;
+                else if (lvl >= 15)
+                    timebonus += 2000;
+            }
+            //Sacred Duty: -60 sec cooldown for Divine Shield and Divine Protection
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 35 && (baseId == DIVINE_SHIELD_1 || baseId == DIVINE_PROTECTION_1))
+                timebonus += 60000;
+            //Reduced Righteous Defense Cooldown (37181): -2 sec cooldown for Righteous Defense
+            if (lvl >= 60 && baseId == RIGHTEOUS_DEFENSE_1)
+                timebonus += 2000;
+            //Paladin T9 Tank 2P Bonus part 1: -2 sec cooldown for Hand of Reckoning
+            if (lvl >= 78 && baseId == HAND_OF_RECKONING_1)
+                timebonus += 2000;
+            //Glyph of Turn Evil: +8 sec cooldown for Turn Evil
+            if (lvl >= 24 && baseId == TURN_EVIL_1)
+                timebonus -= 8000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Purifying Power part 2: -33% cooldown for Exorcism and Holy Wrath
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 35 && (baseId == EXORCISM_1 || baseId == HOLY_WRATH_1))
+                pctbonus += 0.333f;
+            //Glyph of Avenging Wrath: -50% cooldown for Hammer of Wrath if Avenging Wrath is active
+            if (lvl >= 70 && baseId == HAMMER_OF_WRATH_1 &&
+                me->GetAuraEffect(SPELL_AURA_MOD_HEALING_DONE_PERCENT, SPELLFAMILY_PALADIN, 0x0, 0x2000, 0x0))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Improved Judgements: -2 sec cooldown for judgements
+            //Judgment Cooldown Reduction (60153): -1 sec cooldown for judgements
+            //Judgement Cooldown Reduction (61776): -1 sec cooldown for judgements
+            if (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                if (lvl >= 70)
+                    timebonus += 4000;
+                else if (lvl >= 60)
+                    timebonus += 3000;
+                else if (lvl >= 15)
+                    timebonus += 2000;
+            }
+            //Guardian's Favor part 1: -120 sec cooldown for Hand of Protection
+            if (lvl >= 15 && baseId == HAND_OF_PROTECTION_1)
+                timebonus += 120000;
+            //Improved Hammer of Justice: -20 sec cooldown for Hammer of Justice
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 25 && baseId == HAMMER_OF_JUSTICE_1)
+                timebonus += 20000;
+            //Judgements of the Just: -10 sec cooldown for Hammer of Justice (tanks only)
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 55 && baseId == HAMMER_OF_JUSTICE_1)
+                timebonus += 10000;
+            //Glyph of Holy Shock: -1 sec cooldown for Holy Shock
+            if (baseId == HOLY_SHOCK_1)
+                timebonus += 1000;
+            //Glyph of Consecration: +2 sec cooldown for Consecration
+            if (lvl >= 20 && baseId == CONSECRATION_1)
+                timebonus -= 2000;
+            //Glyph of Holy Wrath: -15 sec cooldown for Holy Wrath
+            if (lvl >= 50 && baseId == HOLY_WRATH_1)
+                timebonus += 15000;
+            //Improved Lay on Hands (part 2): -4 min cooldown for Lay on Hands
+            if (lvl >= 20 && baseId == LAY_ON_HANDS_1)
+                timebonus += 240000;
+            //Glyph of Lay on Hands: -5 min cooldown for Lay on Hands (only healers)
+            if (lvl >= 15 && HasRole(BOT_ROLE_HEAL) && baseId == LAY_ON_HANDS_1)
+                timebonus += 300000;
+            //Lay Hands (id: 28774): -4 min cooldown for Lay on Hands (only healers)
+            if (lvl >= 60 && HasRole(BOT_ROLE_HEAL) && baseId == LAY_ON_HANDS_1)
+                timebonus += 240000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            ////Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            ////Holy Reach
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Increased Aura Radii (23565)
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x4020048))
+                flatbonus += 10.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Enlightened Judgements: +30 yd range for Judgement of Light and Judgement of Wisdom (healers)
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 55 && (spellInfo->SpellFamilyFlags[0] & 0x800000))
+                flatbonus += 30.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Hammer of the Righteous: +1 target
+            if (spellInfo->SpellFamilyFlags[1] & 0x40000)
+                bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Improved Devotion Aura: 50% increased effect
+            if (baseId == DEVOTION_AURA_1 && effIndex == EFFECT_0 && _spec == BOT_SPEC_PALADIN_PROTECTION && lvl >= 25)
+                pctbonus *= 1.5f;
+            //Improved Devotion Aura: 6% bonus healing
+            if (baseId == IMPROVED_DEVOTION_AURA_SPELL && effIndex == EFFECT_1 && _spec == BOT_SPEC_PALADIN_PROTECTION && lvl >= 25)
+                value += 6.f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == HOLY_LIGHT_1 || baseId == FLASH_OF_LIGHT_1 || baseId == HOLY_SHOCK_1)
+            {
+                if (AuraEffect const* favo = me->GetAuraEffect(DIVINE_FAVOR_1, 0))
+                    if (favo->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(DIVINE_FAVOR_1);
+            }
+
+            if (baseId == HOLY_LIGHT_1)
+            {
+                if (AuraEffect const* enli = me->GetAuraEffect(ENLIGHTENMENT_BUFF, 0))
+                    if (enli->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(ENLIGHTENMENT_BUFF);
+                if (AuraEffect const* grac = me->GetAuraEffect(LIGHTS_GRACE_BUFF, 0))
+                    if (grac->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(LIGHTS_GRACE_BUFF);
+                if (AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 0))
+                    if (infu->IsAffectedOnSpell(spellInfo))
+                        me->RemoveAurasDueToSpell(INFUSION_OF_LIGHT_BUFF);
+            }
+
+            if (baseId == EXORCISM_1 || baseId == FLASH_OF_LIGHT_1)
+            {
+                //Infusion of Light takes priority since AoW affects Exorcism too
+                AuraEffect const* infu = me->GetAuraEffect(INFUSION_OF_LIGHT_BUFF, 1);
+                //The Art of War
+                AuraEffect const* arto = me->GetAuraEffect(THE_ART_OF_WAR_BUFF, 0);
+                if (arto && arto->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(THE_ART_OF_WAR_BUFF);
+                else if (infu && infu->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(INFUSION_OF_LIGHT_BUFF);
+            }
+
+            if (baseId == DIVINE_SACRIFICE_1)
+            {
+                _sacDamage = 0;
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Beacon of Light: 30 sec increased duration
+            if (baseId == BEACON_OF_LIGHT_1)
+            {
+                Aura* beac = target->GetAura(spellId, me->GetGUID());
+                if (beac)
+                {
+                    uint32 dur = beac->GetDuration() + 30000;
+                    beac->SetDuration(dur);
+                    beac->SetMaxDuration(dur);
+                }
+            }
+            //Judgements of the Just melee attack speed reduction part 1
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && lvl >= 55 && spell->GetCategory() == SPELLCATEGORY_JUDGEMENT)
+            {
+                me->CastSpell(target, JUDGEMENTS_OF_THE_JUST_AURA, true);
+            }
+            //Judgements of the Just melee attack speed reduction part 2
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && spellId == JUDGEMENTS_OF_THE_JUST_AURA)
+            {
+                AuraEffect* slow = target->GetAuraEffect(JUDGEMENTS_OF_THE_JUST_AURA, 1, me->GetGUID());
+                if (slow)
+                    slow->ChangeAmount(slow->GetAmount() - 20);
+            }
+
+            if ((_spec == BOT_SPEC_PALADIN_PROTECTION) && spellId == SEAL_OF_JUSTICE_STUN_AURA)
+            {
+                if (lvl >= 55)
+                {
+                    //Judgements of the Just: 1 sec increased duration
+                    Aura* stun = target->GetAura(spellId, me->GetGUID());
+                    if (stun)
+                    {
+                        uint32 dur = stun->GetDuration() + 1000;
+                        stun->SetDuration(dur);
+                        stun->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == CONSECRATION_1)
+            {
+                if (lvl >= 30)
+                {
+                    //Glyph of Consecration: 2 sec increased duration
+                    Aura* cons = target->GetAura(spellId, me->GetGUID());
+                    if (cons)
+                    {
+                        uint32 dur = cons->GetDuration() + 2000;
+                        cons->SetDuration(dur);
+                        cons->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_RETRIBUTION) && baseId == RETRIBUTION_AURA_1)
+            {
+                if (lvl >= 30)
+                {
+                    //Sanctified Retribution: 50% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 3 / 2);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && baseId == CONCENTRATION_AURA_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Concentration Aura: 15% increased effect (flat)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() + 15); //base = 35, bonus = 15
+                }
+            }
+            if (baseId == FLASH_OF_LIGHT_HEAL_PERIODIC)
+            {
+                if ((_spec == BOT_SPEC_PALADIN_HOLY) && lvl >= 78 && !HasRole(BOT_ROLE_TANK | BOT_ROLE_DPS))
+                {
+                    //Paldin T9 Holy 4P Bonus: 100% increased healing from Infusion of Light (pure healers only)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 2);
+                }
+            }
+            if (baseId == BLESSING_OF_WISDOM_1)
+            {
+                if (lvl >= 25)
+                {
+                    //Improved Blessing of Wisdom: 20% increased effect
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                        eff->ChangeAmount(eff->GetAmount() * 6 / 5);
+                }
+            }
+            if (baseId == BLESSING_OF_MIGHT_1)
+            {
+                if (lvl >= 15)
+                {
+                    //Improved Blessing of Might: 25% increased effect
+                    if (Aura* migh = target->GetAura(spellId, me->GetGUID()))
+                        for (uint8 i = 0; i != EFFECT_2; ++i) // 2 effects
+                            if (AuraEffect* eff = migh->GetEffect(i))
+                                eff->ChangeAmount((eff->GetAmount() * 125) / 100);
+                }
+            }
+            if (baseId == HAND_OF_FREEDOM_1)
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && baseId == HAND_OF_SALVATION_1 && !IsTank(target))
+            {
+                //Blessed Hands (part 2)
+                if (AuraEffect* hos = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    hos->ChangeAmount(hos->GetAmount() * 2);
+                }
+            }
+            if ((_spec == BOT_SPEC_PALADIN_HOLY) && baseId == HAND_OF_SACRIFICE_1)
+            {
+                //Blessed Hands (part 3)
+                if (AuraEffect* hos = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    hos->ChangeAmount(hos->GetAmount() + 10);
+                }
+            }
+            if (baseId == BLESSING_OF_KINGS_1 || baseId == BLESSING_OF_MIGHT_1 ||
+                baseId == BLESSING_OF_WISDOM_1 || baseId == BLESSING_OF_SANCTUARY_1)
+            {
+                //Blessings duration 1h
+                if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    bless->SetDuration(dur);
+                    bless->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == SACRED_SHIELD_AURA_TRIGGERED || baseId == SACRED_SHIELD_1)
+            {
+                //Divine Guardian (part 2): 20% increased absorb, +100% duration
+                Aura* shi = target->GetAura(spellId, me->GetGUID());
+                if (shi)
+                {
+                    uint32 dur = shi->GetDuration() * 2;
+                    shi->SetDuration(dur);
+                    shi->SetMaxDuration(dur);
+                    if (baseId == SACRED_SHIELD_AURA_TRIGGERED)
+                    {
+                        if (AuraEffect* eff = shi->GetEffect(EFFECT_0))
+                            eff->ChangeAmount(eff->GetAmount() * 6 / 5);
+                    }
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Glyph of Seal of Vengeance
+            if (baseId == SEAL_OF_VENGEANCE_1 || baseId == SEAL_OF_CORRUPTION_1)
+            {
+                AuraEffect* sea = me->GetAuraEffect(spell->Id, 1);
+                if (sea)
+                    sea->ChangeAmount(sea->GetAmount() + 10);
+            }
+
+            //Aura Helper
+            if (caster == me)
+            {
+                if (baseId == DEVOTION_AURA_1)
+                    _aura = DEVOTIONAURA;
+                if (baseId == CONCENTRATION_AURA_1)
+                    _aura = CONCENTRATIONAURA;
+                if (baseId == FIRE_RESISTANCE_AURA_1)
+                    _aura = FIRERESAURA;
+                if (baseId == FROST_RESISTANCE_AURA_1)
+                    _aura = FROSTRESAURA;
+                if (baseId == SHADOW_RESISTANCE_AURA_1)
+                    _aura = SHADOWRESAURA;
+                if (baseId == RETRIBUTION_AURA_1)
+                    _aura = RETRIBUTIONAURA;
+                if (baseId == CRUSADER_AURA_1)
+                    _aura = CRUSADERAURA;
+            }
+
+            //immunity markers
+            if (baseId == AVENGING_WRATH_MARKER_SPELL)
+                avDelayTimer = 30000;
+            if (baseId == IMMUNITY_SHIELD_MARKER_SPELL)
+                shieldDelayTimer = 30000;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void OnBotDamageTaken(Unit* /*attacker*/, uint32 damage, CleanDamage const* /*cleanDamage*/, DamageEffectType /*damagetype*/, SpellInfo const* spellInfo) override
+        {
+            // Divine Sacrifice helper - calculate remaining damage amount and find if we can be one-shot'ed
+            if (damage && _sacDamage < int32(me->GetMaxHealth() / 4))
+            {
+                if (spellInfo && spellInfo->Id == DIVINE_SACRIFICE_1)
+                    _sacDamage -= int32(damage);
+                else
+                    _sacDamage += int32(damage);
+
+                if (me->GetHealth() - _sacDamage < me->GetMaxHealth() / 5)
+                {
+                    if (me->GetAuraEffect(SPELL_AURA_SPLIT_DAMAGE_PCT, SPELLFAMILY_PALADIN, 0x0, 0x0, 0x4, me->GetGUID()))
+                    {
+                        _sacDamage = me->GetMaxHealth();
+                        me->RemoveAurasDueToSpell(DIVINE_SACRIFICE_1, me->GetGUID());
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        //healer may be nullptr
+        void HealReceived(Unit* healer, uint32& heal) override
+        {
+            //Spiritual Attunement (double the effect on bots)
+            if (heal && (_spec == BOT_SPEC_PALADIN_PROTECTION) && me->GetLevel() >= 40 && healer != me && GetLostHP(me))
+            {
+                if (int32 basepoints = int32(CalculatePct(std::min<int32>(heal, GetLostHP(me)), 20)))
+                {
+                    CastSpellExtraArgs args(true);
+                    args.AddSpellBP0(basepoints);
+                    me->CastSpell(me, SPIRITUAL_ATTUNEMENT_ENERGIZE, args);
+                }
+            }
+
+            //bot_ai::HealReceived(healer, heal);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(GetSpell(EXORCISM_1) ? EXORCISM_1 : JUDGEMENT_OF_LIGHT_1) : 10.f;
+        }
+
+        void Reset() override
+        {
+            checkAuraTimer = 0;
+            checkSealTimer = 0;
+            checkShieldTimer = 0;
+            checkBeaconTimer = 0;
+            avDelayTimer = 0;
+            shieldDelayTimer = 0;
+            _aura = NOAURA;
+            _sacDamage = 0;
+
+            CLEANSE = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (checkAuraTimer > diff)              checkAuraTimer -= diff;
+            if (checkSealTimer > diff)              checkSealTimer -= diff;
+            if (checkShieldTimer > diff)            checkShieldTimer -= diff;
+            if (checkBeaconTimer > diff)            checkBeaconTimer -= diff;
+            if (avDelayTimer > diff)                avDelayTimer -= diff;
+            if (shieldDelayTimer > diff)            shieldDelayTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isHoly = _spec == BOT_SPEC_PALADIN_HOLY;
+            bool isProt = _spec == BOT_SPEC_PALADIN_PROTECTION;
+            bool isRetr = _spec == BOT_SPEC_PALADIN_RETRIBUTION;
+
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+            InitSpellMap(JUDGEMENT_OF_LIGHT_1);
+            InitSpellMap(JUDGEMENT_OF_WISDOM_1);
+            InitSpellMap(JUDGEMENT_OF_JUSTICE_1);
+            InitSpellMap(CONSECRATION_1);
+            InitSpellMap(HAMMER_OF_WRATH_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(RIGHTEOUS_FURY_1);
+            InitSpellMap(SHIELD_OF_RIGHTEOUSNESS_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(FIRE_RESISTANCE_AURA_1);
+            InitSpellMap(FROST_RESISTANCE_AURA_1);
+            InitSpellMap(SHADOW_RESISTANCE_AURA_1);
+            InitSpellMap(RETRIBUTION_AURA_1);
+            InitSpellMap(CRUSADER_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HAND_OF_FREEDOM_1);
+            InitSpellMap(HAND_OF_SALVATION_1);
+            InitSpellMap(HAND_OF_SACRIFICE_1);
+            InitSpellMap(HAND_OF_RECKONING_1);
+            InitSpellMap(RIGHTEOUS_DEFENSE_1);
+            //InitSpellMap(PURIFY_1);
+            //InitSpellMap(CLEANSE_1);
+            InitSpellMap(SEAL_OF_LIGHT_1);
+            InitSpellMap(SEAL_OF_RIGHTEOUSNESS_1);
+            InitSpellMap(SEAL_OF_WISDOM_1);
+            InitSpellMap(SEAL_OF_JUSTICE_1);
+            InitSpellMap((me->GetRaceMask() & RACEMASK_ALLIANCE) ? SEAL_OF_VENGEANCE_1 : SEAL_OF_CORRUPTION_1);
+            InitSpellMap(DIVINE_INTERVENTION_1);
+            InitSpellMap(DIVINE_PROTECTION_1);
+            InitSpellMap(DIVINE_SHIELD_1);
+
+  /*Talent*/lvl >= (isHoly ? 20 : 70) ? InitSpellMap(AURA_MASTERY_1) : RemoveSpell(AURA_MASTERY_1);
+  /*Talent*/lvl >= 30 && isHoly ? InitSpellMap(DIVINE_FAVOR_1) : RemoveSpell(DIVINE_FAVOR_1);
+  /*Talent*/lvl >= 40 && isHoly ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+  /*Talent*/lvl >= 50 && isHoly ? InitSpellMap(DIVINE_ILLUMINATION_1) : RemoveSpell(DIVINE_ILLUMINATION_1);
+  /*Talent*/lvl >= 60 && isHoly ? InitSpellMap(BEACON_OF_LIGHT_1) : RemoveSpell(BEACON_OF_LIGHT_1);
+
+  /*Talent*/lvl >= (isProt ? 20 : isHoly ? 70 : 99) ? InitSpellMap(DIVINE_SACRIFICE_1) : RemoveSpell(DIVINE_SACRIFICE_1);
+  /*Talent*/lvl >= 30 && isProt ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+  /*Talent*/lvl >= 40 && isProt ? InitSpellMap(HOLY_SHIELD_1) : RemoveSpell(HOLY_SHIELD_1);
+  /*Talent*/lvl >= 50 && isProt ? InitSpellMap(AVENGERS_SHIELD_1) : RemoveSpell(AVENGERS_SHIELD_1);
+  /*Talent*/lvl >= 60 && isProt ? InitSpellMap(HAMMER_OF_THE_RIGHTEOUS_1) : RemoveSpell(HAMMER_OF_THE_RIGHTEOUS_1);
+
+  /*Talent*/lvl >= 20 && isRetr ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 40 && isRetr ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+  /*Talent*/lvl >= 50 && isRetr ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+  /*Talent*/lvl >= 60 && isRetr ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+
+            CLEANSE = InitSpell(me, CLEANSE_1) ? CLEANSE_1 : PURIFY_1;
+            RemoveSpell(CLEANSE_1);
+            RemoveSpell(PURIFY_1);
+            InitSpellMap(CLEANSE);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isHoly = _spec == BOT_SPEC_PALADIN_HOLY;
+            bool isProt = _spec == BOT_SPEC_PALADIN_PROTECTION;
+            bool isRetr = _spec == BOT_SPEC_PALADIN_RETRIBUTION;
+
+            RefreshAura(ILLUMINATION, isHoly && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_LAY_ON_HANDS, isHoly && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_CONCENTRATION_AURA, isHoly && level >= 25 ? 1 : 0);
+            RefreshAura(LIGHTS_GRACE, isHoly && level >= 40 ? 1 : 0);
+            RefreshAura(SACRED_CLEANSING, isHoly && level >= 45 ? 1 : 0);
+            RefreshAura(JUDGEMENTS_OF_THE_PURE, isHoly && level >= 50 ? 1 : 0);
+            RefreshAura(INFUSION_OF_LIGHT, isHoly && level >= 55 ? 1 : 0);
+            RefreshAura(RECUCED_HOLY_LIGHT_CAST_TIME, isHoly && level >= 60 ? 1 : 0); //
+
+            RefreshAura(IMPROVED_RIGHTEOUS_FURY, isProt && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOTION_AURA, isProt && level >= 25 ? 1 : 0);
+            RefreshAura(DIVINE_GUARDIAN, isProt && level >= 25 ? 1 : 0);
+            RefreshAura(RECKONING5, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(RECKONING4, isProt && level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(RECKONING3, isProt && level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(RECKONING2, isProt && level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(RECKONING1, isProt && level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(ONE_HANDED_WEAPON_SPECIALIZATION, isProt && level >= 35 ? 1 : 0);
+            RefreshAura(ARDENT_DEFENDER, isProt && level >= 40 ? 1 : 0);
+            //RefreshAura(COMBAT_EXPERTISE, isProt && level >= 45 ? 1 : 0);
+            RefreshAura(REDOUBT3, isProt && level >= 55 ? 1 : 0);
+            RefreshAura(REDOUBT2, isProt && level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(REDOUBT1, isProt && level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(GUARDED_BY_THE_LIGHT, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(TOUCHED_BY_THE_LIGHT, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(SHIELD_OF_THE_TEMPLAR, isProt && level >= 55 ? 1 : 0);
+            //RefreshAura(JUDGEMENTS_OF_THE_JUST, isProt && level >= 55 ? 1 : 0);
+
+            RefreshAura(HEART_OF_THE_CRUSADER, isRetr && level >= 15 ? 1 : 0);
+            RefreshAura(PURSUIT_OF_JUSTICE, isRetr && level >= 20 ? 1 : 0);
+            RefreshAura(FANATICISM, isRetr && level >= 20 ? 1 : 0);
+            RefreshAura(VINDICATION2, isRetr && level >= 25 ? 1 : 0);
+            RefreshAura(VINDICATION1, isRetr && level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(CRUSADE, isRetr && level >= 25 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, isRetr && level >= 30 ? 1 : 0);
+            RefreshAura(SANCTIFIED_RETRIBUTION, isRetr && level >= 30 ? 1 : 0);
+            RefreshAura(VENGEANCE3, isRetr && level >= 40 ? 1 : 0);
+            RefreshAura(VENGEANCE2, isRetr && level >= 37 && level < 40 ? 1 : 0);
+            RefreshAura(VENGEANCE1, isRetr && level >= 35 && level < 37 ? 1 : 0);
+            RefreshAura(DIVINE_PURPOSE, isRetr && level >= 35 ? 1 : 0);
+            RefreshAura(JUDGEMENTS_OF_THE_WISE, isRetr && level >= 40 ? 1 : 0);
+            RefreshAura(ART_OF_WAR, isRetr && level >= 40 ? 1 : 0);
+            RefreshAura(SWIFT_RETRIBUTION, isRetr && level >= 50 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT3, isRetr && level >= 60 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT2, isRetr && level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(SHEATH_OF_LIGHT1, isRetr && level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE3, isRetr && level >= 60 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE2, isRetr && level >= 57 && level < 60 ? 1 : 0);
+            RefreshAura(RIGHTEOUS_VENGEANCE1, isRetr && level >= 55 && level < 57 ? 1 : 0);
+
+            RefreshAura(GLYPH_HOLY_LIGHT, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_SALVATION, level >= 26 ? 1 : 0);
+
+            RefreshAura(JUDGEMENT_ANTI_PARRY_DODGE_PASSIVE);
+
+            //RefreshAura(CLEANSE_HEAL_PASSIVE, level >= 58 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HAND_OF_FREEDOM_1:
+                case SACRED_SHIELD_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HAND_OF_SALVATION_1:
+                case HAND_OF_SACRIFICE_1:
+                //case SEAL_OF_COMMAND_1:
+                //case SEAL_OF_LIGHT_1:
+                //case SEAL_OF_RIGHTEOUSNESS_1:
+                //case SEAL_OF_WISDOM_1:
+                //case SEAL_OF_JUSTICE_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                case HOLY_SHOCK_1:
+                    return HasRole(BOT_ROLE_HEAL);
+                case DEVOTION_AURA_1:
+                    return _aura != DEVOTIONAURA;
+                case CONCENTRATION_AURA_1:
+                    return _aura != CONCENTRATIONAURA;
+                case FIRE_RESISTANCE_AURA_1:
+                    return _aura != FIRERESAURA;
+                case FROST_RESISTANCE_AURA_1:
+                    return _aura != FROSTRESAURA;
+                case SHADOW_RESISTANCE_AURA_1:
+                    return _aura != SHADOWRESAURA;
+                case RETRIBUTION_AURA_1:
+                    return _aura != RETRIBUTIONAURA;
+                case CRUSADER_AURA_1:
+                    return _aura != CRUSADERAURA;
+                case PURIFY_1:
+                    return !GetSpell(CLEANSE_1);
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(Player const* player, std::list<std::string> &specList) override
+        {
+            uint32 textId;
+            switch (_aura)
+            {
+                case DEVOTIONAURA:      textId = BOT_TEXT_DEVOTION;         break;
+                case CONCENTRATIONAURA: textId = BOT_TEXT_CONCENTRATION;    break;
+                case FIRERESAURA:       textId = BOT_TEXT_FIRERESISTANCE;   break;
+                case FROSTRESAURA:      textId = BOT_TEXT_FROSTRESISTANCE;  break;
+                case SHADOWRESAURA:     textId = BOT_TEXT_SHADOWRESISTANCE; break;
+                case RETRIBUTIONAURA:   textId = BOT_TEXT_RETRIBUTION;      break;
+                case CRUSADERAURA:      textId = BOT_TEXT_CRUSADER;         break;
+                case NOAURA: default:   textId = BOT_TEXT_NOAURA;           break;
+            }
+            specList.push_back(LocalizedNpcText(player, BOT_TEXT_AURA) + ": " + LocalizedNpcText(player, textId));
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Paladin_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Paladin_spells_cc;
+        }
+        std::vector<uint32> const* GetHealingSpellsList() const override
+        {
+            return &Paladin_spells_heal;
+        }
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Paladin_spells_support;
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, HOLY_SHOCK_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HOLY_SHOCK_HEAL_1));
+                _heals[HOLY_SHOCK_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[HOLY_SHOCK_1] = 0;
+
+            if (InitSpell(me, HOLY_LIGHT_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HOLY_LIGHT_1));
+                _heals[HOLY_LIGHT_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[HOLY_LIGHT_1] = 0;
+
+            if (InitSpell(me, FLASH_OF_LIGHT_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, FLASH_OF_LIGHT_1));
+                _heals[FLASH_OF_LIGHT_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[FLASH_OF_LIGHT_1] = 0;
+        }
+
+    private:
+        //Spells
+        uint32 CLEANSE;
+        //Timers
+/*misc*/uint32 checkAuraTimer, checkSealTimer, checkShieldTimer, checkBeaconTimer, avDelayTimer, shieldDelayTimer;
+        //Special
+/*misc*/uint8 _aura;
+/*misc*/int32 _sacDamage;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+
+        //uint32 _getBlessingsMask(Unit const*) const
+        //Scans target for auras which are related to paladin's blessings
+        //(even if aura is just incompatible with one)
+        //returns applied blessings mask
+        //used for finding out which blessings target lacks
+        uint32 _getBlessingsMask(Unit const* target) const
+        {
+            uint32 mask = 0;
+
+            bool blessing;
+            Unit::AuraApplicationMap const& aurapps = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                blessing = true;
+                switch (itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id)
+                {
+                    case BLESSING_OF_WISDOM_1:
+                    case GREATER_BLESSING_OF_WISDOM_1:
+                        mask |= SPECIFIC_BLESSING_WISDOM;
+                        break;
+                    case BLESSING_OF_KINGS_1:
+                    case GREATER_BLESSING_OF_KINGS_1:
+                        mask |= SPECIFIC_BLESSING_KINGS;
+                        break;
+                    case BLESSING_OF_SANCTUARY_1:
+                    case GREATER_BLESSING_OF_SANCTUARY_1:
+                        mask |= SPECIFIC_BLESSING_SANCTUARY;
+                        break;
+                    case BLESSING_OF_MIGHT_1:
+                    case GREATER_BLESSING_OF_MIGHT_1:
+                    case BATTLESHOUT_1:
+                        mask |= SPECIFIC_BLESSING_MIGHT;
+                        break;
+                    default:
+                        blessing = false; //next aura
+                        break;
+                }
+
+                if (blessing && itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                    mask |= SPECIFIC_BLESSING_MY_BLESSING;
+            }
+
+            return mask;
+        }
+        //uint32 _getAurasMask(Unit const*) const
+        //Scans target for paladin's auras
+        //returns applied auras mask
+        //used for finding out which auras target lacks
+        uint32 _getAurasMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            uint32 baseId;
+            bool isAura;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                isAura = true;
+                baseId = itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    case DEVOTION_AURA_1:
+                        mask |= SPECIFIC_AURA_DEVOTION;
+                        break;
+                    case CONCENTRATION_AURA_1:
+                        mask |= SPECIFIC_AURA_CONCENTRATION;
+                        break;
+                    case FIRE_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_FIRE_RES;
+                        break;
+                    case FROST_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_FROST_RES;
+                        break;
+                    case SHADOW_RESISTANCE_AURA_1:
+                        mask |= SPECIFIC_AURA_SHADOW_RES;
+                        break;
+                    case RETRIBUTION_AURA_1:
+                        mask |= SPECIFIC_AURA_RETRIBUTION;
+                        break;
+                    case CRUSADER_AURA_1:
+                        mask |= SPECIFIC_AURA_CRUSADER;
+                        break;
+                    default:
+                        isAura = false; //next aura
+                        break;
+                }
+
+                if (isAura)
+                {
+                    idMap[baseId] = itr->first;
+                    if (itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                        mask |= SPECIFIC_AURA_MY_AURA;
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 000000000..a90c233f7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,2118 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "Group.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+/*
+Priest NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - Around 90%
+TODO: Mana Burn, Binding Heal, Lightwell
+*/
+
+enum PriestBaseSpells
+{
+    DISPEL_MAGIC_1                      = 527,
+    MASS_DISPEL_1                       = 32375,
+    CURE_DISEASE_1                      = 528,
+    ABOLISH_DISEASE_1                   = 552,
+    FEAR_WARD_1                         = 6346,
+    PAIN_SUPPRESSION_1                  = 33206,
+    PSYCHIC_SCREAM_1                    = 8122,
+    FADE_1                              = 586,
+    PSYCHIC_HORROR_1                    = 64044,
+    SILENCE_1                           = 15487,
+    PENANCE_1                           = 47540,
+    VAMPIRIC_EMBRACE_1                  = 15286,
+    DISPERSION_1                        = 47585,
+    MIND_SEAR_1                         = 48045,
+    GUARDIAN_SPIRIT_1                   = 47788,
+    SHACKLE_UNDEAD_1                    = 9484,
+    LESSER_HEAL_1                       = 2050,
+    NORMAL_HEAL_1                       = 2054,
+    GREATER_HEAL_1                      = 2060,
+    RENEW_1                             = 139,
+    FLASH_HEAL_1                        = 2061,
+    PRAYER_OF_HEALING_1                 = 596,
+    CIRCLE_OF_HEALING_1                 = 34861,
+    DIVINE_HYMN_1                       = 64843,
+    PRAYER_OF_MENDING_1                 = 33076,
+    RESURRECTION_1                      = 2006,
+    PW_SHIELD_1                         = 17,
+    INNER_FIRE_1                        = 588,
+    PW_FORTITUDE_1                      = 1243,
+    SHADOW_PROTECTION_1                 = 976,
+    DIVINE_SPIRIT_1                     = 14752,
+    HOLY_FIRE_1                         = 14914,
+    SMITE_1                             = 585,
+    SW_PAIN_1                           = 589,
+    MIND_BLAST_1                        = 8092,
+    SW_DEATH_1                          = 32379,
+    DEVOURING_PLAGUE_1                  = 2944,
+    MIND_FLAY_1                         = 15407,
+    VAMPIRIC_TOUCH_1                    = 34914,
+    SHADOWFORM_1                        = 15473,
+    INNER_FOCUS_1                       = 14751,
+    DESPERATE_PRAYER_1                  = 19236,
+    POWER_INFUSION_1                    = 10060,
+    HYMN_OF_HOPE_1                      = 64901,
+
+    LEVITATE_1                          = 1706
+};
+enum PriestPassives
+{
+//Talents
+    UNBREAKABLE_WILL                = 14791,//rank 5
+    SPIRIT_TAP                      = 15336,//rank 3
+    IMPROVED_SPIRIT_TAP             = 15338,//rank 2
+    MEDITATION                      = 14777,//rank 3
+    INSPIRATION1                    = 14892,
+    INSPIRATION2                    = 15362,
+    INSPIRATION3                    = 15363,
+    SHADOW_WEAVING1                 = 15257,
+    SHADOW_WEAVING2                 = 15331,
+    SHADOW_WEAVING3                 = 15332,
+    SURGE_OF_LIGHT                  = 33154,//rank 2
+    IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+    HOLY_CONCENTRATION              = 34860,//rank 3
+    RENEWED_HOPE                    = 57472,//rank 3
+    RAPTURE                         = 47537,//rank 3
+    BODY_AND_SOUL1                  = 64127,
+    SERENDIPITY                     = 63737,//rank 3
+    IMPROVED_SHADOWFORM             = 47570,//rank 2
+    MISERY1                         = 33191,
+    MISERY2                         = 33192,
+    MISERY3                         = 33193,
+    DIVINE_AEGIS                    = 47515,//rank 3
+    GRACE                           = 47517,//rank 2
+    EMPOWERED_RENEW1                = 63534,
+    EMPOWERED_RENEW2                = 63542,
+    EMPOWERED_RENEW3                = 63543,
+    BORROWED_TIME                   = 52800,//rank 5
+//Glyphs
+    //GLYPH_SW_PAIN                   = 55681,
+    GLYPH_PW_SHIELD                 = 55672,
+    GLYPH_DISPEL_MAGIC              = 55677,
+    GLYPH_PRAYER_OF_HEALING         = 55680,
+    GLYPH_SHADOW                    = 55689,
+//other
+    PRIEST_T10_2P_BONUS             = 70770 //33% renew
+};
+enum PriestSpecial
+{
+    SHADOW_WEAVING_BUFF             = 15258,
+    MIND_FLAY_DAMAGE                = 58381,
+    MIND_SEAR_DAMAGE_1              = 49821,
+    SW_DEATH_BACKLASH               = 32409,
+    WEAKENED_SOUL_DEBUFF            = 6788,
+    SURGE_OF_LIGHT_BUFF             = 33151,
+    SERENDIPITY_BUFF                = 63734,
+    DIVINE_HYMN_HEAL                = 64844,
+    PRAYER_OF_MENDING_AURA_1        = 41635,
+    PRAYER_OF_MENDING_HEAL          = 33110,
+    PENANCE_HEAL_1                  = 47750,
+    IMPROVED_MIND_BLAST_DEBUFF      = 48301,//Mind Trauma
+    HYMN_OF_HOPE_BUFF               = 64904,
+
+    SHADOWFIEND_1                   = 34433
+};
+
+static const uint32 Priest_spells_damage_arr[] =
+{ DEVOURING_PLAGUE_1, HOLY_FIRE_1, MIND_BLAST_1, MIND_FLAY_1, MIND_SEAR_1, PENANCE_1, SMITE_1, SW_PAIN_1, SW_DEATH_1,
+VAMPIRIC_TOUCH_1 };
+
+static const uint32 Priest_spells_cc_arr[] =
+{ PSYCHIC_HORROR_1, PSYCHIC_SCREAM_1, SHACKLE_UNDEAD_1, SILENCE_1 };
+
+static const uint32 Priest_spells_heal_arr[] =
+{ RENEW_1, FLASH_HEAL_1, LESSER_HEAL_1, NORMAL_HEAL_1, GREATER_HEAL_1, PRAYER_OF_HEALING_1, PRAYER_OF_MENDING_1,
+GUARDIAN_SPIRIT_1, PENANCE_1, DIVINE_HYMN_1, CIRCLE_OF_HEALING_1, DESPERATE_PRAYER_1 };
+
+static const uint32 Priest_spells_support_arr[] =
+{ PW_FORTITUDE_1, DIVINE_SPIRIT_1, SHADOW_PROTECTION_1, ABOLISH_DISEASE_1, CURE_DISEASE_1,
+DISPEL_MAGIC_1, MASS_DISPEL_1, DISPERSION_1, FADE_1, FEAR_WARD_1, HYMN_OF_HOPE_1, INNER_FIRE_1, INNER_FOCUS_1,
+LEVITATE_1, PAIN_SUPPRESSION_1, POWER_INFUSION_1, PW_SHIELD_1, RESURRECTION_1, SHADOWFORM_1, VAMPIRIC_EMBRACE_1 };
+
+static const std::vector<uint32> Priest_spells_damage(FROM_ARRAY(Priest_spells_damage_arr));
+static const std::vector<uint32> Priest_spells_cc(FROM_ARRAY(Priest_spells_cc_arr));
+static const std::vector<uint32> Priest_spells_heal(FROM_ARRAY(Priest_spells_heal_arr));
+static const std::vector<uint32> Priest_spells_support(FROM_ARRAY(Priest_spells_support_arr));
+
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new priest_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct priest_botAI : public bot_ai
+    {
+        priest_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_PRIEST;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void CheckHymnOfHope(uint32 diff)
+        {
+            if (!IsSpellReady(HYMN_OF_HOPE_1, diff) || IAmFree() || Rand() > 45 || IsCasting() || IsTank())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                return;
+
+            uint8 LMPcount = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || me->GetMap() != player->FindMap())
+                    continue;
+                if (player->IsAlive() && player->IsInCombat() && me->GetDistance(player) < 40 &&
+                    GetManaPCT(player) < (HasRole(BOT_ROLE_HEAL) ? 10 : 50) &&
+                    !player->GetAuraEffect(SPELL_AURA_MOD_INCREASE_ENERGY, SPELLFAMILY_PRIEST, 0x0, 0x0, 0x10))
+                    if (++LMPcount > 2)
+                        break;
+
+                if (!player->HaveBot())
+                    continue;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (bot->IsInWorld() && bot->IsAlive() && bot->IsInCombat() && me->GetDistance(bot) < 40 &&
+                        GetManaPCT(bot) < (HasRole(BOT_ROLE_HEAL) ? 10 : 50) &&
+                        !bot->GetAuraEffect(SPELL_AURA_MOD_INCREASE_ENERGY, SPELLFAMILY_PRIEST, 0x0, 0x0, 0x10))
+                        if (++LMPcount > 2)
+                            break;
+                }
+                if (LMPcount > 2)
+                    break;
+            }
+            if (LMPcount > 2 && doCast(me, GetSpell(HYMN_OF_HOPE_1)))
+                return;
+        }
+
+        bool MassGroupHeal(uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (IAmFree() || !master->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 65 + 40 * me->GetMap()->IsRaid()) return false;
+
+            Group const* gr = master->GetGroup();
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player const* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (tPlayer->IsAlive() && tPlayer->IsInCombat() && me->GetDistance(tPlayer) < 48)
+                    {
+                        uint32 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            if (++LHPcount > 2)
+                                break;
+                    }
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature const* bot = it->second;
+                        if (bot && bot->IsAlive() && bot->IsInCombat() && GetHealthPCT(bot) < 60 &&
+                            GetLostHP(bot) > 4000 && me->GetDistance(bot) < 48)
+                            if (++LHPcount > 2)
+                                break;
+                    }
+                    if (LHPcount > 2)
+                        break;
+                }
+                if (LHPcount > 2 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                    return true;
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    //uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (tPlayer->IsAlive() && GetHealthPCT(tPlayer) < 65 && me->GetDistance(tPlayer) < 36)
+                        if (++LHPcount > 3)
+                            break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot->IsInWorld() && bot->IsAlive() && GetHealthPCT(bot) < 65 && me->GetDistance(bot) < 36)
+                            if (++LHPcount > 3)
+                                break;
+                    }
+                    if (LHPcount > 3)
+                        break;
+                }
+
+                if (LHPcount > 3)
+                {
+                    if (me->IsInCombat() && IsSpellReady(INNER_FOCUS_1, diff) && GetManaPCT(me) < 70 &&
+                        doCast(me, GetSpell(INNER_FOCUS_1)))
+                    {}
+                    if (doCast(me, GetSpell(PRAYER_OF_HEALING_1)))
+                        return true;
+                }
+            }
+            if (IsSpellReady(CIRCLE_OF_HEALING_1, diff))
+            {
+                Unit* castTarget = nullptr;
+                uint8 LHPcount = 0;
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                        continue;
+                    if (GetHealthPCT(tPlayer) < 85 && me->GetDistance(tPlayer) < 40 &&
+                        (!castTarget || castTarget->GetDistance(tPlayer) < 18))
+                    {
+                        ++LHPcount;
+                        if (GetHealthPCT(tPlayer) < lowestPCT)
+                        {
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot())
+                        continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && GetHealthPCT(bot) < 85 && me->GetDistance(bot) < 40 &&
+                            (!castTarget || castTarget->GetDistance(bot) < 18))
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            {
+                                lowestPCT = GetHealthPCT(bot);
+                                castTarget = bot;
+                            }
+                        }
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 1 && castTarget && doCast(castTarget, GetSpell(CIRCLE_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldGroup(uint32 diff)
+        {
+            if (GC_Timer > diff || IAmFree() || IsCasting()) return false;
+            if (!IsSpellReady(PW_SHIELD_1, diff)) return false;
+            if (Rand() > 65 + 100 * (me->GetMap()->IsRaid())) return false;
+            if (me->GetLevel() >= 30 && _spec != BOT_SPEC_PRIEST_DISCIPLINE &&
+                master->GetBotMgr()->HasBotWithSpec(BOT_SPEC_PRIEST_DISCIPLINE))
+                return false;
+
+            Group const* gr = master->GetGroup();
+            Unit* u = master;
+            if (!gr)
+            {
+                if (u->IsAlive() && !u->getAttackers().empty() && (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                    ShieldTarget(u, diff))
+                    return true;
+                BotMap const* map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && !u->getAttackers().empty() && !u->ToCreature()->IsTempBot() &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+                for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsPet() || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->IsTotem()) continue;
+                    if (u->IsAlive() && !u->getAttackers().empty() &&
+                        !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsTempBot()) &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+                return false;
+            }
+
+            for (GroupReference const* gitr = gr->GetFirstMember(); gitr != nullptr; gitr = gitr->next())
+            {
+                Player* tPlayer = gitr->GetSource();
+                if (!tPlayer || me->GetMap() != tPlayer->FindMap() || tPlayer->isPossessed() || tPlayer->IsCharmed())
+                    continue;
+                u = tPlayer;
+                if (u->IsAlive() && !u->getAttackers().empty() && (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                    ShieldTarget(u, diff))
+                    return true;
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        u = itr->second;
+                        if (u->IsAlive() && !u->getAttackers().empty() && !u->ToCreature()->IsTempBot() &&
+                            (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                            ShieldTarget(u, diff))
+                            return true;
+                    }
+                }
+                for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+                {
+                    u = *itr;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || u->IsTotem()) continue;
+                    if (u->IsAlive() && !u->getAttackers().empty() &&
+                        !(u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsTempBot()) &&
+                        (IsTank(u) || GetHealthPCT(u) < 75) && me->GetDistance(u) < 40 &&
+                        ShieldTarget(u, diff))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff) || IsCasting())
+                return false;
+            //if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+            //    return false;
+            if (target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_PRIEST, 0x20000000) ||
+                target->HasAuraTypeWithFamilyFlags(SPELL_AURA_SCHOOL_ABSORB, SPELLFAMILY_PRIEST, 0x1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+                return true;
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+
+        bool removeShapeshiftForm() override
+        {
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_SHADOW:
+                        me->RemoveAurasDueToSpell(SHADOWFORM_1);
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            return true;
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            //Improved Shadowform: Fade
+            if (IsSpellReady(FADE_1, diff) && me->GetShapeshiftForm() == FORM_SHADOW && me->GetLevel() >= 45 &&
+                Rand() < 35 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (doCast(me, GetSpell(FADE_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            Disperse(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            DoDevCheck(diff);
+            DoShackCheck(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50 && (!HasRole(BOT_ROLE_HEAL) || me->HasAuraType(SPELL_AURA_MOD_SILENCE)))
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            doDefend(diff);
+
+            if (me->GetMap()->IsRaid())
+            {
+                CureGroup(GetSpell(DISPEL_MAGIC_1), diff);
+                CureGroup(GetSpell(ABOLISH_DISEASE_1) ? GetSpell(ABOLISH_DISEASE_1) : GetSpell(CURE_DISEASE_1), diff);
+                MassGroupHeal(diff);
+                ShieldGroup(diff);
+                CheckMending(diff);
+                BuffAndHealGroup(diff);
+            }
+            else
+            {
+                MassGroupHeal(diff);
+                ShieldGroup(diff);
+                CheckMending(diff);
+                BuffAndHealGroup(diff);
+                CureGroup(GetSpell(DISPEL_MAGIC_1), diff);
+                CureGroup(GetSpell(CURE_DISEASE_1), diff);
+            }
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckSilence(diff);
+                CheckDispel(diff);
+                CheckHymnOfHope(diff);
+            }
+
+            Counter(diff);
+
+            if (me->IsInCombat())
+            {
+                CheckShackles(diff);
+                CheckPowerInfusion(diff);
+            }
+            else
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (IsSpellReady(SHADOWFORM_1, diff) && HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_HEAL))
+            {
+                if (doCast(me, SHADOWFORM_1))
+                    return;
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            if (GC_Timer > diff)
+                return;
+
+            //shadow skills range
+            if (me->GetDistance(mytar) > CalcSpellMaxRange(MIND_FLAY_1))
+                return;
+
+            auto [can_do_shadow, can_do_holy] = CanAffectVictimBools(mytar, SPELL_SCHOOL_SHADOW, SPELL_SCHOOL_HOLY);
+
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff) && can_do_shadow && Rand() < 20 &&
+                mytar->GetHealth() > me->GetMaxHealth()/8 && !CCed(mytar) &&
+                !mytar->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (mytar->GetTypeId() == TYPEID_PLAYER ?
+                mytar->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) && mytar->ToPlayer()->IsUseEquipedWeapon(true) :
+                mytar->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && mytar->CanUseAttackType(BASE_ATTACK)))
+            {
+                if (doCast(mytar, GetSpell(PSYCHIC_HORROR_1)))
+                    return;
+            }
+
+            //spell reflections
+            if (IsSpellReady(SW_PAIN_1, diff) && can_do_shadow && CanRemoveReflectSpells(mytar, SW_PAIN_1) &&
+                doCast(mytar, SW_PAIN_1)) //yes, using rank 1
+                return;
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(SHADOWFIEND_1, diff) && GetManaPCT(me) < 50)
+            {
+                SummonBotPet(mytar);
+                SetSpellCooldown(SHADOWFIEND_1, 180000); // (5 - 2) min with Veiled Shadows
+                return;
+            }
+
+            if (!HasRole(BOT_ROLE_HEAL) || GetManaPCT(me) > 35 || botPet)
+            {
+                if (IsSpellReady(SW_DEATH_1, diff) && can_do_shadow && Rand() < 90 && GetHealthPCT(me) > 50 &&
+                    (me->GetMap()->IsRaid() || GetHealthPCT(mytar) < 15 || mytar->GetHealth() < me->GetMaxHealth()/8) &&
+                    doCast(mytar, GetSpell(SW_DEATH_1)))
+                    return;
+                if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && can_do_shadow && Rand() < 80 &&
+                    mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size()) &&
+                    !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x0, 0x400, 0x0, me->GetGUID()) &&
+                    doCast(mytar, GetSpell(VAMPIRIC_TOUCH_1)))
+                    return;
+                if (IsSpellReady(SW_PAIN_1, diff) && can_do_shadow && Rand() < 60 &&
+                    mytar->GetHealth() > me->GetMaxHealth()/2 * (1 + mytar->getAttackers().size()) &&
+                    !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0x0, 0x0, me->GetGUID()))
+                {
+                    AuraEffect const* weav = me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_PRIEST, 0x0, 0x8, 0x0);
+                    if (me->GetLevel() < 60 || (weav && weav->GetBase()->GetStackAmount() >= 4))
+                        if (doCast(mytar, GetSpell(SW_PAIN_1)))
+                            return;
+                }
+                if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && can_do_shadow && !Devcheck && Rand() < 80 &&
+                    (_spec == BOT_SPEC_PRIEST_SHADOW || mytar->IsControlledByPlayer()) &&
+                    mytar->GetHealth() > me->GetMaxHealth()/2 * (1 + mytar->getAttackers().size()) &&
+                    !(mytar->GetTypeId() == TYPEID_UNIT && (mytar->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_INFECTED-1)))) &&
+                    !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_LEECH, SPELLFAMILY_PRIEST, 0x02000000, 0x0, 0x0, me->GetGUID()) &&
+                    doCast(mytar, GetSpell(DEVOURING_PLAGUE_1)))
+                    return;
+                if (IsSpellReady(MIND_BLAST_1, diff) && can_do_shadow &&
+                    doCast(mytar, GetSpell(MIND_BLAST_1)))
+                    return;
+                if (IsSpellReady(MIND_SEAR_1, diff) && can_do_shadow && (!me->isMoving() || Rand() < 80) &&
+                    mytar->GetVictim() && mytar->GetVictim()->getAttackers().size() > 3)
+                {
+                    if (Unit* u = FindSplashTarget(CalcSpellMaxRange(MIND_SEAR_1), mytar, 14.f, 3)) //glyphed, cluster of 4
+                        if (doCast(u, GetSpell(MIND_SEAR_1)))
+                            return;
+                }
+                if (IsSpellReady(HOLY_FIRE_1, diff) && can_do_holy &&
+                    (HasRole(BOT_ROLE_HEAL) || me->GetShapeshiftForm() != FORM_SHADOW) &&
+                    doCast(mytar, GetSpell(HOLY_FIRE_1)))
+                    return;
+                if (IsSpellReady(MIND_FLAY_1, diff) && can_do_shadow &&
+                    (!HasRole(BOT_ROLE_HEAL) || mytar->GetHealth() < me->GetMaxHealth()/2) &&
+                    doCast(mytar, GetSpell(MIND_FLAY_1)))
+                    return;
+                if (IsSpellReady(SMITE_1, diff) && can_do_holy && me->GetLevel() < 20 &&//MF is lvl 20, MB is lvl 10
+                    doCast(mytar, GetSpell(SMITE_1)))
+                    return;
+            }
+
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == SHOOT_WAND && shot->m_targets.GetUnitTarget() != mytar)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (IsSpellReady(SHOOT_WAND, diff) && me->GetDistance(mytar) < 30 && GetEquips(BOT_SLOT_RANGED) &&
+                doCast(mytar, SHOOT_WAND))
+                return;
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+
+            uint8 hp = GetHealthPCT(target);
+            bool pointed = IsPointedHealTarget(target);
+            if (hp > 90 && !(pointed && me->GetMap()->IsRaid()) &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * (me->GetLevel() < 60 ? 2.5f : 2.0f);
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * (me->GetLevel() < 60 ? 2.5f : 2.0f);
+            //TC_LOG_ERROR("entities.player", "priest_bot:HealTarget(): %s's pct %u, hppctps %i, epct %i",
+            //    target->GetName().c_str(), uint32(hp), int32(hppctps), int32(xppct));
+            if (xppct >= 95 && hp >= 25 && !pointed)
+                return false;
+
+            //GUARDIAN SPIRIT no GCD
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && !IAmFree() && target->IsInCombat() && !target->getAttackers().empty() &&
+                (xppct <= 0 || (hp <= 50 && hppctps <= -15) ||
+                (me->GetMap()->Instanceable() && target->GetMaxHealth() > me->GetMaxHealth() << 5)) &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_PRIEST, 0x40000000))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        ReportSpellCast(GUARDIAN_SPIRIT_1, LocalizedNpcText(target->ToPlayer(), BOT_TEXT__ON_YOU), target->ToPlayer());
+
+                    if (!IAmFree() && target != master)
+                    {
+                        std::string msg = target == me ? LocalizedNpcText(master, BOT_TEXT__ON_MYSELF) : (LocalizedNpcText(master, BOT_TEXT__ON_) + target->GetName() + '!');
+                        ReportSpellCast(GUARDIAN_SPIRIT_1, msg, master);
+                    }
+                    //return true;
+                }
+            }
+
+            //PAIN SUPPRESSION
+            if (IsSpellReady(PAIN_SUPPRESSION_1, diff, false) && xppct >= 5 && hp >= 25 && hp <= 55 && hppctps <= -10 &&
+                Rand() < 80 && !target->getAttackers().empty() &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_DISPEL_RESIST, SPELLFAMILY_PRIEST, 0x80000000) &&
+                !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_PRIEST, 0x40000000))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        ReportSpellCast(PAIN_SUPPRESSION_1, LocalizedNpcText(target->ToPlayer(), BOT_TEXT__ON_YOU), target->ToPlayer());
+
+                    if (!IAmFree() && target != master)
+                    {
+                        std::string msg = target == me ? LocalizedNpcText(master, BOT_TEXT__ON_MYSELF) : (LocalizedNpcText(master, BOT_TEXT__ON_) + target->GetName() + '!');
+                        ReportSpellCast(PAIN_SUPPRESSION_1, msg, master);
+                    }
+                    return true;
+                }
+            }
+
+            if (target == me && IsSpellReady(DESPERATE_PRAYER_1, diff) && hp <= 50 && Rand() < 45 &&
+                int32(GetLostHP(me)) > _heals[DESPERATE_PRAYER_1])
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(DESPERATE_PRAYER_1)))
+                    return true;
+            }
+
+            if (IsCasting())
+                return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->isWorldBoss();
+
+            //Penance
+            if (IsSpellReady(PENANCE_1, diff) && !target->IsCharmed() && !target->isPossessed() && hp <= 80 &&
+                Rand() < 90 && xphploss > _heals[PENANCE_1])
+            {
+                if (doCast(target, GetSpell(PENANCE_1)))
+                    return true;
+            }
+            //Big Heal
+            if (IsSpellReady(HEAL, diff) && (xppct > 15 || !GetSpell(FLASH_HEAL_1)) && (tanking || xphploss > _heals[HEAL]))
+            {
+                if (me->IsInCombat() && IsSpellReady(INNER_FOCUS_1, diff) && GetManaPCT(me) < 70 &&
+                    doCast(me, GetSpell(INNER_FOCUS_1)))
+                {}
+                if (doCast(target, GetSpell(HEAL)))
+                    return true;
+            }
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) && (tanking || !target->getAttackers().empty() || me->GetMap()->IsDungeon()) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_PRIEST, 0x40, 0x0, 0x0, me->GetGUID())
+                /*!target->HasAura(GetSpell(RENEW_1), me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(RENEW_1)))
+                    return true;
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff) && xphploss > _heals[FLASH_HEAL_1])
+            {
+                if (doCast(target, GetSpell(FLASH_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff) override
+        {
+            if (IsSpellReady(FEAR_WARD_1, diff) && (!IAmFree() || target == me) &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, MECHANIC_FEAR) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+                return true;
+
+            if (target == me)
+            {
+                if (GetSpell(INNER_FIRE_1) &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_PRIEST, 0x2) &&
+                    doCast(me, GetSpell(INNER_FIRE_1)))
+                    return true;
+                if (HasRole(BOT_ROLE_DPS) && GetSpell(VAMPIRIC_EMBRACE_1) &&
+                    !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_DUMMY, SPELLFAMILY_PRIEST, 0x4) &&
+                    doCast(me, GetSpell(VAMPIRIC_EMBRACE_1)))
+                    return true;
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid())
+                return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_PRIEST, 0x8) &&
+                    doCast(target, PW_FORTITUDE))
+                    return true;
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_RESISTANCE_EXCLUSIVE, SPELLFAMILY_PRIEST, 0x100) &&
+                    doCast(target, SHADOW_PROTECTION))
+                    return true;
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if ((target->GetMaxPower(POWER_MANA) > 1) &&
+                    !target->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_STAT, SPELLFAMILY_PRIEST, 0x20) &&
+                    doCast(target, DIVINE_SPIRIT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            ResurrectGroup(GetSpell(RESURRECTION_1));
+
+            if (GetSpell(LEVITATE_1) && !IAmFree() && Rand() < 30)
+            {
+                Group const* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        Player* pl = ref->GetSource();
+                        if (pl && pl->IsAlive() && pl->FindMap() == me->GetMap() && pl->GetDistance(me) < 30 &&
+                            pl->IsFalling() && pl->m_movementInfo.fallTime > 1000 &&
+                            !pl->HasAuraType(SPELL_AURA_HOVER))
+                        {
+                            if (doCast(pl, GetSpell(LEVITATE_1)))
+                                return;
+                        }
+                    }
+                }
+                else if (master->IsAlive() && master->GetDistance(me) < 30 && master->IsFalling() &&
+                    master->m_movementInfo.fallTime > 1000 && !master->HasAuraType(SPELL_AURA_HOVER))
+                {
+                    if (doCast(master, GetSpell(LEVITATE_1)))
+                        return;
+                }
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (ShackcheckTimer > diff || !IsSpellReady(SHACKLE_UNDEAD_1, diff) || Shackcheck || Rand() > 65 ||
+                (HasRole(BOT_ROLE_HEAL) && (IsCasting() || GetManaPCT(me) < 20)))
+                return;
+
+            //always glyphed so <= 0.5 sec cast time
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(SHACKLE_UNDEAD_1), 0, SHACKLE_UNDEAD_1))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(SHACKLE_UNDEAD_1)))
+                    return;
+            }
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (HasRole(BOT_ROLE_HEAL) && !HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (DispelcheckTimer > diff || IsCasting() || Rand() > 35)
+                return;
+
+            DispelcheckTimer = urand(750, 1000);
+
+            uint32 DM = GetSpell(DISPEL_MAGIC_1);
+            uint32 MD = (_spec == BOT_SPEC_PRIEST_DISCIPLINE) ? GetSpell(MASS_DISPEL_1) : 0;
+
+            if (!DM && !MD)
+                return;
+
+            if (Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(DISPEL_MAGIC_1)))
+            {
+                uint32 dm = DM && !target->HasAuraWithMechanic(1<<MECHANIC_IMMUNE_SHIELD) ? DM : MD;
+                if (dm && doCast(target, dm))
+                    return;
+            }
+        }
+
+        void CheckMending(uint32 diff)
+        {
+            if (Mend_Timer > diff || !HasRole(BOT_ROLE_HEAL) || !IsSpellReady(PRAYER_OF_MENDING_1, diff) ||
+                IAmFree() || !master->GetGroup() || IsCasting() || Rand() > 75)
+                return;
+
+            Mend_Timer = urand(1000, 3000);
+
+            uint32 MENDING_AURA = InitSpell(me, PRAYER_OF_MENDING_AURA_1); //always valid
+            if (FindAffectedTarget(MENDING_AURA, me->GetGUID(), 70, 4))
+                return;
+
+            Group const* gr = master->GetGroup();
+            for (GroupReference const* gitr = gr->GetFirstMember(); gitr != nullptr; gitr = gitr->next())
+            {
+                Player* player = gitr->GetSource();
+                if (player && player->IsAlive() && !player->getAttackers().empty() &&
+                    IsTank(player) && GetHealthPCT(player) < 85 && me->IsWithinDistInMap(player, 40) &&
+                    !player->HasAuraType(SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE))
+                {
+                    if (doCast(player, GetSpell(PRAYER_OF_MENDING_1)))
+                        return;
+                }
+
+                if (player->HaveBot())
+                {
+                    BotMap const* map = player->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (gr->IsMember(itr->second->GetGUID()) && itr->second->IsAlive() && !itr->second->getAttackers().empty() &&
+                            IsTank(itr->second) && GetHealthPCT(player) < 85 && me->IsWithinDistInMap(itr->second, 40) &&
+                            !itr->second->HasAuraType(SPELL_AURA_RAID_PROC_FROM_CHARGE_WITH_VALUE))
+                        {
+                            if (doCast(itr->second, GetSpell(PRAYER_OF_MENDING_1)))
+                                return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (Shackle_Timer > diff || !IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            Shackle_Timer = 500;
+
+            if (FindAffectedTarget(GetSpell(SHACKLE_UNDEAD_1), me->GetGUID(), 60, 255))
+                return;
+            Unit* target = FindUndeadCCTarget(CalcSpellMaxRange(SHACKLE_UNDEAD_1), SHACKLE_UNDEAD_1);
+            if (target && doCast(target, GetSpell(SHACKLE_UNDEAD_1)))
+            {}
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 40)
+                return;
+
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(SILENCE_1), 0, SILENCE_1))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                        return;
+            }
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff))
+            {
+                if (Unit* target = FindCastingTarget(CalcSpellMaxRange(PSYCHIC_HORROR_1), 0, PSYCHIC_HORROR_1))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                        return;
+            }
+        }
+
+        void CheckPowerInfusion(uint32 diff)
+        {
+            if (!IsSpellReady(POWER_INFUSION_1, diff, false) || IsCasting() || Rand() > 25)
+                return;
+
+            if (IAmFree())
+            {
+                if (me->GetVictim() && GetManaPCT(me) < 95 &&
+                    doCast(me, GetSpell(POWER_INFUSION_1)))
+                    return;
+
+                return;
+            }
+
+            Group const* gr = master->GetGroup();
+            BotMap const* map;
+            Unit* u = nullptr;
+            if (!gr)
+            {
+                u = master;
+                if (u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                    GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                    !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                    doCast(u, GetSpell(POWER_INFUSION_1)))
+                    return;
+
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->ToCreature()->GetBotAI()->HasRole(BOT_ROLE_HEAL) &&
+                        u->ToCreature()->GetBotClass() < BOT_CLASS_EX_START &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    u = itr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                        u->ToCreature()->GetBotClass() < BOT_CLASS_EX_START &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+
+                return;
+            }
+
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                u = itr->GetSource();
+                if (u && u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                    GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                    !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                    doCast(u, GetSpell(POWER_INFUSION_1)))
+                    return;
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap() || !player->HaveBot())
+                    continue;
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    u = bitr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->ToCreature()->GetBotAI()->HasRole(BOT_ROLE_HEAL) &&
+                        !IsHeroExClass(u->ToCreature()->GetBotClass()) &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+            }
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || me->GetMap() != player->FindMap() || !player->HaveBot())
+                    continue;
+                map = master->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    u = bitr->second;
+                    if (u->IsAlive() && u->IsInWorld() && u->GetPowerType() == POWER_MANA && u->GetVictim() && !IsTank(u) &&
+                        u->ToCreature()->GetBotClass() < BOT_CLASS_EX_START &&
+                        GetManaPCT(u) < 70 && me->IsWithinDistInMap(u, 30) &&
+                        !u->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_CASTING_SPEED_NOT_STACK, SPELLFAMILY_PRIEST, 0x80000000) &&
+                        doCast(u, GetSpell(POWER_INFUSION_1)))
+                        return;
+                }
+            }
+
+            SetSpellCooldown(POWER_INFUSION_1, 1500); //fail
+        }
+
+        void doDefend(uint32 diff)
+        {
+            if (Rand() > 50) return;
+
+            Unit::AttackerSet const& m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 95 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (!(*iter)->IsAlive()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetDistance((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        if (doCast(me, GetSpell(FADE_1)))
+                            return;
+                    }
+                }
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                DevcheckTimer = 1000;
+                Devcheck = GetSpell(DEVOURING_PLAGUE_1) && FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID(), 70);
+            }
+        }
+
+        void DoShackCheck(uint32 diff)
+        {
+            if (ShackcheckTimer <= diff)
+            {
+                ShackcheckTimer = 1000;
+                Shackcheck = GetSpell(SHACKLE_UNDEAD_1) && FindAffectedTarget(GetSpell(SHACKLE_UNDEAD_1), me->GetGUID(), 70);
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (me->GetVehicle())
+                return;
+            if (!IsSpellReady(DISPERSION_1, diff) || !me->IsInCombat() || HasRole(BOT_ROLE_HEAL) || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && (me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) || !me->getAttackers().empty())) ||
+                (GetManaPCT(me) < 35 && !IsPotionReady()) ||
+                (me->getAttackers().size() > 1 && (CCed(me, true) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE))))
+            {
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                    return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 500); //fail
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Inner Focus
+            if (AuraEffect const* focu = me->GetAuraEffect(INNER_FOCUS_1, 0))
+                if (focu->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 25.f;
+
+            //Benediction (23236)
+            if (lvl >= 60 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 2.f;
+            //Increased Prayer of Healing Criticals (23550): 25% additional critical chance for Prayer of Healing
+            if (lvl >= 60 && baseId == PRAYER_OF_HEALING_1)
+                crit_chance += 25.f;
+            //Item - Priest T9 Shadow 4P Bonus (67198)
+            if (lvl >= 80 && baseId == MIND_FLAY_DAMAGE)
+                crit_chance += 5.f;
+
+            //Holy Specialization: 5% additional critical chance for Holy spells
+            if (lvl >= 10 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                crit_chance += 5.f;
+            //Mind Melt (part 1): 4% additional critical chance for Mind Blast, Mind Flay and Mind Sear
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x802000) || (spellInfo->SpellFamilyFlags[1] & 0x80000)))
+                crit_chance += 4.f;
+            //Mind Melt (part 2): 6% additional critical chance for Vampiric Touch, Devouring Plague and SW: Pain
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x2008000) || (spellInfo->SpellFamilyFlags[1] & 0x400)))
+                crit_chance += 6.f;
+            //Improved Flash Heal (part 2): 10% additional critical chance on targets at or below 50% hp for Flash Heal
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 40 && baseId == FLASH_HEAL_1 && GetHealthPCT(victim) <= 50)
+                crit_chance += 10.f;
+            //Renewed Hope part 1: 4% additional critical chance on targets affected by Weakened Soul for Flash Heal, Greater Heal and Penance (Heal)
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) &&
+                lvl >= 45 && (baseId == FLASH_HEAL_1 || baseId == HEAL || baseId == PENANCE_HEAL_1) &&
+                victim->HasAuraTypeWithFamilyFlags(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_PRIEST, 0x20000000))
+                crit_chance += 4.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Shadow Power: 50% additional crit damage bonus for Mind Blast, Mind Flay and SW:Death
+                if (lvl >= 40 &&
+                    (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_DAMAGE || baseId == SW_DEATH_1))
+                    pctbonus += 0.333f;
+                //Shadowform crit damage increase
+                if (me->GetShapeshiftForm() == FORM_SHADOW &&
+                    (baseId == SW_PAIN_1 || baseId == DEVOURING_PLAGUE_1 || baseId == VAMPIRIC_TOUCH_1))
+                    pctbonus += 0.333f;
+            }
+            //Improved Mind Flay and Smite (37571)
+            if (lvl >= 10 && (baseId == MIND_FLAY_DAMAGE || baseId == SMITE_1))
+                pctbonus += 0.05f;
+            //Item - Priest T8 Shadow 2P Bonus (64906)
+            if (lvl >= 80 && ((baseId == DEVOURING_PLAGUE_1) || (spellInfo->SpellFamilyFlags[2] & 0x8)))
+                pctbonus += 0.15f;
+
+            //Twin Disciplines (damage part): 5% bonus damage for instant spells
+            if (lvl >= 10 && !spellInfo->CastTimeEntry)
+                pctbonus += 0.05f;
+            //Darkness: 10% bonus damage for shadow spells
+            if (lvl >= 10 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Improved Shadow Word: Pain: 6% bonus damage for Shadow Word: Pain
+            if (lvl >= 15 && baseId == SW_PAIN_1)
+                pctbonus += 0.06f;
+            //Focused Power part 1: 4% bonus damage for all spells
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 35)
+                pctbonus += 0.04f;
+            //Improved Devouring Plague part 1: 15% bonus damage Devouring Plague
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 35 && baseId == DEVOURING_PLAGUE_1)
+                pctbonus += 0.15f;
+            //Shadowform: 15% bonus damage for shadow spells (handled)
+            //if (lvl >= 40 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW) && me->GetShapeshiftForm() == FORM_SHADOW)
+            //    pctbonus += 0.15f;
+            //Misery part 3: 15% bonus damage (from spellpower) for Mind Blast, Mind Flay and Mind Sear
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 45)
+            {
+                if (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_DAMAGE || baseId == MIND_SEAR_DAMAGE_1)
+                    fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+
+            //If target is affected BY SW: Pain
+            if (lvl >= 20 && (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_DAMAGE) && damageinfo.target &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_PRIEST, 0x8000, 0x0, 0x0, me->GetGUID()))
+            {
+                //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+                if (baseId == MIND_FLAY_DAMAGE)
+                    pctbonus += 0.1f;
+                //Twisted Faith (part 1): 10% bonus damage for Mind Blast and Mind Flay
+                if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 55)
+                    pctbonus += 0.1f;
+            }
+
+            //Glyph of Shadow Word: Death: 10% bonus damage for Shadow Word: Death on targets below 35% health
+            if (lvl >= 62 && baseId == SW_DEATH_1 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                pctbonus += 0.1f;
+
+            //other
+            if (baseId == SW_DEATH_BACKLASH)
+            {
+                //not affected by +%talents
+                pctbonus = 1.f;
+                ////T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                //if (lvl >= 60) //buffed
+                //    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 30% reduced backlash damage
+                if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 50)
+                    pctbonus -= 0.3f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //pct mods
+            //Improved Greater Heal (38411): 5% bonus healing for Greater Heal
+            if (lvl >= 60 && baseId == HEAL)
+                pctbonus += 0.05f;
+            //Priest T9 Healing 2P: 20% bonus healing for Prayer of Mending
+            if (lvl >= 80 && baseId == PRAYER_OF_MENDING_HEAL)
+                pctbonus += 0.2f;
+
+            //Twin Disciplines (healing part): 5% bonus healing for instant spells
+            if (lvl >= 10 && !spellInfo->CastTimeEntry)
+                pctbonus += 0.05f;
+            //Improved Renew: 15% bonus healing for Renew
+            if (lvl >= 10 && baseId == RENEW_1)
+                pctbonus += 0.15f;
+            //Focused Power part 2: 4% bonus heal for all spells
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 35)
+                pctbonus += 0.04f;
+            //Spiritual Healing: 10% bonus healing for all spells
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 35)
+                pctbonus += 0.15f;
+            //Blessend Resilience part 1: 3% bonus healing for all spells
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 40)
+                pctbonus += 0.03f;
+            //Empowered Healing: 40% bonus (from spellpower) for Greater Heal and 20% bonus (from spellpower) for Flash Heal and Binding Heal
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 45)
+            {
+                if (baseId == HEAL)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+                else if (baseId == FLASH_HEAL_1/* || baseId == BINDING_HEAL_1*/)
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Renew (heal bonus part): 15% bonus healing (from spellpower) for Renew
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 50 && baseId == RENEW_1)
+                flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            //Test of Faith: 12% bonus healing on targets at or below 50% health
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 50 && GetHealthPCT(victim) <= 50)
+                pctbonus += 0.12f;
+            //Divine Providence: 10% bonus healing for Circle of Healing, Binding Heal, Holy Nova, Prayer of Healing, Divine Hymn and Prayer of Mending
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 55 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x18000200) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x4) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x4)))
+                pctbonus += 0.1f;
+
+            //flat mods
+            //Improved Prayer of Mending: 100 additional heal for Prayer of Mending
+            if (baseId == PRAYER_OF_MENDING_HEAL)
+                flat_mod += 100;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Inner Focus
+            if (AuraEffect const* focu = me->GetAuraEffect(INNER_FOCUS_1, 0))
+                if (focu->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.f;
+            //Surge of Light
+            if (AuraEffect const* surg = me->GetAuraEffect(SURGE_OF_LIGHT_BUFF, 1))
+                if (surg->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.f;
+
+            //Reduced Prayer of Healing Cost (38410):
+            if (lvl >= 60 && baseId == PRAYER_OF_HEALING_1)
+                pctbonus += 0.1f;
+            //Greater Heal Cost Reduction (60155):
+            if (lvl >= 60 && baseId == HEAL)
+                pctbonus += 0.05f;
+
+            //Shadow Focus part 2
+            if (lvl >= 15 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.06f;
+            //Absolution:
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 25 && (spellInfo->SpellFamilyFlags[1] & 0x81))
+                pctbonus += 0.15f;
+            //Mental Agility:
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 25 && !spellInfo->CastTimeEntry)
+                pctbonus += 0.1f;
+            //Improved Healing:
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) &&
+                lvl >= 25 && (baseId == HEAL || baseId == DIVINE_HYMN_1 || baseId == PENANCE_HEAL_1))
+                pctbonus += 0.15f;
+            //Soul Warding part 2
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 30 && baseId == PW_SHIELD_1)
+                pctbonus += 0.15f;
+            //Healing Prayers:
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) &&
+                lvl >= 30 && (baseId == PRAYER_OF_HEALING_1 || baseId == PRAYER_OF_MENDING_1))
+                pctbonus += 0.2f;
+            //Focused Mind
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) &&
+                lvl >= 30 && (baseId == MIND_BLAST_1 || baseId == MIND_FLAY_1 ||
+                baseId == MIND_SEAR_1/* || baseId == MIND_CONTROL_1*/))
+                pctbonus += 0.15f;
+            //Improved Flash Heal part 1
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 40 && baseId == FLASH_HEAL_1)
+                pctbonus += 0.15f;
+
+            //Glyph of Fading
+            if (lvl >= 15 && baseId == FADE_1)
+                pctbonus += 0.3f;
+            //Glyph of Fortitude
+            if (lvl >= 15 && baseId == PW_FORTITUDE_1)
+                pctbonus += 0.5f;
+            //Glyph of Flash Heal
+            if (lvl >= 20 && baseId == FLASH_HEAL_1)
+                pctbonus += 0.1f;
+            //Glyph of Mass Dispel
+            if (lvl >= 70 && baseId == MASS_DISPEL_1)
+                pctbonus += 0.35f;
+
+            //flat mods
+            //Cleanse Cost Reduced (id: 27847): -25 mana cost for Cleanse
+            //if (lvl >= 40 && spellId == GetSpell(CLEANSE_1))
+            //    flatbonus += 25;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Surge of Light
+            if (AuraEffect const* surg = me->GetAuraEffect(SURGE_OF_LIGHT_BUFF, 1))
+                if (surg->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.f;
+
+            //pct mods
+            //Serendipity: -12% per stack cast time for Prayer of Healing or Greater Heal
+            if (baseId == GREATER_HEAL_1 || baseId == PRAYER_OF_HEALING_1)
+            {
+                if (AuraEffect const* sere = me->GetAuraEffect(SERENDIPITY_BUFF, 0))
+                    if (sere->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.12f * sere->GetBase()->GetStackAmount();
+            }
+
+            //flat mods
+            //Improved Prayer of Healing (21339)
+            if (lvl >= 60 && baseId == PRAYER_OF_HEALING_1)
+                timebonus += 100;
+            //Master Healer (15027) rank 5
+            if (lvl >= 60 && baseId == HEAL)
+                timebonus += 500;
+            //Prophesy Flash Heal Bonus (21973) part 1
+            if (lvl >= 60 && baseId == FLASH_HEAL_1)
+                timebonus += 100;
+
+            //Divine Fury
+            if (lvl >= 15 && (baseId == HEAL || baseId == SMITE_1 || baseId == HOLY_FIRE_1))
+                timebonus += 500;
+            //Focused Power part 3
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 35 && baseId == MASS_DISPEL_1)
+                timebonus += 1000;
+            //Improved Mana Burn
+            //if (lvl >= 35 && baseId == MANA_BURN_1)
+            //    timebonus += 1000;
+
+            //Glyph of Scourge Imprisonment
+            if (lvl >= 20 && baseId == SHACKLE_UNDEAD_1)
+                timebonus += 1000;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) &&
+                lvl >= 45 && (baseId == INNER_FOCUS_1 || baseId == POWER_INFUSION_1 || baseId == PAIN_SUPPRESSION_1))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Veiled Shadows part 2
+            //if (lvl >= 25 && baseId == SHADOWFIEND_1)
+            //    timebonus += 120000;
+            //Glyph of Dispersion:
+            if (lvl >= 60 && baseId == DISPERSION_1)
+                timebonus += 45000;
+            //Glyph of Penance:
+            if (lvl >= 60 && baseId == PENANCE_1)
+                timebonus += 2000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Aspiration
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 45 && baseId == PENANCE_1)
+                pctbonus += 0.2f;
+            //Divine Providence:
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 55 && baseId == PRAYER_OF_MENDING_1)
+                pctbonus += 0.3f;
+
+            //flat mods
+            //Quick Fade (18388)
+            if (lvl >= 40 && baseId == FADE_1)
+                timebonus += 2000;
+
+            //Improved Psychic Scream
+            if (lvl >= 20 && baseId == PSYCHIC_SCREAM_1)
+                timebonus += 4000;
+            //Improved Mind Blast
+            if (lvl >= 20 && baseId == MIND_BLAST_1)
+                timebonus += 2500;
+            //Veiled Shadows part 1
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 25 && baseId == FADE_1)
+                timebonus += 6000;
+            //Soul Warding part 1
+            if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 30 && baseId == PW_SHIELD_1)
+                timebonus += 4000;
+
+            //Glyph of Fade
+            if (lvl >= 15 && baseId == FADE_1)
+                timebonus += 9000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Prophesy Flash Heal Bonus (21973) part 2
+            if (lvl >= 60 && baseId == FLASH_HEAL_1)
+                timebonus += 100;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Holy Reach
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) &&
+                lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x18400200) || (spellInfo->SpellFamilyFlags[2] & 0x4)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Mind Sear
+            if (lvl >= 75 && baseId == MIND_SEAR_DAMAGE_1)
+                flatbonus += 5.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Shadow Reach: +20% range for Shadow Spells
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 25 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x682A004) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x300502) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x2040)))
+                pctbonus += 0.2f;
+            //Holy Reach: +20% range for Holy Spells
+            if ((_spec == BOT_SPEC_PRIEST_HOLY) && lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x100080))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Shackle Undead: +5 yd range for Shackle Undead
+            if (lvl >= 20 && baseId == SHACKLE_UNDEAD_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Circle of Healing: + 1 target
+            if (spellInfo->SpellFamilyFlags[0] & 0x10000000)
+                bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //Surge of Light
+            //Inner Focus
+            AuraEffect const* surg = me->GetAuraEffect(SURGE_OF_LIGHT_BUFF, 1);
+            AuraEffect const* focu = me->GetAuraEffect(INNER_FOCUS_1, 0);
+            if (surg && surg->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(SURGE_OF_LIGHT_BUFF);
+            else if (focu && focu->IsAffectedOnSpell(spellInfo))
+                me->RemoveAurasDueToSpell(INNER_FOCUS_1);
+
+            //Serendipity
+            if (AuraEffect const* sere = me->GetAuraEffect(SERENDIPITY_BUFF, 0))
+                if (sere->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(SERENDIPITY_BUFF);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Hymn of Hope: +2 sec duration
+            if (lvl >= 60 && (baseId == HYMN_OF_HOPE_1 || baseId == HYMN_OF_HOPE_BUFF))
+            {
+                if (Aura* hymn = target->GetAura(spellId))
+                {
+                    hymn->SetDuration(hymn->GetDuration() + 2000);
+                    hymn->SetDuration(hymn->GetMaxDuration() + 2000);
+                }
+            }
+            //Priest T9 Shadow 2P Bonus (67193)
+            if (lvl >= 80 && baseId == VAMPIRIC_TOUCH_1)
+            {
+                if (Aura* touc = target->GetAura(spellId))
+                {
+                    uint32 dur = touc->GetMaxDuration() + 6000;
+                    touc->SetDuration(dur);
+                    touc->SetMaxDuration(dur);
+                }
+            }
+
+            //Improved Mind Blast part 2
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 20 && baseId == MIND_BLAST_1)
+                me->CastSpell(target, IMPROVED_MIND_BLAST_DEBUFF, true);
+
+            if (lvl >= 15 && baseId == PW_FORTITUDE_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    eff->ChangeAmount(int32(eff->GetAmount() * 1.3f));
+            }
+            if (lvl >= 20 && baseId == PW_SHIELD_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    float amount = float(eff->GetAmount());
+                    //Borrowed Time: +40% of spellpower
+                    if ((_spec == BOT_SPEC_PRIEST_DISCIPLINE) && lvl >= 55)
+                        amount += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.4f;
+                    //Improved PWSH: +15% effect
+                    eff->ChangeAmount(int32(amount * 1.15f));
+                }
+            }
+            //Weakened Soul Reduction (id: 33333): -2 sec to Weakened Soul duration
+            if (lvl >= 51 && baseId == WEAKENED_SOUL_DEBUFF)
+            {
+                if (Aura* soul = target->GetAura(spellId))
+                {
+                    uint32 dur = soul->GetMaxDuration() - 2000;
+                    soul->SetDuration(dur);
+                    soul->SetMaxDuration(dur);
+                }
+            }
+            //Pain and Suffering (part 1): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 50 && baseId == MIND_FLAY_1 && GetSpell(SW_PAIN_1))
+                if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                    pain->RefreshDuration();
+            if (baseId == FEAR_WARD_1)
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+            //buffs duration
+            if (baseId == INNER_FIRE_1 || baseId == VAMPIRIC_EMBRACE_1 || baseId == PW_FORTITUDE_1 ||
+                baseId == SHADOW_PROTECTION_1 || baseId == DIVINE_SPIRIT_1)
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+
+            //convert to effect bonus somehow, this code gonna cause constant stack
+            //if (baseId == PRAYER_OF_MENDING_AURA_1)
+            //{
+            //    //Prayer of Mending Bounce (60154): +1 charge
+            //    if (Aura* mend = target->GetAura(spellId, me->GetGUID()))
+            //    {
+            //        mend->SetCharges(mend->GetCharges() + 1);
+            //    }
+            //}
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Glyph of Inner Fire + Improved Inner Fire:
+            if (lvl >= 15 && baseId == INNER_FIRE_1)
+            {
+                if (Aura* fire = me->GetAura(spellId))
+                {
+                    fire->SetCharges(fire->GetCharges() + 12);
+                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        if (AuraEffect* eff = fire->GetEffect(i))
+                            eff->ChangeAmount(int32(eff->GetAmount() * (i == 0 ? 1.45f*1.5f : 1.45f)));
+                }
+            }
+            //Improved Vampiric Embrace
+            if ((_spec == BOT_SPEC_PRIEST_SHADOW) && lvl >= 30 && baseId == VAMPIRIC_EMBRACE_1)
+            {
+                if (AuraEffect* vamp = me->GetAuraEffect(spellId, 0))
+                    vamp->ChangeAmount(vamp->GetAmount() + 10); //67% is essentially this
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(MIND_FLAY_1) : 20.f;
+        }
+
+        void SummonBotPet(Unit* target)
+        {
+            if (botPet)
+                UnsummonAll();
+
+            uint32 entry = BOT_PET_SHADOWFIEND;
+
+            //Position pos;
+
+            //15 sec duration
+            Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_MANUAL_DESPAWN);
+            //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+            //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, SHADOWFIEND_1);
+
+            botPet = myPet;
+
+            myPet->Attack(target, true);
+            if (!HasBotCommandState(BOT_COMMAND_STAY))
+                myPet->GetMotionMaster()->MoveChase(target);
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+                botPet = nullptr;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_SHADOWFIEND;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            Shackle_Timer = 0;
+            Mend_Timer = 0;
+
+            DispelcheckTimer = 0;
+            DevcheckTimer = 0;
+            ShackcheckTimer = 0;
+
+            Devcheck = false;
+            Shackcheck = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+            if (Mend_Timer > diff)                  Mend_Timer -= diff;
+
+            if (DispelcheckTimer > diff)            DispelcheckTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+            if (ShackcheckTimer > diff)             ShackcheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isDisc = _spec == BOT_SPEC_PRIEST_DISCIPLINE;
+            bool isHoly = _spec == BOT_SPEC_PRIEST_HOLY;
+            bool isShad = _spec == BOT_SPEC_PRIEST_SHADOW;
+
+            InitSpellMap(DISPEL_MAGIC_1);
+            InitSpellMap(MASS_DISPEL_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(ABOLISH_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+            InitSpellMap(MIND_SEAR_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            InitSpellMap(GREATER_HEAL_1);
+            InitSpellMap(NORMAL_HEAL_1);
+            InitSpellMap(LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(PRAYER_OF_MENDING_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(HOLY_FIRE_1);
+            InitSpellMap(SMITE_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+            InitSpellMap(HYMN_OF_HOPE_1);
+            InitSpellMap(LEVITATE_1);
+            InitSpellMap(SHADOWFIEND_1); //not casted
+
+  /*Talent*/lvl >= 20 && isDisc ? InitSpellMap(INNER_FOCUS_1) : RemoveSpell(INNER_FOCUS_1);
+  /*Talent*/lvl >= 40 && isDisc ? InitSpellMap(POWER_INFUSION_1) : RemoveSpell(POWER_INFUSION_1);
+  /*Talent*/lvl >= 50 && isDisc ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+  /*Talent*/lvl >= 60 && isDisc ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+
+  /*Talent*/lvl >= 20 && isHoly ? InitSpellMap(DESPERATE_PRAYER_1) : RemoveSpell(DESPERATE_PRAYER_1);
+  /*Talent*/lvl >= 50 && isHoly ? InitSpellMap(CIRCLE_OF_HEALING_1) : RemoveSpell(CIRCLE_OF_HEALING_1);
+  /*Talent*/lvl >= 60 && isHoly ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+
+  /*Talent*/lvl >= 20 && isShad ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 30 && isShad ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 30 && isShad ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 40 && isShad ? InitSpellMap(SHADOWFORM_1) : RemoveSpell(SHADOWFORM_1);
+  /*Talent*/lvl >= 50 && isShad ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+  /*Talent*/lvl >= 50 && isShad ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 60 && isShad ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+
+            HEAL = GetSpell(GREATER_HEAL_1) ? GREATER_HEAL_1 :
+                GetSpell(NORMAL_HEAL_1) ? NORMAL_HEAL_1 :
+                GetSpell(LESSER_HEAL_1) ? LESSER_HEAL_1 : 0;
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isDisc = _spec == BOT_SPEC_PRIEST_DISCIPLINE;
+            bool isHoly = _spec == BOT_SPEC_PRIEST_HOLY;
+            bool isShad = _spec == BOT_SPEC_PRIEST_SHADOW;
+
+            RefreshAura(UNBREAKABLE_WILL, level >= 10 ? 1 : 0);
+            RefreshAura(MEDITATION, level >= 20 ? 1 : 0);
+            RefreshAura(RENEWED_HOPE, isDisc && level >= 45 ? 1 : 0);
+            RefreshAura(RAPTURE, isDisc && level >= 45 ? 1 : 0);
+            RefreshAura(DIVINE_AEGIS, isDisc && level >= 50 ? 1 : 0);
+            RefreshAura(GRACE, isDisc && level >= 50 ? 1 : 0);
+            RefreshAura(BORROWED_TIME, isDisc && level >= 55 ? 1 : 0);
+
+            RefreshAura(INSPIRATION3, isHoly && level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION2, isHoly && level >= 23 && level < 25 ? 1 : 0);
+            RefreshAura(INSPIRATION1, isHoly && level >= 20 && level < 23 ? 1 : 0);
+            RefreshAura(SURGE_OF_LIGHT, isHoly && level >= 35 ? 1 : 0);
+            RefreshAura(HOLY_CONCENTRATION, isHoly && level >= 40 ? 1 : 0);
+            RefreshAura(BODY_AND_SOUL1, isHoly && level >= 45 ? 1 : 0);
+            RefreshAura(SERENDIPITY, isHoly && level >= 45 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW3, isHoly && level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW2, isHoly && level >= 53 && level < 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW1, isHoly && level >= 50 && level < 53 ? 1 : 0);
+
+            RefreshAura(SPIRIT_TAP, isShad && level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_SPIRIT_TAP, isShad && level >= 10 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING3, isShad && level >= 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING2, isShad && level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING1, isShad && level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOURING_PLAGUE, isShad && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_SHADOWFORM, isShad && level >= 45 ? 1 : 0);
+            RefreshAura(MISERY3, isShad && level >= 50 ? 1 : 0);
+            RefreshAura(MISERY2, isShad && level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(MISERY1, isShad && level >= 45 && level < 48 ? 1 : 0);
+
+            //RefreshAura(GLYPH_SW_PAIN, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_PW_SHIELD, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_DISPEL_MAGIC, level >= 18 ? 1 : 0);
+            RefreshAura(GLYPH_PRAYER_OF_HEALING, level >= 30 ? 1 : 0);
+            RefreshAura(GLYPH_SHADOW, level >= 30 ? 1 : 0);
+            RefreshAura(PRIEST_T10_2P_BONUS, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case MASS_DISPEL_1:
+                case ABOLISH_DISEASE_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case RENEW_1:
+                case PRAYER_OF_HEALING_1:
+                case CIRCLE_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PRAYER_OF_MENDING_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                case FEAR_WARD_1:
+                case FLASH_HEAL_1:
+                case GREATER_HEAL_1:
+                case LEVITATE_1:
+                    return true;
+                case NORMAL_HEAL_1:
+                    return !GetSpell(GREATER_HEAL_1);
+                case LESSER_HEAL_1:
+                    return !GetSpell(NORMAL_HEAL_1) && !GetSpell(GREATER_HEAL_1);
+                case SHADOWFORM_1:
+                    return me->GetShapeshiftForm() != FORM_SHADOW;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Priest_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Priest_spells_cc;
+        }
+        std::vector<uint32> const* GetHealingSpellsList() const override
+        {
+            return &Priest_spells_heal;
+        }
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Priest_spells_support;
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, HEAL))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HEAL));
+                _heals[HEAL] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), DamageEffectType(3), spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[HEAL] = 0;
+
+            if (InitSpell(me, FLASH_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, FLASH_HEAL_1));
+                _heals[FLASH_HEAL_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), DamageEffectType(3), spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[FLASH_HEAL_1] = 0;
+
+            if (InitSpell(me, PENANCE_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, PENANCE_HEAL_1));
+                _heals[PENANCE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), DamageEffectType(3), spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[PENANCE_1] = 0;
+
+            if (InitSpell(me, DESPERATE_PRAYER_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, DESPERATE_PRAYER_1));
+                _heals[DESPERATE_PRAYER_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), DamageEffectType(3), spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[DESPERATE_PRAYER_1] = 0;
+        }
+
+    private:
+        uint32 HEAL;
+        uint32 Shackle_Timer, Mend_Timer, DispelcheckTimer, DevcheckTimer, ShackcheckTimer;
+/*Misc*/bool Devcheck, Shackcheck;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 000000000..66098c50a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,2040 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "Creature.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+#include "SpellMgr.h"
+#include "WorldSession.h"
+/*
+Rogue NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 90%
+TODO:
+*/
+
+enum RogueBaseSpells
+{
+    KICK_1                              = 1766,
+    EXPOSE_ARMOR_1                      = 8647, //NYI
+    FEINT_1                             = 1966,
+    DISMANTLE_1                         = 51722,
+
+    BACKSTAB_1                          = 53,
+    SINISTER_STRIKE_1                   = 1752,
+    EVISCERATE_1                        = 2098,
+    ENVENOM_1                           = 32645,
+    RUPTURE_1                           = 1943,
+    MUTILATE_1                          = 1329,
+    HEMORRHAGE_1                        = 16511,
+    GHOSTLY_STRIKE_1                    = 14278,
+    RIPOSTE_1                           = 14251,
+    DEADLY_THROW_1                      = 26679,
+    FAN_OF_KNIVES_1                     = 51723,
+
+    SPRINT_1                            = 2983,
+    EVASION_1                           = 5277,
+    BLIND_1                             = 2094,
+    VANISH_1                            = 1856,
+    COLD_BLOOD_1                        = 14177,
+    HUNGER_FOR_BLOOD_1                  = 51662,
+    ADRENALINE_RUSH_1                   = 13750,
+    KILLING_SPREE_1                     = 51690,
+    PREPARATION_1                       = 14185,
+    PREMEDITATION_1                     = 14183,
+
+    GOUGE_1                             = 1776,
+
+    KIDNEY_SHOT_1                       = 408,
+    SLICE_DICE_1                        = 5171,
+    BLADE_FLURRY_1                      = 13877,
+    SHADOWSTEP_1                        = 36554,
+    CLOAK_OF_SHADOWS_1                  = 31224,
+    TRICKS_OF_THE_TRADE_1               = 57934,
+    SHADOW_DANCE_1                      = 51713,
+
+    STEALTH_1                           = 1784,
+    SAP_1                               = 6770, //NYI
+    GARROTE_1                           = 703,
+    CHEAP_SHOT_1                        = 1833,
+    AMBUSH_1                            = 8676,
+
+    DISTRACT_1                          = 1725, //NYI
+
+    //Poisons
+    CRIPPLING_POISON_1                  = 3408,
+    INSTANT_POISON_1                    = 8679,
+    DEADLY_POISON_1                     = 2823,
+    WOUND_POISON_1                      = 13219,
+    MIND_NUMBING_POISON_1               = 5761, //manual use only
+    ANESTHETIC_POISON_1                 = 26785,
+
+    PICK_LOCK_1                         = 1804
+};
+
+enum RoguePassives
+{
+    //Talents
+    SEAL_FATE1                          = 14189,
+    SEAL_FATE2                          = 14190,
+    SEAL_FATE3                          = 14193,
+    SEAL_FATE4                          = 14194,
+    SEAL_FATE5                          = 14195,
+    COMBAT_POTENCY1                     = 35541,
+    COMBAT_POTENCY2                     = 35550,
+    COMBAT_POTENCY3                     = 35551,
+    COMBAT_POTENCY4                     = 35552,
+    COMBAT_POTENCY5                     = 35553,
+    QUICK_RECOVERY1                     = 31244,
+    QUICK_RECOVERY2                     = 31245,
+    //BLADE_TWISTING1                     = 31124,
+    //BLADE_TWISTING2                     = 31126,
+    DEADLY_BREW                         = 51626,//rank 2
+    IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+    VIGOR                               = 14983,
+    REMORSELESS_ATTACKS                 = 14148,//rank 2
+    FLEET_FOOTED                        = 31209,//rank 2
+    MURDER                              = 14159,//rank 2
+    OVERKILL                            = 58426,
+    FOCUSED_ATTACKS                     = 51636,//rank 3
+    MASTER_POISONER                     = 58410,//rank 3
+    DUAL_WIELD_SPECIALIZATION           = 13852,//rank 5
+    IMPROVED_KICK                       = 13867,//rank 2
+    IMPROVED_SPRINT                     = 13875,//rank 2
+    HACK_AND_SLASH                      = 13964,//rank 5
+    VITALITY                            = 61329,//rank 3
+    NERVES_OF_STEEL                     = 31131,//rank 2
+    THROWING_SPECIALIZATION             = 51679,//rank 2
+    //SAVAGE_COMBAT                       = 58413,//rank 2
+    UNFAIR_ADVANTAGE                    = 51674,//rank 2
+    SURPRISE_ATTACKS                    = 32601,
+    PREY_ON_THE_WEAK                    = 51689,//rank 5
+    MASTER_OF_DECEPTION                 = 13971,//rank 3
+    SETUP                               = 14071,//rank 3
+    INITIATIVE                          = 13980,//rank 3
+    DIRTY_DEEDS                         = 14083,//rank 2
+    MASTER_OF_SUBTLETY                  = 31223,//rank 3
+    CHEAT_DEATH                         = 31230,//rank 3
+    ENVELOPING_SHADOWS                  = 31213,//rank 3
+    TURN_THE_TABLES                     = 51629,//rank 3
+    HONOR_AMONG_THIEVES                 = 51701,//rank 3
+
+    //Other
+    VIGOR_GLADIATOR                     = 21975,
+    GLYPH_BACKSTAB                      = 56800,
+
+    ROGUE_PASSIVE_DND                   = 21184 //from playercreateinfo_spell
+};
+
+enum RogueSpecial
+{
+    MUTILATE_DAMAGE_MAINHAND_1          = 5374,
+    MUTILATE_DAMAGE_OFFHAND_1           = 27576,
+
+    //TURN_THE_TABLES_BUFF                = 52910,//'rank 3'
+    HUNGER_FOR_BLOOD_BUFF               = 63848,
+    WAYLAY_DEBUFF                       = 51693,
+    REMORSELESS_ATTACKS_BUFF            = 14149,
+    CHEATING_DEATH_BUFF                 = 45182, //hidden
+    TRICKS_OF_THE_TRADE_BUFF            = 57933,
+
+    RELENTLESS_STRIKES_EFFECT           = 14181,
+    RUTHLESSNESS_EFFECT                 = 14157,
+    SEAL_FATE_EFFECT                    = 14189,
+    SETUP_EFFECT                        = 15250,
+    INITIATIVE_EFFECT                   = 13977,
+    HONOR_AMONG_THIEVES_EFFECT          = 51699,
+
+    VANISH_TRIGGERED_1                  = 11327,
+    VANISH_TRIGGERED_2                  = 11329,
+    VANISH_TRIGGERED_3                  = 26888,
+
+    //Poisons
+    CRIPPLING_POISON_PROC_1             = 3409,
+    //INSTANT_POISON_PROC_1               = 8680,
+    DEADLY_POISON_PROC_1                = 2818,
+    WOUND_POISON_PROC_1                 = 13218,
+    MIND_NUMBING_POISON_PROC_1          = 5760,
+    //ANESTHETIC_POISON_PROC_1            = 26688,
+
+    THISTLE_TEA                         = 9512 //'Restore Energy' 1 min cd
+};
+
+static const uint32 Rogue_spells_damage_arr[] =
+{ AMBUSH_1, BACKSTAB_1, DEADLY_THROW_1, EVISCERATE_1, ENVENOM_1, FAN_OF_KNIVES_1, GARROTE_1, GHOSTLY_STRIKE_1, GOUGE_1,
+HEMORRHAGE_1, KILLING_SPREE_1, MUTILATE_1, RIPOSTE_1, RUPTURE_1, SINISTER_STRIKE_1 };
+
+static const uint32 Rogue_spells_cc_arr[] =
+{ BLIND_1, CHEAP_SHOT_1, /*DEADLY_THROW_1, */DISMANTLE_1, GOUGE_1, KICK_1, KIDNEY_SHOT_1, /*SAP_1*/ };
+
+static const uint32 Rogue_spells_support_arr[] =
+{ /*EXPOSE_ARMOR_1, DISTRACT_1, PICK_LOCK_1,*/ STEALTH_1, ADRENALINE_RUSH_1, BLADE_FLURRY_1, CLOAK_OF_SHADOWS_1,
+COLD_BLOOD_1, DISMANTLE_1, EVASION_1, FEINT_1, HUNGER_FOR_BLOOD_1, PREMEDITATION_1, PREPARATION_1, SHADOW_DANCE_1,
+SHADOWSTEP_1, SLICE_DICE_1, SPRINT_1, TRICKS_OF_THE_TRADE_1, VANISH_1, THISTLE_TEA,
+/*CRIPPLING_POISON_1, INSTANT_POISON_1, DEADLY_POISON_1, WOUND_POISON_1, MIND_NUMBING_POISON_1, ANESTHETIC_POISON_1*/ };
+
+static const std::vector<uint32> Rogue_spells_damage(FROM_ARRAY(Rogue_spells_damage_arr));
+static const std::vector<uint32> Rogue_spells_cc(FROM_ARRAY(Rogue_spells_cc_arr));
+static const std::vector<uint32> Rogue_spells_support(FROM_ARRAY(Rogue_spells_support_arr));
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new rogue_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct rogue_botAI : public bot_ai
+    {
+        rogue_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_ROGUE;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { comboPoints = 0; bot_ai::JustDied(u); }
+
+        void getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+        }
+
+        int32 ecost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (combopointsSpent)
+            {
+                combopointsSpent = false;
+                comboPoints = 0;
+            }
+
+            getenergy();
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            CheckSprint(diff);
+            CheckCloakOfShadows(diff);
+            CheckVanish(diff);
+
+            if (!CheckAttackTarget())
+            {
+                if (!me->IsInCombat() && Rand() < 5 && me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_ROGUE, 0x800, 0x0, 0x0)) //vanish
+                    me->RemoveAurasDueToSpell(STEALTH_1);
+                return;
+            }
+
+            CheckBlind(diff);
+            CheckPreparation(diff);
+            CheckTricksOfTheTrade(diff);
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            float dist = me->GetDistance(mytar);
+
+            //Stealth (for Cooldown handling see bot_ai::ReleaseSpellCooldown)
+            //we don't want rogue to swith into stealth for no purpose
+            if (IsSpellReady(STEALTH_1, diff, false) && !me->IsInCombat() && !IsTank() && Rand() < 50 && dist < 28 &&
+                (!me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) || (mytar->GetTypeId() == TYPEID_PLAYER && dist < 6)) &&
+                (me->GetLevel() >= 35 || (energy >= 40 && me->GetLevel() >= 30) || dist > 8))
+            {
+                if (doCast(me, GetSpell(STEALTH_1)))
+                {}
+            }
+
+            if (!CanAffectVictimAny(mytar, SPELL_SCHOOL_NORMAL))
+                return;
+
+            bool stealthed = me->HasAuraType(SPELL_AURA_MOD_STEALTH);
+            bool shadowdance = me->HasAuraType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+
+            //Hunger for Blood
+            if (IsSpellReady(HUNGER_FOR_BLOOD_1, diff) && !shadowdance && HasRole(BOT_ROLE_DPS) && Rand() < 50 && dist < 30 &&
+                mytar->HasAuraState(AURA_STATE_BLEEDING) && energy >= ecost(HUNGER_FOR_BLOOD_1) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_ROGUE, 0x0, 0x1000000, 0x0))
+            {
+                if (doCast(mytar, GetSpell(HUNGER_FOR_BLOOD_1)))
+                    return;
+            }
+            //Premeditation
+            if (IsSpellReady(PREMEDITATION_1, diff, false) && (stealthed || shadowdance) &&
+                HasRole(BOT_ROLE_DPS) && comboPoints < 4 && dist < 15 &&
+                (comboPoints == 0 || mytar->GetHealth() > me->GetMaxHealth() / 4))
+            {
+                if (doCast(mytar, GetSpell(PREMEDITATION_1)))
+                {}
+            }
+            //Kick
+            if (IsSpellReady(KICK_1, diff, false) && !stealthed && dist <= 5 && Rand() < 70 &&
+                energy >= ecost(KICK_1) && mytar->IsNonMeleeSpellCast(false,false,true))
+            {
+                if (doCast(mytar, GetSpell(KICK_1)))
+                    getenergy();
+            }
+            //Killing Spree
+            if (IsSpellReady(KILLING_SPREE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                Rand() < (70 - energy) && dist < 10 && GetHealthPCT(me) > 25 && (!CCed(mytar) || dist > 5) &&
+                (mytar->getAttackers().size() < 4 || mytar->GetMaxHealth() > me->GetMaxHealth() * 2) &&
+                (mytar->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1))
+            {
+                if (doCast(mytar, GetSpell(KILLING_SPREE_1)))
+                    return;
+            }
+             //Gouge: if mytar is trying to attack/cast on us he will always try to face us
+            if (IsSpellReady(GOUGE_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) && dist <= 5 &&
+                Rand() < 30 && !CCed(mytar) && energy >= ecost(GOUGE_1) &&
+                ((energy < 55 && mytar->getAttackers().size() <= 1 && !mytar->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                mytar->IsNonMeleeSpellCast(false,false,true)) && mytar->HasInArc(float(M_PI), me))
+            {
+                if (doCast(mytar, GetSpell(GOUGE_1)))
+                    return;
+            }
+            //Blind: in pvp only for restealth
+            if (IsSpellReady(BLIND_1, diff) && !stealthed && !shadowdance && dist <= 15 && Rand() < 30 &&
+                !CCed(mytar) && energy >= ecost(BLIND_1) &&
+                ((energy <= 30 && mytar->GetTarget() == me->GetGUID() &&
+                mytar->getAttackers().size() <= 1 &&
+                !mytar->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (mytar->GetTypeId() == TYPEID_UNIT &&
+                !IsSpellReady(KICK_1, diff) && !IsSpellReady(GOUGE_1, diff) &&
+                mytar->IsNonMeleeSpellCast(false,false,true))))
+            {
+                if (doCast(mytar, GetSpell(BLIND_1)))
+                    return;
+            }
+            //Blade Flurry
+            if (IsSpellReady(BLADE_FLURRY_1, diff) && HasRole(BOT_ROLE_DPS) && !stealthed && !shadowdance &&
+                dist <= 5 && Rand() < 50 && energy >= ecost(BLADE_FLURRY_1) && !CCed(mytar) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0) &&
+                (mytar->GetTypeId() == TYPEID_PLAYER || mytar->GetHealth() > me->GetHealth() || FindSplashTarget(7, mytar)))
+            {
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                    return;
+            }
+            //Slice and Dice
+            if (IsSpellReady(SLICE_DICE_1, diff) && !shadowdance && HasRole(BOT_ROLE_DPS) && comboPoints > 0 &&
+                Rand() < 110 && energy >= ecost(SLICE_DICE_1) && dist < 10 &&
+                (me->getAttackers().size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000, 0x0, 0x0))
+            {
+                if (doCast(mytar, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //Dismantle
+            if (IsSpellReady(DISMANTLE_1, diff) && !stealthed && !shadowdance &&
+                mytar->GetHealth() >= me->GetHealth() / 2 && energy >= ecost(DISMANTLE_1) && dist <= 5 &&
+                !CCed(mytar) && Rand() < (30 + 90*mytar->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) &&
+                !mytar->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (mytar->GetTypeId() == TYPEID_PLAYER ?
+                mytar->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) && mytar->ToPlayer()->IsUseEquipedWeapon(true) :
+                mytar->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) && mytar->CanUseAttackType(BASE_ATTACK)))
+            {
+                if (doCast(mytar, GetSpell(DISMANTLE_1)))
+                    return;
+            }
+            //Shadowstep
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && !IsTank() && HasRole(BOT_ROLE_DPS) &&
+                Rand() < 50 && dist < 25 && energy >= ecost(SHADOWSTEP_1) &&
+                (mytar->GetTypeId() != TYPEID_PLAYER || dist > 12 || CCed(me, true)) &&
+                (mytar->GetTypeId() == TYPEID_PLAYER || mytar->GetVictim() != me) &&
+                ((!stealthed && !shadowdance) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(mytar, GetSpell(SHADOWSTEP_1)))
+                    getenergy();
+            }
+            //Sprint (no GCD)
+            if (IsSpellReady(SPRINT_1, diff, false) && !HasBotCommandState(BOT_COMMAND_STAY) &&
+                ((me->GetLevel() >= 20 && CCed(me, true) && Rand() < 35) ||
+                (Rand() < (25 + 10*stealthed + 40*shadowdance) && dist > (20 - (5*stealthed + 10*shadowdance)))) &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_ROGUE, 0x40, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(SPRINT_1)))
+                {}
+            }
+            //Evasion (no GCD)
+            if (IsSpellReady(EVASION_1, diff, false) && !stealthed && Rand() < 65 && !me->getAttackers().empty() &&
+                GetHealthPCT(me) < 65 + 10 * me->getAttackers().size() &&
+                !me->GetAuraEffect(SPELL_AURA_MOD_DODGE_PERCENT, SPELLFAMILY_ROGUE, 0x20, 0x0, 0x0))
+            {
+                if (doCast(me, GetSpell(EVASION_1)))
+                    return; //custom: do not skip animation
+            }
+            //Deadly Throw
+            if (IsSpellReady(DEADLY_THROW_1, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                comboPoints > 0 && Rand() < 55 && dist < 30 && dist > 5 && energy >= ecost(DEADLY_THROW_1) &&
+                ((_spec != BOT_SPEC_ROGUE_COMBAT) || mytar->IsNonMeleeSpellCast(false,false,true)))
+            {
+                Item const* thrown = GetEquips(BOT_SLOT_RANGED);
+                if (thrown && thrown->GetTemplate()->Class == ITEM_CLASS_WEAPON &&
+                    thrown->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_THROWN &&
+                    doCast(mytar, GetSpell(DEADLY_THROW_1)))
+                    return;
+            }
+
+            //if target is affected by gouge or blind just try to regen some energy
+            bool hasnormalstun = false;
+            int32 duration = 0;
+            //sizes of theese are typically 1, sometimes maybe 2
+            Unit::AuraEffectList const& stunAuras = mytar->GetAuraEffectsByType(SPELL_AURA_MOD_STUN);
+            for (Unit::AuraEffectList::const_iterator itr = stunAuras.begin(); itr != stunAuras.end(); ++itr)
+            {
+                if (!((*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) &&
+                    (*itr)->GetBase()->GetDuration() > 2000)
+                {
+                    hasnormalstun = true;
+                    break;
+                }
+                if ((*itr)->GetBase()->GetDuration() > duration)
+                    duration = (*itr)->GetBase()->GetDuration();
+            }
+            if (!hasnormalstun)
+            {
+                Unit::AuraEffectList const& confuseAuras = mytar->GetAuraEffectsByType(SPELL_AURA_MOD_CONFUSE);
+                for (Unit::AuraEffectList::const_iterator itr = confuseAuras.begin(); itr != confuseAuras.end(); ++itr)
+                {
+                    if (!((*itr)->GetSpellInfo()->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE) &&
+                        (*itr)->GetBase()->GetDuration() > 2000)
+                    {
+                        hasnormalstun = true;
+                        break;
+                    }
+                    if ((*itr)->GetBase()->GetDuration() > duration)
+                        duration = (*itr)->GetBase()->GetDuration();
+                }
+            }
+
+            //Vanish (no GCD)
+            if (IsSpellReady(VANISH_1, diff, false) && !stealthed && !shadowdance && !IsTank() && Rand() < 45 && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                bool cast = false;
+                //case 1: restealth for opener
+                if (!hasnormalstun && duration < 500 && me->IsInCombat() && dist <= 5)
+                    cast = true;
+                //case 2: evade casted spell
+                if (!cast)
+                {
+                    if (Spell const* spell = mytar->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                    {
+                        if (spell->m_targets.GetUnitTarget() == me && spell->GetTimer() < 500 &&
+                            spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE))
+                            cast = true;
+                    }
+                }
+                //case 3: reset threat / evade in CheckVanish (regardless of mytar availability)
+                if (cast && doCast(me, GetSpell(VANISH_1)))
+                    return; //custom: do not skip animation
+            }
+
+            if (dist > 5)
+            {
+                //if (mytar->IsPolymorphed())
+                //    TC_LOG_ERROR("entities.player", "rogue_bot: cannot attack target (dist)...");
+                return;
+            }
+
+            MoveBehind(mytar);
+
+            if (IsSpellReady(THISTLE_TEA, diff, false) && !hasnormalstun && duration < 1000 &&
+                energy <= std::max<int32>(me->GetMaxPower(POWER_ENERGY) - 110, 10))
+            {
+                if (doCast(me, THISTLE_TEA))
+                    getenergy();
+            }
+
+            //No IsSpellReady checks for spells with no cd below
+            if (GC_Timer > diff)
+                return;
+
+            //Feint
+            if (mytar->CanHaveThreatList())
+            {
+                if (IsSpellReady(FEINT_1, diff) && !stealthed && !IsTank() && mytar->GetVictim() == me && Rand() < 35 &&
+                    energy >= ecost(FEINT_1) && int32(mytar->GetThreatManager().GetThreatListSize()) > 1 &&
+                    int32(mytar->getAttackers().size()) > 1)
+                {
+                    if (doCast(mytar, GetSpell(FEINT_1)))
+                        return;
+                }
+            }
+
+            //Adrenaline Rush
+            if (GetSpell(ADRENALINE_RUSH_1) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) && (hasnormalstun || duration < 1300) && Rand() < 40 &&
+                energy < 50 && GetHealthPCT(me) > 35 &&
+                (mytar->getAttackers().size() < 3 || mytar->GetMaxHealth() > me->GetMaxHealth() * 2) &&
+                (mytar->GetHealth() > me->GetMaxHealth() / 2 || me->getAttackers().size() > 1))
+            {
+                if (doCast(me, GetSpell(ADRENALINE_RUSH_1)))
+                    return;
+            }
+
+            DiminishingLevels const stunDivider = mytar->GetDiminishing(DIMINISHING_OPENING_STUN);
+
+            bool hasHunger = me->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_PERCENT_DONE, SPELLFAMILY_ROGUE, 0x0, 0x1000000, 0x0);
+
+            //Rupture: little troll with applying rupture on target without breaking gouge (creatures only, pvp - restealth)
+            if (GetSpell(RUPTURE_1) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                comboPoints > ((hasHunger || !GetSpell(HUNGER_FOR_BLOOD_1)) ? 1 : 0) &&
+                !(hasHunger && _spec == BOT_SPEC_ROGUE_ASSASINATION && GetSpell(ENVENOM_1)) &&
+                (hasnormalstun || (mytar->CanHaveThreatList() && duration < 2000)) &&
+                (comboPoints < 4 || !GetSpell(KIDNEY_SHOT_1) || stunDivider > DIMINISHING_LEVEL_2) &&
+                energy >= ecost(RUPTURE_1) && mytar->GetHealth() > me->GetMaxHealth() / 4 * (1 + mytar->getAttackers().size()) &&
+                Rand() < (40 + 40 * (mytar->GetTypeId() == TYPEID_PLAYER && IsMeleeClass(mytar->GetClass()))) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100000, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(RUPTURE_1)))
+                    return;
+            }
+
+            if (!hasnormalstun && duration > 300 && uint32(energy) < me->GetMaxPower(POWER_ENERGY))
+            {
+                //TC_LOG_ERROR("entities.player", "bot_rogue: delaying attacks on gouged or blinded target...");
+                return;
+            }
+
+            //Finishers
+            if (comboPoints > 0)
+            {
+                //Kidney Shot
+                if (GetSpell(KIDNEY_SHOT_1) && !stealthed && stunDivider < DIMINISHING_LEVEL_4 &&
+                    Rand() < 80 && !CCed(mytar) &&
+                    !IsImmunedToMySpellEffect(mytar, sSpellMgr->GetSpellInfo(KIDNEY_SHOT_1), EFFECT_0) &&
+                    ((comboPoints >= 4 && stunDivider < DIMINISHING_LEVEL_3 &&
+                    (mytar->GetHealth() > me->GetMaxHealth() / 2 || mytar->GetTypeId() == TYPEID_PLAYER)) ||
+                    mytar->IsNonMeleeSpellCast(false,false,true)) &&
+                    energy >= ecost(KIDNEY_SHOT_1))
+                {
+                    if (doCast(mytar, GetSpell(KIDNEY_SHOT_1)))
+                        return;
+                }
+                //Envenom / Eviscerate
+                uint32 envescerate = (_spec == BOT_SPEC_ROGUE_ASSASINATION && GetSpell(ENVENOM_1) &&
+                    (mytar->GetHealth() > me->GetMaxHealth() / 5 || !GetSpell(EVISCERATE_1))) ? ENVENOM_1 : GetSpell(EVISCERATE_1) ? EVISCERATE_1 : 0;
+                if (envescerate && IsSpellReady(envescerate, diff) && !stealthed && !shadowdance && HasRole(BOT_ROLE_DPS) &&
+                    (comboPoints >= 4  || (envescerate == EVISCERATE_1 && mytar->GetHealth() < me->GetMaxHealth() / 4)) &&
+                    (envescerate != ENVENOM_1 ||
+                    (mytar->GetAuraEffect(SPELL_AURA_MOD_ATTACKER_SPELL_AND_WEAPON_CRIT_CHANCE, SPELLFAMILY_ROGUE, 0x10000, 0x0, 0x0, me->GetGUID()) &&
+                    (energy >= 110 || !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_ROGUE, 0x800000)))) &&
+                    energy >= ecost(envescerate) && Rand() < (70 + comboPoints * 20))
+                {
+                    //Cold Blood (no GCD)
+                    if (IsSpellReady(COLD_BLOOD_1, diff, false) && comboPoints > 3 && Rand() > 50 + 100*(comboPoints == 5))
+                        if (doCast(me, GetSpell(COLD_BLOOD_1)))
+                        {}
+                    if (doCast(mytar, GetSpell(envescerate)))
+                        return;
+                }
+            }
+
+            //Shadow Dance: if have energy or under effect of Adrenaline Rush
+            if (IsSpellReady(SHADOW_DANCE_1, diff, false) && !stealthed && HasRole(BOT_ROLE_DPS) && Rand() < 55 &&
+                GetHealthPCT(me) > 40 && (stunDivider == DIMINISHING_LEVEL_1 || CCed(mytar)) &&
+                (energy >= 60 || (energy >= 40 && me->GetAuraEffect(SPELL_AURA_MOD_POWER_REGEN_PERCENT, SPELLFAMILY_ROGUE, 0x0, 0x80, 0x0))) &&
+                (mytar->GetTypeId() == TYPEID_PLAYER || mytar->GetHealth() > (me->GetMaxHealth() / 4) * mytar->getAttackers().size()))
+            {
+                if (doCast(me, GetSpell(SHADOW_DANCE_1)))
+                {}
+            }
+
+            //Openers
+            if (stealthed || shadowdance)
+            {
+                uint32 opener =
+                    GetSpell(CHEAP_SHOT_1) &&
+                    !mytar->HasAuraType(SPELL_AURA_MOD_STUN) && stunDivider < DIMINISHING_LEVEL_3 &&
+                    (mytar->GetTypeId() == TYPEID_PLAYER || (!IAmFree() && master->GetNpcBotsCount() > 1)) ? CHEAP_SHOT_1 :
+                    GetSpell(GARROTE_1) && HasRole(BOT_ROLE_DPS) && mytar->GetHealth() > me->GetMaxHealth() / 4 &&
+                    !IsImmunedToMySpellEffect(mytar, sSpellMgr->GetSpellInfo(GARROTE_1), EFFECT_0) &&
+                    (!isdaggerMH || (mytar->GetTypeId() == TYPEID_PLAYER &&
+                    (mytar->GetClass() == CLASS_MAGE || mytar->GetClass() == CLASS_PRIEST || mytar->GetClass() == CLASS_WARLOCK))) &&
+                    !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x100, 0x0, 0x0, me->GetGUID()) ? GARROTE_1 :
+                    GetSpell(AMBUSH_1) && HasRole(BOT_ROLE_DPS) && isdaggerMH ? AMBUSH_1 :
+                    GetSpell(BACKSTAB_1) && HasRole(BOT_ROLE_DPS) && isdaggerMH ? BACKSTAB_1 : 0;
+
+                //all opener spells disabled/unusable
+                if (!opener)
+                {
+                    if (stealthed && HasRole(BOT_ROLE_DPS))
+                        me->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+                    //if (shadowdance)
+                    //    me->RemoveAurasByType(SPELL_AURA_MOD_IGNORE_SHAPESHIFT);
+
+                    return;
+                }
+                //openers from behind (backstab too)
+                if (opener != CHEAP_SHOT_1 && mytar->HasInArc(float(M_PI), me))
+                    return;
+
+                //We do not check combo points amount
+                if (energy >= ecost(opener))
+                {
+                    if (doCast(mytar, GetSpell(opener)))
+                        return;
+                }
+
+                return;
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //Fan of Knives
+            if (GetSpell(FAN_OF_KNIVES_1) && energy >= ecost(FAN_OF_KNIVES_1) &&
+                Rand() < 35
+                + 40*(me->GetAuraEffect(SPELL_AURA_MOD_POWER_REGEN_PERCENT, SPELLFAMILY_ROGUE, 0x0, 0x80, 0x0) != nullptr)
+                + 50*(me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x0, 0x0) != nullptr)
+                /*Adrenaline Rush and Blade Flurry*/)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 7.f, 1);
+                if (targets.size() > 2 && doCast(me, GetSpell(FAN_OF_KNIVES_1)))
+                    return;
+            }
+
+            //Combo points generating
+            //Riposte: only after parry
+            if (IsSpellReady(RIPOSTE_1, diff) && comboPoints < 5 && me->HasReactive(REACTIVE_DEFENSE) &&
+                energy >= ecost(RIPOSTE_1))
+            {
+                if (doCast(mytar, GetSpell(RIPOSTE_1)))
+                    return;
+            }
+            //Ghostly Strike: tank mode only
+            if (IsSpellReady(GHOSTLY_STRIKE_1, diff) && comboPoints < 5 && IsTank() && !me->getAttackers().empty() &&
+                energy >= ecost(GHOSTLY_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(GHOSTLY_STRIKE_1)))
+                    return;
+            }
+            //Hemorrhage: does not stack from different casters
+            if (GetSpell(HEMORRHAGE_1) && !isdaggerMH && comboPoints < 5 && !IsTank() && energy >= ecost(HEMORRHAGE_1) &&
+                !mytar->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELLFAMILY_ROGUE, 0x800000, 0x0, 0x0))
+            {
+                if (doCast(mytar, GetSpell(HEMORRHAGE_1)))
+                    return;
+            }
+            //Sinister Strike: tank mode
+            if (GetSpell(SINISTER_STRIKE_1) && comboPoints < 5 &&
+                (!isdaggerMH || IsTank() || (mytar->GetVictim() == me && energy >= 60 && mytar->HasInArc(float(M_PI), me)) || !GetSpell(BACKSTAB_1)) &&
+                energy >= ecost(SINISTER_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //Backstab/Mutilate
+            uint32 mutistab =
+                isdaggerMH && isdaggerOH && GetSpell(MUTILATE_1) ? MUTILATE_1 :
+                isdaggerMH && GetSpell(BACKSTAB_1) ? BACKSTAB_1 : 0;
+            if (mutistab && comboPoints < 4 && energy >= ecost(mutistab) && (mutistab == MUTILATE_1 || !mytar->HasInArc(float(M_PI), me)))
+            {
+                if (doCast(mytar, GetSpell(mutistab)))
+                    return;
+            }
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (me->IsInCombat() && Rand() < 25)
+            {
+                bool canVanish = IsSpellReady(VANISH_1, diff, false);
+                bool canSprint = (_spec == BOT_SPEC_ROGUE_COMBAT) && me->GetLevel() >= 25 && !HasBotCommandState(BOT_COMMAND_STAY) && IsSpellReady(SPRINT_1, diff, false);
+                if ((canVanish || canSprint) && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+                {
+                    uint32 Spanish = canSprint ? SPRINT_1 : VANISH_1;
+                    if (doCast(me, GetSpell(Spanish)))
+                        return;
+                }
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Rand() > 25)
+                return;
+
+            if (mhEnchantExpireTimer > 0 && mhEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* mh = GetEquips(BOT_SLOT_MAINHAND))
+                    if (mh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            mh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+            if (ohEnchantExpireTimer > 0 && ohEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* oh = GetEquips(BOT_SLOT_OFFHAND))
+                    if (oh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            oh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+
+            // Weapon Enchants
+            if (me->isMoving())
+                return;
+            uint8 lvl = me->GetLevel();
+            if (lvl < 20)
+                return;
+
+            Item* mhWeapon = GetEquips(BOT_SLOT_MAINHAND);
+            Item* ohWeapon = GetEquips(BOT_SLOT_OFFHAND);
+
+            bool mhReady = mhWeapon && !mhWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+            bool ohReady = ohWeapon && !ohWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+            if (!mhReady && !ohReady)
+                return; //no ecnhantable weapons
+
+            //OK choose the poisons
+            //MH 20+ Instant, 32+ Wound, envenom Instant
+            //OH 20+ Crippling, 40+ Instant (deadly brew inc), 68+ Anesthetic, envenom Deadly
+            if (needChooseMHEnchant && mhReady)
+                mhEnchant = (_spec == BOT_SPEC_ROGUE_ASSASINATION && GetSpell(ENVENOM_1)) ? INSTANT_POISON_1 :
+                    lvl >= 32 ? WOUND_POISON_1 :
+                    lvl >= 20 ? INSTANT_POISON_1 : 0;
+
+            if (needChooseOHEnchant && ohReady)
+                ohEnchant = (_spec == BOT_SPEC_ROGUE_ASSASINATION && GetSpell(ENVENOM_1)) ? DEADLY_POISON_1 :
+                    lvl >= 68 ? ANESTHETIC_POISON_1 :
+                    lvl >= 40 ? INSTANT_POISON_1 :
+                    lvl >= 20 ? CRIPPLING_POISON_1 : 0;
+
+            uint32 MhPoison = !mhReady ? 0 : GetSpell(mhEnchant);
+            uint32 OhPoison = !ohReady ? 0 : GetSpell(ohEnchant);
+
+            SpellInfo const* MhPoisonInfo = mhReady && MhPoison ? sSpellMgr->GetSpellInfo(MhPoison) : nullptr;
+            SpellInfo const* OhPoisonInfo = ohReady && OhPoison ? sSpellMgr->GetSpellInfo(OhPoison) : nullptr;
+
+            Item* targetWeapon = nullptr;
+            SpellInfo const* targetInfo = nullptr;
+
+            if (mhReady && MhPoison && mhWeapon->IsFitToSpellRequirements(MhPoisonInfo))
+            {
+                targetWeapon = mhWeapon;
+                targetInfo = MhPoisonInfo;
+            }
+            if (!targetWeapon && ohReady && OhPoison && ohWeapon->IsFitToSpellRequirements(OhPoisonInfo))
+            {
+                targetWeapon = ohWeapon;
+                targetInfo = OhPoisonInfo;
+            }
+            if (targetWeapon)
+            {
+                Spell* spell = new Spell(me, targetInfo, TRIGGERED_NONE);
+                SpellCastTargets targets;
+                targets.SetItemTarget(targetWeapon);
+                spell->prepare(targets);
+                return;
+            }
+        }
+
+        void CheckVanish(uint32 diff)
+        {
+            if (!IsSpellReady(VANISH_1, diff, false) || !me->IsInCombat() || me->IsMounted() || IsTank() || Rand() > 50 ||
+                me->getAttackers().empty() || me->HasAuraType(SPELL_AURA_MOD_STEALTH) ||
+                me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY) || me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return;
+
+            if (GetHealthPCT(me) < 30 + 20*me->getAttackers().size() ||
+                (!IAmFree() && GetHealthPCT(me) < 70 && master->GetNpcBotsCount() > 1))
+            {
+                //Unit* victim = me->GetVictim();
+                if (doCast(me, GetSpell(VANISH_1)))
+                    return;
+            }
+        }
+
+        void CheckCloakOfShadows(uint32 diff)
+        {
+            if (!IsSpellReady(CLOAK_OF_SHADOWS_1, diff) || !me->IsInCombat() || me->IsMounted() ||
+                Rand() > 40 + 60 * me->GetMap()->IsDungeon())
+                return;
+
+            uint32 count = 0;
+
+            //dispel debuffs
+            uint32 const dispelMask = DISPEL_ALL_MASK;
+            Unit::AuraApplicationMap const& Auras = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator iter = Auras.begin(); iter != Auras.end(); ++iter)
+            {
+                // remove all harmful spells on you...
+                SpellInfo const* spellInfo = iter->second->GetBase()->GetSpellInfo();
+                if ((spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC || (spellInfo->GetDispelMask() & dispelMask)) &&
+                    !iter->second->IsPositive() && !iter->second->GetBase()->IsPassive())
+                {
+                    if (spellInfo->HasAura(SPELL_AURA_PERIODIC_DAMAGE) ||
+                        spellInfo->HasAura(SPELL_AURA_MOD_SPEED_SLOW_ALL) ||
+                        spellInfo->HasAura(SPELL_AURA_HASTE_SPELLS))
+                        if (++count > 1)
+                            break;
+                }
+            }
+
+            //defend from enemy cast cast
+            if (Unit const* target = FindCastingTarget(50))
+            {
+                if (Spell const* spell = target->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->GetTimer() < 1000 && !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive() &&
+                        !(spell->GetSpellInfo()->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)))
+                    {
+                        //direct spell
+                        if (spell->m_targets.GetUnitTarget() == me &&
+                            spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                            me->IsWithinLOSInMap(target))
+                        {
+                            count += 2;
+                        }
+                        //area spell
+                        if ((spell->GetSpellInfo()->_effects[0].IsEffect() &&
+                            spell->GetSpellInfo()->_effects[0].TargetB.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY) ||
+                            (spell->GetSpellInfo()->_effects[1].IsEffect() &&
+                            spell->GetSpellInfo()->_effects[1].TargetB.GetSelectionCategory() == TARGET_SELECT_CATEGORY_NEARBY))
+                        {
+                            count += 2;
+                        }
+                    }
+                }
+            }
+
+            if (!(count > 1))
+                return;
+
+            if (doCast(me, GetSpell(CLOAK_OF_SHADOWS_1)))
+                return;
+        }
+
+        void CheckBlind(uint32 diff)
+        {
+            if (!IsSpellReady(BLIND_1, diff) || !me->IsInCombat() || me->IsMounted() || IsTank() || Rand() > 40 ||
+                me->HasAuraType(SPELL_AURA_MOD_STEALTH) || me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY) ||
+                IsSpellReady(BLADE_FLURRY_1, diff, false) || IsSpellReady(EVASION_1, diff, false) ||
+                me->GetAuraEffect(SPELL_AURA_MOD_DODGE_PERCENT, SPELLFAMILY_ROGUE, 0x20, 0x0, 0x0) ||//evasion
+                me->GetAuraEffect(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_ROGUE, 0x40000000, 0x800, 0x0))
+                return;
+
+            Unit* u = FindStunTarget(15); //improved always (base 10, improved 15)
+            if (!u)
+                u = FindCastingTarget(15, 0, BLIND_1);
+
+            if (u && doCast(u, GetSpell(BLIND_1)))
+                return;
+        }
+
+        void CheckPreparation(uint32 diff)
+        {
+            if (!IsSpellReady(PREPARATION_1, diff) || !me->IsInCombat() || me->IsMounted() || Rand() > 30)
+                return;
+
+            //TODO: recheck priorities
+            uint32 needFactor = 0;
+            uint32 cooldown;
+            cooldown = GetSpellCooldown(EVASION_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            cooldown = GetSpellCooldown(SPRINT_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            cooldown = GetSpellCooldown(VANISH_1);
+            needFactor += !cooldown ? 0 : 3 * cooldown / 1200; //1-100 x3
+            cooldown = GetSpellCooldown(COLD_BLOOD_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 1800; //1-100 x2
+            cooldown = GetSpellCooldown(SHADOWSTEP_1);
+            needFactor += !cooldown ? 0 : 2 * cooldown / 200;  //1-100 x2
+            cooldown = GetSpellCooldown(BLADE_FLURRY_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 1200; //1-100
+            cooldown = GetSpellCooldown(DISMANTLE_1);
+            needFactor += !cooldown ? 0 : 1 * cooldown / 600;  //1-100
+            //0-1300
+            //ignore Kick
+
+            if (needFactor >= 800 && doCast(me, GetSpell(PREPARATION_1)))
+                return;
+        }
+
+        void CheckTricksOfTheTrade(uint32 diff)
+        {
+            if (!IsSpellReady(TRICKS_OF_THE_TRADE_1, diff) || !me->IsInCombat() || me->IsMounted() || IAmFree() ||
+                IsTank() || Rand() > 30 || !me->GetMap()->IsDungeon() ||
+                me->HasAuraType(SPELL_AURA_MOD_STEALTH) || me->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY))
+                return;
+
+            Group const* group = master->GetGroup();
+            if (!group)
+                return;
+            Unit* victim = me->GetVictim();
+            if (!victim)
+                return;
+
+            Unit* target = nullptr;
+            for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (!player || !player->IsInWorld() || !player->IsAlive() || me->GetMap() != player->FindMap() ||
+                    me->GetDistance(player) > 20)
+                    continue;
+
+                if (IsTank(player) || player->GetVictim() == victim)
+                {
+                    if (!victim->CanHaveThreatList() ||
+                        victim->GetThreatManager().GetThreat(player) < victim->GetThreatManager().GetThreat(me) * 0.75f)
+                    {
+                        target = player;
+                        break;
+                    }
+                }
+            }
+
+            if (target)
+                if (doCast(target, GetSpell(TRICKS_OF_THE_TRADE_1)))
+                    return;
+        }
+
+        void CheckSprint(uint32 diff)
+        {
+            if (!IsSpellReady(SPRINT_1, diff, false) || !HasBotCommandState(BOT_COMMAND_FOLLOW) ||
+                me->GetVictim() || me->IsMounted() || IAmFree() || Rand() > 15)
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 40))
+            {
+                if (doCast(me, GetSpell(SPRINT_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+                return;
+
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Cold Blood
+            if (AuraEffect const* bloo = me->GetAuraEffect(COLD_BLOOD_1, 0, me->GetGUID()))
+                if (bloo->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+
+            //Puncturing Wounds:
+            if (lvl >= 15)
+            {
+                //30% additional critical chance for Backstab
+                if (baseId == BACKSTAB_1)
+                    crit_chance += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (baseId == MUTILATE_1 ||
+                    baseId == MUTILATE_DAMAGE_MAINHAND_1 || baseId == MUTILATE_DAMAGE_OFFHAND_1)
+                    crit_chance += 15.f;
+            }
+            //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+            if (lvl >= 15 && baseId == EVISCERATE_1)
+                crit_chance += 10.f;
+            //Improved Ambush: 50% additional critical chance for Ambush
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 25 && baseId == AMBUSH_1)
+                crit_chance += 50.f;
+            //Turn the Tables:
+            if (lvl >= 50 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x2600070E) || (spellInfo->SpellFamilyFlags[1] & 0x7900106)) &&
+                me->GetAuraEffect(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_ROGUE, 0x0, 0x200000, 0x0))
+                crit_chance += 6.f;
+            //Remorseless Attacks:
+            if (AuraEffect const* remo = me->GetAuraEffect(REMORSELESS_ATTACKS_BUFF, 0, me->GetGUID()))
+                if (remo->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 40.f;
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 &&
+                    (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == MUTILATE_1 || baseId == RIPOSTE_1 ||
+                    baseId == GOUGE_1 || baseId == HEMORRHAGE_1 || baseId == GHOSTLY_STRIKE_1
+                    /*|| baseId == SHIV_1*/ || baseId == MUTILATE_DAMAGE_MAINHAND_1 || baseId == MUTILATE_DAMAGE_OFFHAND_1))
+                    pctbonus += 0.15f;
+            }
+
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && baseId == EVISCERATE_1)
+                pctbonus += 0.15f;
+            //Find Weakness: 6% bonus damage to all abilities
+            if ((_spec == BOT_SPEC_ROGUE_ASSASINATION) && lvl >= 45)
+                pctbonus += 0.06f;
+            //Improved Eviscerate: 20% damage bonus for Eviscerate
+            if (lvl >= 10 && baseId == EVISCERATE_1)
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (lvl >= 10 &&
+                (baseId == BACKSTAB_1 || baseId == MUTILATE_1 || baseId == MUTILATE_DAMAGE_MAINHAND_1 ||
+                baseId == MUTILATE_DAMAGE_OFFHAND_1 || baseId == GARROTE_1 || baseId == AMBUSH_1))
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) &&
+                lvl >= 25 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (baseId == RUPTURE_1 || baseId == GARROTE_1))
+                pctbonus += 0.3f;
+            //Vile Poisons: 20% damage bonus for Poisons and Envenom
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x10012000) || (spellInfo->SpellFamilyFlags[1] & 0x18)))
+                pctbonus += 0.2f;
+            //Serrated Blades part 2: 30% bonus damage for Rupture
+            if (lvl >= 20 && baseId == RUPTURE_1)
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) &&
+                lvl >= 50 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 ||
+                /*baseId == SHIV_1 || */baseId == HEMORRHAGE_1 || baseId == GOUGE_1))
+                pctbonus += 0.1f;
+            //Blade Twisting: 10% bonus damage for Sinister Strike and Backstab
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) && lvl >= 35 && (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1))
+                pctbonus += 0.1f;
+            //Sinister Calling: 10% bonus percentage damage for Backstab and Hemorrhage
+            //We add bonus damage pct because SpellMods are not handled
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 45 && (baseId == BACKSTAB_1 || baseId == HEMORRHAGE_1))
+                pctbonus += 0.1f;
+            //Glyph of Fan of Knives: 20% bonus damage for Fan of Knives
+            if (lvl >= 80 && baseId == FAN_OF_KNIVES_1)
+                pctbonus += 0.2f;
+
+            //Glyph of Sinister Strike: 50% chance to add 1 cp on crit
+            if (baseId == SINISTER_STRIKE_1)
+                glyphSSProc = iscrit && lvl >= 15 && urand(1,100) <= 50;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Glyph of Blade Flurry: -100% cost for Blade Flurry
+            if (lvl >= 30 && baseId == BLADE_FLURRY_1)
+                pctbonus += 1.0f;
+
+            //percent mods
+            //Dirty Tricks: -50% cost for Blind and Sap
+            if (lvl >= 15 && (baseId == BLIND_1 || baseId == SAP_1))
+                pctbonus += 0.5f;
+
+            //flat mods
+            //Improved Expose Armor: -10 energy cost for Expose Armor
+            if (lvl >= 20 && baseId == EXPOSE_ARMOR_1)
+                flatbonus += 10;
+            //Improved Sinister Strike: -5 energy cost for Sinister Strike
+            if (lvl >= 10 && baseId == SINISTER_STRIKE_1)
+                flatbonus += 5;
+            //Dirty Deeds part 1: -20 energy cost for Cheap Shot and Garrote
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 30 && (baseId == CHEAP_SHOT_1 || baseId == GARROTE_1))
+                flatbonus += 20;
+            //Filthy Tricks part 2: -10 energy cost for Tricks of the Trade, Distract and Shadowstep
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) &&
+                lvl >= 50 && (baseId == TRICKS_OF_THE_TRADE_1 || baseId == DISTRACT_1 || baseId == SHADOWSTEP_1))
+                flatbonus += 10;
+            //Slaugher from the Shadows part 1: -20 energy cost for Backstab and Ambush
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 55 && (baseId == BACKSTAB_1 || baseId == AMBUSH_1))
+                flatbonus += 20;
+            //Slaugher from the Shadows part 2: -5 energy cost for Hemorrhage
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 55 && baseId == HEMORRHAGE_1)
+                flatbonus += 5;
+            //Glyph of Feint: -20 energy cost for Feint
+            if (lvl >= 16 && baseId == FEINT_1)
+                flatbonus += 20;
+            //Glyph of Gouge: -15 energy cost for Gouge
+            if (lvl >= 15 && baseId == GOUGE_1)
+                flatbonus += 15;
+            //Glyph of Mutilate: -5 energy cost for Mutilate
+            if (lvl >= 50 && baseId == MUTILATE_1)
+                flatbonus += 5;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Improved Slam: -100% cast time for Slam
+            //if (lvl >= 40 && spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+            //    timebonus += casttime;
+
+            //flat mods
+            //Glyph of Pick Lock: 100% cast time for Pick Lock (reduced for bots)
+            if (lvl >= 16 && baseId == PICK_LOCK_1)
+                timebonus += 4000;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            //if (lvl >= 40 &&
+            //    (spellId == GetSpell(BLOODRAGE_1) || spellId == GetSpell(BERSERKERRAGE_1) ||
+            //    spellId == GetSpell(RECKLESSNESS_1) || spellId == GetSpell(DEATHWISH_1)))
+            //    pctbonus += 0.33f;
+
+            //flat mods
+            //Elusiveness part 2: -60 sec cooldown for Blind
+            if (lvl >= 20 && baseId == BLIND_1)
+                timebonus += 60000;
+            //Elusiveness part 3: -30 sec cooldown for Cloak of Shadows
+            if (lvl >= 20 && baseId == CLOAK_OF_SHADOWS_1)
+                timebonus += 30000;
+            //Filthy Tricks part 1: -10 sec cooldown for Tricks of the Trade, Distract and Shadowstep
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) &&
+                lvl >= 50 && (baseId == TRICKS_OF_THE_TRADE_1 || baseId == DISTRACT_1 || baseId == SHADOWSTEP_1))
+                timebonus += 10000;
+            //Filthy Tricks part 3: -3 min cooldown for Preparation
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 50 && baseId == PREPARATION_1)
+                timebonus += 180000;
+            //Glyph of Killing Spree: -45 sec cooldown for Killing Spree
+            if (lvl >= 60 && baseId == KILLING_SPREE_1)
+                timebonus += 45000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Endurance: -1 min cooldown for Sprint and Evasion
+            if (lvl >= 20 && (baseId == SPRINT_1 || baseId == EVASION_1))
+                timebonus += 60000;
+            //Elusiveness part 1: -60 sec cooldown for Vanish
+            if (lvl >= 20 && baseId == VANISH_1)
+                timebonus += 60000;
+            //Camouflage part 2: -6 sec cooldown for Stealth
+            if (lvl >= 15 && baseId == STEALTH_1)
+                timebonus += 6000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            //if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+            //    timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* /*spellInfo*/, float& radius) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Glyph of Thunder Clap
+            //if (spellInfo->SpellFamilyFlags[0] & 0x80)
+            //    flatbonus += 4.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Booming Voice
+            //if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+            //    pctbonus += 1.0f;
+
+            //flat mods
+            //Throwing Specialization: + 4 yd range for Deadly Throw
+            if ((_spec == BOT_SPEC_ROGUE_COMBAT) && lvl >= 45 && baseId == DEADLY_THROW_1)
+                flatbonus += 4.f;
+            //Dirty Tricks: + 5 yd range for Blind and Sap
+            if (lvl >= 15 && (baseId == BLIND_1 || baseId == SAP_1))
+                flatbonus += 5.f;
+            //Glyph of Ambush: + 5 yd range for Ambush
+            if (/*lvl >= 18 && */baseId == AMBUSH_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* /*spellInfo*/, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Improved Revenge: +1 target (actually 2 in dbc)
+            //if (spellInfo->SpellFamilyFlags[0] & 0x400)
+            //    bonusTargets += 1;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Thistle Tea: cooldown
+            if (baseId == THISTLE_TEA)
+                SetSpellCooldown(THISTLE_TEA, 300000); //5 min (item cd)
+
+            //Remorseless Attacks: proc consume buff
+            if (AuraEffect const* remo = me->GetAuraEffect(REMORSELESS_ATTACKS_BUFF, 0, me->GetGUID()))
+                if (remo->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(REMORSELESS_ATTACKS_BUFF);
+
+            //Relentless Strikes
+            if (spellInfo->NeedsComboPoints() && comboPoints)
+            {
+                if (lvl >= 10)
+                {
+                    if (irand(1,100) <= 20 * comboPoints)
+                    {
+                        me->CastSpell(me, RELENTLESS_STRIKES_EFFECT, true);
+                        //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: RS proc!");
+                    }
+                }
+            }
+
+            //Item enchant
+            //We don't know which item is targeted
+            //Actually it is mh, then oh
+            if (baseId == CRIPPLING_POISON_1 || baseId == INSTANT_POISON_1 || baseId == DEADLY_POISON_1 ||
+                baseId == WOUND_POISON_1 || baseId == ANESTHETIC_POISON_1 || baseId == MIND_NUMBING_POISON_1)
+            {
+                //We set duration to 2 seconds to prevent exploiting unequip mechanic
+                //to get enchanted weapons for player (for non-shaman bots it won't work)
+                uint32 slot = TEMP_ENCHANTMENT_SLOT;
+                uint32 duration = 2 * IN_MILLISECONDS;
+                uint32 charges = 0;
+                uint32 enchant_id = spellInfo->_effects[0].MiscValue;
+                //SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                Item* mh = GetEquips(BOT_SLOT_MAINHAND);
+                Item* oh = GetEquips(BOT_SLOT_OFFHAND);
+                Item* item = nullptr;
+                uint8 itemSlot = 0;
+
+                if (mh && !mh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = mh;
+                    itemSlot = BOT_SLOT_MAINHAND;
+                }
+                else if (oh && !oh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && oh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = oh;
+                    itemSlot = BOT_SLOT_OFFHAND;
+                }
+                else
+                    ASSERT(false, "rogue bot attempted to enchant his weapons but cannot find a weapon to apply it!");
+
+                if (!IAmFree())
+                    master->GetSession()->SendEnchantmentLog(me->GetGUID(), me->GetGUID(), item->GetEntry(), enchant_id);
+
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, charges);
+                ApplyItemBonuses(itemSlot); //RemoveItemBonuses inside
+                if (itemSlot == BOT_SLOT_MAINHAND)
+                    mhEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                else if (itemSlot == BOT_SLOT_OFFHAND)
+                    ohEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                //GC_Timer = 1500; //needed
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            //Vanish: handle stealth add
+            if (baseId == VANISH_TRIGGERED_1 || baseId == VANISH_TRIGGERED_2 || baseId == VANISH_TRIGGERED_3)
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_SHAPESHIFT, SPELLFAMILY_ROGUE, 0x400000, 0x0, 0x0))
+                {
+                    //SetSpellCooldown(STEALTH_1, 0);
+                    me->CastSpell(me, STEALTH_1, true);
+                }
+            }
+            //Cheat Death: assume resilience bonus
+            if (baseId == CHEATING_DEATH_BUFF)
+            {
+                if (AuraEffect* chea = me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_GENERIC, 2109, 0))
+                {
+                    chea->ChangeAmount(-100);
+                }
+            }
+            //Camouflage part 1: +15% speed while stealthed
+            if (baseId == STEALTH_1 && me->GetLevel() >= 15)
+            {
+                if (AuraEffect* stea = me->GetAuraEffect(spell->Id, 2))
+                {
+                    stea->ChangeAmount(stea->GetAmount() + 15);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Cold Blood: handle proc
+            if (AuraEffect const* bloo = me->GetAuraEffect(COLD_BLOOD_1, 0, me->GetGUID()))
+                if (bloo->IsAffectedOnSpell(spell))
+                    me->RemoveAurasDueToSpell(COLD_BLOOD_1);
+
+            //Combo point generating from effects
+            if (baseId == SEAL_FATE_EFFECT || baseId == RUTHLESSNESS_EFFECT ||
+                baseId == SETUP_EFFECT || baseId == INITIATIVE_EFFECT || baseId == HONOR_AMONG_THIEVES_EFFECT)
+            {
+                ++comboPoints;
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN2: %s adds 1, now %u", spell->SpellName[0], uint32(comboPoints));
+                if (comboPoints > 5)
+                {
+                    comboPoints = 5;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP NOR2: now %u", uint32(comboPoints));
+                }
+            }
+            //Combo point generating from spells
+            if (baseId == SINISTER_STRIKE_1 || baseId == BACKSTAB_1 || baseId == MUTILATE_1 ||
+                baseId == GOUGE_1 || baseId == HEMORRHAGE_1 || baseId == GHOSTLY_STRIKE_1 ||
+                baseId == RIPOSTE_1 || baseId == PREMEDITATION_1 ||
+                baseId == AMBUSH_1 || baseId == GARROTE_1 || baseId == CHEAP_SHOT_1/* || baseId == SHIV_1*/)
+            {
+                (baseId == MUTILATE_1 || baseId == PREMEDITATION_1 || baseId == CHEAP_SHOT_1) ?
+                    comboPoints += 2 : ++comboPoints;
+
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN1: %s adds %u, now %u",
+                //    spell->SpellName[0], (baseId == MUTILATE_1 || baseId == PREMEDITATION_1 || baseId == CHEAP_SHOT_1) ?
+                //    2 : 1, uint32(comboPoints));
+
+                //Glyph of Sinister Strike: handle proc
+                if (baseId == SINISTER_STRIKE_1 && glyphSSProc)
+                {
+                    ++comboPoints;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP GEN1: glyphSS proc, now %u", uint32(comboPoints));
+                }
+
+                if (comboPoints > 5)
+                {
+                    comboPoints = 5;
+                    //TC_LOG_ERROR("entities.player", "rogue_bot CP NOR1: now %u", uint32(comboPoints));
+                }
+            }
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE || spellId == EXPOSE_ARMOR || spellId == ENVENOM)
+            //some abilities like relentless strikes require combo points thus tries to proc itself
+            else if (spell->NeedsComboPoints() && comboPoints)
+            {
+                //uint32 tempCP = comboPoints;
+                //comboPoints = 0;
+                combopointsSpent = true; //envenom problem - cps spent before aura application
+
+                //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: %u to 0", tempCP);
+
+                //Relentless Strikes: moved to OnClassSpellGo (triggered even without hitting the target)
+
+                //Ruthlessness
+                if (lvl >= 15)
+                {
+                    if (urand(1,100) <= 60)
+                    {
+                        me->CastSpell(target, RUTHLESSNESS_EFFECT, true);
+                        //TC_LOG_ERROR("entities.player", "rogue_bot CP SPEND1: RU proc!");
+                    }
+                }
+            }
+
+            //Preparation: handle effect
+            if (baseId == PREPARATION_1)
+            {
+                //TC_LOG_ERROR("entities.player", "rogue_bot Preparation hit!");
+                if (GetSpell(EVASION_1))
+                    SetSpellCooldown(EVASION_1, 0);
+                if (GetSpell(SPRINT_1))
+                    SetSpellCooldown(SPRINT_1, 0);
+                if (GetSpell(VANISH_1))
+                    SetSpellCooldown(VANISH_1, 0);
+                if (GetSpell(COLD_BLOOD_1))
+                    SetSpellCooldown(COLD_BLOOD_1, 0);
+                if (GetSpell(SHADOWSTEP_1))
+                    SetSpellCooldown(SHADOWSTEP_1, 0);
+
+                //Glyph of Preparation
+                //if (lvl >= 30) // same level as spell itself
+                {
+                    if (GetSpell(BLADE_FLURRY_1))
+                        SetSpellCooldown(BLADE_FLURRY_1, 0);
+                    if (GetSpell(DISMANTLE_1))
+                        SetSpellCooldown(DISMANTLE_1, 0);
+                    if (GetSpell(KICK_1))
+                        SetSpellCooldown(KICK_1, 0);
+                }
+            }
+
+            //Glyph of Garrote
+            if (lvl >= 15 && baseId == GARROTE_1)
+            {
+                if (Aura* garr = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = garr->GetMaxDuration() - 3000;
+                    garr->SetDuration(dur);
+                    garr->SetMaxDuration(dur);
+                    if (AuraEffect* garrEff = garr->GetEffect(0))
+                    {
+                        garrEff->ChangeAmount(int32(garrEff->GetAmount() * 1.44f)); //not a mistake
+                    }
+                }
+            }
+            //Glyph of Deadly Throw
+            if (lvl >= 64 && baseId == DEADLY_THROW_1)
+            {
+                if (AuraEffect* thro = target->GetAuraEffect(spellId, 1, me->GetGUID()))
+                {
+                    thro->ChangeAmount(thro->GetAmount() - 20);
+                }
+            }
+            //Glyph of Hunger for Blood
+            if (lvl >= 60 && baseId == HUNGER_FOR_BLOOD_BUFF)
+            {
+                if (AuraEffect* hung = me->GetAuraEffect(spellId, 0))
+                {
+                    hung->ChangeAmount(hung->GetAmount() + 3);
+                }
+            }
+            //Glyph of Cloak of Shadows
+            if (lvl >= 66 && baseId == CLOAK_OF_SHADOWS_1)
+            {
+                if (AuraEffect* cloa = me->GetAuraEffect(spellId, 2))
+                {
+                    cloa->ChangeAmount(cloa->GetAmount() - 40);
+                }
+            }
+            //Glyph of Sprint
+            if (lvl >= 15 && baseId == SPRINT_1)
+            {
+                if (AuraEffect* spri = me->GetAuraEffect(spellId, 0))
+                {
+                    spri->ChangeAmount(spri->GetAmount() + 30);
+                }
+            }
+            //Glyph of Vanish
+            if (lvl >= 22 && baseId == VANISH_1)
+            {
+                if (AuraEffect* vani = me->GetAuraEffect(spellId, 2))
+                {
+                    vani->ChangeAmount(vani->GetAmount() + 30);
+                }
+            }
+            //Glyph of Adrenaline Rush
+            if (lvl >= 40 && baseId == ADRENALINE_RUSH_1)
+            {
+                if (Aura* rush = me->GetAura(spellId))
+                {
+                    uint32 dur = rush->GetMaxDuration() + 5000;
+                    rush->SetDuration(dur);
+                    rush->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Evasion
+            if (lvl >= 15 && baseId == EVASION_1)
+            {
+                if (Aura* evas = me->GetAura(spellId))
+                {
+                    uint32 dur = evas->GetMaxDuration() + 5000;
+                    evas->SetDuration(dur);
+                    evas->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Slice and Dice
+            //Improved Slice and Dice
+            if (lvl >= 15 && baseId == SLICE_DICE_1)
+            {
+                if (Aura* dice = me->GetAura(spellId))
+                {
+                    uint32 dur = dice->GetMaxDuration() + 3000;
+                    dur = dur + dur / 2;
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Shadow Dance: 4 sec for bots
+            if (lvl >= 60 && baseId == SHADOW_DANCE_1)
+            {
+                if (Aura* danc = me->GetAura(spellId))
+                {
+                    uint32 dur = danc->GetMaxDuration() + 4000;
+                    danc->SetDuration(dur);
+                    danc->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Rupture
+            if (lvl >= 20 && baseId == RUPTURE_1)
+            {
+                if (Aura* rupt = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rupt->GetMaxDuration() + 4000;
+                    rupt->SetDuration(dur);
+                    rupt->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Expose Armor
+            if (lvl >= 15 && baseId == EXPOSE_ARMOR_1)
+            {
+                if (Aura* expo = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = expo->GetMaxDuration() + 12000;
+                    expo->SetDuration(dur);
+                    expo->SetMaxDuration(dur);
+                }
+            }
+            //Improved Gouge: Increased duration by 1.5 sec
+            if (lvl >= 10 && baseId == GOUGE_1)
+            {
+                if (Aura* goug = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 duration = goug->GetMaxDuration() + 1500;
+                    goug->SetDuration(duration);
+                    goug->SetMaxDuration(duration);
+                }
+            }
+            //Glyph of Tricks of Trade
+            if (lvl >= 75 && baseId == TRICKS_OF_THE_TRADE_BUFF)
+            {
+                if (Aura* tric = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 duration = tric->GetMaxDuration() + 4000;
+                    tric->SetDuration(duration);
+                    tric->SetMaxDuration(duration);
+                }
+            }
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration as for 5 points
+            if (_spec == BOT_SPEC_ROGUE_ASSASINATION && lvl >= 55 && (baseId == EVISCERATE_1 || baseId == ENVENOM_1) && GetSpell(SLICE_DICE_1))
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 duration = 21000 + 3000 + 12000; //base + glyph + improved
+                    dice->SetDuration(duration);
+                    dice->SetMaxDuration(duration);
+                }
+            }
+            //Waylay
+            if ((_spec == BOT_SPEC_ROGUE_SUBTLETY) && lvl >= 45 && (baseId == BACKSTAB_1 || baseId == AMBUSH_1))
+                me->CastSpell(target, WAYLAY_DEBUFF, true);
+
+            //Stun: move behind
+            if (baseId == CHEAP_SHOT_1 || baseId == KIDNEY_SHOT_1 || baseId == GOUGE_1)
+                if (target == opponent)
+                    MoveBehind(target);
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void CheckAttackState() override
+        {
+            if (me->GetVictim() && HasRole(BOT_ROLE_DPS) && !me->HasAuraType(SPELL_AURA_MOD_STEALTH) &&
+                (me->isAttackReady() || me->isAttackReady(OFF_ATTACK)) &&
+                (!me->GetVictim()->GetAuraEffect(SPELL_AURA_MOD_STUN, SPELLFAMILY_ROGUE, 0x8, 0x0, 0x0) &&
+                !me->GetVictim()->GetAuraEffect(SPELL_AURA_MOD_CONFUSE, SPELLFAMILY_ROGUE, 0x01000000, 0x0, 0x0)))
+                DoMeleeAttackIfReady();
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_COMBO_POINTS:
+                    return comboPoints;
+                case BOTAI_MISC_ENCHANT_IS_AUTO_MH:
+                    return needChooseMHEnchant;
+                case BOTAI_MISC_ENCHANT_IS_AUTO_OH:
+                    return needChooseOHEnchant;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    return mhEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    return ohEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    return mhEnchant;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    return ohEnchant;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_1:
+                    return GetSpell(CRIPPLING_POISON_1) ? CRIPPLING_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_2:
+                    return GetSpell(INSTANT_POISON_1) ? INSTANT_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_3:
+                    return GetSpell(MIND_NUMBING_POISON_1) ? MIND_NUMBING_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_4:
+                    return GetSpell(DEADLY_POISON_1) ? DEADLY_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_5:
+                    return GetSpell(WOUND_POISON_1) ? WOUND_POISON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_6:
+                    return GetSpell(ANESTHETIC_POISON_1) ? ANESTHETIC_POISON_1 : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_DAGGER_MAINHAND:
+                    isdaggerMH = bool(value);
+                    break;
+                case BOTAI_MISC_DAGGER_OFFHAND:
+                    isdaggerOH = bool(value);
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    if (value)
+                        mhEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    if (value)
+                        ohEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    mhEnchant = value;
+                    needChooseMHEnchant = value ? false : true;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    ohEnchant = value;
+                    needChooseOHEnchant = value ? false : true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            energy = 0;
+            comboPoints = 0;
+            combopointsSpent = false;
+            glyphSSProc = false;
+
+            mhEnchantExpireTimer = 1;
+            ohEnchantExpireTimer = 1;
+
+            DefaultInit();
+
+            mhEnchant = 0;
+            ohEnchant = 0;
+            needChooseMHEnchant = true;
+            needChooseOHEnchant = true;
+
+            //after InitEquips
+            Item const* mh = GetEquips(BOT_SLOT_MAINHAND);
+            Item const* oh = GetEquips(BOT_SLOT_OFFHAND);
+            isdaggerMH = mh && mh->GetTemplate()->Class == ITEM_CLASS_WEAPON && mh->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER;
+            isdaggerOH = oh && oh->GetTemplate()->Class == ITEM_CLASS_WEAPON && oh->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER;
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (mhEnchantExpireTimer > diff)            mhEnchantExpireTimer -= diff;
+            if (ohEnchantExpireTimer > diff)            ohEnchantExpireTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            //Hack for power
+            me->SetPowerType(POWER_ENERGY);
+
+            if (energy)
+                me->SetPower(POWER_ENERGY, energy);
+            else
+                me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isAssa = _spec == BOT_SPEC_ROGUE_ASSASINATION;
+            bool isComb = _spec == BOT_SPEC_ROGUE_COMBAT;
+            bool isSubt = _spec == BOT_SPEC_ROGUE_SUBTLETY;
+
+            InitSpellMap(KICK_1);
+            //InitSpellMap(EXPOSE_ARMOR_1);
+            InitSpellMap(DISMANTLE_1);
+            InitSpellMap(FEINT_1);
+
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(ENVENOM_1);
+            InitSpellMap(RUPTURE_1);
+            InitSpellMap(DEADLY_THROW_1);
+            InitSpellMap(FAN_OF_KNIVES_1);
+
+            InitSpellMap(SPRINT_1);
+            InitSpellMap(EVASION_1);
+            InitSpellMap(BLIND_1);
+            InitSpellMap(VANISH_1);
+
+            InitSpellMap(GOUGE_1);
+
+            InitSpellMap(KIDNEY_SHOT_1);
+            InitSpellMap(SLICE_DICE_1);
+            InitSpellMap(CLOAK_OF_SHADOWS_1);
+            InitSpellMap(TRICKS_OF_THE_TRADE_1);
+
+            InitSpellMap(STEALTH_1);
+            //InitSpellMap(SAP_1);
+            InitSpellMap(GARROTE_1);
+            InitSpellMap(CHEAP_SHOT_1);
+            InitSpellMap(AMBUSH_1);
+
+            lvl >= 30 && isAssa ? InitSpellMap(COLD_BLOOD_1) : RemoveSpell(COLD_BLOOD_1);
+            lvl >= 50 && isAssa ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 60 && isAssa ? InitSpellMap(HUNGER_FOR_BLOOD_1) : RemoveSpell(HUNGER_FOR_BLOOD_1);
+
+            lvl >= 20 && isComb ? InitSpellMap(RIPOSTE_1) : RemoveSpell(RIPOSTE_1);
+            lvl >= 30 && isComb ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+            lvl >= 40 && isComb ? InitSpellMap(ADRENALINE_RUSH_1) : RemoveSpell(ADRENALINE_RUSH_1);
+            lvl >= 60 && isComb ? InitSpellMap(KILLING_SPREE_1) : RemoveSpell(KILLING_SPREE_1);
+
+            lvl >= 20 && isSubt ? InitSpellMap(GHOSTLY_STRIKE_1) : RemoveSpell(GHOSTLY_STRIKE_1);
+            lvl >= 30 && isSubt ? InitSpellMap(HEMORRHAGE_1) : RemoveSpell(HEMORRHAGE_1);
+            lvl >= 30 && isSubt ? InitSpellMap(PREPARATION_1) : RemoveSpell(PREPARATION_1);
+            lvl >= 40 && isSubt ? InitSpellMap(PREMEDITATION_1) : RemoveSpell(PREMEDITATION_1);
+            lvl >= 50 && isSubt ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            lvl >= 60 && isSubt ? InitSpellMap(SHADOW_DANCE_1) : RemoveSpell(SHADOW_DANCE_1);
+
+            //InitSpellMap(DISTRACT_1);
+
+            InitSpellMap(CRIPPLING_POISON_1);
+            InitSpellMap(INSTANT_POISON_1);
+            InitSpellMap(DEADLY_POISON_1);
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+            InitSpellMap(ANESTHETIC_POISON_1);
+
+            lvl >= 10 ? InitSpellMap(THISTLE_TEA) : RemoveSpell(THISTLE_TEA);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isAssa = _spec == BOT_SPEC_ROGUE_ASSASINATION;
+            bool isComb = _spec == BOT_SPEC_ROGUE_COMBAT;
+            bool isSubt = _spec == BOT_SPEC_ROGUE_SUBTLETY;
+
+            RefreshAura(REMORSELESS_ATTACKS, level >= 10 ? 1 : 0);
+            RefreshAura(VIGOR, level >= 20 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY2, isAssa && level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY1, isAssa && level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(IMPROVED_KIDNEY_SHOT, isAssa && level >= 30 ? 1 : 0);
+            RefreshAura(FLEET_FOOTED, isAssa && level >= 30 ? 1 : 0);
+            RefreshAura(SEAL_FATE5, isAssa && level >= 45 ? 1 : 0);
+            RefreshAura(SEAL_FATE4, isAssa && level >= 42 && level < 45 ? 1 : 0);
+            RefreshAura(SEAL_FATE3, isAssa && level >= 39 && level < 42 ? 1 : 0);
+            RefreshAura(SEAL_FATE2, isAssa && level >= 37 && level < 39 ? 1 : 0);
+            RefreshAura(SEAL_FATE1, isAssa && level >= 35 && level < 37 ? 1 : 0);
+            RefreshAura(MURDER, isAssa && level >= 35 ? 1 : 0);
+            RefreshAura(DEADLY_BREW, isAssa && level >= 40 ? 1 : 0);
+            RefreshAura(OVERKILL, isAssa && level >= 40 ? 1 : 0);
+            //RefreshAura(FOCUSED_ATTACKS, isAssa && level >= 45 ? 1 : 0);
+            RefreshAura(MASTER_POISONER, isAssa && level >= 50 ? 1 : 0);
+
+            RefreshAura(DUAL_WIELD_SPECIALIZATION, level >= 10 ? 1 : 0);
+            RefreshAura(IMPROVED_KICK, isComb && level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_SPRINT, isComb && level >= 25 ? 1 : 0);
+            RefreshAura(HACK_AND_SLASH, isComb && level >= 30 ? 1 : 0);
+            //RefreshAura(BLADE_TWISTING1, isComb && level >= 35 ? 1 : 0);
+            RefreshAura(VITALITY, isComb && level >= 40 ? 1 : 0);
+            RefreshAura(NERVES_OF_STEEL, isComb && level >= 40 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY5, isComb && level >= 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY4, isComb && level >= 52 && level < 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY3, isComb && level >= 49 && level < 52 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY2, isComb && level >= 47 && level < 49 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY1, isComb && level >= 45 && level < 47 ? 1 : 0);
+            RefreshAura(THROWING_SPECIALIZATION, isComb && level >= 45 ? 1 : 0);
+            //RefreshAura(SAVAGE_COMBAT, isComb && level >= 50 ? 1 : 0);
+            RefreshAura(UNFAIR_ADVANTAGE, isComb && level >= 50 ? 1 : 0);
+            RefreshAura(SURPRISE_ATTACKS, isComb && level >= 50 ? 1 : 0);
+            RefreshAura(PREY_ON_THE_WEAK, isComb && level >= 55 ? 1 : 0);
+
+            RefreshAura(MASTER_OF_DECEPTION, level >= 10 ? 1 : 0);
+            RefreshAura(SETUP, isSubt && level >= 25 ? 1 : 0);
+            RefreshAura(INITIATIVE, isSubt && level >= 25 ? 1 : 0);
+            RefreshAura(DIRTY_DEEDS, isSubt && level >= 30 ? 1 : 0);
+            RefreshAura(MASTER_OF_SUBTLETY, isSubt && level >= 35 ? 1 : 0);
+            RefreshAura(CHEAT_DEATH, isSubt && level >= 40 ? 1 : 0);
+            RefreshAura(ENVELOPING_SHADOWS, isSubt && level >= 40 ? 1 : 0);
+            RefreshAura(TURN_THE_TABLES, isSubt && level >= 55 ? 1 : 0);
+            //RefreshAura(HONOR_AMONG_THIEVES, isSubt && level >= 55 ? 1 : 0);
+
+            RefreshAura(VIGOR_GLADIATOR, level >= 70 ? 1 : 0);
+
+            RefreshAura(GLYPH_BACKSTAB, level >= 15 ? 1 : 0);
+
+            RefreshAura(ROGUE_PASSIVE_DND);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case STEALTH_1:
+                case SPRINT_1:
+                case VANISH_1:
+                case BLADE_FLURRY_1:
+                case FAN_OF_KNIVES_1:
+                case TRICKS_OF_THE_TRADE_1:
+                case PREPARATION_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const override
+        {
+            float bonus = 0.0f;
+
+            //Serrated Blades part 1
+            if (me->GetLevel() >= 20)
+                bonus += 9.f;
+
+            //Mace Specialization: 15% armor penetration
+            if (me->GetLevel() >= 30)
+                if (Item const* weap = GetEquips(BOT_SLOT_MAINHAND))
+                    if (weap->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_MACE)
+                        bonus += 15.f;
+
+            return bonus + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(Player const* player, std::list<std::string> &specList) override
+        {
+            uint32 textId1, textId2;
+            switch (mhEnchant)
+            {
+                case CRIPPLING_POISON_1:    textId1 = BOT_TEXT_CRIPPLING;   break;
+                case INSTANT_POISON_1:      textId1 = BOT_TEXT_INSTANT;     break;
+                case DEADLY_POISON_1:       textId1 = BOT_TEXT_DEADLY;      break;
+                case WOUND_POISON_1:        textId1 = BOT_TEXT_WOUND;       break;
+                case MIND_NUMBING_POISON_1: textId1 = BOT_TEXT_MINDNUMBING; break;
+                case ANESTHETIC_POISON_1:   textId1 = BOT_TEXT_ANESTHETIC;  break;
+                default:                    textId1 = BOT_TEXT_NOTHING_C;   break;
+            }
+            switch (ohEnchant)
+            {
+                case CRIPPLING_POISON_1:    textId2 = BOT_TEXT_CRIPPLING;   break;
+                case INSTANT_POISON_1:      textId2 = BOT_TEXT_INSTANT;     break;
+                case DEADLY_POISON_1:       textId2 = BOT_TEXT_DEADLY;      break;
+                case WOUND_POISON_1:        textId2 = BOT_TEXT_WOUND;       break;
+                case MIND_NUMBING_POISON_1: textId2 = BOT_TEXT_MINDNUMBING; break;
+                case ANESTHETIC_POISON_1:   textId2 = BOT_TEXT_ANESTHETIC;  break;
+                default:                    textId2 = BOT_TEXT_NOTHING_C;   break;
+            }
+            specList.push_back(LocalizedNpcText(player, BOT_TEXT_SLOT_MH) + ": " + LocalizedNpcText(player, textId1));
+            specList.push_back(LocalizedNpcText(player, BOT_TEXT_SLOT_OH) + ": " + LocalizedNpcText(player, textId2));
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Rogue_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Rogue_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Rogue_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Rogue_spells_support;
+        }
+
+    private:
+        mutable bool glyphSSProc;
+        int32 energy;
+        uint8 comboPoints;
+        bool combopointsSpent;
+        bool isdaggerMH, isdaggerOH;
+        uint32 mhEnchantExpireTimer, ohEnchantExpireTimer;
+        uint32 mhEnchant, ohEnchant;
+        bool needChooseMHEnchant, needChooseOHEnchant;
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_sea_witch_ai.cpp b/src/server/game/AI/NpcBots/bot_sea_witch_ai.cpp
new file mode 100644
index 000000000..ba6d8cf2c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_sea_witch_ai.cpp
@@ -0,0 +1,771 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "TemporarySummon.h"
+/*
+Naga Sea Witch NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+A vicious scaly denizen of ocean often associated with the coming of prodigious storms (Warcraft III tribute)
+Specifics:
+Spell damage taken reduced by 30%, partially immune to control effects, cloth armor,
+deals physical/spellfrost/spellstorm damage, attack power bonus: agility x2, spell power bonus: 200% intellect. Main attribute: intellect
+Abilities:
+1) Forked Lightning. Calls forth a cone of lightning to damage enemies. Hits 2 to all targets (depending on hero level),
+stunning them for 2 seconds. This damage generates no threat
+2) Frost Arrows. Imbues arrow with spellfrost for extra damage, slowing target's
+movement, attack and casting speed by up to 70% (depending on hero level)
+3) Mana Shield. Creates a shield that absorbs 100% incoming (non-mitigated) damage by using Sea Witch's mana,
+absorbs 2 to 10 damage per point of mana (depending on hero level)
+4) Tornado. Summons a fierce tornado that damages and slows nearby enemy units, sometimes incapacitating them completely.
+Tornado grows over time oudoors, increasing damage dealt and area of effect, but shrinks indoors, dissipating quickly
+5ex) Shot. Normal shoot
+6ex) Naga (passive). Swim speed increased by 200%. Damage and dodge chance are greatly increased while in water
+Complete - 100%
+*/
+
+enum SeaWitchBaseSpells
+{
+    //AUTO_SHOT_1                         = 75,
+    SHOOT_BOW_1                         = SPELL_SHOOT_BOW,
+    FORKED_LIGHTNING_1                  = SPELL_FORKED_LIGHTNING,
+    FROST_ARROW_1                       = SPELL_FROST_ARROW,
+    MANA_SHIELD_1                       = SPELL_MANA_SHIELD,
+    TORNADO_1                           = SPELL_TORNADO
+};
+enum SeaWitchPassives
+{
+};
+enum SeaWitchSpecial
+{
+    MH_ATTACK_ANIM                      = SPELL_ATTACK_MELEE_1H,
+
+    FORKEDLIGHTNING_COST                = 110 * 5,
+    FROSTARROW_COST                     = 10 * 5,
+    TORNADO_COST                        = 250 * 5,
+
+    FORKED_LIGHTNING_EFFECT             = SPELL_FORKED_LIGHTNING_EFFECT,
+    FROST_ARROW_EFFECT                  = SPELL_FROST_ARROW_EFFECT,
+
+    NAGA_SWIM_PASSIVE                   = 40513,
+    SPELL_THREAT_MOD                    = 31745, //Salvation
+
+    SPELL_PARALYTIC_POISON              = 35201
+};
+
+static constexpr size_t TORNADO_MIN_TARGETS = 4u;
+
+static const uint32 Seawitch_spells_damage_arr[] =
+{ FORKED_LIGHTNING_1, FROST_ARROW_1, TORNADO_1 };
+
+static const uint32 Seawitch_spells_cc_arr[] =
+{ FROST_ARROW_1, TORNADO_1 };
+
+static const uint32 Seawitch_spells_support_arr[] =
+{ MANA_SHIELD_1 };
+
+static const std::vector<uint32> Seawitch_spells_damage(FROM_ARRAY(Seawitch_spells_damage_arr));
+static const std::vector<uint32> Seawitch_spells_cc(FROM_ARRAY(Seawitch_spells_cc_arr));
+static const std::vector<uint32> Seawitch_spells_support(FROM_ARRAY(Seawitch_spells_support_arr));
+
+class sea_witch_bot : public CreatureScript
+{
+public:
+    sea_witch_bot() : CreatureScript("sea_witch_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new sea_witch_botAI(creature);
+    }
+
+    struct sea_witch_botAI : public bot_ai
+    {
+        sea_witch_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SEA_WITCH;
+
+            InitUnitFlags();
+
+            //sea witch immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_RANGED, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            //Sea Witch is immune to poisons
+            me->ApplySpellImmune(0, IMMUNITY_DISPEL, DISPEL_POISON, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { /*UnsummonAll();*/ bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+
+        void CheckManaShield(uint32 diff)
+        {
+            if (me->HasAuraType(SPELL_AURA_MANA_SHIELD) || me->HasAuraType(SPELL_AURA_SCHOOL_ABSORB))
+                return;
+
+            if (IsSpellReady(MANA_SHIELD_1, diff, false) && GetManaPCT(me) >= 25 && me->IsInCombat())
+                if (doCast(me, GetSpell(MANA_SHIELD_1)))
+                    return;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(FORKED_LIGHTNING_1, diff, false) || !HasRole(BOT_ROLE_DPS) || Rand() > 55)
+                return;
+
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(FORKED_LIGHTNING_1) - 5.f, 0, FORKED_LIGHTNING_1))
+            {
+                Spell const* spell = target->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+                if (!spell)
+                    spell = target->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+
+                if (spell && spell->GetTimer() > int32(sSpellMgr->GetSpellInfo(GetSpell(FORKED_LIGHTNING_1))->CalcCastTime() + 250))
+                {
+                    me->SetFacingTo(me->GetAbsoluteAngle(target));
+                    if (doCast(target, GetSpell(FORKED_LIGHTNING_1)))
+                        return;
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+            {
+                uint32 const baseId = spell->GetSpellInfo()->GetFirstRankSpell()->Id;
+                //Tornado interrupt
+                if (!me->IsInCombat() && baseId == TORNADO_1)
+                    me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                else if (baseId == FORKED_LIGHTNING_1 && (!me->GetVictim() || !me->HasInArc(float(M_PI) / 2.f, me->GetVictim())))
+                    me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                else if (_spell_preact && spell->GetTimer() < 400)
+                {
+                    _spell_preact = false;
+                    switch (baseId)
+                    {
+                        case TORNADO_1:
+                        //    BotSay("REAP THE STORM!");
+                        //[[fallthrough]];
+                        case FORKED_LIGHTNING_1:
+                            me->CastSpell(me, MH_ATTACK_ANIM, true);
+                            break;
+                        default:
+                            break;
+                    }
+                }
+            }
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < FORKEDLIGHTNING_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 30)
+                    DrinkPotion(false);
+            }
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            CheckManaShield(diff);
+
+            if (!CheckAttackTarget())
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            Counter(diff);
+
+            if (IsCasting())
+                return;
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            float dist = me->GetDistance(mytar);
+            static constexpr float maxRangeLong = 35.f;
+
+            //bool inpostion = !mytar->HasAuraType(SPELL_AURA_MOD_SPEED_SLOW_ALL) || dist > maxRangeLong - 20.f;
+
+            //Auto Shot
+            //Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL);
+            //if (shot && shot->GetSpellInfo()->Id == AUTO_SHOT_1 && (shot->m_targets.GetUnitTarget() != mytar || !inpostion))
+            //    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //RANGED SECTION
+            if (dist > maxRangeLong)
+                return;
+
+            if (CheckForkedLightning(diff))
+                return;
+
+            if (CheckTornado(diff))
+                return;
+
+            if (/*inpostion && */!me->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+            {
+                //Frost Arrow / Autoshot
+                if (IsSpellReady(FROST_ARROW_1, diff) && me->GetPower(POWER_MANA) >= FROSTARROW_COST &&
+                    !mytar->IsImmunedToDamage(sSpellMgr->GetSpellInfo(FROST_ARROW_1)))
+                {
+                    if (doCast(mytar, GetSpell(FROST_ARROW_1)))
+                        return;
+                }
+                else if (IsSpellReady(SHOOT_BOW_1, diff))
+                {
+                    if (doCast(mytar, SHOOT_BOW_1))
+                        return;
+                }
+            }
+        }
+
+        bool CheckTornado(uint32 diff)
+        {
+            if (!IsSpellReady(TORNADO_1, diff, false) || !me->GetVictim() || me->GetPower(POWER_MANA) < TORNADO_COST || Rand() > 50)
+                return false;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsList(targets, 40.f, 0);
+            targets.erase(std::remove_if(targets.begin(), targets.end(), [healthThreshold = uint32(me->GetMaxHealth() / 4 * 3)](Unit const* u) {
+                return u->GetHealth() < healthThreshold;
+            }), targets.end());
+
+            size_t targets_count = (IAmFree() || !master->GetGroup()) ? TORNADO_MIN_TARGETS : std::max<size_t>(master->GetGroup()->GetMemberSlots().size() / 3, TORNADO_MIN_TARGETS);
+            if (targets.size() >= targets_count)
+            {
+                me->SetFacingTo(me->GetAbsoluteAngle(me->GetVictim()));
+                if (doCast(me->GetVictim(), GetSpell(TORNADO_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool CheckForkedLightning(uint32 diff)
+        {
+            if (!IsSpellReady(FORKED_LIGHTNING_1, diff, false) || !me->GetVictim() || me->GetPower(POWER_MANA) < FORKEDLIGHTNING_COST ||
+                Rand() > 90 || !me->HasInArc(float(M_PI), me->GetVictim()))
+                return false;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsInConeList(targets, CalcSpellMaxRange(FORKED_LIGHTNING_1) - 5.f);
+            if (targets.size() > ((me->GetLevel() < 60) ? 1u : 0u))
+            {
+                me->SetFacingTo(me->GetAbsoluteAngle(me->GetVictim()));
+                if (doCast(me->GetVictim(), GetSpell(FORKED_LIGHTNING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& /*damageinfo*/) const override
+        {
+            if (IsInContactWithWater())
+            {
+                //TC_LOG_ERROR("scripts", "ApplyClassDamageMultiplierMelee: %s now in water", me->GetName().c_str());
+                damage *= 3;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const override
+        {
+            if (IsInContactWithWater())
+            {
+                //TC_LOG_ERROR("scripts", "ApplyClassDamageMultiplierMelee: %s now in water", me->GetName().c_str());
+                damage *= 3;
+            }
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            if (IsInContactWithWater())
+            {
+                //TC_LOG_ERROR("scripts", "ApplyClassDamageMultiplierSpell: %s now in water", me->GetName().c_str());
+                fdamage *= 3.f;
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                if (/*baseId == FROST_ARROW_1 || */baseId == FORKED_LIGHTNING_1)
+                    pctbonus *= 1.33f;
+            }
+
+            damage = int32(fdamage * pctbonus + flat_mod);
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //if ()
+            //    pctbonus += 1.0f;
+
+            //pct mods
+            //Frost Arrow affect by attack speed
+            if (baseId == FROST_ARROW_1)
+                pctbonus += 1.0f - me->m_modAttackSpeedPct[RANGED_ATTACK];
+
+            //flat mods
+            //Starlight Wrath: -0.5 sec cast time for Wrath and Starfire
+            //if (lvl >= 10 && (baseId == WRATH_1 || baseId == STARFIRE_1))
+            //    timebonus += 500;
+
+            casttime = std::max<int32>(int32((float(casttime) * (1.0f - pctbonus)) - timebonus), 0);
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == FORKED_LIGHTNING_1)
+            {
+                switch (lvl / 10)
+                {
+                    case 8: targets = 666; break;
+                    case 7: targets =  10; break;
+                    case 6: targets =   7; break;
+                    case 5: targets =   6; break;
+                    case 4: targets =   5; break;
+                    case 3: targets =   4; break;
+                    case 2: targets =   3; break;
+                    case 1: targets =   3; break;
+                    default:               break;
+                }
+            }
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            if (baseId == FROST_ARROW_EFFECT && (effIndex == EFFECT_0 || effIndex == EFFECT_1))
+            {
+                switch (lvl / 10)
+                {
+                    case 8: case 7: case 6: value = -70; break;
+                    case 5: case 4:         value = -50; break;
+                    default:                             break;
+                }
+            }
+
+            value = value * pctbonus;
+        }
+
+        void ApplyClassEffectValueMultiplierMods(SpellInfo const* spellInfo, SpellEffIndex effIndex, float& multiplier) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Mana Shield absorption modifier
+            //Base is 10.f
+            if (baseId == MANA_SHIELD_1 && effIndex == EFFECT_0)
+                pctbonus *= _manaPerDamageMult();
+
+            multiplier = multiplier * pctbonus;
+        }
+
+        void OnClassSpellStart(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            switch (baseId)
+            {
+                case FORKED_LIGHTNING_1:
+                case TORNADO_1:
+                    _spell_preact = true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            switch (baseId)
+            {
+                case FROST_ARROW_1:
+                case FORKED_LIGHTNING_1:
+                case TORNADO_1:
+                {
+                    uint32 attackTime = uint32(me->GetAttackTime(RANGED_ATTACK) * me->m_modAttackSpeedPct[RANGED_ATTACK]);
+                    if (baseId == FROST_ARROW_1)
+                    {
+                        uint32 castTime = spellInfo->CalcCastTime();
+                        GC_Timer = castTime >= attackTime ? 0 : attackTime - castTime;
+                    }
+                    if (baseId == FORKED_LIGHTNING_1 || baseId == TORNADO_1)
+                    {
+                        me->resetAttackTimer();
+                        GC_Timer = attackTime;
+                        //me->CastSpell(me, MH_ATTACK_ANIM, true);
+                    }
+                    break;
+                }
+                default:
+                    break;
+            }
+
+            if (baseId == TORNADO_1)
+                SummonBotPet();
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (target == me)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+
+            if (baseId == FORKED_LIGHTNING_1)
+            {
+                //Forked Lightning stun
+                me->CastSpell(target, FORKED_LIGHTNING_EFFECT, true);
+            }
+            if (baseId == FROST_ARROW_1)
+            {
+                if (AuraEffect* sarr = target->GetAuraEffect(SPELL_AURA_MOD_SPEED_SLOW_ALL, SPELLFAMILY_GENERIC, 0x0, 0x4, 0x0, me->GetGUID()))
+                {
+                    sarr->GetBase()->RefreshDuration();
+                }
+                else if (Aura* arro = me->AddAura(FROST_ARROW_EFFECT, target))
+                {
+                    int32 dur = target->IsPlayer() ? 2000 : 6000;
+                    arro->SetDuration(dur);
+                    arro->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == SPELL_PARALYTIC_POISON)
+            {
+                if (Aura* para = target->GetAura(SPELL_PARALYTIC_POISON, me->GetGUID()))
+                {
+                    static constexpr int32 duration_threshold = 6000;
+                    if (para->GetMaxDuration() > duration_threshold)
+                    {
+                        para->SetDuration(duration_threshold);
+                        para->SetMaxDuration(duration_threshold);
+                    }
+                    else
+                        para->RefreshDuration();
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDamageDealt(Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType /*damagetype*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (damage && victim && (cleanDamage->attackType == BASE_ATTACK || cleanDamage->attackType == OFF_ATTACK) &&
+                victim->IsWithinCombatRange(me, ATTACK_DISTANCE))
+            {
+                if (urand(0, 100) < 5)
+                {
+                    int32 baseAmount = 1;
+                    if (AuraEffect* pois = victim->GetAuraEffect(SPELL_PARALYTIC_POISON, EFFECT_0, me->GetGUID()))
+                        baseAmount = pois->GetAmount() * 2;
+                    else
+                        baseAmount = int32(me->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) + 1;
+                    CastSpellExtraArgs args(true);
+                    args.AddSpellBP0(baseAmount);
+                    me->CastSpell(victim, SPELL_PARALYTIC_POISON, args);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (damage && me->HasAuraType(SPELL_AURA_MANA_SHIELD))
+                me->RemoveAurasDueToSpell(MANA_SHIELD_1);
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* /*summon*/) const override
+        {
+            return 0;
+        }
+
+        void SummonBotPet()
+        {
+            if (!_minions.empty())
+                UnsummonAll();
+
+            Position spos;
+            if (Unit const* mytar = me->GetVictim())
+                mytar->GetNearPoint(mytar, spos.m_positionX, spos.m_positionY, spos.m_positionZ, me->GetDistance2d(mytar) * 0.25f, mytar->GetAbsoluteAngle(me));
+            else
+                me->GetNearPoint(me, spos.m_positionX, spos.m_positionY, spos.m_positionZ, 10.f, 0.f);
+
+            Creature* myPet = me->SummonCreature(BOT_PET_TORNADO, spos, TEMPSUMMON_MANUAL_DESPAWN);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+            myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, TORNADO_1);
+
+            CreatureMovementData& cmData = const_cast<CreatureMovementData&>(myPet->GetMovementTemplate());
+            cmData.Swim = false;
+            cmData.Ground = CreatureGroundMovementType::Run;
+            cmData.Flight = CreatureFlightMovementType::None;
+
+            _minions.insert(myPet);
+        }
+
+        void UnsummonAll() override
+        {
+            while (!_minions.empty())
+                (*_minions.begin())->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDies: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (_minions.find(summon) != _minions.end())
+                _minions.erase(summon);
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(FROST_ARROW_1) - 6.f : CalcSpellMaxRange(FROST_ARROW_1) - 15.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_TORNADO;
+                default:
+                    return 0;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            _spell_preact = false;
+
+            DefaultInit();
+
+            //swim mod
+            if (Aura* swim = me->AddAura(NAGA_SWIM_PASSIVE, me))
+                swim->GetEffect(0)->ChangeAmount(200);
+
+            //threat mod
+            if (Aura* threat = me->AddAura(SPELL_THREAT_MOD, me))
+                threat->GetEffect(0)->ChangeAmount(-50);
+        }
+
+        void ReduceCD(uint32 /*diff*/) override
+        {
+            //if (trapTimer > diff)                   trapTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            //uint8 lvl = me->GetLevel();
+            //InitSpellMap(AUTO_SHOT_1);
+            InitSpellMap(SHOOT_BOW_1);
+            InitSpellMap(FORKED_LIGHTNING_1);
+            InitSpellMap(FROST_ARROW_1);
+            InitSpellMap(MANA_SHIELD_1);
+            InitSpellMap(TORNADO_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        //bool CanUseManually(uint32 basespell) const override
+        //{
+        //    switch (basespell)
+        //    {
+        //        case FORKED_LIGHTNING_1:
+        //        case TORNADO_1:
+        //            return true;
+        //        default:
+        //            return false;
+        //    }
+        //}
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(Player const* player, std::list<std::string> &specList) override
+        {
+            bool amount_is_mana = true;
+            float amount = sSpellMgr->AssertSpellInfo(MANA_SHIELD_1)->GetEffect(EFFECT_0).CalcValueMultiplier(me); //mana per damage
+            if (amount < 1.0f)
+            {
+                amount_is_mana = false;
+                amount = 1.f / amount;
+            }
+
+            std::ostringstream amount_sstr;
+            amount_sstr.setf(std::ios_base::fixed);
+            amount_sstr.precision(1);
+            amount_sstr << amount;
+            uint32 text_id = amount_is_mana ? BOT_TEXT_MANA_PER_DAMAGE : BOT_TEXT_DAMAGE_PER_MANA;
+
+            specList.push_back(LocalizedNpcText(player, text_id) + ": " + amount_sstr.str());
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Seawitch_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Seawitch_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Seawitch_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Seawitch_spells_support;
+        }
+    private:
+        typedef std::set<Unit*> Summons;
+        Summons _minions;
+
+        bool _spell_preact;
+
+        float _manaPerDamageMult() const
+        {
+            switch (me->GetLevel() / 10)
+            {
+                case 8: return 1.f / 100.00f;
+                case 7: return 1.f /  50.00f;
+                case 6: return 1.f /  20.00f;
+                case 5: return 1.f /  10.00f;
+                case 4: return 1.f /   4.00f;
+                case 3: return 1.f /   2.50f;
+                case 2: return 1.f /   1.67f;
+                case 1: return 1.f /   1.25f;
+                default:return 1.f /   1.00f;
+            }
+        }
+    };
+};
+
+void AddSC_sea_witch_bot()
+{
+    new sea_witch_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 000000000..2538fcbd9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,2825 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "Group.h"
+#include "Item.h"
+#include "Log.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "Spell.h"
+#include "SpellMgr.h"
+#include "Totem.h"
+#include "WorldSession.h"
+/*
+Shaman NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - around 90%
+TODO: Elemental mastery (exclusive cd with NatSw), Lava Lash
+Problems:
+Unsummon elemental totems if Elementals are killed
+Aura application bug for bot in other subgroup, maybe caused by creatorGUID mismatch
+*/
+
+#define MAX_WOLVES 2
+#define MAX_TOTEMS 4
+
+enum ShamanBaseSpells
+{
+    HEALING_WAVE_1                      = 331,
+    CHAIN_HEAL_1                        = 1064,
+    LESSER_HEALING_WAVE_1               = 8004,
+    RIPTIDE_1                           = 61295,
+    ANCESTRAL_SPIRIT_1                  = 2008,
+    CURE_TOXINS_1                       = 526,
+    CLEANSE_SPIRIT_1                    = 51886,
+    FLAME_SHOCK_1                       = 8050,
+    EARTH_SHOCK_1                       = 8042,
+    FROST_SHOCK_1                       = 8056,
+    STORMSTRIKE_1                       = 17364,
+    LIGHTNING_BOLT_1                    = 403,
+    CHAIN_LIGHTNING_1                   = 421,
+    LAVA_BURST_1                        = 51505,
+    THUNDERSTORM_1                      = 51490,
+    LIGHTNING_SHIELD_1                  = 324,
+    EARTH_SHIELD_1                      = 974,
+    WATER_SHIELD_1                      = 52127,
+    WATER_BREATHING_1                   = 131,
+    WATER_WALKING_1                     = 546,
+    PURGE_1                             = 370,
+    WIND_SHEAR_1                        = 57994,
+    HEX_1                               = 51514,
+    BLOODLUST_1                         = 2825,
+    HEROISM_1                           = 32182,
+    SHAMANISTIC_RAGE_1                  = 30823,
+    NATURES_SWIFTNESS_1                 = 16188,//castegory = 1202
+    //ELEMENTAL_MASTERY_1                 = 16166,//castegory = 1202 NYI
+    TIDAL_FORCE_1                       = 55198,
+
+    GHOST_WOLF_1                        = 2645,
+
+    FIRE_NOVA_1                         = 1535,//shaman spell
+    EARTHBIND_TOTEM_1                   = 2484,
+    MAGMA_TOTEM_1                       = 8190,
+    SEARING_TOTEM_1                     = 3599,
+    STONECLAW_TOTEM_1                   = 5730,
+    FIRE_ELEMENTAL_TOTEM_1              = 2894,
+    EARTH_ELEMENTAL_TOTEM_1             = 2062,
+    FIRE_RESISTANCE_TOTEM_1             = 8184,
+    FROST_RESISTANCE_TOTEM_1            = 8181,
+    NATURE_RESISTANCE_TOTEM_1           = 10595,
+    FLAMETONGUE_TOTEM_1                 = 8227,
+    GROUNDING_TOTEM_1                   = 8177,
+    SENTRY_TOTEM_1                      = 6495,
+    STONESKIN_TOTEM_1                   = 8071,
+    STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+    WINDFURY_TOTEM_1                    = 8512,
+    WRATH_OF_AIR_TOTEM_1                = 3738,
+    CLEANSING_TOTEM_1                   = 8170,
+    HEALING_STREAM_TOTEM_1              = 5394,
+    MANA_SPRING_TOTEM_1                 = 5675,
+    TOTEM_OF_WRATH_1                    = 30706,
+    MANA_TIDE_TOTEM_1                   = 16190,
+    TREMOR_TOTEM_1                      = 8143,
+
+    TOTEMIC_RECALL_1                    = 36936,
+
+    REINCARNATION_1                     = 21169,
+
+    FERAL_SPIRIT_1                      = 51533, //not casted
+
+    //ROCKBITER_WEAPON_1                  = 8017, //disabled due to bonus handling method
+    FLAMETONGUE_WEAPON_1                = 8024,
+    FROSTBRAND_WEAPON_1                 = 8033,
+    WINDFURY_WEAPON_1                   = 8232,
+    EARTHLIVING_WEAPON_1                = 51730
+};
+
+enum ShamanPassives
+{
+    //Elemental
+    ELEMENTAL_FOCUS                     = 16164,//clearcast
+    ELEMENTAL_DEVASTATION1              = 30160,
+    ELEMENTAL_DEVASTATION2              = 29179,
+    ELEMENTAL_DEVASTATION3              = 29180,
+    ELEMENTAL_OATH                      = 51470,//rank 2
+    //STORM_EARTH_AND_FIRE                = 51486,//rank 3
+    //Enchancement
+    TOUGHNESS                           = 16309,//rank 5
+    FLURRY1                             = 16256,
+    FLURRY2                             = 16281,
+    FLURRY3                             = 16282,
+    FLURRY4                             = 16283,
+    FLURRY5                             = 16284,
+    WEAPON_MASTERY                      = 29086,//rank 3
+    UNLEASHED_RAGE                      = 30809,//rank 3
+    STATIC_SHOCK                        = 51527,//rank 3
+    IMPROVED_STORMSTRIKE                = 51522,//rank 2
+    MAELSTROM_WEAPON1                   = 51528,
+    MAELSTROM_WEAPON2                   = 51529,
+    MAELSTROM_WEAPON3                   = 51530,
+    MAELSTROM_WEAPON4                   = 51531,
+    MAELSTROM_WEAPON5                   = 51532,
+    EARTHEN_POWER                       = 51524,//rank 2
+    //Restoration
+    ANCESTRAL_HEALING                   = 16240,//rank 3
+    ANCESTRAL_AWAKENING                 = 51558,//rank 3
+    IMPROVED_WATER_SHIELD               = 16198,//rank 3
+    TIDAL_WAVES                         = 51566,//rank 5
+    //Special
+    GLYPH_THUNDERSTORM                  = 62132,
+    GLYPH_TOTEM_OF_WRATH                = 63280,
+    SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+};
+
+enum ShamanSpecial
+{
+    SHAMAN_FLAME_SHOCK_PASSIVE          = 75461,//flame shock damage can be critical in 3.3.5, innate
+
+    ELEMENTAL_FOCUS_BUFF                = 16246,
+    TIDAL_FORCE_BUFF                    = 55166,//Unit::HandleAuraDummy(): case 55198:
+
+    MAELSTROM_WEAPON_BUFF               = 53817,
+    TIDAL_WAVES_BUFF                    = 53390,
+    STORMSTRIKE_DAMAGE                  = 32175,
+    STORMSTRIKE_DAMAGE_OFFHAND          = 32176,
+
+    LIGHTNING_SHIELD_DAMAGE_1           = 26364,
+    EARTH_SHIELD_HEAL                   = 379,
+
+    RESURRECTION_VISUAL_SPELL           = 21074, //Test NPC Resurrection
+
+    EXHAUSTION_AURA                     = 57723,
+    SATED_AURA                          = 57724,
+
+    WINDFURY_ATTACK_MAINHAND            = 25504,
+    WINDFURY_ATTACK_OFFHAND             = 33750,
+
+    STORMEARTHANDFIRE_EARTHGRAB         = 64695,
+
+    //TOTEM_AURA_WRATH_AURA1              = 57658,//100
+    //TOTEM_AURA_WRATH_AURA2              = 57660,//120
+    //TOTEM_AURA_WRATH_AURA3              = 57662,//140
+    //TOTEM_AURA_WRATH_AURA4              = 57663,//280
+    //TOTEM_AURA_RESISTANCE_FIRE_1        = 8185,
+    //TOTEM_AURA_RESISTANCE_FROST_1       = 8182,
+    //TOTEM_AURA_RESISTANCE_NATURE_1      = 10596,
+    //TOTEM_AURA_FLAMETONGUE_1            = 52109,
+    //TOTEM_AURA_GROUNDING                = 8178,
+    //TOTEM_AURA_STONESKIN_1              = 8072,
+    //TOTEM_AURA_STRENGTH_OF_EARTH_1      = 8076,
+    //TOTEM_AURA_WINDFURY                 = 8515,
+    //TOTEM_AURA_WRATH_OF_AIR             = 2895,
+    //TOTEM_AURA_MANA_SPRING_1            = 5677
+};
+
+enum TotemSlot
+{
+    T_FIRE  = 0,//m_SummonSlot[1]
+    T_EARTH = 1,//m_SummonSlot[2]
+    T_WATER = 2,//m_SummonSlot[3]
+    T_AIR   = 3,//m_SummonSlot[4]
+};
+enum BotTotemType : uint32
+{
+    BOT_TOTEM_NONE                  = 0,
+    BOT_TOTEM_STRENGTH_OF_EARTH     = 1, //main earth totem
+    BOT_TOTEM_FLAMETONGUE           = 2, //main fire totem
+    BOT_TOTEM_WRATH                 = 3, //main fire totem
+    BOT_TOTEM_MANA_SPRING           = 4, //main water totem
+    BOT_TOTEM_WINDFURY              = 5, //main air totem
+    BOT_TOTEM_WRATH_OF_AIR          = 6, //main air totem
+    BOT_TOTEM_STONESKIN             = 7, //secondary earth totem UNUSED
+    BOT_TOTEM_HEALING_STREAM        = 8, //secondary water totem UNUSED
+    BOT_TOTEM_TREMOR                = 9, //situative earth 1
+    BOT_TOTEM_EARTHBIND             = 10, //situative earth 2
+    BOT_TOTEM_MAGMA                 = 11, //situative fire 1
+    BOT_TOTEM_MANA_TIDE             = 12, //situative water 1
+    BOT_TOTEM_CLEANSING             = 13, //situative water 2 non-raid
+    BOT_TOTEM_GROUNDING             = 14, //situative air 1
+    BOT_TOTEM_RESISTANCE_FROST      = 15, //manual fire 1
+    BOT_TOTEM_RESISTANCE_FIRE       = 16, //manual water 1
+    BOT_TOTEM_RESISTANCE_NATURE     = 17, //manual air 1
+    BOT_TOTEM_ELEMENTAL_EARTH       = 18, //manual earth 1
+    BOT_TOTEM_ELEMENTAL_FIRE        = 19, //manual fire 2
+    BOT_TOTEM_SENTRY                = 20, //UNUSED
+    BOT_TOTEM_STONECLAW             = 21, //UNUSED
+    BOT_TOTEM_SEARING               = 22, //UNUSED, annoying as hell too
+    BOT_TOTEM_END,
+
+    BOT_TOTEM_FLAG_MY_TOTEM_FIRE,
+    BOT_TOTEM_FLAG_MY_TOTEM_EARTH,
+    BOT_TOTEM_FLAG_MY_TOTEM_WATER,
+    BOT_TOTEM_FLAG_MY_TOTEM_AIR,
+
+    BOT_TOTEM_MASK_SUMMONS          = ((1<<BOT_TOTEM_ELEMENTAL_EARTH)|(1<<BOT_TOTEM_ELEMENTAL_FIRE)),
+
+    //BOT_TOTEM_MASK_MY_TOTEM         = (1<<BOT_TOTEM_NONE),
+
+    BOT_TOTEM_MASK_STRENGTH_OF_EARTH= (1<<BOT_TOTEM_STRENGTH_OF_EARTH),
+    BOT_TOTEM_MASK_FLAMETONGUE      = (1<<BOT_TOTEM_FLAMETONGUE),
+    BOT_TOTEM_MASK_WRATH            = (1<<BOT_TOTEM_WRATH),
+    BOT_TOTEM_MASK_MANA_SPRING      = (1<<BOT_TOTEM_MANA_SPRING),
+    BOT_TOTEM_MASK_WINDFURY         = (1<<BOT_TOTEM_WINDFURY),
+    BOT_TOTEM_MASK_WRATH_OF_AIR     = (1<<BOT_TOTEM_WRATH_OF_AIR),
+    //BOT_TOTEM_MASK_STONESKIN        = (1<<BOT_TOTEM_STONESKIN),
+    BOT_TOTEM_MASK_MANA_TIDE        = (1<<BOT_TOTEM_MANA_TIDE),
+    BOT_TOTEM_MASK_GROUNDING        = (1<<BOT_TOTEM_GROUNDING),
+    BOT_TOTEM_MASK_RESISTANCE_FROST = (1<<BOT_TOTEM_RESISTANCE_FROST),
+    BOT_TOTEM_MASK_RESISTANCE_FIRE  = (1<<BOT_TOTEM_RESISTANCE_FIRE),
+    BOT_TOTEM_MASK_RESISTANCE_NATURE= (1<<BOT_TOTEM_RESISTANCE_NATURE),
+
+    BOT_TOTEM_MASK_PRIMARY_FIRE     = (BOT_TOTEM_MASK_FLAMETONGUE | BOT_TOTEM_MASK_WRATH),
+
+    BOT_TOTEM_MASK_MY_TOTEM_FIRE    = (1<<BOT_TOTEM_FLAG_MY_TOTEM_FIRE),
+    BOT_TOTEM_MASK_MY_TOTEM_EARTH   = (1<<BOT_TOTEM_FLAG_MY_TOTEM_EARTH),
+    BOT_TOTEM_MASK_MY_TOTEM_WATER   = (1<<BOT_TOTEM_FLAG_MY_TOTEM_WATER),
+    BOT_TOTEM_MASK_MY_TOTEM_AIR     = (1<<BOT_TOTEM_FLAG_MY_TOTEM_AIR),
+
+    BOT_TOTEM_MASK_PRIMARY_USE      = (BOT_TOTEM_MASK_STRENGTH_OF_EARTH | BOT_TOTEM_MASK_FLAMETONGUE | \
+                                    BOT_TOTEM_MASK_WRATH | BOT_TOTEM_MASK_MANA_SPRING | \
+                                    BOT_TOTEM_WINDFURY | BOT_TOTEM_MASK_WRATH_OF_AIR),
+
+    BOT_TOTEM_MASK_MY_TOTEM_ALL     = (BOT_TOTEM_MASK_MY_TOTEM_FIRE | BOT_TOTEM_MASK_MY_TOTEM_EARTH | \
+                                    BOT_TOTEM_MASK_MY_TOTEM_WATER | BOT_TOTEM_MASK_MY_TOTEM_AIR)
+};
+
+static const uint32 Shaman_spells_damage_arr[] =
+{ EARTH_SHOCK_1, FLAME_SHOCK_1, FROST_SHOCK_1, STORMSTRIKE_1, CHAIN_LIGHTNING_1, LAVA_BURST_1, LIGHTNING_BOLT_1,
+FIRE_NOVA_1, MAGMA_TOTEM_1, SEARING_TOTEM_1, LIGHTNING_SHIELD_1, THUNDERSTORM_1, EARTH_ELEMENTAL_TOTEM_1, FIRE_ELEMENTAL_TOTEM_1 };
+
+static const uint32 Shaman_spells_cc_arr[] =
+{ EARTHBIND_TOTEM_1, FROST_SHOCK_1, HEX_1, WIND_SHEAR_1 };
+
+static const uint32 Shaman_spells_heal_arr[] =
+{ EARTH_SHIELD_1, CHAIN_HEAL_1, LESSER_HEALING_WAVE_1, HEALING_WAVE_1, RIPTIDE_1, HEALING_STREAM_TOTEM_1 };
+
+static const uint32 Shaman_spells_support_arr[] =
+{ ANCESTRAL_SPIRIT_1, GHOST_WOLF_1, FERAL_SPIRIT_1, BLOODLUST_1, HEROISM_1, CURE_TOXINS_1, CLEANSE_SPIRIT_1,
+LIGHTNING_SHIELD_1, NATURES_SWIFTNESS_1, PURGE_1, REINCARNATION_1, SHAMANISTIC_RAGE_1, TIDAL_FORCE_1,
+/*WATER_BREATHING_1, */WATER_SHIELD_1, WATER_WALKING_1, /*ELEMENTAL_MASTERY_1, STONECLAW_TOTEM_1,*/
+FIRE_RESISTANCE_TOTEM_1, FROST_RESISTANCE_TOTEM_1, NATURE_RESISTANCE_TOTEM_1, FLAMETONGUE_TOTEM_1, GROUNDING_TOTEM_1,
+/*SENTRY_TOTEM_1, STONESKIN_TOTEM_1, */STRENGTH_OF_EARTH_TOTEM_1, WINDFURY_TOTEM_1, WRATH_OF_AIR_TOTEM_1,
+CLEANSING_TOTEM_1, MANA_SPRING_TOTEM_1, TOTEM_OF_WRATH_1, MANA_TIDE_TOTEM_1, TREMOR_TOTEM_1/*, TOTEMIC_RECALL_1,
+ROCKBITER_WEAPON_1, FLAMETONGUE_WEAPON_1, FROSTBRAND_WEAPON_1, WINDFURY_WEAPON_1, EARTHLIVING_WEAPON_1*/ };
+
+static const std::vector<uint32> Shaman_spells_damage(FROM_ARRAY(Shaman_spells_damage_arr));
+static const std::vector<uint32> Shaman_spells_cc(FROM_ARRAY(Shaman_spells_cc_arr));
+static const std::vector<uint32> Shaman_spells_heal(FROM_ARRAY(Shaman_spells_heal_arr));
+static const std::vector<uint32> Shaman_spells_support(FROM_ARRAY(Shaman_spells_support_arr));
+
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new shaman_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct shaman_botAI : public bot_ai
+    {
+        shaman_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SHAMAN;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        //only for totems
+        bool doCast(Unit* victim, uint32 spellId, TriggerCastFlags flags)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            if (bot_ai::doCast(victim, spellId, flags))
+            {
+                //Calls: 1.5 sec, totems: 1 sec
+                GC_Timer = (flags & TRIGGERED_CAST_DIRECTLY) ? 1500 : 1000;
+                return true;
+            }
+
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { TotemsCheckTimer = 0; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); removeShapeshiftForm(); bot_ai::JustDied(u); }
+
+        bool removeShapeshiftForm() override
+        {
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_GHOSTWOLF:
+                        me->RemoveAurasDueToSpell(GHOST_WOLF_1);
+                        break;
+                    default:
+                        break;
+                }
+            }
+
+            return true;
+        }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (BloodlustCheckTimer > diff || (!me->IsInCombat() && !master->IsInCombat()) ||
+                me->GetDistance(master) > 18 || Rand() > 35)
+                return;
+
+            BloodlustCheckTimer = 3000;
+
+            uint32 BLOODLUST = (me->GetRaceMask() & RACEMASK_ALLIANCE) ? HEROISM_1 : BLOODLUST_1;
+            if (!IsSpellReady(BLOODLUST, diff))
+                return;
+
+            //already rockin'
+            if (me->GetAuraEffect(SPELL_AURA_MOD_MELEE_RANGED_HASTE, SPELLFAMILY_SHAMAN, 0x0, 0x40, 0x0) ||
+                master->GetAuraEffect(SPELL_AURA_MOD_MELEE_RANGED_HASTE, SPELLFAMILY_SHAMAN, 0x0, 0x40, 0x0))
+                return;
+
+            //environment conditions
+            Unit const* u = me->GetVictim();
+            Creature const* cre = u ? u->ToCreature() : nullptr;
+            if (!(u && (u->GetHealth() > me->GetMaxHealth() * 10 || u->GetTypeId() == TYPEID_PLAYER ||
+                (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                me->getAttackers().size() + master->getAttackers().size() >= 8)))
+                return;
+
+            //BLOODLUST = GetSpell(BLOODLUST); //not ranked
+
+            uint32 sateSpell = (me->GetRaceMask() & RACEMASK_ALLIANCE) ? EXHAUSTION_AURA : SATED_AURA;
+            Unit::AuraEffectList const& dummies = me->GetAuraEffectsByType(SPELL_AURA_DUMMY);
+            for (Unit::AuraEffectList::const_iterator itr = dummies.begin(); itr != dummies.end(); ++itr)
+            {
+                if ((*itr)->GetEffIndex() != 0) continue;
+                SpellInfo const* spellInfo = (*itr)->GetSpellInfo();
+                if (spellInfo->SpellFamilyName != SPELLFAMILY_GENERIC || spellInfo->SpellIconID != 44) continue;
+                if (spellInfo->Id == sateSpell)
+                    return; //can't cast my type of bloodlust
+            }
+
+            me->InterruptNonMeleeSpells(true);
+            if (doCast(me, BLOODLUST))
+                return;
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            if (TotemsCheckTimer > diff)
+                return;
+
+            TotemsCheckTimer = urand(1500, 2000) + (!IAmFree() ? 100 * master->GetNpcBotsCount() / 2 : 0);
+
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != ObjectGuid::Empty &&
+                    (!master->IsAlive() || master->GetDistance(_totems[i].second._pos) > _totems[i].second._effradius) &&
+                    me->GetDistance(_totems[i].second._pos) > _totems[i].second._effradius)
+                {
+                    //Check if we can use totemic recall and regain some mana
+                    if (!me->GetVictim()/* && GetManaPCT(me) < 90*/ && IsSpellReady(TOTEMIC_RECALL_1, diff))
+                    {
+                        uint8 count = 0;
+                        for (uint8 j = 0; j != MAX_TOTEMS; ++j)
+                        {
+                            if (j == i || _totems[j].first == ObjectGuid::Empty) continue;
+                            if (me->GetDistance(_totems[j].second._pos) > 20.f)
+                                ++count;
+                        }
+                        if (count > 1)
+                        {
+                            if (doCast(me, GetSpell(TOTEMIC_RECALL_1)))
+                                return;
+                        }
+                    }
+                    Unit* to = ObjectAccessor::GetUnit(*me, _totems[i].first);
+                    if (!to)
+                    {
+                        TC_LOG_ERROR("entities.player", "%s has unexpectingly lost totem in slot %u!", me->GetName().c_str(), i);
+                        _totems[i].first = ObjectGuid::Empty;
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                    //reset summon check timer;
+                    TotemTimer[i] = 0;
+                }
+            }
+            //global cooldown is not performed below, intead there is a special condition for Calls
+            if (GC_Timer > diff || me->IsMounted() || Feasting() || IsCasting() ||
+                (master->IsAlive() && me->GetDistance(master) > 15))
+                return;
+
+            bool CotE = me->GetLevel() >= 30; //Call of the Elements is at level 30;
+
+            std::map<uint32, uint32> idMap;
+            uint32 mask = _getTotemsMask(idMap);
+
+            //EARTH
+            //EARTHsituative1 : tremor
+            if (TotemTimer[T_EARTH] <= diff && me->IsInCombat() && !IAmFree() &&
+                IsSpellReady(TREMOR_TOTEM_1, diff, false) && _totems[T_EARTH].second._type != BOT_TOTEM_TREMOR)
+            {
+                //Tremor no cd, party members only
+                Group const* gr = master->GetGroup();
+                if (gr && gr->IsMember(me->GetGUID()))
+                {
+                    uint8 subgr = gr->GetMemberGroup(me->GetGUID());
+                    uint8 count = 0;
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        if (ref->getSubGroup() != subgr) continue;
+                        Player* pl = ref->GetSource();
+                        if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                        if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                        if (me->GetDistance(pl) < 20 &&
+                            pl->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+                            ++count;
+
+                        if (!pl->HaveBot()) continue;
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            if (!gr->IsMember(it->second->GetGUID()) || gr->GetMemberGroup(it->second->GetGUID()) != subgr) continue;
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() ||
+                                !bot->InSamePhase(me) || me->GetDistance(bot) > 20) continue;
+                            if (bot->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+                                ++count;
+                        }
+                    }
+
+                    if (count >= (1 + 1*((mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) != 0)))
+                    {
+                        if (doCast(me, GetSpell(TREMOR_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            if (!CotE)
+                                return;
+                    }
+                }
+                //check if casted
+                if (_totems[T_EARTH].second._type != BOT_TOTEM_TREMOR)
+                    SetSpellCooldown(TREMOR_TOTEM_1, 3000); //fail
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) && TotemTimer[T_EARTH] <= diff && me->IsInCombat())
+            {
+                //EARTHsituative2 : earthbind
+                if (GetSpell(EARTHBIND_TOTEM_1)/* && _totems[T_EARTH].second.type != BOT_TOTEM_EARTHBIND*/)
+                {
+                    //15 sec cd, nearby enemies, instant effect
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 15.f, 1);
+                    for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                    {
+                        Unit* u = *itr;
+                        bool erase = false;
+                        if (u->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || u->HasAuraType(SPELL_AURA_MOD_SPEED_SLOW_ALL))
+                            erase = true;
+                        else if (u->isMoving())
+                        {
+                            if (me->GetDistance(u) > 10.f && !u->HasInArc(float(M_PI)/2, me))
+                                erase = true;
+                        }
+                        else if (me->GetDistance(u) > 9.f)
+                            erase = true;
+
+                        if (erase)
+                        {
+                            targets.erase(itr++);
+                            continue;
+                        }
+                        ++itr;
+                    }
+
+                    if (uint8(targets.size()) >= (1 + 2*((mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) != 0)))
+                    {
+                        if (doCast(me, GetSpell(EARTHBIND_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_EARTH) && TotemTimer[T_EARTH] <= diff && me->IsInCombat())
+            {
+                //EARTHmain : strength of earth
+                uint32 SoE = GetSpell(STRENGTH_OF_EARTH_TOTEM_1); //tripple check
+                if (SoE &&
+                    (!(mask & BOT_TOTEM_MASK_STRENGTH_OF_EARTH) || idMap[STRENGTH_OF_EARTH_TOTEM_1] < SoE))
+                {
+                    //no cd
+                    if (doCast(me, SoE, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+
+                //EARTHlast : earth elemental (for mass taunt)
+                //uint32 earthElem = GetSpell(EARTH_ELEMENTAL_TOTEM_1);
+                //if (earthElem && IsSpellReady(EARTH_ELEMENTAL_TOTEM_1, diff) && !me->GetMap()->IsDungeon() &&
+                //    me->getAttackers().size() > 1)
+                //{
+                //    //no cd
+                //    if (doCast(me, earthElem, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                //        if (!CotE)
+                //            return;
+                //}
+            }
+
+            //FIRE
+            //FIREsituative1 : magma
+            if (TotemTimer[T_FIRE] <= diff && me->IsInCombat() && !IAmFree() && HasRole(BOT_ROLE_DPS) &&
+                GetSpell(MAGMA_TOTEM_1)/* && _totems[T_FIRE].second.type != BOT_TOTEM_MAGMA*/)
+            {
+                //magma no cd 8 yd, 2 sec delay before first tick
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 13.f, 1);
+                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                {
+                    Unit* u = *itr;
+                    bool erase = false;
+                    if (u->isMoving())
+                    {
+                        if (me->GetDistance(u) > 10.f && !u->HasInArc(float(M_PI)/2, me))
+                            erase = true;
+                    }
+                    else if (me->GetDistance(u) > 7.f)
+                        erase = true;
+
+                    if (erase)
+                    {
+                        targets.erase(itr++);
+                        continue;
+                    }
+                    ++itr;
+                }
+
+                if (uint8(targets.size()) >= (3 + 3*((mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) != 0)))
+                {
+                    if (doCast(me, GetSpell(MAGMA_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) && me->IsInCombat() && TotemTimer[T_FIRE] <= diff)
+            {
+                //FIREMain : wrath or flametongue no cd
+                //aura is exclusive so check mask
+                uint32 base = TOTEM_OF_WRATH_1;
+                uint32 wrathTotem = GetSpell(TOTEM_OF_WRATH_1);
+                uint32 fMask = BOT_TOTEM_MASK_WRATH;
+                if (!wrathTotem)
+                {
+                    base = FLAMETONGUE_TOTEM_1;
+                    wrathTotem = GetSpell(FLAMETONGUE_TOTEM_1);
+                    fMask = BOT_TOTEM_MASK_FLAMETONGUE;
+                }
+                if (wrathTotem &&
+                    ((mask & BOT_TOTEM_MASK_PRIMARY_FIRE) < fMask ||
+                    ((mask & BOT_TOTEM_MASK_PRIMARY_FIRE) == fMask && idMap[base] < wrathTotem)))
+                {
+                    if (doCast(me, wrathTotem, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+
+                //FIREaddin : fire elemental
+                //uint32 fireElem = GetSpell(FIRE_ELEMENTAL_TOTEM_1);
+                //if (fireElem && IsSpellReady(FIRE_ELEMENTAL_TOTEM_1, diff) && !me->GetMap()->IsDungeon())
+                //{
+                //    if (doCast(me, fireElem, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                //        if (!CotE)
+                //            return;
+                //}
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_FIRE) && me->IsInCombat() && TotemTimer[T_FIRE] <= diff)
+            {
+                //FIRElastresort : frostres (3 shamans of same level req)
+                uint32 frostRes = GetSpell(FROST_RESISTANCE_TOTEM_1);
+                if (frostRes && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_FROST) || idMap[FROST_RESISTANCE_TOTEM_1] < frostRes))
+                {
+                    if (doCast(me, frostRes, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            //WATER
+            //WATERsituative1 : manatide
+            if (TotemTimer[T_WATER] <= diff && me->IsInCombat() && !IAmFree() &&
+                IsSpellReady(MANA_TIDE_TOTEM_1, diff, false))
+            {
+                //5 min cd, party members only, instant effect +4 ticks in 12 secs
+                bool cast = false;
+                Group const* gr = master->GetGroup();
+                if (gr && gr->IsMember(me->GetGUID()))
+                {
+                    uint8 count = 0;
+                    uint8 subgr = gr->GetMemberGroup(me->GetGUID());
+                    for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                    {
+                        if (ref->getSubGroup() != subgr) continue;
+                        Player* pl = ref->GetSource();
+                        if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                        if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                        if (pl->IsInCombat() && pl->GetPowerType() == POWER_MANA &&
+                            GetManaPCT(pl) < 35 && me->GetDistance(pl) < 25)
+                            ++count;
+
+                        if (!pl->HaveBot()) continue;
+                        BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            if (!gr->IsMember(it->second->GetGUID()) || gr->GetMemberGroup(it->second->GetGUID()) != subgr) continue;
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() || !bot->InSamePhase(me)) continue;
+                            if (bot->IsInCombat() && bot->GetPowerType() == POWER_MANA &&
+                                GetManaPCT(bot) < 35 && me->GetDistance(bot) < 20)
+                                ++count;
+                        }
+                    }
+                    cast = (count >= (3 + 1*((mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) != 0)));
+                }
+                if (!cast)
+                {
+                    if (master->IsInCombat() && master->GetPowerType() == POWER_MANA &&
+                        GetManaPCT(master) < 35 && me->GetDistance(master) < 18)
+                        cast = true;
+                    else if (me->IsInCombat() && GetManaPCT(me) < 35)
+                        cast = true;
+                }
+
+                if (cast)
+                {
+                    if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+                //check if casted
+                if (_totems[T_WATER].second._type != BOT_TOTEM_MANA_TIDE)
+                    SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+            }
+
+            //WATERsituative2 : cleansing
+            //REMOVED CHECKS ARE TOO HEAVY
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) && TotemTimer[T_WATER] <= diff)
+            {
+                //WATERmain : manaspring
+                uint32 MSpring = GetSpell(MANA_SPRING_TOTEM_1); //tripple check
+                if (MSpring && (me->IsInCombat() || !master->isMoving()) &&
+                    (!(mask & BOT_TOTEM_MASK_MANA_SPRING) || idMap[MANA_SPRING_TOTEM_1] < MSpring))
+                {
+                    //no cd
+                    bool cast = false;
+                    if (!IAmFree())
+                    {
+                        Group const* gr = master->GetGroup();
+                        if (gr)
+                        {
+                            for (GroupReference const* ref = gr->GetFirstMember(); ref != nullptr; ref = ref->next())
+                            {
+                                Player* pl = ref->GetSource();
+                                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                                if (pl->isMoving()) continue;
+                                if (pl->GetPowerType() == POWER_MANA && GetManaPCT(pl) < 85 && me->GetDistance(pl) < 25)
+                                {
+                                    cast = true;
+                                    break;
+                                }
+
+                                if (!pl->HaveBot()) continue;
+                                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                                {
+                                    Creature* bot = it->second;
+                                    if (!bot || !bot->IsInWorld() || me->GetMap() != bot->FindMap() || !bot->InSamePhase(me)) continue;
+                                    if (bot->GetPowerType() == POWER_MANA && GetManaPCT(bot) < 35 && me->GetDistance(bot) < 25)
+                                    {
+                                        cast = true;
+                                        break;
+                                    }
+                                }
+                                if (cast)
+                                    break;
+                            }
+                        }
+                        else if (!master->isMoving() && master->GetPowerType() == POWER_MANA && GetManaPCT(master) < 85)
+                            cast = true;
+                    }
+                    if (!me->isMoving() && GetManaPCT(me) < 95)
+                        cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, MSpring, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_WATER) && TotemTimer[T_WATER] <= diff)
+            {
+                //WATERlastresort : fireres (2-3 shamans of same level req)
+                uint32 fireRes = GetSpell(FIRE_RESISTANCE_TOTEM_1);
+                if (fireRes && TotemTimer[T_WATER] <= diff && me->IsInCombat() && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_FIRE) || idMap[FIRE_RESISTANCE_TOTEM_1] < fireRes))
+                {
+                    if (doCast(me, fireRes, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            //AIR
+            //AIRsituative1 : grounding
+            if (TotemTimer[T_AIR] <= diff && me->IsInCombat() &&/* !IAmFree() &&*/
+                IsSpellReady(GROUNDING_TOTEM_1, diff, false))
+            {
+                //grounding 15 sec cd, party members only (and bot and master of course)
+                bool cast = false;
+                Unit* u = FindCastingTarget(27); //totem must be within cast distance
+                if (u && !IsChanneling(u)) //do not waste grounding on periodic ticks
+                {
+                    Group const* gr = !IAmFree() ? master->GetGroup() : nullptr;
+                    for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    {
+                        if (Spell const* spell = u->GetCurrentSpell(i))
+                        {
+                            ObjectGuid tGuid = spell->m_targets.GetUnitTargetGUID();
+                            if (tGuid == me->GetGUID() || tGuid == master->GetGUID() ||
+                                (gr && gr->IsMember(tGuid) && gr->IsMember(me->GetGUID()) && gr->SameSubGroup(tGuid, me->GetGUID())))
+                            {
+                                Unit* t = ObjectAccessor::GetUnit(*me, tGuid);
+                                if (t && t->GetDistance(me) < 27 && !t->HasAuraType(SPELL_AURA_SPELL_MAGNET))
+                                    cast = true;
+                            }
+                            break;
+                        }
+                    }
+                }
+                if (cast)
+                {
+                    if (doCast(me, GetSpell(GROUNDING_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        if (!CotE)
+                            return;
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRmain1 : wrathofair - if windfury is disabled or me and master both casters
+                if (!(mask & BOT_TOTEM_MASK_WRATH_OF_AIR) && GetSpell(WRATH_OF_AIR_TOTEM_1))
+                {
+                    bool cast = false;
+
+                    if (!IsMelee() && HasRole(BOT_ROLE_DPS|BOT_ROLE_HEAL) && !IsMeleeClass(master->GetClass()))
+                        cast = true;
+                    else if (!GetSpell(WINDFURY_TOTEM_1)) //disabled
+                        cast = true;
+                    else if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR))
+                        if (mask & BOT_TOTEM_MASK_WINDFURY) //already have windfury from someone else
+                            cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, GetSpell(WRATH_OF_AIR_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            //if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRmain2 : windfury
+                if (!(mask & BOT_TOTEM_MASK_WINDFURY) && GetSpell(WINDFURY_TOTEM_1))
+                {
+                    bool cast = false;
+
+                    if ((IsMelee() && HasRole(BOT_ROLE_DPS)) || (!IAmFree() && IsMeleeClass(master->GetClass())))
+                        cast = true;
+                    else if (!GetSpell(WRATH_OF_AIR_TOTEM_1)) //disabled or not available yet
+                        cast = true;
+                    else if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR))
+                        if (mask & BOT_TOTEM_MASK_WRATH_OF_AIR) //already have wrath of air from someone else
+                            cast = true;
+
+                    if (cast)
+                    {
+                        if (doCast(me, GetSpell(WINDFURY_TOTEM_1), CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                            //if (!CotE)
+                                return;
+                    }
+                }
+            }
+
+            if (!(mask & BOT_TOTEM_MASK_MY_TOTEM_AIR) && TotemTimer[T_AIR] <= diff && me->IsInCombat())
+            {
+                //AIRlastresort : natureres (3-4 shamans of same level req)
+                uint32 natureRes = GetSpell(NATURE_RESISTANCE_TOTEM_1);
+                if (natureRes && !IAmFree() &&
+                    (!(mask & BOT_TOTEM_MASK_RESISTANCE_NATURE) || idMap[NATURE_RESISTANCE_TOTEM_1] < natureRes))
+                {
+                    if (doCast(me, natureRes, CotE ? TRIGGERED_CAST_DIRECTLY : TRIGGERED_NONE))
+                        //if (!CotE)
+                            return;
+                }
+            }
+        }
+
+        void CheckShamanisticRage(uint32 diff)
+        {
+            if (!IsSpellReady(SHAMANISTIC_RAGE_1, diff) || !me->IsInCombat() || IsCasting() || Rand() > 35)
+                return;
+
+            bool cast = false;
+            //case 1: hp pressure
+            if (GetHealthPCT(me) < (50 + 20 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) + 5 * uint32(me->getAttackers().size())))
+                cast = true;
+            //case 2: low mana (melee)
+            else if (me->GetVictim() && !CCed(me, true) && HasRole(BOT_ROLE_DPS) && IsMelee() && GetManaPCT(me) < 40)
+                cast = true;
+
+            if (cast && doCast(me, GetSpell(SHAMANISTIC_RAGE_1)))
+                return;
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff) || !me->IsAlive() || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 25)
+            {
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    return;
+            }
+
+            //case 2: AoE damage
+            //AttackerSet m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetDistance((*iter)) > 9) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 1)
+            {
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    return;
+            }
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || (HasRole(BOT_ROLE_HEAL) && IsCasting()) || Rand() > 40)
+                return;
+
+            if (Unit* target = FindCastingTarget(CalcSpellMaxRange(WIND_SHEAR_1), 0, WIND_SHEAR_1))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                    return;
+            }
+        }
+
+        void CheckShield(uint32 diff)
+        {
+            if (GC_Timer > diff || ShieldCheckTimer > diff || IsCasting() || Rand() > 15)
+                return;
+
+            ShieldCheckTimer = 2000;
+
+            //Aura const* shield = nullptr;
+            uint32 SHIELD =
+                HasRole(BOT_ROLE_TANK)   ? GetSpell(EARTH_SHIELD_1) :
+                HasRole(BOT_ROLE_HEAL)   ? GetSpell(WATER_SHIELD_1) :
+                HasRole(BOT_ROLE_DPS)    ? GetSpell(LIGHTNING_SHIELD_1) :
+                0;
+            SHIELD =
+                SHIELD ? SHIELD :
+                GetSpell(WATER_SHIELD_1) ? GetSpell(WATER_SHIELD_1) :
+                GetSpell(EARTH_SHIELD_1) ? GetSpell(EARTH_SHIELD_1) :
+                0;
+
+            if (!SHIELD && HasRole(BOT_ROLE_DPS))
+                SHIELD = GetSpell(LIGHTNING_SHIELD_1);
+
+            if (!SHIELD)
+                return;
+
+            AuraApplication const* sh = me->GetAuraApplicationOfRankedSpell(SHIELD);
+            if (!sh || sh->GetBase()->GetCharges() < 5 || sh->GetBase()->GetDuration() < 30000 ||
+                sh->GetBase()->GetSpellInfo()->GetRank() < sSpellMgr->GetSpellInfo(SHIELD)->GetRank())
+            {
+                if (doCast(me, SHIELD))
+                    return;
+            }
+        }
+
+        void UpdateDeadAI(uint32 diff) override
+        {
+            if (IsSpellReady(REINCARNATION_1, diff, false) && (IAmFree() || master->IsInCombat()) && Rand() < 20)
+                if (doCast(me, GetSpell(REINCARNATION_1)))
+                    return;
+
+            bot_ai::UpdateDeadAI(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            CheckShamanisticRage(diff);
+            CheckThunderStorm(diff);
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (IsPotionReady())
+            {
+                if (GetManaPCT(me) < 33)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50 && (!HasRole(BOT_ROLE_HEAL) || me->HasAuraType(SPELL_AURA_MOD_SILENCE)))
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(diff);
+            CureGroup(CURE_TOXINS, diff);
+            CheckTotems(diff);
+            CheckShield(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckFireNova(diff);
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            CheckGhostWolf(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            CheckHex(diff);
+            Counter(diff);
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            auto [can_do_frost, can_do_fire, can_do_nature] = CanAffectVictimBools(mytar, SPELL_SCHOOL_FROST, SPELL_SCHOOL_FIRE, SPELL_SCHOOL_NATURE);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetDistance(mytar);
+
+            //spell reflections
+            if (IsSpellReady(EARTH_SHOCK_1, diff) && can_do_nature && HasRole(BOT_ROLE_DPS) && dist < 25 && CanRemoveReflectSpells(mytar, EARTH_SHOCK_1) &&
+                doCast(mytar, EARTH_SHOCK_1))
+                return;
+
+            MoveBehind(mytar);
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && can_do_nature && HasRole(BOT_ROLE_DPS) && IsMelee() && dist <= 5 && Rand() < 120)
+            {
+                if (doCast(mytar, GetSpell(STORMSTRIKE_1)))
+                    return;
+            }
+            //SHOCKS
+            if (GetSpellCooldown(EARTH_SHOCK_1) <= diff && HasRole(BOT_ROLE_DPS) &&
+                (GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                dist < 25 && Rand() < 70)
+            {
+                if (GetSpell(FLAME_SHOCK_1) && can_do_fire)
+                {
+                    AuraEffect const* fsh = mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_SHAMAN, 0x10000000, 0x0, 0x0, me->GetGUID());
+                    if (!fsh || fsh->GetBase()->GetDuration() < 3000)
+                    {
+                        if (doCast(mytar, GetSpell(FLAME_SHOCK_1)))
+                            return;
+                    }
+                }
+
+                uint32 SHOCK = can_do_frost ? GetSpell(FROST_SHOCK_1) : 0;
+                if (!SHOCK && can_do_nature)
+                    SHOCK = GetSpell(EARTH_SHOCK_1);
+
+                if (SHOCK)
+                {
+                    if (doCast(mytar, SHOCK))
+                        return;
+                }
+            }
+
+            //Feral Spirit
+            if (IsSpellReady(FERAL_SPIRIT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40 && dist < 5)
+            {
+                SummonBotPet(mytar);
+                SetSpellCooldown(FERAL_SPIRIT_1, 180000);
+                return;
+            }
+
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && can_do_fire && _spec == BOT_SPEC_SHAMAN_ELEMENTAL &&
+                HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(LAVA_BURST_1) && Rand() < 60 &&
+                (me->getAttackers().empty() || dist > 10))
+            {
+                if (doCast(mytar, GetSpell(LAVA_BURST_1)))
+                    return;
+            }
+
+            if (((MaelstromCount < 5 || MaelstromTimer == 0) && IsMelee()) ||
+                (HasRole(BOT_ROLE_HEAL) && GetManaPCT(me) < 25))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && can_do_nature && HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(CHAIN_LIGHTNING_1) && Rand() < 80)
+            {
+                Unit* u = FindSplashTarget(35.f, mytar, 5.f);
+                if (u && doCast(mytar, GetSpell(CHAIN_LIGHTNING_1)))
+                    return;
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && can_do_nature && HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(LIGHTNING_BOLT_1))
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(mytar, LIGHTNING_BOLT))
+                    return;
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer > diff)
+                return;
+
+            HexyCheckTimer = 2000;
+            Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+        }
+
+        void CheckHex(uint32 /*diff*/)
+        {
+            //if (Hexy || !IsSpellReady(HEX_1, diff))
+            //    return;
+
+            //if (Unit* target = FindPolyTarget(20))
+            //{
+            //    if (doCast(target, GetSpell(HEX_1)))
+            //        return;
+            //}
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer > diff)
+                return;
+
+            EarthyCheckTimer = 1000;
+            Unit const* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 3);
+            Earthy = (u && (IsTank(u) || u == master));
+        }
+
+        void CheckGhostWolf(uint32 diff)
+        {
+            if (!IsSpellReady(GHOST_WOLF_1, diff) || !HasBotCommandState(BOT_COMMAND_FOLLOW) || Rand() > 15 ||
+                me->GetShapeshiftForm() == FORM_GHOSTWOLF || me->GetVictim() || me->IsMounted() || IAmFree())
+                return;
+
+            if (me->GetExactDist2d(master) > std::max<uint8>(master->GetBotMgr()->GetBotFollowDist(), 30))
+            {
+                if (doCast(me, GetSpell(GHOST_WOLF_1)))
+                    return;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Rand() > 25)
+                return;
+
+            ResurrectGroup(GetSpell(ANCESTRAL_SPIRIT_1));
+
+            if (mhEnchantExpireTimer > 0 && mhEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* mh = GetEquips(BOT_SLOT_MAINHAND))
+                    if (mh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            mh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+            if (ohEnchantExpireTimer > 0 && ohEnchantExpireTimer <= diff)
+            {
+                uint8 slot = TEMP_ENCHANTMENT_SLOT;
+                if (Item* oh = GetEquips(BOT_SLOT_OFFHAND))
+                    if (oh->GetEnchantmentId(EnchantmentSlot(slot)))
+                        for (uint8 i = 0; i != MAX_ITEM_ENCHANTMENT_EFFECTS; ++i)
+                            oh->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + i, 0);
+            }
+
+            // Weapon Enchants
+            if (me->isMoving())
+                return;
+
+            Item* mhWeapon = GetEquips(BOT_SLOT_MAINHAND);
+            Item* ohWeapon = GetEquips(BOT_SLOT_OFFHAND);
+            //item must be non-standard, otherwise combat spells won't be rolled anyway
+            bool mhReady = mhWeapon && !mhWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+            bool ohReady = ohWeapon && !ohWeapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT);
+
+            if (!mhReady && !ohReady)
+                return; //no ecnhantable weapons
+
+            //OK choose the enchants
+            //MH 1+ Rockbiter, 10+ Flametongue, 30+ Windfury/Earthliving
+            //OH 1+ Rockbiter, 10+ Flametongue, 20+ Frostbrand, 30+ Windfury/Earthliving
+            if (needChooseMHEnchant && mhReady)
+                mhEnchant = HasRole(BOT_ROLE_HEAL) ? (me->GetLevel() >= 30 ? EARTHLIVING_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    HasRole(BOT_ROLE_RANGED) ? (me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    (me->GetLevel() >= 30 ? WINDFURY_WEAPON_1 :
+                    //me->GetLevel() >= 20 ? FROSTBRAND_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/);
+
+            if (needChooseOHEnchant && ohReady) //basically only lvl 40+
+                ohEnchant = HasRole(BOT_ROLE_HEAL) ? (me->GetLevel() >= 30 ? EARTHLIVING_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    HasRole(BOT_ROLE_RANGED) ? (me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/) :
+                    (me->GetLevel() >= 30 ? WINDFURY_WEAPON_1 :
+                    me->GetLevel() >= 20 ? FROSTBRAND_WEAPON_1 :
+                    me->GetLevel() >= 10 ? FLAMETONGUE_WEAPON_1 :
+                    0/*ROCKBITER_WEAPON_1*/);
+
+            uint32 MhEnchant = !mhReady ? 0 : GetSpell(mhEnchant);
+            uint32 OhEnchant = !ohReady ? 0 : GetSpell(ohEnchant);
+
+            SpellInfo const* MhEnchantInfo = mhReady && MhEnchant ? sSpellMgr->GetSpellInfo(MhEnchant) : nullptr;
+            SpellInfo const* OhEnchantInfo = ohReady && OhEnchant ? sSpellMgr->GetSpellInfo(OhEnchant) : nullptr;
+
+            Item* targetWeapon = nullptr;
+            SpellInfo const* targetInfo = nullptr;
+
+            if (mhReady && MhEnchant && mhWeapon->IsFitToSpellRequirements(MhEnchantInfo))
+            {
+                targetWeapon = mhWeapon;
+                targetInfo = MhEnchantInfo;
+            }
+            if (!targetWeapon && ohReady && OhEnchant && ohWeapon->IsFitToSpellRequirements(OhEnchantInfo))
+            {
+                targetWeapon = ohWeapon;
+                targetInfo = OhEnchantInfo;
+            }
+            if (targetWeapon)
+            {
+                Spell* spell = new Spell(me, targetInfo, TRIGGERED_NONE);
+                SpellCastTargets targets;
+                targets.SetItemTarget(targetWeapon);
+                spell->prepare(targets);
+                return;
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && IsTank(target) && (target == me || !IsTank()) &&
+                (target->IsInCombat() || !target->isMoving()) && Rand() < 35)
+            {
+                AuraEffect const* eShield = target->GetAuraEffect(SPELL_AURA_REDUCE_PUSHBACK, SPELLFAMILY_SHAMAN, 0x0, 0x400, 0x0);
+                bool cast = (!eShield || eShield->GetBase()->GetCharges() < 5 || eShield->GetBase()->GetDuration() < 30000);
+
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                    return true;
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 1000;
+                    return true;
+                }
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 1000;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff) || IsCasting())
+                return;
+
+            Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(PURGE_1));
+            if (target && doCast(target, GetSpell(PURGE_1)))
+                return;
+
+            SetSpellCooldown(PURGE_1, 500); //fail
+        }
+
+        void CheckFireNova(uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_DPS) || _totems[T_FIRE].second._type == BOT_TOTEM_NONE ||
+                !IsSpellReady(FIRE_NOVA_1, diff) || IsCasting() || Rand() > 25)
+                return;
+
+            std::list<Unit*> targets;
+            GetNearbyTargetsList(targets, 9.f, 0, ObjectAccessor::GetUnit(*me, _totems[T_FIRE].first));
+            if (targets.size() > 1 || (!targets.empty() && *(targets.begin()) == me->GetVictim()))
+            {
+                if (doCast(me, GetSpell(FIRE_NOVA_1)))
+                    return;
+            }
+        }
+
+        bool HealTarget(Unit* target, uint32 diff) override
+        {
+            if (!target || !target->IsAlive() || target->GetShapeshiftForm() == FORM_SPIRITOFREDEMPTION || me->GetDistance(target) > 40)
+                return false;
+            uint8 hp = GetHealthPCT(target);
+            bool pointed = IsPointedHealTarget(target);
+            if (hp > 90 && !(pointed && me->GetMap()->IsRaid()) &&
+                (!target->IsInCombat() || target->getAttackers().empty() || !IsTank(target) || !me->GetMap()->IsRaid()))
+                return false;
+
+            int32 hps = GetHPS(target);
+            int32 xphp = target->GetHealth() + hps * 2.5f;
+            int32 hppctps = int32(hps * 100.f / float(target->GetMaxHealth()));
+            int32 xphploss = xphp > int32(target->GetMaxHealth()) ? 0 : abs(int32(xphp - target->GetMaxHealth()));
+            int32 xppct = hp + hppctps * 2.5f;
+            if (xppct >= 95 && hp >= 25 && !pointed)
+                return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) && Rand() < 80 &&
+                (me->IsInCombat() || target->IsInCombat()) &&//may just revive
+                hp <= 20 && xppct <= 0 && xphploss > _heals[HEALING_WAVE_1] / 2 &&
+                (target->GetTypeId() == TYPEID_PLAYER || IsTank(target) || target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)))
+                {
+                    if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                        return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            Unit const* u = target->GetVictim();
+            bool tanking = u && IsTank(target) && u->ToCreature() && u->ToCreature()->isWorldBoss();
+
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                (xppct >= 15 || !GetSpell(LESSER_HEALING_WAVE_1)) && xphploss > _heals[HEALING_WAVE_1])
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            //Riptide stacks from different casters
+            if (IsSpellReady(RIPTIDE_1, diff) && hp <= 85 && (tanking || hps < 0 || xphploss > _heals[RIPTIDE_1]) &&
+                !target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0x0, 0x0, 0x10, me->GetGUID())
+                /*!target->HasAura(GetSpell(RIPTIDE_1), me->GetGUID())*/)
+            {
+                if (doCast(target, GetSpell(RIPTIDE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) && xppct > 35 && xphploss > _heals[CHAIN_HEAL_1] &&
+                (!tanking || Rand() < 60 || target->GetAuraEffect(SPELL_AURA_PERIODIC_HEAL, SPELLFAMILY_SHAMAN, 0x0, 0x0, 0x10, me->GetGUID())))
+            {
+                if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) && xphploss > _heals[LESSER_HEALING_WAVE_1])
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const override
+        {
+            //if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MAGIC)
+            //    return;
+
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 30 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1)))
+                crit_chance += 5.f;
+            //Tidal Mastery: 5% additional critical chance for lightning spells
+            if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & schoolMask))
+                crit_chance += 5.f;
+            //Blessing of the Eternals: 4% additional critical chance for all spells
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 45)
+                crit_chance += 4.f;
+            //Tidal Waves (Lesser Healing Wave crit)
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 1, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 25.f;
+            //Tidal Force
+            if (spellInfo->SpellFamilyFlags[0] & 0x1C0)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_FORCE_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 20.f * eff->GetBase()->GetStackAmount();
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+            float flat_mod = 0.f;
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost spells
+                if (lvl >= 21 &&
+                    (spellInfo->GetSchoolMask() & (SPELL_SCHOOL_MASK_NATURE|SPELL_SCHOOL_MASK_FIRE|SPELL_SCHOOL_MASK_FROST)))
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+            //Improved Shields (part 1): 15% bonus damage for Lightning Shield orbs
+            if (lvl >= 15 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(LIGHTNING_SHIELD_DAMAGE_1)))
+                pctbonus += 0.15f;
+            //Shamanism: +20/25% bonus from spp
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 45)
+            {
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1) || spellId == GetSpell(LIGHTNING_BOLT_1))
+                    flat_mod += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+                else if (spellId == GetSpell(LAVA_BURST_1))
+                    flat_mod += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.25f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            }
+            //Elemental Oath (part 1): 10% bonus damage
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 45 && me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                pctbonus += 0.1f;
+            //Elemental Weapons (part 1): 40% bonus damage
+            if (lvl >= 20 && (spellId == WINDFURY_ATTACK_MAINHAND || spellId == WINDFURY_ATTACK_OFFHAND))
+                pctbonus += 0.4f;
+
+            //Totemic Recall: bots have reduced base mana so increase mana gain here
+            //if (lvl >= 30 && spellId == GetSpell(TOTEMIC_RECALL_1))
+            //    pctbonus += 0.5f;
+
+            damage = int32(fdamage * (1.0f + pctbonus) + flat_mod);
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const override
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Way: 25% bonus healing for Healing Wave
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 30 && spellId == GetSpell(HEALING_WAVE_1))
+                pctbonus += 0.25f;
+            //Purification: 10% bonus healing for all spells
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 35)
+                pctbonus += 0.1f;
+            //Nature's Blessing: 15% of Intellect to healing
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 45)
+                flat_mod += GetTotalBotStat(BOT_STAT_MOD_INTELLECT) * 0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            //Improved Chain Heal: 20% bonus healing for Chain Heal
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 45 && spellId == GetSpell(CHAIN_HEAL_1))
+                pctbonus += 0.2f;
+            //Improved Earth Shield: 10% bonus healing for Earth Shield
+            //Glyph of Earth Shield: 20% bonus healing for Earth Shield
+            if (lvl >= 50 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += (_spec == BOT_SPEC_SHAMAN_RESTORATION) ? 0.3f : 0.2f;
+            //Improved Shields (part 3): 15% bonus healing for Earth Shield
+            if (lvl >= 15 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.15f;
+            //Tidal Waves (part 2): 20% bonus (from spellpower) for Healing Wave and 10% bonus (from spellpower) for Lesser Healing Wave
+            if ((_spec == BOT_SPEC_SHAMAN_RESTORATION) && lvl >= 55)
+            {
+                if (spellId == GetSpell(HEALING_WAVE_1))
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(LESSER_HEALING_WAVE_1))
+                    flat_mod += me->SpellBaseHealingBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.1f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * 1.88f * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo) * stack;
+            }
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Clearcasting: -40% mana cost
+            if (AuraEffect const* eff = me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 0.4f;
+            //Convection
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x90100003) || (spellInfo->SpellFamilyFlags[1] & 0x8001000)))
+                pctbonus += 0.1f;
+            //Shamanistic Focus
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x90100000))
+                pctbonus += 0.45f;
+            //Mental Quickness:
+            if ((_spec == BOT_SPEC_SHAMAN_ENHANCEMENT) && lvl >= 50 && !spellInfo->CalcCastTime())
+                pctbonus += 0.06f;
+            //Totemic Focus:
+            if (lvl >= 10 && (spellInfo->AttributesEx7 & SPELL_ATTR7_SUMMON_PLAYER_TOTEM))
+                pctbonus += 0.25f;
+            //Tidal Focus:
+            if (lvl >= 15 &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x1C0) ||
+                (spellInfo->SpellFamilyFlags[1] & 0x400) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x10)))
+                pctbonus += 0.05f;
+
+            //flat mods
+            //!1 rage = 10 pts!
+            ////Improved Heroic Strike: -3 rage cost for Heroic Strike
+            //if (lvl >= 10 && spellId == GetSpell(HEROIC_STRIKE_1))
+            //    flatbonus += 30;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Nature's Swiftness: -100% cast time
+            if (AuraEffect const* eff = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    pctbonus += 1.0f;
+
+            //pct mods
+            if (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1))
+            {
+                Aura* maelstrom = me->GetAura(MAELSTROM_WEAPON_BUFF);
+                if (maelstrom)
+                {
+                    pctbonus += 0.2f * maelstrom->GetStackAmount();
+                    maelUseUp = true;
+                }
+            }
+            //Tidal Waves (Healing Wave cast time)
+            if (spellInfo->SpellFamilyFlags[0] & 0x40)
+                if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        pctbonus += 0.3f;
+
+            //flat mods
+            //Improved Ghost Wolf: -2 sec
+            if (lvl >= 10 && spellId == GetSpell(GHOST_WOLF_1))
+                timebonus += 2000;
+            //Improved Healing Wave: -0.5 sec
+            if (lvl >= 10 && spellId == GetSpell(HEALING_WAVE_1))
+                timebonus += 500;
+            //Lightning Mastery: -0.5 sec
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x3) || (spellInfo->SpellFamilyFlags[1] & 0x1000)))
+                timebonus += 500;
+            //Stormcaller Chain Heal Bonus (26122): -0.4 sec
+            if (lvl >= 60 && spellId == GetSpell(CHAIN_HEAL_1))
+                timebonus += 400;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+            //Reverberation
+            if (lvl >= 20 && ((spellInfo->SpellFamilyFlags[0] & 0x90100000) || (spellInfo->SpellFamilyFlags[1] & 0x8000000)))
+                timebonus += 1000;
+            //Booming Echoes (part 1)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 45 && (spellInfo->SpellFamilyFlags[0] & 0x90000000))
+                timebonus += 2000;
+            //Storm, Earth and Fire (part 1)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x2))
+                timebonus += 2500;
+            //Improved Fire Nova (part 2)
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x8000000))
+                timebonus += 4000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Improved Reincarnation + Reduced Reincarnation Cooldown: -20 min cooldown for Reincarnation
+            if (spellId == GetSpell(REINCARNATION_1))
+                timebonus += 1200000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Glyph of Shocking: -0.5 sec global cooldown for Shocks
+            if (lvl >= 15 && ((spellInfo->SpellFamilyFlags[0] & 0x90100000) || (spellInfo->SpellFamilyFlags[1] & 0x8000000)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Grim Reach: +20% range for Affliction Spells
+            //if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x8048C41A) || (spellInfo->SpellFamilyFlags[1] & 0x40713)))
+            //    pctbonus += 0.2f;
+
+            //flat mods
+            //Elemental Reach part 1: +6 yd
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 30 && ((spellInfo->SpellFamilyFlags[0] & 0x8000003) || (spellInfo->SpellFamilyFlags[1] & 0x1000)))
+                flatbonus += 6.f;
+            //Elemental Reach part 2: +15 yd
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                lvl >= 30 && (spellInfo->SpellFamilyFlags[0] & 0x10000000))
+                flatbonus += 15.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            uint32 bonusTargets = 0;
+
+            //Glyph of Chain Heal
+            if (spellInfo->SpellFamilyFlags[0] & 0x100)
+                bonusTargets += 1;
+            //Glyph of Chain Lightning
+            if (spellInfo->SpellFamilyFlags[0] & 0x2)
+                bonusTargets += 1;
+            //Chain Healing Wave (23573)
+            if (me->GetLevel() >= 60 && spellInfo->SpellFamilyFlags[0] & 0x100)
+                bonusTargets += 2;
+
+            targets = targets + bonusTargets;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //reincarnation: notify master
+            if (baseId == REINCARNATION_1 && !IAmFree())
+            {
+                ReportSpellCast(baseId, LocalizedNpcText(master, BOT_TEXT__USED), master);
+
+                //no spellHit trigger - do it here
+                SpellHit(me, spellInfo);
+                me->CastSpell(me, RESURRECTION_VISUAL_SPELL, true);
+            }
+            //manatide: notify
+            if (baseId == MANA_TIDE_TOTEM_1 && !IAmFree())
+            {
+                ReportSpellCast(baseId, LocalizedNpcText(master, BOT_TEXT__USED), master);
+            }
+            //Nature's Swiftness: notify master
+            if (baseId == NATURES_SWIFTNESS_1 && !IAmFree())
+            {
+                ReportSpellCast(baseId, LocalizedNpcText(master, BOT_TEXT__USED), master);
+            }
+
+            //Handle Clearcasting
+            if (AuraEffect* eff = me->GetAuraEffect(ELEMENTAL_FOCUS_BUFF, 0, me->GetGUID()))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    eff->GetBase()->DropCharge();
+            //Handle Tidal Focus
+            //Healing Wave (cast time): if full Maelstrom than don't use up charge
+            if (MaelstromCount < 5 && (spellInfo->SpellFamilyFlags[0] & 0x40))
+                if (AuraEffect* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 0, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        eff->GetBase()->DropCharge();
+            //Lesser Healing Wave (crit)
+            if (spellInfo->SpellFamilyFlags[0] & 0x80)
+                if (AuraEffect* eff = me->GetAuraEffect(TIDAL_WAVES_BUFF, 1, me->GetGUID()))
+                    if (eff->IsAffectedOnSpell(spellInfo))
+                        eff->GetBase()->DropCharge();
+
+            //Nature's Swiftness
+            if (AuraEffect const* eff = me->GetAuraEffect(NATURES_SWIFTNESS_1, 0, me->GetGUID()))
+            {
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1);
+            }
+
+            //Tidal Force: Handled in Unit::HandleDummyAuraProc(): case 55166:
+            //if (spellInfo->SpellFamilyFlags[0] & 0x1C0)
+            //    if (AuraEffect const* eff = me->GetAuraEffect(TIDAL_FORCE_BUFF, 0, me->GetGUID()))
+            //        if (eff->IsAffectedOnSpell(spellInfo))
+            //            me->RemoveAuraFromStack(TIDAL_FORCE_BUFF);
+
+            //Shield cd
+            if (baseId == LIGHTNING_SHIELD_DAMAGE_1)
+                SetSpellCooldown(LIGHTNING_SHIELD_DAMAGE_1, 3000); //is that right? from spell_proc_event
+
+            //autouse totems
+            if (baseId == EARTHBIND_TOTEM_1 || baseId == STRENGTH_OF_EARTH_TOTEM_1)
+                TotemTimer[T_EARTH] = 5000;
+            if (baseId == TREMOR_TOTEM_1)
+                TotemTimer[T_EARTH] = 12000;
+            if (baseId == MAGMA_TOTEM_1)
+                TotemTimer[T_FIRE] = 12000;
+            if (baseId == TOTEM_OF_WRATH_1 || baseId == FLAMETONGUE_TOTEM_1)
+                TotemTimer[T_FIRE] = 5000;
+            if (baseId == FROST_RESISTANCE_TOTEM_1)
+                TotemTimer[T_FIRE] = 120000;
+            if (baseId == MANA_TIDE_TOTEM_1)
+                TotemTimer[T_WATER] = 12000;
+            if (baseId == MANA_SPRING_TOTEM_1)
+                TotemTimer[T_WATER] = 5000;
+            if (baseId == FIRE_RESISTANCE_TOTEM_1)
+                TotemTimer[T_WATER] = 120000;
+            if (baseId == GROUNDING_TOTEM_1)
+                TotemTimer[T_AIR] = me->GetLevel() >= 15 ? 13000 : 15000;
+            if (baseId == WRATH_OF_AIR_TOTEM_1 || baseId == WINDFURY_TOTEM_1)
+                TotemTimer[T_AIR] = 5000;
+            if (baseId == NATURE_RESISTANCE_TOTEM_1)
+                TotemTimer[T_AIR] = 120000;
+            //other (manual use)
+            if (baseId == STONECLAW_TOTEM_1)
+                TotemTimer[T_EARTH] = 15000;
+            if (baseId == STONESKIN_TOTEM_1)
+                TotemTimer[T_EARTH] = 300000;
+            if (baseId == EARTH_ELEMENTAL_TOTEM_1)
+                TotemTimer[T_EARTH] = 120000;
+            if (baseId == SEARING_TOTEM_1)
+                TotemTimer[T_FIRE] = 60000;
+            if (baseId == FIRE_ELEMENTAL_TOTEM_1)
+                TotemTimer[T_FIRE] = 120000;
+            if (baseId == CLEANSING_TOTEM_1)
+                TotemTimer[T_WATER] = 300000;
+            if (baseId == HEALING_STREAM_TOTEM_1)
+                TotemTimer[T_WATER] = 300000;
+
+            //Totemic Recall totems resummon helper
+            if (baseId == TOTEMIC_RECALL_1)
+            {
+                TotemsCheckTimer = GC_Timer;
+                for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                    TotemTimer[i] = 0;
+            }
+
+            if (maelUseUp)
+            {
+                if (baseId == LIGHTNING_BOLT_1 || baseId == CHAIN_LIGHTNING_1 || baseId == HEALING_WAVE_1 ||
+                    baseId == LESSER_HEALING_WAVE_1 || baseId == CHAIN_HEAL_1 || baseId == HEX_1)
+                {
+                    MaelstromCount = 0;
+                    me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF);
+                }
+            }
+
+            //Item enchant
+            //We don't know which item is targeted
+            //Actually it is mh, then oh
+            if (/*baseId == ROCKBITER_WEAPON_1 || */baseId == FLAMETONGUE_WEAPON_1 || baseId == FROSTBRAND_WEAPON_1 ||
+                baseId == WINDFURY_WEAPON_1 || baseId == EARTHLIVING_WEAPON_1)
+            {
+                //We set duration to 2 seconds to prevent exploiting unequip mechanic
+                //to get enchanted weapons for player (for non-shaman bots it won't work)
+                uint32 slot = TEMP_ENCHANTMENT_SLOT;
+                uint32 duration = 2 * IN_MILLISECONDS;
+                uint32 charges = 0;
+                uint32 enchant_id = spellInfo->_effects[0].MiscValue;
+                //SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+                Item* mh = GetEquips(BOT_SLOT_MAINHAND);
+                Item* oh = GetEquips(BOT_SLOT_OFFHAND);
+                Item* item = nullptr;
+                uint8 itemSlot = 0;
+
+                if (mh && !mh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && mh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = mh;
+                    itemSlot = BOT_SLOT_MAINHAND;
+                }
+                else if (oh && !oh->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT)/* && oh->IsFitToSpellRequirements(spellInfo)*/)
+                {
+                    item = oh;
+                    itemSlot = BOT_SLOT_OFFHAND;
+                }
+                else
+                    ASSERT(false, "shaman bot attempted to enchant his weapons but cannot find a weapon to apply it!");
+
+                if (!IAmFree())
+                    master->GetSession()->SendEnchantmentLog(me->GetGUID(), me->GetGUID(), item->GetEntry(), enchant_id);
+
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_ID_OFFSET, enchant_id);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_DURATION_OFFSET, duration);
+                item->SetUInt32Value(ITEM_FIELD_ENCHANTMENT_1_1 + slot*MAX_ENCHANTMENT_OFFSET + ENCHANTMENT_CHARGES_OFFSET, charges);
+                ApplyItemBonuses(itemSlot); //RemoveItemBonuses inside
+                if (itemSlot == BOT_SLOT_MAINHAND)
+                    mhEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                else if (itemSlot == BOT_SLOT_OFFHAND)
+                    ohEnchantExpireTimer = ITEM_ENCHANTMENT_EXPIRE_TIMER;
+                GC_Timer = 1500; //needed
+            }
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon helper
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura const* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                    MaelstromCount = mwb->GetStackAmount();
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == EARTH_SHIELD_1)
+                Earthy = true;
+
+            if (baseId == HEX_1)
+            {
+                Hexy = true;
+                HexyCheckTimer += 2000;
+            }
+
+            //Earthen Power part 2
+            if ((_spec == BOT_SPEC_SHAMAN_ENHANCEMENT) && me->GetLevel() >= 50 && baseId == EARTH_SHOCK_1)
+            {
+                if (AuraEffect* eff = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    eff->ChangeAmount(eff->GetAmount() * 2);
+            }
+
+            //Lightning Overload
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) &&
+                me->GetLevel() >= 45 && (baseId == LIGHTNING_BOLT_1 || baseId == CHAIN_LIGHTNING_1) &&
+                urand(1,100) <= 33)
+            {
+                uint32 procId = 0;
+                switch (spellId)
+                {
+                    // Lightning Bolt
+                    case   403: procId = 45284; break; // Rank  1
+                    case   529: procId = 45286; break; // Rank  2
+                    case   548: procId = 45287; break; // Rank  3
+                    case   915: procId = 45288; break; // Rank  4
+                    case   943: procId = 45289; break; // Rank  5
+                    case  6041: procId = 45290; break; // Rank  6
+                    case 10391: procId = 45291; break; // Rank  7
+                    case 10392: procId = 45292; break; // Rank  8
+                    case 15207: procId = 45293; break; // Rank  9
+                    case 15208: procId = 45294; break; // Rank 10
+                    case 25448: procId = 45295; break; // Rank 11
+                    case 25449: procId = 45296; break; // Rank 12
+                    case 49237: procId = 49239; break; // Rank 13
+                    case 49238: procId = 49240; break; // Rank 14
+                    // Chain Lightning
+                    case   421: procId = 45297; break; // Rank  1
+                    case   930: procId = 45298; break; // Rank  2
+                    case  2860: procId = 45299; break; // Rank  3
+                    case 10605: procId = 45300; break; // Rank  4
+                    case 25439: procId = 45301; break; // Rank  5
+                    case 25442: procId = 45302; break; // Rank  6
+                    case 49270: procId = 49268; break; // Rank  7
+                    case 49271: procId = 49269; break; // Rank  8
+                    default:                    break;
+                }
+
+                if (procId)
+                {
+                    if (baseId == LIGHTNING_BOLT_1)
+                        me->CastSpell(target, procId, true);
+                    if (baseId == CHAIN_LIGHTNING_1)
+                    {
+                        //Normalize chance
+                        if (urand(1,100) <= (100.f / spell->_effects[0].ChainTarget))
+                            me->CastSpell(target, procId, true);
+                    }
+                }
+            }
+
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (baseId == LIGHTNING_SHIELD_1 || baseId == EARTH_SHIELD_1 || baseId == WATER_SHIELD_1)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 6);
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint8 GetPetPositionNumber(Creature const* summon) const override
+        {
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                if (_wolves[i] == summon->GetGUID())
+                    return i;
+
+            return 0;
+        }
+
+        void SummonBotPet(Unit* target)
+        {
+            //if (botPet)
+            //    botPet->ToTempSummon()->UnSummon();
+
+            uint32 entry = BOT_PET_SPIRIT_WOLF;
+
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+            {
+                //Position pos;
+
+                //45 sec duration
+                Creature* myPet = me->SummonCreature(entry, *me, TEMPSUMMON_MANUAL_DESPAWN);
+                //me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, 2, me->GetOrientation());
+                //myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+                myPet->SetCreator(master);
+                myPet->SetOwnerGUID(me->GetGUID());
+                myPet->SetFaction(master->GetFaction());
+                myPet->SetControlledByPlayer(!IAmFree());
+                myPet->SetPvP(me->IsPvP());
+                myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+                myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+                myPet->SetUInt32Value(UNIT_CREATED_BY_SPELL, FERAL_SPIRIT_1);
+
+                //botPet = myPet;
+
+                myPet->Attack(target, true);
+                if (!HasBotCommandState(BOT_COMMAND_STAY))
+                    myPet->GetMotionMaster()->MoveChase(target);
+            }
+        }
+
+        void JustSummoned(Creature* summon) override
+        {
+            if (summon->GetEntry() == BOT_PET_SPIRIT_WOLF)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                {
+                    if (!_wolves[i])
+                    {
+                        _wolves[i] = summon->GetGUID();
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Shaman_bot:JustSummoned() wolves array is full");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            //if (summon == botPet)
+            //    botPet = nullptr;
+            if (summon->GetEntry() == BOT_PET_SPIRIT_WOLF)
+            {
+                bool found = false;
+                for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                {
+                    if (_wolves[i] == summon->GetGUID())
+                    {
+                        _wolves[i] = ObjectGuid::Empty;
+                        found = true;
+                        break;
+                    }
+                }
+                if (!found)
+                {
+                    TC_LOG_ERROR("entities.unit", "Shaman_bot:SummonedCreatureDespawn() wolf is not found in array");
+                    ASSERT(false);
+                }
+            }
+        }
+
+        void UnsummonAll() override
+        {
+            //if (botPet)
+            //    botPet->ToTempSummon()->UnSummon();
+
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+            {
+                if (_wolves[i])
+                    if (Unit* wo = ObjectAccessor::GetUnit(*me, _wolves[i]))
+                        wo->ToTempSummon()->UnSummon();
+            }
+
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != ObjectGuid::Empty)
+                {
+                    Unit* to = ObjectAccessor::GetUnit(*me, _totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void OnBotDespawn(Creature* summon) override
+        {
+            if (!summon)
+            {
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s received NULL", me->GetName().c_str());
+                ASSERT(false);
+                //UnsummonAll();
+                return;
+            }
+
+            TempSummon const* totem = summon->ToTempSummon();
+            if (!totem || !totem->IsTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Slot)
+            {
+                case SUMMON_SLOT_TOTEM_FIRE:    slot = T_FIRE;  break;
+                case SUMMON_SLOT_TOTEM_EARTH:   slot = T_EARTH; break;
+                case SUMMON_SLOT_TOTEM_WATER:   slot = T_WATER; break;
+                case SUMMON_SLOT_TOTEM_AIR:     slot = T_AIR;   break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s in unknown slot %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->ID);
+                    return;
+            }
+
+            if (_totems[slot].first == ObjectGuid::Empty)
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s while not having it registered!", me->GetName().c_str(), summon->GetName().c_str());
+            else if (_totems[slot].second._type == BOT_TOTEM_NONE || _totems[slot].second._type >= BOT_TOTEM_END)
+                TC_LOG_ERROR("entities.player", "OnBotDespawn(): Shaman bot %s has despawned totem %s with no type assigned!", me->GetName().c_str(), summon->GetName().c_str());
+
+            //here we reset totem category cd (not totem spell cd) if totem is destroyed
+            //TC_LOG_ERROR("entities.player", "OnBotDespawn(): %s despawned (%s : %u)", summon->GetName().c_str(), summon->IsAlive() ? "alive" : summon->isDying() ? "justdied" : "unk", (uint32)summon->getDeathState());
+            if (!summon->IsAlive()) // alive here means totem is being replaced or unsummoned through other means
+                TotemTimer[slot] = 0;
+
+            _totems[slot].first = ObjectGuid::Empty;
+            _totems[slot].second._type = BOT_TOTEM_NONE;
+            me->m_SummonSlot[slot+1] = ObjectGuid::Empty;
+        }
+
+        void OnBotSummon(Creature* summon) override
+        {
+            TempSummon const* totem = summon->ToTempSummon();
+            if (!totem || !totem->IsTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Slot)
+            {
+                case SUMMON_SLOT_TOTEM_FIRE:    slot = T_FIRE;  break;
+                case SUMMON_SLOT_TOTEM_EARTH:   slot = T_EARTH; break;
+                case SUMMON_SLOT_TOTEM_WATER:   slot = T_WATER; break;
+                case SUMMON_SLOT_TOTEM_AIR:     slot = T_AIR;   break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->ID);
+                    return;
+            }
+
+            //Unsummon current totem
+            ObjectGuid curTotemGUID = _totems[slot].first;
+            if (curTotemGUID)
+            {
+                Unit* curTotem = ObjectAccessor::GetUnit(*me, curTotemGUID);
+                if (curTotem)
+                    curTotem->ToTotem()->UnSummon();
+            }
+
+            float radius = 30.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->_effects[0].RadiusEntry)
+                    radius = std::max<float>(entry->RadiusMax, radius);
+
+            uint32 createSpell = summon->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+            if (createSpell)
+                createSpell = sSpellMgr->GetSpellInfo(createSpell)->GetFirstRankSpell()->Id;
+            //DEBUG
+            //if (!IAmFree())
+            //{
+            //    std::ostringstream msg;
+            //    msg << "Summoned " << summon->GetName() << " by basespell: " << createSpell;
+            //    BotWhisper(msg.str().c_str());
+            //}
+            uint32 btype;
+            switch (createSpell)
+            {
+                case SEARING_TOTEM_1:           btype = BOT_TOTEM_SEARING;              break;
+                case STONECLAW_TOTEM_1:         btype = BOT_TOTEM_STONECLAW;            break;
+                case SENTRY_TOTEM_1:            btype = BOT_TOTEM_SENTRY;               break;
+                case STONESKIN_TOTEM_1:         btype = BOT_TOTEM_STONESKIN;            break;
+                case HEALING_STREAM_TOTEM_1:    btype = BOT_TOTEM_HEALING_STREAM;       break;
+                case EARTHBIND_TOTEM_1:         btype = BOT_TOTEM_EARTHBIND;            break;
+                case EARTH_ELEMENTAL_TOTEM_1:   btype = BOT_TOTEM_ELEMENTAL_EARTH;      break;
+                case FIRE_ELEMENTAL_TOTEM_1:    btype = BOT_TOTEM_ELEMENTAL_FIRE;       break;
+                case MAGMA_TOTEM_1:             btype = BOT_TOTEM_MAGMA;                break;
+                case FLAMETONGUE_TOTEM_1:       btype = BOT_TOTEM_FLAMETONGUE;          break;
+                case FROST_RESISTANCE_TOTEM_1:  btype = BOT_TOTEM_RESISTANCE_FROST;     break;
+                case FIRE_RESISTANCE_TOTEM_1:   btype = BOT_TOTEM_RESISTANCE_FIRE;      break;
+                case NATURE_RESISTANCE_TOTEM_1: btype = BOT_TOTEM_RESISTANCE_NATURE;    break;
+                case GROUNDING_TOTEM_1:         btype = BOT_TOTEM_GROUNDING;            break;
+                case STRENGTH_OF_EARTH_TOTEM_1: btype = BOT_TOTEM_STRENGTH_OF_EARTH;    break;
+                case WINDFURY_TOTEM_1:          btype = BOT_TOTEM_WINDFURY;             break;
+                case WRATH_OF_AIR_TOTEM_1:      btype = BOT_TOTEM_WRATH_OF_AIR;         break;
+                case CLEANSING_TOTEM_1:         btype = BOT_TOTEM_CLEANSING;            break;
+                case MANA_SPRING_TOTEM_1:       btype = BOT_TOTEM_MANA_SPRING;          break;
+                case MANA_TIDE_TOTEM_1:         btype = BOT_TOTEM_MANA_TIDE;            break;
+                case TREMOR_TOTEM_1:            btype = BOT_TOTEM_TREMOR;               break;
+                case TOTEM_OF_WRATH_1:          btype = BOT_TOTEM_WRATH;                break;
+                default:
+                {
+                    TC_LOG_ERROR("scripts", "Unknown totem create spell %u!", createSpell);
+                    btype = BOT_TOTEM_NONE;
+                    break;
+                }
+            }
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second._pos.Relocate(*summon);
+            _totems[slot].second._effradius = !((1<<btype) & BOT_TOTEM_MASK_SUMMONS) ? radius : SIZE_OF_GRIDS;
+            _totems[slot].second._type = btype;
+            me->m_SummonSlot[slot+1] = _totems[slot].first; //needed for scripts handlers
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x=%.2f, y=%.2f, z=%.2f",
+            //    summon->GetName().c_str(), slot + 1, _totems[slot].second.pos.GetPositionX(), _totems[slot].second.pos.GetPositionY(), _totems[slot].second.pos.GetPositionZ());
+
+            //TODO: gets overriden in Spell::EffectSummonType (end)
+            //Without setting creator correctly it will be impossible to use summon X elemental totems
+            summon->SetCreator(me);
+            summon->SetDisplayId(sObjectMgr->GetModelForTotem(SummonSlot(slot+1), Races(me->GetRace())));
+            summon->SetFaction(me->GetFaction());
+            summon->SetPvP(me->IsPvP());
+            summon->SetOwnerGUID(master->GetGUID());
+            summon->SetControlledByPlayer(!IAmFree());
+            summon->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            // totem will claim master's summon slot
+            // free it to avoid conflicts with other shaman bots and master
+            // if master is a shaman his totem will despawn
+            // fixed in summoning sequence
+            //master->m_SummonSlot[++slot] = 0;
+
+            //After summon effects which are not handled for bot totems
+            //check by btype
+
+            // Storm, Earth and Fire: Earthbind totem AoE root
+            if ((_spec == BOT_SPEC_SHAMAN_ELEMENTAL) && btype == BOT_TOTEM_EARTHBIND && me->GetLevel() >= 40)
+            {
+                //master's talent will be found so do not cast earthgrab twice, instead let spell script roll the chance
+                //see spell_shaman.cpp
+                if (!master->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_SHAMAN, 3063, EFFECT_1))
+                    summon->CastSpell(summon, STORMEARTHANDFIRE_EARTHGRAB, false);
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(LIGHTNING_BOLT_1) : 20.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_ENCHANT_IS_AUTO_MH:
+                    return needChooseMHEnchant;
+                case BOTAI_MISC_ENCHANT_IS_AUTO_OH:
+                    return needChooseOHEnchant;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    return mhEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    return ohEnchantExpireTimer;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    return mhEnchant;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    return ohEnchant;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_1:
+                    return /*GetSpell(ROCKBITER_WEAPON_1) ? ROCKBITER_WEAPON_1 : */0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_2:
+                    return GetSpell(FLAMETONGUE_WEAPON_1) ? FLAMETONGUE_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_3:
+                    return GetSpell(FROSTBRAND_WEAPON_1) ? FROSTBRAND_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_4:
+                    return GetSpell(WINDFURY_WEAPON_1) ? WINDFURY_WEAPON_1 : 0;
+                case BOTAI_MISC_ENCHANT_AVAILABLE_5:
+                    return GetSpell(EARTHLIVING_WEAPON_1) ? EARTHLIVING_WEAPON_1 : 0;
+                case BOTAI_MISC_PET_TYPE:
+                    return BOT_PET_SPIRIT_WOLF;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH:
+                    if (value)
+                        mhEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH:
+                    if (value)
+                        ohEnchantExpireTimer = 0;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_MH:
+                    mhEnchant = value;
+                    needChooseMHEnchant = value ? false : true;
+                    break;
+                case BOTAI_MISC_ENCHANT_CURRENT_OH:
+                    ohEnchant = value;
+                    needChooseOHEnchant = value ? false : true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+            for (uint8 i = 0; i != MAX_WOLVES; ++i)
+                _wolves[i] = ObjectGuid::Empty;
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                TotemTimer[i] = 0;
+
+            removeShapeshiftForm();
+
+            TotemsCheckTimer = 1500;
+
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            ShieldCheckTimer = 2000;
+            BloodlustCheckTimer = 5000;
+            MaelstromTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            maelUseUp = false;
+
+            mhEnchantExpireTimer = 1;
+            ohEnchantExpireTimer = 1;
+
+            DefaultInit();
+
+            mhEnchant = 0;
+            ohEnchant = 0;
+            needChooseMHEnchant = true;
+            needChooseOHEnchant = true;
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                if (TotemTimer[i] > diff)
+                    TotemTimer[i] -= diff;
+
+            if (TotemsCheckTimer > diff)        TotemsCheckTimer -= diff;
+
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+            if (ShieldCheckTimer > diff)        ShieldCheckTimer -= diff;
+            if (BloodlustCheckTimer > diff)     BloodlustCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount) { MaelstromCount = 0; maelUseUp = false; }
+
+            if (mhEnchantExpireTimer > diff)    mhEnchantExpireTimer -= diff;
+            if (ohEnchantExpireTimer > diff)    ohEnchantExpireTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isElem = _spec == BOT_SPEC_SHAMAN_ELEMENTAL;
+            bool isEnha = _spec == BOT_SPEC_SHAMAN_ENHANCEMENT;
+            bool isRest = _spec == BOT_SPEC_SHAMAN_RESTORATION;
+
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            InitSpellMap(CURE_TOXINS_1);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+            InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+            InitSpellMap((me->GetRaceMask() & RACEMASK_ALLIANCE) ? HEROISM_1 : BLOODLUST_1); //at least race is constant
+
+            InitSpellMap(GHOST_WOLF_1);
+
+            InitSpellMap(FIRE_NOVA_1);
+            //totems
+            InitSpellMap(EARTHBIND_TOTEM_1);
+            InitSpellMap(MAGMA_TOTEM_1);
+            //InitSpellMap(SEARING_TOTEM_1);
+            //InitSpellMap(STONECLAW_TOTEM_1);
+            InitSpellMap(FIRE_ELEMENTAL_TOTEM_1);
+            InitSpellMap(EARTH_ELEMENTAL_TOTEM_1);
+            InitSpellMap(FIRE_RESISTANCE_TOTEM_1);
+            InitSpellMap(FROST_RESISTANCE_TOTEM_1);
+            InitSpellMap(NATURE_RESISTANCE_TOTEM_1);
+            InitSpellMap(FLAMETONGUE_TOTEM_1);
+            InitSpellMap(GROUNDING_TOTEM_1);
+            //InitSpellMap(SENTRY_TOTEM_1);
+            //InitSpellMap(STONESKIN_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(WRATH_OF_AIR_TOTEM_1);
+            InitSpellMap(CLEANSING_TOTEM_1);
+            //InitSpellMap(HEALING_STREAM_TOTEM_1);
+            InitSpellMap(MANA_SPRING_TOTEM_1);
+            InitSpellMap(TREMOR_TOTEM_1);
+
+            InitSpellMap(TOTEMIC_RECALL_1);
+
+            InitSpellMap(REINCARNATION_1); //base lvl 30, 30 min cd
+
+  /*Talent*///lvl >= 40 && isElem ? InitSpellMap(ELEMENTAL_MASTERY_1) : RemoveSpell(ELEMENTAL_MASTERY_1);
+  /*Talent*/lvl >= 60 && isElem ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+
+  /*Talent*/lvl >= 40 && isEnha ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+  /*Talent*/lvl >= 50 && isEnha ? InitSpellMap(SHAMANISTIC_RAGE_1) : RemoveSpell(SHAMANISTIC_RAGE_1);
+  /*Talent*/lvl >= 60 && isEnha ? InitSpellMap(FERAL_SPIRIT_1) : RemoveSpell(FERAL_SPIRIT_1); //not casted
+
+  /*Talent*/lvl >= 20 && isRest ? InitSpellMap(TIDAL_FORCE_1) : RemoveSpell(TIDAL_FORCE_1);
+  /*Talent*/lvl >= 30 && isRest ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+  /*Talent*/lvl >= 50 && isRest ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+  /*Talent*/lvl >= 60 && isRest ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+
+  /*Talent*/lvl >= 50 && isElem ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
+
+  /*Talent*/lvl >= 40 && isRest ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
+
+            CURE_TOXINS = InitSpell(me, CLEANSE_SPIRIT_1) ? CLEANSE_SPIRIT_1 : CURE_TOXINS_1;
+            RemoveSpell(CLEANSE_SPIRIT_1);
+            RemoveSpell(CURE_TOXINS_1);
+            InitSpellMap(CURE_TOXINS);
+
+            //InitSpellMap(ROCKBITER_WEAPON_1); //lvl 1
+            InitSpellMap(FLAMETONGUE_WEAPON_1); //lvl 10
+            InitSpellMap(FROSTBRAND_WEAPON_1); //lvl 20
+            InitSpellMap(WINDFURY_WEAPON_1); //lvl 30
+            InitSpellMap(EARTHLIVING_WEAPON_1); //lvl 30
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isElem = _spec == BOT_SPEC_SHAMAN_ELEMENTAL;
+            bool isEnha = _spec == BOT_SPEC_SHAMAN_ENHANCEMENT;
+            bool isRest = _spec == BOT_SPEC_SHAMAN_RESTORATION;
+
+            RefreshAura(ELEMENTAL_DEVASTATION3, isEnha && level >= 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION2, isEnha && level >= 15 && level < 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION1, isEnha && level >= 12 && level < 15 ? 1 : 0);
+            RefreshAura(ELEMENTAL_FOCUS, isElem && level >= 20 ? 1 : 0);
+            RefreshAura(ELEMENTAL_OATH, isElem && level >= 40 ? 1 : 0);
+            //RefreshAura(STORM_EARTH_AND_FIRE, isElem && level >= 45 ? 1 : 0);
+
+            RefreshAura(TOUGHNESS, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, isEnha && level >= 29 ? 1 : 0);
+            RefreshAura(FLURRY4, isEnha && level >= 28 && level < 29 ? 1 : 0);
+            RefreshAura(FLURRY3, isEnha && level >= 27 && level < 28 ? 1 : 0);
+            RefreshAura(FLURRY2, isEnha && level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(FLURRY1, isEnha && level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WEAPON_MASTERY, isEnha && level >= 30 ? 1 : 0);
+            RefreshAura(UNLEASHED_RAGE, isEnha && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_STORMSTRIKE, isEnha && level >= 40 ? 1 : 0);
+            RefreshAura(STATIC_SHOCK, isEnha && level >= 41 ? 1 : 0);
+            RefreshAura(EARTHEN_POWER, isEnha && level >= 50 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON5, isEnha && level >= 59 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON4, isEnha && level >= 58 && level < 59 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON3, isEnha && level >= 57 && level < 58 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON2, isEnha && level >= 56 && level < 57 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON1, isEnha && level >= 55 && level < 56 ? 1 : 0);
+
+            RefreshAura(IMPROVED_WATER_SHIELD, isRest && level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_HEALING, isRest && level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_AWAKENING, isRest && level >= 50 ? 1 : 0);
+            RefreshAura(TIDAL_WAVES, isRest && level >= 55 ? 1 : 0);
+
+            RefreshAura(SHAMAN_FLAME_SHOCK_PASSIVE);
+
+            RefreshAura(SHAMAN_T10_RESTO_4P, level >= 70 ? 1 : 0);
+
+            RefreshAura(GLYPH_THUNDERSTORM, GetSpell(THUNDERSTORM_1) ? 1 : 0);
+            RefreshAura(GLYPH_TOTEM_OF_WRATH, GetSpell(TOTEM_OF_WRATH_1) ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CLEANSE_SPIRIT_1:
+                case WATER_WALKING_1:
+                case WATER_BREATHING_1:
+                case BLOODLUST_1:
+                case HEROISM_1:
+                case SHAMANISTIC_RAGE_1:
+                //case ELEMENTAL_MASTERY_1:
+                case TIDAL_FORCE_1:
+                //Totems
+                //case EARTHBIND_TOTEM_1:
+                //case MAGMA_TOTEM_1:
+                //case SEARING_TOTEM_1:
+                //case STONECLAW_TOTEM_1:
+                //case FIRE_ELEMENTAL_TOTEM_1:
+                //case EARTH_ELEMENTAL_TOTEM_1:
+                //case FIRE_RESISTANCE_TOTEM_1:
+                //case FROST_RESISTANCE_TOTEM_1:
+                //case NATURE_RESISTANCE_TOTEM_1:
+                //case FLAMETONGUE_TOTEM_1:
+                case GROUNDING_TOTEM_1:
+                //case SENTRY_TOTEM_1:
+                //case STONESKIN_TOTEM_1:
+                //case STRENGTH_OF_EARTH_TOTEM_1:
+                //case WINDFURY_TOTEM_1:
+                //case WRATH_OF_AIR_TOTEM_1:
+                case CLEANSING_TOTEM_1:
+                //case HEALING_STREAM_TOTEM_1:
+                //case MANA_SPRING_TOTEM_1:
+                //case TOTEM_OF_WRATH_1:
+                case MANA_TIDE_TOTEM_1:
+                case TREMOR_TOTEM_1:
+                case TOTEMIC_RECALL_1:
+                    return true;
+                case CURE_TOXINS_1:
+                    return !GetSpell(CLEANSE_SPIRIT_1);
+                case FIRE_NOVA_1:
+                    return _totems[T_FIRE].second._type != BOT_TOTEM_NONE;
+                default:
+                    return false;
+            }
+        }
+
+        bool HasAbilitiesSpecifics() const override { return true; }
+        void FillAbilitiesSpecifics(Player const* player, std::list<std::string> &specList) override
+        {
+            uint32 textId1, textId2;
+            switch (mhEnchant)
+            {
+                //case ROCKBITER_WEAPON_1:   textId1 = BOT_TEXT_"Rockbiter";  break;
+                case FLAMETONGUE_WEAPON_1: textId1 = BOT_TEXT_FLAMETONGUE;  break;
+                case FROSTBRAND_WEAPON_1:  textId1 = BOT_TEXT_FROSTBRAND;   break;
+                case WINDFURY_WEAPON_1:    textId1 = BOT_TEXT_WINDFURY;     break;
+                case EARTHLIVING_WEAPON_1: textId1 = BOT_TEXT_EARTHLIVING;  break;
+                default:                   textId1 = BOT_TEXT_NOTHING_C;    break;
+            }
+            switch (ohEnchant)
+            {
+                //case ROCKBITER_WEAPON_1:   textId2 = BOT_TEXT_"Rockbiter";  break;
+                case FLAMETONGUE_WEAPON_1: textId2 = BOT_TEXT_FLAMETONGUE;  break;
+                case FROSTBRAND_WEAPON_1:  textId2 = BOT_TEXT_FROSTBRAND;   break;
+                case WINDFURY_WEAPON_1:    textId2 = BOT_TEXT_WINDFURY;     break;
+                case EARTHLIVING_WEAPON_1: textId2 = BOT_TEXT_EARTHLIVING;  break;
+                default:                   textId2 = BOT_TEXT_NOTHING_C;    break;
+            }
+            specList.push_back(LocalizedNpcText(player, BOT_TEXT_SLOT_MH) + ": " + LocalizedNpcText(player, textId1));
+            specList.push_back(LocalizedNpcText(player, BOT_TEXT_SLOT_OH) + ": " + LocalizedNpcText(player, textId2));
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Shaman_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Shaman_spells_cc;
+        }
+        std::vector<uint32> const* GetHealingSpellsList() const override
+        {
+            return &Shaman_spells_heal;
+        }
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Shaman_spells_support;
+        }
+
+        void InitHeals() override
+        {
+            SpellInfo const* spellInfo;
+            if (InitSpell(me, HEALING_WAVE_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, HEALING_WAVE_1));
+                _heals[HEALING_WAVE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[HEALING_WAVE_1] = 0;
+
+            if (InitSpell(me, LESSER_HEALING_WAVE_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, LESSER_HEALING_WAVE_1));
+                _heals[LESSER_HEALING_WAVE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[LESSER_HEALING_WAVE_1] = 0;
+
+            if (InitSpell(me, RIPTIDE_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, RIPTIDE_1));
+                _heals[RIPTIDE_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[RIPTIDE_1] = 0;
+
+            if (InitSpell(me, CHAIN_HEAL_1))
+            {
+                spellInfo = sSpellMgr->GetSpellInfo(InitSpell(me, CHAIN_HEAL_1));
+                _heals[CHAIN_HEAL_1] = me->SpellHealingBonusDone(me, spellInfo, spellInfo->_effects[0].CalcValue(me), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+            }
+            else
+                _heals[CHAIN_HEAL_1] = 0;
+        }
+
+    private:
+        //Totem system
+        struct BotTotemParam
+        {
+            BotTotemParam() : _effradius(0.f) {}
+            uint32 _type;
+            Position _pos;
+            float _effradius;
+        };
+
+        typedef std::pair<ObjectGuid /*guid*/, BotTotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 TotemTimer[MAX_TOTEMS];
+        //Wolves
+        ObjectGuid _wolves[MAX_WOLVES];
+        //Spells
+        uint32 CURE_TOXINS;
+        //Timers
+        uint32 TotemsCheckTimer;
+        uint32 HexyCheckTimer, EarthyCheckTimer, ShieldCheckTimer, BloodlustCheckTimer, MaelstromTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy;
+        mutable bool maelUseUp;
+        uint32 mhEnchantExpireTimer, ohEnchantExpireTimer;
+        uint32 mhEnchant, ohEnchant;
+        bool needChooseMHEnchant, needChooseOHEnchant;
+
+        typedef std::unordered_map<uint32 /*baseId*/, int32 /*amount*/> HealMap;
+        HealMap _heals;
+
+        uint32 _getTotemsMask(std::map<uint32 /*type*/, uint32 /*curId*/>& idMap) const
+        {
+            uint32 mask = 0;
+
+            Unit* cre;
+            uint32 sumonSpell;
+            uint32 baseId;
+            bool isTotem;
+            int8 mytype = -1;
+            Unit::AuraApplicationMap const& aurapps = me->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                //from totem aura extract base spell it could be summoned by
+                if (itr->second->GetBase()->GetType() != UNIT_AURA_TYPE) continue;
+                cre = itr->second->GetBase()->GetUnitOwner();
+                //DEBUG
+                //uint32 base = cre->GetUInt32Value(UNIT_CREATED_BY_SPELL);
+                //if (base)
+                //    baseId = sSpellMgr->GetSpellInfo(base)->GetFirstRankSpell()->Id;
+                //if (target->GetEntry() == 70025 && cre->GetGUID() != me->GetGUID())
+                //{
+                //    TC_LOG_ERROR("spells","totemMask: unit %s, %s (%u), owner %s (crSp %u, base %u), istotem %u", target->GetName().c_str(),
+                //        itr->second->GetBase()->GetSpellInfo()->SpellName[0], itr->second->GetBase()->GetId(),
+                //        cre ? cre->GetName().c_str() : "unk", base, baseId, uint32(cre->IsTotem()));
+                //}
+                sumonSpell = cre ? cre->GetUInt32Value(UNIT_CREATED_BY_SPELL) : 0;
+                if (!sumonSpell || !cre->IsTotem())
+                    continue;
+
+                isTotem = true;
+                baseId = sSpellMgr->GetSpellInfo(sumonSpell)->GetFirstRankSpell()->Id;
+                switch (baseId)
+                {
+                    case FIRE_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_FIRE;     mytype = T_WATER;   break;
+                    case FROST_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_FROST;    mytype = T_FIRE;    break;
+                    case NATURE_RESISTANCE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_RESISTANCE_NATURE;   mytype = T_AIR;     break;
+                    case FLAMETONGUE_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_FLAMETONGUE;         mytype = T_FIRE;    break;
+                    case GROUNDING_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_GROUNDING;           mytype = T_AIR;     break;
+                    //case STONESKIN_TOTEM_1:
+                    //    mask |= BOT_TOTEM_MASK_STONESKIN;           mytype = T_EARTH;   break;
+                    case STRENGTH_OF_EARTH_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_STRENGTH_OF_EARTH;   mytype = T_EARTH;   break;
+                    case WINDFURY_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_WINDFURY;            mytype = T_AIR;     break;
+                    case WRATH_OF_AIR_TOTEM_1: //no ranking
+                        mask |= BOT_TOTEM_MASK_WRATH_OF_AIR;        mytype = T_AIR;     break;
+                    case MANA_SPRING_TOTEM_1:
+                        mask |= BOT_TOTEM_MASK_MANA_SPRING;         mytype = T_WATER;   break;
+                    case TOTEM_OF_WRATH_1:
+                        mask |= BOT_TOTEM_MASK_WRATH;               mytype = T_FIRE;    break;
+                    default:
+                        isTotem = false; //next aura
+                        break;
+                }
+
+                if (isTotem)
+                {
+                    idMap[baseId] = sumonSpell;
+                    for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+                    {
+                        if (itr->second->GetBase()->GetCasterGUID() == me->m_SummonSlot[i+1])
+                        {
+                            //mask |= BOT_TOTEM_MASK_MY_TOTEM;
+                            switch (mytype)
+                            {
+                                case T_FIRE:    mask |= BOT_TOTEM_MASK_MY_TOTEM_FIRE;   break;
+                                case T_EARTH:   mask |= BOT_TOTEM_MASK_MY_TOTEM_EARTH;  break;
+                                case T_WATER:   mask |= BOT_TOTEM_MASK_MY_TOTEM_WATER;  break;
+                                case T_AIR:     mask |= BOT_TOTEM_MASK_MY_TOTEM_AIR;    break;
+                                default:                                                break;
+                            }
+                            break;
+                        }
+                    }
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp b/src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp
new file mode 100644
index 000000000..7069b50f9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_spellbreaker_ai.cpp
@@ -0,0 +1,603 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botspell.h"
+#include "Creature.h"
+//#include "GridNotifiers.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+/*
+Spell Breaker NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Spellbreaker (Warcraft III tribute)
+Abilities:
+1) Steal Magic (Spellsteal). steals a benefical spell from an enemy and applies it to a nearby ally or removes a
+negative spell from an ally and applies it to a nearby enemy, affects magic and curse effects, 3 seconds cooldown.
+2) Control Magic NIY (no substitute for spell)
+3) Feedback (passive). Successful melee attacks burn target's mana equal to damage caused, dealing arcane damage
+Complete - 67%
+TODO:
+*/
+
+enum SpellbreakerBaseSpells
+{
+    SPELLSTEAL_1            = SPELL_STEAL_MAGIC
+};
+enum SpellbreakerPassives
+{
+};
+enum SpellbreakerSpecial
+{
+    SPELLSTEAL_COST         = 75 * 5,
+
+    FEEDBACK_EFFECT         = SPELL_FEEDBACK,
+
+    MH_ATTACK_VISUAL        = SPELL_ATTACK_MELEE_1H,
+    SPELLSTEAL_VISUAL       = 34396,// Zap selfcast
+    ENERGY_SYPHON_ENERGIZE  = 27287 // Only for combat log spell message
+};
+
+static const uint32 Spellbreaker_spells_support_arr[] =
+{ SPELLSTEAL_1 };
+
+static const std::vector<uint32> Spellbreaker_spells_support(FROM_ARRAY(Spellbreaker_spells_support_arr));
+
+class spellbreaker_bot : public CreatureScript
+{
+public:
+    spellbreaker_bot() : CreatureScript("spellbreaker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new spellbreaker_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct spellbreaker_botAI : public bot_ai
+    {
+        spellbreaker_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SPELLBREAKER;
+
+            InitUnitFlags();
+
+            //spellbreaker immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { /*UnsummonAll();*/ bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (me->GetPower(POWER_MANA) < SPELLSTEAL_COST)
+                    DrinkPotion(true);
+                else if (GetHealthPCT(me) < 50)
+                    DrinkPotion(false);
+            }
+
+            if ((me->GetVictim() || Rand() < 15) && IsSpellReady(SPELLSTEAL_1, diff))
+                CureGroup(GetSpell(SPELLSTEAL_1), diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckDispel(diff);
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting())
+                return;
+
+            Unit* target = FindHostileDispelTarget(CalcSpellMaxRange(SPELLSTEAL_1));
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                return;
+
+            SetSpellCooldown(SPELLSTEAL_1, 500); //fail
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            float pctbonus = 1.0f;
+
+            if (damageinfo.Target && damageinfo.Target->GetPowerType() == POWER_MANA && damageinfo.Target->GetMaxPower(POWER_MANA) > 1 &&
+                damageinfo.Target->GetPower(POWER_MANA) < me->GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE))
+            {
+                pctbonus *= 3.f;
+                if (_doCrit == false && urand(1,100) < 2 * GetBotCritChance())
+                    _doCrit = true;
+            }
+            else if (_doCrit == true)
+                _doCrit = false;
+
+            damageinfo.Damages[0].Damage *= pctbonus;
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float pctbonus = 1.0f;
+
+            //Feedback scaling: 50%
+            if (baseId == FEEDBACK_EFFECT && effIndex == EFFECT_0)
+                value += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.5f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            value = value * pctbonus;
+        }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const override
+        {
+            return _doCrit ? MELEE_HIT_CRIT : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == FEEDBACK_EFFECT)
+                me->CastSpell(me, MH_ATTACK_VISUAL, true);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+
+            if (baseId == SPELLSTEAL_1)
+                ProcessSpellsteal(target);
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Feedback
+            if (damage && victim != me && damageType == DIRECT_DAMAGE)
+            {
+                if (victim->GetPowerType() == POWER_MANA && victim->GetMaxPower(POWER_MANA) > 1)
+                {
+                    if (uint32 burned = std::min<uint32>(victim->GetPower(POWER_MANA), damage + me->GetLevel() * 2))
+                    {
+                        int32 basepoints = int32(burned);
+                        //reduce amount againts ex bots
+                        if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotClass() >= BOT_CLASS_EX_START)
+                            basepoints /= 10;
+
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints);
+                        me->CastSpell(victim, FEEDBACK_EFFECT, args);
+                    }
+                }
+                else
+                {
+                    me->EnergizeBySpell(me, ENERGY_SYPHON_ENERGIZE, int32(damage / 4), POWER_MANA);
+                    me->SendPlaySpellVisual(524); //mana gain visual
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            _doCrit = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 /*diff*/) override
+        {
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(SPELLSTEAL_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case SPELLSTEAL_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        //std::vector<uint32> const* GetDamagingSpellsList() const override
+        //{
+        //    return &Spellbreaker_spells_damage;
+        //}
+        //std::vector<uint32> const* GetCCSpellsList() const override
+        //{
+        //    return &Spellbreaker_spells_cc;
+        //}
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Spellbreaker_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Spellbreaker_spells_support;
+        }
+
+    private:
+
+        mutable bool _doCrit;
+
+        void ProcessSpellsteal(Unit* target)
+        {
+            DispelChargesList steal_list;
+
+            bool const isFriend = IsInBotParty(target) || target->IsFriendlyTo(me);
+            static const uint32 sbDispelMask  = (1<<DISPEL_MAGIC) | (1<<DISPEL_CURSE);
+            static const uint8 max_dispelled = 1;
+
+            //TC_LOG_ERROR("entities.unit", "ProcessSpellsteal: on %s, fr=%u", target->GetName().c_str(), uint32(isFriend));
+
+            Unit::AuraMap const& auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+            {
+                Aura* aura = itr->second;
+
+                if (aura->IsPassive() || !(aura->GetSpellInfo()->GetDispelMask() & sbDispelMask) ||
+                    (aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE))
+                    continue;
+
+                AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                if (!aurApp)
+                    continue;
+
+                //do not dispel positive auras from enemies and negative ones from friends
+                if (aurApp->IsPositive() == isFriend)
+                    continue;
+
+                int32 chance = aura->CalcDispelChance(target, !isFriend);
+                if (!chance)
+                    continue;
+                //TC_LOG_ERROR("entities.unit", "%s", aura->GetSpellInfo()->SpellName[0]);
+
+                // The charges / stack amounts don't count towards the total number of auras that can be dispelled.
+                // Ie: A dispel on a target with 5 stacks of Winters Chill and a Polymorph has 1 / (1 + 1) -> 50% chance to dispell
+                // Polymorph instead of 1 / (5 + 1) -> 16%.
+                bool dispel_charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES);
+                uint8 charges = dispel_charges ? aura->GetCharges() : aura->GetStackAmount();
+                if (charges > 0)
+                    steal_list.emplace_back(aura, chance, charges);
+            }
+
+            if (steal_list.empty())
+                return;
+
+            //TC_LOG_ERROR("entities.unit", "failcount...");
+
+            size_t remaining = steal_list.size();
+            uint32 failCount = 0;
+            DispelChargesList success_list;
+            success_list.reserve(max_dispelled);
+            WorldPacket dataFail(SMSG_DISPEL_FAILED, 8+8+4+4+max_dispelled*4);
+            // dispel N = damage buffs (or while exist buffs for dispel)
+            for (uint8 count = 0; count < max_dispelled && remaining > 0;)
+            {
+                // Random select buff for dispel
+                DispelChargesList::iterator itr = steal_list.begin();
+                std::advance(itr, urand(0, steal_list.size() - 1));
+
+                //int32 chance = itr->RollDispel();//itr->first->CalcDispelChance(target, !isFriend);
+                // 2.4.3 Patch Notes: "Dispel effects will no longer attempt to remove effects that have 100% dispel resistance."
+                //if (!chance)
+                //{
+                //    steal_list.erase(itr);
+                //    continue;
+                //}
+                //else
+                bool chance = itr->RollDispel();
+                {
+                    if (chance/*roll_chance_i(chance)*/)
+                    {
+                        auto successItr = std::find_if(success_list.begin(), success_list.end(), [&itr](DispelableAura& dispelAura) -> bool
+                        {
+                            if (dispelAura.GetAura()->GetId() == itr->GetAura()->GetId() && dispelAura.GetAura()->GetCaster() == itr->GetAura()->GetCaster())
+                                return true;
+                            return false;
+                        });
+
+                        if (successItr == success_list.end())
+                            success_list.emplace_back(itr->GetAura(), 0, 1);
+                        else
+                            successItr->IncrementCharges();
+
+                        if (!itr->DecrementCharge())
+                        {
+                            --remaining;
+                            std::swap(*itr, steal_list[remaining]);
+                        }
+                        //success_list.push_back(std::make_pair(itr->first->GetId(), itr->first->GetCasterGUID()));
+                        //--itr->second;
+                        //if (itr->second <= 0)
+                        //    steal_list.erase(itr);
+                    }
+                    else
+                    {
+                        if (!failCount)
+                        {
+                            // Failed to dispell
+                            dataFail << uint64(me->GetGUID());                  // Caster GUID
+                            dataFail << uint64(target->GetGUID());              // Victim GUID
+                            dataFail << uint32(SPELLSTEAL_1);                   // dispel spell id
+                        }
+                        ++failCount;
+                        dataFail << uint32(itr->GetAura()->GetId());                // Spell Id
+                    }
+                    ++count;
+                }
+            }
+
+            if (failCount)
+                me->SendMessageToSet(&dataFail, true);
+
+            if (success_list.empty())
+                return;
+
+            //TC_LOG_ERROR("entities.unit", "logs and auras");
+
+            WorldPacket dataSuccess(SMSG_SPELLSTEALLOG, 8+8+4+1+4+max_dispelled*5);
+            dataSuccess << target->GetPackGUID();           // Victim GUID
+            dataSuccess << me->GetPackGUID();               // Caster GUID
+            dataSuccess << uint32(SPELLSTEAL_1);            // dispel spell id
+            dataSuccess << uint8(0);                        // not used
+            dataSuccess << uint32(success_list.size());     // count
+
+            Unit* randomTarget = nullptr;
+
+            std::list<Unit*> targets;
+
+            if (isFriend) //negative spell from friend to enemy
+            {
+                GetNearbyTargetsList(targets, 50, 0);
+                if (Unit* u = me->GetVictim())
+                {
+                    if (!u->GetVictim() && me->IsWithinDistInMap(u, 50) && !me->IsFriendlyTo(u) &&
+                        me->IsValidAttackTarget(u) && u->GetCreatureType() != CREATURE_TYPE_CRITTER && !u->IsTotem() &&
+                        me->CanSeeOrDetect(u))
+                        targets.push_back(u);
+                }
+                //Trinity::AnyUnfriendlyAttackableVisibleUnitInObjectRangeCheck check(me, 50.f);
+                //Trinity::UnitListSearcher<Trinity::AnyUnfriendlyAttackableVisibleUnitInObjectRangeCheck> searcher(me, targets, check);
+                //me->VisitNearbyObject(50.f, searcher);
+            }
+            else
+            {
+                GetNearbyFriendlyTargetsList(targets, 50); //not self
+                targets.push_back(me); //add self
+            }
+
+            if (!targets.empty())
+            {
+                //if target has stealed aura we should skip him if possible
+                std::list<Unit*> targetsCopy = targets;
+                targets.remove_if(BOTAI_PRED::AuraedTargetExclude(success_list.front().GetAura()->GetId()));
+
+                randomTarget = Trinity::Containers::SelectRandomContainerElement(!targets.empty() ? targets : targetsCopy);
+            }
+
+            for (DispelChargesList::iterator itr = success_list.begin(); itr != success_list.end(); ++itr)
+            {
+                dataSuccess << uint32(itr->GetAura()->GetId());          // Spell Id
+                dataSuccess << uint8(0);                    // 0 - steals !=0 transfers
+
+                if (randomTarget)
+                {
+                    //target->RemoveAurasDueToSpellBySteal(itr->first, itr->second, randomTarget);
+                    TransferAura(itr->GetAura()->GetId(), itr->GetAura()->GetCasterGUID(), target, randomTarget);
+                    randomTarget->CastSpell(randomTarget, SPELLSTEAL_VISUAL, true);
+                }
+                else
+                    target->RemoveAurasDueToSpellByDispel(itr->GetAura()->GetId(), SPELLSTEAL_1, itr->GetAura()->GetCasterGUID(), me, uint8(-1));
+            }
+
+            me->SendMessageToSet(&dataSuccess, true);
+        }
+
+        void TransferAura(uint32 spellId, ObjectGuid casterGUID, Unit* target, Unit* newTarget)
+        {
+            //Copied from Unit::RemoveAurasDueToSpellBySteal with modifications
+            Unit::AuraMapBoundsNonConst range = target->GetOwnedAuras().equal_range(spellId);
+            for (Unit::AuraMap::iterator iter = range.first; iter != range.second;)
+            {
+                Aura* aura = iter->second;
+                if (aura->GetCasterGUID() == casterGUID)
+                {
+                    int32 damage[MAX_SPELL_EFFECTS];
+                    int32 baseDamage[MAX_SPELL_EFFECTS];
+                    uint8 effMask = 0;
+                    uint8 recalculateMask = 0;
+                    Unit* caster = aura->GetCaster();
+                    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+                    {
+                        if (aura->GetEffect(i))
+                        {
+                            baseDamage[i] = aura->GetEffect(i)->GetBaseAmount();
+                            damage[i] = aura->GetEffect(i)->GetAmount();
+                            effMask |= (1<<i);
+                            if (aura->GetEffect(i)->CanBeRecalculated())
+                                recalculateMask |= (1<<i);
+                        }
+                        else
+                        {
+                            baseDamage[i] = 0;
+                            damage[i] = 0;
+                        }
+                    }
+
+                    bool stealCharge = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES);
+                    // Limit max duration to 5 minutes
+                    int32 dur = std::min<int32>(int32(5 * MINUTE * IN_MILLISECONDS), aura->GetDuration());
+                    // But at least for 5 seconds
+                    dur = std::max<int32>(dur, 5 * IN_MILLISECONDS);
+
+                    if (Aura* oldAura = newTarget->GetAura(aura->GetId(), aura->GetCasterGUID()))
+                    {
+                        if (stealCharge)
+                            oldAura->ModCharges(aura->GetCharges());
+                        else
+                            oldAura->ModStackAmount(aura->GetStackAmount());
+                        oldAura->SetDuration(dur);
+                    }
+                    else
+                    {
+                        // single target state must be removed before aura creation to preserve existing single target aura
+                        if (aura->IsSingleTarget())
+                            aura->UnregisterSingleTarget();
+
+                        AuraCreateInfo createInfo(aura->GetSpellInfo(), effMask, newTarget);
+                        createInfo.SetCasterGUID(aura->GetCasterGUID());
+                        createInfo.SetBaseAmount(baseDamage);
+                        //Auras created by scripts may have no caster, prevent crash in Aura::TryRefreshStackOrCreate()
+                        if (!createInfo.CasterGUID)
+                            createInfo.SetCasterGUID(me->GetGUID());
+                        if (Aura* newAura = Aura::TryRefreshStackOrCreate(createInfo))
+                        {
+                            // created aura must not be single target aura,, so stealer won't loose it on recast
+                            if (newAura->IsSingleTarget())
+                            {
+                                newAura->UnregisterSingleTarget();
+                                aura->SetIsSingleTarget(true);
+                                caster->GetSingleCastAuras().push_back(aura);
+                            }
+                            newAura->SetLoadedState(aura->GetMaxDuration(), dur, aura->GetCharges(), aura->GetStackAmount(), recalculateMask, aura->GetCritChance(), aura->CanApplyResilience(), &damage[0]);
+                            newAura->ApplyForTargets();
+                        }
+                    }
+
+                    aura->Remove(AURA_REMOVE_BY_ENEMY_SPELL);
+                    return;
+                }
+                else
+                    ++iter;
+            }
+        }
+    };
+};
+
+void AddSC_spellbreaker_bot()
+{
+    new spellbreaker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_sphynx_ai.cpp b/src/server/game/AI/NpcBots/bot_sphynx_ai.cpp
new file mode 100644
index 000000000..f5ca24e60
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_sphynx_ai.cpp
@@ -0,0 +1,605 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottraits.h"
+#include "Creature.h"
+#include "ScriptMgr.h"
+/*
+Obsidian Destroyer NpcBot (by Trickerer onlysuffering@gmail.com)
+Description:
+Obsidian winged monstrocity with unsatable hunger for magic (Warcraft III tribute)
+Specifics:
+High armor, very high resistances, partially immune to magic, negative mana regeneration (-2%/sec, cannot be changed),
+any armor, dual-wielding wands, no physical attack, spellpower = 50% attack power + 200% intellect
+Abilities:
+1) Devour Magic: dispel up to 2 magic effects from enemies, up to 2 magic effects and up to 2 curses from allies
+and damaging summoned units in 20 yards area, every dispelled effect restores 20% mana and 5% health, 7 seconds cooldown
+2) Shadow Bolt: main attack, single target, no mana cost
+3) Shadow Blast: 125 mana empowered attack, splash damage (6.25% of base mana)
+4) Shadow Armor (passive, custom): restores mana equal to a percentage of damage taken
+5) Drain Mana: leech all mana from a friendly target (up to 100% of od's max mana)
+6) Replenish Mana: restores 2% of max mana to up to 10 surrounding allies within 25yds at cost of all mana
+7) Replenish Life: restores 3% of max hp to up to 10 surrounding allies within 25yds at cost of all mana
+Complete - 100%
+TODO:
+*/
+
+enum SphynxBaseSpells
+{
+    MAIN_ATTACK_1           = SPELL_SHADOW_BOLT1,
+    SPLASH_ATTACK_1         = SPELL_SHADOW_BLAST,
+    DEVOUR_MAGIC_1          = SPELL_DEVOUR_MAGIC,
+    DRAIN_MANA_1            = SPELL_DRAIN_MANA,
+
+    REPLENISH_MANA_1        = SPELL_REPLENISH_MANA,
+    REPLENISH_HEALTH_1      = SPELL_REPLENISH_HEALTH
+};
+enum SphynxPassives
+{
+};
+enum SphynxSpecial
+{
+    MH_ATTACK_ANIM          = SPELL_ATTACK_MELEE_1H,
+    MH_OH_ATTACK_ANIM       = SPELL_ATTACK_MELEE_RANDOM,
+    SPELL_ENERGIZE          = 34424,//"Shadow Armor"
+
+    SPLASH_ATTACK_COST      = BASE_MANA_SPHYNX/16//6.25%
+};
+
+static const uint32 Sphynx_spells_damage_arr[] =
+{ /*MAIN_ATTACK_1, */SPLASH_ATTACK_1 };
+
+static const uint32 Sphynx_spells_heal_arr[] =
+{ REPLENISH_HEALTH_1 };
+
+static const uint32 Sphynx_spells_support_arr[] =
+{ DEVOUR_MAGIC_1, /*DRAIN_MANA_1, */REPLENISH_HEALTH_1, REPLENISH_MANA_1 };
+
+static const std::vector<uint32> Sphynx_spells_damage(FROM_ARRAY(Sphynx_spells_damage_arr));
+static const std::vector<uint32> Sphynx_spells_heal(FROM_ARRAY(Sphynx_spells_heal_arr));
+static const std::vector<uint32> Sphynx_spells_support(FROM_ARRAY(Sphynx_spells_support_arr));
+
+class sphynx_bot : public CreatureScript
+{
+public:
+    sphynx_bot() : CreatureScript("sphynx_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new sphynx_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct sphynx_botAI : public bot_ai
+    {
+        sphynx_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_SPHYNX;
+
+            InitUnitFlags();
+
+            //sphynx immunities
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_POSSESS, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_CHARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_SHAPESHIFT, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_TRANSFORM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_BLOCK_SPELL_FAMILY, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_DISARM_OFFHAND, true);
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_DISARM, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_BLEED, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_POLYMORPH, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INFECTED, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_INTERRUPT, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_FEAR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_HORROR, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_TURN, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SLEEP, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SILENCE, true);
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, MECHANIC_SNARE, true);
+            me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK, true);
+            me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_KNOCK_BACK_DEST, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { dmgReceived = 0; DraincheckTimer = 2000; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { dmgReceived = 0; bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            CheckDevourMagic(diff);
+
+            if (IsSpellReady(DEVOUR_MAGIC_1, diff))
+                CureGroup(DEVOUR_MAGIC_1, diff);
+
+            //if (!me->IsInCombat())
+            //    DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            CheckReplenishHealth(diff);
+            CheckReplenishMana(diff);
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            CheckDrainMana(diff);
+
+            MoveBehind(mytar);
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (GC_Timer > diff)
+                return;
+
+            if (me->GetDistance(mytar) > 20)
+                return;
+
+            if (me->isMoving() && !me->HasInArc(float(M_PI)/2, mytar))
+                return;
+
+            if (!CanAffectVictimAny(mytar, SPELL_SCHOOL_SHADOW, SPELL_SCHOOL_ARCANE))
+                return;
+
+            if (me->GetPower(POWER_MANA) >= SPLASH_ATTACK_COST && IsSpellReady(SPLASH_ATTACK_1, diff))
+            {
+                if (doCast(mytar, GetSpell(SPLASH_ATTACK_1)))
+                    return;
+            }
+            else if (IsSpellReady(MAIN_ATTACK_1, diff))
+            {
+                if (doCast(mytar, GetSpell(MAIN_ATTACK_1)))
+                    return;
+            }
+        }
+
+        void CheckDevourMagic(uint32 diff)
+        {
+            if (DevourcheckTimer > diff || !IsSpellReady(DEVOUR_MAGIC_1, diff, false) || IsCasting() ||
+                (GetHealthPCT(me) > 75 && Rand() > 15 &&
+                (!HasRole(BOT_ROLE_DPS) || me->GetPower(POWER_MANA) >= SPLASH_ATTACK_COST * 6)))
+                return;
+
+            DevourcheckTimer = urand(350, 700);
+
+            Unit* target = FindHostileDispelTarget(40);
+            if (target && doCast(target, GetSpell(DEVOUR_MAGIC_1)))
+                return;
+        }
+
+        void CheckDrainMana(uint32 diff)
+        {
+            if (DraincheckTimer > diff || Rand() > 40 || IAmFree() || !HasRole(BOT_ROLE_DPS) || IsCasting() ||
+                !IsSpellReady(DRAIN_MANA_1, diff, false) || me->GetPower(POWER_MANA) >= SPLASH_ATTACK_COST)
+                return;
+
+            DraincheckTimer = urand(750, 1500);
+
+            std::list<Unit*> targets;
+            GetNearbyFriendlyTargetsList(targets, 40);
+            targets.remove_if(BOTAI_PRED::DrainTargetExclude());
+
+            if (targets.empty())
+                return;
+
+            Unit* target = Trinity::Containers::SelectRandomContainerElement(targets);
+            if (doCast(target, GetSpell(DRAIN_MANA_1)))
+                return;
+        }
+
+        void CheckReplenishHealth(uint32 diff)
+        {
+            if (ReplHealthcheckTimer > diff || !IsSpellReady(REPLENISH_HEALTH_1, diff) || IAmFree() ||
+                !HasRole(BOT_ROLE_HEAL) || IsCasting() ||
+                (HasRole(BOT_ROLE_DPS) && me->GetPower(POWER_MANA) > 0))
+                return;
+
+            ReplHealthcheckTimer = 1000;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                return;
+
+            bool haveHp = false;
+            uint8 partycombat = 0, partynocombat = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsInCombat())
+                    partycombat++;
+                else if (player->IsAlive())
+                    partynocombat++;
+
+                if (!haveHp && player->IsAlive() && me->GetDistance(player) < 15 &&
+                    GetHealthPCT(player) < 95)
+                    haveHp = true;
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (!bot->IsInWorld())
+                        continue;
+
+                    if (bot->IsInCombat())
+                        partycombat++;
+                    else if (bot->IsAlive())
+                        partynocombat++;
+
+                    if (!haveHp && bot != me && bot->IsAlive() && me->GetDistance(bot) < 15 && GetHealthPCT(bot) < 95)
+                        haveHp = true;
+                }
+            }
+
+            if (haveHp && (!me->IsInCombat() || partycombat > partynocombat) &&
+                doCast(me, GetSpell(REPLENISH_HEALTH_1)))
+                return;
+        }
+
+        void CheckReplenishMana(uint32 diff)
+        {
+            if (ReplManacheckTimer > diff || !IsSpellReady(REPLENISH_MANA_1, diff) || IAmFree() || IsCasting() ||
+                (HasRole(BOT_ROLE_DPS) && me->GetPower(POWER_MANA) > 0))
+                return;
+
+            ReplManacheckTimer = 1000;
+
+            Group const* gr = master->GetGroup();
+            if (!gr)
+                return;
+
+            bool haveMana = false;
+            uint8 partycombat = 0, partynocombat = 0;
+            for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+            {
+                Player const* player = itr->GetSource();
+                if (!player || me->GetMap() != player->FindMap())
+                    continue;
+
+                if (player->IsInCombat())
+                    partycombat++;
+                else if (player->IsAlive())
+                    partynocombat++;
+
+                if (!haveMana && player->IsAlive() && me->GetDistance(player) < 15 &&
+                    GetManaPCT(player) < 95)
+                    haveMana = true;
+
+                if (!player->HaveBot())
+                    continue;
+
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature const* bot = it->second;
+                    if (!bot->IsInWorld())
+                        continue;
+
+                    if (bot->IsInCombat())
+                        partycombat++;
+                    else if (bot->IsAlive())
+                        partynocombat++;
+
+                    if (!haveMana && bot->IsInWorld() && bot->IsAlive() && me->GetDistance(bot) < 15 &&
+                        bot->GetBotClass() != BOT_CLASS_SPHYNX &&
+                        GetManaPCT(bot) < 95)
+                        haveMana = true;
+                }
+            }
+
+            if (haveMana && (!me->IsInCombat() || partycombat > partynocombat) &&
+                doCast(me, GetSpell(REPLENISH_MANA_1)))
+                return;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+
+            //apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (iscrit)
+                pctbonus *= 1.333f;
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == MAIN_ATTACK_1 || baseId == SPLASH_ATTACK_1 || baseId == DEVOUR_MAGIC_1 ||
+                baseId == DRAIN_MANA_1 || baseId == REPLENISH_MANA_1 || baseId == REPLENISH_HEALTH_1)
+                GC_Timer = uint32(me->GetAttackTime(BASE_ATTACK) * me->m_modAttackSpeedPct[BASE_ATTACK]);
+
+            if (baseId == SPLASH_ATTACK_1)
+                me->CastSpell(me, MH_ATTACK_ANIM, true);
+            else if (baseId == MAIN_ATTACK_1)
+                me->CastSpell(me, MH_OH_ATTACK_ANIM, true);
+
+            if (baseId == DEVOUR_MAGIC_1)
+            {
+                me->CastSpell(me, MH_OH_ATTACK_ANIM, true);
+
+                if (dispelsDealt > 0)
+                {
+                    //gain 20% of max mana and 5% of max health for every dispel
+                    int32 manaGain = me->GetMaxPower(POWER_MANA) / 5 * dispelsDealt;
+                    uint32 healthGain = me->GetMaxHealth() / 20 * dispelsDealt;
+
+                    HealInfo hinfo(me, me, healthGain, spellInfo, spellInfo->GetSchoolMask());
+
+                    me->EnergizeBySpell(me, DEVOUR_MAGIC_1, manaGain, POWER_MANA);
+                    me->HealBySpell(hinfo);
+
+                    me->CastSpell(me, SPELL_DEVOUR_MAGIC_CASTER_IMPACT, true);
+                }
+
+                dispelsDealt = 0;
+            }
+
+            if (baseId == DRAIN_MANA_1)
+                me->CastSpell(me, MH_OH_ATTACK_ANIM, true);
+
+            if (baseId == REPLENISH_MANA_1)
+                me->SendPlaySpellVisual(425); //arcane cast omni
+            if (baseId == REPLENISH_HEALTH_1)
+                me->SendPlaySpellVisual(21); //empty cast finish anim
+
+            if (baseId == REPLENISH_MANA_1 || baseId == REPLENISH_HEALTH_1)
+                me->SetPower(POWER_MANA, 0);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            if (blastVisualTimer < GetLastDiff() && spellId == SPLASH_ATTACK_1)
+            {
+                blastVisualTimer = 500;
+                me->CastSpell(*target, SHADOWFURY_VISUAL, true);
+            }
+            //Devour Magic: damage to summons
+            if (spellId == DEVOUR_MAGIC_1 && target->IsSummon() && target->GetUInt32Value(UNIT_CREATED_BY_SPELL) &&
+                !target->IsTotem() && me->GetReactionTo(target) <= REP_NEUTRAL)
+            {
+                SpellInfo const* devInfo = sSpellMgr->GetSpellInfo(spellId);
+                uint32 damage = std::min<uint32>(target->GetMaxHealth() / 2, me->GetMaxHealth() / 5 + me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+                Unit::DealDamage(me, target, damage, nullptr, SPELL_DIRECT_DAMAGE, devInfo->GetSchoolMask(), devInfo);
+                OnBotDispelDealt(target, 1);
+            }
+
+            if (spellId == DRAIN_MANA_1)
+            {
+                me->CastSpell(target, SPELL_DEVOUR_MAGIC_BEAM, true);
+                target->SendPlaySpellVisual(419); //drain impact visual
+            }
+            if (spellId == REPLENISH_MANA_1)
+                if (target != me)
+                    target->SendPlaySpellVisual(524/*436*/); //mana gain visual//heal bigger crimson ish
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void OnBotDispelDealt(Unit* dispelled, uint8 num) override
+        {
+            //cast drain visual on dispelled
+            if (me != dispelled)
+            {
+                me->CastSpell(dispelled, SPELL_DEVOUR_MAGIC_BEAM, true);
+                dispelled->SendPlaySpellVisual(357/*317*/); //purge visual
+            }
+
+            dispelsDealt += num;
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (damage)
+            {
+                dmgReceived += damage / 10;
+                uint32 energizeThreshold = me->GetMaxPower(POWER_MANA) / 10;
+
+                int32 manaGain = 0;
+                while (dmgReceived >= energizeThreshold)
+                {
+                    manaGain += energizeThreshold;
+                    dmgReceived -= energizeThreshold;
+                }
+                if (manaGain)
+                    me->EnergizeBySpell(me, SPELL_ENERGIZE, manaGain, POWER_MANA);
+            }
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void CheckAttackState() override
+        {
+        }
+
+        void Reset() override
+        {
+            blastVisualTimer = 0;
+            DevourcheckTimer = 0;
+            DraincheckTimer = 0;
+            ReplManacheckTimer = 0;
+            ReplHealthcheckTimer = 0;
+
+            dmgReceived = 0;
+            dispelsDealt = 0;
+
+            DefaultInit();
+
+            me->SetPower(POWER_MANA, 0);
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (blastVisualTimer > diff)            blastVisualTimer -= diff;
+            if (DevourcheckTimer > diff)            DevourcheckTimer -= diff;
+            if (DraincheckTimer > diff)             DraincheckTimer -= diff;
+            if (ReplManacheckTimer > diff)          ReplManacheckTimer -= diff;
+            if (ReplHealthcheckTimer > diff)        ReplHealthcheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            InitSpellMap(MAIN_ATTACK_1, true, false);
+            InitSpellMap(SPLASH_ATTACK_1, true, false);
+            InitSpellMap(DEVOUR_MAGIC_1, true, false);
+            InitSpellMap(DRAIN_MANA_1, true, false);
+
+            InitSpellMap(REPLENISH_MANA_1, true, false);
+            InitSpellMap(REPLENISH_HEALTH_1, true, false);
+        }
+
+        void ApplyClassPassives() const override
+        {
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case DEVOUR_MAGIC_1:
+                case DRAIN_MANA_1:
+                case REPLENISH_MANA_1:
+                case REPLENISH_HEALTH_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Sphynx_spells_damage;
+        }
+        //std::vector<uint32> const* GetCCSpellsList() const override
+        //{
+        //    return &Sphynx_spells_cc;
+        //}
+        std::vector<uint32> const* GetHealingSpellsList() const override
+        {
+            return &Sphynx_spells_heal;
+        }
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Sphynx_spells_support;
+        }
+
+    private:
+        uint32 blastVisualTimer;
+        uint32 DevourcheckTimer, DraincheckTimer, ReplManacheckTimer, ReplHealthcheckTimer;
+
+        uint32 dmgReceived;
+        uint8 dispelsDealt;
+    };
+};
+
+void AddSC_sphynx_bot()
+{
+    new sphynx_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 000000000..7259d38bf
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,2103 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottraits.h"
+#include "Group.h"
+#include "Log.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "TemporarySummon.h"
+#include "World.h"
+/*
+Warlock NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 85%
+TODO: rituals (not directly feasable), demonic circle, demonic empowerment, demonic pact, health funnel, healthstones for bots, etc...
+*/
+
+enum WarlockBaseSpells
+{
+    CURSE_OF_WEAKNESS_1                 = 702,
+    CURSE_OF_AGONY_1                    = 980,
+    CURSE_OF_TONGUES_1                  = 1714,
+    CURSE_OF_EXHAUSTION_1               = 18223,
+    CURSE_OF_THE_ELEMENTS_1             = 1490,
+    CURSE_OF_DOOM_1                     = 603,//NI
+    SHADOW_BOLT_1                       = 686,
+    IMMOLATE_1                          = 348,
+    CORRUPTION_1                        = 172,
+    SEED_OF_CORRUPTION_1                = 27243,
+    INCINERATE_1                        = 29722,
+    SEARING_PAIN_1                      = 5676,
+    SHADOWBURN_1                        = 17877,
+    CONFLAGRATE_1                       = 17962,
+    SOUL_FIRE_1                         = 6353,
+    CHAOS_BOLT_1                        = 50796,
+    RAIN_OF_FIRE_1                      = 5740,
+    HELLFIRE_1                          = 1949,
+    SHADOWFLAME_1                       = 47897,
+    SHADOWFURY_1                        = 30283,
+    HAUNT_1                             = 48181,
+    UNSTABLE_AFFLICTION_1               = 30108,
+    FEAR_1                              = 5782,
+    HOWL_OF_TERROR_1                    = 5484,
+    DEATH_COIL_1                        = 6789,
+    SOULSHATTER_1                       = 29858,
+
+    DRAIN_SOUL_1                        = 1120,
+    DRAIN_MANA_1                        = 5138,
+    BANISH_1                            = 710,
+
+    DEMON_SKIN_1                        = 687,
+    DEMON_ARMOR_1                       = 706,
+    FEL_ARMOR_1                         = 28176,
+    DETECT_INVISIBILITY_1               = 132,
+    UNENDING_BREATH_1                   = 5697,
+    SHADOW_WARD_1                       = 6229,
+    LIFE_TAP_1                          = 1454,
+    DARK_PACT_1                         = 18220,
+
+    CREATE_HEALTHSTONE_1                = 6201,
+    CREATE_SOULSTONE_1                  = 693,
+
+    CHAOTIC_MIND                        = 61188, //8 sec duration, no cd
+
+    RITUAL_OF_SUMMONING_1               = 698,
+    RITUAL_OF_SOULS_1                   = 29893
+};
+enum WarlockPassives
+{
+    IMPROVED_SHADOW_BOLT                = 17803,//rank 5
+    IMPROVED_DRAIN_SOUL                 = 18372,//rank 2
+    SOUL_SIPHON                         = 17805,//rank 2
+    AFTERMATH                           = 18120,//rank 2
+    IMPROVED_FEAR                       = 53759,//rank 2
+    NIGHTFALL                           = 18095,//rank 2
+    SHADOW_EMBRACE                      = 32394,//rank 5
+    SIPHON_LIFE                         = 63108,
+    BACKLASH                            = 34939,//rank 3
+    MOLTEN_CORE                         = 47247,//rank 3
+    NETHER_PROTECTION                   = 30302,//rank 3
+    ERADICATION                         = 47197,//rank 3
+    DEMONIC_RESILIENCE                  = 30321,//rank 3
+    SOUL_LEECH                          = 30296,//rank 3
+    PYROCLASM                           = 63245,//rank 3
+    DECIMATION                          = 63158,//rank 2
+    IMPROVED_SOUL_LEECH                 = 54118,//rank 2
+    PANDEMIC                            = 58435,
+    BACKDRAFT                           = 47260,//rank 3
+    EVERLASTING_AFFLICTION              = 47205,//rank 5
+
+    //Special
+    GLYPH_CORRUPTION                    = 56218,
+    GLYPH_LIFE_TAP                      = 63320,
+    GLYPH_FEAR                          = 56244,
+    GLYPH_QUICK_DECAY                   = 70947,
+    GLYPH_CONFLAGRATE                   = 56235,
+    GLYPH_SHADOWFLAME                   = 63310
+};
+
+enum WarlockSpecial
+{
+    CHAOS_BOLT_PASSIVE                  = 58284,
+    DEMONIC_IMMOLATE_PASSIVE            = 75445,
+
+    BACKLASH_BUFF                       = 34936,
+    BACKDRAFT_BUFF                      = 54277,//rank 3
+    SHADOW_TRANCE_BUFF                  = 17941,
+    MOLTEN_CORE_BUFF                    = 71165,//rank 3
+    DECIMATION_BUFF                     = 63167,//rank 2
+    CHAOTIC_MIND_BUFF                   = 61189,// "Soul Fire!" 6 sec duration Soul Fire instant cast
+    GLYPH_LIFE_TAP_BUFF                 = 63321,//"Life Tap"
+
+    SHADOW_MASTERY_DEBUFF               = 17800,// Improved Shadow Bolt talent debuff
+
+    SIPHON_LIFE_HEAL                    = 63106,
+    LIFE_TAP_ENERGIZE                   = 31818,
+
+    SEED_OF_CORRUPTION_FINAL_DAMAGE_1   = 27285,
+
+    SOULSTONE_RESURRECTION_1            = 20707,
+    SOULSTONE_RESURRECTION_2            = 20762,
+    SOULSTONE_RESURRECTION_3            = 20763,
+    SOULSTONE_RESURRECTION_4            = 20764,
+    SOULSTONE_RESURRECTION_5            = 20765,
+    SOULSTONE_RESURRECTION_6            = 27239,
+    SOULSTONE_RESURRECTION_7            = 47883,
+
+    BLOOD_PACT_1                        = 6307,
+    FEL_INTELLIGENCE_1                  = 54424,
+
+    SOUL_LINK_PET                       = 25228,//split effect lvl 20 req
+    FEL_SYNERGY_HEAL                    = 54181,
+    LIFE_TAP_ENERGIZE_PET               = 32553
+};
+
+enum CurseType : uint32
+{
+    CURSE_NONE                  = 0,
+    CURSE_WEAKNESS              = 1,
+    CURSE_AGONY                 = 2,
+    CURSE_DOOM                  = 3,
+    CURSE_ELEMENTS              = 4,
+    CURSE_TONGUES               = 5,
+    CURSE_EXHAUSTION            = 6,
+
+    CURSE_FLAG_MY_WEAKNESS,
+    CURSE_FLAG_MY_AGONY,
+    CURSE_FLAG_MY_DOOM,
+    CURSE_FLAG_MY_ELEMENTS,
+    CURSE_FLAG_MY_TONGUES,
+    CURSE_FLAG_MY_EXHAUSTION,
+
+    CURSE_MASK_WEAKNESS         = (1 << CURSE_WEAKNESS),
+    CURSE_MASK_AGONY            = (1 << CURSE_AGONY),
+    CURSE_MASK_DOOM             = (1 << CURSE_DOOM),
+    CURSE_MASK_ELEMENTS         = (1 << CURSE_ELEMENTS),
+    CURSE_MASK_TONGUES          = (1 << CURSE_TONGUES),
+    CURSE_MASK_EXHAUSTION       = (1 << CURSE_EXHAUSTION),
+
+    CURSE_MASK_MY_WEAKNESS      = (1 << CURSE_FLAG_MY_WEAKNESS),
+    CURSE_MASK_MY_AGONY         = (1 << CURSE_FLAG_MY_AGONY),
+    CURSE_MASK_MY_DOOM          = (1 << CURSE_FLAG_MY_DOOM),
+    CURSE_MASK_MY_ELEMENTS      = (1 << CURSE_FLAG_MY_ELEMENTS),
+    CURSE_MASK_MY_TONGUES       = (1 << CURSE_FLAG_MY_TONGUES),
+    CURSE_MASK_MY_EXHAUSTION    = (1 << CURSE_FLAG_MY_EXHAUSTION),
+
+    CURSE_MASK_MY_CURSE_ANY     = (CURSE_MASK_MY_WEAKNESS | CURSE_MASK_MY_AGONY | CURSE_MASK_MY_DOOM | \
+                                CURSE_MASK_MY_ELEMENTS | CURSE_MASK_MY_TONGUES | CURSE_MASK_MY_EXHAUSTION)
+};
+
+static const uint32 Warlock_spells_damage_arr[] =
+{ CHAOS_BOLT_1, CONFLAGRATE_1, CORRUPTION_1, CURSE_OF_AGONY_1, CURSE_OF_DOOM_1, DEATH_COIL_1, DRAIN_SOUL_1, HAUNT_1,
+HELLFIRE_1, IMMOLATE_1, INCINERATE_1, RAIN_OF_FIRE_1, SEARING_PAIN_1, SEED_OF_CORRUPTION_1, SHADOW_BOLT_1,
+SHADOWBURN_1, SHADOWFLAME_1, SHADOWFURY_1, SOUL_FIRE_1, UNSTABLE_AFFLICTION_1 };
+
+static const uint32 Warlock_spells_cc_arr[] =
+{ BANISH_1, CURSE_OF_TONGUES_1, CURSE_OF_EXHAUSTION_1, DEATH_COIL_1, FEAR_1, HOWL_OF_TERROR_1, SHADOWFURY_1 };
+
+static const uint32 Warlock_spells_support_arr[] =
+{ CURSE_OF_TONGUES_1, CURSE_OF_EXHAUSTION_1, CURSE_OF_THE_ELEMENTS_1, CURSE_OF_WEAKNESS_1, DARK_PACT_1, DRAIN_MANA_1,
+DEMON_SKIN_1, DEMON_ARMOR_1, DETECT_INVISIBILITY_1, FEL_ARMOR_1, LIFE_TAP_1, SHADOW_WARD_1, SOULSHATTER_1,
+UNENDING_BREATH_1/*, CREATE_HEALTHSTONE_1, CREATE_SOULSTONE_1, RITUAL_OF_SUMMONING_1, RITUAL_OF_SOULS_1*/ };
+
+static const std::vector<uint32> Warlock_spells_damage(FROM_ARRAY(Warlock_spells_damage_arr));
+static const std::vector<uint32> Warlock_spells_cc(FROM_ARRAY(Warlock_spells_cc_arr));
+static const std::vector<uint32> Warlock_spells_support(FROM_ARRAY(Warlock_spells_support_arr));
+
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new warlock_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct warlock_botAI : public bot_ai
+    {
+        static uint32 const _healthStoneSpells[8/*createHealthstoneRank*/];
+
+        warlock_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARLOCK;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        void JustEnteredCombat(Unit* u) override { canShadowWard = false; bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { UnsummonAll(); bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            if (GetSpell(FEL_ARMOR_1) && !IsTank())
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 0x0, 0x20000000, 0x0)
+                    /*!HasAuraName(me, FEL_ARMOR_1)*/ &&
+                    doCast(me, GetSpell(FEL_ARMOR_1)))
+                    return;
+            }
+            else if (GetSpell(DEMON_ARMOR_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x20, 0x0)
+                    /*!HasAuraName(me, DEMON_ARMOR_1)*/ &&
+                    doCast(me, GetSpell(DEMON_ARMOR_1)))
+                    return;
+            }
+            else if (!GetSpell(FEL_ARMOR_1) && !GetSpell(DEMON_ARMOR_1) && GetSpell(DEMON_SKIN_1))
+            {
+                if (!me->GetAuraEffect(SPELL_AURA_MOD_RESISTANCE, SPELLFAMILY_WARLOCK, 0x0, 0x0, 0x10)
+                    /*!HasAuraName(me, DEMON_SKIN_1)*/ &&
+                    doCast(me, GetSpell(DEMON_SKIN_1)))
+                    return;
+            }
+
+            if (me->GetVictim())
+                return;
+
+            if (!hasHealthstone && GetSpell(CREATE_HEALTHSTONE_1))
+            {
+                if (doCast(me, GetSpell(CREATE_HEALTHSTONE_1)))
+                    return;
+            }
+
+            if (!hasSoulstone && !IAmFree() && GetSpell(CREATE_SOULSTONE_1))
+            {
+                if (doCast(me, GetSpell(CREATE_SOULSTONE_1)))
+                    return;
+            }
+
+            if (GetSpell(DETECT_INVISIBILITY_1))
+            {
+                if (master->IsAlive() && !master->HasAuraType(SPELL_AURA_MOD_INVISIBILITY_DETECT) &&
+                    doCast(master, GetSpell(DETECT_INVISIBILITY_1)))
+                    return;
+            }
+
+            //TODO: soulstone on self/bots
+            //BUG: players cannot accept this buff if they are below lvl 20 (should be 8)
+            if (!IAmFree() && hasSoulstone && soulstoneTimer <= diff && GetSpell(CREATE_SOULSTONE_1))
+            {
+                Group const* gr = master->GetGroup();
+                Unit* u = master;
+                if (!gr)
+                {
+                    if (!u->IsAlive() || u->isPossessed() || u->IsCharmed() ||
+                        me->GetDistance(u) > 30 || u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        u = nullptr;
+                }
+                else
+                {
+                    //check rezzers first
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        u = itr->GetSource();
+                        if (!u || u->GetLevel() < 20 || !u->IsAlive() || me->GetMap() != u->FindMap() ||
+                            u->isPossessed() || u->IsCharmed() || me->GetDistance(u) > 30 ||
+                            u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        {
+                            u = nullptr;
+                            continue;
+                        }
+                        if (u->GetClass() == CLASS_PRIEST || u->GetClass() == CLASS_PALADIN ||
+                            u->GetClass() == CLASS_DRUID || u->GetClass() == CLASS_SHAMAN)
+                            break;
+                    }
+                    if (!u)
+                    {
+                        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                        {
+                            u = itr->GetSource();
+                            if (!u || u->GetLevel() < 20 || !u->IsAlive() || me->GetMap() != u->FindMap() ||
+                                u->isPossessed() || u->IsCharmed() || me->GetDistance(u) > 30 ||
+                                u->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                            {
+                                u = nullptr;
+                                continue;
+                            }
+                            break;
+                        }
+                    }
+                }
+
+                if (u)
+                {
+                    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(CREATE_SOULSTONE_1);
+                    uint32 rank = spellInfo->GetRank();
+
+                    while (rank < 7 && u->GetLevel() > spellInfo->SpellLevel && spellInfo->GetNextRankSpell())
+                    {
+                        spellInfo = spellInfo->GetNextRankSpell();
+                        rank = spellInfo->GetRank();
+                    }
+
+                    uint32 spellId;
+                    switch (spellInfo->Id)
+                    {
+                        case   693: spellId = SOULSTONE_RESURRECTION_1; break; //rank 1
+                        case 20752: spellId = SOULSTONE_RESURRECTION_2; break; //rank 2
+                        case 20755: spellId = SOULSTONE_RESURRECTION_3; break; //rank 3
+                        case 20756: spellId = SOULSTONE_RESURRECTION_4; break; //rank 4
+                        case 20757: spellId = SOULSTONE_RESURRECTION_5; break; //rank 5
+                        case 27238: spellId = SOULSTONE_RESURRECTION_6; break; //rank 6
+                        case 47884: spellId = SOULSTONE_RESURRECTION_7; break; //rank 7
+                        default:
+                            TC_LOG_ERROR("entities.player", "bot_warlockAI: unknown soulstone Id %u", spellInfo->Id);
+                            spellId = SOULSTONE_RESURRECTION_1;
+                            break;
+                    }
+                    me->CastSpell(u, spellId, false);
+                }
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+            fearTimer = std::max<uint32>(fearTimer, 1000);
+        }
+
+        void CheckFear(uint32 diff)
+        {
+            if (fearTimer > diff || GC_Timer > diff || !me->IsInCombat() || IsTank() || IsCasting())
+                return;
+
+            fearTimer = 1600;
+
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (!FEAR)
+                return;
+
+            if (FindAffectedTarget(FEAR, me->GetGUID(), 70, 255))
+                return;
+
+            Unit* feartarget = FindFearTarget(CalcSpellMaxRange(FEAR_1));
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        void CheckBanish(uint32 diff)
+        {
+            if (banishTimer > diff || GC_Timer > diff || !me->IsInCombat() || IsTank() || IsCasting() || Rand() > 50)
+                return;
+
+            banishTimer = 1600;
+
+            uint32 BANISH = GetSpell(BANISH_1);
+            if (!BANISH)
+                return;
+
+            if (FindAffectedTarget(BANISH, me->GetGUID(), 70, 255))
+                return;
+
+            Unit* banishTarget = FindUndeadCCTarget(CalcSpellMaxRange(BANISH_1), BANISH_1);
+            if (banishTarget && doCast(banishTarget, BANISH))
+                return;
+        }
+
+        void CheckUnBanish(uint32 diff)
+        {
+            if (unbanishTimer > diff || GC_Timer > diff || me->GetVictim() || IsCasting() || Rand() > 30)
+                return;
+
+            unbanishTimer = 2000;
+
+            //we check only our spell rank which is enough in 99% cases
+            uint32 BANISH = GetSpell(BANISH_1);
+            if (!BANISH)
+                return;
+
+            //looks like you cannot dispel other people's banish
+            Unit* unbanishTarget = FindAffectedTarget(BANISH, me->GetGUID(), CalcSpellMaxRange(BANISH_1));
+            if (unbanishTarget && doCast(unbanishTarget, BANISH))
+                return;
+        }
+
+        void CheckDrainMana(uint32 diff)
+        {
+            if (drainManaTimer > diff || IsPotionReady() || !IsSpellReady(DRAIN_MANA_1, diff) ||
+                !me->getAttackers().empty() || IsTank() || IsCasting() || GetManaPCT(me) > 25 || Rand() > 60)
+                return;
+
+            drainManaTimer = 1000;
+
+            //1 case: feared mana pot running around
+            Unit* drainTarget = FindDrainTarget(CalcSpellMaxRange(DRAIN_MANA_1));
+
+            if (!drainTarget)
+            {
+                Unit* u = me->GetVictim();
+                if (u && u->GetPowerType() == POWER_MANA && u->GetMaxPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) &&
+                    GetManaPCT(u) >= 15 && me->GetDistance(u) < CalcSpellMaxRange(DRAIN_MANA_1))
+                    drainTarget = u;
+            }
+
+            if (drainTarget && doCast(drainTarget, GetSpell(DRAIN_MANA_1)))
+                return;
+        }
+
+        void CheckWard(uint32 diff)
+        {
+            if (!canShadowWard || (!me->IsInCombat() && !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                !IsSpellReady(SHADOW_WARD_1, diff) || IsCasting())
+                return;
+
+            if (doCast(me, GetSpell(SHADOW_WARD_1)))
+                return;
+        }
+
+        void CheckSoulShatter(uint32 diff)
+        {
+            if (!IsSpellReady(SOULSHATTER_1, diff) || me->getAttackers().empty() || Rand() < 80)
+                return;
+
+            Unit* u = *(me->getAttackers().begin());
+            if (u->GetThreatManager().GetThreatListSize() < 3 || u->GetThreatManager().GetThreat(me) < 100.f)
+                return;
+
+            if (doCast(me, GetSpell(SOULSHATTER_1)))
+                return;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Rand() > 25)
+                return;
+
+            bool busyCasting = me->IsNonMeleeSpellCast(true,true,true);
+
+            //Fear
+            if (!busyCasting && IsSpellReady(FEAR_1, diff))
+            {
+                Unit* u = FindCastingTarget(CalcSpellMaxRange(FEAR_1), 0, FEAR_1);
+                if (u && doCast(u, GetSpell(FEAR_1)))
+                    return;
+            }
+            //Howl of Terror (only instant cast)
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                !busyCasting && me->GetLevel() >= 45 && IsSpellReady(HOWL_OF_TERROR_1, diff))
+            {
+                Unit* u = FindCastingTarget(8, 0, FEAR_1); //same immunity
+                if (u && doCast(u, GetSpell(HOWL_OF_TERROR_1)))
+                    return;
+            }
+            //Shadowfury
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(SHADOWFURY_1, diff))
+            {
+                if (Unit* u = FindCastingTarget(CalcSpellMaxRange(SHADOWFURY_1), 0, SHADOWFURY_1))
+                {
+                    if (busyCasting)
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(u, GetSpell(SHADOWFURY_1)))
+                        return;
+                }
+            }
+             //Death Coil
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(DEATH_COIL_1, diff))
+            {
+                if (Unit* u = FindCastingTarget(CalcSpellMaxRange(DEATH_COIL_1), 0, DEATH_COIL_1))
+                {
+                    if (busyCasting)
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+        }
+
+        void DoDefend(uint32 diff)
+        {
+            if (GC_Timer > diff || !me->IsInCombat() || Rand() > 120)
+                return;
+
+            Unit::AttackerSet const& m_attackers = master->getAttackers();
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            bool needFearM = !IAmFree() && !m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75);
+
+            //HOWL
+            //fear master's attackers
+            if (IsSpellReady(HOWL_OF_TERROR_1, diff))
+            {
+                if (needFearM)
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (CCed(*iter, true)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance(*iter) > 9) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(HOWL_OF_TERROR_1)))
+                        return;
+                }
+                // Defend myself
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if (CCed(*iter, true)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance(*iter) > 9) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(HOWL_OF_TERROR_1)))
+                        return;
+                }
+            }
+            //COIL
+            if (HasRole(BOT_ROLE_DPS) && IsSpellReady(DEATH_COIL_1, diff))
+            {
+                Unit* u = needFearM ? *(m_attackers.begin()) : nullptr;
+                if (u && u->GetMaxHealth() > master->GetMaxHealth() * 2 &&
+                    u->GetDistance(me) < 30)
+                {
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+                u = !b_attackers.empty() ? *(b_attackers.begin()) : nullptr;
+                if (u && u->GetMaxHealth() > me->GetMaxHealth() * 2 && u->GetDistance(me) < 8)
+                {
+                    if (doCast(u, GetSpell(DEATH_COIL_1)))
+                        return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 /*diff*/) override
+        {
+            if (target->GetTypeId() != TYPEID_PLAYER) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (GetSpell(UNENDING_BREATH_1) && target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) &&
+                !target->HasAuraType(SPELL_AURA_WATER_BREATHING))
+            {
+                if (doCast(target, GetSpell(UNENDING_BREATH_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            //pet is killed or unreachable
+            if (GC_Timer <= diff && !me->IsInCombat() && !me->IsMounted() && !me->GetVictim() && !IsCasting() && Rand() < 25 &&
+                (!botPet || me->GetDistance2d(botPet) > sWorld->GetMaxVisibleDistanceOnContinents()))
+                SummonBotPet();
+
+            //Hellfire interrupt
+            Spell const* spell = me->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+            if (spell && spell->GetSpellInfo()->GetFirstRankSpell()->Id == HELLFIRE_1 &&
+                ((!IAmFree() && !master->GetBotMgr()->IsPartyInCombat()) || GetHealthPCT(me) < 25))
+                me->InterruptSpell(CURRENT_CHANNELED_SPELL);
+            else
+            {
+                spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+                if (spell)
+                {
+                    //Fear interrupt
+                    if (spell->GetSpellInfo()->GetFirstRankSpell()->Id == FEAR_1 && spell->m_targets.GetUnitTarget() &&
+                        spell->m_targets.GetUnitTarget()->HasAuraType(SPELL_AURA_MOD_FEAR))
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    //Banish interrupt
+                    else if (spell->GetSpellInfo()->GetFirstRankSpell()->Id == BANISH_1 && spell->m_targets.GetUnitTarget())
+                    {
+                        if (AuraEffect const* bani = spell->m_targets.GetUnitTarget()->GetAuraEffect(SPELL_AURA_SCHOOL_IMMUNITY, SPELLFAMILY_WARLOCK, 0x0, 0x8000000, 0x0))
+                        {
+                            //Already banished
+                            //check spell cast time
+                            if (bani->GetBase()->GetDuration() > bani->GetBase()->GetMaxDuration() - 1500)
+                                me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                        }
+                        else if (!spell->m_targets.GetUnitTarget()->getAttackers().empty())
+                            me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    }
+                    //Soulstone resurrection interrupt
+                    else if (spell->GetSpellInfo()->SpellVisual[0] == 99 && spell->m_targets.GetUnitTarget() &&
+                        spell->m_targets.GetUnitTarget()->GetDummyAuraEffect(SPELLFAMILY_GENERIC, 92, 0))
+                        me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                }
+            }
+
+            if (hasHealthstone && healthstoneTimer <= diff &&
+                /*GetSpell(CREATE_HEALTHSTONE_1) && */!IsCasting() && GetHealthPCT(me) < 65)
+            {
+                uint32 healthStone = InitSpell(me, CREATE_HEALTHSTONE_1);
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(healthStone);
+                //ASSERT(spellInfo);
+                uint32 rank = spellInfo->GetRank();
+                //ASSERT(rank >= 1 && rank <= 8);
+                spellInfo = sSpellMgr->GetSpellInfo(_healthStoneSpells[rank - 1]);
+                ASSERT(spellInfo);
+                int32 healing = spellInfo->_effects[0].BasePoints;
+                //Glyph of Healthstone
+                if (me->GetLevel() >= 15)
+                    healing = int32(float(healing) * 1.3f);
+                CastSpellExtraArgs args(true);
+                args.AddSpellBP0(healing);
+                me->CastSpell(me, _healthStoneSpells[rank - 1], args);
+                healthstoneTimer = 120000; //2 min
+                hasHealthstone = false;
+                return;
+            }
+            else if (IsPotionReady() && GetHealthPCT(me) < 50)
+            {
+                DrinkPotion(false);
+            }
+
+            if (IsSpellReady(DARK_PACT_1, diff) && !IsCasting() && botPet && botPet->GetPower(POWER_MANA) >= 300 &&
+                GetManaPCT(me) < 20)
+            {
+                if (doCast(me, GetSpell(DARK_PACT_1)))
+                    return;
+            }
+            else if (IsSpellReady(LIFE_TAP_1, diff) && !IsCasting() && GetHealthPCT(me) > (me->IsInCombat() ? 30 : 15) &&
+                GetManaPCT(me) < 15 && Rand() < 50)
+            {
+                //it is possible that CheckCast will return SPELL_FAILED_NO_POWER if not enough hp
+                if (doCast(me, GetSpell(LIFE_TAP_1)))
+                    return;
+            }
+            else if (IsPotionReady() && GetManaPCT(me) < 10)
+            {
+                DrinkPotion(true);
+            }
+
+            CheckRacials(diff);
+
+            CheckSoulShatter(diff);
+            DoDefend(diff);
+            CheckFear(diff);
+            CheckWard(diff);
+
+            BuffAndHealGroup(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            Counter(diff);
+
+            CheckBanish(diff);
+            CheckUnBanish(diff);
+
+            CheckDrainMana(diff);
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            MoveBehind(mytar);
+
+            if (GC_Timer > diff)
+                return;
+
+            auto [can_do_shadow, can_do_fire] = CanAffectVictimBools(mytar, SPELL_SCHOOL_SHADOW, SPELL_SCHOOL_FIRE);
+
+            float dist = me->GetDistance(mytar);
+
+            //spell reflections
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && can_do_shadow && dist < CalcSpellMaxRange(CURSE_OF_THE_ELEMENTS_1) &&
+                CanRemoveReflectSpells(mytar, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(mytar, CURSE_OF_THE_ELEMENTS_1))
+                return;
+            else if (IsSpellReady(CURSE_OF_WEAKNESS_1, diff) && can_do_shadow && dist < CalcSpellMaxRange(CURSE_OF_WEAKNESS_1) &&
+                CanRemoveReflectSpells(mytar, CURSE_OF_WEAKNESS_1) &&
+                doCast(mytar, CURSE_OF_WEAKNESS_1))
+                return;
+
+            //Offensive heal (Death Coil)
+            if (IsSpellReady(DEATH_COIL_1, diff) && can_do_shadow && HasRole(BOT_ROLE_DPS) && dist < CalcSpellMaxRange(DEATH_COIL_1) &&
+                GetHealthPCT(me) < 35)
+            {
+                //if (me->IsNonMeleeSpellCast(true))
+                //    me->InterruptNonMeleeSpells(true);
+                if (doCast(mytar, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //Life Tap / Dark Pact for Glyph of Life Tap
+            if (lifeTapCheckTimer <= diff && HasRole(BOT_ROLE_DPS) && Rand() < 75)
+            {
+                lifeTapCheckTimer = 10000;
+                if (me->GetLevel() >= 15 && !me->GetAuraEffect(SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT, SPELLFAMILY_WARLOCK, 208, 0))
+                {
+                    //doesn't work: wrong spell proc entry 10.12.2020
+                    //if (IsSpellReady(DARK_PACT_1, diff) && botPet && GetManaPCT(me) > 70)
+                    //{
+                    //    if (doCast(me, GetSpell(DARK_PACT_1)))
+                    //        return;
+                    //}
+                    //else
+                    if (IsSpellReady(LIFE_TAP_1, diff) && GetHealthPCT(me) > 30)
+                    {
+                        if (doCast(me, GetSpell(LIFE_TAP_1)))
+                            return;
+                    }
+                }
+            }
+            //Shadowfury
+            if (IsSpellReady(SHADOWFURY_1, diff) && can_do_shadow && HasRole(BOT_ROLE_DPS) && !CCed(mytar, true) && Rand() < 55)
+            {
+                if (FindSplashTarget(CalcSpellMaxRange(SHADOWFURY_1)) &&
+                    doCast(mytar, GetSpell(SHADOWFURY_1)))
+                    return;
+            }
+            //Hellfire
+            if (IsSpellReady(HELLFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && !IAmFree() && !JumpingOrFalling() &&
+                GetHealthPCT(me) > 90 && Rand() < 25)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 12.f, 0);
+                for (std::list<Unit*>::iterator itr = targets.begin(); itr != targets.end();)
+                {
+                    Unit* u = *itr;
+                    bool erase = false;
+                    if (u->isMoving())
+                    {
+                        if (me->GetDistance(u) > 10.f && !u->HasInArc(float(M_PI)/2, me))
+                            erase = true;
+                    }
+                    else if (me->GetDistance(u) > 9.5f)
+                        erase = true;
+
+                    if (erase)
+                    {
+                        targets.erase(itr++);
+                        continue;
+                    }
+                    ++itr;
+                }
+                if (targets.size() >= 4 && doCast(me, GetSpell(HELLFIRE_1)))
+                    return;
+            }
+            //Rain of Fire
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && HasRole(BOT_ROLE_DPS) && !JumpingOrFalling() && Rand() < 45 &&
+                (GetSpec() != BOT_SPEC_WARLOCK_AFFLICTION || !GetSpell(SEED_OF_CORRUPTION_1)))
+            {
+                if (Unit* raintarget = FindAOETarget(CalcSpellMaxRange(RAIN_OF_FIRE_1)))
+                {
+                    if (doCast(raintarget, GetSpell(RAIN_OF_FIRE_1)))
+                        return;
+                }
+            }
+            //Searing Pain (PvP)
+            if (longCasted && IsSpellReady(SEARING_PAIN_1, diff) && can_do_fire && HasRole(BOT_ROLE_DPS) &&
+                GetSpec() != BOT_SPEC_WARLOCK_AFFLICTION &&
+                mytar->GetTypeId() == TYPEID_PLAYER && Rand() < 35 && dist < CalcSpellMaxRange(SEARING_PAIN_1))
+            {
+                if (doCast(mytar, GetSpell(SEARING_PAIN_1)))
+                    return;
+            }
+            //Shadowflame
+            if (longCasted && IsSpellReady(SHADOWFLAME_1, diff) && can_do_shadow && HasRole(BOT_ROLE_DPS) && Rand() < 65)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsInConeList(targets, 8); //radius 10 yd
+                if (!targets.empty() && doCast(me, GetSpell(SHADOWFLAME_1)))
+                    return;
+            }
+            //Curse, checking affliction range
+            if (curseCheckTimer <= diff && can_do_shadow && GetSpellCooldown(CURSE_OF_WEAKNESS_1) <= diff && Rand() < 85 &&
+                dist < CalcSpellMaxRange(CURSE_OF_WEAKNESS_1) && mytar->GetHealth() > me->GetMaxHealth() / 4)
+            {
+                curseCheckTimer = 2500;
+                uint32 curses = _getCursesMask(mytar);
+                if (!(curses & CURSE_MASK_MY_CURSE_ANY))
+                {
+                    if (!(curses & CURSE_MASK_ELEMENTS) && GetSpell(CURSE_OF_THE_ELEMENTS_1) && !IAmFree() &&
+                        (GetSpec() != BOT_SPEC_WARLOCK_AFFLICTION || Rand() < 33) &&
+                        master->GetGroup() && master->GetGroup()->GetMembersCount() > 2)
+                    {
+                        if (doCast(mytar, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
+                            return;
+                    }
+                    if (!(curses & CURSE_MASK_MY_AGONY) && GetSpell(CURSE_OF_AGONY_1) && HasRole(BOT_ROLE_DPS) &&
+                        mytar->GetHealth() > me->GetMaxHealth() / 4 * (1 + mytar->getAttackers().size()))
+                    {
+                        if (doCast(mytar, GetSpell(CURSE_OF_AGONY_1)))
+                            return;
+                    }
+                    if (!(curses & CURSE_MASK_TONGUES) && GetSpell(CURSE_OF_TONGUES_1) && mytar->GetHealth() > me->GetMaxHealth() / 2 &&
+                        mytar->IsNonMeleeSpellCast(false, false, true))
+                    {
+                        if (doCast(mytar, GetSpell(CURSE_OF_TONGUES_1)))
+                            return;
+                    }
+                    if (!(curses & CURSE_MASK_EXHAUSTION) && GetSpell(CURSE_OF_EXHAUSTION_1) && !CCed(mytar, true) &&
+                        mytar->IsControlledByPlayer() && !mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+                    {
+                        if (doCast(mytar, GetSpell(CURSE_OF_EXHAUSTION_1)))
+                            return;
+                    }
+                    if (!(curses & CURSE_MASK_WEAKNESS) && GetSpell(CURSE_OF_WEAKNESS_1) && me->GetMap()->IsDungeon() &&
+                        mytar->GetMaxHealth() > me->GetMaxHealth() * 2)
+                    {
+                        if (doCast(mytar, GetSpell(CURSE_OF_WEAKNESS_1)))
+                            return;
+                    }
+                }
+            }
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            //Chaos Bolt
+            if (IsSpellReady(CHAOS_BOLT_1, diff) && can_do_fire && dist < CalcSpellMaxRange(CHAOS_BOLT_1))
+            {
+                if (doCast(mytar, GetSpell(CHAOS_BOLT_1)))
+                    return;
+            }
+            //Soul Fire 1
+            if (IsSpellReady(SOUL_FIRE_1, diff) && can_do_fire && Rand() < 150 && dist < CalcSpellMaxRange(SOUL_FIRE_1) &&
+                (mytar->IsPolymorphed() || me->HasAuraTypeWithAffectMask(SPELL_AURA_NO_REAGENT_USE, sSpellMgr->GetSpellInfo(SOUL_FIRE_1))))
+            {
+                if (doCast(mytar, GetSpell(SOUL_FIRE_1)))
+                    return;
+            }
+            //Conflagrate (always glyphed, does not consume dot)
+            if (longCasted && IsSpellReady(CONFLAGRATE_1, diff) && can_do_fire && dist < CalcSpellMaxRange(CONFLAGRATE_1) &&
+                mytar->HasAuraState(AURA_STATE_CONFLAGRATE) &&
+                mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(CONFLAGRATE_1)))
+                    return;
+            }
+            //Shadowburn
+            if (longCasted && IsSpellReady(SHADOWBURN_1, diff) && can_do_shadow && dist < CalcSpellMaxRange(SHADOWBURN_1) &&
+                mytar->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+            {
+                if (doCast(mytar, GetSpell(SHADOWBURN_1)))
+                    return;
+            }
+            //Immolate
+            if (IsSpellReady(IMMOLATE_1, diff) && can_do_fire && Rand() < 85 && dist < CalcSpellMaxRange(IMMOLATE_1) &&
+                (GetSpec() != BOT_SPEC_WARLOCK_AFFLICTION || !GetSpell(UNSTABLE_AFFLICTION_1)) &&
+                (GetSpell(CONFLAGRATE_1) || mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size())) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(IMMOLATE_1)))
+                    return;
+            }
+            //Haunt
+            if (IsSpellReady(HAUNT_1, diff) && can_do_shadow && Rand() < 125 && dist < CalcSpellMaxRange(HAUNT_1) &&
+                mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size()) &&
+                !mytar->GetAuraEffect(SPELL_AURA_MOD_DAMAGE_FROM_CASTER, SPELLFAMILY_WARLOCK, 0x0, 0x40000, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(HAUNT_1)))
+                    return;
+            }
+            //Unstable Affliction
+            if (IsSpellReady(UNSTABLE_AFFLICTION_1, diff) && can_do_shadow && Rand() < 115 && dist < CalcSpellMaxRange(UNSTABLE_AFFLICTION_1) &&
+                mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size()) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x100, 0x0, me->GetGUID()))
+            {
+                if (doCast(mytar, GetSpell(UNSTABLE_AFFLICTION_1)))
+                    return;
+            }
+            //Seed of Corruption
+            if (IsSpellReady(SEED_OF_CORRUPTION_1, diff) && Rand() < 85)
+            {
+                Unit* target = FindAOETarget(CalcSpellMaxRange(SEED_OF_CORRUPTION_1));
+                if (target && !target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x10, 0x0, me->GetGUID()))
+                {
+                    if (doCast(target, GetSpell(SEED_OF_CORRUPTION_1)))
+                        return;
+                }
+
+                SetSpellCooldown(SEED_OF_CORRUPTION_1, 1000); //fail
+            }
+            //Corruption
+            if (IsSpellReady(CORRUPTION_1, diff) && can_do_shadow && Rand() < 90 && dist < CalcSpellMaxRange(CORRUPTION_1) &&
+                mytar->GetHealth() > me->GetMaxHealth()/4 * (1 + mytar->getAttackers().size()) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x2, 0x0, 0x0, me->GetGUID()) &&//corruption
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x0, 0x10, 0x0, me->GetGUID()))//seed of corruption
+            {
+                if (doCast(mytar, GetSpell(CORRUPTION_1)))
+                    return;
+            }
+            //Drain Soul: only if can quad damage
+            if (IsSpellReady(DRAIN_SOUL_1, diff) && can_do_shadow && mytar->GetTypeId() == TYPEID_UNIT &&
+                Rand() < (50 + 85 * me->GetMap()->IsDungeon()) && GetHealthPCT(mytar) < 25 &&
+                mytar->GetHealth() > me->GetMaxHealth() / 2 && dist < CalcSpellMaxRange(DRAIN_SOUL_1))
+            {
+                if (doCast(mytar, GetSpell(DRAIN_SOUL_1)))
+                    return;
+            }
+            //Soul Fire (conditional)
+            if (IsSpellReady(SOUL_FIRE_1, diff) && can_do_fire && Rand() < 90 && dist < CalcSpellMaxRange(SOUL_FIRE_1) &&
+                mytar->GetHealth() > me->GetMaxHealth()/8 * (1 + mytar->getAttackers().size()) && me->HasAura(BACKDRAFT_BUFF))
+            {
+                if (doCast(mytar, GetSpell(SOUL_FIRE_1)))
+                    return;
+            }
+            //Main: Shadow Bolt, Incinerate, Searing Pain (tank), checking destruction range
+            if (dist < CalcSpellMaxRange(SHADOW_BOLT_1))
+            {
+                uint32 boltinerate =
+                    IsTank() && GetSpell(SEARING_PAIN_1) ? SEARING_PAIN_1 :
+                    GetSpell(SHADOW_BOLT_1) && GetSpec() == BOT_SPEC_WARLOCK_AFFLICTION ? SHADOW_BOLT_1 :
+                    GetSpell(INCINERATE_1) && mytar->HasAuraState(AURA_STATE_CONFLAGRATE) ?
+                    //mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0) &&
+                    //mytar->GetAuraEffect(SPELL_AURA_MOD_ATTACKER_SPELL_CRIT_CHANCE, SPELLFAMILY_WARLOCK, 213, 0) &&
+                    //(me->GetMap()->IsRaid() || !me->HasAura(SHADOW_TRANCE_BUFF)) ?
+                    INCINERATE_1 : SHADOW_BOLT_1;
+
+                bool can_cast_boltinerate;
+                switch (boltinerate)
+                {
+                    case SEARING_PAIN_1: case INCINERATE_1:
+                        can_cast_boltinerate = can_do_fire;
+                        break;
+                    case SHADOW_BOLT_1:
+                        can_cast_boltinerate = can_do_shadow;
+                        break;
+                    default:
+                        can_cast_boltinerate = true;
+                        break;
+                }
+
+                if (boltinerate && can_cast_boltinerate && doCast(mytar, GetSpell(boltinerate)))
+                    return;
+            }
+
+            if (Spell const* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id == SHOOT_WAND && shot->m_targets.GetUnitTarget() != mytar)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+            else if (IsSpellReady(SHOOT_WAND, diff) && me->GetDistance(mytar) < 30 && GetEquips(BOT_SLOT_RANGED) &&
+                doCast(mytar, SHOOT_WAND))
+                return;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const override
+        {
+            //victim can be NULL
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Molten Core part 2.2: 15% additional critical chance for Soul Fire
+            if (lvl >= 35 && baseId == SOUL_FIRE_1)
+            {
+                moltencore = me->HasAura(MOLTEN_CORE_BUFF);
+                if (moltencore)
+                    crit_chance += 15.f;
+            }
+
+            //Devastation: 5% additional critical chance for Destruction spells
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 30 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x3E5) || (spellInfo->SpellFamilyFlags[1] & 0x8310C0)))
+                crit_chance += 5.f;
+            //Fire and Brimstone part 2: 25% additional critical chance for Conflagrate
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 55 && baseId == CONFLAGRATE_1)
+                crit_chance += 25.f;
+            //Malediction part 2: 9% additional critical chance for Corruption and Unstable Affliction
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 45 && (baseId == CORRUPTION_1 || baseId == UNSTABLE_AFFLICTION_1))
+                crit_chance += 9.f;
+            //Glyph of Shadowburn: 20% additional critical chance for Shadowburn on targets 35% hp and below
+            if (lvl >= 20 && baseId == SHADOWBURN_1 && victim && victim->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT))
+                crit_chance += 20.f;
+            //Improved Corruption part 2: 5% additional critical chance for Seed of Corruption
+            if (lvl >= 10 && (baseId == SEED_OF_CORRUPTION_1 || baseId == SEED_OF_CORRUPTION_FINAL_DAMAGE_1))
+                crit_chance += 5.f;
+            //Improved Searing Pain: 10% additional critical chance for Searing Pain
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 25 && baseId == SEARING_PAIN_1)
+                crit_chance += 10.f;
+
+            //Master Demonologist part 1.2 (me): 5% additional critical chance for Fire spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_IMP && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE))
+                crit_chance += 5.f;
+            //Master Demonologist part 3.2 (me): 5% additional critical chance for Shadow spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_SUCCUBUS && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                crit_chance += 5.f;
+
+            //Warlock T84P Bonus (64932): 5% additional critical chance for Shadow Bolt and Incinerate
+            if (lvl >= 80 && (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1))
+                crit_chance += 5.f;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            //2) apply bonus damage mods
+            float pctbonus = 1.0f; //Special condition
+            if (iscrit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Ruin: 50% additional crit damage bonus for Destruction spells
+                if (lvl >= 20 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                    ((spellInfo->SpellFamilyFlags[0] & 0x13E5) || (spellInfo->SpellFamilyFlags[1] & 0xC310C0)))
+                    pctbonus += 0.333f;
+                //Pandemic part 2,3: crit damage for periodics and haunt
+                if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                    lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                    ((spellInfo->SpellFamilyFlags[0] & 0x2) || (spellInfo->SpellFamilyFlags[1] & 0x40100)))
+                    pctbonus += 0.333f;
+                //Glyph of Searing Pain: 20% additional crit damage bonus for Searing Pain
+                if (lvl >= 18 && baseId == SEARING_PAIN_1)
+                    pctbonus += 0.133f;
+            }
+            //Improved Shadow Bolt and Incinerate (38393): 6% bonus damage for Shadow bolt and Incinerate
+            if (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1)
+                pctbonus += 0.06f;
+            //Glyph of Incinerate: 5% bonus damage for Incinerate
+            if (baseId == INCINERATE_1)
+                pctbonus += 0.05f;
+            //Improved Immolate: 30% bonus damage for Immolate
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 30 && baseId == IMMOLATE_1)
+                pctbonus += 0.3f;
+            //EmberStorm part 1: 15% bonus damage for Fire spells
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 35 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x364) || (spellInfo->SpellFamilyFlags[1] & 0x8200C0)))
+                pctbonus += 0.15f;
+            //Fire and Brimstone part 1: 10% bonus damage for Incinerate and Chaos Bolt
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 55 && (baseId == INCINERATE_1 || baseId == CHAOS_BOLT_1) &&
+                damageinfo.target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARLOCK, 0x4, 0x0, 0x0, me->GetGUID()))
+                pctbonus += 0.1f;
+            //Molten Core part 1: 18% bonus damage for Incinerate and Soul Fire
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 35 && (baseId == INCINERATE_1 || baseId == SOUL_FIRE_1))
+            {
+                if (me->HasAura(MOLTEN_CORE_BUFF))
+                    pctbonus += 0.18f;
+            }
+            //Improved Corruption part 1: 10% bonus damage for Corruption
+            if (lvl >= 10 && baseId == CORRUPTION_1)
+                pctbonus += 0.1f;
+            //Corruption (28829): 12% bonus damage for Corruption
+            if (lvl >= 40 && baseId == CORRUPTION_1)
+                pctbonus += 0.12f;
+            //Malediction part 1: 3% bonus damage for All spells
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) && lvl >= 45)
+                pctbonus += 0.03f;
+            //Death's Embrace part 2: 12% bonus damage for Shadow spells on targets below 35 pct health
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 50 && damageinfo.target->HasAuraState(AURA_STATE_HEALTHLESS_35_PERCENT) &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x8248B) || (spellInfo->SpellFamilyFlags[1] & 0x59913)))
+                pctbonus += 0.12f;
+
+            //Empowered Corruption: 36% spellpower bonus for Corruption
+            if (lvl >= 25 && baseId == CORRUPTION_1)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.36f * me->CalculateDefaultCoefficient(spellInfo, DOT) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Shadow and Flame: 20% spellpower bonus for Shadow Bolt, Shadowburn, Chaos Bolt and Incineration
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 45 &&
+                (baseId == SHADOW_BOLT_1 || baseId == CHAOS_BOLT_1 || baseId == SHADOWBURN_1 || baseId == INCINERATE_1))
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+            //Everlasting Affliction part 1: 5% spellpower bonus for Corruption and Unstable Affliction
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 55 && (baseId == CORRUPTION_1 || baseId == UNSTABLE_AFFLICTION_1))
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * 0.05f * me->CalculateDefaultCoefficient(spellInfo, DOT) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            //Firestone/Spellstone: 1% bonus damage for all spells
+            if (lvl >= 28)
+                pctbonus += 0.01f;
+
+            //Improved Shadow Bolt part 1: 10% bonus damage for Shadow Bolt
+            if (lvl >= 10 && baseId == SHADOW_BOLT_1)
+                pctbonus += 0.1f;
+            //Improved Corruption and Immolate (Updated) (61992): 5% bonus damage for Corruption and Immolate
+            if (lvl >= 10 && (baseId == CORRUPTION_1 || baseId == IMMOLATE_1))
+                pctbonus += 0.05f;
+            //Improved Curse of Agony: 10% bonus damage for Curse of Agony
+            if (lvl >= 10 && baseId == CURSE_OF_AGONY_1)
+                pctbonus += 0.1f;
+            //Shadow Mastery: 15% bonus damage for Shadow Spells
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 35 && ((spellInfo->SpellFamilyFlags[0] & 0x80091) || spellInfo->SpellFamilyFlags[1] & 0x451910))
+                pctbonus += 0.15f;
+            //Contagion: 5% bonus damage for Curse of Agony, Corruption and Seed of Corruption
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) &&
+                lvl >= 40 && (baseId == CORRUPTION_1 || baseId == SEED_OF_CORRUPTION_1 ||
+                baseId == SEED_OF_CORRUPTION_FINAL_DAMAGE_1 || baseId == CURSE_OF_AGONY_1))
+                pctbonus += 0.05f;
+
+            //Warlock T82P Bonus (64931): 20/10% bonus damage for Unstable Affliction and Immolate
+            if (lvl >= 80 && baseId == UNSTABLE_AFFLICTION_1)
+                pctbonus += 0.2f;
+            if (lvl >= 80 && baseId == IMMOLATE_1)
+                pctbonus += 0.1f;
+            //Warlock T94P Bonus (67231): 10% bonus damage for Immolate, Corruption and Unstable Affliction
+            if (lvl >= 80 && (baseId == IMMOLATE_1 || baseId == CORRUPTION_1 || baseId == UNSTABLE_AFFLICTION_1))
+                pctbonus += 0.2f;
+
+            //Glyph of Immolate: 10% bonus damage for Immolate
+            if (lvl >= 15 && baseId == IMMOLATE_1)
+                pctbonus += 0.1f;
+
+            //Demonic Pact part 1: 10% bonus damage for all spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) && lvl >= 55)
+                pctbonus *= 1.1f;
+            //Master Demonologist part 1.1 (me): 5% bonus damage for Fire spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_IMP && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_FIRE))
+                pctbonus *= 1.05f;
+            //Master Demonologist part 3.1 (me): 5% bonus damage for Shadow spells
+            if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) &&
+                lvl >= 35 && botPet && myPetType == BOT_PET_SUCCUBUS && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus *= 1.05f;
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 0.0f;
+
+            //Glyph of Siphon Life: 25% bonus healing for Siphon Life effect (50% for bots)
+            if (baseId == SIPHON_LIFE_HEAL)
+                pctbonus += 0.5f;
+            //Improved Death Coil (30052): 30% bonus healing for Death Coil
+            if (lvl >= 60 && baseId == DEATH_COIL_1)
+                pctbonus += 0.3f;
+
+            heal = heal * (1.0f + pctbonus);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Doomcaller Reduced Shadow Bolt Cost (26117): -15% mana cost for Shadow Bolt
+            if (baseId == SHADOW_BOLT_1)
+                pctbonus += 0.15f;
+            //Glyph of Shadow Bolt: -10% mana cost for Shadow Bolt
+            if (lvl >= 15 && baseId == SHADOW_BOLT_1)
+                pctbonus += 0.1f;
+            //Cataclysm: -10% mana cost for Destruction spells
+            if (lvl >= 15 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x3E5) || (spellInfo->SpellFamilyFlags[1] & 0x8310C0)))
+                pctbonus += 0.1f;
+            //Suppression: -6% mana cost for Affliction spells
+            if (lvl >= 10 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x814CC41A) || (spellInfo->SpellFamilyFlags[1] & 0x248F1B)))
+                pctbonus += 0.06f;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus));
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //100% mods
+            //Backlash: -100% cast time for Shadow Bolt or Incinerate
+            if (lvl >= 15 && (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1))
+            {
+                backlash = me->HasAura(BACKLASH_BUFF);
+                shadowtrance = (baseId == SHADOW_BOLT_1 && me->HasAura(SHADOW_TRANCE_BUFF));
+                if (backlash || shadowtrance)
+                    timebonus += casttime;
+            }
+            //Improved Howl of Terror: -1.5sec (-100%) cast time for Howl of Terror
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) && lvl >= 45 && baseId == HOWL_OF_TERROR_1)
+                timebonus += casttime;
+            //Chaotic Mind (custom)
+            if (baseId == SOUL_FIRE_1)
+            {
+                chaoticmind = me->HasAura(CHAOTIC_MIND_BUFF);
+                if (chaoticmind)
+                    timebonus += casttime;
+            }
+
+            //pct mods
+            //BackDraft part 1: -30% cast time for Destruction spells
+            if (lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)))
+            {
+                //skip soul fire insta cast
+                backdraft = me->HasAura(BACKDRAFT_BUFF) && !(chaoticmind && baseId == SOUL_FIRE_1);
+                if (backdraft)
+                    pctbonus += 0.3f;
+            }
+            //Molten Core part 2.1: -30% cast time for Incinerate
+            if (lvl >= 35 && baseId == INCINERATE_1)
+            {
+                moltencore = me->HasAura(MOLTEN_CORE_BUFF);
+                if (moltencore)
+                    pctbonus += 0.3f;
+            }
+            //Decimation: -40% cast time for Soul Fire
+            if (baseId == SOUL_FIRE_1 && me->HasAura(DECIMATION_BUFF))
+                pctbonus += 0.4f;
+
+            //flat mods
+            //Bane: -0.5 sec cast time for Shadow Bolt, Immolate and Chaos Bolt, -2 sec cast for Soul Fire
+            if (lvl >= 10)
+            {
+                if (baseId == SHADOW_BOLT_1 || baseId == IMMOLATE_1 || baseId == CHAOS_BOLT_1)
+                    timebonus += 500;
+                else if (baseId == SOUL_FIRE_1)
+                    timebonus += 2000;
+            }
+            //EmberStorm part 2: -0.25 sec cast time for Incinerate
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 35 && baseId == INCINERATE_1)
+                timebonus += 250;
+            //Glyph of Unstable Affliction: -0.2 sec cast time for Unstable Affliction
+            if (lvl >= 50 && baseId == UNSTABLE_AFFLICTION_1)
+                timebonus += 200;
+            //Fear Cast Time Reduction (23047): -0.2 sec cast time for Fear
+            if (baseId == FEAR_1)
+                timebonus += 200;
+
+            casttime = std::max<int32>((float(casttime) * (1.0f - pctbonus)) - timebonus, 0);
+
+            instaCast = (casttime <= 500); //triggered GCD is too long
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            //if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+            //    pctbonus += 0.07f;
+
+            //flat mods
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Glyph of Chaos Bolt: -2 sec cooldown for Chaos Bolt
+            if (lvl >= 60 && baseId == CHAOS_BOLT_1)
+                timebonus += 2000;
+            //Improved Death Coil (24487): -15% cooldown for Death Coil (30 sec for bots)
+            if (baseId == DEATH_COIL_1)
+                timebonus += 30000;
+            //Glyph of Howl of Terror: -8 sec cooldown for Howl of Terror
+            if (lvl >= 45 && baseId == HOWL_OF_TERROR_1)
+                timebonus += 8000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //BackDraft: -30% global cooldown for Destruction spells
+            if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) &&
+                lvl >= 50 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)) &&
+                me->HasAura(BACKDRAFT_BUFF))
+                pctbonus += 0.3f;
+
+            //flat mods
+            //Amplify Curse: -0.5 sec global cooldown for Curses
+            if (lvl >= 20 && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x408400) || (spellInfo->SpellFamilyFlags[1] & 0x200202) ||
+                (spellInfo->SpellFamilyFlags[2] & 0x800)))
+                timebonus += 500.f;
+
+            //Fear Cast Time Reduction (23047): -0.2 sec global cooldown for Fear
+            if (baseId == FEAR_1)
+                timebonus += 200;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+
+            //flat mods
+            //Improved Rain of Fire / Hellfire
+            if (lvl >= 40 && (spellInfo->SpellFamilyFlags[0] & 0x60))
+                flatbonus += 2.f;
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Grim Reach: +20% range for Affliction Spells
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x8048C41A) || (spellInfo->SpellFamilyFlags[1] & 0x40713)))
+                pctbonus += 0.2f;
+            //Destructive Reach: +20% range for Destruction Spells
+            if (lvl >= 25 && ((spellInfo->SpellFamilyFlags[0] & 0x13A5) || (spellInfo->SpellFamilyFlags[1] & 0x8210C0)))
+                pctbonus += 0.2f;
+
+            //flat mods
+            //Glyph of Curse of Exhaustion: +5 yd range for Curse of Exhaustion
+            if (lvl >= 70 && baseId == CURSE_OF_EXHAUSTION_1)
+                flatbonus += 5.f;
+
+            maxrange = maxrange * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            //Instacast buffs handling
+            if (baseId == SHADOW_BOLT_1)
+            {
+                if (backlash)
+                    me->RemoveAurasDueToSpell(BACKLASH_BUFF);
+                else if (shadowtrance)
+                    me->RemoveAurasDueToSpell(SHADOW_TRANCE_BUFF);
+            }
+            if (baseId == INCINERATE_1)
+            {
+                if (backlash)
+                    me->RemoveAurasDueToSpell(BACKLASH_BUFF);
+            }
+            if (chaoticmind && baseId == SOUL_FIRE_1)
+                me->RemoveAurasDueToSpell(CHAOTIC_MIND_BUFF);
+
+            //Backdraft
+            if (backdraft && spellInfo->SpellFamilyName == SPELLFAMILY_WARLOCK &&
+                ((spellInfo->SpellFamilyFlags[0] & 0x165) || (spellInfo->SpellFamilyFlags[1] & 0x310C0)))
+            {
+                if (Aura* bd = me->GetAura(BACKDRAFT_BUFF))
+                    bd->DropCharge();
+            }
+            //Molten Core
+            if (moltencore && (baseId == INCINERATE_1 || baseId == SOUL_FIRE_1))
+            {
+                if (Aura* mc = me->GetAura(MOLTEN_CORE_BUFF))
+                    mc->DropCharge();
+            }
+            //Decimation: NOT DROPPED ON CAST
+            //if (baseId == SOUL_FIRE_1)
+            //{
+            //    if (Aura* mc = me->GetAura(DECIMATION_BUFF))
+            //        mc->DropCharge();
+            //}
+            longCasted = !instaCast &&
+                (baseId == SHADOW_BOLT_1 || baseId == INCINERATE_1 || baseId == CHAOS_BOLT_1 ||
+                baseId == SOUL_FIRE_1 || baseId == HAUNT_1 || baseId == SEARING_PAIN_1); //damaging spells
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Shadow Ward helper
+            if (!canShadowWard && (spell->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW) &&
+                (spell->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) || spell->HasAura(SPELL_AURA_PERIODIC_DAMAGE)))
+                canShadowWard = true;
+
+            //Create Healthstone trigger
+            if (baseId == CREATE_HEALTHSTONE_1)
+            {
+                hasHealthstone = true;
+            }
+            //Create Soulstone trigger
+            if (baseId == CREATE_SOULSTONE_1)
+            {
+                hasSoulstone = true;
+            }
+
+            //Glyph of Soul Link: +5% increased effect
+            if (baseId == SOUL_LINK_PET)
+            {
+                if (AuraEffect* link = me->GetAuraEffect(spellId, 0))
+                    link->ChangeAmount(link->GetAmount() + 5);
+            }
+
+            //Life Tap energize
+            if (baseId == LIFE_TAP_1)
+            {
+                //level * 3 based on in-game tooltip and spellwork (BasePoints = 2000 + Level * 4,00)
+                int32 damage = spell->_effects[0].CalcValue(me);
+                int32 manaGain = damage;
+                damage += int32(me->GetLevel() * 3);
+                manaGain += 0.5f * me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);
+
+                //Life Tap (id: 28830)
+                //damage = int32(float(damage) * 0.88f);
+                //Improved Life Tap
+                if (me->GetLevel() >= 15)
+                    manaGain = int32(float(manaGain) * 1.2f);
+
+                me->ModifyHealth(-damage);
+                CastSpellExtraArgs args;
+                args.AddSpellBP0(manaGain);
+                me->CastSpell(me, LIFE_TAP_ENERGIZE, args);
+
+                //Mana Feed
+                if ((_spec == BOT_SPEC_WARLOCK_DEMONOLOGY) && me->GetLevel() >= 35 && botPet)
+                    me->EnergizeBySpell(botPet, LIFE_TAP_ENERGIZE_PET, manaGain, POWER_MANA);
+            }
+
+            //Glyph of Life Tap trigger
+            if (baseId == GLYPH_LIFE_TAP_BUFF)
+                SetShouldUpdateStats();
+
+            if (baseId == DEMON_ARMOR_1 || baseId == FEL_ARMOR_1)
+            {
+                if (Aura* armo = me->GetAura(spellId, me->GetGUID()))
+                {
+                    //Armors duration
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    armo->SetDuration(dur);
+                    armo->SetMaxDuration(dur);
+
+                    //Demonic Aegis
+                    if (lvl >= 20)
+                    {
+                        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                            if (AuraEffect* eff = armo->GetEffect(i))
+                                eff->ChangeAmount(eff->GetAmount() * 13 / 10);
+                    }
+                }
+            }
+            //Chaotic Mind (custom)
+            if (baseId == CHAOTIC_MIND)
+            {
+                if (Aura* mind = me->GetAura(spellId))
+                {
+                    uint32 dur = 30000; //30 sec
+                    mind->SetDuration(dur);
+                    mind->SetMaxDuration(dur);
+                }
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Soulstone resurrection trigger (not ranked)
+            if (spellId == SOULSTONE_RESURRECTION_1 || spellId == SOULSTONE_RESURRECTION_2 ||
+                spellId == SOULSTONE_RESURRECTION_3 || spellId == SOULSTONE_RESURRECTION_4 ||
+                spellId == SOULSTONE_RESURRECTION_5 || spellId == SOULSTONE_RESURRECTION_6 ||
+                spellId == SOULSTONE_RESURRECTION_7)
+            {
+                hasSoulstone = false;
+                //reduced for bot
+                //soulstoneTimer = 15 * MINUTE * IN_MILLISECONDS;
+                soulstoneTimer = 10 * MINUTE * IN_MILLISECONDS;
+            }
+
+            //Improved Imp part 3
+            if (lvl >= 10 && baseId == BLOOD_PACT_1 && botPet)
+            {
+                AuraEffect* pact = target->GetAuraEffect(spellId, 0, botPet->GetGUID());
+                if (pact)
+                    pact->ChangeAmount(pact->GetAmount() * 1.3f);
+            }
+
+            //Improved Felhunter part 3
+            if ((_spec == BOT_SPEC_WARLOCK_AFFLICTION) && lvl >= 35 && baseId == FEL_INTELLIGENCE_1 && botPet)
+            {
+                Aura const* feli = target->GetAura(spellId, botPet->GetGUID());
+                if (feli)
+                {
+                    for (uint8 i = EFFECT_0; i != EFFECT_2; ++i)
+                    {
+                        if (AuraEffect* effi = feli->GetEffect(i))
+                            effi->ChangeAmount(effi->GetAmount() + effi->GetAmount() / 10);
+                    }
+                }
+            }
+
+            //Glyph of Unending Breath: swim speed
+            if (/*lvl >= 15 && */baseId == UNENDING_BREATH_1)
+            {
+                AuraEffect* brea = target->GetAuraEffect(spellId, 1, me->GetGUID());
+                if (brea)
+                    brea->ChangeAmount(brea->GetAmount() + 20);
+            }
+
+            //Chaotic Mind (custom)
+            if (lvl >= 60 && target != me && GetSpec() != BOT_SPEC_WARLOCK_AFFLICTION &&
+                spell->SpellFamilyName == SPELLFAMILY_WARLOCK && !spell->IsPositive())
+            {
+                if (urand(1,100) <= 5)
+                    me->CastSpell(me, CHAOTIC_MIND, true);
+            }
+            if (baseId == IMMOLATE_1 || baseId == CORRUPTION_1)
+            {
+                if (Aura* per = target->GetAura(spellId, me->GetGUID()))
+                {
+                    //Improved Corruption and Immolate (37380): +3 sec duration for Immolate and Corruption
+                    uint32 dur = per->GetDuration() + 3000;
+                    //Molten Core: + 9 sec duration for Immolate
+                    if ((_spec == BOT_SPEC_WARLOCK_DESTRUCTION) && lvl >= 35 && baseId == IMMOLATE_1)
+                        dur += 9000;
+                    per->SetDuration(dur);
+                    per->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Death Coil: + 0.5 sec duration for Death Coil (2 sec on creatures)
+            if (baseId == DEATH_COIL_1)
+            {
+                if (Aura* dc = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = dc->GetDuration() + (target->GetTypeId() == TYPEID_PLAYER ? 500 : 2000);
+                    dc->SetDuration(dur);
+                    dc->SetMaxDuration(dur);
+                }
+            }
+            //Improved Curse of Weakness: +20% increased effect
+            if (baseId == CURSE_OF_WEAKNESS_1)
+            {
+                if (AuraEffect* weak = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                {
+                    weak->ChangeAmount(weak->GetAmount() * 12 / 10);
+                }
+            }
+            //Glyph of Haunt: +3% increased effect
+            if (lvl >= 60 && baseId == HAUNT_1)
+            {
+                if (AuraEffect* haun = target->GetAuraEffect(spellId, 2, me->GetGUID()))
+                {
+                    haun->ChangeAmount(haun->GetAmount() + 3);
+                }
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Fel Synergy (Life Tap)
+            if (damage && botPet && me->GetLevel() >= 10 && (damageType == SPELL_DIRECT_DAMAGE || damageType == DOT))
+            {
+                uint32 healVal = float(damage) * 0.15f;
+                if (healVal)
+                {
+                    SpellInfo const* synhealInfo = sSpellMgr->GetSpellInfo(FEL_SYNERGY_HEAL);
+                    HealInfo hinfo(me, botPet, healVal, synhealInfo, synhealInfo->GetSchoolMask());
+                    botPet->HealBySpell(hinfo);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SummonBotPet()
+        {
+            if (botPet)
+                UnsummonAll();
+
+            if (myPetType == BOT_PET_INVALID) //disabled
+                return;
+
+            if (petSummonTimer > GetLastDiff())
+                return;
+
+            uint32 entry;
+
+            if (myPetType)
+                entry = myPetType;
+            else if (me->GetLevel() >= 50 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY)
+                entry = BOT_PET_FELGUARD;
+            else if (!IAmFree())
+            {
+                if (me->GetLevel() >= 30 && master->GetMaxPower(POWER_MANA) > 1 &&
+                    !master->GetBotMgr()->HasBotClass(BOT_CLASS_MAGE) &&
+                    !master->GetBotMgr()->HasBotClass(BOT_CLASS_PRIEST) &&
+                    !master->GetBotMgr()->HasBotPetType(BOT_PET_FELHUNTER))
+                    entry = BOT_PET_FELHUNTER;
+                else if ((me->GetLevel() < 68 || !master->GetBotMgr()->HasBotClass(BOT_CLASS_WARRIOR)) &&
+                    !master->GetBotMgr()->HasBotPetType(BOT_PET_IMP))
+                    entry = BOT_PET_IMP;
+                else if (me->GetLevel() >= 10 && IsTank())
+                    entry = BOT_PET_VOIDWALKER;
+                else if (me->GetLevel() >= 20 && !IsMeleeClass(master->GetClass()))
+                    entry = BOT_PET_SUCCUBUS;
+                else if (me->GetLevel() >= 10)
+                    entry = BOT_PET_VOIDWALKER;
+                else
+                    entry = BOT_PET_IMP;
+            }
+            else
+                entry = urand(BOT_PET_WARLOCK_START, BOT_PET_WARLOCK_END);
+
+            //ensurance
+            if ((entry == BOT_PET_VOIDWALKER && me->GetLevel() < 10) ||
+                (entry == BOT_PET_SUCCUBUS && me->GetLevel() < 20) ||
+                (entry == BOT_PET_FELHUNTER && me->GetLevel() < 30) ||
+                (entry == BOT_PET_FELGUARD && (me->GetLevel() < 50 || _spec != BOT_SPEC_WARLOCK_DEMONOLOGY)) ||
+                (entry != BOT_PET_IMP && entry != BOT_PET_VOIDWALKER && entry != BOT_PET_SUCCUBUS &&
+                entry != BOT_PET_FELHUNTER && entry != BOT_PET_FELGUARD))
+                entry = 0;
+
+            myPetType = entry;
+
+            //try next time
+            if (!myPetType)
+                return;
+
+            ResetSpellCooldown(BLOOD_PACT_1);
+            ResetSpellCooldown(FEL_INTELLIGENCE_1);
+
+            Position pos;
+
+            me->CastSpell(me, SUMMON_DEMON_VISUAL, true);
+            Creature* myPet = me->SummonCreature(myPetType, *me, TEMPSUMMON_CORPSE_DESPAWN);
+            me->GetNearPoint(myPet, pos.m_positionX, pos.m_positionY, pos.m_positionZ, 0, me->GetOrientation() + M_PI / 2);
+            myPet->GetMotionMaster()->MovePoint(me->GetMapId(), pos);
+            myPet->SetCreator(master);
+            myPet->SetOwnerGUID(me->GetGUID());
+            myPet->SetFaction(master->GetFaction());
+            myPet->SetControlledByPlayer(!IAmFree());
+            myPet->SetPvP(me->IsPvP());
+            myPet->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+            myPet->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+            //fix scale and equips
+            switch (myPetType)
+            {
+                case BOT_PET_FELHUNTER:
+                    myPet->SetObjectScale(1.1f);
+                    break;
+                case BOT_PET_FELGUARD:
+                    myPet->SetObjectScale(0.75f);
+                    myPet->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, 22199);
+                    break;
+            }
+
+            botPet = myPet;
+        }
+
+        void UnsummonAll() override
+        {
+            if (botPet)
+                botPet->ToTempSummon()->UnSummon();
+        }
+
+        void SummonedCreatureDies(Creature* /*summon*/, Unit* /*killer*/) override
+        {
+        }
+
+        void SummonedCreatureDespawn(Creature* summon) override
+        {
+            //all warlock bot pets despawn at death or manually (gossip, teleport, etc.)
+            //TC_LOG_ERROR("entities.unit", "SummonedCreatureDespawn: %s's %s", me->GetName().c_str(), summon->GetName().c_str());
+            if (summon == botPet)
+            {
+                petSummonTimer = 10000;
+                botPet = nullptr;
+
+                //party aura hack removal helper
+                switch (summon->GetEntry())
+                {
+                    case BOT_PET_IMP:
+                        me->RemoveAurasDueToSpell(InitSpell(me, BLOOD_PACT_1));
+                        break;
+                    case BOT_PET_FELHUNTER:
+                        me->RemoveAurasDueToSpell(InitSpell(me, FEL_INTELLIGENCE_1));
+                        break;
+                }
+            }
+        }
+
+        float GetSpellAttackRange(bool longRange) const override
+        {
+            return longRange ? CalcSpellMaxRange(SHADOW_BOLT_1) : 20.f;
+        }
+
+        uint32 GetAIMiscValue(uint32 data) const override
+        {
+            switch (data)
+            {
+                case CREATE_HEALTHSTONE_1:
+                    return uint32(hasHealthstone);
+                case BOTAI_MISC_PET_TYPE:
+                    return myPetType;
+                case BOTAI_MISC_PET_AVAILABLE_1:
+                    return BOT_PET_IMP;
+                case BOTAI_MISC_PET_AVAILABLE_2:
+                    return me->GetLevel() >= 10 ? BOT_PET_VOIDWALKER : 0;
+                case BOTAI_MISC_PET_AVAILABLE_3:
+                    return me->GetLevel() >= 20 ? BOT_PET_SUCCUBUS : 0;
+                case BOTAI_MISC_PET_AVAILABLE_4:
+                    return me->GetLevel() >= 30 ? BOT_PET_FELHUNTER : 0;
+                case BOTAI_MISC_PET_AVAILABLE_5:
+                    return me->GetLevel() >= 50 && _spec == BOT_SPEC_WARLOCK_DEMONOLOGY ? BOT_PET_FELGUARD : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case CREATE_HEALTHSTONE_1:
+                    hasHealthstone = bool(value);
+                    break;
+                case BOTAI_MISC_PET_TYPE:
+                    myPetType = value;
+                    UnsummonAll();
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            UnsummonAll();
+
+            myPetType = 0;
+
+            fearTimer = 0;
+            banishTimer = 0;
+            unbanishTimer = 0;
+            drainManaTimer = 0;
+            healthstoneTimer = 0;
+            soulstoneTimer = 0;
+            lifeTapCheckTimer = 0;
+            curseCheckTimer = 0;
+
+            petSummonTimer = 5000;
+
+            hasHealthstone = false;
+            hasSoulstone = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (fearTimer > diff)                   fearTimer -= diff;
+            if (banishTimer > diff)                 banishTimer -= diff;
+            if (unbanishTimer > diff)               unbanishTimer -= diff;
+            if (drainManaTimer > diff)              drainManaTimer -= diff;
+            if (healthstoneTimer > diff)            healthstoneTimer -= diff;
+            if (soulstoneTimer > diff)              soulstoneTimer -= diff;
+            if (lifeTapCheckTimer > diff)           lifeTapCheckTimer -= diff;
+            if (curseCheckTimer > diff)             curseCheckTimer -= diff;
+
+            if (petSummonTimer > diff)              petSummonTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_MANA);
+
+            if (botPet && botPet->GetPowerType() != POWER_MANA)
+                botPet->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_MANA);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isAffl = _spec == BOT_SPEC_WARLOCK_AFFLICTION;
+            //bool isDemo = _spec == BOT_SPEC_WARLOCK_DEMONOLOGY;
+            bool isDest = _spec == BOT_SPEC_WARLOCK_DESTRUCTION;
+
+            InitSpellMap(CURSE_OF_WEAKNESS_1);
+            InitSpellMap(CURSE_OF_AGONY_1);
+            InitSpellMap(CURSE_OF_TONGUES_1);
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            InitSpellMap(CORRUPTION_1);
+            InitSpellMap(SEED_OF_CORRUPTION_1);
+            InitSpellMap(INCINERATE_1);
+            InitSpellMap(SEARING_PAIN_1);
+            InitSpellMap(SOUL_FIRE_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+            InitSpellMap(HELLFIRE_1);
+            InitSpellMap(SHADOWFLAME_1);
+            InitSpellMap(FEAR_1);
+            InitSpellMap(HOWL_OF_TERROR_1);
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(SOULSHATTER_1);
+
+            InitSpellMap(DRAIN_SOUL_1);
+            InitSpellMap(DRAIN_MANA_1);
+            InitSpellMap(BANISH_1);
+
+            InitSpellMap(DEMON_SKIN_1);
+            InitSpellMap(DEMON_ARMOR_1);
+            InitSpellMap(FEL_ARMOR_1);
+            InitSpellMap(DETECT_INVISIBILITY_1);
+            InitSpellMap(UNENDING_BREATH_1);
+            InitSpellMap(SHADOW_WARD_1);
+            InitSpellMap(LIFE_TAP_1);
+            InitSpellMap(DARK_PACT_1);
+            InitSpellMap(CREATE_HEALTHSTONE_1);
+            InitSpellMap(CREATE_SOULSTONE_1);
+
+            InitSpellMap(RITUAL_OF_SUMMONING_1); //manual only
+            InitSpellMap(RITUAL_OF_SOULS_1); //not casted
+
+  /*Talent*/lvl >= 30 && isAffl ? InitSpellMap(CURSE_OF_EXHAUSTION_1) : RemoveSpell(CURSE_OF_EXHAUSTION_1);
+  /*Talent*/lvl >= 50 && isAffl ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+  /*Talent*/lvl >= 60 && isAffl ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+
+  /*Talent*/lvl >= 20 && isDest ? InitSpellMap(SHADOWBURN_1) : RemoveSpell(SHADOWBURN_1);
+  /*Talent*/lvl >= 40 && isDest ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 50 && isDest ? InitSpellMap(SHADOWFURY_1) : RemoveSpell(SHADOWFURY_1);
+  /*Talent*/lvl >= 60 && isDest ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isAffl = _spec == BOT_SPEC_WARLOCK_AFFLICTION;
+            bool isDemo = _spec == BOT_SPEC_WARLOCK_DEMONOLOGY;
+            bool isDest = _spec == BOT_SPEC_WARLOCK_DESTRUCTION;
+
+            RefreshAura(CHAOS_BOLT_PASSIVE);
+            RefreshAura(DEMONIC_IMMOLATE_PASSIVE);
+
+            RefreshAura(IMPROVED_DRAIN_SOUL, level >= 15 ? 1 : 0);
+            RefreshAura(SOUL_SIPHON, level >= 15 ? 1 : 0);
+            RefreshAura(IMPROVED_FEAR, level >= 20 ? 1 : 0);
+            RefreshAura(NIGHTFALL, level >= 25 ? 1 : 0);
+            RefreshAura(SHADOW_EMBRACE, isAffl && level >= 30 ? 1 : 0);
+            RefreshAura(SIPHON_LIFE, isAffl && level >= 30 ? 1 : 0);
+            RefreshAura(ERADICATION, isAffl && level >= 40 ? 1 : 0);
+            RefreshAura(PANDEMIC, isAffl && level >= 50 ? 1 : 0);
+            RefreshAura(EVERLASTING_AFFLICTION, isAffl && level >= 55 ? 1 : 0);
+
+            RefreshAura(DEMONIC_RESILIENCE, isDemo && level >= 40 ? 1 : 0);
+            RefreshAura(DECIMATION, isDemo && level >= 45 ? 1 : 0);
+
+            RefreshAura(IMPROVED_SHADOW_BOLT, level >= 10 ? 1 : 0);
+            RefreshAura(AFTERMATH, level >= 15 ? 1 : 0);
+            RefreshAura(BACKLASH, level >= 30 ? 1 : 0);
+            RefreshAura(MOLTEN_CORE, isDest && level >= 35 ? 1 : 0);
+            RefreshAura(NETHER_PROTECTION, isDest && level >= 35 ? 1 : 0);
+            RefreshAura(SOUL_LEECH, isDest && level >= 40 ? 1 : 0);
+            RefreshAura(PYROCLASM, isDest && level >= 40 ? 1 : 0);
+            RefreshAura(IMPROVED_SOUL_LEECH, isDest && level >= 45 ? 1 : 0);
+            RefreshAura(BACKDRAFT, isDest && level >= 50 ? 1 : 0);
+
+            RefreshAura(GLYPH_CORRUPTION, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_LIFE_TAP, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_FEAR, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_QUICK_DECAY, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_CONFLAGRATE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_SHADOWFLAME, level >= 75 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case RAIN_OF_FIRE_1:
+                case SHADOWFLAME_1:
+                case HOWL_OF_TERROR_1:
+                case DETECT_INVISIBILITY_1:
+                case UNENDING_BREATH_1:
+                //case RITUAL_OF_SUMMONING_1:
+                case SHADOW_WARD_1:
+                case LIFE_TAP_1:
+                case DARK_PACT_1:
+                    return true;
+                //case FEL_ARMOR_1:
+                //    return true;
+                //case DEMON_ARMOR_1:
+                //    return !GetSpell(FEL_ARMOR_1);
+                //case DEMON_SKIN_1:
+                //    return !GetSpell(FEL_ARMOR_1) && !GetSpell(DEMON_ARMOR_1);
+                default:
+                    return false;
+            }
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Warlock_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Warlock_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Warlock_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Warlock_spells_support;
+        }
+
+    private:
+        //Timers
+        uint32 fearTimer, banishTimer, unbanishTimer, drainManaTimer, healthstoneTimer,
+            soulstoneTimer, lifeTapCheckTimer, curseCheckTimer;
+        //Pet
+        uint32 myPetType;
+        uint32 petSummonTimer;
+        //Special
+        mutable bool backlash, shadowtrance, backdraft, moltencore, chaoticmind;
+        bool canShadowWard;
+        bool longCasted; //some sort of rotation thing
+        mutable bool instaCast;
+        bool hasHealthstone, hasSoulstone;
+
+        uint32 _getCursesMask(Unit const* unit) const
+        {
+            uint32 mask = 0;
+            Unit::AuraApplicationMap const& aurapps = unit->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                bool my_cast = itr->second->GetBase()->GetCasterGUID() == me->GetGUID();
+                switch (itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id)
+                {
+                    case CURSE_OF_WEAKNESS_1:       mask |= CURSE_MASK_WEAKNESS | (my_cast ? CURSE_MASK_MY_WEAKNESS : CurseType(0));       break;
+                    case CURSE_OF_AGONY_1:          mask |= CURSE_MASK_AGONY | (my_cast ? CURSE_MASK_MY_AGONY : CurseType(0));             break;
+                    case CURSE_OF_DOOM_1:           mask |= CURSE_MASK_DOOM | (my_cast ? CURSE_MASK_MY_DOOM : CurseType(0));               break;
+                    case CURSE_OF_THE_ELEMENTS_1:   mask |= CURSE_MASK_ELEMENTS | (my_cast ? CURSE_MASK_MY_ELEMENTS : CurseType(0));       break;
+                    case CURSE_OF_TONGUES_1:        mask |= CURSE_MASK_TONGUES | (my_cast ? CURSE_MASK_MY_TONGUES : CurseType(0));         break;
+                    case CURSE_OF_EXHAUSTION_1:     mask |= CURSE_MASK_EXHAUSTION | (my_cast ? CURSE_MASK_MY_EXHAUSTION : CurseType(0));   break;
+                    default:                                                                                                    break;
+                }
+            }
+
+            return mask;
+        }
+    };
+};
+
+//HealthstoneSpellIds (Improved Healthstone rank 2)
+uint32 const warlock_bot::warlock_botAI::_healthStoneSpells[8/*createHealthstoneRank*/] =
+{
+    23469,// Minor
+    23471,// Lesser
+    23473,//
+    23475,// Greater
+    23477,// Major
+    27237,// Master
+    47872,// Demonic
+    47877 // Fel
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 000000000..4a10bfdd9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,2264 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "bottraits.h"
+#include "Group.h"
+#include "Item.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "MovementDefines.h"
+#include "ObjectAccessor.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+
+#include "Formulas.h"
+/*
+Warrior NpcBot (reworked by Trickerer onlysuffering@gmail.com)
+Complete - 98%
+TODO:
+*/
+
+enum WarriorBaseSpells
+{
+    BATTLE_STANCE_1                         = 2457,
+    DEFENSIVE_STANCE_1                      = 71,
+    BERSERKER_STANCE_1                      = 2458,
+
+    INTIMIDATING_SHOUT_1                    = 5246,
+    ENRAGED_REGENERATION_1                  = 55694,
+    CHARGE_1                                = 100,
+    OVERPOWER_1                             = 7384,
+    TAUNT_1                                 = 355,
+    BLOODRAGE_1                             = 2687,
+    BERSERKER_RAGE_1                        = 18499,
+    INTERCEPT_1                             = 20252,
+    CLEAVE_1                                = 845,
+    HAMSTRING_1                             = 1715,
+    INTERVENE_1                             = 3411,
+    WHIRLWIND_1                             = 1680,
+    BLADESTORM_1                            = 46924,
+    BATTLE_SHOUT_1                          = 6673,
+    REND_1                                  = 772,
+    EXECUTE_1                               = 5308,
+    PUMMEL_1                                = 6552,
+    BLOODTHIRST_1                           = 23881,
+    MORTAL_STRIKE_1                         = 12294,
+    SLAM_1                                  = 1464,
+    SUNDER_ARMOR_1                          = 7386,
+    SWEEPING_STRIKES_1                      = 12328,
+    RECKLESSNESS_1                          = 1719,
+    RETALIATION_1                           = 20230,
+    DEATH_WISH_1                            = 12292,
+    VICTORY_RUSH_1                          = 34428,
+    THUNDER_CLAP_1                          = 6343,
+    LAST_STAND_1                            = 12975,
+    REVENGE_1                               = 6572,
+    SHIELD_BLOCK_1                          = 2565,
+    SHIELD_SLAM_1                           = 23922,
+    SPELL_REFLECTION_1                      = 23920,
+    DISARM_1                                = 676,
+    SHIELD_WALL_1                           = 871,
+    SHIELD_BASH_1                           = 72,
+    HEROIC_THROW_1                          = 57755,
+    CONCUSSION_BLOW_1                       = 12809,
+    VIGILANCE_1                             = 50720,
+    DEVASTATE_1                             = 20243,
+    MOCKING_BLOW_1                          = 694,
+    SHOCKWAVE_1                             = 46968,
+    PIERCING_HOWL_1                         = 12323,
+    HEROIC_STRIKE_1                         = 78,
+    CHALLENGING_SHOUT_1                     = 1161,
+    COMMANDING_SHOUT_1                      = 469,
+    SHATTERING_THROW_1                      = 64382,
+    DEMORALIZING_SHOUT_1                    = 1160,
+    HEROIC_FURY_1                           = 60970
+};
+enum WarriorPassives
+{
+//Talents
+    ARMORED_TO_THE_TEETH                    = 61222,//rank 3
+    SHIELD_SPECIALIZATION                   = 12727,//rank 5
+    DEEP_WOUNDS_1                           = 12834,
+    DEEP_WOUNDS_2                           = 12849,
+    DEEP_WOUNDS_3                           = 12867,
+    BLOOD_CRAZE1                            = 16487,
+    BLOOD_CRAZE2                            = 16489,
+    BLOOD_CRAZE3                            = 16492,
+    TOUGHNESS                               = 12764,//rank 5
+    TWO_HANDED_WEAPON_SPECIALIZATION        = 12712,//rank 3
+    TASTE_FOR_BLOOD1                        = 56636,
+    TASTE_FOR_BLOOD2                        = 56637,
+    TASTE_FOR_BLOOD3                        = 56638,
+    DUAL_WIELD_SPECIALIZATION               = 23588,//rank 5
+    IMPROVED_SPELL_REFLECTION               = 59089,//rank 2
+    SWORD_SPEC1                             = 12281,
+    SWORD_SPEC2                             = 12812,
+    SWORD_SPEC3                             = 12813,
+    SWORD_SPEC4                             = 12814,
+    SWORD_SPEC5                             = 12815,
+    IMPROVED_HAMSTRING                      = 23695,//rank 3
+    TRAUMA1                                 = 46854,
+    TRAUMA2                                 = 46855,
+    FLURRY1                                 = 12319,
+    FLURRY2                                 = 12971,
+    FLURRY3                                 = 12972,
+    FLURRY4                                 = 12973,
+    FLURRY5                                 = 12974,
+    ONE_HANDED_WEAPON_SPECIALIZATION        = 16542,//rank 5
+    SECOND_WIND                             = 29838,//rank 2
+    IMPROVED_DEFENSIVE_STANCE               = 29594,//rank 2
+    JUGGERNAUGHT                            = 64976,
+    FURIOUS_ATTACKS                         = 46911,//rank 2
+    SAFEGUARD                               = 46949,//rank 2
+    SUDDEN_DEATH                            = 29724,//rank 3
+    ENDLESS_RAGE                            = 29623,
+    BLOOD_FRENZY                            = 29859,
+    RAMPAGE                                 = 29801,
+    BLOODSURGE                              = 46915,//rank 3
+    WARBRINGER                              = 57499,
+    CRITICAL_BLOCK                          = 47296,//rank 3
+    WRECKING_CREW                           = 56614,//rank 5
+    DAMAGE_SHIELD                           = 58874,//rank 2
+//other
+    GLYPH_HEROIC_STRIKE                     = 58357,
+    GLYPH_REVENGE                           = 58364,
+    GLYPH_EXECUTION                         = 58367,
+    GLYPH_BLOCKING                          = 58375,
+    GLYPH_VIGILANCE                         = 63326,
+    GLYPH_DEVASTATE                         = 58388,
+
+    WARRIOR_T10_PROT_4P                     = 70844 //bloodrage absorb
+};
+enum WarriorSpecial
+{
+    STANCE_NONE                             = 0,
+    STANCE_BATTLE                           = 1,
+    STANCE_DEFENSIVE                        = 2,
+    STANCE_BERSERKER                        = 3,
+
+    TASTE_FOR_BLOOD_BUFF                    = 60503,
+    SWORD_AND_BOARD_BUFF                    = 50227,
+    BLOODSURGE_BUFF                         = 46916,//"Slam!"
+    JUGGERNAUGHT_BUFF                       = 65156,
+    GLYPH_REVENGE_BUFF                      = 58363,
+    UNRELENTING_ASSAULT_SPELL               = 64850,
+    VICTORIOUS_SPELL                        = 32216,
+    REVENGE_STUN_SPELL                      = 12798,
+    //SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+    VIGILANCE_PROC                          = 50725,
+    IMPROVED_BERSERKER_RAGE_EFFECT          = 23691,//rank 2
+    UNBRIDLED_WRATH_EFFECT                  = 12964,
+    SUNDER_ARMOR_DEBUFF                     = 58567,
+    GAG_ORDER_DEBUFF                        = 18498,//silence
+    //SUDDEN_DEATH_BUFF                       = 52437,
+    BLOODRAGE_PERIODIC_EFFECT               = 29131,
+
+    //VICTORIOUS_STATE_PASSIVE              = 32215,
+    BERSERKER_STANCE_PASSIVE                = 7381
+};
+
+static  uint32 Warrior_spells_damage_arr[] =
+{ BLADESTORM_1, BLOODTHIRST_1, CLEAVE_1, CONCUSSION_BLOW_1, DEVASTATE_1, EXECUTE_1, HEROIC_STRIKE_1, HEROIC_THROW_1,
+INTERCEPT_1, MOCKING_BLOW_1, MORTAL_STRIKE_1, OVERPOWER_1, REND_1, RETALIATION_1, REVENGE_1, SHATTERING_THROW_1,
+SHIELD_SLAM_1, SHOCKWAVE_1, SLAM_1, THUNDER_CLAP_1, VICTORY_RUSH_1, WHIRLWIND_1 };
+
+static  uint32 Warrior_spells_cc_arr[] =
+{ CHARGE_1, INTERCEPT_1, INTIMIDATING_SHOUT_1, CONCUSSION_BLOW_1, DISARM_1, HAMSTRING_1, PIERCING_HOWL_1,
+SHIELD_BASH_1, SHOCKWAVE_1 };
+
+static  uint32 Warrior_spells_support_arr[] =
+{ BATTLE_SHOUT_1, COMMANDING_SHOUT_1, CHALLENGING_SHOUT_1, DEMORALIZING_SHOUT_1, BERSERKER_RAGE_1, BLOODRAGE_1,
+DEATH_WISH_1, ENRAGED_REGENERATION_1, HEROIC_FURY_1, INTERVENE_1, LAST_STAND_1, PUMMEL_1, RECKLESSNESS_1,
+RETALIATION_1, SHIELD_BASH_1, SHIELD_BLOCK_1, SHIELD_WALL_1, SPELL_REFLECTION_1, SUNDER_ARMOR_1, SWEEPING_STRIKES_1,
+TAUNT_1, VIGILANCE_1 };
+
+static const std::vector<uint32> Warrior_spells_damage(FROM_ARRAY(Warrior_spells_damage_arr));
+static const std::vector<uint32> Warrior_spells_cc(FROM_ARRAY(Warrior_spells_cc_arr));
+static const std::vector<uint32> Warrior_spells_support(FROM_ARRAY(Warrior_spells_support_arr));
+
+static float rageIncomeMult;
+static float rageLossMult;
+
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new warrior_botAI(creature);
+    }
+/*
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return creature->GetBotAI()->OnGossipHello(player, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_ai* ai = creature->GetBotAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+*/
+    struct warrior_botAI : public bot_ai
+    {
+        warrior_botAI(Creature* creature) : bot_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARRIOR;
+
+            InitUnitFlags();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId)
+        {
+            if (CheckBotCast(victim, spellId) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId);
+        }
+
+        uint8 GetBotStance() const override
+        {
+            if (_inStance(1))
+                return WARRIOR_BATTLE_STANCE;
+            else if (_inStance(2))
+                return WARRIOR_DEFENSIVE_STANCE;
+            else if (_inStance(3))
+                return WARRIOR_BERSERKER_STANCE;
+
+            return BOT_STANCE_NONE;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void JustEnteredCombat(Unit* u) override { bot_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override
+        {
+            //Victorious State spell
+            //only on targets which give xp or honor
+            if (u->GetLevel() > Trinity::XP::GetGrayLevel(me->GetLevel()))
+                me->CastSpell(me, VICTORIOUS_SPELL, true);
+
+            bot_ai::KilledUnit(u);
+        }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        //void modrage(int32 mod, bool set = false)
+        //{
+        //    if (set && mod < 0)
+        //        return;
+        //    if (mod < 0 && rage < abs(mod))
+        //    {
+        //        //debug set rage to 0
+        //        mod = 0;
+        //        set = true;
+        //        return;
+        //    }
+
+        //    if (set)
+        //        rage = mod ? mod*10 : 0;
+        //    else
+        //        rage += mod*10;
+
+        //    me->SetPower(POWER_RAGE, rage);
+        //}
+
+        void getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(CLEAVE_1)))
+                rage = std::max<int32>(rage - 200, 0);
+            else if (me->FindCurrentSpellBySpellId(GetSpell(HEROIC_STRIKE_1)))
+                rage = std::max<int32>(rage - rcost(HEROIC_STRIKE_1), 0);
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void BreakCC(uint32 diff) override
+        {
+            if (IsSpellReady(HEROIC_FURY_1, diff) && Rand() < 55 &&
+                (CCed(me, true) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(me, GetSpell(HEROIC_FURY_1)))
+                    return;
+            }
+            if (IsSpellReady(BERSERKER_RAGE_1, diff) && Rand() < 45 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0) &&
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/
+                me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_KNOCKOUT)))
+            {
+                if (doCast(me, GetSpell(BERSERKER_RAGE_1)))
+                    return;
+            }
+            bot_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (me->IsAlive())
+            {
+                if (ragetimer2 <= diff)
+                {
+                    ragetimer2 = 3000;
+                    //Anger Management
+                    if (me->IsInCombat() && me->GetLevel() >= 20)
+                    {
+                        if (me->GetPower(POWER_RAGE) < 990)
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) + uint32(10.f * rageIncomeMult)); //1 rage per 3 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000); //max
+                    }
+                }
+                if (ragetimer <= diff)
+                {
+                    ragetimer = 1500;
+                    if (!me->IsInCombat() &&
+                        !me->HasAuraTypeWithFamilyFlags(SPELL_AURA_PERIODIC_ENERGIZE, SPELLFAMILY_WARRIOR, 0x100))
+                    {
+                        if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                            me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0); //min
+                    }
+                }
+                getrage();
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoVehicleActions(diff);
+            if (!CanBotAttackOnVehicle())
+                return;
+
+            if (IsPotionReady())
+            {
+                if (GetHealthPCT(me) < 40)
+                    DrinkPotion(false);
+            }
+
+            CheckRacials(diff);
+
+            CheckShouts(diff);
+            CheckVigilance(diff);
+            CheckIntervene(diff);
+            CheckSpellReflect(diff);
+
+            if (me->IsInCombat())
+                CheckShatteringThrow(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (ProcessImmediateNonAttackTarget())
+                return;
+
+            if (!CheckAttackTarget())
+            {
+                if (!me->IsInCombat() && stancetimer <= diff && Rand() < 5 && me->getAttackers().empty() && rage <= 250)
+                {
+                    uint8 mystance = 0;
+                    if (IsTank())
+                    {
+                        if (!_inStance(2))
+                            mystance = 2;
+                    }
+                    else
+                        mystance = 1;
+
+                    if (mystance)
+                        stanceChange(diff, mystance);
+                }
+                return;
+            }
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            Unit* mytar = opponent ? opponent : disttarget ? disttarget : nullptr;
+            if (!mytar)
+                return;
+
+            StartAttack(mytar, IsMelee());
+
+            bool const isFury = _spec == BOT_SPEC_WARRIOR_FURY;
+            bool const isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+
+            //Keep stance in combat
+            if (stancetimer <= diff && Rand() < 10 + 15 * (me->GetPower(POWER_RAGE) <= 250))
+            {
+                uint8 mystance;
+                if (IsTank())
+                    mystance = 2;
+                else if (isFury && me->GetLevel() >= 30)
+                    mystance = 3;
+                else
+                    mystance = 1;
+
+                stanceChange(diff, mystance);
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && rage < 600 && Rand() < 20 &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/)
+            {
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                    getrage();
+            }
+
+            getrage();
+
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && Rand() < 80 && GetHealthPCT(me) < 40 &&
+                rage >= rcost(ENRAGED_REGENERATION_1) && me->HasAuraWithMechanic(1u<<MECHANIC_ENRAGED))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                    return;
+            }
+
+            Unit::AttackerSet const& b_attackers = me->getAttackers();
+            float dist = me->GetDistance(mytar);
+
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && rage >= rcost(INTIMIDATING_SHOUT_1))
+            {
+                if (mytar->IsNonMeleeSpellCast(false, false, true) && dist < 5 &&
+                    mytar->GetCreatureType() != CREATURE_TYPE_UNDEAD)
+                {
+                    if (doCast(mytar, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                Unit::AttackerSet const& m_attackers = master->getAttackers();
+                Unit* fearTarget = nullptr;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->GetClass() != BOT_CLASS_DEATH_KNIGHT &&
+                    master->GetClass() != BOT_CLASS_WARRIOR &&
+                    master->GetClass() != BOT_CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for (Unit::AttackerSet::const_iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance((*iter)) < 7.5f)
+                            ++tCount;
+                        if (!fearTarget && me->GetDistance((*iter)) < 5)
+                            fearTarget = (*iter);
+                        if (fearTarget && tCount > 1)
+                            break;
+                    }
+                    if (fearTarget && tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                //Defend myself
+                if (b_attackers.size() > 1 && (!IsTank() || GetHealthPCT(me) < 50))
+                {
+                    tCount = 0;
+                    fearTarget = nullptr;
+                    for (Unit::AttackerSet::const_iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetDistance((*iter)) < 7.5f)
+                            ++tCount;
+                        if (!fearTarget && me->GetDistance((*iter)) < 5)
+                            fearTarget = (*iter);
+                        if (fearTarget && tCount > 1)
+                            break;
+                    }
+                    if (fearTarget && tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+            }//end FEAR
+
+            //LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) &&
+                GetHealthPCT(me) < (30 + 20 * (b_attackers.size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                if (doCast(me, GetSpell(LAST_STAND_1)))
+                    return;
+            }
+
+            Unit const* u = mytar->GetVictim();
+
+            //TAUNT //No GCD
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && Rand() < 50 && dist < 30 &&
+                mytar->CanHaveThreatList() && !CCed(mytar) && !mytar->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (IsTank() && GetHealthPCT(u) < 30 && GetHealthPCT(me) > 67)) &&
+                ((!IsTankingClass(u->GetClass()) && (GetHealthPCT(u) < 80 || _inStance(2))) || IsTank()) &&
+                IsInBotParty(u) &&
+                (_inStance(2) || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                if (doCast(mytar, GetSpell(TAUNT_1)))
+                    return;
+            }
+            //TAUNT 2 (distant)
+            if (IsSpellReady(TAUNT_1, diff, false) && !IAmFree() && u == me && Rand() < 35 && IsTank() &&
+                (IsOffTank() || master->GetBotMgr()->GetNpcBotsCountByRole(BOT_ROLE_TANK_OFF) == 0) &&
+                !(me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())) &&
+                (_inStance(2) || stancetimer <= diff))
+            {
+                Unit* tUnit = FindDistantTauntTarget();
+                if (tUnit && (_inStance(2) || (stancetimer <= diff && stanceChange(diff, 2))))
+                {
+                    if (doCast(tUnit, GetSpell(TAUNT_1)))
+                        return;
+                }
+            }
+            //CHARGE (warbringer)
+            if (IsSpellReady(CHARGE_1, diff, false) && !HasRole(BOT_ROLE_RANGED) && Rand() < 70 &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !(IsTank() && mytar->GetTypeId() == TYPEID_UNIT && mytar->ToCreature()->isWorldBoss()) &&
+                dist > 8 && dist < CalcSpellMaxRange(CHARGE_1) &&
+                ((IsTank() && me->GetLevel() >= 50) ||
+                (!me->IsInCombat() && (_inStance(1) || (stancetimer <= diff && stanceChange(diff, 1))))))
+            {
+                if (doCast(mytar, GetSpell(CHARGE_1)))
+                    return;
+            }
+            //INTERCEPT (warbringer)
+            if (IsSpellReady(INTERCEPT_1, diff, false) && !HasRole(BOT_ROLE_RANGED) && HasRole(BOT_ROLE_DPS) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !(IsTank() && mytar->GetTypeId() == TYPEID_UNIT && mytar->ToCreature()->isWorldBoss()) &&
+                //!me->HasUnitState(UNIT_STATE_CHARGING) &&
+                !(me->GetMotionMaster()->GetCurrentMovementGenerator() && me->GetMotionMaster()->GetCurrentMovementGenerator()->BaseUnitState == UNIT_STATE_CHARGING) && //not charging
+                (me->IsInCombat() || !IsSpellReady(CHARGE_1, diff, false)) &&
+                Rand() < 60 && dist > 10 && dist < 25 && !CCed(mytar) && rage >= rcost(INTERCEPT_1) &&
+                ((IsTank() && me->GetLevel() >= 50) ||
+                (!IsTank() && (_inStance(3) || (stancetimer <= diff && stanceChange(diff, 3))))))
+            {
+                if (doCast(mytar, GetSpell(INTERCEPT_1)))
+                    return;
+            }
+            //CHALLENGING SHOUT
+            if (IsSpellReady(CHALLENGING_SHOUT_1, diff) && Rand() < 40 &&
+                !(u == me && me->GetLevel() >= 40 && mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->IsDungeonBoss() || mytar->ToCreature()->isWorldBoss())) &&
+                rage >= rcost(CHALLENGING_SHOUT_1))
+            {
+                if (IsTank())
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets, 9.f, 1);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count > 1 && doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+                if (u && u != me && !IsSpellReady(TAUNT_1, diff, false) && !IsTank(u) && !CCed(mytar) && dist < 9 &&
+                    (!IsTankingClass(u->GetClass()) || IsTank()) && IsInBotParty(u))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+            }
+
+            bool can_do_normal = CanAffectVictimAny(mytar, SPELL_SCHOOL_NORMAL);
+
+            //BERSERKER RAGE (for rage)
+            if (IsSpellReady(BERSERKER_RAGE_1, diff) && Rand() < 15 && rage < 80/* && me->GetLevel() >= 35*/)
+            {
+                if (doCast(me, GetSpell(BERSERKER_RAGE_1)))
+                    return;
+            }
+            //MOCKING BLOW
+            if (IsSpellReady(MOCKING_BLOW_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && Rand() < 70 && u && u != me &&
+                !IsTank(u) && dist < 5 && rage >= rcost(MOCKING_BLOW_1) &&
+                !CCed(mytar) && (!IsTankingClass(u->GetClass()) || IsTank()) && IsInBotParty(u) &&
+                (_inStance(4) || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(mytar, GetSpell(MOCKING_BLOW_1)))
+                    return;
+            }
+            //SHIELD SLAM
+            if (IsSpellReady(SHIELD_SLAM_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && CanBlock() &&
+                (_inStance(4) || stancetimer <= diff) && dist <= 5 && rage >= rcost(SHIELD_SLAM_1) &&
+                Rand() < (75 + 200*(me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_WARRIOR, 2780, 0) != nullptr)
+                /*me->HasAura(SWORD_AND_BOARD_BUFF)*/))
+            {
+                //check Shield Block
+                if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && (_inStance(2) || (IsTank() && stanceChange(diff, 2))))
+                {
+                    if (doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                    {}
+                }
+                if (_inStance(4) || stanceChange(diff, 4))
+                {
+                    if (doCast(mytar, GetSpell(SHIELD_SLAM_1)))
+                        return;
+                }
+            }
+            //SHIELD BLOCK
+            if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && CanBlock() && Rand() < 70 &&
+                (_inStance(2) || stancetimer <= diff) &&
+                ((u == me && dist < 8) || (!b_attackers.empty() && me->GetDistance2d(*(b_attackers.begin())) < 8)) &&
+                GetHealthPCT(me) < (65 + 8 * uint8(b_attackers.size())))
+            {
+                if ((_inStance(2) || stanceChange(diff, 2)) &&
+                    doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                    return;
+            }
+            //SHOCKWAVE - frontal cone
+            if (IsSpellReady(SHOCKWAVE_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && dist < 8.f && !CCed(mytar) &&
+                rage >= rcost(SHOCKWAVE_1) && Rand() < (70 + 70 * mytar->IsNonMeleeSpellCast(false)) &&
+                me->HasInArc(float(M_PI)/2, mytar) && mytar->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(SHOCKWAVE_1)))
+                    return;
+            }
+            //HEROIC THROW
+            if (IsSpellReady(HEROIC_THROW_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && dist < 30 &&
+                (mytar->GetTypeId() == TYPEID_UNIT || dist > 6) &&
+                Rand() < (20 - 15 * CanBlock() + 90 * mytar->IsNonMeleeSpellCast(false,false,true)))
+            {
+                if (doCast(mytar, GetSpell(HEROIC_THROW_1)))
+                    return;
+            }
+            //THUNDER CLAP
+            if (IsSpellReady(THUNDER_CLAP_1, diff) && HasRole(BOT_ROLE_DPS) && !isFury && Rand() < 40 &&
+                (_inStance(4) || stancetimer <= diff) && dist < 7.5f && rage >= rcost(THUNDER_CLAP_1) &&
+                ((IsTank() && b_attackers.size() > 1) ||
+                (mytar->GetHealth() > me->GetMaxHealth() / 2 &&
+                !mytar->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_MELEE_HASTE, SPELLFAMILY_WARRIOR, 0x80)) ||
+                FindSplashTarget(7.5f, mytar, 15.f)))
+            {
+                if (_inStance(4) || (me->GetLevel() >= 20 && stanceChange(diff, 4)))
+                {
+                    if (doCast(me, GetSpell(THUNDER_CLAP_1)))
+                        return;
+                }
+            }
+            //REVENGE
+            if (IsSpellReady(REVENGE_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && IsTank() && me->HasReactive(REACTIVE_DEFENSE) &&
+                Rand() < 150 && (_inStance(2) || stancetimer <= diff) && dist < 5 && rage >= rcost(REVENGE_1))
+            {
+                if (_inStance(2) || stanceChange(diff, 2))
+                {
+                    if (doCast(mytar, GetSpell(REVENGE_1)))
+                        return;
+                }
+            }
+            //CONCUSSION BLOW
+            if (IsSpellReady(CONCUSSION_BLOW_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !CCed(mytar) &&
+                dist < 5 && rage >= rcost(CONCUSSION_BLOW_1) &&
+                mytar->GetDiminishing(DIMINISHING_STUN) <= DIMINISHING_LEVEL_2 &&
+                Rand() < (30 + 60 * mytar->IsNonMeleeSpellCast(false,false,true)))
+            {
+                if (doCast(mytar, GetSpell(CONCUSSION_BLOW_1)))
+                    return;
+            }
+
+            MoveBehind(mytar);
+
+            //SHIELD BASH - shared cd with pummel
+            if (IsSpellReady(SHIELD_BASH_1, diff, false) && can_do_normal && CanBlock() && Rand() < 80 &&
+                (_inStance(4) || stancetimer <= diff) &&
+                dist < 5 && rage >= rcost(SHIELD_BASH_1) && mytar->IsNonMeleeSpellCast(false,false,true))
+            {
+                if ((_inStance(4) || stanceChange(diff, 4)) &&
+                    doCast(mytar, GetSpell(SHIELD_BASH_1)))
+                    return;
+            }
+            //PUMMEL - shared cd with shield bash
+            if (IsSpellReady(PUMMEL_1, diff, false) && can_do_normal && !IsTank() && !CanBlock() && Rand() < 80 &&
+                dist < 5 && (_inStance(3) || stancetimer <= diff) &&
+                rage >= rcost(PUMMEL_1) && mytar->IsNonMeleeSpellCast(false,false,true))
+            {
+                if ((_inStance(3) || stanceChange(diff, 3)) &&
+                    doCast(mytar, GetSpell(PUMMEL_1)))
+                    return;
+            }
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && can_do_normal && Rand() < 70 && (_inStance(5) || stancetimer <= diff) &&
+                (!GetSpell(PIERCING_HOWL_1) || mytar->GetTypeId() == TYPEID_PLAYER) &&
+                (mytar->isMoving() || mytar->GetTypeId() == TYPEID_PLAYER) && dist < 5 && rage >= rcost(HAMSTRING_1) &&
+                !mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (_inStance(5) || (me->GetLevel() >= 15 && stanceChange(diff, 5)))
+                    if (doCast(mytar, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //PIERCING HOWL
+            if (IsSpellReady(PIERCING_HOWL_1, diff) && can_do_normal && mytar->isMoving() && Rand() < 80 &&
+                dist < 9 && rage >= rcost(PIERCING_HOWL_1) && !mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE))
+            {
+                if (doCast(me, GetSpell(PIERCING_HOWL_1)))
+                    return;
+            }
+            //DISARM
+            if (IsSpellReady(DISARM_1, diff) && can_do_normal && dist < 5 && (_inStance(2) || stancetimer <= diff) &&
+                Rand() < (35 + 55*mytar->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) &&
+                !mytar->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                mytar->GetHealth() > me->GetMaxHealth() / 8 * (1 + mytar->getAttackers().size()) &&
+                rage >= rcost(DISARM_1))
+            {
+                //check weapons
+                bool hasWeapon = true;
+                if (mytar->GetTypeId() == TYPEID_UNIT && !mytar->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
+                    hasWeapon = false;
+                else if (Player const* pla = mytar->ToPlayer())
+                    if (!pla->GetWeaponForAttack(BASE_ATTACK) || !pla->IsUseEquipedWeapon(true))
+                        hasWeapon = false;
+
+                if (hasWeapon && (_inStance(2) || stanceChange(diff, 2)) &&
+                    doCast(mytar, GetSpell(DISARM_1)))
+                    return;
+            }
+            //DEMORALIZING SHOUT
+            if (IsSpellReady(DEMORALIZING_SHOUT_1, diff) && can_do_normal && Rand() < 15 + 25 * IsTank() && dist < 10 &&
+                (mytar->GetClass() == CLASS_WARRIOR || mytar->GetClass() == CLASS_ROGUE ||
+                (mytar->GetTypeId() == TYPEID_UNIT && mytar->ToCreature()->GetCreatureTemplate()->rank != CREATURE_ELITE_NORMAL)) &&
+                mytar->GetHealth() > me->GetMaxHealth() / 8 * (1 + mytar->getAttackers().size()) &&
+                rage >= rcost(DEMORALIZING_SHOUT_1) &&
+                !mytar->HasAuraTypeWithFamilyFlags(SPELL_AURA_MOD_ATTACK_POWER, SPELLFAMILY_WARRIOR, 0x20000))
+            {
+                if (doCast(me, GetSpell(DEMORALIZING_SHOUT_1)))
+                    return;
+            }
+
+            //UBERS
+            //Shield Wall
+            if (IsSpellReady(SHIELD_WALL_1, diff, false) && CanBlock() &&
+                GetHealthPCT(me) < (30 + 4 * b_attackers.size() + 20 * (mytar->GetTypeId() == TYPEID_UNIT && mytar->ToCreature()->isWorldBoss())) &&
+                (_inStance(2) || stanceChange(diff, 2)))
+            {
+                if (doCast(me, GetSpell(SHIELD_WALL_1)))
+                    return;
+            }
+            //Retaliation
+            if (IsSpellReady(RETALIATION_1, diff) && HasRole(BOT_ROLE_DPS) && !CanBlock() && Rand() < 40 &&
+                !me->HasAuraType(SPELL_AURA_MOD_DISARM) && b_attackers.size() > 4 &&
+                (_inStance(1) || stanceChange(diff, 1)))
+            {
+                if (doCast(me, GetSpell(RETALIATION_1)))
+                    return;
+            }
+            //Recklessness
+            if (IsSpellReady(RECKLESSNESS_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !CanBlock() && !IsTank() && Rand() < 60 &&
+                GetHealthPCT(me) > 50 && (_inStance(3) || stancetimer <= diff) && b_attackers.size() < 2 &&
+                (mytar->GetHealth() > me->GetHealth()/2 * (1 + mytar->getAttackers().size()) || mytar->IsControlledByPlayer()) &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/ &&
+                (_inStance(3) || stanceChange(diff, 3)))
+            {
+                if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    return;
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATH_WISH_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 70 &&
+                dist < 15 && rage >= rcost(DEATH_WISH_1) &&
+                mytar->GetHealth() > me->GetHealth()/4 * (1 + mytar->getAttackers().size()) &&
+                !me->GetAuraEffect(SPELL_AURA_MECHANIC_IMMUNITY, SPELLFAMILY_WARRIOR, 0x0, 0x20000, 0x0)
+                /*!me->HasAura(ENRAGED_REGENERATION_1)*/)
+            {
+                if (doCast(me, GetSpell(DEATH_WISH_1)))
+                    return;
+            }
+
+            //VICTORY RUSH
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && Rand() < 70 && dist < 5 && _inStance(5) &&
+                me->GetAuraEffect(SPELL_AURA_DUMMY, SPELLFAMILY_WARRIOR, 0x0, 0x40000, 0x0))
+            {
+                if (doCast(mytar, GetSpell(VICTORY_RUSH_1)))
+                    return;
+            }
+            //DEVASTATE - only with shield
+            if (IsSpellReady(DEVASTATE_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && CanBlock() && Rand() < 100 &&
+                dist < 5 && rage >= rcost(DEVASTATE_1))
+            {
+                if (doCast(mytar, GetSpell(DEVASTATE_1)))
+                    return;
+            }
+            //SUNDER ARMOR
+            if (IsSpellReady(SUNDER_ARMOR_1, diff) && can_do_normal && IsTank() && Rand() < 55 && mytar->GetHealth() > me->GetMaxHealth() &&
+                dist < 5 && (!HasRole(BOT_ROLE_DPS) || !GetSpell(DEVASTATE_1)) && rage >= rcost(SUNDER_ARMOR_1))
+            {
+                AuraEffect const* sunder = mytar->GetAuraEffect(SUNDER_ARMOR_DEBUFF, 0);
+                if ((!sunder || sunder->GetBase()->GetStackAmount() < 5 || sunder->GetBase()->GetDuration() < 20000) &&
+                    doCast(mytar, GetSpell(SUNDER_ARMOR_1)))
+                    return;
+            }
+            //SWEEPING STRIKES //no GCD
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 65 &&
+                (_inStance(5) || stancetimer <= diff) && rage >= rcost(SWEEPING_STRIKES_1) &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, mytar)))
+            {
+                if ((_inStance(5) || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1)))
+                    getrage();
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                mytar->GetHealth() > me->GetMaxHealth() / 4 * (1 + mytar->getAttackers().size()) &&
+                (isArms || mytar->GetClass() == CLASS_ROGUE || mytar->GetShapeshiftForm() == FORM_CAT) &&
+                dist < 5 && rage >= rcost(REND_1) && mytar->GetCreatureType() != CREATURE_TYPE_MECHANICAL &&
+                !(mytar->GetTypeId() == TYPEID_UNIT &&
+                (mytar->ToCreature()->GetCreatureTemplate()->MechanicImmuneMask & (1<<(MECHANIC_BLEED-1)))) &&
+                !mytar->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_WARRIOR, 0x20, 0x0, 0x0, me->GetGUID()) &&
+                (_inStance(4) || (me->GetLevel() >= 15 && stanceChange(diff, 4))))
+            {
+                if (doCast(mytar, GetSpell(REND_1)))
+                    return;
+            }
+            //BLOODTHIRST
+            if (IsSpellReady(BLOODTHIRST_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) &&
+                dist < 5 && rage >= rcost(BLOODTHIRST_1))
+            {
+                if (doCast(mytar, GetSpell(BLOODTHIRST_1)))
+                    return;
+            }
+            //MORTAL STRIKE
+            if (IsSpellReady(MORTAL_STRIKE_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !CanBlock() &&
+                dist < 5 && rage >= rcost(MORTAL_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(MORTAL_STRIKE_1)))
+                    return;
+            }
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !IsTank() && (!isFury || rage < 250) &&
+                (_inStance(1) || stancetimer <= diff) && dist < 5 && rage >= rcost(OVERPOWER_1) &&
+                (me->HasReactive(REACTIVE_OVERPOWER) ||
+                me->GetAuraEffect(SPELL_AURA_ABILITY_IGNORE_AURASTATE, SPELLFAMILY_WARRIOR, 2961, 0)
+                /*me->HasAura(TASTE_FOR_BLOOD_BUFF)*/))
+            {
+                if (_inStance(1) || (me->GetLevel() >= 15 && stanceChange(diff, 1)))
+                {
+                    if (doCast(mytar, GetSpell(OVERPOWER_1)))
+                        return;
+                }
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() &&
+               dist < 10 && rage >= rcost(BLADESTORM_1) &&
+               (b_attackers.size() > 1 || mytar->GetHealth() > me->GetHealth() / 3 * (1 + mytar->getAttackers().size()) ||
+               mytar->IsControlledByPlayer()) &&
+               (Rand() < 50 || me->HasAuraTypeWithFamilyFlags(SPELL_AURA_ADD_FLAT_MODIFIER, SPELLFAMILY_WARRIOR, 0x10)
+               /*me->HasAura(RECKLESSNESS_1)*/) &&
+               (me->GetMap()->IsDungeon() || mytar->GetMaxHealth() > me->GetMaxHealth() * 8 || CCed(mytar, true) || mytar->HasAuraWithMechanic(1<<MECHANIC_SNARE)))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                    return;
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() && Rand() < 80 &&
+                (isFury || mytar->IsControlledByPlayer() || me->GetLevel() < 60 || !me->GetMap()->IsDungeon()) &&
+                (_inStance(3) || stancetimer <= diff) && dist < 7.f &&
+                rage >= rcost(WHIRLWIND_1) && (isFury || rage >= 500 || FindSplashTarget(7.f, mytar, 15.f)))
+            {
+                if ((_inStance(3) || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                    return;
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 110 &&
+                (isFury || !me->GetMap()->IsRaid()) &&
+                (mytar->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) ||
+                me->GetAuraEffect(SPELL_AURA_ABILITY_IGNORE_AURASTATE, SPELLFAMILY_WARRIOR, 0x0, 0x2000000, 0x0)) &&
+                dist < 5 && rage >= rcost(EXECUTE_1) &&
+                (_inStance(5) || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(mytar, GetSpell(EXECUTE_1)))
+                    return;
+            }
+            //SLAM only with improved, has SPELL_ATTR2_NOT_RESET_AUTO_ACTIONS
+            if (IsSpellReady(SLAM_1, diff) && can_do_normal && HasRole(BOT_ROLE_DPS) && !IsTank() && !CanBlock() &&
+                me->GetLevel() >= 40 && dist < 5 && rage >= rcost(SLAM_1) &&
+                ((isArms && !mytar->isMoving() && me->getAttackTimer(BASE_ATTACK) > 500) ||
+                me->GetAuraEffect(SPELL_AURA_ADD_PCT_MODIFIER, SPELLFAMILY_WARRIOR, 0x0, 0x1000000, 0x0))
+                /*me->HasAura(BLOODSURGE_BUFF)*/)
+            {
+                if (doCast(mytar, GetSpell(SLAM_1)))
+                    return;
+            }
+
+            //skip if already have cleave of heroic strike casted
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && can_do_normal && HasRole(BOT_ROLE_DPS) && Rand() < 70 &&
+                dist < 5 && (!IsTank() || rage >= 500) && rage >= rcost(CLEAVE_1) && FindSplashTarget())
+            {
+                if (doCast(mytar, GetSpell(CLEAVE_1)))
+                    return;
+            }
+            //HEROIC STRIKE
+            if (IsSpellReady(HEROIC_STRIKE_1, diff, false) && can_do_normal && HasRole(BOT_ROLE_DPS) && Rand() < 55 && rage >= 350 &&
+                dist < 5 && (isFury || IsTank() || rage >= 650) && rage >= rcost(HEROIC_STRIKE_1))
+            {
+                if (doCast(mytar, GetSpell(HEROIC_STRIKE_1)))
+                    return;
+            }
+        }
+
+        void CheckShouts(uint32 diff)
+        {
+            if (shoutCheckTimer > diff || GC_Timer > diff || Rand() > 35 || me->IsMounted() || IsCasting() ||
+                (rage < rcost(BATTLE_SHOUT_1) && !IsSpellReady(BLOODRAGE_1, diff, false)))
+                return;
+
+            shoutCheckTimer = urand(3000, 5000);
+
+            if (IAmFree())
+            {
+                if (GetSpell(BATTLE_SHOUT_1) &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_RANGED_ATTACK_POWER, SPELLFAMILY_WARRIOR, 0x10000, 0x0, 0x0) &&
+                    !me->GetAuraEffect(SPELL_AURA_MOD_RANGED_ATTACK_POWER, SPELLFAMILY_PALADIN, 0x2, 0x0, 0x0))
+                {
+                    if (rage < rcost(BATTLE_SHOUT_1))
+                    {
+                        if (IsSpellReady(BLOODRAGE_1, diff, false))
+                        {
+                            if (doCast(me, GetSpell(BLOODRAGE_1)))
+                            {}
+                            else
+                                return;
+                        }
+                        else
+                            return;
+                    }
+                    if (doCast(me, GetSpell(BATTLE_SHOUT_1)))
+                        return;
+                }
+
+                return;
+            }
+
+            if (me->GetDistance(master) > 30)
+                return;
+
+            //ignore Blood Pact
+            AuraEffect const* bs = me->GetAuraEffect(SPELL_AURA_MOD_RANGED_ATTACK_POWER, SPELLFAMILY_WARRIOR, 0x10000, 0x0, 0x0);
+            AuraEffect const* cs = me->GetAuraEffect(SPELL_AURA_230, SPELLFAMILY_WARRIOR, 0x0, 0x80, 0x0);
+            AuraEffect const* bm = me->GetAuraEffect(SPELL_AURA_MOD_RANGED_ATTACK_POWER, SPELLFAMILY_PALADIN, 0x2, 0x0, 0x0);
+
+            bool hasBS = bs && (bs->GetBase()->GetDuration() >= 30000 || bs->GetBase()->GetCasterGUID() != me->GetGUID()) && bs->GetBase()->GetId() >= GetSpell(BATTLE_SHOUT_1);
+            bool hasCS = cs && (cs->GetBase()->GetDuration() >= 30000 || cs->GetBase()->GetCasterGUID() != me->GetGUID()) && cs->GetBase()->GetId() >= GetSpell(COMMANDING_SHOUT_1);
+            bool hasBM = bm != nullptr;
+
+            if (hasCS && (hasBS || hasBM))
+                return;
+
+            bool battleshout = !hasBM && !hasBS && (!cs || cs->GetBase()->GetCasterGUID() != me->GetGUID()) &&
+                (!IsTank(me) || !GetSpell(COMMANDING_SHOUT_1)) && GetSpell(BATTLE_SHOUT_1);
+            bool commandingshout = !hasCS && (!bs || bs->GetBase()->GetCasterGUID() != me->GetGUID()) &&
+                GetSpell(COMMANDING_SHOUT_1);
+
+            if (battleshout && !hasCS && !HasRole(BOT_ROLE_DPS) && GetSpell(COMMANDING_SHOUT_1))
+            {
+                battleshout = false;
+                commandingshout = true;
+            }
+
+            if (battleshout || commandingshout)
+            {
+                if (rage < rcost(BATTLE_SHOUT_1) && IsSpellReady(BLOODRAGE_1, diff, false) &&
+                    doCast(me, GetSpell(BLOODRAGE_1)))
+                    getrage();
+
+                if ((battleshout && doCast(me, GetSpell(BATTLE_SHOUT_1))) ||
+                    (commandingshout && doCast(me, GetSpell(COMMANDING_SHOUT_1))))
+                    return;
+            }
+        }
+
+        void CheckVigilance(uint32 diff)
+        {
+            if (vigiCheckTimer > diff || Rand() > 30 || !IsSpellReady(VIGILANCE_1, diff) || me->IsInCombat() ||
+                me->IsMounted() || IsCasting())
+                return;
+
+            vigiCheckTimer = urand(1000, 3000);
+            uint32 VIGILANCE = GetSpell(VIGILANCE_1);
+
+            Unit* u = vigilanceTargetGuid ? ObjectAccessor::GetUnit(*me, vigilanceTargetGuid) : nullptr;
+
+            if (u)
+            {
+                bool myVig = u->HasAura(VIGILANCE, me->GetGUID());
+                if (!IsTank() || !myVig)
+                {
+                    if (myVig)
+                        u->RemoveAura(VIGILANCE, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                    vigilanceTargetGuid = ObjectGuid::Empty;
+                }
+                return;
+            }
+            else if (vigilanceTargetGuid)
+                vigilanceTargetGuid = ObjectGuid::Empty;
+
+            if (IAmFree() || !IsTank())
+                return;
+
+            Group const* gr = master->GetGroup();
+            if (gr)
+            {
+                //tanks
+                for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                {
+                    Player* pPlayer = itr->GetSource();
+                    if (!pPlayer || !pPlayer->IsInWorld()) continue;
+                    if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                    if (pPlayer->IsAlive() && IsTankingClass(pPlayer->GetClass()) && me->GetDistance(pPlayer) < 30 &&
+                        !pPlayer->HasAura(VIGILANCE) && !pPlayer->HasAura(DAMAGE_REDUCTION))
+                    {
+                        u = pPlayer;
+                        break;
+                    }
+                }
+                if (!u)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* cre = it->second;
+                            if (!cre || cre == me || !cre->IsInWorld() || !cre->IsAlive()) continue;
+                            if (cre->GetBotAI()->HasRole(BOT_ROLE_TANK) &&
+                                me->GetDistance(cre) < 30 && !cre->HasAura(VIGILANCE) && !cre->HasAura(DAMAGE_REDUCTION))
+                            {
+                                u = cre;
+                                break;
+                            }
+                        }
+                    }
+                }
+                //any players
+                if (!u)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer == master) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->IsAlive() && me->GetDistance(pPlayer) < 30 &&
+                            !pPlayer->HasAura(VIGILANCE))
+                        {
+                            u = pPlayer;
+                            break;
+                        }
+                    }
+                }
+                //damage-dealing bots
+                if (!u)
+                {
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player const* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* cre = it->second;
+                            if (!cre || cre == me || !cre->IsInWorld() || !cre->IsAlive() || cre->IsTempBot()) continue;
+                            if (cre->GetBotAI()->HasRole(BOT_ROLE_DPS) && me->GetDistance(cre) < 30 &&
+                                !cre->HasAura(VIGILANCE))
+                            {
+                                u = cre;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (!u && master->IsAlive() && me->IsWithinDistInMap(master, 30) && !master->HasAura(VIGILANCE))
+                u = master;
+
+            if (u && doCast(u, VIGILANCE))
+                return;
+        }
+
+        void CheckIntervene(uint32 diff)
+        {
+            //lvl 70 - warbringer always present
+            if (IsSpellReady(INTERVENE_1, diff, false) && !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !me->IsMounted() && rage >= rcost(INTERVENE_1) &&
+                !IAmFree() && !IsCasting() && Rand() < (IsTank() ? 40 : 80))
+            {
+                if (!me->GetVictim() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetDistance(master);
+                    if (mydist < 25 && mydist > 18)
+                    {
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                            return;
+                    }
+                }
+                Group const* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float mydist = me->GetDistance(master);
+                        if (mydist < 25 && mydist > 8)
+                        {
+                            if (doCast(master, GetSpell(INTERVENE_1)))
+                                return;
+                        }
+                    }
+                }
+                else if (!IsTank() || !me->GetVictim())
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || tPlayer->IsBeingTeleported() || tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (!tPlayer->IsAlive() || GetHealthPCT(tPlayer) > 70 ||
+                            tPlayer->HasAuraType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetDistance(tPlayer);
+                        if (dist > 25 || dist < 8) continue;
+
+                        if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                            return;
+                    }
+                    if (!Bots) return;
+                    for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot() || tPlayer->IsBeingTeleported() || tPlayer->FindMap() != me->GetMap()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (bot == me || !bot->IsInWorld() || !bot->IsAlive() || bot->IsTempBot()) continue;
+                            if (GetHealthPCT(bot) > (70 - 30 * IsTank(bot)) ||
+                                bot->HasAuraType(SPELL_AURA_ADD_CASTER_HIT_TRIGGER)) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            dist = me->GetDistance(bot);
+                            if (dist > 25 || dist < 8) continue;
+
+                            if (doCast(bot, GetSpell(INTERVENE_1)))
+                                return;
+                        }
+                    }
+                }
+
+                SetSpellCooldown(INTERVENE_1, 500); //fail
+            }
+        }
+
+        void CheckSpellReflect(uint32 diff)
+        {
+            if (!IsSpellReady(SPELL_REFLECTION_1, diff, false) || me->IsMounted() || IsCasting() ||
+                !CanBlock() || !(_inStance(4) || stancetimer <= diff) ||
+                rage < rcost(SPELL_REFLECTION_1) || Rand() > 75)
+                return;
+
+            //use first match (covers most cases)
+            if (Unit const* target = FindCastingTarget(70))
+            {
+                if (Spell const* spell = target->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->GetTimer() < 500/*(4500 - 4000 * (target->GetTypeId() == TYPEID_PLAYER))*/ &&
+                        !spell->GetSpellInfo()->IsChanneled() &&
+                        spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                        !(spell->GetSpellInfo()->Attributes & (SPELL_ATTR0_ABILITY|SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY)) &&
+                        !(spell->GetSpellInfo()->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                        !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive())
+                    {
+                        if (Unit const* u = spell->m_targets.GetUnitTarget())
+                        {
+                            if ((IAmFree() ? (u == me) : (master->GetGroup() && master->GetGroup()->IsMember(spell->m_targets.GetObjectTargetGUID()))) &&
+                                me->GetTotalAuraModifier(SPELL_AURA_REFLECT_SPELLS) < 100)
+                            {
+                                if ((_inStance(4) || (stancetimer <= diff && stanceChange(diff, 4))) &&
+                                    doCast(me, GetSpell(SPELL_REFLECTION_1)))
+                                    return;
+                            }
+                        }
+                    }
+                }
+            }
+
+            SetSpellCooldown(SPELL_REFLECTION_1, urand(250, 500)); //fail
+        }
+
+        void CheckShatteringThrow(uint32 diff)
+        {
+            if (!IsSpellReady(SHATTERING_THROW_1, diff) || shatterCheckTimer > diff ||
+                !(_inStance(1) || stancetimer <= diff) || rage < rcost(SHATTERING_THROW_1) ||
+                me->getAttackers().size() > 2 || Rand() > 50)
+                return;
+
+            shatterCheckTimer = urand(500, 1000);
+
+            Unit* unit = FindImmunityShieldDispelTarget();
+            if (unit && me->GetDistance(unit) < 30 && (_inStance(1) || (stancetimer <= diff && stanceChange(diff, 1))))
+                if (doCast(unit, GetSpell(SHATTERING_THROW_1)))
+                    return;
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (stancetimer > diff)
+                return false;
+
+            if (stance == 5)
+                stance = (me->GetLevel() >= 30 && !IsTank()) ? 3 : 1;
+            else if (stance == 4)
+                stance = me->GetLevel() >= 10 && IsTank() ? 2 : 1;
+
+            if (stance == 2 && me->GetLevel() < 10)
+                return false;
+            if (stance == 3 && me->GetLevel() < 30)
+                return false;
+
+            if (_inStance(stance))
+                return true;
+
+            rage = me->GetPower(POWER_RAGE);
+            switch (stance)
+            {
+                case 1:
+                    return doCast(me, BATTLE_STANCE_1);
+                case 2:
+                    return doCast(me, DEFENSIVE_STANCE_1);
+                case 3:
+                    return doCast(me, BERSERKER_STANCE_1);
+                default:
+                    return false;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& damageinfo) const override
+        {
+            float pctbonus = 1.0f;
+
+            if (damageinfo.HitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (_spec == BOT_SPEC_WARRIOR_ARMS && me->GetLevel() >= 30)
+                    if (Item const* weap = GetEquips(uint8(damageinfo.AttackType)))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus *= 1.025f;
+            }
+
+            damageinfo.Damages[0].Damage *= pctbonus;
+        }
+
+        void ApplyClassSpellCritMultiplierAll(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType attackType) const override
+        {
+            if (spellInfo->DmgClass != SPELL_DAMAGE_CLASS_MELEE)
+                return;
+
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Recklessness: 100% additional critical chance for damaging abilities
+            if (AuraEffect const* eff = me->GetAuraEffect(RECKLESSNESS_1, EFFECT_0))
+                if (eff->IsAffectedOnSpell(spellInfo))
+                    crit_chance += 100.f;
+            //Juggernaught: 25 additional critical chance for Mortal Strike and Slam
+            if (lvl >= 45 && (baseId == SLAM_1 || baseId == MORTAL_STRIKE_1))
+                if (AuraEffect const* jugg = me->GetAuraEffect(JUGGERNAUGHT_BUFF, 0))
+                    if (jugg->IsAffectedOnSpell(spellInfo))
+                        crit_chance += 25.f;
+
+            //Poleaxe Specialization: 5% additional critical chance for all attacks
+            if (_spec == BOT_SPEC_WARRIOR_ARMS && lvl >= 30)
+                if (Item const* weap = GetEquips(uint8(attackType)))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                            crit_chance += 5.f;
+
+            //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+            if (((_spec == BOT_SPEC_WARRIOR_PROTECTION && lvl >= 15) ||
+                ((_spec == BOT_SPEC_WARRIOR_ARMS || _spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 75)) &&
+                (baseId == CLEAVE_1 || baseId == HEROIC_STRIKE_1 || baseId == THUNDER_CLAP_1))
+                crit_chance += 15.f;
+            //Improved Overpower: 50% additional critical chance for Overpower
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) && lvl >= 20 && baseId == OVERPOWER_1)
+                crit_chance += 50.f;
+            //Critical Block: 15% additional critical chance for Shield Slam
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 50 && baseId == SHIELD_SLAM_1)
+                crit_chance += 15.f;
+            //Sword and Board: 15% additional critical chance for Devastate
+            if (lvl >= 55 && baseId == DEVASTATE_1)
+                crit_chance += 15.f;
+
+            //Glypg of Victory Rush: 30% additional critical chance for Victory Rush
+            if (lvl >= 15 && baseId == VICTORY_RUSH_1)
+                crit_chance += 30.f;
+
+            //Warrior T8 Protection Bonus (id: 64933): 10% additional critical chance for Devastate (tanks only)
+            if (lvl >= 78 && baseId == DEVASTATE_1)
+                crit_chance += 10.f;
+        }
+
+        void ApplyClassDamageMultiplierMeleeSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType attackType, bool iscrit) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float fdamage = float(damage);
+
+            // apply bonus damage mods
+            float pctbonus = 1.0f;
+            if (iscrit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus *= 1.1f;
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 30)
+                    if (Item const* weap = GetEquips(uint8(attackType)))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus *= 1.025f;
+            }
+
+            //Improved Shield Slam (id: 38407): 10% bonus damage for Shield Slam
+            //if (lvl >= 50 && baseId == SHIELD_SLAM_1)
+            //    pctbonus *= 1.1f;
+            //Shield Slam Damage Up (id: 60173): 10% bonus damage for Shield Slam
+            //if (lvl >= 70 && baseId == SHIELD_SLAM_1)
+            //    pctbonus *= 1.1f;
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (lvl >= 10 && baseId == REND_1)
+                pctbonus *= 1.2f;
+            //Improved Thunder Clap (part 2): 30% bonus damage for Thunder Clap
+            if (lvl >= 10 && baseId == THUNDER_CLAP_1)
+                pctbonus *= 1.3f;
+            //Improved Revenge (part 1): 60% bonus damage for Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 20 && baseId == REVENGE_1)
+                pctbonus *= 1.6f;
+            //Gag Order (part 2): 10% bonus damage for Shield Slam
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 30 && baseId == SHIELD_SLAM_1)
+                pctbonus *= 1.1f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 40 && baseId == WHIRLWIND_1)
+                pctbonus *= 1.2f;
+            //Improved Mortal Strike (part 1): 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && baseId == MORTAL_STRIKE_1)
+                pctbonus *= 1.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                pctbonus *= 1.2f;
+            //Unending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 55 && (baseId == WHIRLWIND_1 || baseId == SLAM_1 || baseId == BLOODTHIRST_1))
+                pctbonus *= 1.1f;
+
+            //Glyph of Mocking Blow: 25% bonus damage for Mocking Blow
+            if (lvl >= 16 && baseId == MOCKING_BLOW_1)
+                pctbonus *= 1.25f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && baseId == MORTAL_STRIKE_1)
+                pctbonus *= 1.1f;
+
+            //Warrior T9 Protection 2P Bonus (id: 67269): 5% bonus damage for Devastate
+            if (lvl >= 77 && baseId == DEVASTATE_1)
+                pctbonus *= 1.05f;
+            //Warrior T10 Protection 2P Bonus (id: 70843): 20% bonus damage for Shield Slam and Shockwave
+            if (lvl >= 78 && (baseId == SHIELD_SLAM_1 || baseId == SHOCKWAVE_1))
+                pctbonus *= 1.2f;
+
+            //Improved Cleave: 120% increased '!bonus damage!' done by Cleave (flat mod)
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 25 && baseId == CLEAVE_1)
+            {
+                float bp = spellInfo->_effects[EFFECT_0].BasePoints; //SPELL_EFFECT_WEAPON_DAMAGE (values: 15 - 222)
+                fdamage += bp * 1.2;
+            }
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float fcost = float(cost);
+            //float pctbonus = 1.0f;
+
+            //100% mods
+            //Sword and Board: -100% rage cost for Shield Slam
+            if (baseId == SHIELD_SLAM_1 && me->HasAura(SWORD_AND_BOARD_BUFF))
+                fcost = 0;
+
+            //Glyph of Bloodrage: -100% health cost for Bloodrage
+            if (lvl >= 15 && baseId == BLOODRAGE_1)
+                fcost = 0;
+            //Glyph of Revenge: -100% rage cost for Heroic Strike
+            if (lvl >= 15 && baseId == HEROIC_STRIKE_1 && me->HasAura(GLYPH_REVENGE_BUFF))
+                fcost = 0;
+            //Glyph of Sweeping Strikes: -100% rage cost for Sweeping Strikes
+            if (lvl >= 30 && baseId == SWEEPING_STRIKES_1)
+                fcost = 0;
+
+            //flat mods
+            //Improved Hamstring (id: 24428): -2 rage cost for Hamstring
+            if (lvl >= 25 && baseId == HAMSTRING_1)
+                fcost -= 20;
+            //Bloodthirst and Mortal Strike Discount (id: 37535): -5 rage cost for Bloodthirst and Mortal Strike
+            if (lvl >= 40 && (baseId == BLOODTHIRST_1 || baseId == MORTAL_STRIKE_1))
+                fcost -= 50;
+
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            if (lvl >= 10 && baseId == HEROIC_STRIKE_1)
+                fcost -= 30;
+            //Improved Thunder Clap (part 1): -4 rage cost for Thunder Clap
+            if (lvl >= 10 && baseId == THUNDER_CLAP_1)
+                fcost -= 40;
+            //Improved Execute: -5 rage cost for Execute
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 25 && baseId == EXECUTE_1)
+                fcost -= 50;
+            //Puncture: -3 rage cost for Sunder Armor and Devastate
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 25 && (baseId == SUNDER_ARMOR_1 || baseId == DEVASTATE_1))
+                fcost -= 30;
+            //Focused Rage: -3 rage cost for all offensive abilities (using rage)
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 40 && ((spellInfo->SpellFamilyFlags[0] & 0x6E6E4EEE) || (spellInfo->SpellFamilyFlags[1] & 0x40E664)))
+                fcost -= 30;
+
+            //Glyph of Resonating Power: -5 rage cost for Thunder Clap
+            if (lvl >= 15 && baseId == THUNDER_CLAP_1)
+                fcost -= 50;
+            //Glyph of Shockwave: -3 rage cost for Shockwave
+            if (lvl >= 60 && baseId == SHOCKWAVE_1)
+                fcost -= 30;
+
+            //cost can be < 0
+            cost = int32(fcost/* * pctbonus*/);
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const override
+        {
+            //casttime is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            //int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Bloodsurge: -100% cast time for Slam
+            if (baseId == SLAM_1 && me->HasAura(BLOODSURGE_BUFF))
+                casttime = 0;
+
+            //flat mods
+            //Improved Slam: -1.0 sec cast time for Slam
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 40 && baseId == SLAM_1)
+                casttime -= 1000;
+
+            casttime = std::max<int32>(casttime, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) && lvl >= 40 &&
+                (baseId == BLOODRAGE_1 || baseId == BERSERKER_RAGE_1 || baseId == RECKLESSNESS_1 || baseId == DEATH_WISH_1))
+                pctbonus *= 0.67f;
+
+            //flat mods
+            //zzzOLDImproved Challenging Shout (id: 12327): -2 min cooldown for Challenging Shout (tanks only)
+            if (lvl >= 30 && IsTank() && baseId == CHALLENGING_SHOUT_1)
+                cooldown -= 120000;
+
+            //Shield Mastery (part 2): -20 sec cooldown for Shield Block
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 20 && baseId == SHIELD_BLOCK_1)
+                cooldown -= 20000;
+            //Improved Disciplines: -60 sec cooldown for Shield Wall, Retaliation and Recklessness
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 35 && (baseId == SHIELD_WALL_1 || baseId == RETALIATION_1 || baseId == RECKLESSNESS_1))
+                cooldown -= 60000;
+
+            //Glyph of Bladestorm: -15 sec cooldown for Bladestorm
+            if (lvl >= 60 && baseId == BLADESTORM_1)
+                cooldown -= 15000;
+            //Glyph of Spell Reflection: -1 sec cooldown for Spell Reflection
+            if (lvl >= 64 && baseId == SPELL_REFLECTION_1)
+                cooldown -= 1000;
+
+            cooldown = std::max<float>(cooldown * pctbonus, 0.f);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct bonuses
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            if (lvl >= 15 && baseId == CHARGE_1)
+                pctbonus *= 0.93f;
+
+            //flat bonuses
+            //Improved Disarm part 1: -20 sec cooldown for Disarm
+            if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 25 && baseId == DISARM_1)
+                cooldown -= 20000;
+            //Improved Intercept: -10 sec cooldown for Intercept
+            if ((_spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 30 && baseId == INTERCEPT_1)
+                cooldown -= 10000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 45 && baseId == MORTAL_STRIKE_1)
+                cooldown -= 1000;
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                cooldown -= 4000;
+
+            //Glyph of Last Stand: -1 min cooldown for Last Stand
+            if (lvl >= 20 && baseId == LAST_STAND_1)
+                cooldown -= 60000;
+            //Glyph of Whirlwind: -2 sec cooldown for Whirlwind
+            if (lvl >= 36 && baseId == WHIRLWIND_1)
+                cooldown -= 2000;
+
+            //Warrior T9 2P Bonus (id: 67269): -2 sec cooldown for Taunt (tanks only)
+            if (lvl >= 80 && IsTank() && baseId == TAUNT_1)
+                cooldown -= 2000;
+
+            cooldown = std::max<float>(cooldown * pctbonus, 0.f);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const override
+        {
+            //cooldown is in milliseconds
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                lvl >= 45 && (baseId == OVERPOWER_1 || baseId == REVENGE_1))
+                cooldown -= 500.f;
+        }
+
+        void ApplyClassSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            //uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct mods
+            //Booming Voice part 1 (doubled for bots)
+            if (lvl >= 10 && ((spellInfo->SpellFamilyFlags[0] & 0x30000) || (spellInfo->SpellFamilyFlags[1] & 0x80)))
+                pctbonus *= 2.0f; //1.5f
+
+            //flat mods
+            //Glyph of Thunder Clap (doubled for tanks)
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0x80))
+                radius += IsTank() ? 4.f : 2.f;
+
+            radius = radius * pctbonus;
+        }
+
+        void ApplyClassSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //pct mods
+            //Holy Reach: +20% range for Holy Spells
+            //if (lvl >= 25 && (spellInfo->SpellFamilyFlags[0] & 0x100080))
+            //    pctbonus *= 1.2f;
+
+            //flat mods
+            //Glyph of Charge: +5 yd range for Charge
+            if (baseId == CHARGE_1 && lvl >= 15)
+                maxrange += 5.f;
+
+            maxrange = maxrange * pctbonus;
+        }
+
+        void ApplyClassSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const override
+        {
+            //uint32 bonusTargets = 0;
+            uint8 lvl = me->GetLevel();
+
+            //Improved Revenge: +1 target (actually 2 in dbc)
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x400))
+                targets += 1;
+
+            //Glyph of Sunder Armor: +1 target
+            if (lvl >= 15 && (spellInfo->SpellFamilyFlags[0] & 0x4000))
+                targets += 1;
+            //Glyph of Cleaving: +1 target
+            if (lvl >= 20 && (spellInfo->SpellFamilyFlags[0] & 0x400000))
+            {
+                targets += 1;
+                //double for non-tanks
+                if (!IsTank())
+                    targets += 1;
+            }
+        }
+
+        void ApplyClassEffectMods(WorldObject const* /*wtarget*/, SpellInfo const* spellInfo, uint8 effIndex, float& value) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+            float pctbonus = 1.0f;
+
+            //Improved Rend: 20% increased effect
+            if (baseId == REND_1 && effIndex == EFFECT_0 && lvl >= 10)
+                pctbonus *= 1.2f;
+            //Improved Bloodrage: 50% increased effect
+            if ((baseId == BLOODRAGE_1 || baseId == BLOODRAGE_PERIODIC_EFFECT) && effIndex == EFFECT_0 && lvl >= 10)
+                pctbonus *= 1.5f;
+            //Improved Charge: +10 rage generated
+            if (baseId == CHARGE_1 && effIndex == EFFECT_1 && lvl >= 15)
+                value += 100.f;
+            //Glyph of Bloodthirst: +100% healing
+            if (baseId == BLOODTHIRST_1 && effIndex == EFFECT_1 && lvl >= 40)
+                pctbonus *= 2.0f;
+
+            value = value * pctbonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo) override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+
+            if (baseId == LAST_STAND_1 && !IAmFree())
+                ReportSpellCast(baseId, LocalizedNpcText(master, BOT_TEXT__USED), master);
+            if (baseId == SHIELD_WALL_1 && !IAmFree())
+                ReportSpellCast(baseId, LocalizedNpcText(master, BOT_TEXT__USED), master);
+            if (baseId == ENRAGED_REGENERATION_1 && !IAmFree())
+                ReportSpellCast(baseId, LocalizedNpcText(master, BOT_TEXT__USED), master);
+
+            if (baseId == SLAM_1)
+                me->RemoveAura(BLOODSURGE_BUFF);
+            if (baseId == HEROIC_STRIKE_1)
+                me->RemoveAura(GLYPH_REVENGE_BUFF);
+            if (baseId == SHIELD_SLAM_1)
+                me->RemoveAura(SWORD_AND_BOARD_BUFF);
+            if (baseId == OVERPOWER_1 && !me->HasReactive(REACTIVE_OVERPOWER))
+                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+            if (baseId == BERSERKER_RAGE_1)
+            {
+                //Improved Berserker Rage: 20 rage bonus when used
+                if (me->GetLevel() >= 35)
+                    me->CastSpell(me, IMPROVED_BERSERKER_RAGE_EFFECT, true);
+            }
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            if (baseId == VIGILANCE_1)
+                vigilanceTargetGuid = target->GetGUID();
+
+            //Recklessness: handle charge drop
+            AuraEffect const* reck = me->GetAuraEffect(RECKLESSNESS_1, EFFECT_0);
+            if (reck && reck->IsAffectedOnSpell(spell))
+                reck->GetBase()->DropCharge();
+            //Juggernaught: consume buff
+            if (baseId == SLAM_1 || baseId == MORTAL_STRIKE_1)
+                if (AuraEffect const* jugg = me->GetAuraEffect(JUGGERNAUGHT_BUFF, 0))
+                    if (jugg->IsAffectedOnSpell(spell))
+                        me->RemoveAurasDueToSpell(JUGGERNAUGHT_BUFF);
+
+            if (baseId == THUNDER_CLAP_1 && lvl >= 10)
+            {
+                if (AuraEffect* clap = target->GetAuraEffect(spellId, EFFECT_1, me->GetGUID()))
+                {
+                    int32 amount = clap->GetAmount();
+                    //Improved Thunder Clap (part 3): 10% extra slow
+                    amount += (-10);
+                    //Conqueror Thunder Clap Bonus: 50% increased effect
+                    if ((_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 60)
+                        amount = amount + amount / 2;
+
+                    clap->ChangeAmount(amount);
+                }
+            }
+            if (baseId == DEMORALIZING_SHOUT_1 && lvl >= 15)
+            {
+                if (AuraEffect* demo = target->GetAuraEffect(spellId, 0, me->GetGUID()))
+                    demo->ChangeAmount(demo->GetAmount() + demo->GetAmount() * 2 / 5);
+            }
+            if (baseId == BATTLE_SHOUT_1 || baseId == COMMANDING_SHOUT_1 || baseId == DEMORALIZING_SHOUT_1)
+            {
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    //Booming Voice part 2
+                    //Buffs duration 10 min for bots
+                    uint32 dur = baseId == DEMORALIZING_SHOUT_1 ? shout->GetDuration() * 3 / 2 : 600000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+
+                    if (baseId == BATTLE_SHOUT_1 || baseId == COMMANDING_SHOUT_1)
+                    {
+                        if (lvl >= 20)
+                        {
+                            //Commanding Presence: +25% increased effect (melee AP / HP)
+                            AuraEffect* bamm = shout->GetEffect(EFFECT_0);
+                            if (bamm)
+                                bamm->ChangeAmount(bamm->GetAmount() * 5 / 4);
+                        }
+                    }
+                    else if (baseId == DEMORALIZING_SHOUT_1)
+                    {
+                        if (lvl >= 15)
+                        {
+                            //Improved Demoralization Shout: +40% effect
+                            AuraEffect* demo = shout->GetEffect(EFFECT_0);
+                            if (demo)
+                                demo->ChangeAmount(demo->GetAmount() * 7 / 5);
+                        }
+                    }
+                }
+            }
+            if (baseId == REVENGE_1)
+            {
+                //zzzOLD Revenge Stun (25% chance): skip players
+                if (lvl >= 25 && target->GetTypeId() != TYPEID_PLAYER && urand(1,100) <= 25)
+                    me->CastSpell(target, REVENGE_STUN_SPELL, true);
+            }
+            if (baseId == DISARM_1 && (_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 25)
+            {
+                //Improved Disarm part 2
+                if (AuraEffect* disa = target->GetAuraEffect(spellId, 1, me->GetGUID()))
+                    disa->ChangeAmount(disa->GetAmount() + 10);
+            }
+            if (baseId == OVERPOWER_1)
+            {
+                me->ClearReactive(REACTIVE_OVERPOWER);
+                //Unrelenting Assault (part 3): reduce spells efficiency on players
+                if (lvl >= 45 && (_spec == BOT_SPEC_WARRIOR_ARMS) &&
+                    target->GetTypeId() == TYPEID_PLAYER && target->IsNonMeleeSpellCast(false, false, true))
+                {
+                    CastSpellExtraArgs args(true);
+                    args.SetOriginalCaster(me->GetGUID());
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, args);
+                }
+            }
+            if (baseId == REND_1 && lvl >= 15)
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == INTERVENE_1)
+            {
+                //Glyph of Intervene + 1 bonus charge
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                    vene->SetCharges(vene->GetCharges() + 1);
+            }
+            if (baseId == PIERCING_HOWL_1)
+            {
+                //Piercing Howl: 4 sec duraion increase (exclude players controlled)
+                if (!target->IsControlledByPlayer())
+                {
+                    if (Aura* howl = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = howl->GetDuration() + 4000;
+                        howl->SetDuration(dur);
+                        howl->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (baseId == SHIELD_BASH_1 && (_spec == BOT_SPEC_WARRIOR_PROTECTION) && lvl >= 30)
+            {
+                //Gag Order part 1: silence target
+                me->CastSpell(target, GAG_ORDER_DEBUFF, true);
+            }
+            if (baseId == VICTORY_RUSH_1)
+            {
+                //Victory rush disable helper
+                me->RemoveAura(VICTORIOUS_SPELL);
+            }
+            if ((baseId == DEVASTATE_1 || baseId == REVENGE_1) &&
+                (_spec == BOT_SPEC_WARRIOR_PROTECTION) &&
+                lvl >= 55 && urand(1,100) <= 30)
+            {
+                //Sword and Board: trigger
+                me->CastSpell(me, SWORD_AND_BOARD_BUFF, true);
+                //Sword And Board: remove Shield Slam cooldown
+                ResetSpellCooldown(SHIELD_SLAM_1);
+            }
+
+            OnSpellHitTarget(target, spell);
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            uint32 spellId = spell->Id;
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            uint8 lvl = me->GetLevel();
+
+            //Stances helper
+            if (spellId == BATTLE_STANCE_1 || spellId == DEFENSIVE_STANCE_1 || spellId == BERSERKER_STANCE_1)
+            {
+                stancetimer = 1000;
+
+                //stance mastery, tactical mastery
+                uint32 temprage = 0;
+                if (lvl >= 20)
+                    temprage = rage > 250 ? 250 : rage;
+                else if (lvl >= 15)
+                    temprage = rage > 150 ? 150 : rage;
+
+                _stance =
+                    spellId == BATTLE_STANCE_1 ? STANCE_BATTLE :
+                    spellId == DEFENSIVE_STANCE_1 ? STANCE_DEFENSIVE :
+                    spellId == BERSERKER_STANCE_1 ? STANCE_BERSERKER : STANCE_NONE;
+
+                me->SetPower(POWER_RAGE, temprage);
+                //Update stength bonus from Improved Berserker Stance
+                //if (lvl >= 45)
+                //    SetStats(false);
+            }
+
+            //Iron Will: -20% duration for stuns and charms
+            if ((_spec == BOT_SPEC_WARRIOR_ARMS || _spec == BOT_SPEC_WARRIOR_FURY) &&
+                lvl >= 15 && !spell->IsPositive() && (spell->Mechanic == MECHANIC_STUN || spell->Mechanic == MECHANIC_CHARM))
+            {
+                if (Aura* chun = me->GetAura(spellId, caster->GetGUID()))
+                {
+                    uint32 dur = chun->GetDuration() - chun->GetDuration() / 5;
+                    chun->SetDuration(dur);
+                    chun->SetMaxDuration(dur);
+                }
+            }
+            //Glyph of Enduring Victory: +5 sec duration
+            if (lvl >= 62 && baseId == VICTORIOUS_SPELL)
+            {
+                if (Aura* vict = me->GetAura(spellId))
+                {
+                    uint32 dur = vict->GetDuration() + 5000;
+                    vict->SetDuration(dur);
+                    vict->SetMaxDuration(dur);
+                }
+            }
+            //Improved Berserker Stance part 2: threat mod
+            if (baseId == BERSERKER_STANCE_PASSIVE)
+            {
+                if (AuraEffect* pass = me->GetAuraEffect(spellId, EFFECT_2))
+                    pass->ChangeAmount(pass->GetAmount() - 10);
+            }
+            if (baseId == RETALIATION_1)
+            {
+                //Increase duration by 3 sec for bot
+                if (Aura* ret = me->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = ret->GetDuration() + 3000;
+                    ret->SetDuration(dur);
+                    ret->SetMaxDuration(dur);
+                }
+            }
+            if (baseId == VIGILANCE_PROC) //confirmed right place
+            {
+                //Vigilance: remove Taunt cooldown
+                ResetSpellCooldown(TAUNT_1);
+            }
+            if (baseId == SHIELD_WALL_1)
+            {
+                //Shield Wall Duration (id: 60175): 3 sec increased Shield Wall duration
+                if (Aura* wall = me->GetAura(spellId))
+                {
+                    int32 dur = wall->GetDuration() + 3000;
+                    wall->SetDuration(dur);
+                    wall->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Unbridled Wrath
+            if ((_spec == BOT_SPEC_WARRIOR_FURY || _spec == BOT_SPEC_WARRIOR_ARMS) &&
+                damage && me->GetLevel() >= 15 && me->CanDualWield() &&
+                (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE))
+            {
+                if (roll_chance_f(me->GetPPMProcChance(me->GetFloatValue(UNIT_FIELD_BASEATTACKTIME+BASE_ATTACK), 15.f, nullptr)))
+                    me->CastSpell(me, UNBRIDLED_WRATH_EFFECT, true);
+            }
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void SetAIMiscValue(uint32 data, uint32 /*value*/) override
+        {
+            switch (data)
+            {
+                case BOTAI_MISC_WEAPON_SPEC:
+                {
+                    //AXE and MACE specs are handled elsewhere
+                    _checkSwordSpec();
+                    break;
+                }
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            shoutCheckTimer = 5000;
+            shatterCheckTimer = 5000;
+            vigiCheckTimer = 5000;
+
+            vigilanceTargetGuid = ObjectGuid::Empty;
+
+            _stance = STANCE_NONE;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            rage = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff) override
+        {
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+            if (shoutCheckTimer > diff)             shoutCheckTimer -= diff;
+            if (shatterCheckTimer > diff)           shatterCheckTimer -= diff;
+            if (vigiCheckTimer > diff)              vigiCheckTimer -= diff;
+        }
+
+        void InitPowers() override
+        {
+            me->SetPowerType(POWER_RAGE);
+        }
+
+        void InitSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+            bool isFury = _spec == BOT_SPEC_WARRIOR_FURY;
+            bool isProt = _spec == BOT_SPEC_WARRIOR_PROTECTION;
+
+            InitSpellMap(BATTLE_STANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVE_STANCE_1) : RemoveSpell(DEFENSIVE_STANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKER_STANCE_1) : RemoveSpell(BERSERKER_STANCE_1);
+
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_ARMOR_1) : RemoveSpell(SUNDER_ARMOR_1);
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKER_RAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+            InitSpellMap(BATTLE_SHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+            InitSpellMap(SLAM_1);
+            InitSpellMap(RECKLESSNESS_1);
+            InitSpellMap(RETALIATION_1);
+            InitSpellMap(VICTORY_RUSH_1);
+            InitSpellMap(THUNDER_CLAP_1);
+            InitSpellMap(REVENGE_1);
+            InitSpellMap(SHIELD_BLOCK_1);
+            InitSpellMap(SHIELD_SLAM_1);
+            InitSpellMap(SPELL_REFLECTION_1);
+            InitSpellMap(DISARM_1);
+            InitSpellMap(SHIELD_WALL_1);
+            InitSpellMap(SHIELD_BASH_1);
+            InitSpellMap(HEROIC_THROW_1);
+            InitSpellMap(MOCKING_BLOW_1);
+            InitSpellMap(HEROIC_STRIKE_1);
+            InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(COMMANDING_SHOUT_1);
+            InitSpellMap(SHATTERING_THROW_1);
+            InitSpellMap(DEMORALIZING_SHOUT_1);
+
+  /*Talent*/lvl >= 30 && isArms ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+  /*Talent*/lvl >= 40 && isArms ? InitSpellMap(MORTAL_STRIKE_1) : RemoveSpell(MORTAL_STRIKE_1);
+  /*Talent*/lvl >= 60 && isArms ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+
+  /*Talent*/lvl >= (isFury ? 20 : isArms ? 70 : 99) ? InitSpellMap(PIERCING_HOWL_1) : RemoveSpell(PIERCING_HOWL_1);
+  /*Talent*/lvl >= 30 && isFury ? InitSpellMap(DEATH_WISH_1) : RemoveSpell(DEATH_WISH_1);
+  /*Talent*/lvl >= 40 && isFury ? InitSpellMap(BLOODTHIRST_1) : RemoveSpell(BLOODTHIRST_1);
+  /*Talent*/lvl >= 50 && isFury ? InitSpellMap(HEROIC_FURY_1) : RemoveSpell(HEROIC_FURY_1);
+
+  /*Talent*/lvl >= 20 && isProt ? InitSpellMap(LAST_STAND_1) : RemoveSpell(LAST_STAND_1);
+  /*Talent*/lvl >= 30 && isProt ? InitSpellMap(CONCUSSION_BLOW_1) : RemoveSpell(CONCUSSION_BLOW_1);
+  /*Talent*/lvl >= 40 && isProt ? InitSpellMap(VIGILANCE_1) : RemoveSpell(VIGILANCE_1);
+  /*Talent*/lvl >= 50 && isProt ? InitSpellMap(DEVASTATE_1) : RemoveSpell(DEVASTATE_1);
+  /*Talent*/lvl >= 60 && isProt ? InitSpellMap(SHOCKWAVE_1) : RemoveSpell(SHOCKWAVE_1);
+        }
+
+        void ApplyClassPassives() const override
+        {
+            uint8 level = master->GetLevel();
+            bool isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+            bool isFury = _spec == BOT_SPEC_WARRIOR_FURY;
+            bool isProt = _spec == BOT_SPEC_WARRIOR_PROTECTION;
+
+            RefreshAura(DEEP_WOUNDS_3, (isArms || isFury) && level >= 24 ? 1 : 0);
+            RefreshAura(DEEP_WOUNDS_2, (isArms || isFury) && level >= 23 && level < 24 ? 1 : 0);
+            RefreshAura(DEEP_WOUNDS_1, (isArms || isFury) && level >= 22 && level < 23 ? 1 : 0);
+            RefreshAura(TWO_HANDED_WEAPON_SPECIALIZATION, isArms && level >= 25 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD3, isArms && level >= 27 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD2, isArms && level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD1, isArms && level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(IMPROVED_HAMSTRING, isArms && level >= 15 ? 1 : 0);
+            RefreshAura(TRAUMA2, isArms && level >= 36 ? 1 : 0);
+            RefreshAura(TRAUMA1, isArms && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SECOND_WIND, isArms && level >= 40 ? 1 : 0);
+            RefreshAura(JUGGERNAUGHT, isArms && level >= 45 ? 1 : 0);
+            RefreshAura(SUDDEN_DEATH, isArms && level >= 50 ? 1 : 0);
+            RefreshAura(ENDLESS_RAGE, isArms && level >= 50 ? 1 : 0);
+            RefreshAura(BLOOD_FRENZY, isArms && level >= 50 ? 1 : 0);
+            RefreshAura(WRECKING_CREW, isArms && level >= 55 ? 1 : 0);
+            _checkSwordSpec();
+
+            RefreshAura(ARMORED_TO_THE_TEETH, level >= 10 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE3, (isArms || isFury) && level >= 22 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE2, (isArms || isFury) && level >= 21 && level < 22 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE1, (isArms || isFury) && level >= 20 && level < 21 ? 1 : 0);
+            RefreshAura(DUAL_WIELD_SPECIALIZATION, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, isFury && level >= 39 ? 1 : 0);
+            RefreshAura(FLURRY4, isFury && level >= 38 && level < 39 ? 1 : 0);
+            RefreshAura(FLURRY3, isFury && level >= 37 && level < 38 ? 1 : 0);
+            RefreshAura(FLURRY2, isFury && level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(FLURRY1, isFury && level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(FURIOUS_ATTACKS, isFury && level >= 45 ? 1 : 0);
+            RefreshAura(RAMPAGE, isFury && level >= 50 ? 1 : 0);
+            RefreshAura(BLOODSURGE, isFury && level >= 50 ? 1 : 0);
+
+            RefreshAura(SHIELD_SPECIALIZATION, isProt && level >= 10 ? 1 : 0);
+            RefreshAura(TOUGHNESS, isProt && level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_SPELL_REFLECTION, isProt && level >= 25 ? 1 : 0);
+            RefreshAura(ONE_HANDED_WEAPON_SPECIALIZATION, isProt && level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_DEFENSIVE_STANCE, isProt && level >= 40 ? 1 : 0);
+            RefreshAura(SAFEGUARD, isProt && level >= 45 ? 1 : 0);
+            RefreshAura(WARBRINGER, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(CRITICAL_BLOCK, isProt && level >= 50 ? 1 : 0);
+            RefreshAura(DAMAGE_SHIELD, isProt && level >= 55 ? 1 : 0);
+
+            RefreshAura(GLYPH_HEROIC_STRIKE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_REVENGE, level >= 15 ? 1 : 0);
+            RefreshAura(GLYPH_EXECUTION, level >= 24 ? 1 : 0);
+            RefreshAura(GLYPH_BLOCKING, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_VIGILANCE, level >= 40 ? 1 : 0);
+            RefreshAura(GLYPH_DEVASTATE, level >= 50 ? 1 : 0);
+
+            RefreshAura(WARRIOR_T10_PROT_4P, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const override
+        {
+            switch (basespell)
+            {
+                case BLOODRAGE_1:
+                case BERSERKER_RAGE_1:
+                case BATTLE_SHOUT_1:
+                case COMMANDING_SHOUT_1:
+                case DEATH_WISH_1:
+                    return true;
+                case ENRAGED_REGENERATION_1:
+                    return me->HasAuraWithMechanic(1u<<MECHANIC_ENRAGED);
+                case BATTLE_STANCE_1:
+                    return !_inStance(1);
+                case DEFENSIVE_STANCE_1:
+                    return !_inStance(2);
+                case BERSERKER_STANCE_1:
+                    return !_inStance(3);
+                case SWEEPING_STRIKES_1:
+                    return _inStance(5);
+                case RETALIATION_1:
+                    return _inStance(1);
+                case RECKLESSNESS_1:
+                    return _inStance(3);
+                case SHIELD_WALL_1:
+                    return CanBlock() && _inStance(2);
+                case SHIELD_BLOCK_1:
+                    return CanBlock();
+                case LAST_STAND_1:
+                case VIGILANCE_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const override
+        {
+            float bonus = 0.0f;
+
+            if (_inStance(1))
+            {
+                bonus += 10.f;
+                //Warrior T10 4P Bonus (part 1): 6% additional armor penetration in Battle Stance
+                if (me->GetLevel() >= 75)
+                    bonus += 6.f;
+            }
+
+            //Mace Specialization: 15% armor penetration
+            if (_spec == BOT_SPEC_WARRIOR_ARMS && me->GetLevel() >= 30)
+                if (Item const* weap = GetEquips(BOT_SLOT_MAINHAND))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2)
+                            bonus += 15.f;
+
+            return bonus + bot_ai::GetBotArmorPenetrationCoef();
+        }
+
+        std::vector<uint32> const* GetDamagingSpellsList() const override
+        {
+            return &Warrior_spells_damage;
+        }
+        std::vector<uint32> const* GetCCSpellsList() const override
+        {
+            return &Warrior_spells_cc;
+        }
+        //std::vector<uint32> const* GetHealingSpellsList() const override
+        //{
+        //    return &Warrior_spells_heal;
+        //}
+        std::vector<uint32> const* GetSupportSpellsList() const override
+        {
+            return &Warrior_spells_support;
+        }
+
+    private:
+        bool _inStance(uint8 stance) const
+        {
+            switch (stance)
+            {
+                case 1: return _stance == STANCE_BATTLE;
+                case 2: return _stance == STANCE_DEFENSIVE;
+                case 3: return _stance == STANCE_BERSERKER;
+                case 4: return _stance == STANCE_BATTLE || _stance == STANCE_DEFENSIVE;
+                case 5: return _stance == STANCE_BATTLE || _stance == STANCE_BERSERKER;
+                default: return false;
+            }
+        }
+
+        void _checkSwordSpec() const
+        {
+            uint8 level = me->GetLevel();
+            bool isArms = _spec == BOT_SPEC_WARRIOR_ARMS;
+            Item const* mhWeap = GetEquips(BOT_SLOT_MAINHAND);
+            uint32 weaponSubClass = mhWeap ? mhWeap->GetTemplate()->SubClass : uint32(ITEM_SUBCLASS_WEAPON_WAND);
+            bool sword = (weaponSubClass == ITEM_SUBCLASS_WEAPON_SWORD || weaponSubClass == ITEM_SUBCLASS_WEAPON_SWORD2);
+            RefreshAura(SWORD_SPEC5, isArms && sword && level >= 34 ? 1 : 0);
+            RefreshAura(SWORD_SPEC4, isArms && sword && level >= 33 && level < 34 ? 1 : 0);
+            RefreshAura(SWORD_SPEC3, isArms && sword && level >= 32 && level < 33 ? 1 : 0);
+            RefreshAura(SWORD_SPEC2, isArms && sword && level >= 31 && level < 32 ? 1 : 0);
+            RefreshAura(SWORD_SPEC1, isArms && sword && level >= 30 && level < 31 ? 1 : 0);
+        }
+
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2, shoutCheckTimer, shatterCheckTimer, vigiCheckTimer;
+/*misc*/int32 rage;
+/*misc*/ObjectGuid vigilanceTargetGuid;
+/*stnc*/uint8 _stance;
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 000000000..751ebfffd
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,2215 @@
+#include "bot_ai.h"
+#include "botdump.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+#include "Chat.h"
+#include "CharacterCache.h"
+#include "Creature.h"
+#include "DatabaseEnv.h"
+#include "DBCStores.h"
+#include "Language.h"
+#include "Group.h"
+#include "Log.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "ObjectAccessor.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "RBAC.h"
+#include "ScriptMgr.h"
+#include "SpellInfo.h"
+#include "SpellMgr.h"
+#include "Vehicle.h"
+#include "World.h"
+#include "WorldDatabase.h"
+#include "WorldSession.h"
+#include "QueryPackets.h"
+
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npc Bot related commands by Trickerer (onlysuffering@gmail.com)
+Category: commandscripts/custom/
+*/
+
+using namespace Trinity::ChatCommands;
+
+class script_bot_commands : public CommandScript
+{
+private:
+    static constexpr size_t SOUND_SETS_COUNT = 3;
+    static constexpr size_t GENDERS_COUNT = 2;
+    static constexpr size_t RACES_COUNT = 10;
+
+    // model ids with different sound sets tied to them
+    enum SoundSetModels : uint32
+    {
+        SOUNDSETMODEL_HUMAN_MALE_1          = 3192,
+        SOUNDSETMODEL_HUMAN_MALE_2          = 1290,
+        SOUNDSETMODEL_HUMAN_MALE_3          = 793,
+        SOUNDSETMODEL_HUMAN_FEMALE_1        = 1295,
+        SOUNDSETMODEL_HUMAN_FEMALE_2        = 1296,
+        SOUNDSETMODEL_HUMAN_FEMALE_3        = 1297,
+        SOUNDSETMODEL_DWARF_MALE_1          = 1280,
+        SOUNDSETMODEL_DWARF_MALE_2          = 1354,
+        SOUNDSETMODEL_DWARF_MALE_3          = 1362,
+        SOUNDSETMODEL_DWARF_FEMALE_1        = 1286,
+        SOUNDSETMODEL_DWARF_FEMALE_2        = 1407,
+        SOUNDSETMODEL_DWARF_FEMALE_3        = 2585,
+        SOUNDSETMODEL_NIGHTELF_MALE_1       = 1285,
+        SOUNDSETMODEL_NIGHTELF_MALE_2       = 3599,
+        SOUNDSETMODEL_NIGHTELF_MALE_3       = 3602,
+        SOUNDSETMODEL_NIGHTELF_FEMALE_1     = 2151,
+        SOUNDSETMODEL_NIGHTELF_FEMALE_2     = 2081,
+        SOUNDSETMODEL_NIGHTELF_FEMALE_3     = 1719,
+        SOUNDSETMODEL_GNOME_MALE_1          = 1832,
+        SOUNDSETMODEL_GNOME_MALE_2          = 4287,
+        SOUNDSETMODEL_GNOME_MALE_3          = 4717,
+        SOUNDSETMODEL_GNOME_FEMALE_1        = 3124,
+        SOUNDSETMODEL_GNOME_FEMALE_2        = 5378,
+        SOUNDSETMODEL_GNOME_FEMALE_3        = 3108,
+        SOUNDSETMODEL_DRAENEI_MALE_1        = 16503,
+        SOUNDSETMODEL_DRAENEI_MALE_2        = 16477,
+        SOUNDSETMODEL_DRAENEI_MALE_3        = 16475,
+        SOUNDSETMODEL_DRAENEI_FEMALE_1      = 16222,
+        SOUNDSETMODEL_DRAENEI_FEMALE_2      = 16202,
+        SOUNDSETMODEL_DRAENEI_FEMALE_3      = 16636,
+        SOUNDSETMODEL_ORC_MALE_1            = 1275,
+        SOUNDSETMODEL_ORC_MALE_2            = 1326,
+        SOUNDSETMODEL_ORC_MALE_3            = 1368,
+        SOUNDSETMODEL_ORC_FEMALE_1          = 1325,
+        SOUNDSETMODEL_ORC_FEMALE_2          = 1868,
+        SOUNDSETMODEL_ORC_FEMALE_3          = 1874,
+        SOUNDSETMODEL_UNDEAD_MALE_1         = 1278,
+        SOUNDSETMODEL_UNDEAD_MALE_2         = 1562,
+        SOUNDSETMODEL_UNDEAD_MALE_3         = 1578,
+        SOUNDSETMODEL_UNDEAD_FEMALE_1       = 1592,
+        SOUNDSETMODEL_UNDEAD_FEMALE_2       = 1593,
+        SOUNDSETMODEL_UNDEAD_FEMALE_3       = 1603,
+        SOUNDSETMODEL_TAUREN_MALE_1         = 2083,
+        SOUNDSETMODEL_TAUREN_MALE_2         = 2087,
+        SOUNDSETMODEL_TAUREN_MALE_3         = 2096,
+        SOUNDSETMODEL_TAUREN_FEMALE_1       = 2113,
+        SOUNDSETMODEL_TAUREN_FEMALE_2       = 2112,
+        SOUNDSETMODEL_TAUREN_FEMALE_3       = 2127,
+        SOUNDSETMODEL_TROLL_MALE_1          = 3608,
+        SOUNDSETMODEL_TROLL_MALE_2          = 4047,
+        SOUNDSETMODEL_TROLL_MALE_3          = 4068,
+        SOUNDSETMODEL_TROLL_FEMALE_1        = 4085,
+        SOUNDSETMODEL_TROLL_FEMALE_2        = 4231,
+        SOUNDSETMODEL_TROLL_FEMALE_3        = 4524,
+        SOUNDSETMODEL_BLOODELF_MALE_1       = 15532,
+        SOUNDSETMODEL_BLOODELF_MALE_2       = 16700,
+        SOUNDSETMODEL_BLOODELF_MALE_3       = 16699,
+        SOUNDSETMODEL_BLOODELF_FEMALE_1     = 15514,
+        SOUNDSETMODEL_BLOODELF_FEMALE_2     = 15518,
+        SOUNDSETMODEL_BLOODELF_FEMALE_3     = 15520,
+    };
+
+    static constexpr size_t RaceToRaceOffset[MAX_RACES] = {
+        RACE_NONE,
+        0, //RACE_HUMAN
+        5, //RACE_ORC
+        1, //RACE_DWARF
+        2, //RACE_RACE_NIGHTELF
+        6, //RACE_RACE_UNDEAD_PLAYER
+        7, //RACE_TAUREN
+        3, //RACE_GNOME
+        8, //RACE_TROLL
+        RACE_NONE,
+        9, //RACE_BLOODELF
+        4, //RACE_DRAENEI
+    };
+    
+    static constexpr uint32 SoundSetModelsArray[RACES_COUNT][GENDERS_COUNT][SOUND_SETS_COUNT] = {
+        {{SOUNDSETMODEL_HUMAN_MALE_1, SOUNDSETMODEL_HUMAN_MALE_2, SOUNDSETMODEL_HUMAN_MALE_3}, {SOUNDSETMODEL_HUMAN_FEMALE_1, SOUNDSETMODEL_HUMAN_FEMALE_2, SOUNDSETMODEL_HUMAN_FEMALE_3}},
+        {{SOUNDSETMODEL_DWARF_MALE_1, SOUNDSETMODEL_DWARF_MALE_2, SOUNDSETMODEL_DWARF_MALE_3}, {SOUNDSETMODEL_DWARF_FEMALE_1, SOUNDSETMODEL_DWARF_FEMALE_2, SOUNDSETMODEL_DWARF_FEMALE_3}},
+        {{SOUNDSETMODEL_NIGHTELF_MALE_1, SOUNDSETMODEL_NIGHTELF_MALE_2, SOUNDSETMODEL_NIGHTELF_MALE_3}, {SOUNDSETMODEL_NIGHTELF_FEMALE_1, SOUNDSETMODEL_NIGHTELF_FEMALE_2, SOUNDSETMODEL_NIGHTELF_FEMALE_3}},
+        {{SOUNDSETMODEL_GNOME_MALE_1, SOUNDSETMODEL_GNOME_MALE_2, SOUNDSETMODEL_GNOME_MALE_3}, {SOUNDSETMODEL_GNOME_FEMALE_1, SOUNDSETMODEL_GNOME_FEMALE_2, SOUNDSETMODEL_GNOME_FEMALE_3}},
+        {{SOUNDSETMODEL_DRAENEI_MALE_1, SOUNDSETMODEL_DRAENEI_MALE_2, SOUNDSETMODEL_DRAENEI_MALE_3}, {SOUNDSETMODEL_DRAENEI_FEMALE_1, SOUNDSETMODEL_DRAENEI_FEMALE_2, SOUNDSETMODEL_DRAENEI_FEMALE_3}},
+        {{SOUNDSETMODEL_ORC_MALE_1, SOUNDSETMODEL_ORC_MALE_2, SOUNDSETMODEL_ORC_MALE_3}, {SOUNDSETMODEL_ORC_FEMALE_1, SOUNDSETMODEL_ORC_FEMALE_2, SOUNDSETMODEL_ORC_FEMALE_3}},
+        {{SOUNDSETMODEL_UNDEAD_MALE_1, SOUNDSETMODEL_UNDEAD_MALE_2, SOUNDSETMODEL_UNDEAD_MALE_3}, {SOUNDSETMODEL_UNDEAD_FEMALE_1, SOUNDSETMODEL_UNDEAD_FEMALE_2, SOUNDSETMODEL_UNDEAD_FEMALE_3}},
+        {{SOUNDSETMODEL_TAUREN_MALE_1, SOUNDSETMODEL_TAUREN_MALE_2, SOUNDSETMODEL_TAUREN_MALE_3}, {SOUNDSETMODEL_TAUREN_FEMALE_1, SOUNDSETMODEL_TAUREN_FEMALE_2, SOUNDSETMODEL_TAUREN_FEMALE_3}},
+        {{SOUNDSETMODEL_TROLL_MALE_1, SOUNDSETMODEL_TROLL_MALE_2, SOUNDSETMODEL_TROLL_MALE_3}, {SOUNDSETMODEL_TROLL_FEMALE_1, SOUNDSETMODEL_TROLL_FEMALE_2, SOUNDSETMODEL_TROLL_FEMALE_3}},
+        {{SOUNDSETMODEL_BLOODELF_MALE_1, SOUNDSETMODEL_BLOODELF_MALE_2, SOUNDSETMODEL_BLOODELF_MALE_3}, {SOUNDSETMODEL_BLOODELF_FEMALE_1, SOUNDSETMODEL_BLOODELF_FEMALE_2, SOUNDSETMODEL_BLOODELF_FEMALE_3}}
+    };
+
+    static void GetBotClassNameAndColor(uint8 botclass, std::string& bot_color_str, std::string& bot_class_str)
+    {
+        switch (botclass)
+        {
+            case BOT_CLASS_WARRIOR:     bot_color_str = "ffc79c6e"; bot_class_str = "Warrior";            break;
+            case BOT_CLASS_PALADIN:     bot_color_str = "fff58cba"; bot_class_str = "Paladin";            break;
+            case BOT_CLASS_HUNTER:      bot_color_str = "ffabd473"; bot_class_str = "Hunter";             break;
+            case BOT_CLASS_ROGUE:       bot_color_str = "fffff569"; bot_class_str = "Rogue";              break;
+            case BOT_CLASS_PRIEST:      bot_color_str = "ffffffff"; bot_class_str = "Priest";             break;
+            case BOT_CLASS_DEATH_KNIGHT:bot_color_str = "ffc41f3b"; bot_class_str = "Death Knight";       break;
+            case BOT_CLASS_SHAMAN:      bot_color_str = "ff0070de"; bot_class_str = "Shaman";             break;
+            case BOT_CLASS_MAGE:        bot_color_str = "ff69ccf0"; bot_class_str = "Mage";               break;
+            case BOT_CLASS_WARLOCK:     bot_color_str = "ff9482c9"; bot_class_str = "Warlock";            break;
+            case BOT_CLASS_DRUID:       bot_color_str = "ffff7d0a"; bot_class_str = "Druid";              break;
+            case BOT_CLASS_BM:          bot_color_str = "ffa10015"; bot_class_str = "Blademaster";        break;
+            case BOT_CLASS_SPHYNX:      bot_color_str = "ff29004a"; bot_class_str = "Obsidian Destroyer"; break;
+            case BOT_CLASS_ARCHMAGE:    bot_color_str = "ff028a99"; bot_class_str = "Archmage";           break;
+            case BOT_CLASS_DREADLORD:   bot_color_str = "ff534161"; bot_class_str = "Dreadlord";          break;
+            case BOT_CLASS_SPELLBREAKER:bot_color_str = "ffcf3c1f"; bot_class_str = "Spellbreaker";       break;
+            case BOT_CLASS_DARK_RANGER: bot_color_str = "ff3e255e"; bot_class_str = "Dark Ranger";        break;
+            case BOT_CLASS_NECROMANCER: bot_color_str = "ff9900cc"; bot_class_str = "Necromancer";        break;
+            case BOT_CLASS_SEA_WITCH:   bot_color_str = "ff40d7a9"; bot_class_str = "Sea Witch";          break;
+            default:                    bot_color_str = "ffffffff"; bot_class_str = "Unknown";            break;
+        }
+    }
+
+    struct BotInfo
+    {
+            explicit BotInfo(uint32 Id, std::string&& Name, uint8 Race) : id(Id), name(std::move(Name)), race(Race) {}
+            uint32 id;
+            std::string name;
+            uint8 race;
+
+            BotInfo (BotInfo&&) noexcept = default;
+            BotInfo& operator=(BotInfo&&) noexcept = default;
+
+            BotInfo() = delete;
+            BotInfo(BotInfo const&) = delete;
+            BotInfo& operator=(BotInfo const&) = delete;
+    };
+    static bool sortbots(BotInfo const& p1, BotInfo const& p2)
+    {
+        return p1.id < p2.id;
+    }
+
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommandTable GetCommands() const override
+    {
+        static ChatCommandTable npcbotToggleCommandTable =
+        {
+            { "flags",      HandleNpcBotToggleFlagsCommand,         rbac::RBAC_PERM_COMMAND_NPCBOT_TOGGLE_FLAGS,       Console::No  },
+        };
+
+        static ChatCommandTable npcbotDebugCommandTable =
+        {
+            { "raid",       HandleNpcBotDebugRaidCommand,           rbac::RBAC_PERM_COMMAND_NPCBOT_DEBUG_RAID,         Console::No  },
+            { "mount",      HandleNpcBotDebugMountCommand,          rbac::RBAC_PERM_COMMAND_NPCBOT_DEBUG_MOUNT,        Console::No  },
+            { "spellvisual",HandleNpcBotDebugSpellVisualCommand,    rbac::RBAC_PERM_COMMAND_NPCBOT_DEBUG_VISUAL,       Console::No  },
+            { "states",     HandleNpcBotDebugStatesCommand,         rbac::RBAC_PERM_COMMAND_NPCBOT_DEBUG_STATES,       Console::No  },
+            { "names",      HandleNpcBotDebugNamesCommand,          rbac::RBAC_PERM_COMMAND_NPCBOT_DEBUG_STATES,       Console::No  },
+        };
+
+        static ChatCommandTable npcbotSetCommandTable =
+        {
+            { "faction",    HandleNpcBotSetFactionCommand,          rbac::RBAC_PERM_COMMAND_NPCBOT_SET_FACTION,        Console::No  },
+            { "owner",      HandleNpcBotSetOwnerCommand,            rbac::RBAC_PERM_COMMAND_NPCBOT_SET_OWNER,          Console::No  },
+            { "spec",       HandleNpcBotSetSpecCommand,             rbac::RBAC_PERM_COMMAND_NPCBOT_SET_SPEC,           Console::No  },
+        };
+
+        static ChatCommandTable npcbotCommandCommandTable =
+        {
+            { "standstill", HandleNpcBotCommandStandstillCommand,   rbac::RBAC_PERM_COMMAND_NPCBOT_COMMAND_STANDSTILL, Console::No  },
+            { "stopfully",  HandleNpcBotCommandStopfullyCommand,    rbac::RBAC_PERM_COMMAND_NPCBOT_COMMAND_STOPFULLY,  Console::No  },
+            { "follow",     HandleNpcBotCommandFollowCommand,       rbac::RBAC_PERM_COMMAND_NPCBOT_COMMAND_FOLLOW,     Console::No  },
+            { "walk",       HandleNpcBotCommandWalkCommand,         rbac::RBAC_PERM_COMMAND_NPCBOT_COMMAND_WALK,       Console::No  },
+        };
+
+        static ChatCommandTable npcbotAttackDistanceCommandTable =
+        {
+            { "short",      HandleNpcBotAttackDistanceShortCommand, rbac::RBAC_PERM_COMMAND_NPCBOT_ATTDISTANCE_SHORT,  Console::No  },
+            { "long",       HandleNpcBotAttackDistanceLongCommand,  rbac::RBAC_PERM_COMMAND_NPCBOT_ATTDISTANCE_LONG,   Console::No  },
+            { "",           HandleNpcBotAttackDistanceExactCommand, rbac::RBAC_PERM_COMMAND_NPCBOT_ATTDISTANCE_EXACT,  Console::No  },
+        };
+
+        static ChatCommandTable npcbotDistanceCommandTable =
+        {
+            { "attack",     npcbotAttackDistanceCommandTable                                                                        },
+            { "",           HandleNpcBotFollowDistanceCommand,      rbac::RBAC_PERM_COMMAND_NPCBOT_FOLDISTANCE_EXACT,  Console::No  },
+        };
+
+        static ChatCommandTable npcbotOrderCommandTable =
+        {
+            { "cast",       HandleNpcBotOrderCastCommand,           rbac::RBAC_PERM_COMMAND_NPCBOT_ORDER_CAST,         Console::No  },
+        };
+
+        static ChatCommandTable npcbotVehicleCommandTable =
+        {
+            { "eject",      HandleNpcBotVehicleEjectCommand,        rbac::RBAC_PERM_COMMAND_NPCBOT_VEHICLE_EJECT,      Console::No  },
+        };
+
+        static ChatCommandTable npcbotDumpCommandTable =
+        {
+            { "load",       HandleNpcBotDumpLoadCommand,            rbac::RBAC_PERM_COMMAND_NPCBOT_DUMP_LOAD,          Console::Yes },
+            { "write",      HandleNpcBotDumpWriteCommand,           rbac::RBAC_PERM_COMMAND_NPCBOT_DUMP_WRITE,         Console::Yes },
+        };
+
+        static ChatCommandTable npcbotRecallCommandTable =
+        {
+            { "",           HandleNpcBotRecallCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_RECALL,             Console::No  },
+            { "teleport",   HandleNpcBotRecallTeleportCommand,      rbac::RBAC_PERM_COMMAND_NPCBOT_RECALL,             Console::No  },
+        };
+
+        static ChatCommandTable npcbotListSpawnedCommandTable =
+        {
+            { "",           HandleNpcBotSpawnedCommand,             rbac::RBAC_PERM_COMMAND_NPCBOT_SPAWNED,            Console::Yes },
+            { "free",       HandleNpcBotSpawnedFreeCommand,         rbac::RBAC_PERM_COMMAND_NPCBOT_SPAWNED,            Console::Yes },
+        };
+
+        static ChatCommandTable npcbotListCommandTable =
+        {
+            { "spawned",    npcbotListSpawnedCommandTable                                                                           },
+        };
+
+        static ChatCommandTable npcbotDeleteCommandTable =
+        {
+            { "",           HandleNpcBotDeleteCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_DELETE,             Console::No  },
+            { "id",         HandleNpcBotDeleteByIdCommand,          rbac::RBAC_PERM_COMMAND_NPCBOT_DELETE,             Console::Yes },
+            { "free",       HandleNpcBotDeleteFreeCommand,          rbac::RBAC_PERM_COMMAND_NPCBOT_DELETE,             Console::Yes },
+        };
+
+        static ChatCommandTable npcbotCommandTable =
+        {
+            //{ "debug",      npcbotDebugCommandTable                                                                                 },
+            //{ "toggle",     npcbotToggleCommandTable                                                                                },
+            { "set",        npcbotSetCommandTable                                                                                   },
+            { "add",        HandleNpcBotAddCommand,                 rbac::RBAC_PERM_COMMAND_NPCBOT_ADD,                Console::No  },
+            { "remove",     HandleNpcBotRemoveCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_REMOVE,             Console::No  },
+            { "createnew",  HandleNpcBotCreateNewCommand,           rbac::RBAC_PERM_COMMAND_NPCBOT_CREATENEW,          Console::Yes },
+            { "spawn",      HandleNpcBotSpawnCommand,               rbac::RBAC_PERM_COMMAND_NPCBOT_SPAWN,              Console::No  },
+            { "move",       HandleNpcBotMoveCommand,                rbac::RBAC_PERM_COMMAND_NPCBOT_MOVE,               Console::No  },
+            { "delete",     npcbotDeleteCommandTable                                                                                },
+            { "lookup",     HandleNpcBotLookupCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_LOOKUP,             Console::Yes },
+            { "list",       npcbotListCommandTable                                                                                  },
+            { "revive",     HandleNpcBotReviveCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_REVIVE,             Console::No  },
+            { "reloadconfig",HandleNpcBotReloadConfigCommand,       rbac::RBAC_PERM_COMMAND_NPCBOT_RELOADCONFIG,       Console::Yes },
+            { "command",    npcbotCommandCommandTable                                                                               },
+            { "info",       HandleNpcBotInfoCommand,                rbac::RBAC_PERM_COMMAND_NPCBOT_INFO,               Console::No  },
+            { "hide",       HandleNpcBotHideCommand,                rbac::RBAC_PERM_COMMAND_NPCBOT_HIDE,               Console::No  },
+            { "unhide",     HandleNpcBotUnhideCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_UNHIDE,             Console::No  },
+            { "show",       HandleNpcBotUnhideCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_UNHIDE,             Console::No  },
+            { "recall",     npcbotRecallCommandTable                                                                                },
+            { "kill",       HandleNpcBotKillCommand,                rbac::RBAC_PERM_COMMAND_NPCBOT_KILL,               Console::No  },
+            { "suicide",    HandleNpcBotKillCommand,                rbac::RBAC_PERM_COMMAND_NPCBOT_KILL,               Console::No  },
+            { "sendto",     HandleNpcBotSendToCommand,              rbac::RBAC_PERM_COMMAND_NPCBOT_SEND,               Console::No  },
+            { "distance",   npcbotDistanceCommandTable                                                                              },
+            { "order",      npcbotOrderCommandTable                                                                                 },
+            { "vehicle",    npcbotVehicleCommandTable                                                                               },
+            { "dump",       npcbotDumpCommandTable                                                                                  },
+        };
+
+        static ChatCommandTable commandTable =
+        {
+            { "npcbot",     npcbotCommandTable                                                                                      },
+        };
+        return commandTable;
+    }
+
+    static bool HandleNpcBotDebugNamesCommand(ChatHandler* handler, Optional<std::string_view> name)
+    {
+        Creature* target = handler->getSelectedCreature();
+        if (!target || !name)
+        {
+            handler->SendSysMessage("Syntax: .npcbot debug names #name");
+            return true;
+        }
+
+        CreatureTemplate const* ci = target->GetCreatureTemplate();
+        LocaleConstant loc = LocaleConstant(handler->GetSessionDbLocaleIndex());
+
+        WorldPackets::Query::QueryCreatureResponse queryTemp;
+        std::string locName(*name), locTitle = ci->Title;
+        if (CreatureLocale const* cl = sObjectMgr->GetCreatureLocale(ci->Entry))
+        {
+            //ObjectMgr::GetLocaleString(cl->Name, loc, locName);
+            ObjectMgr::GetLocaleString(cl->Title, loc, locTitle);
+        }
+        queryTemp.CreatureID = ci->Entry;
+        queryTemp.Allow = true;
+        queryTemp.Stats.Name = locName;
+        queryTemp.Stats.NameAlt = locTitle;
+        queryTemp.Stats.CursorName = ci->IconName;
+        queryTemp.Stats.Flags = ci->type_flags;
+        queryTemp.Stats.CreatureType = ci->type;
+        queryTemp.Stats.CreatureFamily = ci->family;
+        queryTemp.Stats.Classification = ci->rank;
+        memcpy(queryTemp.Stats.ProxyCreatureID, ci->KillCredit, sizeof(uint32) * MAX_KILL_CREDIT);
+        queryTemp.Stats.CreatureDisplayID[0] = ci->Modelid1;
+        queryTemp.Stats.CreatureDisplayID[1] = ci->Modelid2;
+        queryTemp.Stats.CreatureDisplayID[2] = ci->Modelid3;
+        queryTemp.Stats.CreatureDisplayID[3] = ci->Modelid4;
+        queryTemp.Stats.HpMulti = ci->ModHealth;
+        queryTemp.Stats.EnergyMulti = ci->ModMana;
+        queryTemp.Stats.Leader = ci->RacialLeader;
+        for (uint32 i = 0; i < MAX_CREATURE_QUEST_ITEMS; ++i)
+            queryTemp.Stats.QuestItems[i] = 0;
+        if (std::vector<uint32> const* items = sObjectMgr->GetCreatureQuestItemList(ci->Entry))
+            for (uint32 i = 0; i < MAX_CREATURE_QUEST_ITEMS; ++i)
+                if (i < items->size())
+                    queryTemp.Stats.QuestItems[i] = (*items)[i];
+        queryTemp.Stats.CreatureMovementInfoID = ci->movementId;
+        queryTemp.Write();
+        queryTemp.ShrinkToFit();
+
+        WorldPacket response = queryTemp.Move();
+        handler->GetSession()->SendPacket(&response);
+
+        handler->SendSysMessage("Done.");
+        return true;
+    }
+
+    static bool HandleNpcBotDebugStatesCommand(ChatHandler* handler)
+    {
+        Unit* target = handler->getSelectedUnit();
+        if (!target)
+        {
+            handler->SendSysMessage("No target selected");
+            return true;
+        }
+
+        std::ostringstream ostr;
+        ostr << "Listing states for " << target->GetName() << ":";
+        for (uint32 state = 1u; state != 1u << 31; state <<= 1)
+        {
+            if (target->HasUnitState(state))
+                ostr << "\n    0x" << std::hex << (state);
+        }
+
+        handler->SendSysMessage(ostr.str().c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotDebugRaidCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Group const* gr = owner->GetGroup();
+        if (!owner->HaveBot() || !gr)
+        {
+            handler->SendSysMessage(".npcbot debug raid");
+            handler->SendSysMessage("prints your raid bots info");
+            return true;
+        }
+        if (!gr->isRaidGroup())
+        {
+            handler->SendSysMessage("only usable in raid");
+            return true;
+        }
+
+        uint8 counter = 0;
+        uint8* subBots = new uint8[MAX_RAID_SUBGROUPS];
+        memset((void*)subBots, 0, (MAX_RAID_SUBGROUPS)*sizeof(uint8));
+        std::ostringstream sstr;
+        BotMap const* map = owner->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* bot = itr->second;
+            if (!bot || !gr->IsMember(itr->second->GetGUID()))
+                continue;
+
+            uint8 subGroup = gr->GetMemberGroup(itr->second->GetGUID());
+            ++subBots[subGroup];
+            sstr << uint32(++counter) << ": " << bot->GetGUID().GetCounter() << " " << bot->GetName()
+                << " subgr: " << uint32(subGroup + 1) << "\n";
+        }
+
+        for (uint8 i = 0; i != MAX_RAID_SUBGROUPS; ++i)
+            if (subBots[i] > 0)
+                sstr << uint32(subBots[i]) << " bots in subgroup " << uint32(i + 1) << "\n";
+
+        handler->SendSysMessage(sstr.str().c_str());
+        delete[] subBots;
+        return true;
+    }
+
+    static bool HandleNpcBotDebugMountCommand(ChatHandler* handler, Optional<uint32> mountId)
+    {
+        if (!mountId)
+            return false;
+
+        Unit* target = handler->getSelectedUnit();
+        if (!target)
+        {
+            handler->SendSysMessage("No target selected");
+            return true;
+        }
+
+        target->Mount(*mountId);
+        return true;
+    }
+
+    static bool HandleNpcBotDebugSpellVisualCommand(ChatHandler* handler, Optional<uint32> kit)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* target = owner->GetSelectedUnit();
+        if (!target)
+        {
+            handler->SendSysMessage("No target selected");
+            return true;
+        }
+
+        target->SendPlaySpellVisual(kit.value_or(0));
+        return true;
+    }
+
+    static bool HandleNpcBotDumpLoadCommand(ChatHandler* handler, Optional<std::string> file_str, Optional<bool> forceKick)
+    {
+        bool force_kick = forceKick.value_or(false);
+        if (!file_str || (!force_kick && sWorld->GetPlayerCount() > 0))
+        {
+            handler->SendSysMessage(".npcbot dump load");
+            handler->SendSysMessage("Imports NPCBots from a backup SQL file created with '.npcbot dump write' command.");
+            handler->SendSysMessage("Syntax: .npcbot dump load #file_name [#force_kick_all]");
+            if (!force_kick && sWorld->GetPlayerCount() > 0)
+                handler->SendSysMessage("Make sure no players are online before importing.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        sWorld->SetPlayerAmountLimit(0);
+        if (force_kick)
+            sWorld->KickAll();
+
+        //omit file ext if needed
+        if (file_str->find('.') == std::string::npos)
+            *file_str += ".sql";
+
+        switch (NPCBotsDump().Load(*file_str))
+        {
+            case BOT_DUMP_SUCCESS:
+                handler->SendSysMessage("Import successful.");
+                handler->SendSysMessage("Server will be restarted now to prevent DB corruption.");
+                sWorld->ShutdownServ(4, SHUTDOWN_MASK_RESTART, 70);
+                break;
+            case BOT_DUMP_FAIL_FILE_NOT_EXIST:
+                handler->PSendSysMessage("Can't open %s or the file doesn't exist!", file_str->c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            case BOT_DUMP_FAIL_FILE_CORRUPTED:
+                handler->SendSysMessage("File data integrity check failed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            case BOT_DUMP_FAIL_DATA_OCCUPIED:
+                handler->PSendSysMessage("Table data contained in %s overlaps with existing table entries!", file_str->c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            default:
+                handler->SendSysMessage("Error!");
+                handler->SetSentErrorMessage(true);
+                return false;
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotDumpWriteCommand(ChatHandler* handler, Optional<std::string> file_str)
+    {
+        if (!file_str)
+        {
+            handler->SendSysMessage(".npcbot dump write\nExports spawned NPCBots into a SQL file.\nSyntax: .npcbot dump write #file_name");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        //omit file ext if needed
+        if (file_str->find('.') == std::string::npos)
+            *file_str += ".sql";
+
+        switch (NPCBotsDump().Write(*file_str))
+        {
+            case BOT_DUMP_SUCCESS:
+                handler->SendSysMessage("Export successful.");
+                break;
+            case BOT_DUMP_FAIL_FILE_ALREADY_EXISTS:
+                handler->PSendSysMessage("File %s already exists!", file_str->c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            case BOT_DUMP_FAIL_CANT_WRITE_TO_FILE:
+                handler->SendSysMessage("Can't open file for write!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            case BOT_DUMP_FAIL_INCOMPLETE:
+                handler->SendSysMessage("Export was not completed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            default:
+                handler->SendSysMessage("Error!");
+                handler->SetSentErrorMessage(true);
+                return false;
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotOrderCastCommand(ChatHandler* handler, Optional<std::string_view> bot_name, Optional<std::string> spell_name, Optional<std::string_view> target_token)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot() || !bot_name || !spell_name)
+        {
+            handler->SendSysMessage(".npcbot order cast #bot_name #spell_underscored_name #[target_token]");
+            handler->SendSysMessage("Orders bot to cast a spell immediately");
+            return true;
+        }
+
+        for (std::decay_t<decltype(*spell_name)>::size_type i = 0u; i < spell_name->size(); ++i)
+            if ((*spell_name)[i] == '_')
+                (*spell_name)[i] = ' ';
+
+        auto canBotUseSpell = [=](Creature const* tbot, uint32 bspell) {
+            //we ignore GCD for now
+            return bspell && (tbot->GetBotAI()->GetSpellCooldown(bspell) <= tbot->GetBotAI()->GetLastDiff());
+        };
+
+        uint32 base_spell = 0;
+        Creature* bot = owner->GetBotMgr()->GetBotByName(*bot_name);
+        if (bot)
+        {
+            if (!bot->IsInWorld())
+            {
+                handler->PSendSysMessage("Bot %s is not found!", *bot_name);
+                return true;
+            }
+            if (!bot->IsAlive())
+            {
+                handler->PSendSysMessage("%s is dead!", bot->GetName().c_str());
+                return true;
+            }
+
+            base_spell = bot->GetBotAI()->GetBaseSpell(*spell_name, handler->GetSessionDbcLocale());
+            if (!base_spell)
+            {
+                handler->PSendSysMessage("%s doesn't have spell named '%s'!", bot->GetName().c_str(), spell_name->c_str());
+                return true;
+            }
+            if (!canBotUseSpell(bot, base_spell))
+            {
+                handler->PSendSysMessage("%s's %s is not ready yet!", bot->GetName().c_str(), sSpellMgr->GetSpellInfo(base_spell)->SpellName[handler->GetSessionDbcLocale()]);
+                return true;
+            }
+        }
+        else
+        {
+            auto class_name = *bot_name;
+            for (auto const c : class_name)
+            {
+                if (!std::islower(c))
+                {
+                    handler->SendSysMessage("Bot class name must be in lower case!");
+                    return true;
+                }
+            }
+
+            uint8 bot_class = BotMgr::BotClassByClassName(std::string(class_name));
+            if (bot_class == BOT_CLASS_NONE)
+            {
+                handler->PSendSysMessage("Unknown bot name or class %s!", std::string(class_name).c_str());
+                return true;
+            }
+
+            std::list<Creature*> cBots = owner->GetBotMgr()->GetAllBotsByClass(bot_class);
+
+            if (cBots.empty())
+            {
+                handler->PSendSysMessage("No bots of class %u found!", bot_class);
+                return true;
+            }
+
+            for (Creature const* fbot : cBots)
+            {
+                base_spell = fbot->GetBotAI()->GetBaseSpell(*spell_name, handler->GetSessionDbcLocale());
+                if (base_spell)
+                    break;
+            }
+
+            if (!base_spell)
+            {
+                handler->PSendSysMessage("None of %u found bots have spell named '%s'!", cBots.size(), spell_name->c_str());
+                return true;
+            }
+
+            cBots.erase(std::remove_if(cBots.begin(), cBots.end(),
+                [=](Creature const* tbot) {
+                    if (tbot->GetBotAI()->GetOrdersCount() >= MAX_BOT_ORDERS_QUEUE_SIZE)
+                        return true;
+                    return !canBotUseSpell(tbot, base_spell);
+                }),
+                cBots.end());
+
+            decltype(cBots) ccBots;
+            for (decltype(cBots)::const_iterator it = cBots.begin(); it != cBots.end();)
+            {
+                if (!(*it)->GetCurrentSpell(CURRENT_CHANNELED_SPELL) && !(*it)->IsNonMeleeSpellCast(false, false, true, false, false))
+                {
+                    ccBots.push_back(*it);
+                    it = cBots.erase(it);
+                }
+                else
+                    ++it;
+            }
+
+            bot = ccBots.empty() ? nullptr : ccBots.size() == 1 ? ccBots.front() : Trinity::Containers::SelectRandomContainerElement(ccBots);
+            if (!bot)
+                bot = cBots.empty() ? nullptr : cBots.size() == 1 ? cBots.front() : Trinity::Containers::SelectRandomContainerElement(cBots);
+
+            if (!bot)
+            {
+                handler->PSendSysMessage("None of %u found bots can use %s yet!", cBots.size(), spell_name->c_str());
+                return true;
+            }
+        }
+
+        ObjectGuid target_guid;
+        if (!target_token || target_token == "bot" || target_token == "self")
+            target_guid = bot->GetGUID();
+        else if (target_token == "me" || target_token == "master")
+            target_guid = owner->GetGUID();
+        else if (target_token == "mypet")
+            target_guid = owner->GetPetGUID();
+        else if (target_token == "myvehicle")
+            target_guid = owner->GetVehicle() ? owner->GetVehicleBase()->GetGUID() : ObjectGuid::Empty;
+        else if (target_token == "target")
+            target_guid = bot->GetTarget();
+        else if (target_token == "mytarget")
+            target_guid = owner->GetTarget();
+        else
+        {
+            handler->PSendSysMessage("Invalid target token '%s'!", *target_token);
+            handler->SendSysMessage("Valid target tokens:\n    '','bot','self', 'me','master', 'mypet', 'myvehicle', 'target', 'mytarget'");
+            return true;
+        }
+
+        Unit* target = target_guid ? ObjectAccessor::GetUnit(*owner, target_guid) : nullptr;
+        if (!target || !bot->FindMap() || target->FindMap() != bot->FindMap())
+        {
+            handler->PSendSysMessage("Invalid target '%s'!", target ? target->GetName().c_str() : "unknown");
+            return true;
+        }
+
+        bot_ai::BotOrder order(BOT_ORDER_SPELLCAST);
+        order.params.spellCastParams.baseSpell = base_spell;
+        order.params.spellCastParams.targetGuid = target_guid.GetRawValue();
+
+        if (bot->GetBotAI()->AddOrder(std::move(order)))
+        {
+            if (DEBUG_BOT_ORDERS)
+                handler->PSendSysMessage("Order given: %s: %s on %s", bot->GetName().c_str(),
+                    sSpellMgr->GetSpellInfo(base_spell)->SpellName[handler->GetSessionDbcLocale()], target ? target->GetName().c_str() : "unknown");
+        }
+        else
+        {
+            if (DEBUG_BOT_ORDERS)
+                handler->PSendSysMessage("Order failed: %s: %s on %s", bot->GetName().c_str(),
+                    sSpellMgr->GetSpellInfo(base_spell)->SpellName[handler->GetSessionDbcLocale()], target ? target->GetName().c_str() : "unknown");
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotVehicleEjectCommand(ChatHandler* handler)
+    {
+        Player const* owner = handler->GetSession()->GetPlayer();
+        Unit const* target = handler->getSelectedUnit();
+
+        bool hasBotsInVehicles = false;
+        bool botsInSelVehicle = 0;
+        BotMap const* bmap = nullptr;
+        if (owner->HaveBot())
+        {
+            bmap = owner->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator ci = bmap->begin(); ci != bmap->end(); ++ci)
+            {
+                if (ci->second && ci->second->GetVehicle())
+                {
+                    if (!hasBotsInVehicles)
+                        hasBotsInVehicles = true;
+                    if (!botsInSelVehicle && target && target->IsVehicle() && target->GetVehicleKit()->GetSeatForPassenger(ci->second))
+                        botsInSelVehicle = true;
+                }
+                if (hasBotsInVehicles && botsInSelVehicle)
+                    break;
+            }
+        }
+
+        if (bmap && hasBotsInVehicles)
+        {
+            for (BotMap::const_iterator ci = bmap->begin(); ci != bmap->end(); ++ci)
+            {
+                Creature* bot = ci->second;
+                if (bot && bot->GetVehicle())
+                {
+                    bool doeject = false;
+                    if (!botsInSelVehicle)
+                        doeject = true;
+                    else if (target)
+                        if (/*VehicleSeatEntry const* seat = */target->GetVehicleKit()->GetSeatForPassenger(bot))
+                            //if (seat->CanEnterOrExit())
+                                doeject = true;
+
+                    if (doeject)
+                    {
+                        bot->GetVehicle()->GetBase()->StopMoving();
+                        //handler->PSendSysMessage("Removing %s from %s", bot->GetName().c_str(), bot->GetVehicle()->GetBase()->GetName().c_str());
+                        bot->ExitVehicle();
+                        //bot->BotStopMovement();
+                    }
+                }
+            }
+            return true;
+        }
+
+        handler->SendSysMessage(".npcbot eject");
+        handler->SendSysMessage("Removes your bots from selected vehicle, or, all bots from any vehicles if no vehicle selected");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotFollowDistanceCommand(ChatHandler* handler, Optional<int32> dist)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot() || !dist)
+        {
+            handler->SendSysMessage(".npcbot distance #[attack] #newdist");
+            handler->SendSysMessage("Sets follow / attack distance for bots");
+            return true;
+        }
+
+        uint8 newdist = uint8(std::min<int32>(std::max<int32>(*dist, 0), 100));
+        owner->GetBotMgr()->SetBotFollowDist(newdist);
+
+        handler->PSendSysMessage("Bots' follow distance is set to %u", uint32(newdist));
+        return true;
+    }
+
+    static bool HandleNpcBotAttackDistanceShortCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot distance attack short");
+            handler->SendSysMessage("Sets attack distance for bots");
+            return true;
+        }
+
+        owner->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_SHORT);
+
+        handler->SendSysMessage("Bots' attack distance is set to 'short'");
+        return true;
+    }
+
+    static bool HandleNpcBotAttackDistanceLongCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot distance attack long");
+            handler->SendSysMessage("Sets attack distance for bots");
+            return true;
+        }
+
+        owner->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_LONG);
+
+        handler->SendSysMessage("Bots' attack distance is set to 'long'");
+        return true;
+    }
+
+    static bool HandleNpcBotAttackDistanceExactCommand(ChatHandler* handler, Optional<int32> dist)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot() || !dist)
+        {
+            handler->SendSysMessage(".npcbot distance attack #newdist");
+            handler->SendSysMessage("Sets attack distance for bots");
+            return true;
+        }
+
+        uint8 newdist = uint8(std::min<int32>(std::max<int32>(*dist, 0), 50));
+        owner->GetBotMgr()->SetBotAttackRangeMode(BOT_ATTACK_RANGE_EXACT, newdist);
+
+        handler->PSendSysMessage("Bots' attack distance is set to %u", uint32(newdist));
+        return true;
+    }
+
+    static bool HandleNpcBotHideCommand(ChatHandler* handler)
+    {
+        // Hiding/unhiding bots should be allowed only out of combat
+        // Currenly bots can teleport to master in combat
+        // This creates potential for some serious trolls
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot hide");
+            handler->SendSysMessage("Removes your owned npcbots from world temporarily");
+            //handler->SendSysMessage("You have no bots!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->SetBotsHidden(true);
+        handler->SendSysMessage("Bots hidden");
+        return true;
+    }
+
+    static bool HandleNpcBotUnhideCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot unhide | show");
+            handler->SendSysMessage("Returns your temporarily hidden bots back");
+            //handler->SendSysMessage("You have no bots!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat() && (owner->IsPvP() || owner->IsFFAPvP()))
+        {
+            handler->GetSession()->SendNotification("You can't do that while in PvP combat");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->SetBotsHidden(false);
+        handler->SendSysMessage("Bots unhidden");
+        return true;
+    }
+
+    static bool HandleNpcBotKillCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid || !owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot kill | suicide");
+            handler->SendSysMessage("Makes your npcbot just drop dead. If you select yourself ALL your bots will die");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (guid == owner->GetGUID())
+        {
+            owner->GetBotMgr()->KillAllBots();
+            return true;
+        }
+        if (Creature* bot = owner->GetBotMgr()->GetBot(guid))
+        {
+            owner->GetBotMgr()->KillBot(bot);
+            return true;
+        }
+
+        handler->SendSysMessage("You must select one of your bots or yourself");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotSendToCommand(ChatHandler* handler, Optional<std::vector<std::string_view>> names)
+    {
+        static auto return_syntax = [](ChatHandler* chandler) -> bool {
+            chandler->SendSysMessage("Syntax: .npcbot sendto");
+            chandler->SendSysMessage("Makes selected bot wait 30 sec for your next DEST spell, assume that position and hold it");
+            chandler->SendSysMessage("Select self to move ALL bots");
+            chandler->SendSysMessage("Max distance is 70 yds");
+            chandler->SetSentErrorMessage(true);
+            return false;
+        };
+
+        static auto return_success = [](ChatHandler* chandler, Variant<std::string_view, uint32> name_or_count) -> bool {
+            if (name_or_count.holds_alternative<uint32>())
+                chandler->PSendSysMessage("Your next dest spell will send %u bot(s) to position...", name_or_count.get<uint32>());
+            else
+                chandler->PSendSysMessage("Your next dest spell will send %s to position...", name_or_count.get<std::string_view>().data());
+            return true;
+        };
+
+        Player const* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+            return return_syntax(handler);
+
+        if (!names || names->empty())
+        {
+            Unit const* target = handler->getSelectedCreature();
+            Creature const* bot = target ? owner->GetBotMgr()->GetBot(target->GetGUID()) : nullptr;
+            if (bot && bot->IsAlive())
+            {
+                bot->GetBotAI()->SetBotAwaitState(BOT_AWAIT_SEND);
+                return return_success(handler, { bot->GetName() });
+            }
+            return return_syntax(handler);
+        }
+
+        uint32 count = 0;
+        for (decltype(names)::value_type::value_type name : *names)
+        {
+            Creature const* bot = owner->GetBotMgr()->GetBotByName(name);
+            if (bot && bot->IsAlive())
+            {
+                ++count;
+                bot->GetBotAI()->SetBotAwaitState(BOT_AWAIT_SEND);
+            }
+        }
+
+        if (count == 0)
+        {
+            handler->PSendSysMessage("Unable to send any of %u bots!", uint32(names->size()));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        return return_success(handler, { count });
+    }
+
+    static bool HandleNpcBotRecallCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid || !owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot recall");
+            handler->SendSysMessage("Forces npcbots to move directly on your position. Select a npcbot you want to move or select yourself to move all bots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat())
+        {
+            handler->GetSession()->SendNotification(LANG_YOU_IN_COMBAT);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (guid == owner->GetGUID())
+        {
+            owner->GetBotMgr()->RecallAllBots();
+            return true;
+        }
+        if (Creature* bot = owner->GetBotMgr()->GetBot(guid))
+        {
+            owner->GetBotMgr()->RecallBot(bot);
+            return true;
+        }
+
+        handler->SendSysMessage("You must select one of your bots or yourself");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRecallTeleportCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot recall teleport");
+            handler->SendSysMessage("Forces all your npcbots to teleport to your position");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsAlive())
+        {
+            handler->GetSession()->SendNotification("You are dead");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetBotMgr()->IsPartyInCombat() && (owner->IsPvP() || owner->IsFFAPvP()))
+        {
+            handler->GetSession()->SendNotification("You can't do that while in PvP combat");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        owner->GetBotMgr()->RecallAllBots(true);
+        return true;
+    }
+
+    static bool HandleNpcBotToggleFlagsCommand(ChatHandler* handler, Optional<uint32> flag)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* unit = chr->GetSelectedUnit();
+        if (!unit || unit->GetTypeId() != TYPEID_UNIT || !flag)
+        {
+            handler->SendSysMessage(".npcbot toggle flags #flag");
+            handler->SendSysMessage("This is a debug command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint32 setFlags = 0;
+        switch (*flag)
+        {
+            case 6:
+                setFlags = UNIT_FLAG_UNK_6;
+                break;
+            case 14:
+                setFlags = UNIT_FLAG_CANNOT_SWIM;
+                break;
+            case 15:
+                setFlags = UNIT_FLAG_CAN_SWIM;
+                break;
+            case 16:
+                setFlags = UNIT_FLAG_NON_ATTACKABLE_2;
+                break;
+            default:
+                break;
+        }
+
+        if (!setFlags)
+            return false;
+
+        handler->PSendSysMessage("Toggling flag %u on %s", setFlags, unit->GetName().c_str());
+        unit->ToggleFlag(UNIT_FIELD_FLAGS, setFlags);
+        return true;
+    }
+
+    static bool HandleNpcBotSetFactionCommand(ChatHandler* handler, Optional<std::string> factionStr)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !factionStr)
+        {
+            handler->SendSysMessage(".npcbot set faction #faction");
+            handler->SendSysMessage("Sets faction for selected npcbot (saved in DB)");
+            handler->SendSysMessage("Use 'a', 'h', 'm' or 'f' as argument to set faction to alliance, horde, monsters (hostile to all) or friends (friendly to all)");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot() || !bot->IsFreeBot())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint32 factionId = 0;
+
+        if ((*factionStr)[0] == 'a')
+            factionId = 1802; //Alliance
+        else if ((*factionStr)[0] == 'h')
+            factionId = 1801; //Horde
+        else if ((*factionStr)[0] == 'm')
+            factionId = 14; //Monsters
+        else if ((*factionStr)[0] == 'f')
+            factionId = 35; //Friendly to all
+
+        if (!factionId)
+        {
+            char* pfactionid = handler->extractKeyFromLink((char*)factionStr->c_str(), "Hfaction");
+            factionId = atoi(pfactionid);
+        }
+
+        if (!sFactionTemplateStore.LookupEntry(factionId))
+        {
+            handler->PSendSysMessage(LANG_WRONG_FACTION, factionId);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_FACTION, &factionId);
+        bot->GetBotAI()->ReInitFaction();
+
+        handler->PSendSysMessage("%s's faction set to %u", bot->GetName().c_str(), factionId);
+        return true;
+    }
+
+    static bool HandleNpcBotSetOwnerCommand(ChatHandler* handler, Optional<std::string> charVal)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !charVal)
+        {
+            handler->SendSysMessage(".npcbot set owner #guid | #name");
+            handler->SendSysMessage("Binds selected npcbot to new player owner using guid or name and updates owner in DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("You must select a npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("This npcbot already has owner");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* characterName_str = strtok((char*)charVal->c_str(), " ");
+        if (!characterName_str)
+            return false;
+
+        std::string characterName = characterName_str;
+        uint32 guidlow = (uint32)atoi(characterName_str);
+
+        bool found = true;
+        if (guidlow)
+            found = sCharacterCache->GetCharacterNameByGuid(ObjectGuid(HighGuid::Player, 0, guidlow), characterName);
+        else
+            guidlow = sCharacterCache->GetCharacterGuidByName(characterName).GetCounter();
+
+        if (!guidlow || !found)
+        {
+            handler->SendSysMessage("Player not found");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &guidlow);
+        bot->GetBotAI()->ReinitOwner();
+        //bot->GetBotAI()->Reset();
+
+        handler->PSendSysMessage("%s's new owner is %s (guidlow: %u)", bot->GetName().c_str(), characterName.c_str(), guidlow);
+        return true;
+    }
+
+    static bool HandleNpcBotSetSpecCommand(ChatHandler* handler, Optional<uint8> spec)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !spec)
+        {
+            handler->SendSysMessage(".npcbot set spec #specnumber");
+            handler->SendSysMessage("Changes talent spec for selected npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("You must select a npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!bot_ai::IsValidSpecForClass(bot->GetBotClass(), *spec))
+        {
+            handler->PSendSysMessage("%s is not a valid spec for bot class %u!",
+                bot_ai::LocalizedNpcText(chr, bot_ai::TextForSpec(*spec)), uint32(bot->GetBotClass()));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->GetBotAI()->SetSpec(*spec);
+
+        handler->PSendSysMessage("%s's new spec is %u", bot->GetName().c_str(), uint32(*spec));
+        return true;
+    }
+
+    static bool HandleNpcBotLookupCommand(ChatHandler* handler, Optional<uint8> botclass, Optional <bool> unspawned)
+    {
+        //this is just a modified '.lookup creature' command
+        if (!botclass)
+        {
+            handler->SendSysMessage(".npcbot lookup #class #[not_spawned_only]");
+            handler->SendSysMessage("Looks up npcbots by #class, and returns all matches with their creature ID's");
+            handler->SendSysMessage("If #not_spawned_only is set to 1 shows only bots which don't exist in world");
+            handler->PSendSysMessage("BOT_CLASS_WARRIOR = %u", uint32(BOT_CLASS_WARRIOR));
+            handler->PSendSysMessage("BOT_CLASS_PALADIN = %u", uint32(BOT_CLASS_PALADIN));
+            handler->PSendSysMessage("BOT_CLASS_HUNTER = %u", uint32(BOT_CLASS_HUNTER));
+            handler->PSendSysMessage("BOT_CLASS_ROGUE = %u", uint32(BOT_CLASS_ROGUE));
+            handler->PSendSysMessage("BOT_CLASS_PRIEST = %u", uint32(BOT_CLASS_PRIEST));
+            handler->PSendSysMessage("BOT_CLASS_DEATH_KNIGHT = %u", uint32(BOT_CLASS_DEATH_KNIGHT));
+            handler->PSendSysMessage("BOT_CLASS_SHAMAN = %u", uint32(BOT_CLASS_SHAMAN));
+            handler->PSendSysMessage("BOT_CLASS_MAGE = %u", uint32(BOT_CLASS_MAGE));
+            handler->PSendSysMessage("BOT_CLASS_WARLOCK = %u", uint32(BOT_CLASS_WARLOCK));
+            handler->PSendSysMessage("BOT_CLASS_DRUID = %u", uint32(BOT_CLASS_DRUID));
+            handler->PSendSysMessage("BOT_CLASS_BLADEMASTER = %u", uint32(BOT_CLASS_BM));
+            handler->PSendSysMessage("BOT_CLASS_SPHYNX = %u", uint32(BOT_CLASS_SPHYNX));
+            handler->PSendSysMessage("BOT_CLASS_ARCHMAGE = %u", uint32(BOT_CLASS_ARCHMAGE));
+            handler->PSendSysMessage("BOT_CLASS_DREADLORD = %u", uint32(BOT_CLASS_DREADLORD));
+            handler->PSendSysMessage("BOT_CLASS_SPELLBREAKER = %u", uint32(BOT_CLASS_SPELLBREAKER));
+            handler->PSendSysMessage("BOT_CLASS_DARK_RANGER = %u", uint32(BOT_CLASS_DARK_RANGER));
+            handler->PSendSysMessage("BOT_CLASS_NECROMANCER = %u", uint32(BOT_CLASS_NECROMANCER));
+            handler->PSendSysMessage("BOT_CLASS_SEA_WITCH = %u", uint32(BOT_CLASS_SEA_WITCH));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (botclass == BOT_CLASS_NONE || botclass >= BOT_CLASS_END)
+        {
+            handler->PSendSysMessage("Unknown bot class %u", uint32(*botclass));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Looking for bots of class %u...", uint32(*botclass));
+
+        uint8 localeIndex = handler->GetSessionDbLocaleIndex();
+        CreatureTemplateContainer const& ctc = sObjectMgr->GetCreatureTemplates();
+        typedef std::vector<BotInfo> BotList;
+        BotList botlist;
+        for (CreatureTemplateContainer::const_iterator itr = ctc.begin(); itr != ctc.end(); ++itr)
+        {
+            uint32 id = itr->second.Entry;
+
+            if (id == BOT_ENTRY_MIRROR_IMAGE_BM)
+                continue;
+            //Blademaster disabled
+            if (botclass == BOT_CLASS_BM)
+                continue;
+
+            NpcBotExtras const* _botExtras = BotDataMgr::SelectNpcBotExtras(id);
+            if (!_botExtras || _botExtras->bclass != botclass)
+                continue;
+
+            if (unspawned && *unspawned && BotDataMgr::SelectNpcBotData(id))
+                continue;
+
+            uint8 race = _botExtras->race;
+
+            if (CreatureLocale const* creatureLocale = sObjectMgr->GetCreatureLocale(id))
+            {
+                if (creatureLocale->Name.size() > localeIndex && !creatureLocale->Name[localeIndex].empty())
+                {
+                    botlist.emplace_back(id, std::string(creatureLocale->Name[localeIndex]), race);
+                    continue;
+                }
+            }
+
+            std::string name = itr->second.Name;
+            if (name.empty())
+                continue;
+
+            botlist.emplace_back(id, std::move(name), race);
+        }
+
+        if (botlist.empty())
+        {
+            handler->SendSysMessage(LANG_COMMAND_NOCREATUREFOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::sort(botlist.begin(), botlist.end(), script_bot_commands::sortbots);
+
+        for (BotList::const_iterator itr = botlist.begin(); itr != botlist.end(); ++itr)
+        {
+            uint8 race = itr->race;
+            if (race >= MAX_RACES)
+                race = RACE_NONE;
+
+            std::string_view raceName;
+            switch (race)
+            {
+                case RACE_HUMAN:        raceName = "Human";     break;
+                case RACE_ORC:          raceName = "Orc";       break;
+                case RACE_DWARF:        raceName = "Dwarf";     break;
+                case RACE_NIGHTELF:     raceName = "Night Elf"; break;
+                case RACE_UNDEAD_PLAYER:raceName = "Forsaken";  break;
+                case RACE_TAUREN:       raceName = "Tauren";    break;
+                case RACE_GNOME:        raceName = "Gnome";     break;
+                case RACE_TROLL:        raceName = "Troll";     break;
+                case RACE_BLOODELF:     raceName = "Blood Elf"; break;
+                case RACE_DRAENEI:      raceName = "Draenei";   break;
+                case RACE_NONE:         raceName = "No Race";   break;
+                default:                raceName = "Unknown";   break;
+            }
+
+            handler->PSendSysMessage("%d - |cffffffff|Hcreature_entry:%d|h[%s]|h|r %s", itr->id, itr->id, itr->name.c_str(), raceName);
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteCommand(ChatHandler* handler)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot)
+        {
+            handler->SendSysMessage(".npcbot delete");
+            handler->SendSysMessage("Deletes selected npcbot spawn from world and DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("No npcbot selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player const* botowner = bot->GetBotOwner()->ToPlayer();
+
+        ObjectGuid receiver =
+            botowner ? botowner->GetGUID() :
+            bot->GetBotAI()->GetBotOwnerGuid() != 0 ? ObjectGuid(HighGuid::Player, 0, bot->GetBotAI()->GetBotOwnerGuid()) :
+            chr->GetGUID();
+        if (!bot->GetBotAI()->UnEquipAll(receiver))
+        {
+            handler->PSendSysMessage("%s is unable to unequip some gear. Please remove equips before deleting bot!", bot->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (botowner)
+            botowner->GetBotMgr()->RemoveBot(bot->GetGUID(), BOT_REMOVE_DISMISS);
+
+        bot->CombatStop();
+        bot->GetBotAI()->Reset();
+        bot->GetBotAI()->canUpdate = false;
+        Creature::DeleteFromDB(bot->GetSpawnId());
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_ERASE);
+
+        handler->PSendSysMessage("Npcbot %s successfully deleted", bot->GetName().c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteByIdCommand(ChatHandler* handler, Optional<uint32> creature_id)
+    {
+        if (!creature_id)
+        {
+            handler->SendSysMessage(".npcbot delete id");
+            handler->SendSysMessage("Deletes npcbot spawn from world and DB using creature id");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature const* bot = BotDataMgr::FindBot(*creature_id);
+        if (!bot)
+        {
+            handler->PSendSysMessage("npcbot %u not found!", *creature_id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = !handler->IsConsole() ? handler->GetSession()->GetPlayer() : nullptr;
+        Player const* botowner = bot->GetBotOwner()->ToPlayer();
+
+        if (bot->GetBotAI()->HasRealEquipment())
+        {
+            ObjectGuid receiver =
+                botowner ? botowner->GetGUID() :
+                bot->GetBotAI()->GetBotOwnerGuid() != 0 ? ObjectGuid(HighGuid::Player, 0, bot->GetBotAI()->GetBotOwnerGuid()) :
+                chr ? chr->GetGUID() : ObjectGuid::Empty;
+            if (receiver == ObjectGuid::Empty)
+            {
+                handler->PSendSysMessage("Cannot delete bot %s from console: has gear but no player to give it back to! Can only delete this bot in-game.", bot->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (!bot->GetBotAI()->UnEquipAll(receiver))
+            {
+                handler->PSendSysMessage("%s is unable to unequip some gear. Please remove equips before deleting bot!", bot->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+        }
+
+        if (botowner)
+            botowner->GetBotMgr()->RemoveBot(bot->GetGUID(), BOT_REMOVE_DISMISS);
+
+        const_cast<Creature*>(bot)->CombatStop();
+        bot->GetBotAI()->Reset();
+        bot->GetBotAI()->canUpdate = false;
+        Creature::DeleteFromDB(bot->GetSpawnId());
+
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_ERASE);
+
+        handler->PSendSysMessage("Npcbot %s successfully deleted", bot->GetName().c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteFreeCommand(ChatHandler* handler)
+    {
+        uint32 count = 0;
+        for (uint32 creature_id : BotDataMgr::GetExistingNPCBotIds())
+            if (NpcBotData const* botData = BotDataMgr::SelectNpcBotData(creature_id))
+                if (botData->owner == 0)
+                    if (HandleNpcBotDeleteByIdCommand(handler, creature_id))
+                        ++count;
+
+        handler->PSendSysMessage("%u free npcbots deleted", count);
+        return true;
+    }
+
+    static bool HandleNpcBotMoveCommand(ChatHandler* handler, Optional<std::string> creVal)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        Creature* creature = handler->getSelectedCreature();
+
+        if (!creature && !creVal)
+        {
+            handler->SendSysMessage(".npcbot move");
+            handler->SendSysMessage("Moves npcbot to your location");
+            handler->SendSysMessage("Syntax: .npcbot move [#ID]");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* charID = creVal ? handler->extractKeyFromLink((char*)creVal->c_str(), "Hcreature_entry") : nullptr;
+        if (!charID && !creature)
+            return false;
+
+        uint32 id = charID ? atoi(charID) : creature->GetEntry();
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+        if (!creInfo)
+        {
+            handler->PSendSysMessage("creature id %u does not exist!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+            handler->PSendSysMessage("creature id %u is not a npcbot!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!BotDataMgr::SelectNpcBotData(id))
+        {
+            handler->PSendSysMessage("NpcBot %u is not spawned!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature const* bot = BotDataMgr::FindBot(id);
+        ASSERT(bot);
+
+        uint32 lowguid = bot->GetSpawnId();
+
+        CreatureData const* data = sObjectMgr->GetCreatureData(lowguid);
+        if (!data)
+        {
+            handler->PSendSysMessage(LANG_COMMAND_CREATGUIDNOTFOUND, lowguid);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        CreatureData* cdata = const_cast<CreatureData*>(data);
+        cdata->spawnPoint.Relocate(player);
+        cdata->spawnPoint.SetOrientation(player->GetOrientation());
+        cdata->mapId = player->GetMapId();
+
+        WorldDatabase.PExecute(
+            "UPDATE creature SET position_x = %.3f, position_y = %.3f, position_z = %.3f, orientation = %.3f, map = %u WHERE guid = %u",
+            cdata->spawnPoint.GetPositionX(), cdata->spawnPoint.GetPositionY(), cdata->spawnPoint.GetPositionZ(), cdata->spawnPoint.GetOrientation(), uint32(cdata->mapId), lowguid);
+
+        if (bot->GetBotAI()->IAmFree() && bot->IsInWorld() && !bot->IsInCombat() && bot->IsAlive())
+            BotMgr::TeleportBot(const_cast<Creature*>(bot), player->GetMap(), player);
+
+        handler->PSendSysMessage("NpcBot %u (guid %u) was moved", id, lowguid);
+        return true;
+    }
+
+    static bool HandleNpcBotCreateNewCommand(ChatHandler* handler, Optional<std::string_view> name, Optional<uint8> bclass, Optional<uint8> race, Optional<uint8> gender, Optional<uint8> skin, Optional<uint8> face, Optional<uint8> hairstyle, Optional<uint8> haircolor, Optional<uint8> features, Optional<uint8> soundset)
+    {
+        static auto const ret_err = [](ChatHandler* handler) {
+            handler->SendSysMessage(".npcbot createnew");
+            handler->SendSysMessage("Creates a new npcbot creature entry");
+            handler->SendSysMessage("Syntax: .npcbot createnew #name #class ##race ##gender ##skin ##face ##hairstyle ##haircolor ##features ##[sound_variant = {1,2,3}]");
+            handler->SendSysMessage("In case of class that cannot change appearance all extra arguments must be omitted");
+            handler->SetSentErrorMessage(true);
+            return false;
+        };
+        static auto const ret_err_invalid_arg = [](ChatHandler* handler, char const* argname, Optional<uint8> argval = {}) {
+            handler->PSendSysMessage("Invalid %s%s!", argname, argval ?  (" " + std::to_string(*argval)).c_str() : "");
+            handler->SetSentErrorMessage(true);
+            return false;
+        };
+        static auto const ret_err_invalid_args_for = [](ChatHandler* handler, char const* argname1, char const* argname2) {
+            handler->PSendSysMessage("Invalid arguments for %s '%s'!", argname1, argname2);
+            handler->SetSentErrorMessage(true);
+            return false;
+        };
+
+        if (!bclass || !name)
+            return ret_err(handler);
+
+        bool const can_change_appearance = (*bclass < BOT_CLASS_EX_START || *bclass == BOT_CLASS_ARCHMAGE);
+
+        if (can_change_appearance && (!race || !gender || !skin || !face || !hairstyle || !haircolor || !features))
+            return ret_err(handler);
+        if (!can_change_appearance && (race || gender || skin || face || hairstyle || haircolor || features))
+            return ret_err(handler);
+        if (soundset && (*soundset < 1 || *soundset > SOUND_SETS_COUNT))
+            return ret_err(handler);
+
+        if (*bclass >= BOT_CLASS_END || (*bclass < BOT_CLASS_EX_START && !((1u << (*bclass - 1)) & CLASSMASK_ALL_PLAYABLE)))
+            return ret_err_invalid_arg(handler, "class", bclass);
+
+        std::string namestr;
+        normalizePlayerName(namestr);
+        if (!consoleToUtf8(*name, namestr))
+            return ret_err_invalid_arg(handler, "name");
+        namestr[0] = std::toupper(namestr[0]);
+
+        if (race && !((1u << (*race - 1)) & RACEMASK_ALL_PLAYABLE))
+            return ret_err_invalid_arg(handler, "race", race);
+
+        if (can_change_appearance && *gender != GENDER_MALE && *gender != GENDER_FEMALE)
+            return ret_err_invalid_arg(handler, "gender", gender);
+
+        // class / race combination check
+        if ((*bclass < BOT_CLASS_EX_START && !sObjectMgr->GetPlayerInfo(*race, *bclass)) ||
+            (*bclass == BOT_CLASS_ARCHMAGE && *race != RACE_HUMAN))
+            return ret_err_invalid_args_for(handler, "class", GetClassName(*bclass, handler->GetSessionDbcLocale()));
+
+#define GENDER_PRED2(male,female) ((male == female || *gender == GENDER_MALE) ? male : female)
+        if (can_change_appearance)
+        {
+            static const auto ret_race_err = [](ChatHandler* handler, uint8 race) {
+                return ret_err_invalid_args_for(handler, "race", GetRaceName(race, handler->GetSessionDbcLocale()));
+            };
+            switch (*race)
+            {
+                case RACE_HUMAN:
+                    if (*skin > 9 || *face > GENDER_PRED2(11, 14) || *hairstyle > GENDER_PRED2(16, 23) || *haircolor > 9 || *features > GENDER_PRED2(8, 6))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_DWARF:
+                    if (*skin > 8 || *face > GENDER_PRED2(9,9) || *hairstyle > GENDER_PRED2(15,18) || *haircolor > 9 || *features > GENDER_PRED2(10,5))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_NIGHTELF:
+                    if (*skin > 8 || *face > GENDER_PRED2(8,8) || *hairstyle > GENDER_PRED2(11,11) || *haircolor > 7 || *features > GENDER_PRED2(5,9))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_GNOME:
+                    if (*skin > 4 || *face > GENDER_PRED2(6,6) || *hairstyle > GENDER_PRED2(11,11) || *haircolor > 8 || *features > GENDER_PRED2(7,6))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_DRAENEI:
+                    if (*skin > 13 || *face > GENDER_PRED2(9,9) || *hairstyle > GENDER_PRED2(13,15) || *haircolor > 6 || *features > GENDER_PRED2(7,6))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_ORC:
+                    if (*skin > 8 || *face > GENDER_PRED2(8,8) || *hairstyle > GENDER_PRED2(11,12) || *haircolor > 7 || *features > GENDER_PRED2(10,6))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_UNDEAD_PLAYER:
+                    if (*skin > 5 || *face > GENDER_PRED2(9,9) || *hairstyle > GENDER_PRED2(14,14) || *haircolor > 9 || *features > GENDER_PRED2(16,7))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_TAUREN:
+                    if (*skin > GENDER_PRED2(18,10) || *face > GENDER_PRED2(4,3) || *hairstyle > GENDER_PRED2(12,11) || *haircolor > 2 || *features > GENDER_PRED2(6,4))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_TROLL:
+                    if (*skin > 5 || *face > GENDER_PRED2(4,5) || *hairstyle > GENDER_PRED2(9,9) || *haircolor > 9 || *features > GENDER_PRED2(10,5))
+                        return ret_race_err(handler, *race);
+                    break;
+                case RACE_BLOODELF:
+                    if (*skin > 9 || *face > GENDER_PRED2(9,9) || *hairstyle > GENDER_PRED2(15,18) || *haircolor > 9 || *features > GENDER_PRED2(9,10))
+                        return ret_race_err(handler, *race);
+                    break;
+                default:
+                    return ret_err_invalid_arg(handler, "race", race);
+            }
+        }
+#undef GENDER_PRED2
+
+        //here we force races for custom classes
+        switch (*bclass)
+        {
+            case BOT_CLASS_BM:
+            case BOT_CLASS_SPHYNX:
+            case BOT_CLASS_DREADLORD:
+            case BOT_CLASS_SPELLBREAKER:
+                race = 15; //RACE_SKELETON
+                break;
+            case BOT_CLASS_NECROMANCER:
+                race = RACE_HUMAN;
+                break;
+            case BOT_CLASS_DARK_RANGER:
+                race = RACE_BLOODELF;
+                break;
+            case BOT_CLASS_SEA_WITCH:
+                race = 13; //RACE_NAGA
+                break;
+        }
+
+        //get normalized modelID
+        uint32 modelId = can_change_appearance ? SoundSetModelsArray[RaceToRaceOffset[*race]][*gender][soundset ? *soundset - 1 : urand(0u, 2u)] : 0;
+
+        uint32 newentry = 0;
+        QueryResult creres = WorldDatabase.PQuery("SELECT entry FROM creature_template WHERE entry = %u", BOT_ENTRY_CREATE_BEGIN);
+        if (!creres)
+            newentry = BOT_ENTRY_CREATE_BEGIN;
+        else
+        {
+            creres = WorldDatabase.PQuery("SELECT MIN(entry) FROM creature_template WHERE entry >= %u AND entry IN (SELECT entry FROM creature_template) AND entry+1 NOT IN (SELECT entry FROM creature_template)", BOT_ENTRY_CREATE_BEGIN);
+            ASSERT(creres);
+            Field* field = creres->Fetch();
+            newentry = field[0].GetUInt32() + 1;
+        }
+
+        WorldDatabaseTransaction trans = WorldDatabase.BeginTransaction();
+        trans->Append("DROP TEMPORARY TABLE IF EXISTS creature_template_temp_npcbot_create");
+        trans->PAppend("CREATE TEMPORARY TABLE creature_template_temp_npcbot_create ENGINE=MEMORY SELECT * FROM creature_template WHERE entry = (SELECT entry FROM creature_template_npcbot_extras WHERE class = %u LIMIT 1)", uint32(*bclass));
+        trans->PAppend("UPDATE creature_template_temp_npcbot_create SET entry = %u, name = \"%s\"", newentry, namestr.c_str());
+        if (modelId)
+            trans->PAppend("UPDATE creature_template_temp_npcbot_create SET modelid1 = %u", modelId);
+        trans->Append("INSERT INTO creature_template SELECT * FROM creature_template_temp_npcbot_create");
+        trans->Append("DROP TEMPORARY TABLE creature_template_temp_npcbot_create");
+        trans->PAppend("INSERT INTO creature_template_npcbot_extras VALUES (%u, %u, %u)", newentry, uint32(*bclass), uint32(*race));
+        trans->PAppend("INSERT INTO creature_equip_template SELECT %u, 1, ids.itemID1, ids.itemID2, ids.itemID3, -1 FROM (SELECT itemID1, itemID2, itemID3 FROM creature_equip_template WHERE CreatureID = (SELECT entry FROM creature_template_npcbot_extras WHERE class = %u LIMIT 1)) ids", newentry, uint32(*bclass));
+        if (can_change_appearance)
+            trans->PAppend("INSERT INTO creature_template_npcbot_appearance VALUES (%u, \"%s\", %u, %u, %u, %u, %u, %u)",
+                newentry, namestr.c_str(), uint32(*gender), uint32(*skin), uint32(*face), uint32(*hairstyle), uint32(*haircolor), uint32(*features));
+        WorldDatabase.DirectCommitTransaction(trans);
+
+        handler->PSendSysMessage("New NPCBot %s (class %u) is created with entry %u and will be available for spawning after server restart.", namestr.c_str(), uint32(*bclass), newentry);
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnCommand(ChatHandler* handler, Optional<std::string> creVal)
+    {
+        if (!creVal)
+        {
+            handler->SendSysMessage(".npcbot spawn");
+            handler->SendSysMessage("Adds new npcbot spawn of given entry in world. You can shift-link the npc");
+            handler->SendSysMessage("Syntax: .npcbot spawn #entry");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* charID = handler->extractKeyFromLink((char*)creVal->c_str(), "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        uint32 id = uint32(atoi(charID));
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!creInfo)
+        {
+            handler->PSendSysMessage("creature %u does not exist!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+            handler->PSendSysMessage("creature %u is not a npcbot!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (BotDataMgr::SelectNpcBotData(id))
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to move this bot to a new location use '.npcbot move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        WorldDatabasePreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (/*Transport* trans = */chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        //float x = chr->GetPositionX();
+        //float y = chr->GetPositionY();
+        //float z = chr->GetPositionZ();
+        //float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, chr->GetPhaseMaskForSpawn(), id, *chr))
+        {
+            delete creature;
+            handler->SendSysMessage("Creature is not created!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        NpcBotExtras const* _botExtras = BotDataMgr::SelectNpcBotExtras(id);
+        if (!_botExtras)
+        {
+            handler->PSendSysMessage("No class/race data found for bot %u!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotDataMgr::AddNpcBotData(id, bot_ai::DefaultRolesForClass(_botExtras->bclass), bot_ai::DefaultSpecForClass(_botExtras->bclass), creature->GetCreatureTemplate()->faction);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetSpawnId();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("NpcBot successfully spawned");
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnedCommand(ChatHandler* handler)
+    {
+        std::unique_lock<std::shared_mutex> lock(*BotDataMgr::GetLock());
+        NpcBotRegistry const& all_bots = BotDataMgr::GetExistingNPCBots();
+        std::stringstream ss;
+        if (all_bots.empty())
+            ss << "No spawned bots found!";
+        else
+        {
+            ss << "Found " << uint32(all_bots.size()) << " bots:";
+            uint32 counter = 0;
+            for (Creature const* bot : all_bots)
+            {
+                ++counter;
+
+                std::string bot_color_str;
+                std::string bot_class_str;
+                GetBotClassNameAndColor(bot->GetBotClass(), bot_color_str, bot_class_str);
+
+                AreaTableEntry const* zone = sAreaTableStore.LookupEntry(bot->GetBotAI()->GetLastZoneId() ? bot->GetBotAI()->GetLastZoneId() : bot->GetZoneId());
+                std::string zone_name = zone ? zone->AreaName[handler->GetSession() ? handler->GetSessionDbLocaleIndex() : 0] : "Unknown";
+
+                ss << "\n" << counter << ") " << bot->GetEntry() << ": "
+                    << bot->GetName() << " - |c" << bot_color_str << bot_class_str << "|r - "
+                    << "level " << uint32(bot->GetLevel()) << " - \"" << zone_name << "\" - "
+                    << (bot->IsFreeBot() ? (bot->GetBotAI()->GetBotOwnerGuid() ? "inactive (owned)" : "free") : "active");
+            }
+        }
+
+        handler->SendSysMessage(ss.str().c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnedFreeCommand(ChatHandler* handler)
+    {
+        std::unique_lock<std::shared_mutex> lock(*BotDataMgr::GetLock());
+        NpcBotRegistry const& all_bots = BotDataMgr::GetExistingNPCBots();
+        //using std::remove_if with sets requires c++20
+        std::vector<NpcBotRegistry::value_type> free_bots;
+        free_bots.reserve(all_bots.size());
+        for (Creature const* bot : all_bots)
+            if (BotDataMgr::SelectNpcBotData(bot->GetEntry())->owner == 0)
+                free_bots.push_back(bot);
+        std::stringstream ss;
+        if (free_bots.empty())
+            ss << "No free bots found!";
+        else
+        {
+            ss << "Found " << uint32(free_bots.size()) << " free bots:";
+            uint32 counter = 0;
+            for (Creature const* bot : free_bots)
+            {
+                ++counter;
+
+                std::string bot_color_str;
+                std::string bot_class_str;
+                GetBotClassNameAndColor(bot->GetBotClass(), bot_color_str, bot_class_str);
+
+                AreaTableEntry const* zone = sAreaTableStore.LookupEntry(bot->GetBotAI()->GetLastZoneId() ? bot->GetBotAI()->GetLastZoneId() : bot->GetZoneId());
+                std::string zone_name = zone ? zone->AreaName[handler->GetSession() ? handler->GetSessionDbLocaleIndex() : 0] : "Unknown";
+
+                ss << '\n' << counter << ") " << bot->GetEntry() << ": "
+                    << bot->GetName() << " - |c" << bot_color_str << bot_class_str << "|r - "
+                    << "level " << uint32(bot->GetLevel()) << " - \"" << zone_name << '"'
+                    << (bot->GetBotAI()->HasRealEquipment() ? " |cff00ffff(has equipment!)|r" : "");
+            }
+        }
+
+        handler->SendSysMessage(ss.str().c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->SendSysMessage(".npcbot info");
+            handler->SendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master)
+        {
+            handler->SendSysMessage("No player selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (handler->HasLowerSecurity(master, ObjectGuid::Empty))
+        {
+            handler->SendSysMessage("Invalid target");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = BOT_CLASS_WARRIOR; i != BOT_CLASS_END; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                if (Creature* cre = itr->second)
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+
+            char const* bclass;
+            switch (i)
+            {
+                case BOT_CLASS_WARRIOR:         bclass = "Warriors";        break;
+                case BOT_CLASS_PALADIN:         bclass = "Paladins";        break;
+                case BOT_CLASS_MAGE:            bclass = "Mages";           break;
+                case BOT_CLASS_PRIEST:          bclass = "Priests";         break;
+                case BOT_CLASS_WARLOCK:         bclass = "Warlocks";        break;
+                case BOT_CLASS_DRUID:           bclass = "Druids";          break;
+                case BOT_CLASS_DEATH_KNIGHT:    bclass = "Death Knights";   break;
+                case BOT_CLASS_ROGUE:           bclass = "Rogues";          break;
+                case BOT_CLASS_SHAMAN:          bclass = "Shamans";         break;
+                case BOT_CLASS_HUNTER:          bclass = "Hunters";         break;
+                case BOT_CLASS_BM:              bclass = "Blademasters";    break;
+                case BOT_CLASS_SPHYNX:          bclass = "Destroyers";      break;
+                case BOT_CLASS_ARCHMAGE:        bclass = "Archmagi";        break;
+                case BOT_CLASS_DREADLORD:       bclass = "Dreadlords";      break;
+                case BOT_CLASS_SPELLBREAKER:    bclass = "Spell Breakers";  break;
+                case BOT_CLASS_DARK_RANGER:     bclass = "Dark Rangers";    break;
+                case BOT_CLASS_NECROMANCER:     bclass = "Necromancers";    break;
+                case BOT_CLASS_SEA_WITCH:       bclass = "Sea Witches";     break;
+                default:                        bclass = "Unknown Class";   break;
+            }
+            handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotCommandStandstillCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command standstill");
+            handler->SendSysMessage("Forces your npcbots to stop all movement and remain stationed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        Unit* target = owner->GetSelectedUnit();
+        if (target && owner->GetBotMgr()->GetBot(target->GetGUID()))
+        {
+            target->ToCreature()->GetBotAI()->SetBotCommandState(BOT_COMMAND_STAY);
+            msg = target->GetName() + "'s command state set to 'STAY'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_STAY);
+            msg = "Bots' command state set to 'STAY'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotCommandStopfullyCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command stopfully");
+            handler->SendSysMessage("Forces your npcbots to stop all activity");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        Unit* target = owner->GetSelectedUnit();
+        if (target && owner->GetBotMgr()->GetBot(target->GetGUID()))
+        {
+            target->ToCreature()->GetBotAI()->SetBotCommandState(BOT_COMMAND_FULLSTOP);
+            msg = target->GetName() + "'s command state set to 'FULLSTOP'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_FULLSTOP);
+            msg = "Bots' command state set to 'FULLSTOP'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotCommandFollowCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command follow");
+            handler->SendSysMessage("Allows npcbots to follow you again if stopped");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        Unit* target = owner->GetSelectedUnit();
+        if (target && owner->GetBotMgr()->GetBot(target->GetGUID()))
+        {
+            target->ToCreature()->GetBotAI()->SetBotCommandState(BOT_COMMAND_FOLLOW);
+            msg = target->GetName() + "'s command state set to 'FOLLOW'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_FOLLOW);
+            msg = "Bots' command state set to 'FOLLOW'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotCommandWalkCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+
+        if (!owner->HaveBot())
+        {
+            handler->SendSysMessage(".npcbot command walk");
+            handler->SendSysMessage("Toggles walk mode for your npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        std::string msg;
+        bool isWalking = owner->GetBotMgr()->GetBotMap()->begin()->second->GetBotAI()->HasBotCommandState(BOT_COMMAND_WALK);
+        if (!isWalking)
+        {
+            owner->GetBotMgr()->SendBotCommandState(BOT_COMMAND_WALK);
+            msg = "Bots' movement mode is set to 'WALK'";
+        }
+        else
+        {
+            owner->GetBotMgr()->SendBotCommandStateRemove(BOT_COMMAND_WALK);
+            msg = "Bots' movement mode is set to 'RUN'";
+        }
+
+        handler->SendSysMessage(msg.c_str());
+        return true;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot remove");
+            handler->SendSysMessage("Frees selected npcbot from it's owner. Select player to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* master = u->ToPlayer();
+        if (master)
+        {
+            if (master->HaveBot())
+            {
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+
+                if (!master->HaveBot())
+                {
+                    handler->SendSysMessage("Npcbots were successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->SendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->SendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = u->ToCreature();
+        if (cre && cre->IsNPCBot() && !cre->IsFreeBot())
+        {
+            master = cre->GetBotOwner();
+            master->GetBotMgr()->RemoveBot(cre->GetGUID(), BOT_REMOVE_DISMISS);
+            if (master->GetBotMgr()->GetBot(cre->GetGUID()) == nullptr)
+            {
+                handler->SendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->SendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->SendSysMessage("You must select player or controlled npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot revive");
+            handler->SendSysMessage("Revives selected npcbot. If player is selected, revives all selected player's npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* master = u->ToPlayer())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("%s has no npcbots!", master->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+
+            master->GetBotMgr()->ReviveAllBots();
+            handler->SendSysMessage("Npcbots revived");
+            return true;
+        }
+        else if (Creature* bot = u->ToCreature())
+        {
+            if (bot->GetBotAI())
+            {
+                if (bot->IsAlive())
+                {
+                    handler->PSendSysMessage("%s is not dead", bot->GetName().c_str());
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+
+                BotMgr::ReviveBot(bot, (bot->GetBotOwner() == owner) ? owner->ToUnit() : bot->ToUnit());
+                handler->PSendSysMessage("%s revived", bot->GetName().c_str());
+                return true;
+            }
+        }
+
+        handler->SendSysMessage("You must select player or npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* cre = owner->GetSelectedUnit();
+
+        if (!cre || cre->GetTypeId() != TYPEID_UNIT)
+        {
+            handler->SendSysMessage(".npcbot add");
+            handler->SendSysMessage("Allows to hire selected uncontrolled bot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = cre->ToCreature();
+        if (!bot || !bot->IsNPCBot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotMgr* mgr = owner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(owner);
+
+        if (mgr->AddBot(bot, false) == BOT_ADD_SUCCESS)
+        {
+            handler->PSendSysMessage("%s is now your npcbot", bot->GetName().c_str());
+            return true;
+        }
+
+        handler->SendSysMessage("NpcBot is NOT added for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotReloadConfigCommand(ChatHandler* handler)
+    {
+        TC_LOG_INFO("misc", "Re-Loading config settings...");
+        sWorld->LoadConfigSettings(true);
+        sMapMgr->InitializeVisibilityDistanceInfo();
+        handler->SendGlobalGMSysMessage("World config settings reloaded.");
+        BotMgr::ReloadConfig();
+        handler->SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+        return true;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botcommon.h b/src/server/game/AI/NpcBots/botcommon.h
new file mode 100644
index 000000000..cdebf9870
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommon.h
@@ -0,0 +1,564 @@
+#ifndef _BOTCOMMON_H
+#define _BOTCOMMON_H
+
+#include "SharedDefines.h"
+#include "SpellAuraDefines.h"
+
+#include <utility>
+#include <vector>
+
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+struct Position;
+
+typedef std::vector<std::pair<Position, float> > AoeSpotsVec;
+typedef std::vector<Position> AoeSafeSpotsVec;
+
+enum BotCommonValues
+{
+//MISC
+    BOT_GIVER_ENTRY                     = 70000,
+    BOT_ENTRY_BEGIN                     = 70001,
+    //BOT_ENTRY_END                       = 71000,
+    BOT_ENTRY_CREATE_BEGIN              = 70800, // 70800+ reserved for bot creation
+    //BOT_PET_ENTRY_BEGIN                 = 70501,
+    //BOT_PET_ENTRY_END                   = 70550,
+    BOT_ENTRY_MIRROR_IMAGE_BM           = 70552,
+    BOT_MAX_CHASE_RANGE                 = 120,  //yds
+    //BOT_EVADE_TIME                      = 3000, //ms
+//COMMON GAMEOBJECTS
+    GO_REFRESHMENT_TABLE_1              = 186812,//lvl 65 req70
+    GO_REFRESHMENT_TABLE_2              = 193061,//lvl 80 req80
+    GO_SOULWELL_1                       = 181621,//lvl 60 req68
+    GO_SOULWELL_2                       = 193169,//lvl 69 req80
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    REGEN_CD                            = 1000, //update hp/mana every X milliseconds
+//COMMON TIMERS
+    ITEM_ENCHANTMENT_EXPIRE_TIMER       = 3600000, //1 Hour
+//VEHICLE CREATURES
+    CREATURE_NEXUS_SKYTALON_1           = 32535, // [Q] Aces High
+    CREATURE_EOE_SKYTALON_N             = 30161, // Eye of Eternity
+    CREATURE_EOE_SKYTALON_H             = 31752,
+    CREATURE_OCULUS_DRAKE_RUBY          = 27756, // Oculus
+    CREATURE_OCULUS_DRAKE_EMERALD       = 27692,
+    CREATURE_OCULUS_DRAKE_AMBER         = 27755,
+    //CREATURE_TOC_STEED_QUELDOREI        = 33845, // Argent Tournament
+    //CREATURE_TOC_NIGHTSABER             = 33319,
+    //CREATURE_TOC_STEED_STORMWIND        = 33217,
+    //CREATURE_TOC_MECHANOSTRIDER         = 33317,
+    //CREATURE_TOC_RAM                    = 33316,
+    //CREATURE_TOC_ELEKK                  = 33318,
+    //CREATURE_TOC_HAWKSTRIDER_SUNREAVER  = 33844,
+    //CREATURE_TOC_RAPTOR                 = 33321,
+    //CREATURE_TOC_WARHORSE               = 33324,
+    //CREATURE_TOC_WOLF                   = 33320,
+    //CREATURE_TOC_HAWKSTRIDER_SILVERMOON = 33323,
+    //CREATURE_TOC_KODO                   = 33322,
+    CREATURE_TOC5_WARHORSE              = 35644, // Trial of Champion
+    CREATURE_TOC5_BATTLEWORG            = 36558,
+    CREATURE_ULDUAR_DEMOLISHER          = 33109, // Ulduar
+    CREATURE_ULDUAR_SIEGE_ENGINE        = 33060,
+    CREATURE_ULDUAR_CHOPPER             = 33062,
+    CREATURE_ULDUAR_CHOPPER1            = 34045,
+    CREATURE_ICC_BONE_SPIKE1            = 36619, // Icecrown Citadel
+    CREATURE_ICC_BONE_SPIKE2            = 38712,
+    CREATURE_ICC_BONE_SPIKE3            = 38711,
+    CREATURE_ICC_GUNSHIPCANNON_ALLIANCE = 36838,
+    CREATURE_ICC_GUNSHIPCANNON_HORDE    = 36839,
+    CREATURE_ICC_MUTATED_ABOMINATION1   = 38285,
+    CREATURE_ICC_MUTATED_ABOMINATION2   = 38788,
+    CREATURE_ICC_MUTATED_ABOMINATION3   = 38789,
+    CREATURE_ICC_MUTATED_ABOMINATION4   = 38790,
+    CREATURE_ICC_MUTATED_ABOMINATION5   = 37672,
+    CREATURE_ICC_MUTATED_ABOMINATION6   = 38605,
+    CREATURE_ICC_MUTATED_ABOMINATION7   = 38786,
+    CREATURE_ICC_MUTATED_ABOMINATION8   = 38787,
+//COMMON AOE TRIGGERS
+    CREATURE_ZA_FIRE_BOMB               = 23920,
+    CREATURE_EOE_STATIC_FIELD           = 30592,
+    CREATURE_ICC_OOZE_PUDDLE            = 37690,
+//COMMON ENEMY CREATURES
+    CREATURE_BOSS_EREGOS_N              = 27656,
+    CREATURE_BOSS_EREGOS_H              = 31561,
+    CREATURE_ICC_SINDRAGOSA1            = 36853,
+    CREATURE_ICC_SINDRAGOSA2            = 38265,
+    CREATURE_ICC_SINDRAGOSA3            = 38266,
+    CREATURE_ICC_SINDRAGOSA4            = 38267,
+    CREATURE_ICC_ICE_TOMB1              = 36980,
+    CREATURE_ICC_ICE_TOMB2              = 38320,
+    CREATURE_ICC_ICE_TOMB3              = 38321,
+    CREATURE_ICC_ICE_TOMB4              = 38322,
+    CREATURE_ICC_VALKYR_LK1             = 36609,
+    CREATURE_ICC_VALKYR_LK2             = 39120,
+    CREATURE_ICC_VALKYR_LK3             = 39121,
+    CREATURE_ICC_VALKYR_LK4             = 39122,
+    CREATURE_ICC_ICE_SPHERE1            = 36633,
+    CREATURE_ICC_ICE_SPHERE2            = 39305,
+    CREATURE_ICC_ICE_SPHERE3            = 39306,
+    CREATURE_ICC_ICE_SPHERE4            = 39307,
+//COMMON NPCS
+    SHAMAN_EARTH_ELEMENTAL              = 15352,
+    SHAMAN_FIRE_ELEMENTAL               = 15438,
+    //NPC_WORLD_TRIGGER                   = 22515,
+//COMMON ITEM DISPLAY IDS
+    CHEST_HALISCAN                      = 50566, //Haliscan Jacket
+    LEGS_HALISCAN                       = 50567, //Haliscan Pants
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON FACTIONS
+    FACTION_TEMPLATE_HATES_EVERYTHING_1 = 2150, //faction 966 - Monster spar buddy
+//COMMON AI MISC VALUES
+    BOTAI_MISC_COMBO_POINTS             = 1,
+    BOTAI_MISC_DAGGER_MAINHAND,
+    BOTAI_MISC_DAGGER_OFFHAND,
+    BOTAI_MISC_ENCHANT_IS_AUTO_MH,
+    BOTAI_MISC_ENCHANT_IS_AUTO_OH,
+    BOTAI_MISC_ENCHANT_CAN_EXPIRE_MH,
+    BOTAI_MISC_ENCHANT_CAN_EXPIRE_OH,
+    BOTAI_MISC_ENCHANT_CURRENT_MH,
+    BOTAI_MISC_ENCHANT_CURRENT_OH,
+    BOTAI_MISC_ENCHANT_AVAILABLE_1,
+    BOTAI_MISC_ENCHANT_AVAILABLE_2,
+    BOTAI_MISC_ENCHANT_AVAILABLE_3,
+    BOTAI_MISC_ENCHANT_AVAILABLE_4,
+    BOTAI_MISC_ENCHANT_AVAILABLE_5,
+    BOTAI_MISC_ENCHANT_AVAILABLE_6,
+    BOTAI_MISC_PET_TYPE,
+    BOTAI_MISC_PET_AVAILABLE_1,
+    BOTAI_MISC_PET_AVAILABLE_2,
+    BOTAI_MISC_PET_AVAILABLE_3,
+    BOTAI_MISC_PET_AVAILABLE_4,
+    BOTAI_MISC_PET_AVAILABLE_5,
+    BOTAI_MISC_PET_AVAILABLE_6,
+    BOTAI_MISC_PET_AVAILABLE_7,
+    BOTAI_MISC_PET_AVAILABLE_8,
+    BOTAI_MISC_PET_AVAILABLE_9,
+    BOTAI_MISC_PET_AVAILABLE_10,
+    BOTAI_MISC_PET_AVAILABLE_11,
+    BOTAI_MISC_WEAPON_SPEC,
+    BOTPETAI_MISC_DURATION,
+    BOTPETAI_MISC_MAXLEVEL,
+  //SOUNDS
+    SOUND_FREEZE_IMPACT_WINDWALK        = 29,
+    SOUND_AXE_2H_IMPACT_FLESH_CRIT      = 158,
+    SOUND_ABSORB_GET_HIT                = 3334,
+    SOUND_MISS_WHOOSH_2H                = 7081,
+
+//UNUSED
+    //SPELL_SUMMON_FELBLAZE_PREVISUAL     = 46350,//green splash impact head/torso
+
+//OTHER
+    BASE_MANA_SPHYNX                    = 400 * 5,
+    BASE_MANA_SPELLBREAKER              = 250 * 5,
+    BASE_MANA_NECROMANCER               = 400 * 5,
+    //base mana at 10
+    BASE_MANA_10_BM                     = 540 * 5,
+    BASE_MANA_10_ARCHMAGE               = 705 * 5,
+    BASE_MANA_10_DREADLORD              = 600 * 5,
+    BASE_MANA_10_DARK_RANGER            = 570 * 5,
+    BASE_MANA_10_SEA_WITCH              = 735 * 5,
+    //base mana at 1
+    BASE_MANA_1_BM                      = 240 * 5,
+    BASE_MANA_1_ARCHMAGE                = 285 * 5,
+    BASE_MANA_1_DREADLORD               = 270 * 5,
+    BASE_MANA_1_DARK_RANGER             = 225 * 5,
+    BASE_MANA_1_SEA_WITCH               = 330 * 5,
+
+    //MAX_LOOT_ITEMS                      = 18 // Client limitation 3.3.5 code confirmed
+};
+
+enum BotClasses : uint8
+{
+    BOT_CLASS_NONE                      = CLASS_NONE,
+    BOT_CLASS_WARRIOR                   = CLASS_WARRIOR,
+    BOT_CLASS_PALADIN                   = CLASS_PALADIN,
+    BOT_CLASS_HUNTER                    = CLASS_HUNTER,
+    BOT_CLASS_ROGUE                     = CLASS_ROGUE,
+    BOT_CLASS_PRIEST                    = CLASS_PRIEST,
+    BOT_CLASS_DEATH_KNIGHT              = CLASS_DEATH_KNIGHT,
+    BOT_CLASS_SHAMAN                    = CLASS_SHAMAN,
+    BOT_CLASS_MAGE                      = CLASS_MAGE,
+    BOT_CLASS_WARLOCK                   = CLASS_WARLOCK,
+    BOT_CLASS_DRUID                     = CLASS_DRUID,
+
+    BOT_CLASS_BM,
+    BOT_CLASS_SPHYNX,
+    BOT_CLASS_ARCHMAGE,
+    BOT_CLASS_DREADLORD,
+    BOT_CLASS_SPELLBREAKER,
+    BOT_CLASS_DARK_RANGER,
+    BOT_CLASS_NECROMANCER,
+    BOT_CLASS_SEA_WITCH,
+
+    BOT_CLASS_END,
+
+    BOT_CLASS_EX_START                  = BOT_CLASS_BM
+};
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = BOT_CLASS_END,
+    WARRIOR_DEFENSIVE_STANCE,
+    WARRIOR_BERSERKER_STANCE,
+    DEATH_KNIGHT_BLOOD_PRESENCE,
+    DEATH_KNIGHT_FROST_PRESENCE,
+    DEATH_KNIGHT_UNHOLY_PRESENCE,
+    DRUID_BEAR_FORM,
+    DRUID_CAT_FORM,
+    DRUID_MOONKIN_FORM,
+    DRUID_TREE_FORM,
+    DRUID_TRAVEL_FORM,
+    DRUID_AQUATIC_FORM,
+    //DRUID_FLIGHT_FORM //NYI
+};
+
+enum BotRoles : uint32
+{
+    BOT_ROLE_NONE                       = 0x00000,
+    BOT_ROLE_TANK                       = 0x00001,
+    BOT_ROLE_TANK_OFF                   = 0x00002,
+    BOT_ROLE_DPS                        = 0x00004,
+    BOT_ROLE_HEAL                       = 0x00008,
+    BOT_ROLE_RANGED                     = 0x00010,
+
+    BOT_ROLE_PARTY                      = 0x00020, //hidden
+
+    BOT_ROLE_GATHERING_MINING           = 0x00040,
+    BOT_ROLE_GATHERING_HERBALISM        = 0x00080,
+    BOT_ROLE_GATHERING_SKINNING         = 0x00100,
+    BOT_ROLE_GATHERING_ENGINEERING      = 0x00200,
+
+    BOT_ROLE_AUTOLOOT                   = 0x00400, //not in mask
+    BOT_ROLE_AUTOLOOT_POOR              = 0x00800,
+    BOT_ROLE_AUTOLOOT_COMMON            = 0x01000,
+    BOT_ROLE_AUTOLOOT_UNCOMMON          = 0x02000,
+    BOT_ROLE_AUTOLOOT_RARE              = 0x04000,
+    BOT_ROLE_AUTOLOOT_EPIC              = 0x08000,
+    BOT_ROLE_AUTOLOOT_LEGENDARY         = 0x10000,
+
+    BOT_MAX_ROLE                        = 0x20000,
+
+    BOT_ROLE_MASK_MAIN                  = (BOT_ROLE_TANK | BOT_ROLE_TANK_OFF | BOT_ROLE_DPS | BOT_ROLE_HEAL | BOT_ROLE_RANGED),
+    //BOT_ROLE_MASK_MAIN_EX               = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL | BOT_ROLE_RANGED | BOT_ROLE_PARTY),
+    BOT_ROLE_MASK_GATHERING             = (BOT_ROLE_GATHERING_MINING | BOT_ROLE_GATHERING_HERBALISM | BOT_ROLE_GATHERING_SKINNING | BOT_ROLE_GATHERING_ENGINEERING),
+    BOT_ROLE_MASK_LOOTING               = (BOT_ROLE_AUTOLOOT_POOR | BOT_ROLE_AUTOLOOT_COMMON | BOT_ROLE_AUTOLOOT_UNCOMMON | BOT_ROLE_AUTOLOOT_RARE | BOT_ROLE_AUTOLOOT_EPIC | BOT_ROLE_AUTOLOOT_LEGENDARY),
+
+    //BOT_ROLE_TANK_MELEE                 = (BOT_ROLE_TANK | BOT_ROLE_DPS),
+    //BOT_ROLE_TANK_RANGED                = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_RANGED),
+    //BOT_ROLE_TANK_RANGED_NODPS          = (BOT_ROLE_TANK | BOT_ROLE_RANGED),
+};
+
+enum BotTalentSpecs
+{
+    BOT_SPEC_WARRIOR_ARMS               = 1,
+    BOT_SPEC_WARRIOR_FURY               = 2,
+    BOT_SPEC_WARRIOR_PROTECTION         = 3,
+    BOT_SPEC_PALADIN_HOLY               = 4,
+    BOT_SPEC_PALADIN_PROTECTION         = 5,
+    BOT_SPEC_PALADIN_RETRIBUTION        = 6,
+    BOT_SPEC_HUNTER_BEASTMASTERY        = 7,
+    BOT_SPEC_HUNTER_MARKSMANSHIP        = 8,
+    BOT_SPEC_HUNTER_SURVIVAL            = 9,
+    BOT_SPEC_ROGUE_ASSASINATION         = 10,
+    BOT_SPEC_ROGUE_COMBAT               = 11,
+    BOT_SPEC_ROGUE_SUBTLETY             = 12,
+    BOT_SPEC_PRIEST_DISCIPLINE          = 13,
+    BOT_SPEC_PRIEST_HOLY                = 14,
+    BOT_SPEC_PRIEST_SHADOW              = 15,
+    BOT_SPEC_DK_BLOOD                   = 16,
+    BOT_SPEC_DK_FROST                   = 17,
+    BOT_SPEC_DK_UNHOLY                  = 18,
+    BOT_SPEC_SHAMAN_ELEMENTAL           = 19,
+    BOT_SPEC_SHAMAN_ENHANCEMENT         = 20,
+    BOT_SPEC_SHAMAN_RESTORATION         = 21,
+    BOT_SPEC_MAGE_ARCANE                = 22,
+    BOT_SPEC_MAGE_FIRE                  = 23,
+    BOT_SPEC_MAGE_FROST                 = 24,
+    BOT_SPEC_WARLOCK_AFFLICTION         = 25,
+    BOT_SPEC_WARLOCK_DEMONOLOGY         = 26,
+    BOT_SPEC_WARLOCK_DESTRUCTION        = 27,
+    BOT_SPEC_DRUID_BALANCE              = 28,
+    BOT_SPEC_DRUID_FERAL                = 29,
+    BOT_SPEC_DRUID_RESTORATION          = 30,
+    BOT_SPEC_DEFAULT                    = 31,
+
+    BOT_SPEC_BEGIN                      = BOT_SPEC_WARRIOR_ARMS,
+    BOT_SPEC_END                        = BOT_SPEC_DEFAULT
+
+};
+
+enum BotPetTypes
+{
+    //Warlock
+    BOT_PET_IMP                         = 70501,
+    BOT_PET_VOIDWALKER                  = 70502,
+    BOT_PET_SUCCUBUS                    = 70503,
+    BOT_PET_FELHUNTER                   = 70504,
+    BOT_PET_FELGUARD                    = 70505,
+
+    BOT_PET_WARLOCK_START               = BOT_PET_IMP,
+    BOT_PET_WARLOCK_END                 = BOT_PET_FELGUARD,
+
+    //Hunter
+    //cunning
+    BOT_PET_SPIDER                      = 70506,
+    BOT_PET_SERPENT                     = 70507,
+    BOT_PET_BIRDOFPREY                  = 70508,
+    BOT_PET_BAT                         = 70509,
+    BOT_PET_WINDSERPENT                 = 70510,
+    BOT_PET_RAVAGER                     = 70511,
+    BOT_PET_DRAGONHAWK                  = 70512,
+    BOT_PET_NETHERRAY                   = 70513,
+    BOT_PET_SPOREBAT                    = 70514,
+    //ferocity
+    BOT_PET_CARRIONBIRD                 = 70515,
+    BOT_PET_RAPTOR                      = 70516,
+    BOT_PET_WOLF                        = 70517,
+    BOT_PET_TALLSTRIDER                 = 70518,
+    BOT_PET_CAT                         = 70519,
+    BOT_PET_HYENA                       = 70520,
+    BOT_PET_WASP                        = 70521,
+    BOT_PET_TEROMOTH                    = 70522,
+    //tenacity
+    BOT_PET_SCORPID                     = 70523,
+    BOT_PET_TURTLE                      = 70524,
+    BOT_PET_GORILLA                     = 70525,
+    BOT_PET_BEAR                        = 70526,
+    BOT_PET_BOAR                        = 70527,
+    BOT_PET_CRAB                        = 70528,
+    BOT_PET_CROCOLISK                   = 70529,
+    BOT_PET_WARPSTALKER                 = 70530,
+    //cunning (exotic)
+    BOT_PET_SILITHID                    = 70531,
+    BOT_PET_CHIMAERA                    = 70532,
+    //ferocity (exotic)
+    BOT_PET_SPIRITBEAST                 = 70533,
+    BOT_PET_COREHOUND                   = 70534,
+    BOT_PET_DEVILSAUR                   = 70535,
+    //tenacity (exotic)
+    BOT_PET_RHINO                       = 70536,
+    BOT_PET_WORM                        = 70537,
+
+    BOT_PET_HUNTER_START                = BOT_PET_SPIDER,
+    BOT_PET_HUNTER_END_GENERAL          = BOT_PET_WARPSTALKER,
+    BOT_PET_HUNTER_END_EXOTIC           = BOT_PET_WORM,
+
+    BOT_PET_CUNNING_START               = BOT_PET_SPIDER,
+    BOT_PET_CUNNING_END                 = BOT_PET_SPOREBAT,
+    BOT_PET_FEROCITY_START              = BOT_PET_CARRIONBIRD,
+    BOT_PET_FEROCITY_END                = BOT_PET_TEROMOTH,
+    BOT_PET_TENACITY_START              = BOT_PET_SCORPID,
+    BOT_PET_TENACITY_END                = BOT_PET_WARPSTALKER,
+
+    BOT_PET_EXOTIC_START                = BOT_PET_SILITHID,
+    BOT_PET_EXOTIC_END                  = BOT_PET_WORM,
+
+    //DK
+    BOT_PET_GHOUL                       = 70538,
+    BOT_PET_GARGOYLE                    = 70539,//NYI
+    BOT_PET_DANCING_RUNE_WEAPON         = 70540,//NYI
+    BOT_PET_AOD_GHOUL                   = 70541,//NYI
+
+    //Priest
+    BOT_PET_SHADOWFIEND                 = 70542,
+
+    //Shaman
+    BOT_PET_SPIRIT_WOLF                 = 70543,
+
+    //Mage
+    BOT_PET_WATER_ELEMENTAL             = 70544,
+
+    //Druid
+    BOT_PET_FORCE_OF_NATURE             = 70545,
+
+    //Archmage
+    BOT_PET_AWATER_ELEMENTAL            = 70556,
+
+    //Dreadlord
+    BOT_PET_INFERNAL                    = 70562,
+
+    //Dark Ranger
+    BOT_PET_DARK_MINION                 = 70573,
+    BOT_PET_DARK_MINION_ELITE           = 70574,
+
+    //Necromancer
+    BOT_PET_NECROSKELETON               = 70580,
+
+    BOT_PET_TORNADO                     = 70586,
+
+    BOT_PET_INVALID                     = 99999
+};
+
+enum BotPetOriginalEntries
+{
+    ORIGINAL_ENTRY_IMP                  = 416,
+    ORIGINAL_ENTRY_VOIDWALKER           = 1860,
+    ORIGINAL_ENTRY_SUCCUBUS             = 1863,
+    ORIGINAL_ENTRY_FELHUNTER            = 417,
+    ORIGINAL_ENTRY_FELGUARD             = 17252,
+    //ORIGINAL_ENTRY_GHOUL                = 26125,
+    //ORIGINAL_ENTRY_SHADOWFIEND          = 19668,
+    //ORIGINAL_ENTRY_SPIRIT_WOLF          = 29264,
+    ORIGINAL_ENTRY_WATER_ELEMENTAL      = 510,
+    //ORIGINAL_ENTRY_FORCE_OF_NATURE      = 1964,
+    ORIGINAL_ENTRY_HUNTER_PET           = 1 // from Pet.cpp InitStatsForLevel()
+};
+
+enum BotEquipSlot : uint8
+{
+    BOT_SLOT_MAINHAND           = 0,
+    BOT_SLOT_OFFHAND            = 1,
+    BOT_SLOT_RANGED             = 2,
+    BOT_SLOT_HEAD               = 3,
+    BOT_SLOT_SHOULDERS          = 4,
+    BOT_SLOT_CHEST              = 5,
+    BOT_SLOT_WAIST              = 6,
+    BOT_SLOT_LEGS               = 7,
+    BOT_SLOT_FEET               = 8,
+    BOT_SLOT_WRIST              = 9,
+    BOT_SLOT_HANDS              = 10,
+    BOT_SLOT_BACK               = 11,
+    BOT_SLOT_BODY               = 12,
+    BOT_SLOT_FINGER1            = 13,
+    BOT_SLOT_FINGER2            = 14,
+    BOT_SLOT_TRINKET1           = 15,
+    BOT_SLOT_TRINKET2           = 16,
+    BOT_SLOT_NECK               = 17,
+    BOT_INVENTORY_SIZE
+};
+
+constexpr uint8 BOT_TRANSMOG_INVENTORY_SIZE = 13; // BOT_SLOT_BODY + 1
+
+enum BotStatMods : uint8
+{
+    //ItemProtoType.h
+    BOT_STAT_MOD_MANA                       = 0,
+    BOT_STAT_MOD_HEALTH                     = 1,
+    BOT_STAT_MOD_AGILITY                    = 3,
+    BOT_STAT_MOD_STRENGTH                   = 4,
+    BOT_STAT_MOD_INTELLECT                  = 5,
+    BOT_STAT_MOD_SPIRIT                     = 6,
+    BOT_STAT_MOD_STAMINA                    = 7,
+    BOT_STAT_MOD_DEFENSE_SKILL_RATING       = 12,
+    BOT_STAT_MOD_DODGE_RATING               = 13,
+    BOT_STAT_MOD_PARRY_RATING               = 14,
+    BOT_STAT_MOD_BLOCK_RATING               = 15,
+    BOT_STAT_MOD_HIT_MELEE_RATING           = 16,
+    BOT_STAT_MOD_HIT_RANGED_RATING          = 17,
+    BOT_STAT_MOD_HIT_SPELL_RATING           = 18,
+    BOT_STAT_MOD_CRIT_MELEE_RATING          = 19,
+    BOT_STAT_MOD_CRIT_RANGED_RATING         = 20,
+    BOT_STAT_MOD_CRIT_SPELL_RATING          = 21,
+    BOT_STAT_MOD_HIT_TAKEN_MELEE_RATING     = 22,
+    BOT_STAT_MOD_HIT_TAKEN_RANGED_RATING    = 23,
+    BOT_STAT_MOD_HIT_TAKEN_SPELL_RATING     = 24,
+    BOT_STAT_MOD_CRIT_TAKEN_MELEE_RATING    = 25,
+    BOT_STAT_MOD_CRIT_TAKEN_RANGED_RATING   = 26,
+    BOT_STAT_MOD_CRIT_TAKEN_SPELL_RATING    = 27,
+    BOT_STAT_MOD_HASTE_MELEE_RATING         = 28,
+    BOT_STAT_MOD_HASTE_RANGED_RATING        = 29,
+    BOT_STAT_MOD_HASTE_SPELL_RATING         = 30,
+    BOT_STAT_MOD_HIT_RATING                 = 31,
+    BOT_STAT_MOD_CRIT_RATING                = 32,
+    BOT_STAT_MOD_HIT_TAKEN_RATING           = 33,
+    BOT_STAT_MOD_CRIT_TAKEN_RATING          = 34,
+    BOT_STAT_MOD_RESILIENCE_RATING          = 35,
+    BOT_STAT_MOD_HASTE_RATING               = 36,
+    BOT_STAT_MOD_EXPERTISE_RATING           = 37,
+    BOT_STAT_MOD_ATTACK_POWER               = 38,
+    BOT_STAT_MOD_RANGED_ATTACK_POWER        = 39,
+    BOT_STAT_MOD_FERAL_ATTACK_POWER         = 40,
+    BOT_STAT_MOD_SPELL_HEALING_DONE         = 41,                 // deprecated
+    BOT_STAT_MOD_SPELL_DAMAGE_DONE          = 42,                 // deprecated
+    BOT_STAT_MOD_MANA_REGENERATION          = 43,
+    BOT_STAT_MOD_ARMOR_PENETRATION_RATING   = 44,
+    BOT_STAT_MOD_SPELL_POWER                = 45,
+    BOT_STAT_MOD_HEALTH_REGEN               = 46,
+    BOT_STAT_MOD_SPELL_PENETRATION          = 47,
+    BOT_STAT_MOD_BLOCK_VALUE                = 48,
+    //END ItemProtoType.h
+
+    BOT_STAT_MOD_DAMAGE_MIN                 = BOT_STAT_MOD_BLOCK_VALUE + 1,
+    BOT_STAT_MOD_DAMAGE_MAX,
+    BOT_STAT_MOD_ARMOR,
+    BOT_STAT_MOD_RESIST_HOLY,
+    BOT_STAT_MOD_RESIST_FIRE,
+    BOT_STAT_MOD_RESIST_NATURE,
+    BOT_STAT_MOD_RESIST_FROST,
+    BOT_STAT_MOD_RESIST_SHADOW,
+    BOT_STAT_MOD_RESIST_ARCANE,
+    BOT_STAT_MOD_EX,
+    MAX_BOT_ITEM_MOD,
+
+    BOT_STAT_MOD_RESISTANCE_START           = BOT_STAT_MOD_ARMOR
+};
+
+enum BotAIResetType
+{
+    BOTAI_RESET_INIT                    = 0x01,
+    BOTAI_RESET_DISMISS                 = 0x02,
+    BOTAI_RESET_LOST                    = 0x04,
+    BOTAI_RESET_LOGOUT                  = 0x08,
+
+    BOTAI_RESET_MASK_ABANDON_MASTER     = (BOTAI_RESET_INIT | BOTAI_RESET_DISMISS)
+};
+
+enum BotMovementType
+{
+    BOT_MOVE_POINT                      = 1,
+    //BOT_MOVE_FOLLOW
+    BOT_MOVE_CHASE
+};
+
+enum BotCommandStates
+{
+    BOT_COMMAND_STAY                    = 0x01,
+    BOT_COMMAND_FOLLOW                  = 0x02,
+    BOT_COMMAND_ATTACK                  = 0x04,
+    BOT_COMMAND_COMBATRESET             = 0x08,
+    BOT_COMMAND_FULLSTOP                = 0x10,
+    BOT_COMMAND_ISSUED_ORDER            = 0x20,
+    BOT_COMMAND_WALK                    = 0x40,
+
+    BOT_COMMAND_MASK_UNCHASE            = BOT_COMMAND_STAY | BOT_COMMAND_FOLLOW | BOT_COMMAND_FULLSTOP,
+    BOT_COMMAND_MASK_UNMOVING           = BOT_COMMAND_STAY | BOT_COMMAND_FULLSTOP | BOT_COMMAND_ISSUED_ORDER
+};
+
+enum BotAwaitStates
+{
+    BOT_AWAIT_NONE                      = 0x00,
+    BOT_AWAIT_SEND                      = 0x01
+};
+
+#define FROM_ARRAY(arr) arr, arr + sizeof(arr) / sizeof(arr[0])
+
+//Only non-persistent types are allowed
+enum BotOrderTypes
+{
+    BOT_ORDER_NONE          = 0,
+    BOT_ORDER_SPELLCAST     = 1
+};
+#define DEBUG_BOT_ORDERS 0
+#define MAX_BOT_ORDERS_QUEUE_SIZE 3
+
+enum BotVehicleStrats
+{
+    BOT_VEH_STRAT_NONE,
+    BOT_VEH_STRAT_WYRMREST_SKYTALON,
+    BOT_VEH_STRAT_RUBY_DRAKE,
+    BOT_VEH_STRAT_EMERALD_DRAKE,
+    BOT_VEH_STRAT_AMBER_DRAKE,
+    BOT_VEH_STRAT_TOC5_MOUNT,
+    BOT_VEH_STRAT_ULDUAR_DEMOLISHER,
+    BOT_VEH_STRAT_ULDUAR_SIEGEENGINE,
+    BOT_VEH_STRAT_ULDUAR_CHOPPER,
+
+    BOT_VEH_STRAT_GENERIC
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botdatamgr.cpp b/src/server/game/AI/NpcBots/botdatamgr.cpp
new file mode 100644
index 000000000..1172ca13c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdatamgr.cpp
@@ -0,0 +1,709 @@
+#include "botdatamgr.h"
+#include "Creature.h"
+#include "DatabaseEnv.h"
+#include "GroupMgr.h"
+#include "Item.h"
+#include "Log.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "StringConvert.h"
+#include "WorldDatabase.h"
+/*
+Npc Bot Data Manager by Trickerer (onlysuffering@gmail.com)
+NpcBots DB Data management
+%Complete: ???
+*/
+
+typedef std::unordered_map<uint32 /*entry*/, NpcBotData*> NpcBotDataMap;
+typedef std::unordered_map<uint32 /*entry*/, NpcBotAppearanceData*> NpcBotAppearanceDataMap;
+typedef std::unordered_map<uint32 /*entry*/, NpcBotExtras*> NpcBotExtrasMap;
+typedef std::unordered_map<uint32 /*entry*/, NpcBotTransmogData*> NpcBotTransmogDataMap;
+NpcBotDataMap _botsData;
+NpcBotAppearanceDataMap _botsAppearanceData;
+NpcBotExtrasMap _botsExtras;
+NpcBotTransmogDataMap _botsTransmogData;
+NpcBotRegistry _existingBots;
+
+bool allBotsLoaded = false;
+
+std::shared_mutex* BotDataMgr::GetLock()
+{
+    static std::shared_mutex _lock;
+    return &_lock;
+}
+
+bool BotDataMgr::AllBotsLoaded()
+{
+    return allBotsLoaded;
+}
+
+void BotDataMgr::LoadNpcBots(bool spawn)
+{
+    if (allBotsLoaded)
+        return;
+
+    uint32 botoldMSTime = getMSTime();
+
+    TC_LOG_INFO("server.loading", "Starting NpcBot system...");
+
+    Field* field;
+    uint8 index;
+
+    //                                                      1       2     3     4     5          6
+    QueryResult result = WorldDatabase.Query("SELECT entry, gender, skin, face, hair, haircolor, features FROM creature_template_npcbot_appearance");
+    if (result)
+    {
+        do
+        {
+            field = result->Fetch();
+            index = 0;
+            uint32 entry = field[  index].GetUInt32();
+
+            NpcBotAppearanceData* appearanceData = new NpcBotAppearanceData();
+            appearanceData->gender =    field[++index].GetUInt8();
+            appearanceData->skin =      field[++index].GetUInt8();
+            appearanceData->face =      field[++index].GetUInt8();
+            appearanceData->hair =      field[++index].GetUInt8();
+            appearanceData->haircolor = field[++index].GetUInt8();
+            appearanceData->features =  field[++index].GetUInt8();
+
+            _botsAppearanceData[entry] = appearanceData;
+
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", ">> Bot appearance data loaded");
+    }
+    else
+        TC_LOG_INFO("server.loading", ">> Bots appearance data is not loaded. Table `creature_template_npcbot_appearance` is empty!");
+
+    //                                          1      2
+    result = WorldDatabase.Query("SELECT entry, class, race FROM creature_template_npcbot_extras");
+    if (result)
+    {
+        do
+        {
+            field = result->Fetch();
+            index = 0;
+            uint32 entry =      field[  index].GetUInt32();
+
+            NpcBotExtras* extras = new NpcBotExtras();
+            extras->bclass =    field[++index].GetUInt8();
+            extras->race =      field[++index].GetUInt8();
+
+            _botsExtras[entry] = extras;
+
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", ">> Bot race data loaded");
+    }
+    else
+        TC_LOG_INFO("server.loading", ">> Bots race data is not loaded. Table `creature_template_npcbot_extras` is empty!");
+
+    //                                              1     2        3
+    result = CharacterDatabase.Query("SELECT entry, slot, item_id, fake_id FROM characters_npcbot_transmog");
+    if (result)
+    {
+        do
+        {
+            field = result->Fetch();
+            index = 0;
+            uint32 entry =          field[  index].GetUInt32();
+
+            if (_botsTransmogData.count(entry) == 0)
+                _botsTransmogData[entry] = new NpcBotTransmogData();
+
+            //load data
+            uint8 slot =            field[++index].GetUInt8();
+            uint32 item_id =        field[++index].GetUInt32();
+            uint32 fake_id =        field[++index].GetUInt32();
+
+            _botsTransmogData[entry]->transmogs[slot] = { item_id, fake_id };
+
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", ">> Bot transmog data loaded");
+    }
+    else
+        TC_LOG_INFO("server.loading", ">> Bots transmog data is not loaded. Table `characters_npcbot_transmog` is empty!");
+
+    //                                       0      1      2      3     4        5          6          7          8          9               10          11          12         13
+    result = CharacterDatabase.Query("SELECT entry, owner, roles, spec, faction, equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet,"
+    //   14          15          16         17         18            19            20             21             22         23
+        "equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck, spells_disabled FROM characters_npcbot");
+
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", ">> Loaded 0 npcbots. Table `characters_npcbot` is empty!");
+        allBotsLoaded = true;
+        return;
+    }
+
+    uint32 botcounter = 0;
+    uint32 datacounter = 0;
+    std::list<uint32> botgrids;
+    QueryResult infores;
+    CreatureTemplate const* proto;
+    NpcBotData* botData;
+    std::list<uint32> entryList;
+
+    do
+    {
+        field = result->Fetch();
+        index = 0;
+        uint32 entry =          field[  index].GetUInt32();
+
+        //load data
+        botData = new NpcBotData(0, 0);
+        botData->owner =        field[++index].GetUInt32();
+        botData->roles =        field[++index].GetUInt32();
+        botData->spec =         field[++index].GetUInt8();
+        botData->faction =      field[++index].GetUInt32();
+
+        for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+            botData->equips[i] = field[++index].GetUInt32();
+
+        if (char const* disabled_spells_str = field[++index].GetCString())
+        {
+            std::vector<std::string_view> tok = Trinity::Tokenize(disabled_spells_str, ' ', false);
+            for (std::vector<std::string_view>::size_type i = 0; i != tok.size(); ++i)
+                botData->disabled_spells.insert(*(Trinity::StringTo<uint32>(tok[i])));
+        }
+
+        entryList.push_back(entry);
+        _botsData[entry] = botData;
+        ++datacounter;
+
+    } while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u bot data entries", datacounter);
+
+    if (!spawn)
+    {
+        allBotsLoaded = true;
+        return;
+    }
+
+    for (std::list<uint32>::const_iterator itr = entryList.begin(); itr != entryList.end(); ++itr)
+    {
+        uint32 entry = *itr;
+        proto = sObjectMgr->GetCreatureTemplate(entry);
+        if (!proto)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot find creature_template entry for npcbot (id: %u)!", entry);
+            continue;
+        }
+        //                                     1     2    3           4            5           6
+        infores = WorldDatabase.PQuery("SELECT guid, map, position_x, position_y"/*, position_z, orientation*/" FROM creature WHERE id = %u", entry);
+        if (!infores)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot spawn npcbot %s (id: %u), not found in `creature` table!", proto->Name.c_str(), entry);
+            continue;
+        }
+
+        field = infores->Fetch();
+        uint32 tableGuid = field[0].GetUInt32();
+        uint32 mapId = uint32(field[1].GetUInt16());
+        float pos_x = field[2].GetFloat();
+        float pos_y = field[3].GetFloat();
+        //float pos_z = field[4].GetFloat();
+        //float ori = field[5].GetFloat();
+
+        CellCoord c = Trinity::ComputeCellCoord(pos_x, pos_y);
+        GridCoord g = Trinity::ComputeGridCoord(pos_x, pos_y);
+        ASSERT(c.IsCoordValid(), "Invalid Cell coord!");
+        ASSERT(g.IsCoordValid(), "Invalid Grid coord!");
+        Map* map = sMapMgr->CreateBaseMap(mapId);
+        map->LoadGrid(pos_x, pos_y);
+
+        ObjectGuid Guid(HighGuid::Unit, entry, tableGuid);
+        TC_LOG_DEBUG("server.loading", "bot %u: spawnId %u, full %s", entry, tableGuid, Guid.ToString().c_str());
+        Creature* bot = map->GetCreature(Guid);
+        if (!bot) //not in map, use storage
+        {
+            //TC_LOG_DEBUG("server.loading", "bot %u: spawnId %u, is not in map on load", entry, tableGuid);
+            typedef Map::CreatureBySpawnIdContainer::const_iterator SpawnIter;
+            std::pair<SpawnIter, SpawnIter> creBounds = map->GetCreatureBySpawnIdStore().equal_range(tableGuid);
+            if (creBounds.first == creBounds.second)
+            {
+                TC_LOG_ERROR("server.loading", "bot %u is not in spawns list, consider re-spawning it!", entry);
+                continue;
+            }
+            bot = creBounds.first->second;
+        }
+        ASSERT(bot);
+        if (!bot->FindMap())
+            TC_LOG_ERROR("server.loading", "bot %u is not in map!", entry);
+        if (!bot->IsInWorld())
+            TC_LOG_ERROR("server.loading", "bot %u is not in world!", entry);
+        if (!bot->IsAlive())
+        {
+            TC_LOG_ERROR("server.loading", "bot %u is dead, respawning!", entry);
+            bot->Respawn();
+        }
+
+        TC_LOG_DEBUG("server.loading", ">> Spawned npcbot %s (id: %u, map: %u, grid: %u, cell: %u)", proto->Name.c_str(), entry, mapId, g.GetId(), c.GetId());
+        botgrids.push_back(g.GetId());
+        ++botcounter;
+    }
+
+    botgrids.sort();
+    botgrids.unique();
+    TC_LOG_INFO("server.loading", ">> Spawned %u npcbot(s) within %u grid(s) in %u ms", botcounter, uint32(botgrids.size()), GetMSTimeDiffToNow(botoldMSTime));
+
+    allBotsLoaded = true;
+}
+
+void BotDataMgr::LoadNpcBotGroupData()
+{
+    TC_LOG_INFO("server.loading", "Loading NPCBot Group members...");
+
+    uint32 oldMSTime = getMSTime();
+
+    CharacterDatabase.DirectExecute("DELETE FROM characters_npcbot_group_member WHERE guid NOT IN (SELECT guid FROM `groups`)");
+    CharacterDatabase.DirectExecute("DELETE FROM characters_npcbot_group_member WHERE entry NOT IN (SELECT entry FROM characters_npcbot)");
+
+    //                                                   0     1      2            3         4
+    QueryResult result = CharacterDatabase.Query("SELECT guid, entry, memberFlags, subgroup, roles FROM characters_npcbot_group_member ORDER BY guid");
+    if (!result)
+    {
+        TC_LOG_INFO("server.loading", ">> Loaded 0 NPCBot group members. DB table `characters_npcbot_group_member` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 creature_id = fields[1].GetUInt32();
+        if (!SelectNpcBotExtras(creature_id))
+        {
+            TC_LOG_WARN("server.loading", "Table `characters_npcbot_group_member` contains non-NPCBot creature %u which will not be loaded!", creature_id);
+            continue;
+        }
+
+        if (Group* group = sGroupMgr->GetGroupByDbStoreId(fields[0].GetUInt32()))
+            group->LoadCreatureMemberFromDB(creature_id, fields[2].GetUInt8(), fields[3].GetUInt8(), fields[4].GetUInt8());
+        else
+            TC_LOG_ERROR("misc", "BotDataMgr::LoadNpcBotGroupData: Consistency failed, can't find group (storage id: %u)", fields[0].GetUInt32());
+
+        ++count;
+
+    } while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u NPCBot group members in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
+void BotDataMgr::AddNpcBotData(uint32 entry, uint32 roles, uint8 spec, uint32 faction)
+{
+    //botData must be allocated explicitly
+    NpcBotDataMap::iterator itr = _botsData.find(entry);
+    if (itr == _botsData.end())
+    {
+        NpcBotData* botData = new NpcBotData(roles, faction, spec);
+        _botsData[entry] = botData;
+
+        CharacterDatabasePreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles, spec, faction) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC);
+        bstmt->setUInt32(0, entry);
+        bstmt->setUInt32(1, roles);
+        bstmt->setUInt8(2, spec);
+        bstmt->setUInt32(3, faction);
+        CharacterDatabase.Execute(bstmt);
+
+        return;
+    }
+
+    TC_LOG_ERROR("sql.sql", "BotMgr::AddNpcBotData(): trying to add new data but entry already exists! entry = %u", entry);
+}
+NpcBotData const* BotDataMgr::SelectNpcBotData(uint32 entry)
+{
+    NpcBotDataMap::const_iterator itr = _botsData.find(entry);
+    return itr != _botsData.end() ? itr->second : nullptr;
+}
+void BotDataMgr::UpdateNpcBotData(uint32 entry, NpcBotDataUpdateType updateType, void* data)
+{
+    NpcBotDataMap::iterator itr = _botsData.find(entry);
+    if (itr == _botsData.end())
+        return;
+
+    CharacterDatabasePreparedStatement* bstmt;
+    switch (updateType)
+    {
+        case NPCBOT_UPDATE_OWNER:
+            if (itr->second->owner == *(uint32*)(data))
+                break;
+            itr->second->owner = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+            //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, itr->second->owner);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            //break; //no break: erase transmogs
+        [[fallthrough]];
+        case NPCBOT_UPDATE_TRANSMOG_ERASE:
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT_TRANSMOG);
+            //"DELETE FROM characters_npcbot_transmog WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_ROLES:
+            itr->second->roles = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+            //"UPDATE character_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, itr->second->roles);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_SPEC:
+            itr->second->spec = *(uint8*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_SPEC);
+            //"UPDATE characters_npcbot SET spec = ? WHERE entry = ?", CONNECTION_ASYNCH
+            bstmt->setUInt8(0, itr->second->spec);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_FACTION:
+            itr->second->faction = *(uint32*)(data);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_FACTION);
+            //"UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_ASYNCH
+            bstmt->setUInt32(0, itr->second->faction);
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        case NPCBOT_UPDATE_DISABLED_SPELLS:
+        {
+            NpcBotData::DisabledSpellsContainer const* spells = (NpcBotData::DisabledSpellsContainer const*)(data);
+            std::ostringstream ss;
+            for (NpcBotData::DisabledSpellsContainer::const_iterator citr = spells->begin(); citr != spells->end(); ++citr)
+                ss << (*citr) << ' ';
+
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_DISABLED_SPELLS);
+            //"UPDATE characters_npcbot SET spells_disabled = ? WHERE entry = ?", CONNECTION_ASYNCH
+            bstmt->setString(0, ss.str());
+            bstmt->setUInt32(1, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        }
+        case NPCBOT_UPDATE_EQUIPS:
+        {
+            Item** items = (Item**)(data);
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(entry, id);
+
+            CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+            //"UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?,
+            //equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC
+            CharacterDatabasePreparedStatement* stmt;
+            uint8 k;
+            for (k = BOT_SLOT_MAINHAND; k != BOT_INVENTORY_SIZE; ++k)
+            {
+                itr->second->equips[k] = items[k] ? items[k]->GetGUID().GetCounter() : 0;
+                if (Item const* botitem = items[k])
+                {
+                    bool standard = false;
+                    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+                    {
+                        if (einfo->ItemEntry[i] == botitem->GetEntry())
+                        {
+                            itr->second->equips[k] = 0;
+                            bstmt->setUInt32(k, 0);
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    uint8 index = 0;
+                    stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ITEM_INSTANCE);
+                    //REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid)
+                    //VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC : 0-13
+                    stmt->setUInt32(  index, botitem->GetEntry());
+                    stmt->setUInt32(++index, botitem->GetOwnerGUID().GetCounter());
+                    stmt->setUInt32(++index, botitem->GetGuidValue(ITEM_FIELD_CREATOR).GetCounter());
+                    stmt->setUInt32(++index, botitem->GetGuidValue(ITEM_FIELD_GIFTCREATOR).GetCounter());
+                    stmt->setUInt32(++index, botitem->GetCount());
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_DURATION));
+
+                    std::ostringstream ssSpells;
+                    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                        ssSpells << botitem->GetSpellCharges(i) << ' ';
+                    stmt->setString(++index, ssSpells.str());
+
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_FLAGS));
+
+                    std::ostringstream ssEnchants;
+                    for (uint8 i = 0; i < MAX_ENCHANTMENT_SLOT; ++i)
+                    {
+                        ssEnchants << botitem->GetEnchantmentId(EnchantmentSlot(i)) << ' ';
+                        ssEnchants << botitem->GetEnchantmentDuration(EnchantmentSlot(i)) << ' ';
+                        ssEnchants << botitem->GetEnchantmentCharges(EnchantmentSlot(i)) << ' ';
+                    }
+                    stmt->setString(++index, ssEnchants.str());
+
+                    stmt->setInt16 (++index, botitem->GetItemRandomPropertyId());
+                    stmt->setUInt16(++index, botitem->GetUInt32Value(ITEM_FIELD_DURABILITY));
+                    stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
+                    stmt->setString(++index, botitem->GetText());
+                    stmt->setUInt32(++index, botitem->GetGUID().GetCounter());
+
+                    trans->Append(stmt);
+
+                    Item::DeleteFromInventoryDB(trans, botitem->GetGUID().GetCounter()); //prevent duplicates
+
+                    bstmt->setUInt32(k, botitem->GetGUID().GetCounter());
+                }
+                else
+                    bstmt->setUInt32(k, uint32(0));
+            }
+
+            bstmt->setUInt32(k, entry);
+            trans->Append(bstmt);
+            CharacterDatabase.CommitTransaction(trans);
+            break;
+        }
+        case NPCBOT_UPDATE_ERASE:
+        {
+            NpcBotDataMap::iterator bitr = _botsData.find(entry);
+            ASSERT(bitr != _botsData.end());
+            delete bitr->second;
+            _botsData.erase(bitr);
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+            //"DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, entry);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        }
+        default:
+            TC_LOG_ERROR("sql.sql", "BotDataMgr:UpdateNpcBotData: unhandled updateType %u", uint32(updateType));
+            break;
+    }
+}
+void BotDataMgr::UpdateNpcBotDataAll(uint32 playerGuid, NpcBotDataUpdateType updateType, void* data)
+{
+    CharacterDatabasePreparedStatement* bstmt;
+    switch (updateType)
+    {
+        case NPCBOT_UPDATE_OWNER:
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER_ALL);
+            //"UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC
+            bstmt->setUInt32(0, *(uint32*)(data));
+            bstmt->setUInt32(1, playerGuid);
+            CharacterDatabase.Execute(bstmt);
+            //break; //no break: erase transmogs
+        [[fallthrough]];
+        case NPCBOT_UPDATE_TRANSMOG_ERASE:
+            bstmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT_TRANSMOG_ALL);
+            //"DELETE FROM characters_npcbot_transmog WHERE entry IN (SELECT entry FROM characters_npcbot WHERE owner = ?)", CONNECTION_ASYNC
+            bstmt->setUInt32(0, playerGuid);
+            CharacterDatabase.Execute(bstmt);
+            break;
+        //case NPCBOT_UPDATE_ROLES:
+        //case NPCBOT_UPDATE_FACTION:
+        //case NPCBOT_UPDATE_EQUIPS:
+        default:
+            TC_LOG_ERROR("sql.sql", "BotDataMgr:UpdateNpcBotDataAll: unhandled updateType %u", uint32(updateType));
+            break;
+    }
+}
+
+void BotDataMgr::SaveNpcBotStats(NpcBotStats const* stats)
+{
+    CharacterDatabasePreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_NPCBOT_STATS);
+    //"REPLACE INTO characters_npcbot_stats
+    //(entry, maxhealth, maxpower, strength, agility, stamina, intellect, spirit, armor, defense,
+    //resHoly, resFire, resNature, resFrost, resShadow, resArcane, blockPct, dodgePct, parryPct, critPct,
+    //attackPower, spellPower, spellPen, hastePct, hitBonusPct, expertise, armorPenPct) VALUES
+    //(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC
+
+    uint32 index = 0;
+    bstmt->setUInt32(  index, stats->entry);
+    bstmt->setUInt32(++index, stats->maxhealth);
+    bstmt->setUInt32(++index, stats->maxpower);
+    bstmt->setUInt32(++index, stats->strength);
+    bstmt->setUInt32(++index, stats->agility);
+    bstmt->setUInt32(++index, stats->stamina);
+    bstmt->setUInt32(++index, stats->intellect);
+    bstmt->setUInt32(++index, stats->spirit);
+    bstmt->setUInt32(++index, stats->armor);
+    bstmt->setUInt32(++index, stats->defense);
+    bstmt->setUInt32(++index, stats->resHoly);
+    bstmt->setUInt32(++index, stats->resFire);
+    bstmt->setUInt32(++index, stats->resNature);
+    bstmt->setUInt32(++index, stats->resFrost);
+    bstmt->setUInt32(++index, stats->resShadow);
+    bstmt->setUInt32(++index, stats->resArcane);
+    bstmt->setFloat (++index, stats->blockPct);
+    bstmt->setFloat (++index, stats->dodgePct);
+    bstmt->setFloat (++index, stats->parryPct);
+    bstmt->setFloat (++index, stats->critPct);
+    bstmt->setUInt32(++index, stats->attackPower);
+    bstmt->setUInt32(++index, stats->spellPower);
+    bstmt->setUInt32(++index, stats->spellPen);
+    bstmt->setFloat (++index, stats->hastePct);
+    bstmt->setFloat (++index, stats->hitBonusPct);
+    bstmt->setUInt32(++index, stats->expertise);
+    bstmt->setFloat (++index, stats->armorPenPct);
+
+    CharacterDatabase.Execute(bstmt);
+}
+
+NpcBotAppearanceData const* BotDataMgr::SelectNpcBotAppearance(uint32 entry)
+{
+    NpcBotAppearanceDataMap::const_iterator itr = _botsAppearanceData.find(entry);
+    return itr != _botsAppearanceData.end() ? itr->second : nullptr;
+}
+
+NpcBotExtras const* BotDataMgr::SelectNpcBotExtras(uint32 entry)
+{
+    NpcBotExtrasMap::const_iterator itr = _botsExtras.find(entry);
+    return itr != _botsExtras.end() ? itr->second : nullptr;
+}
+
+NpcBotTransmogData const* BotDataMgr::SelectNpcBotTransmogs(uint32 entry)
+{
+    NpcBotTransmogDataMap::const_iterator itr = _botsTransmogData.find(entry);
+    return itr != _botsTransmogData.end() ? itr->second : nullptr;
+}
+void BotDataMgr::UpdateNpcBotTransmogData(uint32 entry, uint8 slot, uint32 item_id, uint32 fake_id, bool update_db)
+{
+    ASSERT(slot < BOT_TRANSMOG_INVENTORY_SIZE);
+
+    NpcBotTransmogDataMap::iterator itr = _botsTransmogData.find(entry);
+    if (itr == _botsTransmogData.end())
+        _botsTransmogData[entry] = new NpcBotTransmogData();
+
+    _botsTransmogData[entry]->transmogs[slot] = { item_id, fake_id };
+
+    if (update_db)
+    {
+        CharacterDatabasePreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_NPCBOT_TRANSMOG);
+        //"REPLACE INTO characters_npcbot_transmog (entry, slot, item_id, fake_id) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC
+        bstmt->setUInt32(0, entry);
+        bstmt->setUInt8(1, slot);
+        bstmt->setUInt32(2, item_id);
+        bstmt->setUInt32(3, fake_id);
+        CharacterDatabase.Execute(bstmt);
+    }
+}
+
+void BotDataMgr::ResetNpcBotTransmogData(uint32 entry, bool update_db)
+{
+    NpcBotTransmogDataMap::iterator itr = _botsTransmogData.find(entry);
+    if (itr == _botsTransmogData.end())
+        return;
+
+    if (update_db)
+    {
+        CharacterDatabaseTransaction trans = CharacterDatabase.BeginTransaction();
+        for (uint8 i = 0; i != BOT_TRANSMOG_INVENTORY_SIZE; ++i)
+        {
+            if (_botsTransmogData[entry]->transmogs[i].first == 0 && _botsTransmogData[entry]->transmogs[i].second == 0)
+                continue;
+
+            CharacterDatabasePreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_NPCBOT_TRANSMOG);
+            //"REPLACE INTO characters_npcbot_transmog (entry, slot, item_id, fake_id) VALUES (?, ?, ?, ?)", CONNECTION_ASYNC
+            bstmt->setUInt32(0, entry);
+            bstmt->setUInt8(1, i);
+            bstmt->setUInt32(2, 0);
+            bstmt->setUInt32(3, 0);
+            trans->Append(bstmt);
+        }
+
+        if (trans->GetSize() > 0)
+            CharacterDatabase.CommitTransaction(trans);
+    }
+
+    for (uint8 i = 0; i != BOT_TRANSMOG_INVENTORY_SIZE; ++i)
+        _botsTransmogData[entry]->transmogs[i] = { 0, 0 };
+}
+
+void BotDataMgr::RegisterBot(Creature const* bot)
+{
+    if (_existingBots.find(bot) != _existingBots.end())
+    {
+        TC_LOG_ERROR("entities.unit", "BotDataMgr::RegisterBot: bot %u (%s) already registered!",
+            bot->GetEntry(), bot->GetName().c_str());
+        return;
+    }
+
+    std::unique_lock<std::shared_mutex> lock(*GetLock());
+
+    _existingBots.insert(bot);
+    //TC_LOG_ERROR("entities.unit", "BotDataMgr::RegisterBot: registered bot %u (%s)", bot->GetEntry(), bot->GetName().c_str());
+}
+void BotDataMgr::UnregisterBot(Creature const* bot)
+{
+    if (_existingBots.find(bot) == _existingBots.end())
+    {
+        TC_LOG_ERROR("entities.unit", "BotDataMgr::UnregisterBot: bot %u (%s) not found!",
+            bot->GetEntry(), bot->GetName().c_str());
+        return;
+    }
+
+    std::unique_lock<std::shared_mutex> lock(*GetLock());
+
+    _existingBots.erase(bot);
+    //TC_LOG_ERROR("entities.unit", "BotDataMgr::UnregisterBot: unregistered bot %u (%s)", bot->GetEntry(), bot->GetName().c_str());
+}
+Creature const* BotDataMgr::FindBot(uint32 entry)
+{
+    std::shared_lock<std::shared_mutex> lock(*GetLock());
+
+    for (NpcBotRegistry::const_iterator ci = _existingBots.begin(); ci != _existingBots.end(); ++ci)
+    {
+        if ((*ci)->GetEntry() == entry)
+            return *ci;
+    }
+    return nullptr;
+}
+
+NpcBotRegistry const& BotDataMgr::GetExistingNPCBots()
+{
+    return _existingBots;
+}
+
+void BotDataMgr::GetNPCBotGuidsByOwner(std::vector<ObjectGuid> &guids_vec, ObjectGuid owner_guid)
+{
+    ASSERT(AllBotsLoaded());
+
+    std::shared_lock<std::shared_mutex> lock(*GetLock());
+
+    for (NpcBotRegistry::const_iterator ci = _existingBots.begin(); ci != _existingBots.end(); ++ci)
+    {
+        if (_botsData[(*ci)->GetEntry()]->owner == owner_guid.GetCounter())
+            guids_vec.push_back((*ci)->GetGUID());
+    }
+}
+
+ObjectGuid BotDataMgr::GetNPCBotGuid(uint32 entry)
+{
+    ASSERT(AllBotsLoaded());
+
+    std::shared_lock<std::shared_mutex> lock(*GetLock());
+
+    for (NpcBotRegistry::const_iterator ci = _existingBots.begin(); ci != _existingBots.end(); ++ci)
+    {
+        if ((*ci)->GetEntry() == entry)
+            return (*ci)->GetGUID();
+    }
+
+    return ObjectGuid::Empty;
+}
+
+std::vector<uint32> BotDataMgr::GetExistingNPCBotIds()
+{
+    ASSERT(AllBotsLoaded());
+
+    std::vector<uint32> existing_ids;
+    existing_ids.reserve(_botsData.size());
+    for (decltype(_botsData)::value_type const& bot_data_pair : _botsData)
+        existing_ids.push_back(bot_data_pair.first);
+
+    return existing_ids;
+}
diff --git a/src/server/game/AI/NpcBots/botdatamgr.h b/src/server/game/AI/NpcBots/botdatamgr.h
new file mode 100644
index 000000000..7afc825c6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdatamgr.h
@@ -0,0 +1,159 @@
+#ifndef _BOTDATAMGR_H
+#define _BOTDATAMGR_H
+
+#include "botcommon.h"
+
+#include <set>
+#include <shared_mutex>
+#include <vector>
+
+class Creature;
+
+enum NpcBotDataUpdateType
+{
+    NPCBOT_UPDATE_OWNER                 = 1,
+    NPCBOT_UPDATE_ROLES,
+    NPCBOT_UPDATE_SPEC,
+    NPCBOT_UPDATE_DISABLED_SPELLS,
+    NPCBOT_UPDATE_FACTION,
+    NPCBOT_UPDATE_EQUIPS,
+    NPCBOT_UPDATE_ERASE,
+    NPCBOT_UPDATE_TRANSMOG_ERASE,
+    NPCBOT_UPDATE_END
+};
+
+struct NpcBotData
+{
+    typedef std::set<uint32> DisabledSpellsContainer;
+
+    friend class BotDataMgr;
+public:
+    uint32 owner;
+    uint32 roles;
+    uint32 faction;
+    uint8 spec;
+    uint32 equips[BOT_INVENTORY_SIZE];
+    DisabledSpellsContainer disabled_spells;
+
+private:
+    explicit NpcBotData(uint32 iroles, uint32 ifaction, uint8 ispec = 1) : owner(0), roles(iroles), faction(ifaction), spec(ispec)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            equips[i] = 0;
+    }
+    NpcBotData(NpcBotData const&);
+};
+
+struct NpcBotAppearanceData
+{
+    friend class BotDataMgr;
+public:
+    uint8 gender;
+    uint8 skin;
+    uint8 face;
+    uint8 hair;
+    uint8 haircolor;
+    uint8 features;
+private:
+    explicit NpcBotAppearanceData() {}
+    NpcBotAppearanceData(NpcBotAppearanceData const&);
+};
+
+struct NpcBotExtras
+{
+    friend class BotDataMgr;
+public:
+    uint8 race;
+    uint8 bclass;
+private:
+    explicit NpcBotExtras() {}
+    NpcBotExtras(NpcBotExtras const&);
+};
+
+struct NpcBotTransmogData
+{
+    friend class BotDataMgr;
+public:
+    std::pair<uint32 /*item_id*/, uint32 /*fake_id*/> transmogs[BOT_TRANSMOG_INVENTORY_SIZE];
+private:
+    explicit NpcBotTransmogData()
+    {
+        for (uint8 i = 0; i != BOT_TRANSMOG_INVENTORY_SIZE; ++i)
+            transmogs[i] = { 0, 0 };
+    }
+    NpcBotTransmogData(NpcBotTransmogData const&);
+};
+
+struct NpcBotStats
+{
+public:
+    NpcBotStats() {}
+
+    uint32 entry;
+    uint32 maxhealth;
+    uint32 maxpower;
+    uint32 strength;
+    uint32 agility;
+    uint32 stamina;
+    uint32 intellect;
+    uint32 spirit;
+    uint32 armor;
+    uint32 defense;
+    uint32 resHoly;
+    uint32 resFire;
+    uint32 resNature;
+    uint32 resFrost;
+    uint32 resShadow;
+    uint32 resArcane;
+    float blockPct;
+    float dodgePct;
+    float parryPct;
+    float critPct;
+    uint32 attackPower;
+    uint32 spellPower;
+    uint32 spellPen;
+    float hastePct;
+    float hitBonusPct;
+    uint32 expertise;
+    float armorPenPct;
+};
+
+typedef std::set<Creature const*> NpcBotRegistry;
+
+class BotDataMgr
+{
+    public:
+        static void LoadNpcBots(bool spawn = true);
+        static void LoadNpcBotGroupData();
+
+        static void AddNpcBotData(uint32 entry, uint32 roles, uint8 spec, uint32 faction);
+        static NpcBotData const* SelectNpcBotData(uint32 entry);
+        static void UpdateNpcBotData(uint32 entry, NpcBotDataUpdateType updateType, void* data = nullptr);
+        static void UpdateNpcBotDataAll(uint32 playerGuid, NpcBotDataUpdateType updateType, void* data = nullptr);
+        static void SaveNpcBotStats(NpcBotStats const* stats);
+
+        static NpcBotAppearanceData const* SelectNpcBotAppearance(uint32 entry);
+        static NpcBotExtras const* SelectNpcBotExtras(uint32 entry);
+
+        static NpcBotTransmogData const* SelectNpcBotTransmogs(uint32 entry);
+        static void UpdateNpcBotTransmogData(uint32 entry, uint8 slot, uint32 item_id, uint32 fake_id, bool update_db = true);
+        static void ResetNpcBotTransmogData(uint32 entry, bool update_db = true);
+
+        static bool AllBotsLoaded();
+
+        static void RegisterBot(Creature const* bot);
+        static void UnregisterBot(Creature const* bot);
+        static Creature const* FindBot(uint32 entry);
+        static NpcBotRegistry const& GetExistingNPCBots();
+        static void GetNPCBotGuidsByOwner(std::vector<ObjectGuid> &guids_vec, ObjectGuid owner_guid);
+        static ObjectGuid GetNPCBotGuid(uint32 entry);
+        static std::vector<uint32> GetExistingNPCBotIds();
+
+        static std::shared_mutex* GetLock();
+
+    private:
+        BotDataMgr() {}
+        BotDataMgr(BotDataMgr const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botdpstracker.cpp b/src/server/game/AI/NpcBots/botdpstracker.cpp
new file mode 100644
index 000000000..e7b178eb2
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdpstracker.cpp
@@ -0,0 +1,133 @@
+#include "botdpstracker.h"
+#include "Unit.h"
+
+/*
+Name: bot_dps_tracker
+%Complete: 100
+Comment: dps taken tracker for NPCBot system by Trickerer (onlysuffering@gmail.com)
+DPS trackers may collect data from different bot owners if in party but this overdoing has no significance whatsoever
+*/
+
+enum DPSTrackerConstants : uint32
+{
+    DPS_UPDATE_TIMER        =  500, //recalculate dps every x ms
+    MAX_DPS_TRACK_TIME      = 5000, //track damage taken for last x ms
+    DPS_INACTIVE_TIMER      = 5000, //reset if combat not active for botparty for x ms
+    //maximum tracked damage taken periods of DPS_UPDATE_TIMER during MAX_DPS_TRACK_TIME
+    MAX_DAMAGES             = MAX_DPS_TRACK_TIME/DPS_UPDATE_TIMER
+};
+
+DPSTracker::DPSTracker()
+{
+    _updateTimer = 0;
+    _inactiveTimer = 0;
+    _trackTimer = 0;
+    _active = false;
+}
+
+DPSTracker::~DPSTracker()
+{
+    for (DamageTakenMap::const_iterator itr = _damages.begin(); itr != _damages.end(); ++itr)
+        delete[] itr->second;
+
+    _damages.clear();
+    _DPSes.clear();
+}
+
+void DPSTracker::Update(uint32 diff)
+{
+    if (_active)
+    {
+        _inactiveTimer += diff;
+        _updateTimer += diff;
+        _trackTimer += diff;
+
+        if (_inactiveTimer >= DPS_INACTIVE_TIMER)
+        {
+            _Reset();
+        }
+        else if (_updateTimer >= DPS_UPDATE_TIMER)
+        {
+            _updateTimer -= DPS_UPDATE_TIMER;
+            _Release();
+        }
+    }
+}
+
+void DPSTracker::_Reset()
+{
+    if (_active)
+    {
+        _active = false;
+
+        for (DamageTakenMap::const_iterator itr = _damages.begin(); itr != _damages.end(); ++itr)
+            for (uint8 i = 0; i != MAX_DAMAGES; ++i)
+                itr->second[i] = 0;
+        for (DPSTakenMap::iterator itr = _DPSes.begin(); itr != _DPSes.end(); ++itr)
+            itr->second = 0;
+
+        _updateTimer = 0;
+        _inactiveTimer = 0;
+        _trackTimer = 0;
+    }
+}
+
+void DPSTracker::_Release()
+{
+    for (DamageTakenMap::const_iterator itr = _damages.begin(); itr != _damages.end(); ++itr)
+    {
+        uint32* dmgs = itr->second;
+        uint32 total_damage = 0;
+        for (uint8 i = 0; i != MAX_DAMAGES; ++i)
+            total_damage += dmgs[i];
+
+        _DPSes[itr->first] = uint32(total_damage / (0.001f * std::max<uint32>(1 * IN_MILLISECONDS, std::min<uint32>(_trackTimer, MAX_DPS_TRACK_TIME))));
+        //TC_LOG_ERROR("entities.player", "DPSTracker::Release(): guidlow = %u, time = %u, tick damage %u, total %u, dps = %u",
+        //    itr->first, _trackTimer, dmgs[0], total_damage, _DPSes[itr->first]);
+
+        //shift
+        for (int8 i = MAX_DAMAGES-1; i > 0; --i)
+            dmgs[i] = dmgs[i-1];
+        dmgs[0] = 0;
+    }
+}
+
+void DPSTracker::_AccumulateDamage(uint64 guid, uint32 damage)
+{
+    DamageTakenMap::const_iterator itr = _damages.find(guid);
+
+    if (itr == _damages.end())
+    {
+        uint32* dmgarray = new uint32[MAX_DAMAGES];
+        memset(dmgarray, 0, sizeof(uint32)*MAX_DAMAGES);
+
+        dmgarray[0] = damage;
+
+        _damages[guid] = dmgarray;
+        return;
+    }
+
+    itr->second[0] += damage;
+}
+//victim is bot owner, bot, party player or party bot; checked in Unit::DealDamage()
+void DPSTracker::TrackDamage(Unit const* victim, uint32 damage)
+{
+    //TC_LOG_ERROR("entities.player", "DPSTracker::OnDamage(): on %s, damage %u", victim->GetName().c_str(), damage);
+
+    _SetActive();
+    _AccumulateDamage(victim->GetGUID().GetRawValue(), damage);
+}
+
+void DPSTracker::_SetActive()
+{
+    _inactiveTimer = 0;
+    if (!_active)
+        _active = true;
+}
+
+uint32 DPSTracker::GetDPSTaken(uint64 guid) const
+{
+    DPSTakenMap::const_iterator itr = _DPSes.find(guid);
+    //TC_LOG_ERROR("entities.player", "DPSTracker::GetDPSTaken(): from %u, damage %u", guid, itr != _DPSes.end() ? itr->second : 0);
+    return itr != _DPSes.end() ? itr->second : 0;
+}
diff --git a/src/server/game/AI/NpcBots/botdpstracker.h b/src/server/game/AI/NpcBots/botdpstracker.h
new file mode 100644
index 000000000..a528a8ffb
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdpstracker.h
@@ -0,0 +1,42 @@
+#ifndef _BOT_DPSTRACKER_H
+#define _BOT_DPSTRACKER_H
+
+#include "Define.h"
+
+#include <unordered_map>
+
+class Unit;
+
+class DPSTracker
+{
+    public:
+        DPSTracker();
+        ~DPSTracker();
+
+        void Update(uint32 diff);
+
+        void TrackDamage(Unit const* victim, uint32 damage);
+        uint32 GetDPSTaken(uint64 guid) const;
+
+        void SetOwner(uint32 guidlow) { _ownerGuid = guidlow; }
+
+    private:
+        void _Reset();
+        void _Release();
+        void _AccumulateDamage(uint64 guid, uint32 damage);
+        void _SetActive();
+
+        typedef std::unordered_map<uint64 /*guid*/, uint32* /*dmgarray*/> DamageTakenMap;
+        typedef std::unordered_map<uint64 /*guid*/, uint32 /*dps*/> DPSTakenMap;
+        DamageTakenMap _damages;
+        DPSTakenMap _DPSes;
+
+        uint32 _ownerGuid;
+
+        uint32 _updateTimer;
+        uint32 _inactiveTimer;
+        uint32 _trackTimer;
+        bool _active;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botdump.cpp b/src/server/game/AI/NpcBots/botdump.cpp
new file mode 100644
index 000000000..a75b02ea6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdump.cpp
@@ -0,0 +1,1019 @@
+/*
+ * NpcBots Data Migration System by Trickerer (onlysuffering@gmail.com)
+ *
+ * Last update: *23 Jan 2021*
+ *
+ * Saved data:
+ * 1) `characters_npcbot` - spawned bots' BOT info
+ * 2) `item_instance` - bots' equipment
+ * 3) `creature` - bot spawns
+ *
+ * Make sure you have bots installed, or you are in for an unpleasant surprise.
+ */
+
+#include "botdump.h"
+#include "botdatamgr.h"
+#include "DatabaseEnv.h"
+#include "Log.h"
+#include "ObjectMgr.h"
+
+#include <sstream>
+
+class BotStringTransaction
+{
+public:
+    BotStringTransaction() : _buf() {}
+
+    void Append(std::string const& sql)
+    {
+        _buf += sql;
+    }
+
+    std::string const& GetBuffer() const
+    {
+        return _buf;
+    }
+
+private:
+    std::string _buf;
+};
+
+enum ImportDataTableType : uint8
+{
+    TABLE_TYPE_CHARACTERS_NPCBOT    = 0,
+    TABLE_TYPE_NPCBOT_TRANSMOG      = 1,
+    TABLE_TYPE_ITEM_INSTANCE        = 2,
+    TABLE_TYPE_CREATURE             = 3,
+
+    IMPORT_TABLES_COUNT             = 4,
+    IMPORT_TABLE_INVALID            = 255
+};
+
+struct TableImportData
+{
+    std::string const name;
+    std::string const fieldsStr;
+    uint32 paramsCount;
+    size_t guidOffsetBegin;
+    size_t guidOffsetEnd;
+};
+
+TableImportData TableImportDatas[IMPORT_TABLES_COUNT] =
+{
+    { "`characters_npcbot` ",
+      "("
+      //0       1       2       3      4         5                 6           7           8           9
+      "`entry`,`owner`,`roles`,`spec`,`faction`,`spells_disabled`,`equipMhEx`,`equipOhEx`,`equipRhEx`,`equipHead`,"
+      //10               11           12           13          14          15           16           17
+      "`equipShoulders`,`equipChest`,`equipWaist`,`equipLegs`,`equipFeet`,`equipWrist`,`equipHands`,`equipBack`,"
+      //18          19             20             21              22              23
+      "`equipBody`,`equipFinger1`,`equipFinger2`,`equipTrinket1`,`equipTrinket2`,`equipNeck`"
+      ") VALUES ", 24, 6, 23 },
+
+    { "`characters_npcbot_transmog` ",
+      "("
+      //0       1      2         3
+      "`entry`,`slot`,`item_id`,`fake_id`"
+      ") VALUES ", 4, 0, 0 },
+
+    { "`item_instance` ",
+      "("
+      //0             1                 2       3          4         5       6
+      "`creatorGuid`,`giftCreatorGuid`,`count`,`duration`,`charges`,`flags`,`enchantments`,"
+      //7                  8            9            10     11     12          13
+      "`randomPropertyId`,`durability`,`playedTime`,`text`,`guid`,`itemEntry`,`owner_guid`"
+      ") VALUES ", 14, 11, 11 },
+
+    { "`creature` ",
+      "("
+      //0      1    2     3           4           5            6            7            8             9           10
+      "`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`curhealth`,`curmana`"
+      ") VALUES ", 11, 0, 0 }
+};
+
+ImportDataTableType GetImportDataTableType(std::string const& name)
+{
+    for (uint8 i = TABLE_TYPE_CHARACTERS_NPCBOT; i != IMPORT_TABLES_COUNT; ++i)
+    {
+        //TC_LOG_ERROR("scripts", "import: GetImportDataTableType");
+        if (!TableImportDatas[i].name.compare(name))
+            return ImportDataTableType(i);
+    }
+
+    return IMPORT_TABLE_INVALID;
+}
+
+inline uint8 GetImportLineParamsCount(std::string const& line)
+{
+    static std::string const ParamSeparator = "','";
+    uint8 count = 0;
+    size_t pos = line.find(ParamSeparator);
+    while (pos != std::string::npos)
+    {
+        //TC_LOG_ERROR("scripts", "import: GetImportLineParamsCount");
+        ++count;
+        pos = line.find(ParamSeparator, pos + 1);
+    }
+    return count + 1; //separators count is params count - 1
+}
+
+inline void FixNULLfields(std::string& line)
+{
+    static std::string const NullString = "'NULL'";
+    size_t pos = line.find(NullString);
+    while (pos != std::string::npos)
+    {
+        //TC_LOG_ERROR("scripts", "import: FixNULLfields");
+        line.replace(pos, NullString.length(), "NULL");
+        pos = line.find(NullString);
+    }
+}
+
+std::set<uint32> ExistingNPCBots;
+std::set<uint32> ExistingNPCBotTransmogs;
+
+template<typename T>
+void StringToVal(std::string const& /*line*/, T& /*v*/, size_t /*begin_pos*/, size_t /*end_pos*/)
+{
+    TC_LOG_ERROR("scripts", "StringToVal misuse");
+}
+/*
+template<>
+void StringToVal(std::string const& line, float& v, size_t begin_pos, size_t end_pos)
+{
+    v = atof(line.substr(begin_pos, end_pos).c_str());
+    TC_LOG_ERROR("scripts", "import: StringToVal returned %.2f", v);
+}
+*/
+template<>
+void StringToVal(std::string const& line, uint32& v, size_t begin_pos, size_t end_pos)
+{
+    std::string subst = line.substr(begin_pos, end_pos - begin_pos).c_str();
+    v = (uint32)atoi(subst.c_str());
+    //TC_LOG_ERROR("scripts", "import: StringToVal returned %u (%u to %u: %s)",
+    //    v, uint32(begin_pos), uint32(end_pos), subst.c_str());
+}
+
+template<typename T>
+std::string ValToString(T /*v*/)
+{
+    TC_LOG_ERROR("scripts", "ValToString misuse");
+    return "";
+}
+template<>
+std::string ValToString(uint32 v)
+{
+    std::ostringstream stv;
+    stv << v;
+    return stv.str();
+}
+
+template<typename T>
+bool ExtractValueFromString(std::string const& line, T& v, size_t offset, std::string const sep = "'")
+{
+    uint32 sepNum = 0;
+
+    size_t begin_pos = 0, end_pos = 0;
+
+    size_t pos = line.find(sep);
+    while (pos != std::string::npos)
+    {
+        ++sepNum;
+        if (begin_pos == 0 && !((sepNum-1) % 2) && ((sepNum-1) / 2) == offset)
+        {
+            begin_pos = pos + 1;
+            //TC_LOG_ERROR("scripts", "import: ExtractValueFromString begin_pos %u", uint32(begin_pos));
+        }
+        else if (end_pos == 0 && ((sepNum-1) % 2) && ((sepNum-1) / 2) == offset)
+        {
+            end_pos = pos;
+            //TC_LOG_ERROR("scripts", "import: ExtractValueFromString end_pos %u", uint32(end_pos));
+        }
+
+        if (begin_pos && end_pos)
+            break;
+
+        pos = line.find(sep, pos + 1);
+    }
+
+    if (begin_pos && end_pos)
+    {
+        StringToVal(line, v, begin_pos, end_pos);
+        return true;
+    }
+
+    return false;
+}
+
+typedef std::map<uint32, uint32> ReGuidMap;
+ReGuidMap itemReguidMap;
+
+inline bool ReGuidBotEquip(std::string& line, size_t ne_guid_offset)
+{
+    /*
+    INSERT INTO `characters_npcbot` (`entry`,`owner`,`roles`,`spec`,`faction`,`spell
+    s_disabled`,`equipMhEx`,`equipOhEx`,`equipRhEx`,`equipHead`,`equipShoulders`,`eq
+    uipChest`,`equipWaist`,`equipLegs`,`equipFeet`,`equipWrist`,`equipHands`,`equipB
+    ack`,`equipBody`,`equipFinger1`,`equipFinger2`,`equipTrinket1`,`equipTrinket2`,`
+    equipNeck`) VALUES ('70027','2204','19','3','35','NULL','4305063','4305032','0','0
+    ','4305069','4237321','4237326','4305049','4305067','4305055','0','4305054','430
+    5029','4303835','0','0','0','0');
+    */
+    static const std::string ne_vals_sep = "('";
+    static const std::string ne_sep = "'";
+
+    bool reguidDone = false;
+    uint32 sepNum = 0;
+    size_t begin_pos = 0, end_pos = 0;
+
+    size_t pos = line.find(ne_vals_sep);
+    ASSERT(pos != std::string::npos);
+    pos = line.find(ne_sep);
+    ASSERT(pos != std::string::npos);
+    while (pos != std::string::npos)
+    {
+        ++sepNum;
+        //TC_LOG_ERROR("scripts", "import: ReGuidBotEquip sepNum %u", sepNum);
+        if (begin_pos == 0 && !((sepNum-1) % 2) && ((sepNum-1) / 2) == ne_guid_offset)
+        {
+            begin_pos = pos + 1;
+            //TC_LOG_ERROR("scripts", "import: ReGuidBotEquip begin_pos %u", uint32(begin_pos));
+        }
+        else if (end_pos == 0 && ((sepNum-1) % 2) && ((sepNum-1) / 2) == ne_guid_offset)
+        {
+            end_pos = pos;
+            //TC_LOG_ERROR("scripts", "import: ReGuidBotEquip end_pos %u", uint32(end_pos));
+        }
+
+        if (begin_pos && end_pos)
+        {
+            uint32 guidVal;
+            StringToVal(line, guidVal, begin_pos, end_pos);
+            if (!guidVal)
+            {
+                //ignore no equip
+                if (line.substr(begin_pos, end_pos - begin_pos) == "0")
+                    return true;
+
+                TC_LOG_ERROR("scripts", "import: ReGuidBotEquip no guidVal from %s offset %u!",
+                    line.substr(begin_pos, end_pos - begin_pos).c_str(), uint32(ne_guid_offset));
+                break;
+            }
+
+            if (itemReguidMap.count(guidVal) == 0)
+            {
+                TC_LOG_ERROR("scripts", "import: ReGuidBotEquip reguid value not found for %u!", guidVal);
+                break;
+            }
+
+            uint32 neVal = itemReguidMap[guidVal];
+            //TC_LOG_ERROR("scripts", "import: ReGuidBotEquip replacing %u with %u", guidVal, neVal);
+            line.replace(begin_pos, end_pos - begin_pos, ValToString(neVal));
+            reguidDone = true;
+            break;
+        }
+
+        pos = line.find(ne_sep, pos + 1);
+    }
+
+    return reguidDone;
+}
+inline bool ReGuidBotEquips(std::string& line)
+{
+    static const size_t ne_guid_offset_s = TableImportDatas[TABLE_TYPE_CHARACTERS_NPCBOT].guidOffsetBegin;
+    static const size_t ne_guid_offset_e = TableImportDatas[TABLE_TYPE_CHARACTERS_NPCBOT].guidOffsetEnd;
+    //TC_LOG_ERROR("scripts", "import: ReGuidBotEquips ne_guid_offset_s %u ne_guid_offset_e %u", uint32(ne_guid_offset_s), uint32(ne_guid_offset_e));
+
+    for (size_t i = ne_guid_offset_s; i <= ne_guid_offset_e; ++i)
+    {
+        if (!ReGuidBotEquip(line, i))
+            return false;
+    }
+
+    return true;
+}
+
+inline bool ReGuidItemInstance(std::string& line, uint32& nextGuid)
+{
+    /*
+    INSERT INTO `item_instance` (`creatorGuid`,`giftCreatorGuid`,`count`,`duration`,
+    `charges`,`flags`,`enchantments`,`randomPropertyId`,`durability`,`playedTime`,`t
+    ext`,`guid`,`itemEntry`,`owner_guid`) VALUES ('0','0','1','0','0 0 0 0 0 ','1','
+    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ','0','9
+    0','7200','','4296510','42490','0'),('0','0','1','0','0 0 0 0 0 ','0','0 0 0 0 0
+     0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 ','0','100','0','
+    ','4303949','48468','0'), etc.
+    */
+    static const size_t ii_guid_offset = TableImportDatas[TABLE_TYPE_ITEM_INSTANCE].guidOffsetBegin;
+    static const std::string ii_vals_sep = "('";
+    static const std::string ii_sep = "'";
+
+    //TC_LOG_ERROR("scripts", "import: ReGuidItemInstance ii_guid_offset %u", uint32(ii_guid_offset));
+
+    size_t pos1 = line.find(ii_vals_sep);
+    ASSERT(pos1 != std::string::npos);
+    while (pos1 != std::string::npos)
+    {
+        //TC_LOG_ERROR("scripts", "cur pos1 %i", int32(pos1));
+        bool reguidDone = false;
+        uint32 sepNum = 0;
+        size_t begin_pos = 0, end_pos = 0;
+        size_t pos2 = line.find(ii_sep, pos1 + 1);
+        ASSERT(pos2 != std::string::npos);
+        while (pos2 != std::string::npos)
+        {
+            ++sepNum;
+            //TC_LOG_ERROR("scripts", "cur pos2 %i sep %u s %u e %u, cval %u",
+            //    int32(pos2), sepNum, uint32(begin_pos), uint32(end_pos), uint32((sepNum-1) / 2));
+            if (begin_pos == 0 && !((sepNum-1) % 2) && ((sepNum-1) / 2) == ii_guid_offset)
+            {
+                begin_pos = pos2 + 1;
+                //TC_LOG_ERROR("scripts", "import: ReGuidItemInstance begin_pos %u", uint32(begin_pos));
+            }
+            else if (end_pos == 0 && ((sepNum-1) % 2) && ((sepNum-1) / 2) == ii_guid_offset)
+            {
+                end_pos = pos2;
+                //TC_LOG_ERROR("scripts", "import: ReGuidItemInstance end_pos %u", uint32(end_pos));
+            }
+
+            if (begin_pos && end_pos)
+            {
+                uint32 guidVal;
+                StringToVal(line, guidVal, begin_pos, end_pos);
+                if (!guidVal)
+                {
+                    TC_LOG_ERROR("scripts", "import: ReGuidItemInstance no guidVal from %s!",
+                        line.substr(begin_pos, end_pos - begin_pos).c_str());
+                    return false;
+                }
+                //this is not checked at dump save
+                if (itemReguidMap.count(guidVal) == 0)
+                    itemReguidMap[guidVal] = nextGuid;
+                else
+                    TC_LOG_ERROR("scripts", "import: ReGuidItemInstance item guid %u was already reguided to %u. Saved dump contains duplicate item guids - you'll have to fix them manually, proceeding anyways...",
+                        guidVal, itemReguidMap[guidVal]);
+
+                //TC_LOG_ERROR("scripts", "import: ReGuidItemInstance replacing %u with %u", guidVal, nextGuid);
+                line.replace(begin_pos, end_pos - begin_pos, ValToString(nextGuid));
+
+                ++nextGuid;
+                reguidDone = true;
+                break;
+            }
+
+            pos2 = line.find(ii_sep, pos2 + 1);
+        }
+
+        if (!reguidDone)
+        {
+            TC_LOG_ERROR("scripts", "import: ReGuidItemInstance reguid failed for string! Was:\n%s", line.c_str());
+            return false;
+        }
+
+        pos1 = line.find(ii_vals_sep, pos1 + 1);
+    }
+
+    return true;
+}
+
+inline bool ReGuidCreature(std::string& line)
+{
+    /*
+    INSERT INTO `item_instance` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position
+    _x`,`position_y`,`position_z`,`orientation`,`curhealth`,`curmana` VALUES ('12561
+    3','30102','571','0','0','1','1','0','0','5735.7','-3037.58','296.551','0.558505
+    ','120','0','0','1','0','0','0','0','0','','0');
+    */
+    static const size_t cr_guid_offset = TableImportDatas[TABLE_TYPE_CREATURE].guidOffsetBegin;
+    static const std::string cr_vals_sep = "('";
+    static const std::string cr_sep = "'";
+
+    bool reguidDone = false;
+    uint32 sepNum = 0;
+    size_t begin_pos = 0, end_pos = 0;
+
+    size_t pos = line.find(cr_vals_sep);
+    ASSERT(pos != std::string::npos);
+    pos = line.find(cr_sep);
+    ASSERT(pos != std::string::npos);
+    while (pos != std::string::npos)
+    {
+        ++sepNum;
+        //TC_LOG_ERROR("scripts", "import: ReGuidCreature sepNum %u", sepNum);
+        if (begin_pos == 0 && !((sepNum-1) % 2) && ((sepNum-1) / 2) == cr_guid_offset)
+        {
+            begin_pos = pos + 1;
+            //TC_LOG_ERROR("scripts", "import: ReGuidCreature begin_pos %u", uint32(begin_pos));
+        }
+        else if (end_pos == 0 && ((sepNum-1) % 2) && ((sepNum-1) / 2) == cr_guid_offset)
+        {
+            end_pos = pos;
+            //TC_LOG_ERROR("scripts", "import: ReGuidCreature end_pos %u", uint32(end_pos));
+        }
+
+        if (begin_pos && end_pos)
+        {
+            uint32 guidVal;
+            StringToVal(line, guidVal, begin_pos, end_pos);
+            if (!guidVal)
+            {
+                TC_LOG_ERROR("scripts", "import: ReGuidCreature no guidVal from %s!",
+                    line.substr(begin_pos, end_pos - begin_pos).c_str());
+                return false;
+            }
+
+            uint32 nextGuid = sObjectMgr->GenerateCreatureSpawnId();
+            //TC_LOG_ERROR("scripts", "import: ReGuidCreature replacing %u with %u", guidVal, nextGuid);
+            line.replace(begin_pos, end_pos - begin_pos, ValToString(nextGuid));
+
+            reguidDone = true;
+            break;
+        }
+
+        pos = line.find(cr_sep, pos + 1);
+    }
+
+    return reguidDone;
+}
+
+BotDataDumpResult NPCBotsDump::Load(std::string const& file)
+{
+    std::ifstream input(file.c_str());
+    if (!input)
+        return BOT_DUMP_FAIL_FILE_NOT_EXIST;
+
+    return LoadDump(input);
+}
+
+BotDataDumpResult NPCBotsDump::LoadDump(std::ifstream& input)
+{
+    //prepare data for existing entries checks
+    //bot entry
+    //first - from `characters_npcbot`
+    QueryResult result = CharacterDatabase.Query("SELECT `entry` FROM `characters_npcbot`");
+    Field* fields;
+    if (result)
+    {
+        fields = result->Fetch();
+        do
+        {
+            ExistingNPCBots.insert((*fields).GetUInt32());
+        } while (result->NextRow());
+    }
+    //second - join with entries from `creature` table (who knows what you have spawned there before you needed to import bots eh?)
+    result = WorldDatabase.Query("SELECT `id` FROM `creature` WHERE `id` IN (SELECT `entry` FROM `creature_template_npcbot_extras`) ORDER BY `id`");
+    if (result)
+    {
+        fields = result->Fetch();
+        do
+        {
+            ExistingNPCBots.insert((*fields).GetUInt32());
+        } while (result->NextRow());
+    }
+    //bot transmogs
+    result = CharacterDatabase.Query("SELECT `entry` FROM `characters_npcbot_transmog`");
+    if (result)
+    {
+        fields = result->Fetch();
+        do
+        {
+            ExistingNPCBotTransmogs.insert((*fields).GetUInt32());
+        } while (result->NextRow());
+    }
+    //item guid
+    result = CharacterDatabase.Query("SELECT MAX(`guid`) FROM `item_instance`");
+    ASSERT(result);
+    fields = result->Fetch();
+    static uint32 NextItemGuid = (*fields).GetUInt32() + 1;
+    //TC_LOG_ERROR("scripts", "import: NextItemGuid %u", NextItemGuid);
+
+    CharacterDatabaseTransaction ctrans = CharacterDatabase.BeginTransaction();
+    WorldDatabaseTransaction wtrans = WorldDatabase.BeginTransaction();
+
+    std::list<std::string> ctransStrings;
+    std::list<std::string> wtransStrings;
+
+    ImportDataTableType curImportDataTableType = IMPORT_TABLE_INVALID;
+    std::string curFieldsStr;
+    std::string curExecLine;
+    uint8 curParamCount = 0;
+
+    std::string line;
+    uint32 lineNum = 0;
+    while (std::getline(input, line))
+    {
+        ++lineNum;
+
+        size_t nw_pos = line.find_first_not_of(" \t\n\r\7");
+        if (nw_pos == std::string::npos)
+            continue;
+
+        static std::string const NoteLine = "IMPORTANT NOTE:";
+        if (line.substr(nw_pos, NoteLine.size()) == NoteLine)
+            continue;
+
+        if (curFieldsStr.empty())
+        {
+            std::string table_name = line.substr(line.find_first_of('`'));
+            //TC_LOG_ERROR("scripts", "import: found table %s", table_name.c_str());
+            curImportDataTableType = GetImportDataTableType(table_name);
+            switch (curImportDataTableType)
+            {
+                case TABLE_TYPE_CHARACTERS_NPCBOT:
+                case TABLE_TYPE_NPCBOT_TRANSMOG:
+                case TABLE_TYPE_ITEM_INSTANCE:
+                case TABLE_TYPE_CREATURE:
+                    curFieldsStr = TableImportDatas[curImportDataTableType].fieldsStr;
+                    break;
+                default:
+                    TC_LOG_ERROR("scripts", "import: unknown table %s at line %u", table_name.c_str(), lineNum);
+                    return BOT_DUMP_FAIL_FILE_CORRUPTED;
+            }
+
+            curExecLine += line;
+            continue;
+        }
+        else if (curParamCount == 0)
+        {
+            if (line.compare(curFieldsStr))
+                return BOT_DUMP_FAIL_FILE_CORRUPTED;
+
+            curParamCount = TableImportDatas[curImportDataTableType].paramsCount;
+            //TC_LOG_ERROR("scripts", "import: param count %u", uint32(curParamCount));
+
+            curExecLine += line;
+            continue;
+        }
+        else
+        {
+            if (GetImportLineParamsCount(line) != curParamCount)
+            {
+                TC_LOG_ERROR("scripts", "import: invalid param count %u at line %u", uint32(curParamCount), lineNum);
+                return BOT_DUMP_FAIL_FILE_CORRUPTED;
+            }
+
+            //check values conflicts, abort on existing values
+            size_t checkOffset = 0;
+            bool needCheckVal = false;
+            switch (curImportDataTableType)
+            {
+                case TABLE_TYPE_CHARACTERS_NPCBOT:
+                    //entry
+                    //checkOffset = 0;
+                    needCheckVal = true;
+                    break;
+                case TABLE_TYPE_NPCBOT_TRANSMOG:
+                    //entry
+                    //checkOffset = 0;
+                    needCheckVal = true;
+                    break;
+                default:
+                    break;
+            }
+            uint32 checkVal;
+            if (needCheckVal && !ExtractValueFromString(line, checkVal, checkOffset))
+            {
+                TC_LOG_ERROR("scripts", "import: unable to extract value from line %u at offset %u type %u",
+                    lineNum, uint32(checkOffset), uint32(curImportDataTableType));
+                return BOT_DUMP_FAIL_FILE_CORRUPTED;
+            }
+            switch (curImportDataTableType)
+            {
+                case TABLE_TYPE_CHARACTERS_NPCBOT:
+                    if (ExistingNPCBots.find(checkVal) != ExistingNPCBots.end())
+                    {
+                        TC_LOG_ERROR("scripts", "import: NPCBot id %u already exists in `characters_npcbot` or `creature` table! Aborting", checkVal);
+                        return BOT_DUMP_FAIL_DATA_OCCUPIED;
+                    }
+                    break;
+                case TABLE_TYPE_NPCBOT_TRANSMOG:
+                    if (ExistingNPCBotTransmogs.find(checkVal) != ExistingNPCBotTransmogs.end())
+                    {
+                        TC_LOG_ERROR("scripts", "import: NPCBot id %u already exists in `characters_npcbot_transmog` table! Aborting", checkVal);
+                        return BOT_DUMP_FAIL_DATA_OCCUPIED;
+                    }
+                    break;
+                default:
+                    break;
+            }
+
+            curExecLine += line;
+
+            //multi-line import
+            if (line[line.size()-1] == ',')
+                continue;
+            else if (line[line.size()-1] != ';')
+            {
+                TC_LOG_ERROR("scripts", "import: unexpected line ending at line %u", lineNum);
+                return BOT_DUMP_FAIL_FILE_CORRUPTED;
+            }
+        }
+
+        //reguid if needed
+        switch (curImportDataTableType)
+        {
+            case TABLE_TYPE_ITEM_INSTANCE:
+                if (!ReGuidItemInstance(curExecLine, NextItemGuid))
+                {
+                    TC_LOG_ERROR("scripts", "import: unable to reguid item instance at line %u!", lineNum);
+                    return BOT_DUMP_FAIL_FILE_CORRUPTED;
+                }
+                if (!ReGuidBotEquips(ctransStrings.back()))
+                {
+                    TC_LOG_ERROR("scripts", "import: unable to reguid bot equips at line %u:\n%s!", lineNum, ctransStrings.back().c_str());
+                    return BOT_DUMP_FAIL_FILE_CORRUPTED;
+                }
+                break;
+            case TABLE_TYPE_CREATURE:
+                if (!ReGuidCreature(curExecLine))
+                {
+                    TC_LOG_ERROR("scripts", "import: unable to reguid creature at line %u!", lineNum);
+                    return BOT_DUMP_FAIL_FILE_CORRUPTED;
+                }
+                break;
+            default:
+                break;
+        }
+
+        switch (curImportDataTableType)
+        {
+            case TABLE_TYPE_CHARACTERS_NPCBOT:
+            case TABLE_TYPE_NPCBOT_TRANSMOG:
+            case TABLE_TYPE_ITEM_INSTANCE:
+                //TC_LOG_ERROR("scripts", "import: adding to chars DB");
+                ctransStrings.push_back(curExecLine);
+                //ctrans->Append(curExecLine.c_str());
+                break;
+            case TABLE_TYPE_CREATURE:
+                //TC_LOG_ERROR("scripts", "import: adding to world DB");
+                wtransStrings.push_back(curExecLine);
+                //wtrans->Append(curExecLine.c_str());
+                break;
+            default:
+                ASSERT(false);
+        }
+
+        curParamCount = 0;
+        curExecLine.clear();
+        curFieldsStr.clear();
+        curImportDataTableType = IMPORT_TABLE_INVALID;
+    }
+
+    //check incomplete last query
+    if (!curExecLine.empty() || !curFieldsStr.empty() || curParamCount > 0 ||
+        curImportDataTableType != IMPORT_TABLE_INVALID)
+    {
+        TC_LOG_ERROR("scripts", "import: unexpected file ending, incomplete query %s, fields %s, type %u!",
+            curExecLine.c_str(), curFieldsStr.c_str(), uint32(curImportDataTableType));
+
+        return BOT_DUMP_FAIL_FILE_CORRUPTED;
+    }
+
+    //Replace all 'NULL' values as they are saved in dump with plain NULL
+    for (std::list<std::string>::iterator ci = ctransStrings.begin(); ci != ctransStrings.end(); ++ci)
+        FixNULLfields(*ci);
+    for (std::list<std::string>::iterator wi = wtransStrings.begin(); wi != wtransStrings.end(); ++wi)
+        FixNULLfields(*wi);
+
+    //TC_LOG_ERROR("scripts", "import: charDb execLines:");
+    for (std::list<std::string>::const_iterator ci = ctransStrings.begin(); ci != ctransStrings.end(); ++ci)
+    {
+        //TC_LOG_ERROR("scripts", "%s", (*ci).c_str());
+        ctrans->Append((*ci).c_str());
+    }
+    //TC_LOG_ERROR("scripts", "import: worldDb execLines:");
+    for (std::list<std::string>::const_iterator wi = wtransStrings.begin(); wi != wtransStrings.end(); ++wi)
+    {
+        //TC_LOG_ERROR("scripts", "%s", (*wi).c_str());
+        wtrans->Append((*wi).c_str());
+    }
+
+    CharacterDatabase.CommitTransaction(ctrans);
+    WorldDatabase.CommitTransaction(wtrans);
+
+    return BOT_DUMP_SUCCESS;
+}
+
+BotDataDumpResult NPCBotsDump::Write(std::string const& file)
+{
+    if (FILE* f = fopen(file.c_str(), "r"))
+    {
+        fclose(f);
+        return BOT_DUMP_FAIL_FILE_ALREADY_EXISTS;
+    }
+
+    BotDataDumpResult ret = BOT_DUMP_SUCCESS;
+    std::string dumpstr;
+    if (!GetDump(dumpstr))
+        ret = BOT_DUMP_FAIL_INCOMPLETE;
+
+    FILE* fout = fopen(file.c_str(), "w");
+    if (!fout)
+        return BOT_DUMP_FAIL_CANT_WRITE_TO_FILE;
+
+    fprintf(fout, "%s", dumpstr.c_str());
+    fclose(fout);
+
+    return ret;
+}
+
+bool NPCBotsDump::GetDump(std::string& dump)
+{
+    //bots are disabled but we need that data
+    if (!BotDataMgr::AllBotsLoaded())
+        BotDataMgr::LoadNpcBots(false);
+
+    dump = "";
+
+    dump += "IMPORTANT NOTE: THIS DUMPFILE IS MADE FOR USE WITH THE 'NPCBOT DUMP' COMMAND ONLY - EITHER THROUGH INGAME CHAT OR ON CONSOLE!\n";
+    dump += "IMPORTANT NOTE: DO NOT apply it directly - it will irreversibly DAMAGE and CORRUPT your database! You have been warned!\n\n";
+
+    BotStringTransaction trans;
+
+    std::set<uint32> valid_ids;
+    bool integrityChecked = true;
+    for (uint32 i : BotDataMgr::GetExistingNPCBotIds())
+    {
+        BotDataVerificationResult res = VerifyWriteData(i);
+        if (res == BOT_DATA_INCOMPLETE)
+        {
+            if (integrityChecked)
+                integrityChecked = false;
+        }
+        else if (res == BOT_DATA_VALID)
+            valid_ids.insert(i);
+    }
+
+    if (!integrityChecked || valid_ids.empty())
+        return false;
+
+    for (std::set<uint32>::const_iterator ci = valid_ids.begin(); ci != valid_ids.end(); ++ci)
+    {
+        AppendBotNPCBotData(&trans, *ci);
+        AppendBotNPCBotTransmogData(&trans, *ci);
+        AppendBotEquipsData(&trans, *ci);
+        AppendBotCreatureData(&trans, *ci);
+    }
+
+    dump += trans.GetBuffer();
+
+    return true;
+}
+
+BotDataVerificationResult NPCBotsDump::VerifyWriteData(uint32 entry) const
+{
+    NpcBotData const* botData = BotDataMgr::SelectNpcBotData(entry);
+
+    //bot of this entry is not spawned
+    if (!botData)
+        return BOT_DATA_NOT_EXIST;
+
+    int8 id = 1;
+    EquipmentInfo const* deinfo = sObjectMgr->GetEquipmentInfo(entry, id);
+    if (!deinfo)
+    {
+        TC_LOG_ERROR("scripts", "NPCBotsDump::AppendBotCreatureData creature %u is not found in `creature_equip_template` table!", entry);
+        return BOT_DATA_INCOMPLETE;
+    }
+
+    QueryResult result = WorldDatabase.PQuery("SELECT `guid` FROM `creature` WHERE `id` = %u", entry);
+
+    //creature is not spawned, corrupted
+    if (!result)
+    {
+        TC_LOG_ERROR("scripts", "NPCBotsDump::AppendBotCreatureData creature %u is not found in `creature` table!", entry);
+        return BOT_DATA_INCOMPLETE;
+    }
+    if (result->GetRowCount() > 1)
+    {
+        TC_LOG_ERROR("scripts", "NPCBotsDump::AppendBotCreatureData creature %u is spawned more that once!", entry);
+        return BOT_DATA_INCOMPLETE;
+    }
+
+    return BOT_DATA_VALID;
+}
+
+template<typename T>
+inline void AppendEscapedValue(std::ostringstream& ss, T const& val, bool end = false)
+{
+    ss << '\'' << val << '\'';
+    if (!end)
+        ss << ',';
+}
+inline void AppendNULL(std::ostringstream& ss, bool end = false)
+{
+    AppendEscapedValue(ss, "NULL", end);
+    //ss << "NULL";
+    //if (!end)
+    //    ss << ',';
+}
+std::string const EscapedString(char const* cstr)
+{
+    std::string s = cstr;
+    CharacterDatabase.EscapeString(s);
+    return s;
+}
+
+void NPCBotsDump::AppendBotNPCBotData(BotStringTransaction* trans, uint32 entry) const
+{
+    NpcBotData const* botData = BotDataMgr::SelectNpcBotData(entry);
+    ASSERT(botData);
+
+    std::ostringstream ss;
+    ss << "INSERT INTO " << TableImportDatas[TABLE_TYPE_CHARACTERS_NPCBOT].name << '\n'
+        << TableImportDatas[TABLE_TYPE_CHARACTERS_NPCBOT].fieldsStr << '\n';
+
+    ss << '(';
+
+    AppendEscapedValue(ss, entry);
+    AppendEscapedValue(ss, botData->owner);
+    AppendEscapedValue(ss, botData->roles);
+    AppendEscapedValue(ss, uint32(botData->spec));
+    AppendEscapedValue(ss, botData->faction);
+
+    if (botData->disabled_spells.empty())
+        AppendNULL(ss);
+    else
+    {
+        std::ostringstream ssds;
+        for (NpcBotData::DisabledSpellsContainer::const_iterator ci = botData->disabled_spells.begin(); ci != botData->disabled_spells.end(); ++ci)
+            ssds << *ci << ' ';
+        AppendEscapedValue(ss, ssds.str());
+    }
+
+    for (uint8 i = BOT_SLOT_MAINHAND; i != BOT_INVENTORY_SIZE; ++i)
+        AppendEscapedValue(ss, botData->equips[i], i == BOT_INVENTORY_SIZE-1);
+
+    ss << ");\n";
+
+    trans->Append(ss.str());
+}
+
+void NPCBotsDump::AppendBotNPCBotTransmogData(BotStringTransaction* trans, uint32 entry) const
+{
+    NpcBotData const* botData = BotDataMgr::SelectNpcBotData(entry);
+    ASSERT(botData);
+
+    QueryResult tresult = CharacterDatabase.PQuery("SELECT `entry`,`slot`,`item_id`,`fake_id` FROM `characters_npcbot_transmog` WHERE entry = %u", entry);
+
+    if (!tresult)
+        return;
+
+    std::ostringstream ss;
+    ss << "INSERT INTO " << TableImportDatas[TABLE_TYPE_NPCBOT_TRANSMOG].name << '\n'
+        << TableImportDatas[TABLE_TYPE_NPCBOT_TRANSMOG].fieldsStr << '\n';
+
+    static const uint32 transmog_fields_count = TableImportDatas[TABLE_TYPE_NPCBOT_TRANSMOG].paramsCount;
+
+    while (true)
+    {
+        Field* fields = tresult->Fetch();
+
+        ss << '(';
+
+        for (uint8 i = 0; i != transmog_fields_count; ++i)
+        {
+            bool end = i == transmog_fields_count - 1;
+            switch (i)
+            {
+                case 1:  //slot
+                    AppendEscapedValue(ss, uint32(fields[i].GetUInt8()), end);
+                    break;
+                default:
+                    AppendEscapedValue(ss,        fields[i].GetUInt32(), end);
+                    break;
+            }
+        }
+
+        if (tresult->NextRow())
+            ss << "),\n";
+        else
+        {
+            ss << ");\n";
+            break;
+        }
+    }
+
+    trans->Append(ss.str());
+}
+
+void NPCBotsDump::AppendBotEquipsData(BotStringTransaction* trans, uint32 entry) const
+{
+    NpcBotData const* botData = BotDataMgr::SelectNpcBotData(entry);
+    ASSERT(botData);
+
+    int8 id = 1;
+    EquipmentInfo const* deinfo = sObjectMgr->GetEquipmentInfo(entry, id);
+    ASSERT(deinfo);
+
+    CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+    //        0            1                2      3         4        5      6             7                 8           9           10    11    12         13
+    //"SELECT creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid, itemEntry, owner_guid "
+    //  "FROM item_instance WHERE guid IN (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_SYNCH
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        stmt->setUInt32(i, botData->equips[i]);
+
+    PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+
+    //all zeros? or maybe broken entry
+    if (!iiresult)
+        return;
+
+    std::ostringstream ss;
+    ss << "INSERT INTO " << TableImportDatas[TABLE_TYPE_ITEM_INSTANCE].name << '\n'
+        << TableImportDatas[TABLE_TYPE_ITEM_INSTANCE].fieldsStr << '\n';
+
+    static const uint32 item_instance_fields_count = TableImportDatas[TABLE_TYPE_ITEM_INSTANCE].paramsCount;
+
+    while (true)
+    {
+        Field* fields = iiresult->Fetch();
+
+        ss << '(';
+
+        for (uint8 i = 0; i != item_instance_fields_count; ++i)
+        {
+            bool end = i == item_instance_fields_count-1;
+            switch (i)
+            {
+                case 4:  //charges
+                case 6:  //enchantments
+                case 10: //text
+                {
+                    char const* cstr = fields[i].GetCString();
+                    if (!cstr)
+                        AppendNULL(ss, end);
+                    else
+                        AppendEscapedValue(ss, EscapedString(cstr), end);
+                    break;
+                }
+                case 7:  //randomPropertyId
+                    AppendEscapedValue(ss,      int32(fields[i].GetInt16()),   end);
+                    break;
+                case 8:  //durability
+                    AppendEscapedValue(ss,     uint32(fields[i].GetUInt16()),  end);
+                    break;
+                default:
+                    AppendEscapedValue(ss,            fields[i].GetUInt32(),   end);
+                    break;
+            }
+        }
+
+        if (iiresult->NextRow())
+            ss << "),\n";
+        else
+        {
+            ss << ");\n";
+            break;
+        }
+    }
+
+    trans->Append(ss.str());
+}
+
+void NPCBotsDump::AppendBotCreatureData(BotStringTransaction* trans, uint32 entry) const
+{
+    QueryResult cresult = WorldDatabase.PQuery("SELECT `guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`curhealth`,`curmana` FROM `creature` WHERE id = %u", entry);
+
+    ASSERT(cresult);
+
+    std::ostringstream ss;
+    ss << "INSERT INTO " << TableImportDatas[TABLE_TYPE_CREATURE].name << '\n'
+        << TableImportDatas[TABLE_TYPE_CREATURE].fieldsStr << '\n';
+
+    ss << '(';
+
+    static const uint32 creature_fields_count = TableImportDatas[TABLE_TYPE_CREATURE].paramsCount;
+
+    Field* fields = cresult->Fetch();
+
+    for (uint8 i = 0; i != creature_fields_count; ++i)
+    {
+        bool end = i == creature_fields_count-1;
+        switch (i)
+        {
+            case 5:  //position_x
+            case 6:  //position_y
+            case 7:  //position_z
+            case 8:  //orientation
+                ss.setf(std::ios_base::fixed);
+                ss.precision(6);
+                AppendEscapedValue(ss,            fields[i].GetFloat(),    end);
+                break;
+            case 3:  //spawnMask
+                AppendEscapedValue(ss,     uint32(fields[i].GetUInt8()),   end);
+                break;
+            case 2:  //map
+                AppendEscapedValue(ss,     uint32(fields[i].GetUInt16()),  end);
+                break;
+            default:
+                AppendEscapedValue(ss,            fields[i].GetUInt32(),   end);
+                break;
+        }
+    }
+
+    ss << ");\n";
+
+    trans->Append(ss.str());
+}
diff --git a/src/server/game/AI/NpcBots/botdump.h b/src/server/game/AI/NpcBots/botdump.h
new file mode 100644
index 000000000..16a6440fb
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botdump.h
@@ -0,0 +1,51 @@
+#ifndef _BOTDUMP_H
+#define _BOTDUMP_H
+
+#include "Define.h"
+
+#include <fstream>
+#include <string>
+
+enum BotDataDumpResult
+{
+    //all
+    BOT_DUMP_SUCCESS                    = 0,
+    //write
+    BOT_DUMP_FAIL_FILE_ALREADY_EXISTS,
+    BOT_DUMP_FAIL_CANT_WRITE_TO_FILE,
+    BOT_DUMP_FAIL_INCOMPLETE,
+    //load
+    BOT_DUMP_FAIL_FILE_NOT_EXIST,
+    BOT_DUMP_FAIL_FILE_CORRUPTED,
+    BOT_DUMP_FAIL_DATA_OCCUPIED
+};
+
+enum BotDataVerificationResult
+{
+    BOT_DATA_VALID                      = 0,
+    BOT_DATA_NOT_EXIST,
+    BOT_DATA_INCOMPLETE
+};
+
+class BotStringTransaction;
+
+class NPCBotsDump
+{
+    public:
+        NPCBotsDump() {}
+
+        BotDataDumpResult Write(std::string const& file);
+        BotDataDumpResult Load(std::string const& file);
+
+    private:
+        bool GetDump(std::string& dump);
+        BotDataVerificationResult VerifyWriteData(uint32 entry) const;
+        void AppendBotNPCBotData(BotStringTransaction* trans, uint32 entry) const;
+        void AppendBotNPCBotTransmogData(BotStringTransaction* trans, uint32 entry) const;
+        void AppendBotEquipsData(BotStringTransaction* trans, uint32 entry) const;
+        void AppendBotCreatureData(BotStringTransaction* trans, uint32 entry) const;
+
+        BotDataDumpResult LoadDump(std::ifstream& input);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botgiver.cpp b/src/server/game/AI/NpcBots/botgiver.cpp
new file mode 100644
index 000000000..ce1c2e104
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botgiver.cpp
@@ -0,0 +1,285 @@
+#include "bot_ai.h"
+#include "botcommon.h"
+#include "botdatamgr.h"
+#include "botgossip.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "botmgr.h"
+#include "Creature.h"
+#include "Log.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+/*
+NPCbot giver NPC by Trickerer (<https://github.com/Trickerer/> <onlysuffering@gmail.com>)
+Complete - 100%
+*/
+
+#define HIRE GOSSIP_SENDER_BOTGIVER_HIRE
+#define HIRE_CLASS GOSSIP_SENDER_BOTGIVER_HIRE_CLASS
+#define HIRE_ENTRY GOSSIP_SENDER_BOTGIVER_HIRE_ENTRY
+
+class script_bot_giver : public CreatureScript
+{
+public:
+    script_bot_giver() : CreatureScript("script_bot_giver") { }
+
+    struct bot_giver_AI : public CreatureAI
+    {
+        bot_giver_AI(Creature* creature) : CreatureAI(creature) {}
+
+        void UpdateAI(uint32 /*diff*/) override {}
+
+        bool OnGossipHello(Player* player) override
+        {
+            if (!BotMgr::IsNpcBotModEnabled())
+            {
+                player->PlayerTalkClass->SendCloseGossip();
+                return true;
+            }
+
+            if (me->isMoving())
+                me->BotStopMovement();
+
+            AddGossipItemFor(player, GOSSIP_ICON_TALK, bot_ai::LocalizedNpcText(player, BOT_TEXT_BOTGIVER_SERVICE), HIRE, GOSSIP_ACTION_INFO_DEF + 1);
+
+            AddGossipItemFor(player, GOSSIP_ICON_CHAT, bot_ai::LocalizedNpcText(player, BOT_TEXT_NEVERMIND), 0, GOSSIP_ACTION_INFO_DEF + 2);
+
+            player->PlayerTalkClass->SendGossipMenu(GOSSIP_BOTGIVER_GREET, me->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, uint32 /*menuId*/, uint32 gossipListId) override
+        {
+            if (!BotMgr::IsNpcBotModEnabled())
+            {
+                player->PlayerTalkClass->SendCloseGossip();
+                return true;
+            }
+
+            uint32 sender = player->PlayerTalkClass->GetGossipOptionSender(gossipListId);
+            uint32 action = player->PlayerTalkClass->GetGossipOptionAction(gossipListId);
+
+            player->PlayerTalkClass->ClearMenus();
+            bool subMenu = false;
+
+            uint32 gossipTextId = GOSSIP_BOTGIVER_GREET;
+
+            switch (sender)
+            {
+                case 0: //exit
+                    break;
+                case 1: //BACK: return to main menu
+                    return OnGossipHello(player);
+                case HIRE:
+                {
+                    gossipTextId = GOSSIP_BOTGIVER_HIRE;
+
+                    if (player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                    {
+                        WhisperTo(player, bot_ai::LocalizedNpcText(player, BOT_TEXT_BOTGIVER_TOO_MANY_BOTS).c_str());
+                        break;
+                    }
+
+                    subMenu = true;
+
+                    uint8 availCount = 0;
+                    std::array<uint32, BOT_CLASS_END> npcbot_count_per_class{ 0 };
+
+                    {
+                        std::unique_lock<std::shared_mutex> lock(*BotDataMgr::GetLock());
+                        for (Creature const* bot : BotDataMgr::GetExistingNPCBots())
+                        {
+                            if (!bot->IsAlive() || bot->IsTempBot() || bot->GetBotAI()->GetBotOwnerGuid() || bot->HasAura(BERSERK))
+                                continue;
+                            if (BotMgr::FilterRaces() && bot->GetBotClass() < BOT_CLASS_EX_START && (bot->GetRaceMask() & RACEMASK_ALL_PLAYABLE) &&
+                                !(bot->GetRaceMask() & ((player->GetRaceMask() & RACEMASK_ALLIANCE) ? RACEMASK_ALLIANCE : RACEMASK_HORDE)))
+                                continue;
+
+                            ++npcbot_count_per_class[bot->GetBotClass()];
+                        }
+                    }
+
+                    for (uint8 botclass = BOT_CLASS_WARRIOR; botclass < BOT_CLASS_END; ++botclass)
+                    {
+                        if (!BotMgr::IsClassEnabled(botclass))
+                            continue;
+
+                        if (player->HaveBot() && BotMgr::GetMaxClassBots())
+                        {
+                            uint8 count = 0;
+                            BotMap const* map = player->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                                if (itr->second->GetBotClass() == botclass)
+                                    ++count;
+                            if (count >= BotMgr::GetMaxClassBots())
+                                continue;
+                        }
+
+                        uint32 textId;
+                        switch (botclass)
+                        {
+                            case BOT_CLASS_WARRIOR:     textId = BOT_TEXT_CLASS_WARRIOR_PLU;        break;
+                            case BOT_CLASS_PALADIN:     textId = BOT_TEXT_CLASS_PALADIN_PLU;        break;
+                            case BOT_CLASS_MAGE:        textId = BOT_TEXT_CLASS_MAGE_PLU;           break;
+                            case BOT_CLASS_PRIEST:      textId = BOT_TEXT_CLASS_PRIEST_PLU;         break;
+                            case BOT_CLASS_WARLOCK:     textId = BOT_TEXT_CLASS_WARLOCK_PLU;        break;
+                            case BOT_CLASS_DRUID:       textId = BOT_TEXT_CLASS_DRUID_PLU;          break;
+                            case BOT_CLASS_DEATH_KNIGHT:textId = BOT_TEXT_CLASS_DEATH_KNIGHT_PLU;   break;
+                            case BOT_CLASS_ROGUE:       textId = BOT_TEXT_CLASS_ROGUE_PLU;          break;
+                            case BOT_CLASS_SHAMAN:      textId = BOT_TEXT_CLASS_SHAMAN_PLU;         break;
+                            case BOT_CLASS_HUNTER:      textId = BOT_TEXT_CLASS_HUNTER_PLU;         break;
+                            case BOT_CLASS_BM:          textId = BOT_TEXT_CLASS_BM_PLU;             break;
+                            case BOT_CLASS_SPHYNX:      textId = BOT_TEXT_CLASS_SPHYNX_PLU;         break;
+                            case BOT_CLASS_ARCHMAGE:    textId = BOT_TEXT_CLASS_ARCHMAGE_PLU;       break;
+                            case BOT_CLASS_DREADLORD:   textId = BOT_TEXT_CLASS_DREADLORD_PLU;      break;
+                            case BOT_CLASS_SPELLBREAKER:textId = BOT_TEXT_CLASS_SPELLBREAKER_PLU;   break;
+                            case BOT_CLASS_DARK_RANGER: textId = BOT_TEXT_CLASS_DARK_RANGER_PLU;    break;
+                            case BOT_CLASS_NECROMANCER: textId = BOT_TEXT_CLASS_NECROMANCER_PLU;    break;
+                            case BOT_CLASS_SEA_WITCH:   textId = BOT_TEXT_CLASS_SEAWITCH_PLU;       break;
+                            default:                    textId = 0;                                 break;
+                        }
+
+                        if (!textId)
+                            continue;
+
+                        std::ostringstream bclass;
+                        bclass << npcbot_count_per_class[botclass] << " " << bot_ai::LocalizedNpcText(player, textId) << " (" << BotMgr::GetNpcBotCostStr(player->GetLevel(), botclass) << ")";
+
+                        AddGossipItemFor(player, GOSSIP_ICON_TALK, bclass.str(), HIRE_CLASS, GOSSIP_ACTION_INFO_DEF + botclass);
+
+                        if (++availCount >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                            break;
+                    }
+
+                    if (availCount == 0)
+                        gossipTextId = GOSSIP_BOTGIVER_HIRE_EMPTY;
+
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, bot_ai::LocalizedNpcText(player, BOT_TEXT_NEVERMIND), 0, GOSSIP_ACTION_INFO_DEF + 1);
+
+                    break;
+                }
+                case HIRE_CLASS:
+                {
+                    gossipTextId = GOSSIP_BOTGIVER_HIRE_CLASS;
+
+                    uint8 botclass = action - GOSSIP_ACTION_INFO_DEF;
+
+                    uint32 cost = BotMgr::GetNpcBotCost(player->GetLevel(), botclass);
+                    if (!player->HasEnoughMoney(cost))
+                    {
+                        WhisperTo(player, bot_ai::LocalizedNpcText(player, BOT_TEXT_HIREFAIL_COST).c_str());
+                        break;
+                    }
+
+                    subMenu = true;
+
+                    uint8 availCount = 0;
+
+                    //go through bots map to find what bots are available
+                    std::unique_lock<std::shared_mutex> lock(*BotDataMgr::GetLock());
+                    NpcBotRegistry const& allBots = BotDataMgr::GetExistingNPCBots();
+                    for (NpcBotRegistry::const_iterator ci = allBots.begin(); ci != allBots.end(); ++ci)
+                    {
+                        Creature const* bot = *ci;
+                        bot_ai const* ai = bot->GetBotAI();
+                        if (bot->GetBotClass() != botclass || !bot->IsAlive() || ai->IsTempBot() || ai->GetBotOwnerGuid() || bot->HasAura(BERSERK))
+                            continue;
+                        if (BotMgr::FilterRaces() && botclass < BOT_CLASS_EX_START && (bot->GetRaceMask() & RACEMASK_ALL_PLAYABLE) &&
+                            !(bot->GetRaceMask() & ((player->GetRaceMask() & RACEMASK_ALLIANCE) ? RACEMASK_ALLIANCE : RACEMASK_HORDE)))
+                            continue;
+
+                        std::ostringstream message1;
+                        message1 << bot_ai::LocalizedNpcText(player, BOT_TEXT_BOTGIVER_WISH_TO_HIRE_) << bot->GetName() << '?';
+
+                        std::ostringstream info_ostr;
+                        uint32 raceTextId;
+                        switch (bot->GetRace())
+                        {
+                            case RACE_HUMAN:        raceTextId = BOT_TEXT_RACE_HUMAN;   break;
+                            case RACE_ORC:          raceTextId = BOT_TEXT_RACE_ORC;     break;
+                            case RACE_DWARF:        raceTextId = BOT_TEXT_RACE_DWARF;   break;
+                            case RACE_NIGHTELF:     raceTextId = BOT_TEXT_RACE_NELF;    break;
+                            case RACE_UNDEAD_PLAYER:raceTextId = BOT_TEXT_RACE_UNDEAD;  break;
+                            case RACE_TAUREN:       raceTextId = BOT_TEXT_RACE_TAUREN;  break;
+                            case RACE_GNOME:        raceTextId = BOT_TEXT_RACE_GNOME;   break;
+                            case RACE_TROLL:        raceTextId = BOT_TEXT_RACE_TROLL;   break;
+                            case RACE_BLOODELF:     raceTextId = BOT_TEXT_RACE_BELF;    break;
+                            case RACE_DRAENEI:      raceTextId = BOT_TEXT_RACE_DRAENEI; break;
+                            default:                raceTextId = BOT_TEXT_RACE_UNKNOWN; break;
+                        }
+                        info_ostr << bot->GetName() << " (" << (
+                            bot->GetGender() == GENDER_MALE ? bot_ai::LocalizedNpcText(player, BOT_TEXT_GENDER_MALE) + ' ' :
+                            bot->GetGender() == GENDER_FEMALE ? bot_ai::LocalizedNpcText(player, BOT_TEXT_GENDER_FEMALE) + ' ' :
+                            "") << bot_ai::LocalizedNpcText(player, raceTextId) << ')';
+
+                        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TALK, info_ostr.str(),
+                            HIRE_ENTRY, GOSSIP_ACTION_INFO_DEF + bot->GetEntry(), message1.str(), cost, false);
+
+                        if (++availCount >= BOT_GOSSIP_MAX_ITEMS - 1) //back
+                            break;
+                    }
+
+                    if (availCount == 0)
+                        gossipTextId = GOSSIP_BOTGIVER_HIRE_EMPTY;
+
+                    AddGossipItemFor(player, GOSSIP_ICON_CHAT, bot_ai::LocalizedNpcText(player, BOT_TEXT_BACK), HIRE, GOSSIP_ACTION_INFO_DEF + 1);
+
+                    break;
+                }
+                case HIRE_ENTRY:
+                {
+                    uint32 entry = action - GOSSIP_ACTION_INFO_DEF;
+                    Creature const* bot = BotDataMgr::FindBot(entry);
+                    if (!bot)
+                    {
+                        //possible but still
+                        TC_LOG_ERROR("entities.unit", "HIRE_NBOT_ENTRY: bot %u not found!", entry);
+                        break;
+                    }
+
+                    bot_ai const* ai = bot->GetBotAI();
+                    if (bot->IsInCombat() || !bot->IsAlive() || bot_ai::CCed(bot) || ai->IsDuringTeleport() ||
+                        bot->HasUnitState(UNIT_STATE_CASTING) || ai->GetBotOwnerGuid() || bot->HasAura(BERSERK))
+                    {
+                        //TC_LOG_ERROR("entities.unit", "HIRE_NBOT_ENTRY: bot %u (%s) is unavailable all of the sudden!", entry);
+                        std::ostringstream failMsg;
+                        failMsg << bot->GetName() << bot_ai::LocalizedNpcText(player, BOT_TEXT_BOTGIVER__BOT_BUSY);
+                        WhisperTo(player, failMsg.str().c_str());
+                        break;
+                    }
+
+                    //laways returns true
+                    bot->GetBotAI()->OnGossipSelect(player, me, GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF);
+
+                    if (player->HaveBot() && player->GetBotMgr()->GetBot(bot->GetGUID()))
+                        WhisperTo(player, bot_ai::LocalizedNpcText(player, BOT_TEXT_BOTGIVER_HIRESUCCESS).c_str());
+
+                    break;
+                }
+            }
+
+            if (subMenu)
+                player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+            else
+                player->PlayerTalkClass->SendCloseGossip();
+
+            return true;
+        }
+
+        void WhisperTo(Player* player, char const* message)
+        {
+            me->Whisper(message, LANG_UNIVERSAL, player);
+        }
+    };
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new bot_giver_AI(creature);
+    }
+};
+
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/game/AI/NpcBots/botgossip.h b/src/server/game/AI/NpcBots/botgossip.h
new file mode 100644
index 000000000..38c61f3de
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botgossip.h
@@ -0,0 +1,132 @@
+#ifndef BOTGOSSIP_H
+#define BOTGOSSIP_H
+
+#include "Define.h"
+
+enum BotGossips : uint32
+{
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_BOTGIVER_HIRE,
+    GOSSIP_SENDER_BOTGIVER_HIRE_CLASS,
+    GOSSIP_SENDER_BOTGIVER_HIRE_ENTRY,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_CLASS_ACTION,
+    GOSSIP_SENDER_CLASS_ACTION2,
+    GOSSIP_SENDER_CLASS_ACTION3,
+    GOSSIP_SENDER_CLASS_ACTION4,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_EQUIP_TRANSMOGS,
+    GOSSIP_SENDER_EQUIP_TRANSMOG_INFO,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_BEGIN = GOSSIP_SENDER_EQUIP_TRANSMOGRIFY,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_MHAND = GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_BEGIN,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_OHAND,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_RANGED,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_HEAD,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_CHEST,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_WAIST,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_LEGS,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_FEET,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_WRIST,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_HANDS,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_BACK,
+    GOSSIP_SENDER_EQUIP_TRANSMOGRIFY_BODY,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_UNEQUIP_ALL,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN = GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND = GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES_MAIN,
+    GOSSIP_SENDER_ROLES_MAIN_TOGGLE,
+    GOSSIP_SENDER_ROLES_GATHERING,
+    GOSSIP_SENDER_ROLES_GATHERING_TOGGLE,
+    GOSSIP_SENDER_ROLES_LOOTING,
+    GOSSIP_SENDER_ROLES_LOOTING_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+    GOSSIP_SENDER_ABILITIES_SPECIFICS_LIST,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST_DAMAGE,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST_CC,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST_HEAL,
+    GOSSIP_SENDER_ABILITIES_USAGE_LIST_SUPPORT,
+    GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_DAMAGE,
+    GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_CC,
+    GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_HEAL,
+    GOSSIP_SENDER_ABILITIES_USAGE_TOGGLE_SUPPORT,
+    GOSSIP_SENDER_SPEC,
+    GOSSIP_SENDER_SPEC_SET,
+    GOSSIP_SENDER_USEITEM,
+    GOSSIP_SENDER_USEITEM_USE,
+    GOSSIP_SENDER_HIRE,
+    GOSSIP_SENDER_DISMISS,
+    GOSSIP_SENDER_JOIN_GROUP,
+    GOSSIP_SENDER_LEAVE_GROUP,
+    GOSSIP_SENDER_FORMATION,
+    GOSSIP_SENDER_FORMATION_FOLLOW_DISTANCE_SET,
+    GOSSIP_SENDER_FORMATION_TOGGLE_COMBAT_POSITIONING,
+    GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE,
+    GOSSIP_SENDER_FORMATION_ATTACK_DISTANCE_SET,
+    GOSSIP_SENDER_FORMATION_ATTACK_ANGLE,
+    GOSSIP_SENDER_FORMATION_ATTACK_ANGLE_SET,
+    GOSSIP_SENDER_MODEL_UPDATE,
+    GOSSIP_SENDER_HOLDPOSITION,
+    GOSSIP_SENDER_DONOTHING,
+    GOSSIP_SENDER_FOLLOWME,
+    GOSSIP_SENDER_ENGAGE_BEHAVIOR,
+    GOSSIP_SENDER_ENGAGE_DELAY_SET_ATTACK,
+    GOSSIP_SENDER_ENGAGE_DELAY_SET_HEALING,
+    GOSSIP_SENDER_TROUBLESHOOTING,
+    GOSSIP_SENDER_TROUBLESHOOTING_FIX,
+    GOSSIP_SENDER_TROUBLESHOOTING_AURA,
+    GOSSIP_SENDER_SCAN,
+    GOSSIP_SENDER_DEBUG,
+    GOSSIP_SENDER_DEBUG_ACTION,
+//GOSSIP CONST
+    BOT_GOSSIP_MAX_ITEMS                = 32, // Client limitation 3.3.5 code confirmed
+};
+
+#endif //BOTGOSSIP_H
diff --git a/src/server/game/AI/NpcBots/botmgr.cpp b/src/server/game/AI/NpcBots/botmgr.cpp
new file mode 100644
index 000000000..791586953
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.cpp
@@ -0,0 +1,1771 @@
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "botdatamgr.h"
+#include "botdpstracker.h"
+#include "botmgr.h"
+#include "botspell.h"
+#include "bottext.h"
+#include "bpet_ai.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "InstanceScript.h"
+#include "Language.h"
+#include "Log.h"
+#include "Map.h"
+#include "MapManager.h"
+#include "MotionMaster.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "Transport.h"
+#include "World.h"
+/*
+Npc Bot Manager by Trickerer (onlysuffering@gmail.com)
+Player NpcBots management
+TODO: Move creature hooks here
+*/
+
+//config
+uint8 _basefollowdist;
+uint8 _maxNpcBots;
+uint8 _maxClassNpcBots;
+uint8 _xpReductionNpcBots;
+uint8 _healTargetIconFlags;
+uint8 _tankingTargetIconFlags;
+uint8 _offTankingTargetIconFlags;
+uint8 _dpsTargetIconFlags;
+uint8 _rangedDpsTargetIconFlags;
+uint8 _noDpsTargetIconFlags;
+int32 _botInfoPacketsLimit;
+uint32 _npcBotsCost;
+uint32 _npcBotUpdateDelayBase;
+uint32 _npcBotEngageDelayDPS_default;
+uint32 _npcBotEngageDelayHeal_default;
+uint32 _npcBotOwnerExpireTime;
+bool _enableNpcBots;
+bool _enableNpcBotsDungeons;
+bool _enableNpcBotsRaids;
+bool _enableNpcBotsBGs;
+bool _enableNpcBotsArenas;
+bool _enableDungeonFinder;
+bool _limitNpcBotsDungeons;
+bool _limitNpcBotsRaids;
+bool _botPvP;
+bool _botMovementFoodInterrupt;
+bool _filterRaces;
+bool _displayEquipment;
+bool _showCloak;
+bool _showHelm;
+bool _sendEquipListItems;
+bool _transmog_enable;
+bool _transmog_mixArmorClasses;
+bool _transmog_mixWeaponClasses;
+bool _transmog_mixWeaponInvTypes;
+bool _transmog_useEquipmentSlots;
+bool _enableclass_blademaster;
+bool _enableclass_sphynx;
+bool _enableclass_archmage;
+bool _enableclass_dreadlord;
+bool _enableclass_spellbreaker;
+bool _enableclass_darkranger;
+bool _enableclass_necromancer;
+bool _enableclass_seawitch;
+bool _enrageOnDismiss;
+bool _botStatLimits;
+float _botStatLimits_dodge;
+float _botStatLimits_parry;
+float _botStatLimits_block;
+float _botStatLimits_crit;
+float _mult_dmg_physical;
+float _mult_dmg_spell;
+float _mult_healing;
+float _mult_hp;
+
+bool __firstload = true;
+
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_blademaster_bot();
+void AddSC_sphynx_bot();
+void AddSC_archmage_bot();
+void AddSC_dreadlord_bot();
+void AddSC_spellbreaker_bot();
+void AddSC_dark_ranger_bot();
+void AddSC_necromancer_bot();
+void AddSC_sea_witch_bot();
+void AddSC_archmage_bot_pets();
+void AddSC_dreadlord_bot_pets();
+void AddSC_dark_ranger_bot_pets();
+void AddSC_necromancer_bot_pets();
+void AddSC_sea_witch_bot_pets();
+void AddSC_hunter_bot_pets();
+void AddSC_warlock_bot_pets();
+void AddSC_deathknight_bot_pets();
+void AddSC_priest_bot_pets();
+void AddSC_shaman_bot_pets();
+void AddSC_mage_bot_pets();
+void AddSC_druid_bot_pets();
+void AddSC_script_bot_commands();
+void AddSC_script_bot_giver();
+
+void AddNpcBotScripts()
+{
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_blademaster_bot();
+    AddSC_sphynx_bot();
+    AddSC_archmage_bot();
+    AddSC_dreadlord_bot();
+    AddSC_spellbreaker_bot();
+    AddSC_dark_ranger_bot();
+    AddSC_necromancer_bot();
+    AddSC_sea_witch_bot();
+    AddSC_archmage_bot_pets();
+    AddSC_dreadlord_bot_pets();
+    AddSC_dark_ranger_bot_pets();
+    AddSC_necromancer_bot_pets();
+    AddSC_sea_witch_bot_pets();
+    AddSC_hunter_bot_pets();
+    AddSC_warlock_bot_pets();
+    AddSC_deathknight_bot_pets();
+    AddSC_priest_bot_pets();
+    AddSC_shaman_bot_pets();
+    AddSC_mage_bot_pets();
+    AddSC_druid_bot_pets();
+    AddSC_script_bot_commands();
+    AddSC_script_bot_giver();
+}
+
+BotMgr::BotMgr(Player* const master) : _owner(master), _dpstracker(new DPSTracker())
+{
+    //LoadConfig(); already loaded (MapManager.cpp)
+    _followdist = _basefollowdist;
+    _exactAttackRange = 0;
+    _attackRangeMode = BOT_ATTACK_RANGE_SHORT;
+    _attackAngleMode = BOT_ATTACK_ANGLE_NORMAL;
+    _allowCombatPositioning = true;
+    _npcBotEngageDelayDPS = _npcBotEngageDelayDPS_default;
+    _npcBotEngageDelayHeal = _npcBotEngageDelayHeal_default;
+
+    _botsHidden = false;
+    _quickrecall = false;
+
+    _dpstracker->SetOwner(master->GetGUID().GetCounter());
+    master->SetBotMgr(this);
+}
+BotMgr::~BotMgr()
+{
+    delete _dpstracker;
+}
+
+void BotMgr::Initialize()
+{
+    LoadConfig();
+
+    if (!_enableNpcBots)
+        return;
+
+    BotDataMgr::LoadNpcBots();
+    BotDataMgr::LoadNpcBotGroupData();
+}
+
+void BotMgr::ReloadConfig()
+{
+    LoadConfig(true);
+}
+
+void BotMgr::LoadConfig(bool reload)
+{
+    if (__firstload)
+        __firstload = false;
+    else if (!reload)
+        return;
+
+    _enableNpcBots                  = sConfigMgr->GetBoolDefault("NpcBot.Enable", true);
+    _maxNpcBots                     = sConfigMgr->GetIntDefault("NpcBot.MaxBots", 1);
+    _maxClassNpcBots                = sConfigMgr->GetIntDefault("NpcBot.MaxBotsPerClass", 1);
+    _filterRaces                    = sConfigMgr->GetBoolDefault("NpcBot.Botgiver.FilterRaces", false);
+    _basefollowdist                 = sConfigMgr->GetIntDefault("NpcBot.BaseFollowDistance", 30);
+    _xpReductionNpcBots             = sConfigMgr->GetIntDefault("NpcBot.XpReduction", 0);
+    _healTargetIconFlags            = sConfigMgr->GetIntDefault("NpcBot.HealTargetIconMask", 0);
+    _tankingTargetIconFlags         = sConfigMgr->GetIntDefault("NpcBot.TankTargetIconMask", 0);
+    _offTankingTargetIconFlags      = sConfigMgr->GetIntDefault("NpcBot.OffTankTargetIconMask", 0);
+    _dpsTargetIconFlags             = sConfigMgr->GetIntDefault("NpcBot.DPSTargetIconMask", 0);
+    _rangedDpsTargetIconFlags       = sConfigMgr->GetIntDefault("NpcBot.RangedDPSTargetIconMask", 0);
+    _noDpsTargetIconFlags           = sConfigMgr->GetIntDefault("NpcBot.NoDPSTargetIconMask", 0);
+    _mult_dmg_physical              = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Physical", 1.0f);
+    _mult_dmg_spell                 = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Spell", 1.0f);
+    _mult_healing                   = sConfigMgr->GetFloatDefault("NpcBot.Mult.Healing", 1.0f);
+    _mult_hp                        = sConfigMgr->GetFloatDefault("NpcBot.Mult.HP", 1.0f);
+    _enableNpcBotsDungeons          = sConfigMgr->GetBoolDefault("NpcBot.Enable.Dungeon", true);
+    _enableNpcBotsRaids             = sConfigMgr->GetBoolDefault("NpcBot.Enable.Raid", false);
+    _enableNpcBotsBGs               = sConfigMgr->GetBoolDefault("NpcBot.Enable.BG", false);
+    _enableNpcBotsArenas            = sConfigMgr->GetBoolDefault("NpcBot.Enable.Arena", false);
+    _enableDungeonFinder            = sConfigMgr->GetBoolDefault("NpcBot.Enable.DungeonFinder", true);
+    _limitNpcBotsDungeons           = sConfigMgr->GetBoolDefault("NpcBot.Limit.Dungeon", true);
+    _limitNpcBotsRaids              = sConfigMgr->GetBoolDefault("NpcBot.Limit.Raid", true);
+    _botInfoPacketsLimit            = sConfigMgr->GetIntDefault("NpcBot.InfoPacketsLimit", -1);
+    _npcBotsCost                    = sConfigMgr->GetIntDefault("NpcBot.Cost", 1000000);
+    _npcBotUpdateDelayBase          = sConfigMgr->GetIntDefault("NpcBot.UpdateDelay.Base", 0);
+    _npcBotEngageDelayDPS_default   = sConfigMgr->GetIntDefault("NpcBot.EngageDelay.DPS", 0);
+    _npcBotEngageDelayHeal_default  = sConfigMgr->GetIntDefault("NpcBot.EngageDelay.Heal", 0);
+    _npcBotOwnerExpireTime          = sConfigMgr->GetIntDefault("NpcBot.OwnershipExpireTime", 0);
+    _botPvP                         = sConfigMgr->GetBoolDefault("NpcBot.PvP", true);
+    _botMovementFoodInterrupt       = sConfigMgr->GetBoolDefault("NpcBot.Movements.InterruptFood", false);
+    _displayEquipment               = sConfigMgr->GetBoolDefault("NpcBot.EquipmentDisplay.Enable", true);
+    _showCloak                      = sConfigMgr->GetBoolDefault("NpcBot.EquipmentDisplay.ShowCloak", true);
+    _showHelm                       = sConfigMgr->GetBoolDefault("NpcBot.EquipmentDisplay.ShowHelm", false);
+    _sendEquipListItems             = sConfigMgr->GetBoolDefault("NpcBot.Gossip.ShowEquipmentListItems", false);
+    _transmog_enable                = sConfigMgr->GetBoolDefault("NpcBot.Transmog.Enable", false);
+    _transmog_mixArmorClasses       = sConfigMgr->GetBoolDefault("NpcBot.Transmog.MixArmorClasses", false);
+    _transmog_mixWeaponClasses      = sConfigMgr->GetBoolDefault("NpcBot.Transmog.MixWeaponClasses", false);
+    _transmog_mixWeaponInvTypes     = sConfigMgr->GetBoolDefault("NpcBot.Transmog.MixWeaponInventoryTypes", false);
+    _transmog_useEquipmentSlots     = sConfigMgr->GetBoolDefault("NpcBot.Transmog.UseEquipmentSlots", false);
+    _enableclass_blademaster        = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Blademaster.Enable", true);
+    _enableclass_sphynx             = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.ObsidianDestroyer.Enable", true);
+    _enableclass_archmage           = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Archmage.Enable", true);
+    _enableclass_dreadlord          = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Dreadlord.Enable", true);
+    _enableclass_spellbreaker       = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.SpellBreaker.Enable", true);
+    _enableclass_darkranger         = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.DarkRanger.Enable", true);
+    _enableclass_necromancer        = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.Necromancer.Enable", true);
+    _enableclass_seawitch           = sConfigMgr->GetBoolDefault("NpcBot.NewClasses.SeaWitch.Enable", true);
+    _enrageOnDismiss                = sConfigMgr->GetBoolDefault("NpcBot.EnrageOnDismiss", true);
+    _botStatLimits                  = sConfigMgr->GetBoolDefault("NpcBot.Stats.Limits.Enable", false);
+    _botStatLimits_dodge            = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Dodge", 95.0f);
+    _botStatLimits_parry            = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Parry", 95.0f);
+    _botStatLimits_block            = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Block", 95.0f);
+    _botStatLimits_crit             = sConfigMgr->GetFloatDefault("NpcBot.Stats.Limits.Crit", 95.0f);
+
+    //limits
+    RoundToInterval(_mult_dmg_physical, 0.1f, 10.f);
+    RoundToInterval(_mult_dmg_spell, 0.1f, 10.f);
+    RoundToInterval(_mult_healing, 0.1f, 10.f);
+    RoundToInterval(_mult_hp, 0.1f, 10.f);
+
+    //exclusions
+    uint8 dpsFlags = /*_tankingTargetIconFlags | _offTankingTargetIconFlags | */_dpsTargetIconFlags | _rangedDpsTargetIconFlags;
+    if (uint8 interFlags = (_noDpsTargetIconFlags & dpsFlags))
+    {
+        _noDpsTargetIconFlags &= ~interFlags;
+        TC_LOG_ERROR("scripts", "BotMgr::LoadConfig: NoDPSTargetIconMask intersects with dps targets flags 0x%02X! Removed, new mask: 0x%02X",
+            uint32(interFlags), uint32(_noDpsTargetIconFlags));
+    }
+
+    bot_ai::InitBotCustomSpells();
+}
+
+uint8 BotMgr::GetNpcBotsCount() const
+{
+    //if (!inWorldOnly)
+        return (uint8)_bots.size();
+
+    //CRITICAL SECTION
+    //inWorldOnly is only for one-shot cases (opcodes, etc.)
+    //maybe convert to (bot && bot->isInWorld()) ?
+    //uint8 count = 0;
+    //for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    //    if (ObjectAccessor::GetObjectInWorld(itr->first, (Creature*)nullptr))
+    //        ++count;
+    //return count;
+}
+
+uint8 BotMgr::GetNpcBotsCountByRole(uint32 roles) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second && (roles & itr->second->GetBotRoles()))
+            ++count;
+    return count;
+}
+
+uint8 BotMgr::GetNpcBotsCountByVehicleEntry(uint32 creEntry) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second && itr->second->GetVehicle() && itr->second->GetVehicleBase()->GetEntry() == creEntry)
+            ++count;
+    return count;
+}
+
+uint8 BotMgr::GetNpcBotSlot(Creature const* bot) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        ++count;
+        if (itr->second == bot)
+            return count;
+    }
+    return 1;
+}
+
+uint8 BotMgr::GetNpcBotSlotByRole(uint32 roles, Creature const* bot) const
+{
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (roles & itr->second->GetBotRoles())
+        {
+            if (!(roles == BOT_ROLE_DPS && (itr->second->GetBotRoles() & BOT_ROLE_TANK)))
+                ++count;
+            if (itr->second == bot)
+                return count;
+        }
+    }
+    return 1;
+}
+
+uint32 BotMgr::GetAllNpcBotsClassMask() const
+{
+    uint32 classMask = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        classMask |= (1 << (itr->second->GetBotClass() - 1));
+
+    return classMask;
+}
+
+bool BotMgr::IsNpcBotModEnabled()
+{
+    return _enableNpcBots;
+}
+
+bool BotMgr::IsNpcBotDungeonFinderEnabled()
+{
+    return _enableDungeonFinder;
+}
+
+bool BotMgr::DisplayEquipment()
+{
+    return _displayEquipment;
+}
+
+bool BotMgr::ShowEquippedCloak()
+{
+    return _showCloak;
+}
+
+bool BotMgr::ShowEquippedHelm()
+{
+    return _showHelm;
+}
+
+bool BotMgr::SendEquipListItems()
+{
+    return _sendEquipListItems;
+}
+
+bool BotMgr::IsTransmogEnabled()
+{
+    return _transmog_enable;
+}
+bool BotMgr::MixArmorClasses()
+{
+    return _transmog_mixArmorClasses;
+}
+bool BotMgr::MixWeaponClasses()
+{
+    return _transmog_mixWeaponClasses;
+}
+bool BotMgr::MixWeaponInventoryTypes()
+{
+    return _transmog_mixWeaponInvTypes;
+}
+bool BotMgr::TransmogUseEquipmentSlots()
+{
+    return _transmog_useEquipmentSlots;
+}
+
+bool BotMgr::IsClassEnabled(uint8 m_class)
+{
+    switch (m_class)
+    {
+        case BOT_CLASS_BM:
+            return _enableclass_blademaster;
+        case BOT_CLASS_SPHYNX:
+            return _enableclass_sphynx;
+        case BOT_CLASS_ARCHMAGE:
+            return _enableclass_archmage;
+        case BOT_CLASS_DREADLORD:
+            return _enableclass_dreadlord;
+        case BOT_CLASS_SPELLBREAKER:
+            return _enableclass_spellbreaker;
+        case BOT_CLASS_DARK_RANGER:
+            return _enableclass_darkranger;
+        case BOT_CLASS_NECROMANCER:
+            return _enableclass_necromancer;
+        case BOT_CLASS_SEA_WITCH:
+            return _enableclass_seawitch;
+        default:
+            return true;
+    }
+}
+
+bool BotMgr::IsEnrageOnDimissEnabled()
+{
+    return _enrageOnDismiss;
+}
+bool BotMgr::IsBotStatsLimitsEnabled()
+{
+    return _botStatLimits;
+}
+bool BotMgr::IsPvPEnabled()
+{
+    return _botPvP;
+}
+bool BotMgr::IsFoodInterruptedByMovement()
+{
+    return _botMovementFoodInterrupt;
+}
+bool BotMgr::FilterRaces()
+{
+    return _filterRaces;
+}
+uint8 BotMgr::GetMaxClassBots()
+{
+    return _maxClassNpcBots;
+}
+uint8 BotMgr::GetHealTargetIconFlags()
+{
+    return _healTargetIconFlags;
+}
+uint8 BotMgr::GetTankTargetIconFlags()
+{
+    return _tankingTargetIconFlags;
+}
+uint8 BotMgr::GetOffTankTargetIconFlags()
+{
+    return _offTankingTargetIconFlags;
+}
+uint8 BotMgr::GetDPSTargetIconFlags()
+{
+    return _dpsTargetIconFlags;
+}
+uint8 BotMgr::GetRangedDPSTargetIconFlags()
+{
+    return _rangedDpsTargetIconFlags;
+}
+uint8 BotMgr::GetNoDPSTargetIconFlags()
+{
+    return _noDpsTargetIconFlags;
+}
+uint32 BotMgr::GetBaseUpdateDelay()
+{
+    return _npcBotUpdateDelayBase;
+}
+uint32 BotMgr::GetOwnershipExpireTime()
+{
+    return _npcBotOwnerExpireTime;
+}
+float BotMgr::GetBotStatLimitDodge()
+{
+    return _botStatLimits_dodge;
+}
+float BotMgr::GetBotStatLimitParry()
+{
+    return _botStatLimits_parry;
+}
+float BotMgr::GetBotStatLimitBlock()
+{
+    return _botStatLimits_block;
+}
+float BotMgr::GetBotStatLimitCrit()
+{
+    return _botStatLimits_crit;
+}
+
+uint8 BotMgr::GetNpcBotXpReduction()
+{
+    return _xpReductionNpcBots;
+}
+
+uint8 BotMgr::GetMaxNpcBots()
+{
+    return _maxNpcBots <= MAXRAIDSIZE - 1 ? _maxNpcBots : MAXRAIDSIZE - 1;
+}
+
+int32 BotMgr::GetBotInfoPacketsLimit()
+{
+    return _botInfoPacketsLimit;
+}
+
+bool BotMgr::LimitBots(Map const* map)
+{
+    if (map->IsBattlegroundOrArena())
+        return true;
+
+    if (_limitNpcBotsDungeons && map->IsNonRaidDungeon())
+        return true;
+    if (_limitNpcBotsRaids && map->IsRaid())
+        return true;
+
+    return false;
+}
+
+bool BotMgr::CanBotParryWhileCasting(Creature const* bot)
+{
+    switch (bot->GetBotClass())
+    {
+        case BOT_CLASS_SEA_WITCH:
+            return true;
+        default:
+            return false;
+    }
+}
+
+void BotMgr::Update(uint32 diff)
+{
+    //remove temp bots from bot map before updating it
+    while (!_removeList.empty())
+    {
+        std::list<ObjectGuid>::iterator itr = _removeList.begin();
+
+        BotMap::iterator bitr = _bots.find(*itr);
+        ASSERT(bitr != _bots.end());
+        _bots.erase(bitr);
+
+        _removeList.erase(itr);
+    }
+
+    _dpstracker->Update(diff);
+
+    if (!HaveBot())
+        return;
+
+    //ObjectGuid guid;
+    Creature* bot;
+    bot_ai* ai;
+    bool partyCombat = IsPartyInCombat();
+    bool restrictBots = RestrictBots(nullptr, false);
+
+    _aoespots.clear();
+    if (partyCombat)
+        bot_ai::CalculateAoeSpots(_owner, _aoespots);
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        //guid = itr->first;
+        bot = itr->second;
+        ai = bot->GetBotAI();
+
+        if (ai->IAmFree())
+            continue;
+
+        if (!bot->IsInWorld())
+        {
+            ai->CommonTimers(diff);
+            continue;
+        }
+
+        if (partyCombat == false)
+            ai->UpdateReviveTimer(diff);
+
+        //bot->IsAIEnabled = true;
+
+        if (ai->GetReviveTimer() <= diff)
+        {
+            if (bot->IsInWorld() && !bot->IsAlive() && _owner->IsAlive() && !_owner->IsInCombat() &&
+                !_owner->IsBeingTeleported() && !_owner->InArena() && !_owner->IsInFlight() &&
+                !_owner->HasUnitFlag2(UNIT_FLAG2_FEIGN_DEATH) &&
+                !_owner->HasInvisibilityAura() && !_owner->HasStealthAura())
+            {
+                _reviveBot(bot);
+                continue;
+            }
+
+            ai->SetReviveTimer(urand(1000, 5000));
+        }
+
+        if (_owner->IsAlive() && (bot->IsAlive() || restrictBots) && !ai->IsTempBot() && !ai->IsDuringTeleport() &&
+            (restrictBots || bot->GetMap() != _owner->GetMap() ||
+            (!bot->GetBotAI()->HasBotCommandState(BOT_COMMAND_STAY) && _owner->GetDistance(bot) > SIZE_OF_GRIDS)))
+        {
+            //_owner->m_Controlled.erase(bot);
+            TeleportBot(bot, _owner->GetMap(), _owner, _quickrecall);
+            continue;
+        }
+
+        ai->canUpdate = true;
+        bot->Update(diff);
+        ai->canUpdate = false;
+    }
+
+    if (_quickrecall)
+    {
+        _quickrecall = false;
+        _botsHidden = false;
+    }
+}
+
+bool BotMgr::RestrictBots(Creature const* bot, bool add) const
+{
+    if (!_owner->FindMap())
+        return true;
+
+    if (_owner->IsInFlight())
+        return true;
+
+    if (_botsHidden)
+        return true;
+
+    Map const* currMap = _owner->GetMap();
+
+    if ((!_enableNpcBotsBGs && currMap->IsBattleground()) ||
+        (!_enableNpcBotsArenas && currMap->IsBattleArena()) ||
+        (!_enableNpcBotsDungeons && currMap->IsNonRaidDungeon()) ||
+        (!_enableNpcBotsRaids && currMap->IsRaid()))
+        return true;
+
+    if (LimitBots(currMap))
+    {
+        //if bot is not in instance group - deny (only if trying to teleport to instance)
+        if (add)
+            if (!_owner->GetGroup() || !_owner->GetGroup()->IsMember(bot->GetGUID()))
+                return true;
+
+        uint32 max_players = 0;
+        if (currMap->IsDungeon())
+            max_players = currMap->ToInstanceMap()->GetMaxPlayers();
+        else if (currMap->IsBattleground())
+            max_players = _owner->GetBattleground()->GetMaxPlayersPerTeam();
+        else if (currMap->IsBattleArena())
+            max_players = _owner->GetBattleground()->GetArenaType();
+
+        if (max_players && currMap->GetPlayersCountExceptGMs() + uint32(add) > max_players)
+            return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::IsPartyInCombat() const
+{
+    if (_owner->IsInCombat())
+        return true;
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (!itr->second->IsInWorld())
+            continue;
+        if (itr->second->IsInCombat())
+            return true;
+        if (Unit const* pet = itr->second->GetBotsPet())
+            if (pet->IsInCombat())
+                return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::HasBotClass(uint8 botclass) const
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->GetBotClass() == botclass)
+            return true;
+
+    return false;
+}
+
+bool BotMgr::HasBotWithSpec(uint8 spec, bool alive) const
+{
+    for (BotMap::const_iterator itr = _bots.cbegin(); itr != _bots.cend(); ++itr)
+        if (itr->second->GetBotAI()->GetSpec() == spec && (!alive || itr->second->IsAlive()))
+            return true;
+
+    return false;
+}
+
+bool BotMgr::HasBotPetType(uint32 petType) const
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (itr->second->GetBotsPet() && itr->second->GetBotAI()->GetAIMiscValue(BOTAI_MISC_PET_TYPE) == petType)
+            return true;
+
+    return false;
+}
+
+bool BotMgr::IsBeingResurrected(WorldObject const* corpse) const
+{
+    std::vector<Unit const*> casters;
+    if (_owner->IsNonMeleeSpellCast(false, true, true))
+        casters.push_back(_owner);
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (itr->second->IsNonMeleeSpellCast(false, true, true))
+            casters.push_back(itr->second);
+    }
+
+    if (Group const* group = _owner->GetGroup())
+    {
+        for (GroupReference const* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player const* player = itr->GetSource();
+            if (!player || player == _owner || player->FindMap() != corpse->GetMap())
+                continue;
+
+            if (player->IsNonMeleeSpellCast(false, true, true))
+                casters.push_back(player);
+
+            if (player->HaveBot())
+            {
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    if (bitr->second->IsNonMeleeSpellCast(false, true, true))
+                        casters.push_back(bitr->second);
+                }
+            }
+        }
+    }
+
+    for (Unit const* caster : casters)
+    {
+        if (Spell const* spell = caster->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+        {
+            if (corpse->GetGUID() == (corpse->ToCorpse() ? spell->m_targets.GetCorpseTargetGUID() : spell->m_targets.GetUnitTargetGUID()))
+                return true;
+        }
+    }
+
+    return false;
+}
+
+void BotMgr::_reviveBot(Creature* bot, WorldLocation* dest)
+{
+    if (bot->IsAlive())
+        return;
+
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        if (!dest)
+            bot->CastSpell(bot, COSMETIC_RESURRECTION, false);
+
+        if (!dest)
+            dest = bot->GetBotOwner();
+
+        bot->NearTeleportTo(dest->GetPositionX(), dest->GetPositionY(), dest->GetPositionZ(), dest->GetOrientation());
+        //some weird pos manipulation
+        if (dest != bot)
+            bot->Relocate(dest);
+    }
+
+    bot->SetDisplayId(bot->GetNativeDisplayId());
+    bot->ReplaceAllNpcFlags(NPCFlags(bot->GetCreatureTemplate()->npcflag));
+    bot->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+    bot->ReplaceAllUnitFlags(UnitFlags(0));
+    bot->SetPvP(bot->GetBotOwner()->IsPvP());
+    bot->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+    bot->setDeathState(ALIVE);
+    //bot->GetBotAI()->Reset();
+    bot->GetBotAI()->SetShouldUpdateStats();
+
+    bot->SetHealth(bot->GetMaxHealth() / 4); //25% of max health
+    if (bot->GetMaxPower(POWER_MANA) > 1)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA) / 4); //25% of max mana
+
+    if (!bot->GetBotAI()->IAmFree() && !bot->GetBotAI()->HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        bot->GetBotAI()->SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+}
+
+Creature* BotMgr::GetBot(ObjectGuid guid) const
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    return itr != _bots.end() ? itr->second : nullptr;
+}
+
+Creature* BotMgr::GetBotByName(std::string_view name) const
+{
+    std::wstring wname;
+    if (Utf8toWStr(name, wname))
+    {
+        wstrToLower(wname);
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        {
+            if (!itr->second)
+                continue;
+
+            std::string basename = itr->second->GetName();
+            if (CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(itr->second->GetEntry()))
+            {
+                uint32 loc = _owner->GetSession()->GetSessionDbLocaleIndex();
+                if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+                    basename = creatureInfo->Name[loc];
+            }
+
+            std::wstring wbname;
+            if (!Utf8toWStr(basename, wbname))
+                continue;
+
+            wstrToLower(wbname);
+            if (wbname == wname)
+                return itr->second;
+        }
+    }
+
+    return nullptr;
+}
+
+std::list<Creature*> BotMgr::GetAllBotsByClass(uint8 botclass) const
+{
+    std::list<Creature*> foundBots;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (!itr->second || !itr->second->IsInWorld() || !itr->second->IsAlive())
+            continue;
+
+        if (itr->second->GetBotClass() == botclass)
+            foundBots.push_back(itr->second);
+    }
+
+    return foundBots;
+}
+
+void BotMgr::OnOwnerSetGameMaster(bool on)
+{
+    Creature* bot;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        if (!bot)
+            continue;
+
+        bot->SetFaction(_owner->GetFaction());
+        //bot->getHostileRefManager().setOnlineOfflineState(!on);
+        bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1)); //pvp state
+
+        if (on && bot->IsInWorld())
+            bot->CombatStop(true);
+
+        if (Unit* pet = bot->GetBotsPet())
+        {
+            pet->SetFaction(_owner->GetFaction());
+            //pet->getHostileRefManager().setOnlineOfflineState(!on);
+            pet->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1)); //pvp state
+
+            if (on)
+                pet->CombatStop(true);
+        }
+    }
+}
+
+void BotMgr::OnTeleportFar(uint32 mapId, float x, float y, float z, float ori)
+{
+    Map* newMap = sMapMgr->CreateBaseMap(mapId);
+    Creature* bot;
+    Position pos;
+    pos.Relocate(x, y, z, ori);
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        ASSERT(bot, "BotMgr::OnTeleportFar(): bot does not exist!!!");
+
+        if (bot->IsTempBot())
+            continue;
+
+        //_owner->m_Controlled.erase(bot);
+        TeleportBot(bot, newMap, &pos);
+    }
+}
+
+void BotMgr::_teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori, bool quick)
+{
+    ASSERT(bot->GetBotAI());
+    bot->GetBotAI()->AbortTeleport();
+
+    bot->GetBotAI()->KillEvents(true);
+
+    if (bot->GetVehicle())
+        bot->ExitVehicle();
+
+    if (bot->GetTransport())
+    {
+        bot->ClearUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+        bot->GetTransport()->RemovePassenger(bot);
+    }
+
+    if (bot->IsInWorld())
+        bot->CastSpell(bot, COSMETIC_TELEPORT_EFFECT, true);
+
+    if (Map* mymap = bot->FindMap())
+    {
+        bot->BotStopMovement();
+        bot->GetBotAI()->UnsummonAll();
+
+        bot->InterruptNonMeleeSpells(true);
+        if (bot->IsInWorld())
+        {
+            if (!bot->IsFreeBot())
+                if (InstanceScript* iscr = bot->GetBotOwner()->GetInstanceScript())
+                    iscr->OnNPCBotLeave(bot);
+
+            bot->RemoveFromWorld();
+        }
+
+        ASSERT(bot->GetGUID());
+
+        bot->RemoveAllGameObjects();
+
+        bot->m_Events.KillAllEvents(false);
+        bot->CombatStop();
+        bot->ClearComboPoints();
+        bot->ClearComboPointHolders();
+
+        mymap->RemoveFromMap(bot, false);
+    }
+
+    if (bot->IsFreeBot())
+    {
+        bot->Relocate(x, y, z, ori);
+        bot->SetMap(newMap);
+        bot->GetMap()->AddToMap(bot);
+        return;
+    }
+
+    //update group member online state
+    if (Group* gr = bot->GetBotOwner()->GetGroup())
+        if (gr->IsMember(bot->GetGUID()))
+            gr->SendUpdate();
+
+    TeleportFinishEvent* finishEvent = new TeleportFinishEvent(bot->GetBotAI());
+    std::chrono::milliseconds delay(quick ? urand(500, 1500) : urand(5000, 8000));
+    bot->GetBotAI()->GetEvents()->AddEvent(finishEvent, bot->GetBotAI()->GetEvents()->CalculateTime(delay));
+    bot->GetBotAI()->SetTeleportFinishEvent(finishEvent);
+}
+
+void BotMgr::TeleportBot(Creature* bot, Map* newMap, Position* pos, bool quick)
+{
+    _teleportBot(bot, newMap, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation(), quick);
+}
+
+void BotMgr::CleanupsBeforeBotDelete(ObjectGuid guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end(), "Trying to remove bot which does not belong to this botmgr(b)!!");
+    //ASSERT(_owner->IsInWorld(), "Trying to remove bot while not in world(b)!!");
+
+    Creature* bot = itr->second;
+
+    //don't allow removing bots while they are teleporting
+    if (!bot->IsInWorld())
+        bot->GetBotAI()->AbortTeleport();
+
+    if (bot->GetVehicle())
+        bot->ExitVehicle();
+
+    RemoveBotFromBGQueue(bot);
+    if (removetype != BOT_REMOVE_LOGOUT)
+        RemoveBotFromGroup(bot);
+
+    //remove any summons
+    bot->GetBotAI()->UnsummonAll();
+
+    ASSERT(bot->GetCreatorGUID() == _owner->GetGUID());
+    //bot->SetOwnerGUID(ObjectGuid::Empty);
+    //_owner->m_Controlled.erase(bot);
+    bot->SetControlledByPlayer(false);
+    //bot->RemoveUnitFlag(UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+    bot->SetCreator(nullptr);
+
+    Map* map = bot->FindMap();
+    if (!map || map->IsDungeon())
+        bot->RemoveFromWorld();
+}
+
+void BotMgr::_addBotToRemoveList(ObjectGuid guid)
+{
+    _removeList.push_back(guid);
+}
+
+void BotMgr::RemoveAllBots(uint8 removetype)
+{
+    while (!_bots.empty())
+        RemoveBot(_bots.begin()->second->GetGUID(), removetype);
+}
+//Bot is being abandoned by player
+void BotMgr::RemoveBot(ObjectGuid guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end(), "Trying to remove bot which does not belong to this botmgr(a)!!");
+    //ASSERT(_owner->IsInWorld(), "Trying to remove bot while not in world(a)!!");
+
+    //trying to remove temp bot second time means removing all bots
+    //just erase from bots because already cleaned up
+    for (std::list<ObjectGuid>::iterator it = _removeList.begin(); it != _removeList.end(); ++it)
+    {
+        if (*it == guid)
+        {
+            _removeList.erase(it);
+            _bots.erase(itr);
+            return;
+        }
+    }
+
+    Creature* bot = itr->second;
+    CleanupsBeforeBotDelete(guid, removetype);
+
+    ////remove control bar
+    //if (GetNpcBotsCount() <= 1 && !_owner->GetPetGUID() && _owner->m_Controlled.empty())
+    //    _owner->SendRemoveControlBar();
+
+    if (bot->GetBotAI()->IsTempBot())
+    {
+        //bot->GetBotAI()->OnBotDespawn(bot); //send to self
+        _addBotToRemoveList(guid);
+        return;
+    }
+
+    _bots.erase(itr);
+
+    bot->GetBotAI()->ResetBotAI(removetype == BOT_REMOVE_DISMISS ? BOTAI_RESET_DISMISS : BOTAI_RESET_LOGOUT);
+
+    bot->SetFaction(bot->GetCreatureTemplate()->faction);
+    bot->SetLevel(bot->GetCreatureTemplate()->minlevel);
+
+    if (removetype == BOT_REMOVE_DISMISS)
+    {
+        BotDataMgr::ResetNpcBotTransmogData(bot->GetEntry(), false);
+        uint32 newOwner = 0;
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+    }
+
+    bot->GetBotAI()->Reset();
+    bot->GetBotAI()->canUpdate = true;
+}
+
+BotAddResult BotMgr::AddBot(Creature* bot, bool takeMoney)
+{
+    ASSERT(bot->IsNPCBot());
+    ASSERT(bot->GetBotAI() != nullptr);
+
+    bool temporary = bot->GetBotAI()->IsTempBot();
+
+    if (!_enableNpcBots)
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.SendSysMessage(bot_ai::LocalizedNpcText(GetOwner(), BOT_TEXT_BOTADDFAIL_DISABLED).c_str());
+        return BOT_ADD_DISABLED;
+    }
+    if (GetBot(bot->GetGUID()))
+        return BOT_ADD_ALREADY_HAVE; //Silent error, intended
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage(bot_ai::LocalizedNpcText(GetOwner(), BOT_TEXT_BOTADDFAIL_OWNED).c_str(),
+            bot->GetName().c_str(), bot->GetBotOwner()->GetName().c_str());
+        return BOT_ADD_NOT_AVAILABLE;
+    }
+    if (bot->GetBotAI()->IsDuringTeleport())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage(bot_ai::LocalizedNpcText(GetOwner(), BOT_TEXT_BOTADDFAIL_TELEPORTED).c_str(), bot->GetName().c_str());
+        return BOT_ADD_BUSY;
+    }
+    if (!temporary && _owner->GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage(bot_ai::LocalizedNpcText(GetOwner(), BOT_TEXT_HIREFAIL_MAXBOTS).c_str(), GetMaxNpcBots());
+        return BOT_ADD_MAX_EXCEED;
+    }
+    if (!temporary && HaveBot() && _maxClassNpcBots)
+    {
+        uint8 count = 0;
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetBotClass() == bot->GetBotClass())
+                ++count;
+
+        if (count >= _maxClassNpcBots)
+        {
+            ChatHandler ch(_owner->GetSession());
+            ch.PSendSysMessage(bot_ai::LocalizedNpcText(GetOwner(), BOT_TEXT_HIREFAIL_MAXCLASSBOTS).c_str(), count, _maxClassNpcBots);
+            return BOT_ADD_MAX_CLASS_EXCEED;
+        }
+    }
+    //Map* curMap = _owner->GetMap();
+    //if (!temporary && LimitBots(curMap))
+    //{
+    //    InstanceMap* map = curMap->ToInstanceMap();
+    //    uint32 count = map->GetPlayersCountExceptGMs();
+    //    if (count >= map->GetMaxPlayers())
+    //    {
+    //        ChatHandler ch(_owner->GetSession());
+    //        ch.PSendSysMessage("Instance players limit exceed (%u of %u)", count, map->GetMaxPlayers());
+    //        return BOT_ADD_INSTANCE_LIMIT;
+    //    }
+    //}
+    if (!temporary && takeMoney)
+    {
+        uint32 cost = GetNpcBotCost(_owner->GetLevel(), bot->GetBotClass());
+        if (!_owner->HasEnoughMoney(cost))
+        {
+            ChatHandler ch(_owner->GetSession());
+            std::string str = bot_ai::LocalizedNpcText(GetOwner(), BOT_TEXT_HIREFAIL_COST) + " (";
+            str += GetNpcBotCostStr(_owner->GetLevel(), bot->GetBotClass());
+            str += ")!";
+            ch.SendSysMessage(str.c_str());
+            return BOT_ADD_CANT_AFFORD;
+        }
+
+        _owner->ModifyMoney(-(int32(cost)));
+    }
+
+    bot->GetBotAI()->canUpdate = false;
+
+    if (!bot->IsAlive())
+        _reviveBot(bot);
+
+    bot->GetBotAI()->UnsummonAll();
+
+    _bots[bot->GetGUID()] = bot;
+
+    ASSERT(!bot->GetCreatorGUID());
+    //bot->SetOwnerGUID(_owner->GetGUID());
+    bot->SetCreator(_owner); //needed in case of FFAPVP
+    //_owner->m_Controlled.insert(bot);
+    bot->SetControlledByPlayer(true);
+    bot->SetUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+    bot->SetFaction(_owner->GetFaction());
+    bot->SetPhaseMask(_owner->GetPhaseMask(), true);
+
+    bot->GetBotAI()->SetBotOwner(_owner);
+
+    bot->GetBotAI()->Reset();
+
+    if (!temporary)
+    {
+        bot->GetBotAI()->SetBotCommandState(BOT_COMMAND_FOLLOW, true);
+        if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            AddBotToGroup(bot);
+
+        uint32 newOwner = _owner->GetGUID().GetCounter();
+        BotDataMgr::UpdateNpcBotData(bot->GetEntry(), NPCBOT_UPDATE_OWNER, &newOwner);
+    }
+
+    return BOT_ADD_SUCCESS;
+}
+
+bool BotMgr::AddBotToGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (gr)
+    {
+        if (gr->IsMember(bot->GetGUID()))
+            return true;
+
+        if (gr->IsFull())
+        {
+            if (!gr->isRaidGroup()) //non-raid group is full
+                gr->ConvertToRaid();
+            else
+                return false;
+        }
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(_owner))
+        {
+            delete gr;
+            return false;
+        }
+        sGroupMgr->AddGroup(gr);
+    }
+
+    if (gr->AddMember((Player*)bot))
+    {
+        if (!bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+        return true;
+    }
+
+    return false;
+}
+
+void BotMgr::RemoveBotFromBGQueue(Creature const* bot)
+{
+    for (uint8 i = 0; i < PLAYER_MAX_BATTLEGROUND_QUEUES; ++i)
+    {
+        if (BattlegroundQueueTypeId bgQueueTypeId = _owner->GetBattlegroundQueueTypeId(i))
+            sBattlegroundMgr->GetBattlegroundQueue(bgQueueTypeId).RemovePlayer(bot->GetGUID(), true);
+    }
+}
+
+bool BotMgr::RemoveBotFromGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (!gr || !gr->IsMember(bot->GetGUID()))
+        return false;
+
+    RemoveBotFromBGQueue(bot);
+
+    if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY) && !_owner->GetSession()->PlayerLogout())
+        bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+    //debug
+    //if (gr->RemoveMember(bot->GetGUID()))
+    //    TC_LOG_ERROR("entities.player", "RemoveBotFromGroup(): bot %s removed from group", bot->GetName().c_str());
+    //else
+    //    TC_LOG_ERROR("entities.player", "RemoveBotFromGroup(): RemoveMember() returned FALSE on bot %s", bot->GetName().c_str());
+
+    gr->RemoveMember(bot->GetGUID());
+
+    //if removed from group while in instance / bg then remove from world immediately
+    if (bot->IsInWorld() && RestrictBots(bot, true))
+        TeleportBot(bot, bot->GetMap(), bot);
+
+    return true;
+}
+
+bool BotMgr::RemoveAllBotsFromGroup()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        RemoveBotFromGroup(itr->second);
+
+    return true;
+}
+
+uint32 BotMgr::GetNpcBotCost(uint8 level, uint8 botclass)
+{
+    //assuming default 1000000
+    //level 1: 500  //5  silver
+    //10 : 10000    //1  gold
+    //20 : 50000    //5  gold
+    //30 : 200000   //20 gold
+    //40 : 500000   //50 gold
+    //rest is linear
+    //rare / rareelite bots have their cost adjusted
+    uint32 cost =
+        level < 10 ? _npcBotsCost / 2000 : //5 silver
+        level < 20 ? _npcBotsCost / 100 :  //1 gold
+        level < 30 ? _npcBotsCost / 20 :   //5 gold
+        level < 40 ? _npcBotsCost / 5 :    //20 gold
+        (_npcBotsCost * level) / DEFAULT_MAX_LEVEL; //50 - 100 gold
+
+    switch (botclass)
+    {
+        case BOT_CLASS_BM:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_SPELLBREAKER:
+        case BOT_CLASS_NECROMANCER:
+            cost += cost; //200%
+            break;
+        case BOT_CLASS_SPHYNX:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_DARK_RANGER:
+        case BOT_CLASS_SEA_WITCH:
+            cost += cost * 4; //500%
+            break;
+        default:
+            break;
+    }
+
+    return cost;
+}
+
+std::string BotMgr::GetNpcBotCostStr(uint8 level, uint8 botclass)
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost(level, botclass))
+    {
+        uint32 gold = uint32(cost / GOLD);
+        cost -= (gold * GOLD);
+        uint32 silver = uint32(cost / SILVER);
+        cost -= (silver * SILVER);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+
+    return money.str();
+}
+
+uint8 BotMgr::BotClassByClassName(std::string const& className)
+{
+    static const std::map<std::string, uint8> BotClassNamesMap = {
+        { "warrior", BOT_CLASS_WARRIOR },
+        { "paladin", BOT_CLASS_PALADIN },
+        { "hunter", BOT_CLASS_HUNTER },
+        { "rogue", BOT_CLASS_ROGUE },
+        { "priest", BOT_CLASS_PRIEST },
+        { "deathknight", BOT_CLASS_DEATH_KNIGHT },
+        { "death_knight", BOT_CLASS_DEATH_KNIGHT },
+        { "shaman", BOT_CLASS_SHAMAN },
+        { "mage", BOT_CLASS_MAGE },
+        { "warlock", BOT_CLASS_WARLOCK },
+        { "druid", BOT_CLASS_DRUID },
+        { "blademaster", BOT_CLASS_BM },
+        { "blade_master", BOT_CLASS_BM },
+        { "sphynx", BOT_CLASS_SPHYNX },
+        { "obsidiandestroyer", BOT_CLASS_SPHYNX },
+        { "obsidian_destroyer", BOT_CLASS_SPHYNX },
+        { "destroyer", BOT_CLASS_SPHYNX },
+        { "archmage", BOT_CLASS_ARCHMAGE },
+        { "dreadlord", BOT_CLASS_DREADLORD },
+        { "spellbreaker", BOT_CLASS_SPELLBREAKER },
+        { "spell_breaker", BOT_CLASS_SPELLBREAKER },
+        { "darkranger", BOT_CLASS_DARK_RANGER },
+        { "dark_ranger", BOT_CLASS_DARK_RANGER },
+        { "necromancer", BOT_CLASS_NECROMANCER },
+        { "necro", BOT_CLASS_NECROMANCER },
+        { "seawitch", BOT_CLASS_SEA_WITCH },
+        { "sea_witch", BOT_CLASS_SEA_WITCH }
+    };
+
+    //std::transform(className.begin(), className.end(), className.begin(), std::tolower);
+    auto iter = BotClassNamesMap.find(className);
+    if (iter != BotClassNamesMap.end())
+        return iter->second;
+
+    return BOT_CLASS_NONE;
+}
+
+void BotMgr::ReviveAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        _reviveBot(itr->second);
+}
+
+void BotMgr::SendBotCommandState(uint8 state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->SetBotCommandState(state, true);
+}
+
+void BotMgr::SendBotCommandStateRemove(uint8 state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->RemoveBotCommandState(state);
+}
+
+void BotMgr::SendBotAwaitState(uint8 state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->SetBotAwaitState(state);
+}
+
+void BotMgr::RecallAllBots(bool teleport)
+{
+    if (teleport)
+    {
+        _botsHidden = true;
+        _quickrecall = true;
+    }
+    else
+    {
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->IsInWorld() && itr->second->IsAlive() && !bot_ai::CCed(itr->second, true))
+                itr->second->GetMotionMaster()->MovePoint(_owner->GetMapId(), *_owner, false);
+    }
+}
+
+void BotMgr::RecallBot(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    if (bot->IsInWorld() && bot->IsAlive() && !bot_ai::CCed(bot, true))
+        bot->GetMotionMaster()->MovePoint(_owner->GetMapId(), *_owner, false);
+}
+
+void BotMgr::KillAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        KillBot(itr->second);
+}
+
+void BotMgr::KillBot(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    if (bot->IsInWorld() && bot->IsAlive())
+    {
+        bot->setDeathState(JUST_DIED);
+        bot->GetBotAI()->JustDied(bot);
+        //bot->Kill(bot);
+    }
+}
+
+void BotMgr::SetBotsShouldUpdateStats()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        itr->second->GetBotAI()->SetShouldUpdateStats();
+}
+
+void BotMgr::UpdatePhaseForBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetPhaseMask(_owner->GetPhaseMask(), itr->second->IsInWorld());
+        if (itr->second->GetBotsPet())
+            itr->second->GetBotsPet()->SetPhaseMask(_owner->GetPhaseMask(), true); //only if in world
+    }
+}
+
+void BotMgr::UpdatePvPForBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        if (itr->second->GetBotsPet())
+            itr->second->GetBotsPet()->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+    }
+}
+
+void BotMgr::PropagateEngageTimers() const
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (itr->second->GetBotAI()->IsTank())
+            continue;
+
+        uint32 delay = itr->second->GetBotAI()->HasRole(BOT_ROLE_HEAL) ? GetEngageDelayHeal() :
+            itr->second->GetBotAI()->HasRole(BOT_ROLE_DPS) ? GetEngageDelayDPS() : 0;
+
+        itr->second->GetBotAI()->ResetEngageTimer(delay);
+    }
+}
+
+void BotMgr::TrackDamage(Unit const* u, uint32 damage)
+{
+    _dpstracker->TrackDamage(u, damage);
+}
+
+uint32 BotMgr::GetDPSTaken(Unit const* u) const
+{
+    return _dpstracker->GetDPSTaken(u->GetGUID().GetRawValue());
+}
+
+int32 BotMgr::GetHPSTaken(Unit const* unit) const
+{
+    if (!HaveBot())
+        return 0;
+
+    std::list<Unit*> unitList;
+    Group const* gr = _owner->GetGroup();
+    if (!gr)
+    {
+        if (_owner->HasUnitState(UNIT_STATE_CASTING))
+            unitList.push_back(_owner);
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetTarget() == unit->GetGUID() && itr->second->HasUnitState(UNIT_STATE_CASTING))
+                unitList.push_back(itr->second);
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* player = itr->GetSource();
+            if (player == nullptr) continue;
+            if (_owner->GetMap() != player->FindMap()) continue;
+            if (!Bots)
+                Bots = true;
+            if (player->HasUnitState(UNIT_STATE_CASTING))
+                unitList.push_back(player);
+        }
+        if (Bots)
+        {
+            for (GroupReference const* gitr = gr->GetFirstMember(); gitr != nullptr; gitr = gitr->next())
+            {
+                if (gitr->GetSource() == nullptr) continue;
+                if (_owner->GetMap() != gitr->GetSource()->FindMap()) continue;
+
+                if (gitr->GetSource()->HaveBot())
+                {
+                    BotMap const* map = gitr->GetSource()->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                        if (itr->second->GetTarget() == unit->GetGUID() && itr->second->HasUnitState(UNIT_STATE_CASTING))
+                            unitList.push_back(itr->second);
+                }
+            }
+        }
+    }
+
+    int32 amount = 0;
+
+    Unit* u;
+    Spell const* spell;
+    SpellInfo const* spellInfo;
+    for (std::list<Unit*>::const_iterator itr = unitList.begin(); itr != unitList.end(); ++itr)
+    {
+        u = *itr;
+
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+        {
+            spell = u->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+
+            ObjectGuid targetGuid = spell->m_targets.GetObjectTargetGUID();
+            if (!targetGuid || !targetGuid.IsUnit())
+                continue;
+
+            if (targetGuid != unit->GetGUID())
+            {
+                if (!gr || !gr->IsMember(unit->GetGUID()))
+                    continue;
+            }
+
+            spellInfo = spell->GetSpellInfo();
+
+            for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
+            {
+                if (spellInfo->_effects[j].Effect != SPELL_EFFECT_HEAL)
+                    continue;
+
+                if (targetGuid != unit->GetGUID())
+                {
+                    if (spellInfo->_effects[j].TargetA.GetSelectionCategory() != TARGET_SELECT_CATEGORY_AREA)
+                        continue;
+
+                    //Targets t = spellInfo->_effects[j].TargetA.GetTarget();
+                    //non-existing case
+                    //if (t == TARGET_UNIT_CASTER_AREA_PARTY && !gr->SameSubGroup(u->GetGUID(), unit->GetGUID()))
+                    //    continue;
+                    Targets t = spellInfo->_effects[j].TargetB.GetTarget();
+                    if (t == TARGET_UNIT_LASTTARGET_AREA_PARTY &&
+                        !(GetBot(unit->GetGUID()) && GetBot(targetGuid)) &&
+                        !gr->SameSubGroup(unit->GetGUID(), targetGuid))
+                        continue;
+                }
+
+                int32 healing = u->SpellHealingBonusDone(const_cast<Unit*>(unit), spellInfo, spellInfo->_effects[0].CalcValue(u), HEAL, spellInfo->GetEffect(EFFECT_0), {});
+                healing = unit->SpellHealingBonusTaken(u, spellInfo, healing, HEAL);
+
+                if (i == CURRENT_CHANNELED_SPELL)
+                    amount += int32(healing / (spellInfo->_effects[j].Amplitude * 0.001f));
+                else
+                    amount += int32(healing / (std::max<int32>(spell->GetTimer(), 1000) * 0.001f));
+
+                //TC_LOG_ERROR("entities.player", "BotMgr:pendingHeals: found %s's %s on %s in %u (%i, total %i)",
+                //    u->GetName().c_str(), spellInfo->SpellName[0], target->GetName().c_str(), pheal->delay, healing, pheal->amount);
+            }
+
+            break;
+        }
+    }
+
+    //HoTs
+    Unit::AuraEffectList const& hots = unit->GetAuraEffectsByType(SPELL_AURA_PERIODIC_HEAL);
+    for (Unit::AuraEffectList::const_iterator itr = hots.begin(); itr != hots.end(); ++itr)
+        amount += int32((*itr)->GetAmount() / ((*itr)->GetAmplitude() * 0.001f));
+
+    //if (amount != 0)
+    //    TC_LOG_ERROR("entities.player", "BotMgr:GetHPSTaken(): %s got %i)", unit->GetName().c_str(), amount);
+
+    return amount;
+}
+
+void BotMgr::OnBotSpellGo(Unit const* caster, Spell const* spell, bool ok)
+{
+    if (caster->ToCreature()->GetBotAI())
+        caster->ToCreature()->GetBotAI()->OnBotSpellGo(spell, ok);
+    else if (caster->ToCreature()->GetBotPetAI())
+        caster->ToCreature()->GetBotPetAI()->OnBotPetSpellGo(spell, ok);
+}
+
+void BotMgr::OnBotOwnerSpellGo(Unit const* caster, Spell const* spell, bool ok)
+{
+    BotMap const* bmap = caster->ToPlayer()->GetBotMgr()->GetBotMap();
+    for (BotMap::const_iterator itr = bmap->begin(); itr != bmap->end(); ++itr)
+    {
+        if (Creature const* bot = itr->second)
+        {
+            if (!bot->IsInWorld() || !bot->IsAlive())
+                continue;
+
+            bot->GetBotAI()->OnBotOwnerSpellGo(spell, ok);
+            //if (Creature const* botpet = bot->GetBotsPet())
+            //    botpet->GetBotAI()->OnBotPetOwnerSpellGo(spell, ok);
+        }
+    }
+}
+
+void BotMgr::OnVehicleSpellGo(Unit const* caster, Spell const* spell, bool ok)
+{
+    if (caster->GetCharmerGUID().IsPlayer())
+    {
+        Unit const* owner = caster->GetCharmer();
+        if (owner && owner->ToPlayer()->HaveBot())
+        {
+            BotMap const* bmap = owner->ToPlayer()->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = bmap->begin(); itr != bmap->end(); ++itr)
+            {
+                if (Creature const* bot = itr->second)
+                {
+                    bot->GetBotAI()->OnBotOwnerSpellGo(spell, ok);
+                    //if (Creature const* botpet = bot->GetBotsPet())
+                    //    botpet->GetBotAI()->OnBotPetOwnerSpellGo(spell, ok);
+                }
+            }
+        }
+    }
+    else if (caster->GetCharmerGUID().IsCreature())
+    {
+        Unit const* bot = caster->GetCharmer();
+        if (bot->ToCreature()->GetBotAI())
+            bot->ToCreature()->GetBotAI()->OnBotSpellGo(spell, ok);
+    }
+}
+
+void BotMgr::OnVehicleAttackedBy(Unit* attacker, Unit const* victim)
+{
+    Unit const* owner = victim->GetCharmer();
+    if (victim->GetCharmerGUID().IsPlayer())
+        owner = victim->GetCharmer();
+    else if (victim->GetCharmerGUID().IsCreature())
+        if (Unit const* bot = victim->GetCharmer())
+            owner = bot->ToCreature()->GetBotOwner();
+
+    if (owner && owner->GetTypeId() == TYPEID_PLAYER && owner->ToPlayer()->HaveBot())
+    {
+        BotMap const* bmap = owner->ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = bmap->begin(); itr != bmap->end(); ++itr)
+            if (Creature const* bot = itr->second)
+                bot->GetBotAI()->OnOwnerVehicleDamagedBy(attacker);
+    }
+}
+
+void BotMgr::OnBotDamageTaken(Unit* attacker, Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* spellInfo)
+{
+    victim->ToCreature()->GetBotAI()->OnBotDamageTaken(attacker, damage, cleanDamage , damagetype, spellInfo);
+}
+
+void BotMgr::OnBotDamageDealt(Unit* attacker, Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* spellInfo)
+{
+    attacker->ToCreature()->GetBotAI()->OnBotDamageDealt(victim, damage, cleanDamage, damagetype, spellInfo);
+}
+
+void BotMgr::OnBotDispelDealt(Unit* dispeller, Unit* dispelled, uint8 num)
+{
+    dispeller->ToCreature()->GetBotAI()->OnBotDispelDealt(dispelled, num);
+}
+
+void BotMgr::OnBotEnterVehicle(Creature const* passenger, Vehicle const* vehicle)
+{
+    passenger->GetBotAI()->OnBotEnterVehicle(vehicle);
+}
+
+void BotMgr::OnBotExitVehicle(Creature const* passenger, Vehicle const* vehicle)
+{
+    passenger->GetBotAI()->OnBotExitVehicle(vehicle);
+}
+
+void BotMgr::OnBotOwnerEnterVehicle(Player const* passenger, Vehicle const* vehicle)
+{
+    BotMap const* bmap = passenger->GetBotMgr()->GetBotMap();
+    for (BotMap::const_iterator itr = bmap->begin(); itr != bmap->end(); ++itr)
+        if (Creature const* bot = itr->second)
+            if (bot->IsInWorld() && bot->IsAlive())
+                bot->GetBotAI()->OnBotOwnerEnterVehicle(vehicle);
+}
+
+void BotMgr::OnBotOwnerExitVehicle(Player const* passenger, Vehicle const* vehicle)
+{
+    BotMap const* bmap = passenger->GetBotMgr()->GetBotMap();
+    for (BotMap::const_iterator itr = bmap->begin(); itr != bmap->end(); ++itr)
+        if (Creature const* bot = itr->second)
+            if (bot->IsInWorld() && bot->IsAlive())
+                bot->GetBotAI()->OnBotOwnerExitVehicle(vehicle);
+}
+
+void BotMgr::OnBotPartyEngage(Player const* owner)
+{
+    Group const* gr = owner->GetGroup();
+    if (gr)
+    {
+        std::vector<Player const*> affectedPlayers;
+        for (GroupReference const* itr = gr->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player const* player = itr->GetSource();
+            if (!player || owner->GetMap() != player->FindMap() ||
+                player->GetDistance(owner) > sWorld->GetMaxVisibleDistanceOnContinents() ||
+                !player->HaveBot())
+                continue;
+
+            if (player->GetBotMgr()->IsPartyInCombat())
+                return;
+
+            affectedPlayers.push_back(player);
+        }
+        for (Player const* p : affectedPlayers)
+            p->GetBotMgr()->PropagateEngageTimers();
+    }
+    else
+        owner->GetBotMgr()->PropagateEngageTimers();
+}
+
+void BotMgr::ApplyBotEffectMods(Unit const* caster, Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value)
+{
+    caster->ToCreature()->GetBotAI()->ApplyBotEffectMods(target, spellInfo, effIndex, value);
+}
+
+void BotMgr::ApplyBotThreatMods(Unit const* attacker, SpellInfo const* spellInfo, float& threat)
+{
+    attacker->ToCreature()->GetBotAI()->ApplyBotThreatMods(spellInfo, threat);
+}
+
+void BotMgr::ApplyBotEffectValueMultiplierMods(Unit const* caster, SpellInfo const* spellInfo, SpellEffIndex effIndex, float& multiplier)
+{
+    caster->ToCreature()->GetBotAI()->ApplyBotEffectValueMultiplierMods(spellInfo, effIndex, multiplier);
+}
+
+float BotMgr::GetBotDamageTakenMod(Creature const* bot, bool magic)
+{
+    return bot->GetBotAI()->GetBotDamageTakenMod(magic);
+}
+
+int32 BotMgr::GetBotStat(Creature const* bot, BotStatMods stat)
+{
+    return bot->GetBotAI()->GetTotalBotStat(stat);
+}
+
+float BotMgr::GetBotDamageModPhysical()
+{
+    return _mult_dmg_physical;
+}
+float BotMgr::GetBotDamageModSpell()
+{
+    return _mult_dmg_spell;
+}
+float BotMgr::GetBotHealingMod()
+{
+    return _mult_healing;
+}
+float BotMgr::GetBotHPMod()
+{
+    return _mult_hp;
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.h b/src/server/game/AI/NpcBots/botmgr.h
new file mode 100644
index 000000000..efab54ef6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.h
@@ -0,0 +1,240 @@
+#ifndef _BOTMGR_H
+#define _BOTMGR_H
+
+#include "botcommon.h"
+
+class Creature;
+class Map;
+class Player;
+class Unit;
+class Vehicle;
+class WorldLocation;
+class DPSTracker;
+
+struct Position;
+
+enum BotAddResult
+{
+    BOT_ADD_DISABLED                    = 0x001,
+    BOT_ADD_ALREADY_HAVE                = 0x002,
+    BOT_ADD_MAX_EXCEED                  = 0x004,
+    BOT_ADD_MAX_CLASS_EXCEED            = 0x008,
+    BOT_ADD_CANT_AFFORD                 = 0x010,
+    BOT_ADD_INSTANCE_LIMIT              = 0x020,
+    BOT_ADD_BUSY                        = 0x040,
+    BOT_ADD_NOT_AVAILABLE               = 0x080,
+
+    BOT_ADD_SUCCESS                     = 0x100,
+
+    BOT_ADD_FATAL                       = (BOT_ADD_DISABLED | BOT_ADD_CANT_AFFORD | BOT_ADD_MAX_EXCEED | BOT_ADD_MAX_CLASS_EXCEED)
+};
+
+enum BotRemoveType
+{
+    BOT_REMOVE_LOGOUT                   = 0,
+    BOT_REMOVE_DISMISS                  = 1,
+    BOT_REMOVE_UNSUMMON                 = 2,
+    BOT_REMOVE_BY_DEFAULT               = BOT_REMOVE_LOGOUT
+};
+
+enum BotAttackRange
+{
+    BOT_ATTACK_RANGE_SHORT              = 1,
+    BOT_ATTACK_RANGE_LONG               = 2,
+    BOT_ATTACK_RANGE_EXACT              = 3
+};
+
+enum BotAttackAngle
+{
+    BOT_ATTACK_ANGLE_NORMAL             = 1,
+    BOT_ATTACK_ANGLE_AVOID_FRONTAL_AOE  = 2
+};
+
+typedef std::unordered_map<ObjectGuid /*guid*/, Creature* /*bot*/> BotMap;
+
+class BotMgr
+{
+    public:
+        BotMgr(Player* const master);
+        ~BotMgr();
+
+        Player* GetOwner() const { return _owner; }
+
+        BotMap const* GetBotMap() const { return &_bots; }
+        BotMap* GetBotMap() { return &_bots; }
+
+        static bool IsNpcBotModEnabled();
+        static bool IsNpcBotDungeonFinderEnabled();
+        static bool DisplayEquipment();
+        static bool ShowEquippedCloak();
+        static bool ShowEquippedHelm();
+        static bool SendEquipListItems();
+        static bool IsTransmogEnabled();
+        static bool MixArmorClasses();
+        static bool MixWeaponClasses();
+        static bool MixWeaponInventoryTypes();
+        static bool TransmogUseEquipmentSlots();
+        static bool IsClassEnabled(uint8 m_class);
+        static bool IsEnrageOnDimissEnabled();
+        static bool IsBotStatsLimitsEnabled();
+        static bool IsPvPEnabled();
+        static bool IsFoodInterruptedByMovement();
+        static bool FilterRaces();
+        static uint8 GetMaxClassBots();
+        static uint8 GetHealTargetIconFlags();
+        static uint8 GetTankTargetIconFlags();
+        static uint8 GetOffTankTargetIconFlags();
+        static uint8 GetDPSTargetIconFlags();
+        static uint8 GetRangedDPSTargetIconFlags();
+        static uint8 GetNoDPSTargetIconFlags();
+        static uint32 GetBaseUpdateDelay();
+        static uint32 GetOwnershipExpireTime();
+        static float GetBotStatLimitDodge();
+        static float GetBotStatLimitParry();
+        static float GetBotStatLimitBlock();
+        static float GetBotStatLimitCrit();
+        static float GetBotDamageModPhysical();
+        static float GetBotDamageModSpell();
+        static float GetBotHealingMod();
+        static float GetBotHPMod();
+
+        static void Initialize();
+        static void ReloadConfig();
+        static void LoadConfig(bool reload = false);
+
+        //onEvent hooks
+        static void OnBotSpellGo(Unit const* caster, Spell const* spell, bool ok = true);
+        static void OnBotOwnerSpellGo(Unit const* caster, Spell const* spell, bool ok = true);
+        static void OnVehicleSpellGo(Unit const* caster, Spell const* spell, bool ok = true);
+        static void OnVehicleAttackedBy(Unit* attacker, Unit const* victim);
+        static void OnBotDamageTaken(Unit* attacker, Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* spellInfo);
+        static void OnBotDamageDealt(Unit* attacker, Unit* victim, uint32 damage, CleanDamage const* cleanDamage, DamageEffectType damagetype, SpellInfo const* spellInfo);
+        static void OnBotDispelDealt(Unit* dispeller, Unit* dispelled, uint8 num);
+        static void OnBotEnterVehicle(Creature const* passenger, Vehicle const* vehicle);
+        static void OnBotExitVehicle(Creature const* passenger, Vehicle const* vehicle);
+        static void OnBotOwnerEnterVehicle(Player const* passenger, Vehicle const* vehicle);
+        static void OnBotOwnerExitVehicle(Player const* passenger, Vehicle const* vehicle);
+        static void OnBotPartyEngage(Player const* owner);
+        //mod hooks
+        static void ApplyBotEffectMods(Unit const* caster, Unit const* target, SpellInfo const* spellInfo, uint8 effIndex, float& value);
+        static void ApplyBotThreatMods(Unit const* attacker, SpellInfo const* spellInfo, float& threat);
+        static void ApplyBotEffectValueMultiplierMods(Unit const* caster, SpellInfo const* spellInfo, SpellEffIndex effIndex, float& multiplier);
+        static float GetBotDamageTakenMod(Creature const* bot, bool magic);
+        static int32 GetBotStat(Creature const* bot, BotStatMods stat);
+
+        void Update(uint32 diff);
+
+        Creature* GetBot(ObjectGuid guid) const;
+        Creature* GetBotByName(std::string_view name) const;
+        std::list<Creature*> GetAllBotsByClass(uint8 botclass) const;
+
+        bool HaveBot() const { return !_bots.empty(); }
+        uint8 GetNpcBotsCount() const;
+        uint8 GetNpcBotsCountByRole(uint32 roles) const;
+        uint8 GetNpcBotsCountByVehicleEntry(uint32 creEntry) const;
+        uint8 GetNpcBotSlot(Creature const* bot) const;
+        uint8 GetNpcBotSlotByRole(uint32 roles, Creature const* bot) const;
+        uint32 GetAllNpcBotsClassMask() const;
+        static uint8 GetMaxNpcBots();
+        static uint8 GetNpcBotXpReduction();
+        static int32 GetBotInfoPacketsLimit();
+        static bool LimitBots(Map const* map);
+        static bool CanBotParryWhileCasting(Creature const* bot);
+        bool RestrictBots(Creature const* bot, bool add) const;
+        bool IsPartyInCombat() const;
+        bool HasBotClass(uint8 botclass) const;
+        bool HasBotWithSpec(uint8 spec, bool alive = true) const;
+        bool HasBotPetType(uint32 petType) const;
+        bool IsBeingResurrected(WorldObject const* corpse) const;
+
+        static uint32 GetNpcBotCost(uint8 level, uint8 botclass);
+        static std::string GetNpcBotCostStr(uint8 level, uint8 botclass);
+        static uint8 BotClassByClassName(std::string const& className);
+
+        void OnTeleportFar(uint32 mapId, float x, float y, float z, float ori = 0.f);
+        void OnOwnerSetGameMaster(bool on);
+        void ReviveAllBots();
+        void SendBotCommandState(uint8 state);
+        void SendBotCommandStateRemove(uint8 state);
+        void SendBotAwaitState(uint8 state);
+        void RecallAllBots(bool teleport = false);
+        void RecallBot(Creature* bot);
+        void KillAllBots();
+        void KillBot(Creature* bot);
+
+        void CleanupsBeforeBotDelete(ObjectGuid guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveAllBots(uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveBot(ObjectGuid guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        BotAddResult AddBot(Creature* bot, bool takeMoney);
+        bool AddBotToGroup(Creature* bot);
+        void RemoveBotFromBGQueue(Creature const* bot);
+        bool RemoveBotFromGroup(Creature* bot);
+        bool RemoveAllBotsFromGroup();
+
+        static uint8 GetBotFollowDistDefault() { return 100; }
+        uint8 GetBotFollowDist() const { return _followdist; }
+        void SetBotFollowDist(uint8 dist) { _followdist = dist; }
+
+        uint8 GetBotExactAttackRange() const { return _exactAttackRange; }
+        uint8 GetBotAttackRangeMode() const { return _attackRangeMode; }
+        void SetBotAttackRangeMode(uint8 mode, uint8 exactRange = 0) { _attackRangeMode = mode; _setBotExactAttackRange(exactRange); }
+
+        uint8 GetBotAttackAngleMode() const { return _attackAngleMode; }
+        void SetBotAttackAngleMode(uint8 mode) { _attackAngleMode = mode; }
+
+        bool GetBotAllowCombatPositioning() const { return _allowCombatPositioning; }
+        void SetBotAllowCombatPositioning(bool allow) { _allowCombatPositioning = allow; }
+
+        uint32 GetEngageDelayDPS() const { return _npcBotEngageDelayDPS; }
+        uint32 GetEngageDelayHeal() const { return _npcBotEngageDelayHeal; }
+        void SetEngageDelayDPS(uint32 delay) { _npcBotEngageDelayDPS = delay; }
+        void SetEngageDelayHeal(uint32 delay) { _npcBotEngageDelayHeal = delay; }
+        void PropagateEngageTimers() const;
+
+        void SetBotsHidden(bool hidden) { _botsHidden = hidden; }
+
+        void SetBotsShouldUpdateStats();
+        void UpdatePhaseForBots();
+        void UpdatePvPForBots();
+
+        void TrackDamage(Unit const* u, uint32 damage);
+        uint32 GetDPSTaken(Unit const* u) const;
+        int32 GetHPSTaken(Unit const* unit) const;
+
+        static void ReviveBot(Creature* bot, WorldLocation* dest = nullptr) { _reviveBot(bot, dest); }
+
+        //TELEPORT BETWEEN MAPS
+        //CONFIRMEND UNSAFE (charmer,owner)
+        static void TeleportBot(Creature* bot, Map* newMap, Position* pos, bool quick = false);
+
+        AoeSpotsVec const& GetAoeSpots() const { return _aoespots; }
+        AoeSpotsVec& GetAoeSpots() { return _aoespots; }
+
+    private:
+        static void _teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori = 0.f, bool quick = false);
+        static void _reviveBot(Creature* bot, WorldLocation* dest = nullptr);
+        void _addBotToRemoveList(ObjectGuid guid);
+        void _setBotExactAttackRange(uint8 exactRange) { _exactAttackRange = exactRange; }
+
+        Player* const _owner;
+        BotMap _bots;
+        std::list<ObjectGuid> _removeList;
+        DPSTracker* const _dpstracker;
+
+        uint8 _followdist;
+        uint8 _exactAttackRange;
+        uint8 _attackRangeMode;
+        uint8 _attackAngleMode;
+        bool _allowCombatPositioning;
+        uint32 _npcBotEngageDelayDPS;
+        uint32 _npcBotEngageDelayHeal;
+
+        bool _botsHidden;
+        bool _quickrecall;
+
+        AoeSpotsVec _aoespots;
+};
+
+void AddNpcBotScripts();
+
+#endif
diff --git a/src/server/game/AI/NpcBots/botspell.h b/src/server/game/AI/NpcBots/botspell.h
new file mode 100644
index 000000000..213b0f77c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botspell.h
@@ -0,0 +1,246 @@
+#ifndef _BOTSPELL_H
+#define _BOTSPELL_H
+
+#include "Define.h"
+
+/*
+NpcBot System by Trickerer (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+enum BotSpells : uint32
+{
+//COMMON SPELLS
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+    BERSERK                             = 46587,//68378,//900%/150%
+    MODEL_TRANSITION                    = 24753,//"Trick" cannot cast or attack
+    SUMMONING_DISORIENTATION            = 32752,
+    ACTIVATE_SPEC                       = 63645,//Activate Primary Spec
+    SHOOT_WAND                          = 5019,
+///Passives
+    DAMAGE_REDUCTION                    = 68066,//Vigilance, Blessing of Sanctuary, etc.
+///Passives for Pets
+    DAMAGEDONE_PASSIVE                  = 30147,//for custom value, Tamed Pet Passive (DND) physical at 0, magic at 1
+    DAMAGETAKEN_PASSIVE                 = 35697,//for custom value, Pet Passive (DND), single effect (aura 87 at 0)
+    SPELLDAMAGE_PASSIVE                 = 43922,//for custom value, Increase Spell Dam 473, single effect (aura 13 at 0)
+    SPELLPENETRATION_PASSIVE            = 25975,//for custom value, Spell Penetration 10, single effect (aura 123 at 0)
+    SPELLHASTE_PASSIVE                  = 44400,//for custom value, Netherwind Presence rank 1, single effect (aura 65 at 0)
+    CRITBONUS_PASSIVE                   = 35695,//for custom value, Pet Passive (DND), spell at 0, physical at 1
+///Racials
+    RACIAL_EVERY_MAN_FOR_HIMSELF        = 59752,//pvp trinket effect, instant, 2 min cd
+    RACIAL_BLOOD_FURY_WARLOCK           = 33702,//effect varies, 15 sec, 2 min cd
+    RACIAL_BLOOD_FURY_SHAMAN            = 33697,
+    RACIAL_BLOOD_FURY_OTHERS            = 20572,
+    RACIAL_STONEFORM                    = 20594,//dispell disease, poison, bleed, instant, 2 min cd
+    //RACIAL_FIND_TREASURE                = 2481,
+    RACIAL_SHADOWMELD                   = 58984,//stealth, -threat, instant, 2 min cd
+    RACIAL_WILL_OF_THE_FORSAKEN         = 7744,//dispel charm/fear/sleep, instant, 2 min cd, 45 sec category cd
+    RACIAL_WARSTOMP                     = 20549,//2sec stun, casttime 500, 8yd, 2 min cd
+    RACIAL_ESCAPE_ARTIST                = 20589,//dispel snare/root, instant, 1 min 45 sec cd
+    RACIAL_BERSERKING                   = 26297,//haste all 20%, isntant, 3 min cd
+    RACIAL_ARCANE_TORRENT_DEATHKNIGHT   = 50613,//2sec AoE silence + energize, instant, 2 min cd
+    RACIAL_ARCANE_TORRENT_ROGUE         = 25046,
+    RACIAL_ARCANE_TORRENT_OTHERS        = 28730,
+    RACIAL_GIFT_OF_NAARU_WARRIOR        = 28880,//Hot over 15 sec, instant, 2 min cd
+    RACIAL_GIFT_OF_NAARU_PALADIN        = 59542,
+    RACIAL_GIFT_OF_NAARU_HUNTER         = 59543,
+    RACIAL_GIFT_OF_NAARU_PRIEST         = 59544,
+    RACIAL_GIFT_OF_NAARU_DEATHKNIGHT    = 59545,
+    RACIAL_GIFT_OF_NAARU_SHAMAN         = 59547,
+    RACIAL_GIFT_OF_NAARU_MAGE           = 59548,
+//ADVANCED
+    //HONORLESS_TARGET                    = 2479,
+    COSMETIC_TELEPORT_EFFECT            = 52096,//visual instant cast omni
+    COSMETIC_RESURRECTION               = 58854,//visual instant cast self (castable while dead, hidden)
+    SUMMON_DEMON_VISUAL                 = 6657,//SUMMON_SERPENT_MESSENGER
+    CALL_PET_VISUAL                     = 30416,//QUEST_WOOD_CLEANSE_EFFECT
+    SPELL_VERTEX_COLOR_BLACK            = 39662,//black color model full
+    SPELL_VERTEX_COLOR_GREY             = 43355,//grey color model full
+////CUSTOM SPELLS - UNUSED IN CODE AND DB
+  //common
+  //modify
+    SPELL_TRIGGERED_HEAL                = 25155,//hidden
+  //unmodify
+    SPELL_ATTACK_MELEE_1H               = 42880,
+    SPELL_TRIGGERED_ENERGIZE            = 60628,//hidden
+//BLADEMASTER
+  //SPELLS
+  //unmodify
+    //SPELL_DEATH_GRIP_JUMP               = 49575,
+/**/SPELL_CRITICAL_STRIKE               = 1132,
+    SPELL_BURNING_BLADE_BLADEMASTER     = 32281,//horde flag visual
+    SPELL_STUN_FREEZE_ANIM              = 59123,//stun forever, full stop
+  //modify
+    SPELL_TRANSPARENCY_50               = 44816,
+/**/SPELL_NETHERWALK                    = 31599,
+/**/SPELL_MIRROR_IMAGE_BM               = 69936,//blank spell
+    SPELL_COMBAT_SPECIAL_2H_ATTACK      = 44079,//animation only
+//SPHYNX
+  //modify
+    SPELL_SHADOW_BOLT1                  = 16408,
+    SPELL_SHADOW_BLAST                  = 38085,
+    //SPELL_SHADOW_BLAST_SPLASH           = 38205,
+    SPELL_ATTACK_MELEE_RANDOM           = 42902,
+    SHADOWFURY_VISUAL                   = 47444,//59912,
+    SPELL_DEVOUR_MAGIC                  = 17012,//used by Spellmaw but no matter (this spell does not work as intended)
+    SPELL_DRAIN_MANA                    = 25755,
+    SPELL_REPLENISH_MANA                = 33394,//5406,
+    SPELL_REPLENISH_HEALTH              = 34756,//regenerating aura
+  //unmodify
+    SPELL_DEVOUR_MAGIC_CASTER_IMPACT    = 50527,
+    SPELL_DEVOUR_MAGIC_BEAM             = 54393,
+//ARCHMAGE
+  //modify
+    SPELL_BRILLIANCE_AURA               = 1234,
+    SPELL_FIREBALL                      = 9488,
+    SPELL_BLIZZARD                      = 15783,
+    SPELL_SUMMON_WATER_ELEMENTAL        = 35593,
+    SPELL_WATERBOLT                     = 72898,
+  //unmodify
+//DREADLORD
+  //modify
+    SPELL_VAMPIRIC_AURA                 = 20810,
+    SPELL_SLEEP                         = 20663,
+    SPELL_CARRION_SWARM                 = 34240,
+    SPELL_INFERNO                       = 12740, //summon infernal servant
+    SPELL_INFERNO_METEOR_VISUAL         = 5739, //meteor strike infernal
+  //unmodify
+    SPELL_INFERNO_EFFECT                = 22703, //stun, damage (warlock spell)
+    //SPELL_INFERNO_IMPACT_EXPLOSION      = 00000, //visual
+//SPELLBREAKER
+  //modify
+    SPELL_STEAL_MAGIC                   = 30036, //used by Ethereal Spellfilcher
+    SPELL_FEEDBACK                      = 32897,
+  //unmodify
+//DARK RANGER
+  //modify
+    SPELL_BLACK_ARROW                   = 20733, //supposed to be used by Dark Ranger Clea
+    SPELL_DRAIN_LIFE                    = 17238, //used by Maleki the Palid, supposed to be by Shadow Adept (31145)
+    SPELL_SILENCE                       = 29943,
+    //SPELL_CHARM                         = 11111, //
+  //unmodify
+//NECROMANCER
+  //modify
+    SPELL_SHADOW_BOLT2                  = 17509,
+    SPELL_RAISE_DEAD                    = 34011,
+    SPELL_UNHOLY_FRENZY                 = 52499,
+    SPELL_CRIPPLE                       = 50379,
+    SPELL_CORPSE_EXPLOSION              = 61614,
+    //SPELL_BONE_SHIELD                   = 0,//27688, //NIY //NO VIABLE SPELLS
+    //for Attract faction reaction must be adjusted at Object.cpp::GetFactionReactionTo(L2831)
+    //SPELL_BLOOD_CURSE                   = 29933, //NIY for Attract //NO VIABLE SPELLS
+  //unmodify
+    CORPSE_EXPLOSION_VISUAL             = 60081, //explosion
+//NAGA SEA WITCH
+  //modify
+    SPELL_FORKED_LIGHTNING              = 63541,
+    SPELL_FORKED_LIGHTNING_EFFECT       = 50900, // "Lightning Shock"
+    SPELL_FROST_ARROW                   = 38942,
+    SPELL_FROST_ARROW_EFFECT            = 56095,
+    SPELL_MANA_SHIELD                   = 35064,
+    SPELL_TORNADO                       = 34695,
+    SPELL_TORNADO_EFFECT                = 21990, // stun, -resistances
+    SPELL_TORNADO_EFFECT2               = 34683, // aoe damage
+    SPELL_TORNADO_EFFECT3               = 39261,
+    SPELL_SHOOT_BOW                     = 41188,
+  //unmodify
+    SPELL_TORNADO_LIGHTNING_VISUAL      = 45869, //periodic, 1 sec
+};
+
+enum BotMountSpells : uint32
+{
+    //By game events
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827,
+    //AQ40
+    QIRAJI_BATTLE_TANK_1                = 25953,
+    QIRAJI_BATTLE_TANK_2                = 26054,
+    QIRAJI_BATTLE_TANK_3                = 26055,
+    QIRAJI_BATTLE_TANK_4                = 26056,
+    //By class
+    BOT_DARK_RANGER_MOUNT               = 17481, // Deathcharger's Reins
+    BOT_BE_PALLY_FAST_MOUNT             = 34767,
+    BOT_BE_PALLY_MOUNT                  = 34769,
+    BOT_ALLI_PALLY_FAST_MOUNT           = 23214,
+    BOT_ALLI_PALLY_MOUNT                = 13819,
+    BOT_DEATH_KNIGHT_MOUNT              = 48778,
+    BOT_WARLOCK_FAST_MOUNT              = 23161,
+    BOT_WARLOCK_MOUNT                   = 5784,
+    //By race
+    BOT_MOUNT_HUMAN_60_1                = 458,
+    BOT_MOUNT_HUMAN_60_2                = 468,
+    BOT_MOUNT_HUMAN_60_3                = 470,
+    BOT_MOUNT_ORC_60_1                  = 459,
+    BOT_MOUNT_ORC_60_2                  = 578,
+    BOT_MOUNT_ORC_60_3                  = 579,
+    BOT_MOUNT_DWARF_60_1                = 6777,
+    BOT_MOUNT_DWARF_60_2                = 6896,
+    BOT_MOUNT_DWARF_60_3                = 6897,
+    BOT_MOUNT_NIGHTELF_60_1             = 8394,
+    BOT_MOUNT_NIGHTELF_60_2             = 10787,
+    BOT_MOUNT_NIGHTELF_60_3             = 10789,
+    BOT_MOUNT_FORSAKEN_60_1             = 8980,
+    BOT_MOUNT_FORSAKEN_60_2             = 17462,
+    BOT_MOUNT_FORSAKEN_60_3             = 17463,
+    BOT_MOUNT_TAUREN_60_1               = 18363,
+    BOT_MOUNT_TAUREN_60_2               = 18989,
+    BOT_MOUNT_TAUREN_60_3               = 18990,
+    BOT_MOUNT_GNOME_60_1                = 10873,
+    BOT_MOUNT_GNOME_60_2                = 10969,
+    BOT_MOUNT_GNOME_60_3                = 15780,
+    BOT_MOUNT_TROLL_60_1                = 8395,
+    BOT_MOUNT_TROLL_60_2                = 10795,
+    BOT_MOUNT_TROLL_60_3                = 10796,
+    BOT_MOUNT_BLOODELF_60_1             = 34795,
+    BOT_MOUNT_BLOODELF_60_2             = 35018,
+    BOT_MOUNT_BLOODELF_60_3             = 35020,
+    BOT_MOUNT_DRAENEI_60_1              = 34406,
+    BOT_MOUNT_DRAENEI_60_2              = 35710,
+    BOT_MOUNT_DRAENEI_60_3              = 35711,
+    BOT_MOUNT_HUMAN_100_1               = 23227,
+    BOT_MOUNT_HUMAN_100_2               = 23228,
+    BOT_MOUNT_HUMAN_100_3               = 23229,
+    BOT_MOUNT_ORC_100_1                 = 23250,
+    BOT_MOUNT_ORC_100_2                 = 23251,
+    BOT_MOUNT_ORC_100_3                 = 23252,
+    BOT_MOUNT_DWARF_100_1               = 23238,
+    BOT_MOUNT_DWARF_100_2               = 23239,
+    BOT_MOUNT_DWARF_100_3               = 23240,
+    BOT_MOUNT_NIGHTELF_100_1            = 23219,
+    BOT_MOUNT_NIGHTELF_100_2            = 23220,
+    BOT_MOUNT_NIGHTELF_100_3            = 23221,
+    BOT_MOUNT_FORSAKEN_100_1            = 17465,
+    BOT_MOUNT_FORSAKEN_100_2            = 22722,
+    BOT_MOUNT_FORSAKEN_100_3            = 23246,
+    BOT_MOUNT_TAUREN_100_1              = 23247,
+    BOT_MOUNT_TAUREN_100_2              = 23248,
+    BOT_MOUNT_TAUREN_100_3              = 23249,
+    BOT_MOUNT_GNOME_100_1               = 23222,
+    BOT_MOUNT_GNOME_100_2               = 23223,
+    BOT_MOUNT_GNOME_100_3               = 23225,
+    BOT_MOUNT_TROLL_100_1               = 23241,
+    BOT_MOUNT_TROLL_100_2               = 23242,
+    BOT_MOUNT_TROLL_100_3               = 23243,
+    BOT_MOUNT_BLOODELF_100_1            = 35025,
+    BOT_MOUNT_BLOODELF_100_2            = 35027,
+    BOT_MOUNT_BLOODELF_100_3            = 46628,
+    BOT_MOUNT_DRAENEI_100_1             = 35712,
+    BOT_MOUNT_DRAENEI_100_2             = 35713,
+    BOT_MOUNT_DRAENEI_100_3             = 35714,
+    //By Team (flyers)
+    BOT_MOUNT_FLY_ALLIANCE_150_1        = 32235,
+    BOT_MOUNT_FLY_ALLIANCE_150_2        = 32239,
+    BOT_MOUNT_FLY_ALLIANCE_150_3        = 32240,
+    BOT_MOUNT_FLY_HORDE_150_1           = 32243,
+    BOT_MOUNT_FLY_HORDE_150_2           = 32244,
+    BOT_MOUNT_FLY_HORDE_150_3           = 32245,
+    BOT_MOUNT_FLY_ALLIANCE_280_1        = 32242,
+    BOT_MOUNT_FLY_ALLIANCE_280_2        = 32289,
+    BOT_MOUNT_FLY_ALLIANCE_280_3        = 32290,
+    BOT_MOUNT_FLY_HORDE_280_1           = 32246,
+    BOT_MOUNT_FLY_HORDE_280_2           = 32295,
+    BOT_MOUNT_FLY_HORDE_280_3           = 32296
+};
+constexpr std::size_t NUM_MOUNTS_PER_SPEED = 3;
+
+#endif //_BOTSPELL_H
diff --git a/src/server/game/AI/NpcBots/bottext.h b/src/server/game/AI/NpcBots/bottext.h
new file mode 100644
index 000000000..ac72c09d4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bottext.h
@@ -0,0 +1,397 @@
+#ifndef BOTTEXT_H
+#define BOTTEXT_H
+
+#include "Define.h"
+
+enum BotTexts : uint32
+{
+    GOSSIP_NORMAL_SERVE_MASTER          = 70001,//"I live only to serve the master."
+    GOSSIP_GREET_NEED_SMTH              = 70002,//"You need something?"
+    GOSSIP_GREET_MURDER                 = 70003,//"Mortals... usually I kill wretches like you at sight"
+    GOSSIP_GREET_CUSTOM_SPHYNX          = 70004,
+    GOSSIP_NORMAL_CUSTOM_SPHYNX         = 70005,
+    GOSSIP_GREET_CUSTOM_DREADLORD       = 70006,
+    GOSSIP_NORMAL_CUSTOM_DREADLORD      = 70007,
+    GOSSIP_GREET_CUSTOM_DARKRANGER      = 70008,
+    GOSSIP_NORMAL_CUSTOM_DARKRANGER     = 70009,
+    GOSSIP_GREET_CUSTOM_SEAWITCH        = 70010,
+    GOSSIP_NORMAL_CUSTOM_SEAWITCH       = 70011,
+    //70012-70100 reserved for bot gossip texts (not selectable)
+    GOSSIP_CLASSDESC_BM                 = 70101,
+    GOSSIP_CLASSDESC_SPHYNX             = 70102,
+    GOSSIP_CLASSDESC_ARCHMAGE           = 70103,
+    GOSSIP_CLASSDESC_DREADLORD          = 70104,
+    GOSSIP_CLASSDESC_SPELLBREAKER       = 70105,
+    GOSSIP_CLASSDESC_DARKRANGER         = 70106,
+    GOSSIP_CLASSDESC_NECROMANCER        = 70107,
+    GOSSIP_CLASSDESC_SEAWITCH           = 70108,
+    //70109-70200 reserved for bot class descriptions gossip texts (not selectable)
+    GOSSIP_BOTGIVER_GREET               = 70201,
+    GOSSIP_BOTGIVER_HIRE                = 70202,
+    GOSSIP_BOTGIVER_HIRE_CLASS          = 70203,
+    GOSSIP_BOTGIVER_HIRE_EMPTY          = 70204,
+    //70205-70299 reserved for botgiver gossip texts (not selectable)
+    BOT_TEXT_DIE                        = 70300, //"Die!"
+    BOT_TEXT_REZZING_YOU                = 70301, //"Rezzing You"
+    BOT_TEXT_REZZING_                   = 70302, //"Rezzing "
+    BOT_TEXT_YOUR_BOT                   = 70303, //"your bot"
+    BOT_TEXT__S_BOT                     = 70304, //"'s bot"
+    BOT_TEXT_CANT_CONJURE_WATER_YET     = 70305, //"I can't conjure water yet"
+    BOT_TEXT_CANT_CONJURE_FOOD_YET      = 70306, //"I can't conjure food yet"
+    BOT_TEXT_CANT_RIGHT_NOW             = 70307, //"I can't do it right now"
+    BOT_TEXT_HERE_YOU_GO                = 70308, //"Here you go..."
+    BOT_TEXT_DISABLED                   = 70309, //"Disabled"
+    BOT_TEXT_NOT_READY_YET              = 70310, //"Not ready yet"
+    BOT_TEXT_INVALID_OBJECT_TYPE        = 70311, //"Invalid object type"
+    BOT_TEXT_FAILED                     = 70312, //"Failed"
+    BOT_TEXT_DONE                       = 70313, //"Done"
+    BOT_TEXT_NOT_SHAPESHIFTED           = 70314, //"I am not shapeshifted"
+    BOT_TEXT_NO_HEALTHSTONE             = 70315, //"I don't have a healthstone"
+    BOT_TEXT_CANT_CREATE_HEALTHSTONE    = 70316, //"I can't create healthstones yet!"
+    BOT_TEXT_NO_LOCKPICKING             = 70317, //"WTF I don't have lockpicking!"
+    BOT_TEXT_SKILL_LEVEL_TOO_LOW        = 70318, //"My skill level in not high enough"
+    BOT_TEXT_CHANGING_MY_SPEC_TO_       = 70319, //"Changing my spec to "
+    BOT_TEXT_SPEC_ARMS                  = 70320, //"Arms"
+    BOT_TEXT_SPEC_FURY                  = 70321, //"Fury"
+    BOT_TEXT_SPEC_PROTECTION            = 70322, //"Protection"
+    BOT_TEXT_SPEC_RETRIBUTION           = 70323, //"Retribution"
+    BOT_TEXT_SPEC_BEASTMASTERY          = 70324, //"Beast Mastery"
+    BOT_TEXT_SPEC_MARKSMANSHIP          = 70325, //"Marksmanship"
+    BOT_TEXT_SPEC_SURVIVAL              = 70326, //"Survival"
+    BOT_TEXT_SPEC_ASSASINATION          = 70327, //"Assassination"
+    BOT_TEXT_SPEC_COMBAT                = 70328, //"Combat"
+    BOT_TEXT_SPEC_SUBTLETY              = 70329, //"Subtlety"
+    BOT_TEXT_SPEC_DISCIPLINE            = 70330, //"Discipline"
+    BOT_TEXT_SPEC_HOLY                  = 70331, //"Holy"
+    BOT_TEXT_SPEC_SHADOW                = 70332, //"Shadow"
+    BOT_TEXT_SPEC_BLOOD                 = 70333, //"Blood"
+    BOT_TEXT_SPEC_FROST                 = 70334, //"Frost"
+    BOT_TEXT_SPEC_UNHOLY                = 70335, //"Unholy"
+    BOT_TEXT_SPEC_ELEMENTAL             = 70336, //"Elemental"
+    BOT_TEXT_SPEC_ENHANCEMENT           = 70337, //"Enhancement"
+    BOT_TEXT_SPEC_RESTORATION           = 70338, //"Restoration"
+    BOT_TEXT_SPEC_ARCANE                = 70339, //"Arcane"
+    BOT_TEXT_SPEC_FIRE                  = 70340, //"Fire"
+    BOT_TEXT_SPEC_AFFLICTION            = 70341, //"Affliction"
+    BOT_TEXT_SPEC_DEMONOLOGY            = 70342, //"Demonology"
+    BOT_TEXT_SPEC_DESTRUCTION           = 70343, //"Destruction"
+    BOT_TEXT_SPEC_BALANCE               = 70344, //"Balance"
+    BOT_TEXT_SPEC_FERAL                 = 70345, //"Feral Combat"
+    BOT_TEXT_SPEC_UNKNOWN               = 70346, //"Unknown"
+    BOT_TEXT_HIREDENY_DK                = 70347, //"Go away, weakling"
+    BOT_TEXT_HIREDENY_SPHYNX            = 70348, //" is not convinced"
+    BOT_TEXT_HIREDENY_ARCHMAGE          = 70349, //"I am not going to waste my time on just anything"
+    BOT_TEXT_HIREDENY_DREADLORD         = 70350, //NIY
+    BOT_TEXT_HIREDENY_SPELLBREAKER      = 70351, //NIY
+    BOT_TEXT_HIREDENY_DARKRANGER        = 70352, //NIY
+    BOT_TEXT_HIRE_SUCCESS               = 70353, //"I am ready"
+    BOT_TEXT_HIREDENY_MY_MASTER_IS_     = 70354, //"Go away. I serve my master "
+    BOT_TEXT_UNKNOWN                    = 70355, //"unknown"
+    BOT_TEXT__ON_YOU                    = 70356, //" on You!"
+    BOT_TEXT__ON_MYSELF                 = 70357, //" on myself!"
+    BOT_TEXT__ON_                       = 70358, //" on "
+    BOT_TEXT__USED                      = 70359, //" used!"
+    BOT_TEXT_BOT_TANK                   = 70360, //"bot tank"
+    BOT_TEXT_CLASS                      = 70361, //"class"
+    BOT_TEXT_PLAYER                     = 70362, //"player"
+    BOT_TEXT_MASTER                     = 70363, //"master"
+    BOT_TEXT_NONE                       = 70364, //"none"
+    BOT_TEXT_RANK                       = 70365, //"Rank"
+    BOT_TEXT_TALENT                     = 70366, //"talent"
+    BOT_TEXT_PASSIVE                    = 70367, //"passive"
+    BOT_TEXT_HIDDEN                     = 70368, //"hidden"
+    BOT_TEXT_KNOWN                      = 70369, //"known"
+    BOT_TEXT_ABILITY                    = 70370, //"ability"
+    BOT_TEXT_STAT_STR                   = 70371, //"str"
+    BOT_TEXT_STAT_AGI                   = 70372, //"agi"
+    BOT_TEXT_STAT_STA                   = 70373, //"sta"
+    BOT_TEXT_STAT_INT                   = 70374, //"int"
+    BOT_TEXT_STAT_SPI                   = 70375, //"spi"
+    BOT_TEXT_STAT_UNK                   = 70376, //"unk stat"
+    BOT_TEXT_TOTAL                      = 70377, //"total"
+    BOT_TEXT_MELEE_AP                   = 70378, //"Melee AP"
+    BOT_TEXT_RANGED_AP                  = 70379, //"Ranged AP"
+    BOT_TEXT_ARMOR                      = 70380, //"armor"
+    BOT_TEXT_CRIT                       = 70381, //"crit"
+    BOT_TEXT_DEFENSE                    = 70382, //"defense"
+    BOT_TEXT_MISS                       = 70383, //"miss"
+    BOT_TEXT_DODGE                      = 70384, //"dodge"
+    BOT_TEXT_PARRY                      = 70385, //"parry"
+    BOT_TEXT_BLOCK                      = 70386, //"block"
+    BOT_TEXT_BLOCKVALUE                 = 70387, //"block value"
+    BOT_TEXT_DMG_TAKEN_MELEE            = 70388, //"Damage taken melee"
+    BOT_TEXT_DMG_TAKEN_SPELL            = 70389, //"Damage taken spell"
+    BOT_TEXT_DMG_RANGE_MAINHAND         = 70390, //"Damage range mainhand"
+    BOT_TEXT_DMG_MULT_MAINHAND          = 70391, //"Damage mult mainhand"
+    BOT_TEXT_ATTACK_TIME_MAINHAND       = 70392, //"Attack time mainhand"
+    BOT_TEXT_DMG_RANGE_OFFHAND          = 70393, //"Damage range offhand"
+    BOT_TEXT_DMG_MULT_OFFHAND           = 70394, //"Damage mult offhand"
+    BOT_TEXT_ATTACK_TIME_OFFHAND        = 70395, //"Attack time offhand"
+    BOT_TEXT_DMG_RANGE_RANGED           = 70396, //"Damage range ranged"
+    BOT_TEXT_DMG_MULT_RANGED            = 70397, //"Damage mult ranged"
+    BOT_TEXT_ATTACK_TIME_RANGED         = 70398, //"Attack time ranged"
+    BOT_TEXT_MIN                        = 70399, //"min"
+    BOT_TEXT_MAX                        = 70400, //"max"
+    BOT_TEXT_DPS                        = 70401, //"DPS"
+    BOT_TEXT_BASE_HP                    = 70402, //"base hp"
+    BOT_TEXT_TOTAL_HP                   = 70403, //"total hp"
+    BOT_TEXT_BASE_MP                    = 70404, //"base mana"
+    BOT_TEXT_TOTAL_MP                   = 70405, //"total mana"
+    BOT_TEXT_CURR_MP                    = 70406, //"current mana"
+    BOT_TEXT_SPELLPOWER                 = 70407, //"spell power"
+    BOT_TEXT_REGEN_HP                   = 70408, //"health regen_5 bonus"
+    BOT_TEXT_REGEN_MP_CAST              = 70409, //"mana regen_5 no cast"
+    BOT_TEXT_REGEN_MP_NOCAST            = 70410, //"mana regen_5 casting"
+    BOT_TEXT_HASTE                      = 70411, //"haste"
+    BOT_TEXT_HIT                        = 70412, //"hit"
+    BOT_TEXT_EXPERTISE                  = 70413, //"expertise"
+    BOT_TEXT_ARMOR_PEN                  = 70414, //"armor penetration"
+    BOT_TEXT_SPELL_PEN                  = 70415, //"spell penetration"
+    BOT_TEXT_PCT                        = 70416, //"pct"
+    BOT_TEXT_HOLY                       = 70417, //"holy"
+    BOT_TEXT_FIRE                       = 70418, //"fire"
+    BOT_TEXT_NATURE                     = 70419, //"nature"
+    BOT_TEXT_FROST                      = 70420, //"frost"
+    BOT_TEXT_SHADOW                     = 70421, //"shadow"
+    BOT_TEXT_ARCANE                     = 70422, //"arcane"
+    BOT_TEXT_RESISTANCE                 = 70423, //"Resistance"
+    BOT_TEXT_COMMAND_STATES             = 70424, //"Command states"
+    BOT_TEXT_COMMAND_FOLLOW             = 70425, //"Follow"
+    BOT_TEXT_COMMAND_ATTACK             = 70426, //"Attack"
+    BOT_TEXT_COMMAND_STAY               = 70427, //"Stay"
+    BOT_TEXT_COMMAND_RESET              = 70428, //"Reset"
+    BOT_TEXT_COMMAND_FULLSTOP           = 70429, //"FullStop"
+    BOT_TEXT_FOLLOW_DISTANCE            = 70430, //"Follow distance"
+    BOT_TEXT_SPEC                       = 70431, //"Spec"
+    BOT_TEXT_BOT_ROLEMASK_MAIN          = 70432, //"Bot roles mask main"
+    BOT_TEXT_BOT_ROLEMASK_GATHERING     = 70433, //"Bot roles mask gathering"
+    BOT_TEXT_PVP_KILLS                  = 70434, //"PvP kills"
+    BOT_TEXT_PLAYERS                    = 70435, //"players"
+    BOT_TEXT_DIED_                      = 70436, //"Died "
+    BOT_TEXT__TIMES                     = 70437, //" times"
+    BOT_TEXT_BOT_TICKLED                = 70438, //"%s (bot) calms down"
+    BOT_TEXT_DEBUG                      = 70439, //"<Debug>"
+    BOT_TEXT_HIREWARN_SPHYNX_1          = 70440, //"Are you sure you want to risk drawing "
+    BOT_TEXT_HIREWARN_SPHYNX_2          = 70441, //"'s attention?"
+    BOT_TEXT_HIREOPTION_SPHYNX          = 70442, //"<Insert Coin>"
+    BOT_TEXT_HIREWARN_DREADLORD         = 70443, //"Do you want to entice "
+    BOT_TEXT_HIREOPTION_DREADLORD       = 70444, //"<Try to make an offering>"
+    BOT_TEXT_HIREWARN_DEFAULT           = 70445, //"Do you wish to hire "
+    BOT_TEXT_HIREOPTION_DEFAULT         = 70446, //"<Hire bot>"
+    BOT_TEXT_MANAGE_EQUIPMENT           = 70447, //"Manage equipment..."
+    BOT_TEXT_MANAGE_ROLES               = 70448, //"Manage roles..."
+    BOT_TEXT_MANAGE_FORMATION           = 70449, //"Manage formation..."
+    BOT_TEXT_MANAGE_ABILITIES           = 70450, //"Manage abilities..."
+    BOT_TEXT_MANAGE_TALENTS             = 70451, //"Manage talents..."
+    BOT_TEXT_GIVE_CONSUMABLE            = 70452, //"Give consumable..."
+    BOT_TEXT_CREATE_GROUP               = 70453, //"<Create group>"
+    BOT_TEXT_CREATE_GROUP_ALL           = 70454, //"<Create group (all bots)>"
+    BOT_TEXT_ADD_TO_GROUP               = 70455, //"<Add to group>"
+    BOT_TEXT_ADD_TO_GROUP_ALL           = 70456, //"<Add all bots to group>"
+    BOT_TEXT_REMOVE_FROM_GROUP          = 70457, //"<Remove from group>"
+    BOT_TEXT_FOLLOW_ME                  = 70458, //"Follow me"
+    BOT_TEXT_HOLD_POSITION              = 70459, //"Hold your position"
+    BOT_TEXT_STAY_HERE                  = 70460, //"Stay here and don't do anything"
+    BOT_TEXT_MAGE_FOOD                  = 70461, //"I need food"
+    BOT_TEXT_MAGE_DRINK                 = 70462, //"I need water"
+    BOT_TEXT_MAGE_TABLE                 = 70463, //"I need a refreshment table"
+    BOT_TEXT_ROGUE_PICKLOCK             = 70464, //"Help me pick a lock"
+    BOT_TEXT_WARLOCK_HEALTHSTONE        = 70465, //"I need your your healthstone"
+    BOT_TEXT_WARLOCK_SOULWELL           = 70466, //"I need a soulwell"
+    BOT_TEXT_ROGUE_POISON_REFRESH       = 70467, //"I need you to refresh poisons"
+    BOT_TEXT_ROGUE_POISON_MH            = 70468, //"<Choose poison (Main Hand)>"
+    BOT_TEXT_ROGUE_POISON_OH            = 70469, //"<Choose poison (Offhand)>"
+    BOT_TEXT_SHAMAN_ENCH_REFRESH        = 70470, //"I need you to refresh enchants"
+    BOT_TEXT_SHAMAN_ENCH_MH             = 70471, //"<Choose enchant (Main Hand)>"
+    BOT_TEXT_SHAMAN_ENCH_OH             = 70472, //"<Choose enchant (Offhand)>"
+    BOT_TEXT_REMOVE_SHAPESHIFT          = 70473, //"I need you to remove shapeshift"
+    BOT_TEXT_CHOOSE_PET_TYPE            = 70474, //"<Choose pet type>"
+    BOT_TEXT_UR_DISMISSED               = 70475, //"You are dismissed"
+    BOT_TEXT_ABANDON_WARN_1             = 70476, //"Are you going to abandon "
+    BOT_TEXT_ABANDON_WARN_2             = 70477, //"You may regret it..."
+    BOT_TEXT_PULL_URSELF                = 70478, //"Pull yourself together, damnit"
+    BOT_TEXT_STUDY_CREATURE             = 70479, //"<Study the creature>"
+    BOT_TEXT_NEVERMIND                  = 70480, //"Nevermind"
+    BOT_TEXT_DISTANCE_SHORT             = 70481, //"dist"
+    BOT_TEXT_BACK                       = 70482, //"BACK"
+    BOT_TEXT_AUTO                       = 70483, //"<Auto>"
+    BOT_TEXT_NONE2                      = 70484, //"<None>"
+    BOT_TEXT_RANDOMPET_CUNNING          = 70485, //"Random (Cunning)"
+    BOT_TEXT_RANDOMPET_FEROCITY         = 70486, //"Random (Ferocity)"
+    BOT_TEXT_RANDOMPET_TENACITY         = 70487, //"Random (Tenacity)"
+    BOT_TEXT_SHOW_INVENTORY             = 70488, //"Show me your inventory"
+    BOT_TEXT_AUTOEQUIP                  = 70489, //"Auto-equip"
+    BOT_TEXT_SLOT_MH                    = 70490, //"Main hand"
+    BOT_TEXT_SLOT_OH                    = 70491, //"Off-hand"
+    BOT_TEXT_SLOT_RH                    = 70492, //"Ranged"
+    BOT_TEXT_SLOT_RELIC                 = 70493, //"Relic"
+    BOT_TEXT_SLOT_HEAD                  = 70494, //"Head"
+    BOT_TEXT_SLOT_SHOULDERS             = 70495, //"Shoulders"
+    BOT_TEXT_SLOT_CHEST                 = 70496, //"Chest"
+    BOT_TEXT_SLOT_WAIST                 = 70497, //"Waist"
+    BOT_TEXT_SLOT_LEGS                  = 70498, //"Legs"
+    BOT_TEXT_SLOT_FEET                  = 70499, //"Feet"
+    BOT_TEXT_SLOT_WRIST                 = 70500, //"Wrist"
+    BOT_TEXT_SLOT_HANDS                 = 70501, //"Hands"
+    BOT_TEXT_SLOT_BACK                  = 70502, //"Back"
+    BOT_TEXT_SLOT_SHIRT                 = 70503, //"Shirt"
+    BOT_TEXT_SLOT_FINGER1               = 70504, //"Finger1"
+    BOT_TEXT_SLOT_FINGER2               = 70505, //"Finger2"
+    BOT_TEXT_SLOT_TRINKET1              = 70506, //"Trinket1"
+    BOT_TEXT_SLOT_TRINKET2              = 70507, //"Trinket2"
+    BOT_TEXT_SLOT_NECK                  = 70508, //"Neck"
+    BOT_TEXT_UNEQUIP_ALL                = 70509, //"Unequip all"
+    BOT_TEXT_UPDATE_VISUAL              = 70510, //"Update visual"
+    BOT_TEXT_VISUALONLY                 = 70511, //"visual only"
+    BOT_TEXT_EQUIPPED                   = 70512, //"Equipped"
+    BOT_TEXT_NOTHING                    = 70513, //"nothing"
+    BOT_TEXT_USE_OLD_EQUIPMENT          = 70514, //"Use your old equipment"
+    BOT_TEXT_UNEQUIP                    = 70515, //"Unequip it"
+    BOT_TEXT_NOTHING_TO_GIVE            = 70516, //"Hm... I have nothing to give you"
+    BOT_TEXT_GATHERING                  = 70517, //"Gathering"
+    BOT_TEXT_ABILITIES_STATUS           = 70518, //"Abilities status"
+    BOT_TEXT_ALLOWED_ABILITIES          = 70519, //"Manage allowed abilities"
+    BOT_TEXT_USE_                       = 70520, //"Use "
+    BOT_TEXT_UPDATE                     = 70521, //"Update"
+    BOT_TEXT_DAMAGE                     = 70522, //"Damage"
+    BOT_TEXT_CONTROL                    = 70523, //"Control"
+    BOT_TEXT_HEAL                       = 70524, //"Heal"
+    BOT_TEXT_OTHER                      = 70525, //"Other"
+    BOT_TEXT_HIRE_EMOTE_SPHYNX          = 70526, //" makes a grinding sound and begins to follow "
+    BOT_TEXT_HIREFAIL_OWNED             = 70527, //"%s will not join you until dismissed by the owner"
+    BOT_TEXT_HIREFAIL_LVL60             = 70528, //"%s will not join you until you are level 60"
+    BOT_TEXT_HIREFAIL_LVL55             = 70529, //"%s will not join you until you are level 55"
+    BOT_TEXT_HIREFAIL_LVL40             = 70530, //"%s will not join you until you are level 40"
+    BOT_TEXT_HIREFAIL_LVL20             = 70531, //"%s will not join you until you are level 20"
+    BOT_TEXT_HIREFAIL_MAXBOTS           = 70532, //"You exceed max npcbots (%u)"
+    BOT_TEXT_HIREFAIL_COST              = 70533, //"You don't have enough money"
+    BOT_TEXT_HIREFAIL_MAXCLASSBOTS      = 70534, //"You cannot have more bots of that class! %u of %u"
+    BOT_TEXT_CANT_DISMISS_EQUIPMENT     = 70535, //"Cannot reset equipment in slot %u (%s)! Cannot dismiss bot!"
+    BOT_TEXT_CURRENT                    = 70536, //"current"
+    BOT_TEXT_ATTACK_DISTANCE            = 70537, //"Attack distance"
+    BOT_TEXT_SHORT_RANGE_ATTACKS        = 70538, //"Short range attacks"
+    BOT_TEXT_LONG_RANGE_ATTACKS         = 70539, //"Long range attacks"
+    BOT_TEXT_EXACT                      = 70540, //"Exact"
+    BOT_TEXT_REMOVE_BUFF                = 70541, //"Remove buff"
+    BOT_TEXT_FIX_POWER                  = 70542, //"Fix your power type"
+    BOT_TEXT_CANT_UNEQUIP_MAILING       = 70543, //"Cannot unequip %s for some stupid reason! Sending through mail"
+    BOT_TEXT_TANK                       = 70544, //"Tank"
+    BOT_TEXT_RANGED                     = 70545, //"Ranged"
+    BOT_TEXT_MINER                      = 70546, //"Miner"
+    BOT_TEXT_HERBALIST                  = 70547, //"Herbalist"
+    BOT_TEXT_SKINNER                    = 70548, //"Skinner"
+    BOT_TEXT_ENGINEER                   = 70549, //"Engineer"
+    BOT_TEXT_OWNERSHIP_EXPIRED          = 70550, //"Bot ownership expired due to inactivity"
+    BOT_TEXT_BOTADDFAIL_DISABLED        = 70551, //"NpcBot system is currently disabled. Please contact administration."
+    BOT_TEXT_BOTADDFAIL_OWNED           = 70552, //"%s will not join you, already has master: %s"
+    BOT_TEXT_BOTADDFAIL_TELEPORTED      = 70553, //"%s cannot join you while about to teleport"
+    BOT_TEXT_ASPECT                     = 70554, //"Aspect"
+    BOT_TEXT_MONKEY                     = 70555, //"Monkey"
+    BOT_TEXT_HAWK                       = 70556, //"Hawk"
+    BOT_TEXT_CHEETAH                    = 70557, //"Cheetah"
+    BOT_TEXT_VIPER                      = 70558, //"Viper"
+    BOT_TEXT_BEAST                      = 70559, //"Beast"
+    BOT_TEXT_PACK                       = 70560, //"Pack"
+    BOT_TEXT_WILD                       = 70561, //"Wild"
+    BOT_TEXT_DRAGONHAWK                 = 70562, //"Dragonhawk"
+    BOT_TEXT_NOASPECT                   = 70563, //"No Aspect"
+    BOT_TEXT_AURA                       = 70564, //"Aura"
+    BOT_TEXT_DEVOTION                   = 70565, //"Devotion"
+    BOT_TEXT_CONCENTRATION              = 70566, //"Concentration"
+    BOT_TEXT_FIRERESISTANCE             = 70567, //"Fire Resistance"
+    BOT_TEXT_FROSTRESISTANCE            = 70568, //"Frost Resistance"
+    BOT_TEXT_SHADOWRESISTANCE           = 70569, //"Shadow Resistance"
+    BOT_TEXT_RETRIBUTION                = 70570, //"Retribution"
+    BOT_TEXT_CRUSADER                   = 70571, //"Crusader"
+    BOT_TEXT_NOAURA                     = 70572, //"No Aura"
+    BOT_TEXT_CRIPPLING                  = 70573, //"Crippling"
+    BOT_TEXT_INSTANT                    = 70574, //"Instant"
+    BOT_TEXT_DEADLY                     = 70575, //"Deadly"
+    BOT_TEXT_WOUND                      = 70576, //"Wound"
+    BOT_TEXT_MINDNUMBING                = 70577, //"Mind-Numbing"
+    BOT_TEXT_ANESTHETIC                 = 70578, //"Anesthetic"
+    BOT_TEXT_NOTHING_C                  = 70579, //"Nothing"
+    BOT_TEXT_FLAMETONGUE                = 70580, //"Flametongue"
+    BOT_TEXT_FROSTBRAND                 = 70581, //"Frostbrand"
+    BOT_TEXT_WINDFURY                   = 70582, //"Windfury"
+    BOT_TEXT_EARTHLIVING                = 70583, //"Earthliving"
+    BOT_TEXT_BOTGIVER_SERVICE           = 70584, //"I need your services"
+    BOT_TEXT_BOTGIVER_TOO_MANY_BOTS     = 70585, //"You have too many bots"
+    BOT_TEXT_BOTGIVER_WISH_TO_HIRE_     = 70586, //"Do you wish to hire "
+    BOT_TEXT_BOTGIVER__BOT_BUSY         = 70587, //" is a bit busy at the moment, try again later."
+    BOT_TEXT_BOTGIVER_HIRESUCCESS       = 70588, //"Pleasure doing business with you"
+    BOT_TEXT_CLASS_WARRIOR_PLU          = 70589, //"Warriors"
+    BOT_TEXT_CLASS_PALADIN_PLU          = 70590, //"Paladins"
+    BOT_TEXT_CLASS_MAGE_PLU             = 70591, //"Mages"
+    BOT_TEXT_CLASS_PRIEST_PLU           = 70592, //"Priests"
+    BOT_TEXT_CLASS_WARLOCK_PLU          = 70593, //"Warlocks"
+    BOT_TEXT_CLASS_DRUID_PLU            = 70594, //"Druids"
+    BOT_TEXT_CLASS_DEATH_KNIGHT_PLU     = 70595, //"Death Knights"
+    BOT_TEXT_CLASS_ROGUE_PLU            = 70596, //"Rogues"
+    BOT_TEXT_CLASS_SHAMAN_PLU           = 70597, //"Shamans"
+    BOT_TEXT_CLASS_HUNTER_PLU           = 70598, //"Hunters"
+    BOT_TEXT_CLASS_BM_PLU               = 70599, //"Blademasters"
+    BOT_TEXT_CLASS_SPHYNX_PLU           = 70600, //"Destroyers"
+    BOT_TEXT_CLASS_ARCHMAGE_PLU         = 70601, //"Archmagi"
+    BOT_TEXT_CLASS_DREADLORD_PLU        = 70602, //"Dreadlords"
+    BOT_TEXT_CLASS_SPELLBREAKER_PLU     = 70603, //"Spell Breakers"
+    BOT_TEXT_CLASS_DARK_RANGER_PLU      = 70604, //"Dark Rangers"
+    BOT_TEXT_CLASS_WARRIOR              = 70605, //"Warrior"
+    BOT_TEXT_CLASS_PALADIN              = 70606, //"Paladin"
+    BOT_TEXT_CLASS_MAGE                 = 70607, //"Mage"
+    BOT_TEXT_CLASS_PRIEST               = 70608, //"Priest"
+    BOT_TEXT_CLASS_WARLOCK              = 70609, //"Warlock"
+    BOT_TEXT_CLASS_DRUID                = 70610, //"Druid"
+    BOT_TEXT_CLASS_DEATH_KNIGHT         = 70611, //"Death Knight"
+    BOT_TEXT_CLASS_ROGUE                = 70612, //"Rogue"
+    BOT_TEXT_CLASS_SHAMAN               = 70613, //"Shaman"
+    BOT_TEXT_CLASS_HUNTER               = 70614, //"Hunter"
+    BOT_TEXT_CLASS_BM                   = 70615, //"Blademaster"
+    BOT_TEXT_CLASS_SPHYNX               = 70616, //"Destroyer"
+    BOT_TEXT_CLASS_ARCHMAGE             = 70617, //"Archmage"
+    BOT_TEXT_CLASS_DREADLORD            = 70618, //"Dreadlord"
+    BOT_TEXT_CLASS_SPELLBREAKER         = 70619, //"Spell Breaker"
+    BOT_TEXT_CLASS_DARK_RANGER          = 70620, //"Dark Ranger"
+    BOT_TEXT_GENDER_MALE                = 70621, //"Male"
+    BOT_TEXT_GENDER_FEMALE              = 70622, //"Female"
+    BOT_TEXT_RACE_HUMAN                 = 70623, //"Human"
+    BOT_TEXT_RACE_ORC                   = 70624, //"Orc"
+    BOT_TEXT_RACE_DWARF                 = 70625, //"Dwarf"
+    BOT_TEXT_RACE_NELF                  = 70626, //"Night Elf"
+    BOT_TEXT_RACE_UNDEAD                = 70627, //"Undead"
+    BOT_TEXT_RACE_TAUREN                = 70628, //"Tauren"
+    BOT_TEXT_RACE_GNOME                 = 70629, //"Gnome"
+    BOT_TEXT_RACE_TROLL                 = 70630, //"Troll"
+    BOT_TEXT_RACE_BELF                  = 70631, //"Blood Elf"
+    BOT_TEXT_RACE_DRAENEI               = 70632, //"Draenei"
+    BOT_TEXT_RACE_UNKNOWN               = 70633, //"Unknown"
+    BOT_TEXT_LOOTING                    = 70634, //"Looting"
+    BOT_TEXT_POOR                       = 70635, //"Poor"
+    BOT_TEXT_COMMON                     = 70636, //"Common"
+    BOT_TEXT_UNCOMMON                   = 70637, //"Uncommon"
+    BOT_TEXT_RARE                       = 70638, //"Rare"
+    BOT_TEXT_EPIC                       = 70639, //"Epic"
+    BOT_TEXT_LEGENDARY                  = 70640, //"Legendary"
+    BOT_TEXT_ENGAGE_BEHAVIOR            = 70641, //"Engage behavior"
+    BOT_TEXT_DELAY_ATTACK_BY            = 70642, //"Delay attack by"
+    BOT_TEXT_DELAY_HEALING_BY           = 70643, //"Delay healing by"
+    BOT_TEXT_SECOND_SHORT               = 70644, //"s"
+    BOT_TEXT_TANK_OFF                   = 70645, //"Off-Tank"
+    BOT_TEXT_CLASS_NECROMANCER_PLU      = 70646, //"Necromancers"
+    BOT_TEXT_CLASS_NECROMANCER          = 70647, //"Necromancer"
+    BOT_TEXT_ATTACK_ANGLE               = 70648, //"Attack angle"
+    BOT_TEXT_NORMAL                     = 70649, //"Normal"
+    BOT_TEXT_AVOID_FRONTAL_AOE          = 70650, //"Avoid frontal AOE"
+    BOT_TEXT_HIREDENY_SEAWITCH          = 70651, //NIY
+    BOT_TEXT_HIREWARN_SEAWITCH          = 70652, //"Are you sure this is gonna work? It's better be the best water in the world..."
+    BOT_TEXT_HIREOPTION_SEAWITCH        = 70653, //"Seems like you could really use a drink of fresh water."
+    BOT_TEXT_CLASS_SEAWITCH_PLU         = 70654, //"Sea Witches"
+    BOT_TEXT_CLASS_SEAWITCH             = 70655, //"Sea Witch"
+    BOT_TEXT_MANA_PER_DAMAGE            = 70656, //"Mana per damage"
+    BOT_TEXT_DAMAGE_PER_MANA            = 70657, //"Damage per mana"
+    BOT_TEXT_TRANSMOGRIFICATION         = 70658, //"Transmogrification..."
+    BOT_TEXT_DISABLE_COMBAT_POSITIONING = 70659, //"DISABLE combat positioning"
+    //70660-70799 reserved for custom localization strings
+};
+
+#endif //BOTTEXT_H
diff --git a/src/server/game/AI/NpcBots/bpet_ai.cpp b/src/server/game/AI/NpcBots/bpet_ai.cpp
new file mode 100644
index 000000000..ec1051517
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_ai.cpp
@@ -0,0 +1,2445 @@
+#include "bpet_ai.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "Log.h"
+#include "Map.h"
+#include "MotionMaster.h"
+#include "ObjectMgr.h"
+#include "SpellAuraEffects.h"
+#include "Transport.h"
+#include "World.h"
+/*
+NpcBot Pet System by Trickerer (https://github.com/trickerer/Trinity-Bots; onlysuffering@gmail.com)
+*/
+
+static constexpr uint32 SHAMAN_MAX_PET_POSITIONS = 2;
+static constexpr uint32 DRUID_MAX_PET_POSITIONS = 3;
+static constexpr uint32 DK_MAX_PET_POSITIONS = 10;
+static constexpr uint32 DARK_RANGER_MAX_PET_POSITIONS = 5;
+static constexpr uint32 NECROMANCER_MAX_PET_POSITIONS = 6;
+float constexpr ShamanPetPositionAnglesByPosNumber[SHAMAN_MAX_PET_POSITIONS] =
+{
+    0.f,//left
+    float(M_PI)//right
+};
+float constexpr DruidPetPositionAnglesByPosNumber[DRUID_MAX_PET_POSITIONS] =
+{
+    0.f,//left
+    float(M_PI)/2,//back
+    float(M_PI)//right
+};
+float constexpr DKPetPositionAnglesByPosNumber[DK_MAX_PET_POSITIONS] =
+{
+    0.f,
+    float(M_PI),
+    0.3490658f,//1*M_PI/9
+    0.6981317f,//2*M_PI/9
+    1.0471975f,//3*M_PI/9
+    1.3962634f,//4*M_PI/9
+    1.7453292f,//5*M_PI/9
+    2.0943951f,//6*M_PI/9
+    2.4434609f,//7*M_PI/9
+    2.7925268f //8*M_PI/9
+};
+float constexpr DarkRangerPetPositionAnglesByPosNumber[DARK_RANGER_MAX_PET_POSITIONS] =
+{
+    0.f,
+    float(M_PI),
+    0.7853981f,//1*M_PI/4
+    1.5707963f,//2*M_PI/4
+    2.3561944f //3*M_PI/4
+};
+float constexpr NecromancerPetPositionAnglesByPosNumber[NECROMANCER_MAX_PET_POSITIONS] =
+{
+    0.f,
+    float(M_PI),
+    float(M_PI) / 5.f * 1.f,
+    float(M_PI) / 5.f * 4.f,
+    float(M_PI) / 5.f * 2.f,
+    float(M_PI) / 5.f * 3.f
+};
+
+extern uint8 GroupIconsFlags[TARGETICONCOUNT];
+
+static uint16 __rand; //calculated for each bot separately once every updateAI tick
+
+extern bool _botPvP;
+extern uint8 _healTargetIconFlags;
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : CreatureAI(creature)
+{
+    m_botCommandState = BOT_COMMAND_FOLLOW;
+    regenTimer = 0;
+    waitTimer = 0;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _energyFraction = 0.f;
+    _updateTimerMedium = 0;
+    _updateTimerEx1 = urand(12000, 15000);
+    checkAurasTimer = 0;
+
+    myType = 0;
+    petOwner = nullptr;
+    canUpdate = true;
+}
+bot_pet_ai::~bot_pet_ai()
+{
+    while (!_spells.empty())
+    {
+        BotPetSpellMap::iterator itr = _spells.begin();
+        delete itr->second;
+        _spells.erase(itr);
+    }
+}
+
+uint16 bot_pet_ai::Rand() const
+{
+    return __rand;
+}
+//0-178
+void bot_pet_ai::GenerateRand() const
+{
+    __rand = urand(0, IAmFree() ? 100 : 100 + (petOwner->GetBotOwner()->GetNpcBotsCount() - 1) * 2);
+}
+
+bool bot_pet_ai::_checkImmunities(Unit const* target, SpellInfo const* spellInfo) const
+{
+    return target && spellInfo && !target->IsImmunedToDamage(spellInfo);
+}
+//Follow point calculation
+void bot_pet_ai::_calculatePos(Position& pos) const
+{
+    float x,y,z;
+    //destination
+    if (petOwner->GetTransport() || !petOwner->GetMotionMaster()->GetDestination(x, y, z))
+        petOwner->GetPosition(x, y, z);
+    //relative angle
+    float o = petOwner->GetOrientation() + PET_FOLLOW_ANGLE;
+    uint8 posNum = petOwner->GetBotAI()->GetPetPositionNumber(me);
+    if (petOwner->GetBotClass() == BOT_CLASS_DEATH_KNIGHT)
+        o += DKPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_DRUID)
+        o += DruidPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_SHAMAN)
+        o += ShamanPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_DARK_RANGER)
+        o += DarkRangerPetPositionAnglesByPosNumber[posNum];
+    else if (petOwner->GetBotClass() == BOT_CLASS_NECROMANCER)
+        o += NecromancerPetPositionAnglesByPosNumber[posNum];
+
+    o = Position::NormalizeOrientation(o);
+    //distance
+    x += (PET_FOLLOW_DIST + me->GetCombatReach()) * std::cos(o);
+    y += (PET_FOLLOW_DIST + me->GetCombatReach()) * std::sin(o);
+    if (!petOwner->GetTransport())
+        me->UpdateGroundPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.5f; //prevent going underground
+
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+void bot_pet_ai::SetBotCommandState(uint8 st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingOrFalling())
+        return;
+
+    if ((st & BOT_COMMAND_FOLLOW) && !IsChanneling() &&
+        ((!me->isMoving() && !IsCasting() && petOwner->GetBotOwner()->IsAlive()) || force))
+    {
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 10) return;
+
+        float x,y,z;
+        if (petOwner->GetMotionMaster()->GetDestination(x, y, z) && me->GetDistance(x, y, z) < 6.f)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW))
+                me->GetMotionMaster()->MoveFollow(petOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+        {
+            if (!newpos)
+                _calculatePos(movepos);
+            else
+            {
+                movepos.m_positionX = newpos->m_positionX;
+                movepos.m_positionY = newpos->m_positionY;
+                movepos.m_positionZ = newpos->m_positionZ;
+            }
+            me->GetMotionMaster()->MovePoint(petOwner->GetMapId(), movepos);
+        }
+        RemoveBotCommandState(BOT_COMMAND_STAY | BOT_COMMAND_FULLSTOP | BOT_COMMAND_ATTACK | BOT_COMMAND_COMBATRESET);
+    }
+    else if (st & BOT_COMMAND_FULLSTOP)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_STAY | BOT_COMMAND_ATTACK);
+        me->AttackStop();
+        me->InterruptNonMeleeSpells(true);
+        if (me->isMoving())
+            me->BotStopMovement();
+    }
+    else if (st & BOT_COMMAND_STAY)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW | BOT_COMMAND_FULLSTOP);
+        if (me->isMoving())
+            me->BotStopMovement();
+    }
+    else if (st & BOT_COMMAND_ATTACK)
+    {
+        RemoveBotCommandState(BOT_COMMAND_FOLLOW);
+    }
+    else if (st & BOT_COMMAND_COMBATRESET)
+    {
+        RemoveBotCommandState(BOT_COMMAND_ATTACK);
+    }
+    m_botCommandState |= st;
+}
+
+void bot_pet_ai::RemoveBotCommandState(uint8 st)
+{
+    m_botCommandState &= ~st;
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_pet_ai::CureGroup(uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell) return;
+    if (GC_Timer > diff) return;
+    if (IsCasting()) return;
+
+    if (IAmFree())
+    {
+        std::list<Unit*> cureTargets;
+
+        if (_canCureTarget(me, cureSpell))
+            cureTargets.push_back(me);
+        if (_canCureTarget(petOwner, cureSpell))
+            cureTargets.push_back(petOwner);
+
+        if (!cureTargets.empty())
+            me->CastSpell(Trinity::Containers::SelectRandomContainerElement(cureTargets), cureSpell, false);
+
+        return;
+    }
+
+    if (!me->GetMap()->IsRaid() && Rand() > 35)
+        return;
+
+    std::list<Unit*> targets;
+    Group const* pGroup = petOwner->GetBotOwner()->GetGroup();
+    BotMap const* map;
+    Unit* u;
+    if (!pGroup)
+    {
+        if (_canCureTarget(petOwner->GetBotOwner(), cureSpell))
+            targets.push_back(petOwner->GetBotOwner());
+
+        map = petOwner->GetBotOwner()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            u = itr->second;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+
+        for (Unit::ControlList::const_iterator itr = petOwner->GetBotOwner()->m_Controlled.begin(); itr != petOwner->GetBotOwner()->m_Controlled.end(); ++itr)
+        {
+            u = *itr;
+            if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+            if (_canCureTarget(u, cureSpell))
+                targets.push_back(u);
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (_canCureTarget(tPlayer, cureSpell))
+                targets.push_back(tPlayer);
+        }
+        if (!Bots) return;
+        for (GroupReference const* itr = pGroup->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == nullptr) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+
+            if (tPlayer->HaveBot())
+            {
+                map = tPlayer->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator bitr = map->begin(); bitr != map->end(); ++bitr)
+                {
+                    u = bitr->second;
+                    if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                    if (_canCureTarget(u, cureSpell))
+                        targets.push_back(u);
+                }
+            }
+
+            for (Unit::ControlList::const_iterator citr = tPlayer->m_Controlled.begin(); citr != tPlayer->m_Controlled.end(); ++citr)
+            {
+                u = *citr;
+                if (!u || !u->IsPet() || !u->IsAlive() || me->GetDistance(u) > 30) continue;
+
+                if (_canCureTarget(u, cureSpell))
+                    targets.push_back(u);
+            }
+        }
+    }
+
+    if (!targets.empty())
+        me->CastSpell(Trinity::Containers::SelectRandomContainerElement(targets), cureSpell, false);
+}
+
+// determines if unit has something to cure
+bool bot_pet_ai::_canCureTarget(Unit const* target, uint32 cureSpell) const
+{
+    if (me->GetLevel() < 10 || target->GetLevel() < 10) return false;
+    if (target->HasUnitState(UNIT_STATE_ISOLATED)) return false;
+    if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsTempBot()) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    if (me->GetDistance(target) > CalcSpellMaxRange(cureSpell, false))
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->_effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->_effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    std::list<Aura const*> dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_pet_ai::_getBotDispellableAuraList(Unit const* target, Unit const* caster, uint32 dispelMask, std::list<Aura const*> &dispelList) const
+{
+    //Unholy Blight prevents diseases from being dispelled
+    if ((dispelMask & (1<<DISPEL_DISEASE)) &&
+        target->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_DEATHKNIGHT, 1494, 0))
+        dispelMask &= ~(1<<DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura const* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication const* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            if (((aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount()) > 0)
+                dispelList.push_back(aura);
+        }
+    }
+}
+
+uint32 bot_pet_ai::GetData(uint32 data) const
+{
+    switch (data)
+    {
+        case BOTPETAI_MISC_DURATION:
+            return 0;
+        case BOTPETAI_MISC_MAXLEVEL:
+            return petOwner->GetLevel();
+        default:
+            TC_LOG_DEBUG("entities.unit", "bot_pet_ai::GetData(): unk data type %u!", data);
+            return 0;
+    }
+}
+
+void bot_pet_ai::SetPetStats(bool force)
+{
+    switch (myType)
+    {
+        //warlock
+        case BOT_PET_IMP:
+        case BOT_PET_VOIDWALKER:
+        case BOT_PET_SUCCUBUS:
+        case BOT_PET_FELHUNTER:
+        case BOT_PET_FELGUARD:
+        //hunter
+        //cunning
+        case BOT_PET_SPIDER:
+        case BOT_PET_SERPENT:
+        case BOT_PET_BIRDOFPREY:
+        case BOT_PET_BAT:
+        case BOT_PET_WINDSERPENT:
+        case BOT_PET_RAVAGER:
+        case BOT_PET_DRAGONHAWK:
+        case BOT_PET_NETHERRAY:
+        case BOT_PET_SPOREBAT:
+        //ferocity
+        case BOT_PET_CARRIONBIRD:
+        case BOT_PET_RAPTOR:
+        case BOT_PET_WOLF:
+        case BOT_PET_TALLSTRIDER:
+        case BOT_PET_CAT:
+        case BOT_PET_HYENA:
+        case BOT_PET_WASP:
+        case BOT_PET_TEROMOTH:
+        //tenacity
+        case BOT_PET_SCORPID:
+        case BOT_PET_TURTLE:
+        case BOT_PET_GORILLA:
+        case BOT_PET_BEAR:
+        case BOT_PET_BOAR:
+        case BOT_PET_CRAB:
+        case BOT_PET_CROCOLISK:
+        case BOT_PET_WARPSTALKER:
+        //cunning (exotic)
+        case BOT_PET_SILITHID:
+        case BOT_PET_CHIMAERA:
+        //ferocity (exotic)
+        case BOT_PET_SPIRITBEAST:
+        case BOT_PET_COREHOUND:
+        case BOT_PET_DEVILSAUR:
+        //tenacity (exotic)
+        case BOT_PET_RHINO:
+        case BOT_PET_WORM:
+        //death knight
+        case BOT_PET_GHOUL:
+        //case BOT_PET_GARGOYLE:
+        //case BOT_PET_DANCING_RUNE_WEAPON:
+        //case BOT_PET_AOD_GHOUL:
+        //priest
+        case BOT_PET_SHADOWFIEND:
+        //shaman
+        case BOT_PET_SPIRIT_WOLF:
+        //mage
+        case BOT_PET_WATER_ELEMENTAL:
+        //druid
+        case BOT_PET_FORCE_OF_NATURE:
+        //archmage
+        case BOT_PET_AWATER_ELEMENTAL:
+        //dreadlord
+        case BOT_PET_INFERNAL:
+        //dark ranger
+        case BOT_PET_DARK_MINION:
+        case BOT_PET_DARK_MINION_ELITE:
+        //necromancer
+        case BOT_PET_NECROSKELETON:
+        //sea witch
+        case BOT_PET_TORNADO:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "bot_pet_ai::SetPetStats(): unk pet type %u, aborting", myType);
+            return;
+    }
+
+    //some time limited summons can only init stats and never change them
+    switch (myType)
+    {
+        case BOT_PET_SHADOWFIEND:
+        case BOT_PET_SPIRIT_WOLF:
+        //case BOT_PET_WATER_ELEMENTAL:
+        case BOT_PET_FORCE_OF_NATURE:
+        case BOT_PET_DARK_MINION:
+        case BOT_PET_DARK_MINION_ELITE:
+        case BOT_PET_NECROSKELETON:
+        case BOT_PET_TORNADO:
+            if (force == false)
+                return;
+            break;
+        default:
+            break;
+    }
+
+    uint8 level = std::min<uint8>(petOwner->GetLevel(), GetData(BOTPETAI_MISC_MAXLEVEL));
+    if (level != me->GetLevel())
+    {
+        me->SetLevel(level);
+        force = true;
+    }
+
+    int32 spdtotal;
+    switch (petOwner->GetBotClass())
+    {
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_ARCHMAGE:
+        case BOT_CLASS_DREADLORD:
+        case BOT_CLASS_SEA_WITCH:
+            spdtotal = petOwner->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);
+            break;
+        default:
+            spdtotal = 0;
+            break;
+    }
+
+    if (force)
+    {
+        InitPetSpells();
+        ApplyPetPassives();
+
+        me->RemoveAurasDueToSpell(DAMAGEDONE_PASSIVE);
+        me->RemoveAurasDueToSpell(DAMAGETAKEN_PASSIVE);
+        me->RemoveAurasDueToSpell(SPELLDAMAGE_PASSIVE);
+        me->RemoveAurasDueToSpell(SPELLPENETRATION_PASSIVE);
+        me->RemoveAurasDueToSpell(SPELLHASTE_PASSIVE);
+        me->RemoveAurasDueToSpell(CRITBONUS_PASSIVE);
+
+        me->CastSpell(me, DAMAGEDONE_PASSIVE, true);
+        me->CastSpell(me, DAMAGETAKEN_PASSIVE, true);
+        me->CastSpell(me, SPELLDAMAGE_PASSIVE, true);
+        me->CastSpell(me, SPELLPENETRATION_PASSIVE, true);
+        me->CastSpell(me, SPELLHASTE_PASSIVE, true);
+        me->CastSpell(me, CRITBONUS_PASSIVE, true);
+    }
+
+    //base stats
+    uint32 myarmor = 0;
+    if (force)
+    {
+        uint32 origEntry = bot_ai::GetPetOriginalEntry(myType);
+        CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(origEntry);
+        ASSERT(cinfo);
+
+        me->SetMeleeDamageSchool(SpellSchools(cinfo->dmgschool));
+
+        PetLevelInfo const* pInfo = sObjectMgr->GetPetLevelInfo(origEntry, level);
+        if (pInfo)
+        {
+            me->SetCreateHealth(pInfo->health);
+            if (petOwner->GetBotClass() == BOT_CLASS_HUNTER) //hunter pet use focus
+            {
+                //prevent from modifying powers inside
+                if (me->GetPowerType() != POWER_FOCUS)
+                {
+                    me->SetMaxPower(POWER_FOCUS, 100);
+                    me->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_FOCUS);
+                }
+            }
+            else if (myType == BOT_PET_GHOUL)
+            {
+                if (me->GetPowerType() != POWER_ENERGY)
+                {
+                    me->SetMaxPower(POWER_ENERGY, 100);
+                    me->SetByteValue(UNIT_FIELD_BYTES_0, 3, POWER_ENERGY);
+                }
+            }
+            else if (myType == BOT_PET_SHADOWFIEND)
+            {
+                me->SetCreateHealth(28 + 30*level);
+                me->SetCreateMana(28 + 10*level);
+                me->SetPowerType(POWER_MANA);
+            }
+            else if (myType == BOT_PET_SPIRIT_WOLF)
+            {
+                me->SetCreateHealth(30*level);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_FORCE_OF_NATURE)
+            {
+                me->SetCreateHealth(30*(level+1));
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_DARK_MINION)
+            {
+                me->SetCreateHealth(pInfo->health / 4);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_DARK_MINION_ELITE)
+            {
+                me->SetCreateHealth(pInfo->health / 2);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_NECROSKELETON)
+            {
+                me->SetCreateHealth(pInfo->health / 5);
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else if (myType == BOT_PET_AWATER_ELEMENTAL || myType == BOT_PET_INFERNAL)
+            {
+                //custom pets / not using mana
+                me->SetByteValue(UNIT_FIELD_BYTES_0, 3, MAX_POWERS);
+            }
+            else
+            {
+                me->SetCreateMana(pInfo->mana);
+                me->SetPowerType(POWER_MANA);
+            }
+
+            if (pInfo->armor > 0)
+                myarmor = pInfo->armor;
+
+            for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+                me->SetCreateStat(Stats(i), pInfo->stats[i]);
+        }
+        else
+        {
+            CreatureBaseStats const* stats = sObjectMgr->GetCreatureBaseStats(level, me->GetCreatureTemplate()->unit_class);
+            me->SetCreateHealth(stats->BaseHealth[cinfo->expansion]);
+            me->SetCreateMana(stats->BaseMana);
+
+            me->SetCreateStat(STAT_STRENGTH, level * 3 + 20);
+            me->SetCreateStat(STAT_AGILITY, level * 2 + 20);
+            me->SetCreateStat(STAT_STAMINA, level * 5 + 20);
+            me->SetCreateStat(STAT_INTELLECT, level * 2 + 25);
+            me->SetCreateStat(STAT_SPIRIT,  level * 2 + 30);
+            TC_LOG_ERROR("entities.unit", "SetPetStats(): pInfo is NULL, setting default stats for pet %u", myType);
+        }
+    }
+
+    //STAT INHERITANCE
+    //STAT -- 'mod' -- description
+    // WARLOCK
+    //AP      x0.57 -- attack power from spd
+    //Armor   x0.35 -- armor
+    //Resist  x0.4  -- resistances
+    //Stamina x0.75 -- stamina
+    //Int     x0.3  -- int
+    //Spd     x0.15 -- spd
+    //Sppen   x1.00 -- sppenetration
+    // HUNTER
+    //AP      x0.22 -- attack power/spd from ranged AP (0.338 wild hunt)
+    //Stamina x0.4  -- health (0.63 wild hunt)
+    //Spd   x0.1287 -- spd from ranged AP (0.18 wild hunt)
+    //rest is same as warlock
+    // DK
+    //AP      x1.52 -- attack power from master's strength
+    //Stamina x0.88 -- health
+    //rest is same as warlock
+    // PRIEST
+    //Damage from spd
+    // SHAMAN
+    //AP      x0.6  -- attack power glyphed
+    //Stamina x0.75 -- health
+    // MAGE
+    //Stamina x0.75 -- health
+    //Spd     x0.40 -- spd
+    //Int     x0.3  -- int
+    // DRUID
+    //Stamina x0.45 -- health
+    //
+    // SHAMAN
+    //
+    // ARCHMAGE
+    //Stamina x2.5  -- stamina
+    //Spd     x1.0  -- spd
+    //rest is same as warlock
+    // DREADLORD
+    //AP      x1.00 -- attack power from spd
+    //Resist  x2.0  -- resistances
+    //Stamina x2.5  -- stamina
+    //Spd     x1.0  -- spd
+    // DARK RANGER
+    //AP      x0.50 -- attack power
+    //Resist  x0.3  -- resistances
+    //Stamina x0.8  -- stamina
+    //rest is same as warlock
+    // NECROMANCER
+    //AP      x0.40 -- attack power
+    //Resist  x0.25 -- resistances
+    //Stamina x0.8  -- stamina
+    //rest is same as warlock
+    // SEA WITCH
+    //Spd     x1.0  -- spd
+    //rest is same as warlock
+
+    //attack power
+    if (force)
+    {
+        if (myType == BOT_PET_SHADOWFIEND)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 3 + spdtotal * 0.3f));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 5 + spdtotal * 0.3f));
+        }
+        else if (myType == BOT_PET_SPIRIT_WOLF)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 3));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 5));
+        }
+        else if (myType == BOT_PET_FORCE_OF_NATURE)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 2) + spdtotal * 0.15f);
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 3) + spdtotal * 0.15f);
+        }
+        else if (myType == BOT_PET_DARK_MINION)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level + level / 2));
+        }
+        else if (myType == BOT_PET_DARK_MINION_ELITE)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level * 3));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level * 4));
+        }
+        else if (myType == BOT_PET_NECROSKELETON)
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level + level / 3));
+        }
+        else
+        {
+            me->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, float(level - (level / 4)));
+            me->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, float(level + (level / 4)));
+        }
+    }
+    float atpower = /*IAmFree() ? 1000.f :*/ 0.f; //+1000/+0 base pet ap
+    switch (myType)
+    {
+        case BOT_PET_IMP:
+            atpower += me->GetTotalStatValue(STAT_STRENGTH) - 10.0f;
+            break;
+        case BOT_PET_GHOUL:
+            atpower += me->GetTotalStatValue(STAT_STRENGTH) - 10.0f;
+            atpower += 1.52f * petOwner->GetTotalStatValue(STAT_STRENGTH);
+            atpower += 0.3f * petOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+            atpower += level * 8;
+            break;
+        case BOT_PET_DARK_MINION:
+            atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            atpower += 0.3f * petOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+            break;
+        case BOT_PET_DARK_MINION_ELITE:
+            atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            atpower += 0.4f * petOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+            break;
+        case BOT_PET_NECROSKELETON:
+            atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            break;
+        default:
+            //atpower += 2 * me->GetTotalStatValue(STAT_STRENGTH) - 20.0f;
+            break;
+    }
+    switch (petOwner->GetBotClass())
+    {
+        case BOT_CLASS_HUNTER:
+            atpower += (level >= 80 ? 0.338f : 0.22f) * petOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+            //Hunter vs. Wild
+            if (level >= 30 && Spec() == BOT_SPEC_HUNTER_SURVIVAL)
+                atpower += 0.3f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            //Animal Handler
+            if (level >= 35 && Spec() == BOT_SPEC_HUNTER_BEASTMASTERY)
+                atpower *= 1.1f;
+            break;
+        case BOT_CLASS_SHAMAN:
+            //Glyph of Feral Spirit
+            atpower += 0.6f * petOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+            break;
+        case BOT_CLASS_DRUID:
+            atpower += 300 + 0.3f * petOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+            break;
+        case BOT_CLASS_WARLOCK:
+            atpower += 0.57f * spdtotal;
+            //TC_LOG_ERROR("entities.player", "SetPetStat(): atpower += 0.57 of %i = %.2f", spdtotal, atpower);
+            break;
+        case BOT_CLASS_DREADLORD:
+            atpower += spdtotal * 6;
+            break;
+        case BOT_CLASS_NECROMANCER:
+            atpower += 0.75f * spdtotal;
+            break;
+        default:
+            break;
+    }
+    me->SetStatFlatModifier(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    me->UpdateAttackPowerAndDamage();
+    //armor
+    myarmor = std::max<uint32>(myarmor, level*50);
+    myarmor += me->GetStat(STAT_AGILITY)*2 + petOwner->GetArmor()*0.35f;
+    //armor bonuses
+    if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+    {
+        //5% innate
+        myarmor += myarmor / 20;
+        //Thick Hide
+        if (level >= 15)
+            myarmor += myarmor / 5;
+        //Natural Armor
+        if (level >= 20)
+            myarmor += myarmor / 10;
+        //Pet Barding
+        if (level >= 32)
+            myarmor += myarmor / 10;
+    }
+    if (petOwner->GetBotClass() == BOT_CLASS_DARK_RANGER || petOwner->GetBotClass() == BOT_CLASS_NECROMANCER)
+    {
+        //even though skeletons have shields their armor needs to be very low
+        myarmor = myarmor / 4;
+    }
+    me->SetStatFlatModifier(UNIT_MOD_ARMOR, BASE_VALUE, float(myarmor));
+    me->UpdateArmor();
+    //resistances
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        float petResist;
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_DREADLORD:
+                petResist = (petOwner->GetBotAI()->GetBotResistanceBonus(SpellSchools(i)) + petOwner->GetResistance(SpellSchools(i)))*2.0f;
+                break;
+            case BOT_CLASS_DARK_RANGER:
+            case BOT_CLASS_NECROMANCER:
+                petResist = (petOwner->GetBotAI()->GetBotResistanceBonus(SpellSchools(i)) + petOwner->GetResistance(SpellSchools(i)))*0.3f;
+                break;
+            default:
+                petResist = (petOwner->GetBotAI()->GetBotResistanceBonus(SpellSchools(i)) + petOwner->GetResistance(SpellSchools(i)))*0.4f;
+                break;
+        }
+        me->SetStatFlatModifier(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, petResist);
+        me->UpdateResistances(i);
+    }
+    //crit physical
+    if (AuraEffect* critbonus = me->GetAuraEffect(CRITBONUS_PASSIVE, 1, me->GetGUID()))
+    {
+        int32 amount = 5; //base crit
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Demonic Tactics part 1 (pet)
+                amount += level >= 45 ? 10 : 0;
+                //Improved Demonic Tactics (pshysical)
+                amount += level >= 50 ? petOwner->GetCreatureCritChance() * 0.3f : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Ferocity
+                if (level >= 20)
+                    amount += 10;
+                //Spider's Bite
+                if (level >= 44)
+                    amount += 9;
+                break;
+            case BOT_CLASS_DREADLORD:
+                amount += petOwner->GetCreatureCritChance() * 0.5f;
+                break;
+            case BOT_CLASS_DARK_RANGER:
+            case BOT_CLASS_NECROMANCER:
+                amount += petOwner->GetCreatureCritChance() * 0.35f;
+                break;
+            default:
+                break;
+        }
+        critbonus->ChangeAmount(amount);
+    }
+    //crit spell
+    if (AuraEffect* critbonus = me->GetAuraEffect(CRITBONUS_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 5; //base crit
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+            case BOT_PET_SUCCUBUS:
+                //Master Demonologist part 1.2 (pet)
+                //Master Demonologist part 3.2 (pet)
+                amount += level >= 35 ? 5 : 0;
+                //Improved Demonic Tactics (pshysical)
+                amount += level >= 50 ? petOwner->GetCreatureCritChance() * 0.3f : 0;
+                break;
+            default:
+                break;
+        }
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Demonic Tactics part 2 (pet)
+                amount += level >= 45 ? 10 : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Ferocity
+                if (level >= 20)
+                    amount += 10;
+                //Spider's Bite
+                if (level >= 44)
+                    amount += 9;
+                break;
+            case BOT_CLASS_ARCHMAGE:
+            case BOT_CLASS_SEA_WITCH:
+                amount += petOwner->GetCreatureCritChance();
+                break;
+            default:
+                break;
+        }
+        critbonus->ChangeAmount(amount);
+    }
+    //damage done physical
+    if (AuraEffect* physdam = me->GetAuraEffect(DAMAGEDONE_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+                //Empowered Imp part 1
+                amount += level >= 50 ? 30 : 0;
+                break;
+            case BOT_PET_INFERNAL:
+                amount += 100;
+                break;
+            default:
+                break;
+        }
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Unholy Power
+                if (myType != BOT_PET_IMP)
+                    amount += level >= 30 ? 20 : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Hapiness bonus (always happy) + 5% innate
+                amount += 30;
+                //Unleashed Fury
+                if (level >= 20)
+                    amount += 15;
+                //Kindred Spirits
+                if (level >= 55 && Spec() == BOT_SPEC_HUNTER_BEASTMASTERY)
+                    amount += 20;
+                //Spiked Collar
+                if (level >= 32)
+                    amount += 9;
+                //Shark Attack
+                if (level >= 80)
+                    amount += 6;
+                break;
+            default:
+                break;
+        }
+        //Command (Racial)
+        if (petOwner->GetRace() == RACE_ORC)
+            amount += 5;
+        physdam->ChangeAmount(amount);
+    }
+    //damage done magic
+    if (AuraEffect* spelldam = me->GetAuraEffect(DAMAGEDONE_PASSIVE, 1, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+                //Empowered Imp part 1, Master Demonologist part 1.2 (pet), Improved Imp part 1
+                amount += level >= 50 ? 65 : level >= 35 ? 35 : level >= 10 ? 30 : 0;
+                break;
+            case BOT_PET_SUCCUBUS:
+                //Master Demonologist part 3 (pet)
+                amount += level >= 35 ? 5 : 0;
+                break;
+            default:
+                break;
+        }
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                //Unholy Power
+                if (myType == BOT_PET_IMP)
+                    amount += level >= 30 ? 20 : 0;
+                break;
+            case BOT_CLASS_HUNTER:
+                //Hapiness bonus (always happy) + 5% innate
+                amount += 30;
+                //Unleashed Fury
+                if (level >= 20)
+                    amount += 15;
+                //Kindred Spirits
+                if (level >= 55 && Spec() == BOT_SPEC_HUNTER_BEASTMASTERY)
+                    amount += 20;
+                //Spiked Collar
+                if (level >= 32)
+                    amount += 9;
+                //Shark Attack
+                if (level >= 80)
+                    amount += 6;
+                break;
+            default:
+                break;
+        }
+        //Command (Racial)
+        if (petOwner->GetRace() == RACE_ORC)
+            amount += 5;
+        spelldam->ChangeAmount(amount);
+    }
+    //spell power
+    if (AuraEffect* spelldam = me->GetAuraEffect(SPELLDAMAGE_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (petOwner->GetBotClass())
+        {
+            case BOT_CLASS_HUNTER:
+                amount += int32(petOwner->GetTotalAttackPowerValue(RANGED_ATTACK) * (level >= 80 ? 0.18f : 0.1287f));
+                break;
+            case BOT_CLASS_WARLOCK:
+                amount += int32(spdtotal * 0.15f);
+                break;
+            case BOT_CLASS_MAGE:
+                amount += int32(spdtotal * 0.4f);
+                break;
+            case BOT_CLASS_ARCHMAGE:
+                amount += int32(spdtotal * 1.0f);
+                break;
+            case BOT_CLASS_DREADLORD:
+                amount += int32(spdtotal * 1.0f);
+                break;
+            case BOT_CLASS_SEA_WITCH:
+                amount += int32(spdtotal * 1.0f);
+                break;
+            default:
+                break;
+        }
+        spelldam->ChangeAmount(amount);
+    }
+    //spell penetration
+    if (AuraEffect* spellpenet = me->GetAuraEffect(SPELLPENETRATION_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = int32(petOwner->GetCreatureSpellPenetration());
+        spellpenet->ChangeAmount(amount);
+    }
+    //haste spell
+    if (AuraEffect* spellhaste = me->GetAuraEffect(SPELLHASTE_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+        switch (myType)
+        {
+            case BOT_PET_IMP:
+                //Demonic Power part 2
+                amount += level >= 20 ? 25 : 0;
+                break;
+            case BOT_PET_SUCCUBUS:
+                //Improved Succubus part 1
+                amount += level >= 20 ? 200 : 0;
+                break;
+            case BOT_PET_AWATER_ELEMENTAL:
+                amount += petOwner->GetBotAI()->GetHaste();
+                break;
+            default:
+                break;
+        }
+        spellhaste->ChangeAmount(amount);
+    }
+    //dmgtaken
+    if (AuraEffect* dmgtaken = me->GetAuraEffect(DAMAGETAKEN_PASSIVE, 0, me->GetGUID()))
+    {
+        int32 amount = 0;
+
+        if (petOwner->GetBotClass() == BOT_CLASS_WARLOCK)
+        {
+            //Demonic Resilience part 2
+            if (level >= 40)
+                amount += 15;
+        }
+        if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+        {
+            //Great Resistance (everything)
+            if (level >= 44)
+                amount += 15;
+        }
+        if (petOwner->GetBotClass() == BOT_CLASS_DREADLORD)
+        {
+            amount += 25;
+        }
+
+        dmgtaken->ChangeAmount(amount);
+    }
+    //hp
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA) - me->GetCreateStat(STAT_STAMINA);
+    switch (petOwner->GetBotClass())
+    {
+        case BOT_CLASS_HUNTER:
+            stamValue += (level >= 80 ? 0.63f : 0.4f) * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_WARLOCK:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DEATH_KNIGHT:
+            switch (myType)
+            {
+                case BOT_PET_GHOUL:
+                    stamValue += 0.88f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+                default:
+                    stamValue += 0.3f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+            }
+            break;
+        case BOT_CLASS_SHAMAN:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_MAGE:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DRUID:
+            stamValue += 0.45f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_ARCHMAGE:
+            stamValue += 2.50f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DREADLORD:
+            stamValue += 2.50f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        case BOT_CLASS_DARK_RANGER:
+            switch (myType)
+            {
+                case BOT_PET_DARK_MINION_ELITE:
+                    stamValue += 1.0f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+                default:
+                    stamValue += 0.8f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+                    break;
+            }
+            break;
+        case BOT_CLASS_NECROMANCER:
+            stamValue += 0.75f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_STAMINA);
+            break;
+        default:
+            break;
+    }
+    float stamMult;
+    switch (myType)
+    {
+        case BOT_PET_IMP:        stamMult = 8.4f;  break;
+        case BOT_PET_VOIDWALKER: stamMult = 11.0f; break;
+        case BOT_PET_SUCCUBUS:   stamMult = 9.1f;  break;
+        case BOT_PET_FELHUNTER:  stamMult = 9.5f;  break;
+        case BOT_PET_FELGUARD:   stamMult = 11.0f; break;
+        default:                 stamMult = 10.f;  break;
+    }
+    //stam bonuses
+    if (petOwner->GetBotClass() == BOT_CLASS_WARLOCK)
+    {
+        //Fel Vitality (pet) part 1
+        if (level >= 15)
+            stamValue *= 1.15f;
+        //Glyph of Voidwalker
+        if (myType == BOT_PET_VOIDWALKER && level >= 15)
+            stamValue *= 1.2f;
+    }
+    if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+    {
+        //Endurance Training
+        if (level >= 10)
+            stamValue *= 1.1f;
+        //Greater Stamina
+        if (level >= 20)
+            stamValue *= 1.12f;
+        //Blood of the Rhino part 1
+        if (level >= 32)
+            stamValue *= 1.04f;
+    }
+    //additional: store stat
+    me->SetStat(STAT_STAMINA, int32(stamValue));
+    float m_totalhp = stamValue * stamMult + me->GetCreateHealth() + (/*IAmFree() ? level * 125.f :*/ 0); //+10000/+0 hp at 80
+    //hp bonuses
+    if (petOwner->GetBotClass() == BOT_CLASS_HUNTER)
+    {
+        //Innate 5%
+        m_totalhp *= 1.05f;
+    }
+    //TC_LOG_ERROR("entities.player", "SetPetStat(): hp stamval %.1f, stammult %.1f, base %u, total %.2f", stamValue, stamMult, botPet->GetCreateHealth(), m_totalhp);
+    bool fullhp = me->GetHealth() == me->GetMaxHealth();
+    float pct = fullhp ? 100.f : me->GetHealthPct(); // needs for regeneration
+    me->SetStatFlatModifier(UNIT_MOD_HEALTH, BASE_VALUE, m_totalhp);
+    me->UpdateMaxHealth();
+    me->SetHealth(fullhp ? me->GetMaxHealth() : uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+    //mana
+    if (me->GetPowerType() == POWER_MANA)
+    {
+        float intValue = me->GetTotalStatValue(STAT_INTELLECT) - me->GetCreateStat(STAT_INTELLECT);
+        intValue += 0.3f * petOwner->GetBotAI()->GetTotalBotStat(BOT_STAT_MOD_INTELLECT);
+        float intMult;
+        switch (myType)
+        {
+            case BOT_PET_IMP:        intMult = 4.95f; break;
+            case BOT_PET_VOIDWALKER:
+            case BOT_PET_SUCCUBUS:
+            case BOT_PET_FELHUNTER:
+            case BOT_PET_FELGUARD:   intMult = 11.5f; break;
+            default:                 intMult = 15.f;  break;
+        }
+        //int/mana bonuses
+        if (petOwner->GetBotClass() == BOT_CLASS_WARLOCK)
+        {
+            //Fel Vitality (pet) part 2
+            if (level >= 15)
+                intValue *= 1.15f;
+        }
+        //additional: store stat
+        me->SetStat(STAT_INTELLECT, int32(intValue));
+        float m_totalmana = intValue * intMult/* + me->GetCreatePowerValue(POWER_MANA)*/ + (IAmFree() ? level * 25.f : 0); //+2000/+0 mana at 80
+        //TC_LOG_ERROR("entities.player", "SetPetStat(): mana intValue %.1f, intMult %.1f, base %u, total %.2f", intValue, intMult, botPet->GetCreatePowerValue(POWER_MANA), m_totalmana);
+        bool fullmana = me->GetPower(POWER_MANA) == me->GetMaxPower(POWER_MANA);
+        pct = fullmana ? 100.f : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+        me->SetStatFlatModifier(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
+        me->UpdateMaxPower(POWER_MANA);
+        me->SetPower(POWER_MANA, fullmana ? me->GetMaxPower(POWER_MANA) :
+            uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        if (me->GetPowerType() == POWER_MANA)
+            me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+        else if (me->GetPowerType() == POWER_FOCUS)
+            me->SetPower(POWER_FOCUS, me->GetMaxPower(POWER_FOCUS));
+    }
+}
+//Force pet to start attack anyone who tries to DAMAGE me or owner
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_pet_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+
+    if (!me->IsValidAttackTarget(attacker) || !attacker->isTargetableForAttack() || IsInBotParty(attacker))
+        return;
+
+    SetBotCommandState(BOT_COMMAND_COMBATRESET);
+    me->Attack(attacker, IsPetMelee());
+}
+
+bool bot_pet_ai::IsPetMelee() const
+{
+    return bot_ai::IsPetMelee(myType);
+}
+
+uint8 bot_pet_ai::Spec() const
+{
+    return petOwner->GetBotAI()->GetSpec();
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_pet_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == petOwner->GetBotOwner() || unit == me || unit == petOwner) return true;
+
+    if (IAmFree())
+    {
+        if (me->GetFaction() == 14 || unit->GetFaction() == 14)
+            return false;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP) ||
+            unit->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            return false;
+
+        return
+            (unit->GetTypeId() == TYPEID_PLAYER || unit->ToCreature()->IsPet() || unit->ToCreature()->IsNPCBot() || unit->ToCreature()->IsNPCBotPet()) &&
+            (unit->GetFaction() == me->GetFaction() ||
+            (me->GetReactionTo(unit) >= REP_FRIENDLY && unit->GetReactionTo(me) >= REP_FRIENDLY));
+    }
+
+    //cheap check
+    if (Group const* gr = petOwner->GetBotOwner()->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (BotMgr::GetHealTargetIconFlags() & GroupIconsFlags[i] &&
+                !((BotMgr::GetOffTankTargetIconFlags() | BotMgr::GetDPSTargetIconFlags()) & GroupIconsFlags[i]))
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])
+                    if (guid == unit->GetGUID())
+                        return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        ObjectGuid ownerGuid = unit->GetOwnerGUID() ? unit->GetOwnerGUID() : unit->GetCreatorGUID();
+        //controlled by master
+        if (ownerGuid == petOwner->GetBotOwner()->GetGUID())
+            return true;
+        //npcbot/npcbot's pet case
+        if (cre->GetBotOwner() == petOwner->GetBotOwner())
+            return true;
+        if (ownerGuid && petOwner->GetBotOwner()->GetBotMgr()->GetBot(ownerGuid))
+            return true;
+        //controlled by group member
+        //pets, minions, guardians etc.
+        //bot pets too
+        if (ownerGuid)
+            if (Group const* gr = petOwner->GetBotOwner()->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/removes/reapplies aura stacks
+void bot_pet_ai::RefreshAura(uint32 spellId, int8 count, Unit* target) const
+{
+    if (count < 0 || count > 10)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::RefreshAura(): count is out of bounds (%i) for bot %s (botclass: %u, entry: %u)",
+            int32(count), me->GetName().c_str(), uint32(petOwner->GetBotClass()), me->GetEntry());
+        return;
+    }
+    if (!spellId)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::RefreshAura(): spellId is 0 for bot %s (botclass: %u, entry: %u)",
+            me->GetName().c_str(), uint32(petOwner->GetBotClass()), me->GetEntry());
+        return;
+    }
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), uint32(petOwner->GetBotClass()), me->GetEntry());
+        return;
+    }
+
+    if (!target)
+        target = me;
+
+    target->RemoveAurasDueToSpell(spellId);
+
+    for (int8 i = 0; i < count; ++i)
+        target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//All code above 'x = _getTarget() call must not dereference opponent since it can be invalid
+Unit* bot_pet_ai::_getTarget(bool &reset) const
+{
+    if (petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return nullptr;
+    if (petOwner->GetBotAI()->GetEngageTimer() > lastdiff)
+        return nullptr;
+
+    Unit* mytar = me->GetVictim();
+    Unit* u = petOwner->GetVictim();
+
+    if (mytar && me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+        return mytar;
+
+    if (u)
+    {
+        if (opponent && u != opponent)
+            reset = true;
+        return u;
+    }
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : petOwner->GetBotOwner()->GetBotMgr()->GetBotFollowDist();
+
+    if (followdist == 0)
+        return nullptr;
+
+    float foldist = _getAttackDistance(float(followdist));
+    if (!IAmFree() && !IsPetMelee())
+    {
+        float spelldist;
+        uint8 rangeMode = petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode();
+        if (rangeMode == BOT_ATTACK_RANGE_EXACT)
+            spelldist = petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange();
+        else
+            spelldist = GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG);
+        foldist = std::max<float>(foldist, spelldist + 4.f);
+    }
+    bool dropTarget = false;
+    if (!dropTarget && mytar)
+    {
+        dropTarget = IAmFree() ?
+            petOwner->GetDistance(mytar) > foldist :
+            (petOwner->GetBotOwner()->GetDistance(mytar) > foldist || (petOwner->GetBotOwner()->GetDistance(mytar) > foldist * 0.75f && !mytar->IsWithinLOSInMap(petOwner)));
+    }
+    if (dropTarget)
+        return nullptr;
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && me->IsValidAttackTarget(mytar) && !petOwner->GetBotAI()->IsPointedNoDPSTarget(mytar))
+    {
+        if (me->GetDistance(mytar) > (!IsPetMelee() ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    return nullptr;
+}
+//'CanAttack' function
+//Only called in class ai UpdateAI function
+bool bot_pet_ai::CheckAttackTarget()
+{
+    bool reset = false;
+    opponent = _getTarget(reset);
+
+    if (!opponent)
+    {
+        if (me->GetVictim() || me->IsInCombat())
+        {
+            if (me->GetVictim())
+                me->AttackStop();
+        }
+
+        return false;
+    }
+
+    if (reset)
+        SetBotCommandState(BOT_COMMAND_COMBATRESET);//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, IsPetMelee());
+
+    return true;
+}
+//POSITION
+//Ranged attack position
+void bot_pet_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : petOwner->GetBotOwner()->GetBotMgr()->GetBotFollowDist();
+    uint8 rangeMode = IAmFree() ? uint8(BOT_ATTACK_RANGE_LONG) : petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode();
+    uint8 exactRange = rangeMode != BOT_ATTACK_RANGE_EXACT || IAmFree() ? 255 : petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange();
+    Position ppos;
+    float //x(0),y(0),z(0),
+        dist = (rangeMode == BOT_ATTACK_RANGE_EXACT) ? exactRange :
+        followdist >= 40 ? followdist :
+        5 + urand(followdist/3, followdist/3 + 5)/*18-23 at 40, 15-20 at 30*/,
+        angle = target->GetAbsoluteAngle(me);
+    //most ranged classes have some sort of 20yd spell
+    if (rangeMode != BOT_ATTACK_RANGE_EXACT)
+        dist = std::min<float>(dist, petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS) ? GetSpellAttackRange(rangeMode == BOT_ATTACK_RANGE_LONG) - 4.f : 30.f);
+
+    float clockwise = (me->GetEntry() % 2) ? 1.f : -1.f;
+    float angleDelta = frand(0.0f, float(M_PI)*0.10f) * clockwise;
+
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        ppos = target->GetFirstCollisionPosition(dist, angle - target->GetOrientation());
+        //target->GetNearPoint(me, x, y, z, dist, angle);
+        if (!target->IsWithinLOS(/*x,y,z*/ppos.m_positionX, ppos.m_positionY, ppos.m_positionZ))
+        {
+            if (rangeMode != BOT_ATTACK_RANGE_EXACT)
+                dist *= i >= 4 ? 0.1f : 0.33f;
+            if (i >= 4)
+                angle += angleDelta;
+        }
+    }
+
+    pos.Relocate(ppos);
+    //pos.m_positionX = x;
+    //pos.m_positionY = y;
+    //pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_pet_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (petOwner->GetBotAI()->HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+    if (CCed(me, true) || JumpingOrFalling())
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || me->isMoving()) && !force)
+        return;
+    if (IsCasting())
+        return;
+
+    if (!IAmFree() && petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+        petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange() == 0)
+    {
+        attackpos.m_positionX = newtarget->GetPositionX() - frand(0.5f, 1.5f) * std::cos(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionY = newtarget->GetPositionY() - frand(0.5f, 1.5f) * std::sin(me->GetAbsoluteAngle(newtarget));
+        attackpos.m_positionZ = newtarget->GetPositionZ();
+        if (me->GetExactDist2d(&attackpos) > 3.5f)
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+        return;
+    }
+
+    uint8 followdist = IAmFree() ? BotMgr::GetBotFollowDistDefault() : petOwner->GetBotOwner()->GetBotMgr()->GetBotFollowDist();
+    if (!IsPetMelee())
+    {
+        //do not allow constant runaway from player
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3))
+            return;
+
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetExactDist2d(&attackpos) > 4.f || !me->IsWithinLOSInMap(newtarget))
+        {
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+            if (!me->HasUnitState(UNIT_STATE_MELEE_ATTACKING))
+                me->SetInFront(newtarget);
+        }
+    }
+    else if (!JumpingOrFalling() && ((!me->HasUnitState(UNIT_STATE_CHASE) && !me->isMoving()) || (!me->HasUnitState(UNIT_STATE_CHASE_MOVE) && me->GetDistance(newtarget) > 1.5f)))
+    {
+        //me->BotStopMovement();
+        me->GetMotionMaster()->MoveChase(newtarget);
+    }
+
+    if (newtarget != me->GetVictim())
+    {
+        if (!me->Attack(newtarget, IsPetMelee()))
+            me->SetInFront(newtarget);
+    }
+}
+
+void bot_pet_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        MoveBehind(me->GetVictim());
+
+        if (petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS) &&
+            !me->HasAuraType(SPELL_AURA_MOD_STEALTH) && !me->HasAuraType(SPELL_AURA_MOD_INVISIBILITY))
+        {
+            //if (!CCed(me->GetVictim()) || me->HasAuraType(SPELL_AURA_MOD_TAUNT))
+                DoMeleeAttackIfReady();
+        }
+    }
+}
+
+void bot_pet_ai::MoveBehind(Unit const* target) const
+{
+    if (HasBotCommandState(BOT_COMMAND_MASK_UNMOVING)) return;
+    if (!IsPetMelee() || CCed(me, true)) return;
+    if (JumpingOrFalling()) return;
+
+    if (target->GetVictim() != me && !CCed(target) &&
+        target->IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target->HasInArc(float(M_PI), me))
+    {
+        float x,y,z;
+        target->GetNearPoint(me, x, y, z, me->GetCombatReach(), me->GetAbsoluteAngle(target));
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+        waitTimer = 500;
+    }
+}
+bool bot_pet_ai::_canRegenerate() const
+{
+    switch (me->GetEntry())
+    {
+        case BOT_PET_DARK_MINION:
+        case BOT_PET_DARK_MINION_ELITE:
+        case BOT_PET_NECROSKELETON:
+        case BOT_PET_TORNADO:
+            return false;
+        default:
+            return true;
+    }
+}
+//Health and Powers regeneration
+void bot_pet_ai::Regenerate()
+{
+    regenTimer += lastdiff;
+
+    //every tick
+    if (me->GetPowerType() == POWER_FOCUS)
+        RegeneratePetFocus();
+    else if (me->GetPowerType() == POWER_ENERGY)
+        RegeneratePetEnergy();
+
+    if (regenTimer >= REGEN_CD)
+    {
+        regenTimer -= REGEN_CD;
+
+        // Regen Pet Health
+        if (_canRegenerate() && (!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+        {
+            int32 add = IAmFree() && !me->GetVictim() ? me->GetMaxHealth() / 32 : 20 + me->GetCreateHealth() / 64;
+
+            if (me->IsPolymorphed())
+                add += me->GetMaxHealth() / 6;
+            else if (!me->IsInCombat() || me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+            {
+                if (!me->IsInCombat())
+                {
+                    Unit::AuraEffectList const& mModHealthRegenPct = me->GetAuraEffectsByType(SPELL_AURA_MOD_HEALTH_REGEN_PERCENT);
+                    for (Unit::AuraEffectList::const_iterator i = mModHealthRegenPct.begin(); i != mModHealthRegenPct.end(); ++i)
+                        AddPct(add, (*i)->GetAmount());
+
+                    add += me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN) * REGEN_CD / 5000;
+                }
+                else if (me->HasAuraType(SPELL_AURA_MOD_REGEN_DURING_COMBAT))
+                    ApplyPct(add, me->GetTotalAuraModifier(SPELL_AURA_MOD_REGEN_DURING_COMBAT));
+            }
+
+            add += me->GetTotalAuraModifier(SPELL_AURA_MOD_HEALTH_REGEN_IN_COMBAT);
+
+            if (add < 0)
+                add = 0;
+
+            me->ModifyHealth(add);
+        }
+        // Regen Pet Mana (use bot's regen rate) warlock only
+        if (me->GetPowerType() == POWER_MANA && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+        {
+            float addvalue;
+            if (me->IsUnderLastManaUseEffect())
+                addvalue = petOwner->GetFloatValue(UNIT_FIELD_POWER_REGEN_INTERRUPTED_FLAT_MODIFIER);
+            else
+                addvalue = petOwner->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+
+            addvalue *= sWorld->getRate(RATE_POWER_MANA) * REGEN_CD * 0.001f; //regenTimer threshold / 1000
+            if (addvalue < 0.0f)
+                addvalue = 0.0f;
+
+            me->ModifyPower(POWER_MANA, int32(addvalue));
+        }
+    }
+}
+
+void bot_pet_ai::RegeneratePetFocus()
+{
+    uint32 curValue = me->GetPower(POWER_FOCUS);
+    uint32 maxValue = me->GetMaxPower(POWER_FOCUS);
+
+    // Regen Pet Focus
+    if (curValue < maxValue)
+    {
+        float addvalue = 0.005f * lastdiff * sWorld->getRate(RATE_POWER_FOCUS); //5 per sec
+
+        //Bestial Discipline
+        if (petOwner->GetLevel() >= 30)
+            addvalue *= 2;
+
+        addvalue += _energyFraction;
+
+        if (addvalue == 0x0) //only if world rate for focus is 0
+            return;
+
+        uint32 integerValue = uint32(fabs(addvalue));
+
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            _energyFraction = 0.f;
+        }
+        else
+            _energyFraction = addvalue - float(integerValue);
+
+        if (curValue == maxValue || regenTimer >= REGEN_CD)
+            me->SetPower(POWER_FOCUS, curValue);
+        else
+            me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_FOCUS, curValue);
+    }
+}
+
+void bot_pet_ai::RegeneratePetEnergy()
+{
+    uint32 curValue = me->GetPower(POWER_ENERGY);
+    uint32 maxValue = me->GetMaxPower(POWER_ENERGY);
+
+    if (curValue < maxValue)
+    {
+        float addvalue = 0.01f * lastdiff * sWorld->getRate(RATE_POWER_ENERGY); //10 per sec
+
+        if (addvalue == 0x0) //only if world rate for enegy is 0
+            return;
+
+        addvalue += _energyFraction;
+
+        uint32 integerValue = uint32(fabs(addvalue));
+
+        curValue += integerValue;
+
+        if (curValue > maxValue)
+        {
+            curValue = maxValue;
+            _energyFraction = 0.f;
+        }
+        else
+            _energyFraction = addvalue - float(integerValue);
+
+        if (curValue == maxValue || regenTimer >= REGEN_CD)
+            me->SetPower(POWER_ENERGY, curValue);
+        else
+            me->UpdateUInt32Value(UNIT_FIELD_POWER1 + POWER_ENERGY, curValue);
+    }
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spellId of max rank allowed for given caster
+//If you want bot to use this spell through doCast() go InitSpellMap(uint32) instead
+uint32 bot_pet_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->GetLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, puts spell of max rank allowed for given caster in spellmap
+void bot_pet_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "bot_pet_ai::InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->GetLevel();
+    uint32 spellId = forceadd ? basespell : 0;
+
+    while (info != nullptr && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotPetSpell* newSpell = _spells[basespell];
+    if (!newSpell)
+    {
+        newSpell = new BotPetSpell();
+        _spells[basespell] = newSpell;
+    }
+
+    newSpell->spellId = spellId;
+}
+//Using first-rank spell as source, return current spell id
+uint32 bot_pet_ai::GetSpell(uint32 basespell) const
+{
+    BotPetSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() && (itr->second->enabled == true || IAmFree()) ? itr->second->spellId : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_pet_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotPetSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr != _spells.end() ? itr->second->cooldown : 0;
+}
+bool bot_pet_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD) const
+{
+    if (checkGCD && GC_Timer > diff)
+        return false;
+
+    BotPetSpellMap::const_iterator itr = _spells.find(basespell);
+    return itr == _spells.end() ? true :
+        ((itr->second->enabled == true || IAmFree()) && itr->second->spellId != 0 && itr->second->cooldown <= diff);
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_pet_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotPetSpellMap::iterator itr = _spells.find(basespell);
+    if (itr != _spells.end())
+    {
+        itr->second->cooldown = msCooldown;
+        return;
+    }
+    else if (!msCooldown)
+        return;
+
+    InitSpellMap(basespell, true, false);
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_pet_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotPetSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->first == spellInfo->Id && itr->second->cooldown >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (info && itr->first == spellInfo->Id && info->GetCategory() != category)
+        {
+            if (itr->first != 7814) // Lash of Pain
+            {
+                TC_LOG_ERROR("scripts", "Warning: SetSpellCategoryCooldown: %u has baseId %u but category %u, not %u!",
+                    info->Id, itr->first, info->GetCategory(), category);
+            }
+        }
+
+        if (info && (info->GetCategory() == category || itr->first == spellInfo->Id) && itr->second->cooldown < msCooldown)
+            itr->second->cooldown = msCooldown;
+    }
+}
+//Handles spell cooldowns for spell with IsCooldownStartedOnEvent() == true
+void bot_pet_ai::ReleaseSpellCooldown(uint32 basespell)
+{
+    SpellInfo const* baseInfo = sSpellMgr->GetSpellInfo(basespell);
+
+    if (!baseInfo->IsCooldownStartedOnEvent())
+    {
+        TC_LOG_ERROR("spells", "bot_pet_ai::ReleaseSpellCooldown is called for wrong spell %u!", basespell);
+        return;
+    }
+
+    uint32 rec = baseInfo->RecoveryTime;
+    uint32 catrec = baseInfo->CategoryRecoveryTime;
+
+    SetSpellCooldown(baseInfo->Id, rec > 0 ? rec : 0);
+    SetSpellCategoryCooldown(baseInfo, catrec > 0 && !(baseInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS) ? catrec : 0);
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_pet_ai::RemoveSpell(uint32 basespell)
+{
+    BotPetSpell* newSpell;
+    BotPetSpellMap::iterator itr = _spells.find(basespell);
+    if (itr == _spells.end())
+    {
+        newSpell = new BotPetSpell();
+        _spells[basespell] = newSpell;
+    }
+    else
+        newSpell = itr->second;
+
+    newSpell->spellId = 0;
+    newSpell->cooldown = 0;
+}
+//See CommonTimers(uint32)
+void bot_pet_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotPetSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        if (itr->second->cooldown >= diff)
+            itr->second->cooldown -= diff;
+        else if (itr->second->cooldown > 0)
+            itr->second->cooldown = 0;
+    }
+}
+//Bots cannot dodge/parry from behind so try to condense enemies at front
+//opponent is always valid
+void bot_pet_ai::AdjustTankingPosition() const
+{
+    if (/*!IsTank() || */!me->IsInCombat() || IsCasting() ||
+        JumpingOrFalling() || CCed(me, true) || Rand() > 10 + 20*me->GetMap()->IsDungeon() ||
+        HasBotCommandState(BOT_COMMAND_MASK_UNMOVING))
+        return;
+
+    Unit::AttackerSet const& myattackers = me->getAttackers();
+    if (myattackers.size() < 2)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition() by %s", me->GetName().c_str());
+
+    uint32 bCount = 0;
+    for (Unit::AttackerSet::const_iterator itr = myattackers.begin(); itr != myattackers.end(); ++itr)
+    {
+        if (/*!CCed(*itr) && */(*itr)->GetDistance(me) < 5 && !me->HasInArc(float(M_PI), *itr))
+            ++bCount;
+            //if (++bCount)
+            //    break;
+    }
+
+    if (bCount == 0)
+        return;
+
+    //TC_LOG_ERROR("entities.player", "AdjustTankingPosition(): atts %u, behind %u", uint32(myattackers.size()), bCount);
+
+    //calculate new position
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float ori = me->GetOrientation();
+    float const moveDist = -1.f * std::max<float>(opponent->GetCombatReach() * 0.6f, 3.f);
+    float moveX = 0.f;
+    float moveY = 0.f;
+    for (uint8 i = 0; i != 3; ++i)
+    {
+        if (i)
+        {
+            ori = Position::NormalizeOrientation(ori + (i+1)*(M_PI*0.5f));
+        }
+
+        //move back
+        moveX = moveDist * std::cos(ori);
+        moveY = moveDist * std::sin(ori);
+
+        if (me->IsWithinLOS(x+moveX, y+moveY, z))
+            break;
+
+        if (i == 2)
+        {
+            moveX *= 0.2f;
+            moveY *= 0.2f;
+        }
+    }
+
+    x += moveX;
+    y += moveY;
+
+    me->UpdateAllowedPositionZ(x, y, z);
+    if (me->GetPositionZ() < z)
+        z += 0.75f; //prevent going underground
+
+    //if (CCed(opponent, true))
+    //    me->AttackStop();
+    //me->SetOrientation(ori);
+    me->GetMotionMaster()->MovePoint(me->GetMapId(), x, y, z);
+}
+//SpellHit()... OnSpellHit()
+void bot_pet_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    //uint32 const spellId = spell->Id;
+
+    if (spell->HasAura(SPELL_AURA_MOD_TAUNT) || spell->HasEffect(SPELL_EFFECT_ATTACK_ME))
+        if (caster && me->Attack(caster, true))
+            me->GetMotionMaster()->MoveChase(caster);
+
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 const auraname = spell->_effects[i].ApplyAuraName;
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_SPELL_DAMAGE_OF_STAT_PERCENT ||
+            auraname == SPELL_AURA_MOD_RATING || auraname == SPELL_AURA_MOD_RATING_FROM_STAT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+            auraname == SPELL_AURA_230 ||
+            auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+            shouldUpdateStats = true;
+        else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY || auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+            shouldUpdateStats = true;
+    }
+
+    if (!me->GetVictim() && (me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        if (me->CanSeeOrDetect(caster) && (caster->IsInCombat() || me->IsInCombat() || petOwner->IsInCombat()))
+            petOwner->GetBotAI()->OwnerAttackedBy(caster);
+    }
+}
+//Update delay
+//Skip UpdateAI cycles for randomization of bots' reaction and performance adjustments
+bool bot_pet_ai::Wait()
+{
+    if (waitTimer > lastdiff)
+        return true;
+
+    if (IAmFree())
+        waitTimer = me->IsInCombat() ? 500 : urand(750, 1250);
+    else if (!me->GetMap()->IsRaid())
+        waitTimer = std::min<uint32>(uint32(50 * (petOwner->GetBotOwner()->GetNpcBotsCount() - 1) + __rand + __rand), 500);
+    else
+        waitTimer = __rand;
+
+    return false;
+}
+//Spell Mod Hooks
+void bot_pet_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    //DAMAGE SPELLS damage bonus (DMG_CLASS_MAGIC)
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+//Spell Mod Utilities
+float bot_pet_ai::CalcSpellMaxRange(uint32 spellId, bool enemy) const
+{
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    ASSERT(spellInfo);
+
+    return spellInfo->GetMaxRange(!enemy);
+}
+bool bot_pet_ai::IAmFree() const
+{
+    return petOwner->IsFreeBot();
+}
+
+bool bot_pet_ai::CCed(Unit const* target, bool root)
+{
+    return bot_ai::CCed(target, root);
+}
+
+bool bot_pet_ai::IsTank(Unit const* unit) const
+{
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+    else if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINTANK;
+            }
+        }
+    }
+
+    return false;
+}
+//Unused
+bool bot_pet_ai::IsOffTank(Unit const* unit) const
+{
+    if (Creature const* bot = unit->ToCreature())
+        return bot->GetBotAI() && bot->GetBotAI()->HasRole(BOT_ROLE_TANK_OFF);
+    else if (Player const* player = unit->ToPlayer())
+    {
+        if (Group const* gr = player->GetGroup())
+        {
+            if (gr->isRaidGroup())
+            {
+                Group::MemberSlotList const& slots = gr->GetMemberSlots();
+                for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                    if (itr->guid == unit->GetGUID())
+                        return itr->flags & MEMBER_FLAG_MAINASSIST;
+            }
+        }
+    }
+
+    return false;
+}
+
+void bot_pet_ai::OnStartAttack(Unit const* /*u*/)
+{
+    AdjustTankingPosition();
+}
+
+bool bot_pet_ai::StartAttack(Unit const* u, bool force)
+{
+    if (HasBotCommandState(BOT_COMMAND_ATTACK) && !force)
+        return false;
+
+    SetBotCommandState(BOT_COMMAND_ATTACK);
+    OnStartAttack(u);
+    return true;
+}
+
+void bot_pet_ai::JustDied(Unit*)
+{
+    KillEvents(false);
+}
+
+void bot_pet_ai::AttackStart(Unit* /*u*/)
+{
+}
+
+void bot_pet_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+    {
+        if (Creature* cre = victim->ToCreature())
+        {
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(petOwner->GetBotOwner());
+
+            //controlled case is handled in Unit::DealDamage
+            if (IAmFree())
+                cre->LowerPlayerDamageReq(cre->GetHealth() < damage ?  cre->GetHealth() : damage);
+        }
+    }
+}
+
+void bot_pet_ai::IsSummonedBy(WorldObject* summoner)
+{
+    //TC_LOG_ERROR("entities.unit", "bot_pet_ai::IsSummonedBy for %s by %s", me->GetName().c_str(), summoner->GetName().c_str());
+    //ASSERT(!petOwner);
+    //ASSERT(summoner->GetTypeId() == TYPEID_UNIT);
+    petOwner = summoner->ToCreature();
+    m_botCommandState = petOwner->GetBotAI()->GetBotCommandState();
+    myType = me->GetEntry();
+    //myType = petOwner->GetBotAI()->GetAIMiscValue(BOTAI_MISC_PET_TYPE);
+    //ASSERT(myType);
+    ASSERT(!me->GetBotAI());
+    ASSERT(!me->GetBotPetAI());
+    me->SetBotPetAI(this);
+    SetPetStats(true);
+    if (petOwner->GetTransport())
+    {
+        petOwner->GetTransport()->AddPassenger(me);
+        me->m_movementInfo.transport.pos.Relocate(petOwner->GetTransOffset());
+        me->Relocate(bot_ai::GetAbsoluteTransportPosition(petOwner));
+        me->AddUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+    }
+}
+//This function is called after Spell::SendSpellCooldown() and Spell::DoAllEffects...() call
+void bot_pet_ai::OnBotPetSpellGo(Spell const* spell, bool ok)
+{
+    if (!ok)
+        return;
+
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+
+    //Set cooldown
+    if (!curInfo->IsCooldownStartedOnEvent() && !curInfo->IsPassive())
+    {
+        uint32 rec = curInfo->RecoveryTime;
+        uint32 catrec = curInfo->CategoryRecoveryTime;
+
+        SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+        SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+    }
+
+    if ((!curInfo->CastTimeEntry || !curInfo->CastTimeEntry->Base) &&
+        curInfo->StartRecoveryTime)
+    {
+        GC_Timer = curInfo->StartRecoveryTime;
+        GC_Timer = std::max<uint32>(GC_Timer, 1000);
+        GC_Timer = std::min<uint32>(GC_Timer, 1500);
+    }
+
+    OnPetClassSpellGo(curInfo);
+}
+
+void bot_pet_ai::OnBotPetSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotPetSpellMap::iterator itr = _spells.begin(); itr != _spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second->spellId);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        itr->second->cooldown += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotPetSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+
+    GC_Timer = 0; //reset global cooldown since cast is canceled
+}
+//GLOBAL UPDATE
+//opponent unsafe
+bool bot_pet_ai::GlobalUpdate(uint32 diff)
+{
+    if (!petOwner)
+    {
+        TC_LOG_ERROR("entities.unit", "botpet:GlobalUpdate(): no owner!");
+        return false;
+    }
+
+    ReduceCD(diff);
+
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+        if (!IAmFree())
+        {
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != petOwner->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, petOwner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    //Check current cast state: interrupt casts that became pointless
+    if (me->HasUnitState(UNIT_STATE_CASTING) && urand(1,100) <= 75)
+    {
+        bool interrupt;
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+        {
+            interrupt = false;
+            Spell const* spell = me->GetCurrentSpell(CurrentSpellTypes(i));
+            if (!spell)
+                continue;
+            Unit const* target = spell->m_targets.GetUnitTarget();
+            if (!target)
+                continue;
+            SpellInfo const* info = spell->GetSpellInfo();
+            if (!info->CastTimeEntry)
+                continue;
+            if (!info->IsPositive())
+            {
+                if (!target->IsAlive())
+                    interrupt = true;
+                //control interruptions should be checked inside pet class ai
+                //else if ((info->Mechanic == MECHANIC_POLYMORPH || info->Mechanic == MECHANIC_SHACKLE ||
+                //    info->Mechanic == MECHANIC_DISORIENTED || info->Mechanic == MECHANIC_SLEEP ||
+                //    info->Mechanic == MECHANIC_CHARM || info->Mechanic == MECHANIC_BANISH ||
+                //    info->Mechanic == MECHANIC_STUN || info->Mechanic == MECHANIC_FREEZE) &&
+                //    !target->getAttackers().empty() && !IsCasting(target))
+                //    interrupt = true; //useless control
+                else if (target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && !IsCasting(target) &&
+                    (info->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+                    interrupt = true; //useless control breaks immediately
+            }
+
+            if (interrupt)
+            {
+                me->InterruptSpell(CurrentSpellTypes(i));
+                GC_Timer = 0;
+                break;
+            }
+        }
+    }
+
+    if (_updateTimerEx1 <= diff && !IAmFree())
+    {
+        _updateTimerEx1 = urand(2000, 2500);
+
+        //Ex1-timed updates
+
+        //DEBUG
+        /*
+        Sometimes bots are affected by zone (instance) scripts
+        Good example is CoT: Battle for Mount Hyjal
+        */
+        //Faction
+        //ensure master is not controlled
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(petOwner->GetBotOwner()->GetRace());
+        uint32 fac = rEntry ? rEntry->FactionID : 0;
+        if (me->GetFaction() != petOwner->GetBotOwner()->GetFaction() && petOwner->GetBotOwner()->GetFaction() == fac)
+        {
+            //std::ostringstream msg;
+            //msg << "Something changed my faction (now " << me->GetFaction() << "), changing back to " << fac << "!";
+            //BotWhisper(msg.str().c_str());
+            me->SetFaction(fac);
+        }
+        //Visibility
+        if (!me->IsVisible() && petOwner->GetBotOwner()->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making visible...");
+            me->SetVisible(true);
+        }
+        if (me->IsVisible() && !petOwner->GetBotOwner()->IsVisible())
+        {
+            //BotWhisper("Something changed my visibility status! Making invisible...");
+            me->SetVisible(false);
+        }
+        //Phase
+        if (me->GetPhaseMask() != petOwner->GetBotOwner()->GetPhaseMask())
+        {
+            //BotWhisper("Somehow we are not is same phase! Fixing that...");
+            me->SetPhaseMask(petOwner->GetBotOwner()->GetPhaseMask(), true);
+        }
+        if (me->GetTransport() != petOwner->GetBotOwner()->GetTransport())
+        {
+            if (petOwner->GetBotOwner()->GetTransport())
+            {
+                if (me->GetDistance2d(petOwner->GetBotOwner()) < 20.f)
+                {
+                    petOwner->GetBotOwner()->GetTransport()->AddPassenger(me);
+                    me->m_movementInfo.transport.pos.Relocate(petOwner->GetBotOwner()->GetTransOffset());
+                    me->Relocate(bot_ai::GetAbsoluteTransportPosition(petOwner->GetBotOwner()));
+                    me->AddUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+                }
+            }
+            else
+            {
+                switch (me->GetEntry())
+                {
+                    case BOT_PET_TORNADO:
+                        break;
+                    default:
+                        me->ClearUnitState(UNIT_STATE_IGNORE_PATHFINDING);
+                    break;
+                }
+                me->GetTransport()->RemovePassenger(me);
+            }
+        }
+        //end DEBUG
+    }
+
+    Regenerate();
+
+    //update flags
+    if (!me->IsInCombat())
+    {
+        if (me->HasUnitFlag(UNIT_FLAG_PET_IN_COMBAT))
+            me->RemoveUnitFlag(UNIT_FLAG_PET_IN_COMBAT);
+    }
+
+    //update movement orders if near owner, otherwise get close
+    bool closeToOwner = false;
+    if (!opponent && !IsCasting())
+    {
+        _calculatePos(movepos);
+        if (!petOwner->isMoving())
+        {
+            if (me->GetExactDist(&movepos) > 5.f)
+                SetBotCommandState(BOT_COMMAND_FOLLOW, true, &movepos);
+            else
+                closeToOwner = !me->isMoving();
+        }
+        else
+        {
+            Position destPos;
+            me->GetMotionMaster()->GetDestination(destPos.m_positionX, destPos.m_positionY, destPos.m_positionZ);
+            if (destPos.GetExactDist(&movepos) > 5.f)
+                SetBotCommandState(BOT_COMMAND_FOLLOW, true, &movepos);
+            else
+                closeToOwner = !me->isMoving();
+        }
+    }
+    if (closeToOwner || me->IsInCombat())
+    {
+        uint8 st = (petOwner->GetBotAI()->GetBotCommandState() & BOT_COMMAND_MASK_UNMOVING);
+        if (st && GetBotCommandState() != st)
+        {
+            SetBotCommandState(st);
+            return !(st & BOT_COMMAND_FULLSTOP);
+        }
+    }
+
+    if (HasBotCommandState(BOT_COMMAND_FULLSTOP))
+        return false;
+
+    CheckAttackState();
+
+    if (checkAurasTimer <= lastdiff)
+    {
+        Unit* victim = me->GetVictim();
+        checkAurasTimer += uint32(__rand + __rand + (IAmFree() ? 1000 : 40 * (1 + petOwner->GetBotOwner()->GetNpcBotsCount())));
+
+        if (!HasBotCommandState(BOT_COMMAND_MASK_UNCHASE) && victim && !CCed(me, true) &&
+            !me->isMoving() && !IsCasting() && me->GetEntry() != BOT_PET_TORNADO)
+        {
+            if (!IAmFree() && petOwner->GetBotOwner()->GetBotMgr()->GetBotAttackRangeMode() == BOT_ATTACK_RANGE_EXACT &&
+                petOwner->GetBotOwner()->GetBotMgr()->GetBotExactAttackRange() == 0)
+            {
+                GetInPosition(true, victim);
+            }
+            else if (IsPetMelee())
+            {
+                if (me->GetDistance(victim) > 1.5f)
+                    GetInPosition(true, victim);
+            }
+            else
+            {
+                CalculateAttackPos(victim, attackpos);
+                if (me->GetExactDist2d(&attackpos) > 4.f || !me->IsWithinLOSInMap(victim))
+                    GetInPosition(true, victim, &attackpos);
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == petOwner->GetBotOwner()->GetPhaseMask())
+            SetPetStats(false);
+    }
+
+    if (Wait())
+        return false;
+
+    if (CCed(me))
+        return false;
+
+    GenerateRand();
+
+    return true;
+}
+
+void bot_pet_ai::CommonTimers(uint32 diff)
+{
+    //_petEvents.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (checkAurasTimer > diff)     checkAurasTimer -= diff;
+    if (waitTimer > diff)           waitTimer -= diff;
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+    if (_updateTimerEx1 > diff)     _updateTimerEx1 -= diff;
+}
+
+void bot_pet_ai::KillEvents(bool /*force*/)
+{
+    //_petEvents.KillAllEvents(force);
+}
+
+bool bot_pet_ai::IsChanneling(Unit const* u/* = nullptr*/) const
+{
+    if (!u)
+        u = me;
+    return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+}
+bool bot_pet_ai::IsCasting(Unit const* u/* = nullptr*/) const
+{
+    if (!u)
+        u = me;
+    return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true, false, false));
+}
+bool bot_pet_ai::JumpingFlyingOrFalling() const
+{
+    return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW);
+}
+bool bot_pet_ai::JumpingOrFalling() const
+{
+    return Jumping() || me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_FALLING_SLOW);
+}
+bool bot_pet_ai::Jumping() const
+{
+    return me->HasUnitState(UNIT_STATE_JUMPING);
+}
+
+uint32 bot_pet_ai::GetLostHP(Unit const* unit)
+{
+    return unit->GetMaxHealth() - unit->GetHealth();
+}
+uint8 bot_pet_ai::GetHealthPCT(Unit const* u)
+{
+    if (!u || !u->IsAlive() || u->GetMaxHealth() <= 1)
+        return 100;
+    return uint8(((float(u->GetHealth()))/u->GetMaxHealth()) * 100);
+}
+uint8 bot_pet_ai::GetManaPCT(Unit const* u)
+{
+    if (!u || !u->IsAlive() || u->GetMaxPower(POWER_MANA) <= 1)
+        return 100;
+    return (u->GetPower(POWER_MANA)*10/(1 + u->GetMaxPower(POWER_MANA)/10));
+}
diff --git a/src/server/game/AI/NpcBots/bpet_ai.h b/src/server/game/AI/NpcBots/bpet_ai.h
new file mode 100644
index 000000000..0f6a68d48
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_ai.h
@@ -0,0 +1,176 @@
+#ifndef _BOT_PET_AI_H
+#define _BOT_PET_AI_H
+
+#include "CreatureAI.h"
+#include "Position.h"
+
+/*
+NpcBot Pet System by Trickerer (onlysuffering@gmail.com)
+*/
+
+struct SpellNonMeleeDamage;
+
+class Aura;
+class Spell;
+class Unit;
+
+class bot_pet_ai : public CreatureAI
+{
+    public:
+        virtual ~bot_pet_ai();
+
+        bool canUpdate;
+
+        void InitializeAI() override { Reset(); }
+        void Reset() override {}
+
+        void JustDied(Unit*) override;
+        //virtual void KilledUnit(Unit* u);
+        void AttackStart(Unit* u) override;
+        //virtual void JustEnteredCombat(Unit* u) override;
+        void MoveInLineOfSight(Unit* /*u*/) override {}
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override;
+        void DamageTaken(Unit* /*attacker*/, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override { }
+        //void ReceiveEmote(Player* player, uint32 emote);
+        uint32 GetData(uint32 data) const override;
+        void IsSummonedBy(WorldObject* summoner) override;
+
+        Creature* GetPetsOwner() const { return petOwner; }
+
+        //EventProcessor* GetEvents() { return &_petEvents; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        void CommonTimers(uint32 diff);
+        void KillEvents(bool force);
+        void SetBotCommandState(uint8 st, bool force = false, Position* newpos = nullptr);
+        void RemoveBotCommandState(uint8 st);
+        bool HasBotCommandState(uint8 st) const { return (m_botCommandState & st); }
+        uint8 GetBotCommandState() const { return m_botCommandState; }
+        bool IsInBotParty(Unit const* unit) const;
+        virtual void ApplyBotPetSpellRadiusMods(SpellInfo const* /*spellInfo*/, float& /*radius*/) const {}
+        bool IsTank(Unit const* unit) const;
+        bool IsOffTank(Unit const* unit) const;
+        bool IAmFree() const;
+
+        static bool CCed(Unit const* target, bool root = false);
+
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+
+        //virtual uint32 GetAIMiscValue(uint32 /*data*/) const { return 0; }
+        //virtual void SetAIMiscValue(uint32 /*data*/, uint32 /*value*/) {}
+
+        void OnBotPetSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        void OnBotPetSpellGo(Spell const* spell, bool ok = true);
+        virtual void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) {}
+
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+        void ReleaseSpellCooldown(uint32 basespell);
+
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+
+    protected:
+        explicit bot_pet_ai(Creature* creature);
+
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool /*crit*/) const {}
+
+        virtual void ReduceCD(uint32 /*diff*/) {}
+        bool GlobalUpdate(uint32 diff);
+
+        void CureGroup(uint32 cureSpell, uint32 diff);
+        void SetPetStats(bool force);
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        bool IsPetMelee() const;
+        uint8 Spec() const;
+
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+
+        void RefreshAura(uint32 spellId, int8 count = 1, Unit* target = nullptr) const;
+        bool CheckAttackTarget();
+        void MoveBehind(Unit const* target) const;
+
+        void AdjustTankingPosition() const;
+        void OnStartAttack(Unit const* /*u*/);
+        bool StartAttack(Unit const* u, bool force = false);
+
+        bool IsChanneling(Unit const* u = nullptr) const;
+        bool IsCasting(Unit const* u = nullptr) const;
+        bool JumpingFlyingOrFalling() const;
+        bool JumpingOrFalling() const;
+        bool Jumping() const;
+
+        float CalcSpellMaxRange(uint32 spellId, bool enemy = true) const;
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+        void GetInPosition(bool force, Unit* newtarget, Position* pos = nullptr);
+        virtual float GetSpellAttackRange(bool longRange) const { return longRange ? 25.f : 15.f; }
+        virtual void CheckAttackState();
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+
+        void CheckAuras(bool force = false);
+        virtual void InitPetSpells() {}
+        virtual void ApplyPetPassives() const {}
+
+        void Regenerate();
+        void RegeneratePetFocus();
+        void RegeneratePetEnergy();
+
+        bool Wait();
+        uint16 Rand() const;
+        void GenerateRand() const;
+
+        static uint32 GetLostHP(Unit const* unit);
+        static uint8 GetHealthPCT(Unit const* u);
+        static uint8 GetManaPCT(Unit const* u);
+
+        Unit* opponent;
+        Creature* petOwner;
+        //EventProcessor _petEvents;
+        uint32 GC_Timer;
+        uint32 myType;
+
+    private:
+        bool _canCureTarget(Unit const* target, uint32 cureSpell) const;
+        void _getBotDispellableAuraList(Unit const* target, Unit const* caster, uint32 dispelMask, std::list<Aura const*> &dispelList) const;
+        void _calculatePos(Position& pos) const;
+
+        bool _canRegenerate() const;
+
+        Unit* _getTarget(bool &reset) const;
+        bool _checkImmunities(Unit const* target, SpellInfo const* spellInfo) const;
+        static inline float _getAttackDistance(float distance) { return distance*0.72f; }
+
+        Position movepos, attackpos;
+        uint8 m_botCommandState;
+
+        //timers
+        uint32 lastdiff, checkAurasTimer, regenTimer, _updateTimerMedium, _updateTimerEx1;
+        mutable uint32 waitTimer;
+
+        float _energyFraction;
+
+        bool shouldUpdateStats;
+
+        struct BotPetSpell
+        {
+            explicit BotPetSpell() : spellId(0), cooldown(0), enabled(true) {}
+            uint32 spellId;
+            uint32 cooldown;
+            bool enabled;
+        private:
+            BotPetSpell(BotPetSpell const&);
+        };
+
+        typedef std::unordered_map<uint32 /*firstrankspellid*/, BotPetSpell* /*spell*/> BotPetSpellMap;
+        BotPetSpellMap const& GetSpellMap() const { return _spells; }
+        BotPetSpellMap _spells;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bpet_archmage.cpp b/src/server/game/AI/NpcBots/bpet_archmage.cpp
new file mode 100644
index 000000000..4714bcb83
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_archmage.cpp
@@ -0,0 +1,141 @@
+#include "bot_ai.h"
+#include "botspell.h"
+#include "bpet_ai.h"
+#include "Creature.h"
+#include "ScriptMgr.h"
+/*
+Archmage NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum ArchmagePetBaseSpells
+{
+    WATERBOLT_1             = SPELL_WATERBOLT
+};
+
+enum ArchmagePetSpecial
+{
+};
+
+class archmage_pet_bot : public CreatureScript
+{
+public:
+    archmage_pet_bot() : CreatureScript("archmage_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new awater_elemental_botpetAI(creature);
+    }
+
+    struct awater_elemental_botpetAI : public bot_pet_ai
+    {
+        awater_elemental_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(WATERBOLT_1, diff) && me->GetDistance(opponent) < 30)
+            {
+                me->CastSpell(opponent, GetSpell(WATERBOLT_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(WATERBOLT_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+    };
+};
+
+void AddSC_archmage_bot_pets()
+{
+    new archmage_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_dark_ranger.cpp b/src/server/game/AI/NpcBots/bpet_dark_ranger.cpp
new file mode 100644
index 000000000..8a6c304c0
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_dark_ranger.cpp
@@ -0,0 +1,214 @@
+#include "bot_ai.h"
+#include "botspell.h"
+#include "bpet_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Dark Ranger NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Notes:
+Extra abilities. For the sake of defending the owner added Taunt. For self defense added Blocking (block value unchanged)
+Both abilities are one-time use
+Complete - 100%
+TODO:
+*/
+
+enum DarkRangerPetBaseSpells
+{
+    BLOCKING_1                          = 3248,
+    TAUNT_1                             = 37548
+};
+enum DarkRangerPetPassives
+{
+};
+enum DarkRangerPetSpecial
+{
+    SPELL_GENERATE_THREAT               = 23604, //reduce threat
+    THREAT_BASE                         = 5,
+    MINION_DURATION                     = 80000
+};
+
+class dark_ranger_pet_bot : public CreatureScript
+{
+public:
+    dark_ranger_pet_bot() : CreatureScript("dark_ranger_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new dark_ranger_botpetAI(creature);
+    }
+
+    struct dark_ranger_botpetAI : public bot_pet_ai
+    {
+        dark_ranger_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(1000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+            //if (threatGenTimer < diff)
+            //{
+            //    threatGenTimer = 1500;
+            //    int32 threat = THREAT_BASE;
+            //    CastSpellExtraArgs args(true);
+            //    args.AddSpellBP0(threat);
+            //    me->CastSpell(me, SPELL_GENERATE_THREAT, args);
+            //}
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= MINION_DURATION)
+            {
+                canUpdate = false;
+                me->setDeathState(JUST_DIED);
+                me->ToTempSummon()->UnSummon(1000);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (IsSpellReady(TAUNT_1, diff, false) && Rand() < 50 &&
+                ((opponent->GetVictim() == petOwner && !IsTank(petOwner)) ||
+                (opponent->GetVictim() == petOwner->GetBotOwner() && !IsTank(petOwner->GetBotOwner()))) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(TAUNT_1), false);
+                SetSpellCooldown(TAUNT_1, std::numeric_limits<uint32>::max());
+                return;
+            }
+
+            if (IsSpellReady(BLOCKING_1, diff) && !me->getAttackers().empty() && Rand() < 40)
+            {
+                me->CastSpell(me, GetSpell(BLOCKING_1), true);
+                SetSpellCooldown(BLOCKING_1, 20000);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint32 GetData(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTPETAI_MISC_DURATION:
+                    return liveTimer;
+                case BOTPETAI_MISC_MAXLEVEL:
+                    return maxlevel;
+                default:
+                    return bot_pet_ai::GetData(data);
+            }
+        }
+
+        void SetData(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTPETAI_MISC_MAXLEVEL:
+                    maxlevel = uint8(value);
+                    SetPetStats(true);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+            maxlevel = 1;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(TAUNT_1, true, false);
+            InitSpellMap(BLOCKING_1, true, false);
+        }
+
+        void ApplyPetPassives() const override
+        {
+
+            if (me->GetEntry() == BOT_PET_DARK_MINION_ELITE)
+                RefreshAura(SPELL_VERTEX_COLOR_BLACK);
+            else if (me->GetEntry() == BOT_PET_DARK_MINION)
+                RefreshAura(SPELL_VERTEX_COLOR_GREY);
+        }
+
+    private:
+        uint32 liveTimer;
+        uint8 maxlevel;
+    };
+};
+
+void AddSC_dark_ranger_bot_pets()
+{
+    new dark_ranger_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_death_knight.cpp b/src/server/game/AI/NpcBots/bpet_death_knight.cpp
new file mode 100644
index 000000000..ae98798ba
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_death_knight.cpp
@@ -0,0 +1,191 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Deathknight NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 25%
+TODO: Garg, AOD, DRW
+*/
+enum DeathknightPetBaseSpells
+{
+    CLAW_1                              = 47468, //150% damage, 40 cost
+    GNAW_1                              = 47481, //12% damage, stun 3 sec, 30 cost
+    LEAP_1                              = 47482, //jump beh tar, 10 cost
+    HUDDLE_1                            = 47484  //mini-shwall, channeled, 10 sec, 10 cost
+};
+
+enum DeathknightPetPassives
+{
+    AVOIDANCE                           = 62137
+};
+
+enum DeathknightPetSpecial
+{
+    GHOUL_FRENZY_1                      = 63560 //player-on-pet spell
+};
+
+class deathknight_pet_bot : public CreatureScript
+{
+public:
+    deathknight_pet_bot() : CreatureScript("deathknight_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new deathknight_botpetAI(creature);
+    }
+
+    struct deathknight_botpetAI : public bot_pet_ai
+    {
+        deathknight_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            //Unit const* u = opponent->GetVictim();
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (myType == BOT_PET_GHOUL)
+            {
+                if (IsSpellReady(GHOUL_FRENZY_1, diff) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    RefreshAura(GHOUL_FRENZY_1);
+                    SetSpellCooldown(GHOUL_FRENZY_1, 30000);
+                }
+
+                uint32 const energy = me->GetPower(POWER_ENERGY);
+
+                if (IsSpellReady(HUDDLE_1, diff) && energy >= 10 && dist < 7 &&
+                    !me->getAttackers().empty() && GetHealthPCT(me) < 70)
+                {
+                    me->CastSpell(me, GetSpell(HUDDLE_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(LEAP_1, diff) && energy >= 10 &&
+                    !HasBotCommandState(BOT_COMMAND_STAY) &&
+                    !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                    dist > 5 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(LEAP_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(GNAW_1, diff) && canDPS && energy >= 30 &&
+                    me->IsWithinMeleeRange(opponent) && opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(GNAW_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(CLAW_1, diff) && canDPS && energy >= 40 && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(CLAW_1), false);
+                    return;
+                }
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(CLAW_1);
+            InitSpellMap(GNAW_1);
+            InitSpellMap(LEAP_1);
+            InitSpellMap(HUDDLE_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            if (myType == BOT_PET_GHOUL/* || myType == BOT_PET_AOD_GHOUL*/)
+                RefreshAura(AVOIDANCE);
+        }
+
+    private:
+    };
+};
+
+void AddSC_deathknight_bot_pets()
+{
+    new deathknight_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_dreadlord.cpp b/src/server/game/AI/NpcBots/bpet_dreadlord.cpp
new file mode 100644
index 000000000..11ef46750
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_dreadlord.cpp
@@ -0,0 +1,164 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "Creature.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Dreadlord NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum DreadlordPetBaseSpells
+{
+};
+
+enum DreadlordPetPassives
+{
+};
+
+enum DreadlordPetSpecial
+{
+    IMMOLATION_DAMAGE       = 35959,
+
+    INFERNAL_DURATION       = 180000 - 2000 //3 min
+};
+
+class dreadlord_pet_bot : public CreatureScript
+{
+public:
+    dreadlord_pet_bot() : CreatureScript("dreadlord_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new dreadlord_botpetAI(creature);
+    }
+
+    struct dreadlord_botpetAI : public bot_pet_ai
+    {
+        dreadlord_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            //infernal death & unsummon
+            if ((liveTimer += diff) >= INFERNAL_DURATION)
+            {
+                canUpdate = false;
+                me->setDeathState(JUST_DIED);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsPetMelee());
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool /*iscrit*/) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            float fdamage = float(damage);
+
+            float pctbonus = 1.0f;
+            pctbonus *= 0.5f;
+
+            if (baseId == IMMOLATION_DAMAGE)
+                fdamage += me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC) * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * me->CalculateSpellpowerCoefficientLevelPenalty(spellInfo);
+
+            damage = int32(fdamage * pctbonus);
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_dreadlord_bot_pets()
+{
+    new dreadlord_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_druid.cpp b/src/server/game/AI/NpcBots/bpet_druid.cpp
new file mode 100644
index 000000000..af28318ee
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_druid.cpp
@@ -0,0 +1,146 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Druid NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum DruidPetBaseSpells
+{
+};
+
+enum DruidPetPassives
+{
+};
+
+enum DruidPetSpecial
+{
+    TREANT_DURATION         = 30000
+};
+
+class druid_pet_bot : public CreatureScript
+{
+public:
+    druid_pet_bot() : CreatureScript("druid_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new druid_botpetAI(creature);
+    }
+
+    struct druid_botpetAI : public bot_pet_ai
+    {
+        druid_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(5000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= TREANT_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 /*diff*/)
+        {
+            StartAttack(opponent, IsPetMelee());
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_druid_bot_pets()
+{
+    new druid_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_hunter.cpp b/src/server/game/AI/NpcBots/bpet_hunter.cpp
new file mode 100644
index 000000000..511fa087d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_hunter.cpp
@@ -0,0 +1,1000 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Map.h"
+#include "ScriptMgr.h"
+#include "SpellMgr.h"
+#include "Player.h"
+/*
+Hunter NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+//talent tiers 20-32-44-56-68-80
+enum HunterPetBaseSpells
+{
+    //common
+    GROWL_1                             = 2649,//1
+    COWER_1                             = 1742,//20
+    //semi-common
+    //attack
+    BITE_1                              = 17253,//1 cost 25, Bat, Boar, Carrion Bird, Chimaera, Core Hound, Crocolisk, Devilsaur, Dragonhawk, Hyena, Nether Ray, Ravager, Serpent, Wolf, Worm
+    CLAW_1                              = 16827,//1 cost 25, Bear, Bird of Prey, Cat, Crab, Raptor, Scorpid, Silithid, Spirit Beast, Tallstrider
+    SMACK_1                             = 49966,//1 cost 25, Gorilla, Sporebat, Moth, Rhino, Wasp
+    //movement
+    //charge
+    SWOOP_1                             = 52825,//44 cost 35 Carrion Bird, Wasp, Teromoth
+    CHARGE_1                            = 61685,//20/44 cost 35 Bear, Boar, Cat, Core Hound, Crab, Crocolisk, Devilsaur, Gorilla, Hyena, Raptor, Rhino, Scorpid, Spirit Beast, Tallstrider, Turtle, Warp Stalker, Wolf, Worm
+    //sprint
+    DASH_1                              = 61684,//20/44 cost 30 Cat, Core Hound, Devilsaur, Hyena, Raptor, Ravager, Serpent, Silithid, Spider, Spirit Beast, Tallstrider, Warp Stalker, Wolf
+    DIVE_1                              = 23145,//20 cost 30 Bat, Bird of Prey, Carrion Bird, Chimaera, Dragonhawk, Moth, Nether Ray, Sporebat, Wasp, Wind Serpent
+    //talents cunning
+    CARRION_FEEDER_1                    = 54045,//44 triggered spell
+    WOLVERINE_BITE_1                    = 53508,//68 after crit (any time for bot)
+    ROAR_OF_RECOVERY_1                  = 53517,//68 mana regen
+    BULLHEADED_1                        = 53490,//68 movement imparing remove
+    //talents ferocity
+    //HEART_OF_THE_PHOENIX_1              = 55709,
+    RABID_1                             = 53401,//68 attack increase proc
+    LICK_YOUR_WOUNDS_1                  = 53426,//68 full heal over 5, channeled
+    CALL_OF_THE_WILD_1                  = 53434,//68 10% AP for pet and hunter
+    //talents tenacity
+    THUNDERSTOMP_1                      = 63900,//44
+    LAST_STAND_1                        = 53478,//68 30%
+    TAUNT_1                             = 53477,//68 3 min cd 126 sec improved
+    ROAR_OF_SACRIFICE_1                 = 53480,//68
+    INTERVENE_1                         = 53476,//68
+    //pet-specific
+    //cunning
+    SONIC_BLAST_1                       = 50519,//bat c80 dmg/stun 20y cd60
+    SNATCH_1                            = 50541,//birdop c20 dmg/disarm 5y cd60
+    FROSTSTORM_BREATH_1                 = 54644,//chimera c20 dmg/slow 30y cd10
+    FIRE_BREATH_1                       = 34889,//dhawk c20 dmg/dot 20y cd10
+    NETHER_SHOCK_1                      = 50479,//nray c20 dmg/interrupt 20y cd40
+    RAVAGE_1                            = 50518,//ravager c0 (bug?) dmg/stun 5y cd40
+    POISON_SPIT_1                       = 35387,//serpent c20 dot/slowcast 30y cd10
+    VENOM_WEB_SPRAY_1                   = 54706,//silithid c0 dot/root 30y cd40
+    WEB_1                               = 4167,//spider c0 root 30y cd40
+    SPORE_CLOUD_1                       = 50274,//sporebat c20 aoedot/-armorpct 6yd cd10
+    LIGHTNING_BREATH_1                  = 24844,//wserpent c20 dmg 20y cd10
+    //ferocity
+    DEMORALIZING_SCREECH_1              = 24423,//cbird c20 dmg/aoe-ap 5y cd10
+    PROWL_1                             = 24450,//cat,spbeast c0 stealth 0y cd10
+    LAVA_BREATH_1                       = 58604,//chound c20 dmg/slowcast 30y cd10
+    MONSTROUS_BITE_1                    = 54680,//dsaur c20 dmg/buff 5y cd10
+    TENDON_RIP_1                        = 50271,//hyena c20 dmg/snare 5y cd20
+    SERENITY_DUST_1                     = 50318,//tmoth c0 hot/buff+ap 0y cd60
+    SAVAGE_REND_1                       = 50498,//raptor c20 dmg/dot 5y cd60
+    SPIRIT_STRIKE_1                     = 61193,//spbeast c20 dmg/dot 30y cd10
+    DUST_CLOUD_1                        = 50285,//tstrider c20 aoe-100hit 10y cd40 lvl6
+    STING_1                             = 56626,//wasp c20 dmg/-5%armor 5y cd6
+    FURIOUS_HOWL_1                      = 24604,//wolf c20 buff+ap 100y cd40
+    //tenacity
+    SWIPE_1                             = 50256,//bear c20 dmg 5y cd5
+    GORE_1                              = 35290,//boar c20 dmg 5y cd10
+    PIN_1                               = 50245,//crab c0 root/dot 5y cd40
+    PUMMEL_1                            = 26090,//gorilla c20 interrupt 5y cd30
+    STAMPEDE_1                          = 57386,//rhino c0 dmg/debuff+bleed 5y cd60
+    SCORPID_POISON_1                    = 24640,//scorpid c20 threat/dot 5y cd10
+    SHELL_SHIELD_1                      = 26064,//turtle c0 buff%dmgtaken 0y cd60
+    WARP_1                              = 35346,//wstalker c0 tp/buff50%avoid 30y cd15
+    ACID_SPIT_1                         = 55749,//worm c20 dmg/debuff-10%armor 30y cd10
+
+    //from hunter's talents
+    SPIRIT_BOND_PET                     = 24529,
+    KINDRED_SPIRITS_PET                 = 57475,
+    INTIMIDATION_1                      = 24394,
+    BESTIAL_WRATH_1                     = 19574,
+    BEAST_WITHIN_1                      = 34471
+};
+
+enum HunterPetPassives
+{
+    //common
+    AVOIDANCE                           = 65220,
+    //pet talents
+    COBRA_REFLEXES                      = 61683,//rank 2
+    //BOARS_SPEED                         = 19596,
+    BLOOD_OF_THE_RHINO                  = 53482,//rank 2
+    OWLS_FOCUS                          = 53516,//rank 2
+    CULLING_THE_HERD                    = 52858,//rank 3
+    GRACE_OF_THE_MANTIS                 = 53451,//rank 2
+    CORNERED                            = 53497,//rank 2
+    FEEDING_FRENZY                      = 53512,//rank 2
+    SILVERBACK                          = 62765,//rank 2
+    //special
+    //Catlike Reflexes and Serpent's Swiftness replacement
+    HASTE_DODGE_PASSIVE                 = 13789,//Lightning Reflexes rank 3 6 dodge 10 haste
+};
+
+enum HunterPetSpecial
+{
+    PET_CATEGORY_CUNNING                = 1,
+    PET_CATEGORY_FEROCITY               = 2,
+    PET_CATEGORY_TENACITY               = 3,
+
+    GO_FOR_THE_THROAT_ENERGIZE          = 34953,
+    FRENZY_BUFF                         = 19615,
+    //HEART_OF_THE_PHOENIX_TRIGGERED      = 54114,//resurrect pet effect
+    //HEART_OF_THE_PHOENIX_DEBUFF         = 55711 //Weakened Heart dummy eff 0 icon 2787
+};
+
+class hunter_pet_bot : public CreatureScript
+{
+public:
+    hunter_pet_bot() : CreatureScript("hunter_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new hunter_botpetAI(creature);
+    }
+
+    struct hunter_botpetAI : public bot_pet_ai
+    {
+        hunter_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (GetSpell(SPIRIT_BOND_PET) && IsSpellReady(SPIRIT_BOND_PET, diff, false) &&
+                !petOwner->GetAuraEffect(SPELL_AURA_MOD_HEALING_PCT, SPELLFAMILY_GENERIC, 960, 1))
+            {
+                me->CastSpell(me, SPIRIT_BOND_PET, true);
+                SetSpellCooldown(SPIRIT_BOND_PET, uint32(-1));
+            }
+            if (GetSpell(KINDRED_SPIRITS_PET) && IsSpellReady(KINDRED_SPIRITS_PET, diff, false) &&
+                !petOwner->GetAuraEffect(SPELL_AURA_MOD_INCREASE_SPEED, SPELLFAMILY_GENERIC, 3559, 0))
+            {
+                me->CastSpell(me, KINDRED_SPIRITS_PET, true);
+                SetSpellCooldown(KINDRED_SPIRITS_PET, uint32(-1));
+            }
+
+            //Ignoring pet category
+
+            if (IsSpellReady(CARRION_FEEDER_1, diff, false) && !me->isMoving() && GetHealthPCT(me) <= 80 &&
+                !me->IsInCombat() && !me->GetVictim() && me->getAttackers().empty() &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && Rand() < 20)
+            {
+                WorldObject* result = nullptr;
+                Trinity::AnyDeadUnitSpellTargetInRangeCheck check(me, 5.f, sSpellMgr->GetSpellInfo(CARRION_FEEDER_1), TARGET_CHECK_ENEMY);
+                Trinity::WorldObjectSearcher<Trinity::AnyDeadUnitSpellTargetInRangeCheck> searcher(me, result, check);
+                Cell::VisitWorldObjects(me, searcher, 5.f);
+
+                if (result)
+                {
+                    me->CastSpell(me, GetSpell(CARRION_FEEDER_1), false);
+                    SetSpellCooldown(CARRION_FEEDER_1, 21000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(LICK_YOUR_WOUNDS_1, diff, false) && !me->isMoving() && !me->GetVictim() &&
+                me->getAttackers().empty() && GetHealthPCT(me) <= 50 + 30 * me->IsInCombat() &&
+                !me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && Rand() < 40)
+            {
+                me->CastSpell(me, GetSpell(LICK_YOUR_WOUNDS_1), false);
+                SetSpellCooldown(LICK_YOUR_WOUNDS_1, 126000);
+                return;
+            }
+
+            if (IsSpellReady(ROAR_OF_RECOVERY_1, diff, false) && petOwner->IsInCombat() && opponent &&
+                GetManaPCT(petOwner) < 65 && petOwner->GetDistance(me) < 40)
+            {
+                me->CastSpell(me, GetSpell(ROAR_OF_RECOVERY_1), false);
+                SetSpellCooldown(ROAR_OF_RECOVERY_1, 126000);
+                return;
+            }
+
+            if (IsSpellReady(INTERVENE_1, diff, false) && GetHealthPCT(petOwner) < 95 && !petOwner->getAttackers().empty() &&
+                me->getAttackers().size() <= petOwner->getAttackers().size())
+            {
+                float petdist = me->GetDistance(petOwner);
+                if (petdist < 25 && petdist > 8)
+                {
+                    me->CastSpell(petOwner, GetSpell(INTERVENE_1), false);
+                    SetSpellCooldown(INTERVENE_1, 21000);
+                    return;
+                }
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            Unit const* u = opponent->GetVictim();
+            float dist = me->GetDistance(opponent);
+            uint32 focus = me->GetPower(POWER_FOCUS);
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            //improved + Longevity applied to cds
+
+            if (IsSpellReady(BESTIAL_WRATH_1, diff, false) && canDPS && opponent && dist < 10 &&
+                (opponent->GetHealth() > petOwner->GetMaxHealth()/4 * (1 + opponent->getAttackers().size()) ||
+                opponent->GetTypeId() == TYPEID_PLAYER))
+            {
+                if (petOwner->AddAura(GetSpell(BESTIAL_WRATH_1), me))
+                {
+                    if (GetSpell(BEAST_WITHIN_1))
+                        petOwner->AddAura(GetSpell(BEAST_WITHIN_1), petOwner);
+
+                    SetSpellCooldown(BESTIAL_WRATH_1, 70000);
+                    return;
+                }
+            }
+
+            //LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) &&
+                GetHealthPCT(me) < (30 + 20 * (opponent->getAttackers().size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                me->CastSpell(me, GetSpell(LAST_STAND_1), false);
+                SetSpellCooldown(LAST_STAND_1, 252000);
+            }
+
+            if (IsSpellReady(INTIMIDATION_1, diff, false) && !CCed(opponent) && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(INTIMIDATION_1), false);
+                SetSpellCooldown(INTIMIDATION_1, 60000);
+                return;
+            }
+
+            if (IsSpellReady(GROWL_1, diff, false) && u && u != me && focus >= 15 && me->IsWithinMeleeRange(opponent) &&
+                opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 50)) && IsInBotParty(u))
+            {
+                me->CastSpell(opponent, GetSpell(GROWL_1), false);
+                SetSpellCooldown(GROWL_1, 3500);
+                return;
+            }
+
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 50)) && IsInBotParty(u))
+            {
+                me->CastSpell(opponent, GetSpell(TAUNT_1), false);
+                SetSpellCooldown(TAUNT_1, 126000);
+                return;
+            }
+
+            if (IsSpellReady(COWER_1, diff, false) && !me->getAttackers().empty() &&
+                me->GetDistance(*me->getAttackers().begin()) < 7 && GetHealthPCT(me) < 90)
+            {
+                me->CastSpell(me, GetSpell(COWER_1), false);
+                SetSpellCooldown(COWER_1, 31500);
+                return;
+            }
+
+            if (IsSpellReady(BULLHEADED_1, diff, false) && GetHealthPCT(me) < 90 &&
+                ((!me->getAttackers().empty() && me->GetDistance(*me->getAttackers().begin()) < 7) ||
+                (dist > 3 && !opponent->HasInArc(float(M_PI)/2, me) &&
+                (CCed(me, true) || me->HasAuraWithMechanic(1<<MECHANIC_SNARE)))))
+            {
+                me->CastSpell(me, GetSpell(BULLHEADED_1), false);
+                SetSpellCooldown(BULLHEADED_1, 31500);
+                return;
+            }
+
+            uint32 SPRINT = IsPetTypeSpell(DASH_1) ? DASH_1 : IsPetTypeSpell(DIVE_1) ? DIVE_1 : 0;
+            if (SPRINT && GetSpell(SPRINT) && IsSpellReady(SPRINT, diff, false) && dist > 10 && dist < 30 &&
+                !HasBotCommandState(BOT_COMMAND_STAY))
+            {
+                me->CastSpell(opponent, GetSpell(SPRINT), false);
+                SetSpellCooldown(SPRINT, 17500);
+                return;
+            }
+
+            if (IsSpellReady(CALL_OF_THE_WILD_1, diff, false) && canDPS && opponent && dist < 10)
+            {
+                me->CastSpell(me, GetSpell(CALL_OF_THE_WILD_1), false);
+                SetSpellCooldown(CALL_OF_THE_WILD_1, 210000);
+                return;
+            }
+
+            if (IsSpellReady(RABID_1, diff, false) && canDPS && dist < 10)
+            {
+                me->CastSpell(me, GetSpell(RABID_1), false);
+                SetSpellCooldown(RABID_1, 31500);
+                return;
+            }
+
+            if (IsSpellReady(THUNDERSTOMP_1, diff, false) && canDPS && focus >= 20 &&
+                me->IsWithinMeleeRange(opponent) && me->getAttackers().size() > 1)
+            {
+                me->CastSpell(opponent, GetSpell(THUNDERSTOMP_1), false);
+                SetSpellCooldown(THUNDERSTOMP_1, 7000);
+                return;
+            }
+
+            if (myType == BOT_PET_BAT)
+            {
+                if (IsSpellReady(SONIC_BLAST_1, diff, false) && canDPS && focus >= 80 &&
+                    dist < 20 && opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(SONIC_BLAST_1), false);
+                    SetSpellCooldown(SONIC_BLAST_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_BIRDOFPREY)
+            {
+                if (IsSpellReady(SNATCH_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                    ((opponent->GetTypeId() == TYPEID_PLAYER) ? opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) != nullptr :
+                    opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID) != 0))
+                {
+                    me->CastSpell(opponent, GetSpell(SNATCH_1), false);
+                    SetSpellCooldown(SNATCH_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CHIMAERA)
+            {
+                if (IsSpellReady(FROSTSTORM_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(FROSTSTORM_BREATH_1), false);
+                    SetSpellCooldown(FROSTSTORM_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_DRAGONHAWK)
+            {
+                if (IsSpellReady(FIRE_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 20)
+                {
+                    me->CastSpell(opponent, GetSpell(FIRE_BREATH_1), false);
+                    SetSpellCooldown(FIRE_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_NETHERRAY)
+            {
+                if (IsSpellReady(NETHER_SHOCK_1, diff, false) && canDPS && focus >= 20 && dist < 20 &&
+                    opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(NETHER_SHOCK_1), false);
+                    SetSpellCooldown(NETHER_SHOCK_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_RAVAGER)
+            {
+                if (IsSpellReady(RAVAGE_1, diff, false) && canDPS/* && focus >= 0*/ &&
+                    me->IsWithinMeleeRange(opponent) && opponent->IsNonMeleeSpellCast(false, false, true))
+                {
+                    me->CastSpell(opponent, GetSpell(RAVAGE_1), false);
+                    SetSpellCooldown(RAVAGE_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SERPENT)
+            {
+                if (IsSpellReady(POISON_SPIT_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(POISON_SPIT_1), false);
+                    SetSpellCooldown(POISON_SPIT_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SILITHID)
+            {
+                if (IsSpellReady(VENOM_WEB_SPRAY_1, diff, false) && canDPS/* && focus >= 0*/ && dist < 30 &&
+                    !CCed(opponent, true))
+                {
+                    me->CastSpell(opponent, GetSpell(VENOM_WEB_SPRAY_1), false);
+                    SetSpellCooldown(VENOM_WEB_SPRAY_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SPIDER)
+            {
+                if (IsSpellReady(WEB_1, diff, false)/* && focus >= 0*/ && dist < 30 && !CCed(opponent, true))
+                {
+                    me->CastSpell(opponent, GetSpell(WEB_1), false);
+                    SetSpellCooldown(WEB_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SPOREBAT)
+            {
+                if (IsSpellReady(SPORE_CLOUD_1, diff, false) && canDPS && focus >= 20 && dist < 5)
+                {
+                    me->CastSpell(opponent, GetSpell(SPORE_CLOUD_1), false);
+                    SetSpellCooldown(SPORE_CLOUD_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WINDSERPENT)
+            {
+                if (IsSpellReady(LIGHTNING_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 20)
+                {
+                    me->CastSpell(opponent, GetSpell(LIGHTNING_BREATH_1), false);
+                    SetSpellCooldown(LIGHTNING_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CARRIONBIRD)
+            {
+                if (IsSpellReady(DEMORALIZING_SCREECH_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(DEMORALIZING_SCREECH_1), false);
+                    SetSpellCooldown(DEMORALIZING_SCREECH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CAT)
+            {
+                if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && !me->HasStealthAura() &&
+                    /*focus >= 0 && */dist < 20 && dist > 5)
+                {
+                    me->CastSpell(opponent, GetSpell(PROWL_1), false);
+                    SetSpellCooldown(PROWL_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_COREHOUND)
+            {
+                if (IsSpellReady(LAVA_BREATH_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(LAVA_BREATH_1), false);
+                    SetSpellCooldown(LAVA_BREATH_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_DEVILSAUR)
+            {
+                if (IsSpellReady(MONSTROUS_BITE_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(MONSTROUS_BITE_1), false);
+                    SetSpellCooldown(MONSTROUS_BITE_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_HYENA)
+            {
+                if (IsSpellReady(TENDON_RIP_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(TENDON_RIP_1), false);
+                    SetSpellCooldown(TENDON_RIP_1, 14000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_TEROMOTH)
+            {
+                if (IsSpellReady(SERENITY_DUST_1, diff, false) && (canDPS || GetHealthPCT(me) < 90) &&
+                    /*focus >= 0 && */dist < 7)
+                {
+                    me->CastSpell(me, GetSpell(SERENITY_DUST_1), false);
+                    SetSpellCooldown(SERENITY_DUST_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_RAPTOR)
+            {
+                if (IsSpellReady(SAVAGE_REND_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SAVAGE_REND_1), false);
+                    SetSpellCooldown(SAVAGE_REND_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SPIRITBEAST)
+            {
+                if (IsSpellReady(PROWL_1, diff, false) && !me->IsInCombat() && !me->HasStealthAura() &&
+                    /*focus >= 0 && */dist < 30 && dist > 5)
+                {
+                    me->CastSpell(opponent, GetSpell(PROWL_1), false);
+                    SetSpellCooldown(PROWL_1, 10000); //custom
+                    return;
+                }
+                if (IsSpellReady(SPIRIT_STRIKE_1, diff, false) && canDPS && !me->HasStealthAura() &&
+                    focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(SPIRIT_STRIKE_1), false);
+                    SetSpellCooldown(SPIRIT_STRIKE_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_TALLSTRIDER)
+            {
+                if (IsSpellReady(DUST_CLOUD_1, diff, false) && focus >= 20 && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(DUST_CLOUD_1), false);
+                    SetSpellCooldown(DUST_CLOUD_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WASP)
+            {
+                if (IsSpellReady(STING_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(STING_1), false);
+                    SetSpellCooldown(STING_1, 4000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WOLF)
+            {
+                if (IsSpellReady(FURIOUS_HOWL_1, diff, false) && canDPS && focus >= 20)
+                {
+                    me->CastSpell(me, GetSpell(FURIOUS_HOWL_1), false);
+                    SetSpellCooldown(FURIOUS_HOWL_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_BEAR)
+            {
+                if (IsSpellReady(SWIPE_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SWIPE_1), false);
+                    SetSpellCooldown(SWIPE_1, 3500);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_BOAR)
+            {
+                if (IsSpellReady(GORE_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(GORE_1), false);
+                    SetSpellCooldown(GORE_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_CRAB)
+            {
+                if (IsSpellReady(PIN_1, diff, false) && canDPS/* && focus >= 0*/ &&
+                    me->IsWithinMeleeRange(opponent) && !CCed(opponent, true))
+                {
+                    me->CastSpell(opponent, GetSpell(PIN_1), false);
+                    SetSpellCooldown(PIN_1, 28000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_GORILLA)
+            {
+                if (IsSpellReady(PUMMEL_1, diff, false) && focus >= 20 && me->IsWithinMeleeRange(opponent) &&
+                    opponent->IsNonMeleeSpellCast(false,false,true))
+                {
+                    me->CastSpell(opponent, GetSpell(PUMMEL_1), false);
+                    SetSpellCooldown(PUMMEL_1, 21000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_RHINO)
+            {
+                if (IsSpellReady(STAMPEDE_1, diff, false) && canDPS/* && focus >= 0*/ &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(STAMPEDE_1), false);
+                    SetSpellCooldown(STAMPEDE_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SCORPID)
+            {
+                if (IsSpellReady(SCORPID_POISON_1, diff, false) && canDPS && focus >= 20 &&
+                    me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SCORPID_POISON_1), false);
+                    SetSpellCooldown(SCORPID_POISON_1, 7000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_TURTLE)
+            {
+                if (IsSpellReady(SHELL_SHIELD_1, diff, false)/* && focus >= 0*/ && dist < 7 &&
+                    !me->getAttackers().empty())
+                {
+                    me->CastSpell(me, GetSpell(SHELL_SHIELD_1), false);
+                    SetSpellCooldown(SHELL_SHIELD_1, 42000);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WARPSTALKER)
+            {
+                if (IsSpellReady(WARP_1, diff, false)/* && focus >= 0*/ && dist < 10)
+                {
+                    me->CastSpell(opponent, GetSpell(WARP_1), false);
+                    SetSpellCooldown(WARP_1, 10500);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_WORM)
+            {
+                if (IsSpellReady(ACID_SPIT_1, diff, false) && canDPS && focus >= 20 && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(ACID_SPIT_1), false);
+                    SetSpellCooldown(ACID_SPIT_1, 7000);
+                    return;
+                }
+            }
+
+            uint32 CHARGE = IsPetTypeSpell(SWOOP_1) ? SWOOP_1 : IsPetTypeSpell(CHARGE_1) ? CHARGE_1 : 0;
+            if (CHARGE && GetSpell(CHARGE) && IsSpellReady(CHARGE, diff, false) && !CCed(opponent, true) && !me->HasStealthAura() &&
+                !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                dist > 8 && dist < 25)
+            {
+                me->CastSpell(opponent, GetSpell(CHARGE), false);
+                SetSpellCooldown(CHARGE, 17500);
+                return;
+            }
+
+            if (GetSpell(WOLVERINE_BITE_1) && canDPS && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(WOLVERINE_BITE_1), false);
+                SetSpellCooldown(WOLVERINE_BITE_1, 7000);
+                return;
+            }
+
+            uint32 ATTACK_1 = IsPetTypeSpell(BITE_1) ? BITE_1 : IsPetTypeSpell(CLAW_1) ? CLAW_1 : SMACK_1;
+            if (GetSpell(ATTACK_1) && IsSpellReady(ATTACK_1, diff) && canDPS && focus >= 25 && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(ATTACK_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            uint8 lvl = me->GetLevel();
+            bool isBeas = Spec() == BOT_SPEC_HUNTER_BEASTMASTERY;
+
+            InitSpellMap(GROWL_1);
+            InitSpellMap(COWER_1);
+
+            InitSpellMap(BITE_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(SMACK_1);
+
+            //talents
+  /*Talent*/IsPetTypeSpell(SWOOP_1) ? InitSpellMap(SWOOP_1, true) : RemoveSpell(SWOOP_1);
+  /*Talent*/IsPetTypeSpell(CHARGE_1) ? InitSpellMap(CHARGE_1, true) : RemoveSpell(CHARGE_1);
+  /*Talent*/IsPetTypeSpell(DASH_1) ? InitSpellMap(DASH_1, true) : RemoveSpell(DASH_1);
+  /*Talent*/IsPetTypeSpell(DIVE_1) ? InitSpellMap(DIVE_1, true) : RemoveSpell(DIVE_1);
+            //talents cunning
+  /*Talent*/lvl >= 44 ? InitSpellMap(CARRION_FEEDER_1, true) : RemoveSpell(CARRION_FEEDER_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(WOLVERINE_BITE_1, true) : RemoveSpell(WOLVERINE_BITE_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(ROAR_OF_RECOVERY_1, true) : RemoveSpell(ROAR_OF_RECOVERY_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(BULLHEADED_1, true) : RemoveSpell(BULLHEADED_1);
+            //talents ferocity
+  ///*Talent*/lvl >= 68 ? InitSpellMap(HEART_OF_THE_PHOENIX_1, true) : RemoveSpell(HEART_OF_THE_PHOENIX_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(RABID_1, true) : RemoveSpell(RABID_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(LICK_YOUR_WOUNDS_1, true) : RemoveSpell(LICK_YOUR_WOUNDS_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(CALL_OF_THE_WILD_1, true) : RemoveSpell(CALL_OF_THE_WILD_1);
+            //talents tenacity
+  /*Talent*/lvl >= 44 ? InitSpellMap(THUNDERSTOMP_1, true) : RemoveSpell(THUNDERSTOMP_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(LAST_STAND_1, true) : RemoveSpell(LAST_STAND_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(TAUNT_1, true) : RemoveSpell(TAUNT_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(ROAR_OF_SACRIFICE_1, true) : RemoveSpell(ROAR_OF_SACRIFICE_1);
+  /*Talent*/lvl >= 68 ? InitSpellMap(INTERVENE_1, true) : RemoveSpell(INTERVENE_1);
+            //pet-specific
+            InitSpellMap(SONIC_BLAST_1);
+            InitSpellMap(SNATCH_1);
+            InitSpellMap(FROSTSTORM_BREATH_1);
+            InitSpellMap(FIRE_BREATH_1);
+            InitSpellMap(NETHER_SHOCK_1);
+            InitSpellMap(RAVAGE_1);
+            InitSpellMap(POISON_SPIT_1);
+            InitSpellMap(VENOM_WEB_SPRAY_1);
+            InitSpellMap(WEB_1);
+            InitSpellMap(SPORE_CLOUD_1);
+            InitSpellMap(LIGHTNING_BREATH_1);
+            InitSpellMap(DEMORALIZING_SCREECH_1);
+            InitSpellMap(PROWL_1);
+            InitSpellMap(LAVA_BREATH_1);
+            InitSpellMap(MONSTROUS_BITE_1);
+            InitSpellMap(TENDON_RIP_1);
+            InitSpellMap(SERENITY_DUST_1);
+            InitSpellMap(SAVAGE_REND_1);
+            InitSpellMap(SPIRIT_STRIKE_1);
+            InitSpellMap(DUST_CLOUD_1);
+            InitSpellMap(STING_1);
+            InitSpellMap(FURIOUS_HOWL_1);
+            InitSpellMap(SWIPE_1);
+            InitSpellMap(GORE_1);
+            InitSpellMap(PIN_1);
+            InitSpellMap(PUMMEL_1);
+            InitSpellMap(STAMPEDE_1);
+            InitSpellMap(SCORPID_POISON_1);
+            InitSpellMap(SHELL_SHIELD_1);
+            InitSpellMap(WARP_1);
+            InitSpellMap(ACID_SPIT_1);
+
+  /*Talent*/lvl >= 30 && isBeas ? InitSpellMap(SPIRIT_BOND_PET, true) : RemoveSpell(SPIRIT_BOND_PET);
+  /*Talent*/lvl >= 55 && isBeas ? InitSpellMap(KINDRED_SPIRITS_PET, true) : RemoveSpell(KINDRED_SPIRITS_PET);
+  /*Talent*/lvl >= 30 && isBeas ? InitSpellMap(INTIMIDATION_1, true) : RemoveSpell(INTIMIDATION_1);
+  /*Talent*/lvl >= 40 && isBeas ? InitSpellMap(BESTIAL_WRATH_1, true) : RemoveSpell(BESTIAL_WRATH_1);
+  /*Talent*/lvl >= 50 && isBeas ? InitSpellMap(BEAST_WITHIN_1, true) : RemoveSpell(BEAST_WITHIN_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            uint8 lvl = me->GetLevel();
+
+            RefreshAura(AVOIDANCE, lvl >= 60);
+            //ignore pet type
+            RefreshAura(COBRA_REFLEXES, lvl >= 20);
+            RefreshAura(BLOOD_OF_THE_RHINO, lvl >= 32);
+            RefreshAura(OWLS_FOCUS, lvl >= 32);
+            RefreshAura(CULLING_THE_HERD, lvl >= 32);
+            RefreshAura(GRACE_OF_THE_MANTIS, lvl >= 44);
+            RefreshAura(CORNERED, lvl >= 44);
+            RefreshAura(FEEDING_FRENZY, lvl >= 44);
+            RefreshAura(SILVERBACK, lvl >= 80);
+
+            RefreshAura(HASTE_DODGE_PASSIVE, lvl >= 45);
+        }
+
+    private:
+        bool IsPetTypeSpell(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case BITE_1: //lvl 1
+                    switch (myType)
+                    {
+                        case BOT_PET_BAT:
+                        case BOT_PET_BOAR:
+                        case BOT_PET_CARRIONBIRD:
+                        case BOT_PET_CROCOLISK:
+                        case BOT_PET_DRAGONHAWK:
+                        case BOT_PET_HYENA:
+                        case BOT_PET_NETHERRAY:
+                        case BOT_PET_RAVAGER:
+                        case BOT_PET_SERPENT:
+                        case BOT_PET_WOLF:
+
+                        case BOT_PET_CHIMAERA:
+                        case BOT_PET_COREHOUND:
+                        case BOT_PET_DEVILSAUR:
+                        case BOT_PET_WORM:
+                            return true;
+                        default:
+                            return false;
+                    }
+                case CLAW_1: //lvl 1
+                    switch (myType)
+                    {
+                        case BOT_PET_BEAR:
+                        case BOT_PET_BIRDOFPREY:
+                        case BOT_PET_CAT:
+                        case BOT_PET_CRAB:
+                        case BOT_PET_RAPTOR:
+                        case BOT_PET_SCORPID:
+                        case BOT_PET_TALLSTRIDER:
+
+                        case BOT_PET_SILITHID:
+                        case BOT_PET_SPIRITBEAST:
+                            return true;
+                        default:
+                            return false;
+                    }
+                case SMACK_1: //lvl 1
+                    switch (myType)
+                    {
+                        case BOT_PET_GORILLA:
+                        case BOT_PET_SPOREBAT:
+                        case BOT_PET_TEROMOTH:
+                        case BOT_PET_WASP:
+
+                        case BOT_PET_RHINO:
+                            return true;
+                        default:
+                            return false;
+                    }
+                case SWOOP_1: //fliers ferocity lvl 44
+                    switch (myType)
+                    {
+                        case BOT_PET_CARRIONBIRD:
+                        case BOT_PET_WASP:
+                        case BOT_PET_TEROMOTH:
+                            return me->GetLevel() >= 44;
+                        default:
+                            return false;
+                    }
+                case CHARGE_1: //non-fliers tenacity/ferocity lvl 20/44
+                    switch (myType)
+                    {
+                        case BOT_PET_BEAR:
+                        case BOT_PET_BOAR:
+                        case BOT_PET_CAT:
+                        case BOT_PET_CRAB:
+                        case BOT_PET_CROCOLISK:
+                        case BOT_PET_GORILLA:
+                        case BOT_PET_HYENA:
+                        case BOT_PET_RAPTOR:
+                        case BOT_PET_SCORPID:
+                        case BOT_PET_TALLSTRIDER:
+                        case BOT_PET_TURTLE:
+                        case BOT_PET_WARPSTALKER:
+                        case BOT_PET_WOLF:
+
+                        case BOT_PET_COREHOUND:
+                        case BOT_PET_DEVILSAUR:
+                        case BOT_PET_RHINO:
+                        case BOT_PET_SPIRITBEAST:
+                        case BOT_PET_WORM:
+                            return me->GetLevel() >= (IsPetCategory(PET_CATEGORY_FEROCITY) ? 44 : 20);
+                        default:
+                            return false;
+                    }
+                case DASH_1: //non-fliers ferocity/cunning lvl 20/44
+                    switch (myType)
+                    {
+                        case BOT_PET_CAT:
+                        case BOT_PET_HYENA:
+                        case BOT_PET_RAPTOR:
+                        case BOT_PET_RAVAGER:
+                        case BOT_PET_SERPENT:
+                        case BOT_PET_SPIDER:
+                        case BOT_PET_TALLSTRIDER:
+                        case BOT_PET_WARPSTALKER:
+                        case BOT_PET_WOLF:
+
+                        case BOT_PET_COREHOUND:
+                        case BOT_PET_DEVILSAUR:
+                        case BOT_PET_SILITHID:
+                        case BOT_PET_SPIRITBEAST:
+                            return me->GetLevel() >= (IsPetCategory(PET_CATEGORY_CUNNING) ? 44 : 20);
+                        default:
+                            return false;
+                    }
+                case DIVE_1: //fliers lvl 20
+                    switch (myType)
+                    {
+                        case BOT_PET_BAT:
+                        case BOT_PET_BIRDOFPREY:
+                        case BOT_PET_CARRIONBIRD:
+                        case BOT_PET_DRAGONHAWK:
+                        case BOT_PET_TEROMOTH:
+                        case BOT_PET_NETHERRAY:
+                        case BOT_PET_SPOREBAT:
+                        case BOT_PET_WASP:
+                        case BOT_PET_WINDSERPENT:
+
+                        case BOT_PET_CHIMAERA:
+                            return me->GetLevel() >= 20;
+                        default:
+                            return false;
+                    }
+                default:
+                    return true;
+            }
+        }
+
+        bool IsPetCategory(uint8 category) const
+        {
+            switch (myType)
+            {
+                case BOT_PET_SPIDER:
+                case BOT_PET_SERPENT:
+                case BOT_PET_BIRDOFPREY:
+                case BOT_PET_BAT:
+                case BOT_PET_WINDSERPENT:
+                case BOT_PET_RAVAGER:
+                case BOT_PET_DRAGONHAWK:
+                case BOT_PET_NETHERRAY:
+                case BOT_PET_SPOREBAT:
+
+                case BOT_PET_SILITHID:
+                case BOT_PET_CHIMAERA:
+                    return category == PET_CATEGORY_CUNNING;
+                case BOT_PET_CARRIONBIRD:
+                case BOT_PET_RAPTOR:
+                case BOT_PET_WOLF:
+                case BOT_PET_TALLSTRIDER:
+                case BOT_PET_CAT:
+                case BOT_PET_HYENA:
+                case BOT_PET_WASP:
+                case BOT_PET_TEROMOTH:
+
+                case BOT_PET_SPIRITBEAST:
+                case BOT_PET_COREHOUND:
+                case BOT_PET_DEVILSAUR:
+                    return category == PET_CATEGORY_FEROCITY;
+                case BOT_PET_SCORPID:
+                case BOT_PET_TURTLE:
+                case BOT_PET_GORILLA:
+                case BOT_PET_BEAR:
+                case BOT_PET_BOAR:
+                case BOT_PET_CRAB:
+                case BOT_PET_CROCOLISK:
+                case BOT_PET_WARPSTALKER:
+
+                case BOT_PET_RHINO:
+                case BOT_PET_WORM:
+                    return category == PET_CATEGORY_TENACITY;
+                default:
+                    return false;
+            }
+        }
+    };
+};
+
+void AddSC_hunter_bot_pets()
+{
+    new hunter_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_mage.cpp b/src/server/game/AI/NpcBots/bpet_mage.cpp
new file mode 100644
index 000000000..a95a0b5a3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_mage.cpp
@@ -0,0 +1,177 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ObjectAccessor.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellInfo.h"
+#include "TemporarySummon.h"
+/*
+Mage NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum MagePetBaseSpells
+{
+    WATERBOLT_1             = 31707,
+    FREEZE_1                = 33395
+};
+
+enum MagePetSpecial
+{
+    ELEMENTAL_DURATION      = 45000
+};
+
+class mage_pet_bot : public CreatureScript
+{
+public:
+    mage_pet_bot() : CreatureScript("mage_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new water_elemental_botpetAI(creature);
+    }
+
+    struct water_elemental_botpetAI : public bot_pet_ai
+    {
+        water_elemental_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(3000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (!IsSpellReady(FREEZE_1, diff, false) || Rand() > 40 || !IsCasting(petOwner))
+                return;
+
+            Spell const* spell = petOwner->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+            if (!spell || !spell->GetSpellInfo()->HasEffect(SPELL_EFFECT_SCHOOL_DAMAGE) ||
+                !(spell->GetTimer() < spell->GetCastTime() / 2))
+                return;
+
+            Unit* target = ObjectAccessor::GetUnit(*me, spell->m_targets.GetObjectTargetGUID());
+            if (!target || target->IsFrozen() || target->GetDistance(me) - target->GetCombatReach() > 25.f ||
+                !me->IsValidAttackTarget(target))
+                return;
+
+            me->InterruptNonMeleeSpells(false);
+            me->CastSpell(target, GetSpell(FREEZE_1), false);
+            return;
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= ELEMENTAL_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsSpellReady(WATERBOLT_1, diff) && me->GetDistance(opponent) < 45)
+            {
+                me->CastSpell(opponent, GetSpell(WATERBOLT_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(WATERBOLT_1);
+            InitSpellMap(FREEZE_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_mage_bot_pets()
+{
+    new mage_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_necromancer.cpp b/src/server/game/AI/NpcBots/bpet_necromancer.cpp
new file mode 100644
index 000000000..9f203862c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_necromancer.cpp
@@ -0,0 +1,193 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Necromancer NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Notes:
+Extra abilities. For the sake of defending the owner added Taunt. For self defense added Blocking (block value unchanged)
+Both abilities are one-time use
+Complete - 100%
+TODO:
+*/
+
+enum NecromancerPetBaseSpells
+{
+    BLOCKING_1                          = 3248,
+    TAUNT_1                             = 37548
+};
+enum NecromancerPetPassives
+{
+};
+enum NecromancerPetSpecial
+{
+    THREAT_BASE                         = 5,
+    MINION_DURATION                     = 65000
+};
+
+class necromancer_pet_bot : public CreatureScript
+{
+public:
+    necromancer_pet_bot() : CreatureScript("necromancer_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new necromancer_botpetAI(creature);
+    }
+
+    struct necromancer_botpetAI : public bot_pet_ai
+    {
+        necromancer_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(1000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= MINION_DURATION)
+            {
+                canUpdate = false;
+                me->setDeathState(JUST_DIED);
+                me->ToTempSummon()->UnSummon(1000);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            if (IsSpellReady(TAUNT_1, diff, false) && Rand() < 50 &&
+                ((opponent->GetVictim() == petOwner && !IsTank(petOwner)) ||
+                (opponent->GetVictim() == petOwner->GetBotOwner() && !IsTank(petOwner->GetBotOwner()))) &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) && me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(TAUNT_1), false);
+                SetSpellCooldown(TAUNT_1, std::numeric_limits<uint32>::max());
+                return;
+            }
+
+            if (IsSpellReady(BLOCKING_1, diff) && !me->getAttackers().empty() && Rand() < 25)
+            {
+                me->CastSpell(me, GetSpell(BLOCKING_1), true);
+                SetSpellCooldown(TAUNT_1, std::numeric_limits<uint32>::max());
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        uint32 GetData(uint32 data) const override
+        {
+            switch (data)
+            {
+                case BOTPETAI_MISC_DURATION:
+                    return liveTimer;
+                case BOTPETAI_MISC_MAXLEVEL:
+                    return maxlevel;
+                default:
+                    return bot_pet_ai::GetData(data);
+            }
+        }
+
+        void SetData(uint32 data, uint32 value) override
+        {
+            switch (data)
+            {
+                case BOTPETAI_MISC_MAXLEVEL:
+                    maxlevel = uint8(value);
+                    SetPetStats(true);
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+            maxlevel = 1;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(TAUNT_1, true, false);
+            InitSpellMap(BLOCKING_1, true, false);
+        }
+
+        void ApplyPetPassives() const override
+        {
+        }
+
+    private:
+        uint32 liveTimer;
+        uint8 maxlevel;
+    };
+};
+
+void AddSC_necromancer_bot_pets()
+{
+    new necromancer_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_priest.cpp b/src/server/game/AI/NpcBots/bpet_priest.cpp
new file mode 100644
index 000000000..865b46331
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_priest.cpp
@@ -0,0 +1,172 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Priest NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum PriestPetBaseSpells
+{
+    SHADOWCRAWL_1                       = 63619
+};
+
+enum PriestPetPassives
+{
+    MANA_LEECH                          = 28305,
+    AVOIDANCE                           = 63623
+};
+
+enum PriestPetSpecial
+{
+    GLYPH_SHADOWFIEND_PROC              = 58227,
+
+    SHADOWFIEND_DURATION                = 15000
+};
+
+class priest_pet_bot : public CreatureScript
+{
+public:
+    priest_pet_bot() : CreatureScript("priest_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new priest_botpetAI(creature);
+    }
+
+    struct priest_botpetAI : public bot_pet_ai
+    {
+        priest_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(5000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 /*diff*/)
+        {
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= SHADOWFIEND_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (IsSpellReady(SHADOWCRAWL_1, diff) && canDPS && dist < 30)
+            {
+                me->CastSpell(opponent, GetSpell(SHADOWCRAWL_1), false);
+                SetSpellCooldown(SHADOWCRAWL_1, 6000);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            //Handled by spell scripts
+            //if (damage && victim && damageType == DIRECT_DAMAGE)
+            //    victim->CastSpell(petOwner, MANA_LEECH_PROC, true);
+
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (damage >= me->GetHealth())
+                petOwner->CastSpell(petOwner, GLYPH_SHADOWFIEND_PROC, true);
+
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(SHADOWCRAWL_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            RefreshAura(MANA_LEECH);
+            RefreshAura(AVOIDANCE);
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_priest_bot_pets()
+{
+    new priest_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_sea_witch.cpp b/src/server/game/AI/NpcBots/bpet_sea_witch.cpp
new file mode 100644
index 000000000..dccb04397
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_sea_witch.cpp
@@ -0,0 +1,250 @@
+#include "bot_ai.h"
+#include "botspell.h"
+#include "bpet_ai.h"
+#include "MotionMaster.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "TemporarySummon.h"
+/*
+Sea Witch NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum SeaWitchPetBaseSpells
+{
+    ENVELOP_1                   = SPELL_TORNADO_EFFECT,
+    LIGHTNING_1                 = SPELL_TORNADO_EFFECT2,
+};
+
+enum SeaWitchPetSpecial
+{
+    TORNADO_DURATION            = 40000,
+    TORNADO_MOVE_RESET_TIMER    = 1500,
+    TORNADO_GROWTH_TIMER        = 2500,
+    TORNADO_DISSIPATE_TIMER     = 5000,
+
+    PERIODIC_LIGHTNING_VISUAL   = 45869,
+    CAMERA_SHAKE_VISUAL         = 12816,
+    TARGET_LIGHTNING_VISUAL     = 39381,
+    TARGET_LIGHTNING_VISUAL2    = 45935,
+    SPELL_GROWTH                = 55948,//+10% size, +10% damage
+    SPELL_SLOW_AURA             = SPELL_TORNADO_EFFECT3
+};
+
+class sea_witch_pet_bot : public CreatureScript
+{
+public:
+    sea_witch_pet_bot() : CreatureScript("sea_witch_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new tornado_botpetAI(creature);
+    }
+
+    struct tornado_botpetAI : public bot_pet_ai
+    {
+        tornado_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(1); bot_pet_ai::JustDied(u); }
+
+        void DoPetActions(uint32 diff)
+        {
+            //Envelop random target: every 3 sec
+            if (IsSpellReady(ENVELOP_1, diff, false))
+            {
+                std::list<Unit*> targets;
+                petOwner->GetBotAI()->HelpGetNearbyTargetsList(targets, 10.f, 1, me);
+                if (targets.size() > 2)
+                    Trinity::Containers::RandomResize(targets, 2);
+                for (Unit* u : targets)
+                    me->CastSpell(u, GetSpell(ENVELOP_1), true);
+                SetSpellCooldown(ENVELOP_1, 3000);
+            }
+
+            if (IsSpellReady(LIGHTNING_1, diff, false))
+            {
+                std::list<Unit*> targets;
+                petOwner->GetBotAI()->HelpGetNearbyTargetsList(targets, 15.f, 0, me);
+                if (!targets.empty())
+                    me->CastSpell(me, CAMERA_SHAKE_VISUAL, true);
+                for (Unit* u : targets)
+                {
+                    me->CastSpell(u, GetSpell(LIGHTNING_1), true);
+                    u->CastSpell(u, TARGET_LIGHTNING_VISUAL, true);
+                    u->CastSpell(u, TARGET_LIGHTNING_VISUAL2, true);
+                }
+                SetSpellCooldown(LIGHTNING_1, 4500);
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (((liveTimer += diff) >= TORNADO_DURATION) || !petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS))
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+            else if (!me->IsOutdoors() && (indoorsTimer += diff) >= TORNADO_DISSIPATE_TIMER)
+            {
+                canUpdate = false;
+                me->SetObjectScale(me->GetNativeObjectScale() / 2.f);
+                me->ToTempSummon()->UnSummon(2000);
+                return;
+            }
+
+            if ((growthTimer += diff) > TORNADO_GROWTH_TIMER)
+            {
+                growthTimer %= TORNADO_GROWTH_TIMER;
+                me->CastSpell(me, SPELL_GROWTH, true);
+                //me->SetObjectScale(me->GetObjectScale() * 1.1f);
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            DoPetActions(diff);
+
+            if (IsCasting())
+                return;
+
+            if (!CheckAttackTarget())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            if ((moveResetTimer += diff) > TORNADO_MOVE_RESET_TIMER || opponent->GetGUID() != me->GetTarget())
+            {
+                moveResetTimer %= TORNADO_MOVE_RESET_TIMER;
+                SetBotCommandState(BOT_COMMAND_ATTACK);
+                me->SetTarget(opponent->GetGUID());
+                Position pos = opponent->GetNearPosition(frand(3.f, 5.f + opponent->GetCombatReach()), opponent->GetAbsoluteAngle(petOwner) + frand(float(-M_PI) / 2.f, float(M_PI) / 2.f));
+                me->GetMotionMaster()->MovePoint(me->GetMapId(), pos.GetPositionX(), pos.GetPositionY(), opponent->GetPositionZ(), false);
+                //me->GetMotionMaster()->MoveChase(opponent, frand(3.f, 10.f), opponent->GetAbsoluteAngle(petOwner) + frand(-M_PI / 2, M_PI / 2));
+            }
+        }
+
+        void ApplyBotPetSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const override
+        {
+            uint32 baseId = spellInfo->GetFirstRankSpell()->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            //uint8 lvl = me->GetLevel();
+            float flatbonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            ////pct mods
+            ////Increased Area (AhnQ set bonus?) 23549
+            //if (lvl >= 60 && (spellInfo->SpellFamilyFlags[0] & 0x1084))
+            //    pctbonus += 0.25f;
+
+            //flat mods
+            //Slow Aura growth
+            if (baseId == SPELL_SLOW_AURA)
+                flatbonus += me->GetCombatReach();
+
+            radius = radius * (1.0f + pctbonus) + flatbonus;
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override {}
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* wtarget, SpellInfo const* spell) override
+        {
+            Unit* target = wtarget->ToUnit();
+            if (!target)
+                return;
+
+            if (target == me)
+                return;
+
+            uint32 baseId = spell->GetFirstRankSpell()->Id;
+            //uint8 lvl = me->GetLevel();
+
+            if (baseId == ENVELOP_1)
+            {
+                if (target->IsControlledByPlayer())
+                {
+                    if (Aura* enve = target->GetAura(GetSpell(baseId), me->GetGUID()))
+                    {
+                        int32 dur = std::max<int32>(enve->GetDuration() - 6000, 0);
+                        enve->SetDuration(dur);
+                        enve->SetMaxDuration(dur);
+                    }
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void CheckAttackState() override
+        {
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+            moveResetTimer = 0;
+            growthTimer = 0;
+            indoorsTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(ENVELOP_1, true, false);
+            InitSpellMap(LIGHTNING_1, true, false);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            RefreshAura(PERIODIC_LIGHTNING_VISUAL);
+            RefreshAura(SPELL_SLOW_AURA);
+        }
+
+    private:
+        uint32 liveTimer;
+        uint32 moveResetTimer;
+        uint32 growthTimer;
+        uint32 indoorsTimer;
+    };
+};
+
+void AddSC_sea_witch_bot_pets()
+{
+    new sea_witch_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_shaman.cpp b/src/server/game/AI/NpcBots/bpet_shaman.cpp
new file mode 100644
index 000000000..62fcc2eef
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_shaman.cpp
@@ -0,0 +1,191 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "ScriptMgr.h"
+#include "TemporarySummon.h"
+/*
+Shaman NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum ShamanPetBaseSpells
+{
+    BASH_1                              = 58861, //r5 cd45
+    LEAP_1                              = 58867, //r5-30 cd20
+    TWIN_HOWL_1                         = 58857, //r10 cd15
+    SPIRIT_WALK_1                       = 58875  //r25 cd32
+};
+
+enum ShamanPetPassives
+{
+    SPIRIT_HUNT                         = 58877
+};
+
+enum ShamanPetSpecial
+{
+    SPIRITWOLF_DURATION                 = 45000
+};
+
+class shaman_pet_bot : public CreatureScript
+{
+public:
+    shaman_pet_bot() : CreatureScript("shaman_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new shaman_botpetAI(creature);
+    }
+
+    struct shaman_botpetAI : public bot_pet_ai
+    {
+        shaman_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { canUpdate = false; me->ToTempSummon()->UnSummon(5000); bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (IsSpellReady(SPIRIT_WALK_1, diff) && (me->GetVictim() || petOwner->GetVictim()) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                me->GetDistance(petOwner) < 25)
+            {
+                me->CastSpell(me, GetSpell(SPIRIT_WALK_1), false);
+                return;
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if ((liveTimer += diff) >= SPIRITWOLF_DURATION)
+            {
+                canUpdate = false;
+                me->ToTempSummon()->UnSummon(1);
+                return;
+            }
+
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            Unit const* u = opponent->GetVictim();
+            //bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (IsSpellReady(LEAP_1, diff) &&
+                !HasBotCommandState(BOT_COMMAND_STAY) &&
+                !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                dist > 5 && dist < 30)
+            {
+                me->CastSpell(opponent, GetSpell(LEAP_1), false);
+                return;
+            }
+
+            if (IsSpellReady(BASH_1, diff) && !CCed(opponent) &&
+                me->IsWithinMeleeRange(opponent))
+            {
+                me->CastSpell(opponent, GetSpell(BASH_1), false);
+                return;
+            }
+
+            if (IsSpellReady(TWIN_HOWL_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 50)) && IsInBotParty(u))
+            {
+                me->CastSpell(opponent, GetSpell(TWIN_HOWL_1), false);
+                return;
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+            liveTimer = 0;
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(BASH_1);
+            InitSpellMap(LEAP_1);
+            InitSpellMap(TWIN_HOWL_1);
+            InitSpellMap(SPIRIT_WALK_1);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            RefreshAura(SPIRIT_HUNT);
+        }
+
+    private:
+        uint32 liveTimer;
+    };
+};
+
+void AddSC_shaman_bot_pets()
+{
+    new shaman_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bpet_warlock.cpp b/src/server/game/AI/NpcBots/bpet_warlock.cpp
new file mode 100644
index 000000000..b484561c9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bpet_warlock.cpp
@@ -0,0 +1,409 @@
+#include "bot_ai.h"
+#include "bpet_ai.h"
+#include "botmgr.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "TemporarySummon.h"
+/*
+Warlock NpcBot Pets (by Trickerer onlysuffering@gmail.com)
+Complete - 100%
+TODO:
+*/
+
+enum WarlockPetBaseSpells
+{
+    //imp
+    FIREBOLT_1                          = 3110,//1
+    BLOOD_PACT_1                        = 6307,//4
+    PHASE_SHIFT_1                       = 4511,//12
+    FIRE_SHIELD_1                       = 2947,//14 unused
+    //voidwalker
+    TORMENT_1                           = 3716,//10
+    SACRIFICE_1                         = 7812,//16
+    CONSUME_SHADOWS_1                   = 17767,//18
+    SUFFERING_1                         = 17735,//24
+    //succubus
+    LASH_OF_PAIN_1                      = 7814,//20
+    SOOTHING_KISS_1                     = 6360,//22
+    SEDUCTION_1                         = 6358,//26
+    LESSER_INVISIBILITY_1               = 7870,//32
+    //felhunter
+    DEVOUR_MAGIC_1                      = 19505,//30
+    FEL_INTELLIGENCE_1                  = 54424,//32
+    SPELL_LOCK_1                        = 19244,//36
+    SHADOW_BITE_1                       = 54049,//42
+    //felguard
+    ANGUISH_1                           = 33698,//50
+    CLEAVE_1                            = 30213,//50
+    INTERCEPT_1                         = 30151 //52
+};
+
+enum WarlockPetPassives
+{
+    AVOIDANCE                           = 32233,
+    DEMONIC_FRENZY                      = 32850
+};
+
+enum WarlockPetSpecial
+{
+    SOUL_LINK_PET                       = 25228//split effect lvl 20 req
+};
+
+class warlock_pet_bot : public CreatureScript
+{
+public:
+    warlock_pet_bot() : CreatureScript("warlock_pet_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const override
+    {
+        return new warlock_botpetAI(creature);
+    }
+
+    struct warlock_botpetAI : public bot_pet_ai
+    {
+        warlock_botpetAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        void JustEnteredCombat(Unit* u) override { bot_pet_ai::JustEnteredCombat(u); }
+        void KilledUnit(Unit* u) override { bot_pet_ai::KilledUnit(u); }
+        void EnterEvadeMode(EvadeReason why = EVADE_REASON_OTHER) override { bot_pet_ai::EnterEvadeMode(why); }
+        void MoveInLineOfSight(Unit* u) override { bot_pet_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) override { bot_pet_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (!bot_pet_ai::StartAttack(u, force))
+                return;
+            GetInPosition(force, u);
+        }
+
+        void DoPetActions(uint32 diff)
+        {
+            if (GetSpell(SOUL_LINK_PET) && !petOwner->HasAuraTypeWithCaster(SPELL_AURA_SPLIT_DAMAGE_PCT, me->GetGUID()))
+            {
+                me->CastSpell(me, SOUL_LINK_PET, false);
+                return;
+            }
+            if (myType == BOT_PET_IMP)
+            {
+                //hacked - confilct with soul link due to ownerGuid mismatch
+                if (IsSpellReady(BLOOD_PACT_1, diff, false) && (!me->HasAuraType(SPELL_AURA_230) ||
+                    me->GetAuraEffectsByType(SPELL_AURA_230).front()->GetAmount() < sSpellMgr->GetSpellInfo(GetSpell(BLOOD_PACT_1))->_effects[0].CalcValue()))
+                {
+                    me->CastSpell(me, GetSpell(BLOOD_PACT_1), false);
+                    //CastSpellExtraArgs args(true);
+                    //args.SetOriginalCaster(me->GetGUID());
+                    //petOwner->CastSpell(petOwner, GetSpell(BLOOD_PACT_1), args);
+                    SetSpellCooldown(BLOOD_PACT_1, uint32(-1));
+                }
+
+                if (IsSpellReady(PHASE_SHIFT_1, diff, false) && !me->GetVictim() &&
+                    (!petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS) || !me->IsInCombat()) &&
+                    !me->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+                {
+                    me->CastSpell(me, GetSpell(PHASE_SHIFT_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_VOIDWALKER)
+            {
+                if (GetSpell(CONSUME_SHADOWS_1) && !me->IsInCombat() && !me->isMoving() &&
+                    me->GetDistance(me) < 10 && GetHealthPCT(me) < 80)
+                {
+                    me->CastSpell(me, GetSpell(CONSUME_SHADOWS_1), false);
+                    return;
+                }
+
+                if (IsSpellReady(SACRIFICE_1, diff, false) &&
+                    (!petOwner->getAttackers().empty() || petOwner->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) &&
+                    me->GetHealth() > me->GetCreateHealth() / 4) //hp cost 25%
+                {
+                    me->CastSpell(me, GetSpell(SACRIFICE_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_SUCCUBUS)
+            {
+                if (IsSpellReady(SOOTHING_KISS_1, diff, false) &&
+                    !me->getAttackers().empty() && me->GetDistance(*(me->getAttackers().begin())) < 10)
+                {
+                    me->CastSpell(*(me->getAttackers().begin()), GetSpell(SOOTHING_KISS_1), false);
+                    SetSpellCooldown(SOOTHING_KISS_1, 4000);
+                    return;
+                }
+
+                if (GetSpell(SEDUCTION_1) && Rand() < 20 && !IsCasting())
+                {
+                    Unit* target = petOwner->GetBotAI()->HelpFindStunTarget(30);
+                    if (target && target->GetDiminishing(DIMINISHING_FEAR) <= DIMINISHING_LEVEL_2 + 1 * (target->IsNonMeleeSpellCast(false, false, true)))
+                    {
+                        me->CastSpell(target, GetSpell(SEDUCTION_1), false);
+                        return;
+                    }
+                }
+
+                if (IsSpellReady(LESSER_INVISIBILITY_1, diff, false) && !me->GetVictim() && !me->IsInCombat() &&
+                    !me->HasAuraType(SPELL_AURA_MOD_INVISIBILITY))
+                {
+                    me->CastSpell(me, GetSpell(LESSER_INVISIBILITY_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_FELHUNTER)
+            {
+                //hacked - confilct with soul link due to ownerGuid mismatch
+                if (IsSpellReady(FEL_INTELLIGENCE_1, diff, false) &&
+                    (IAmFree() ||
+                    (!petOwner->GetBotOwner()->GetBotMgr()->HasBotClass(BOT_CLASS_MAGE) &&
+                    !petOwner->GetBotOwner()->GetBotMgr()->HasBotClass(BOT_CLASS_PRIEST))))
+                {
+                    me->CastSpell(me, GetSpell(FEL_INTELLIGENCE_1), false);
+                    //CastSpellExtraArgs args(true);
+                    //args.SetOriginalCaster(me->GetGUID());
+                    //petOwner->CastSpell(petOwner, GetSpell(FEL_INTELLIGENCE_1), args);
+                    SetSpellCooldown(FEL_INTELLIGENCE_1, uint32(-1));
+                }
+
+                if (IsSpellReady(SPELL_LOCK_1, diff, false))
+                {
+                    if (Unit* target = petOwner->GetBotAI()->HelpFindCastingTarget(30, 0, SPELL_LOCK_1))
+                        me->CastSpell(target, GetSpell(SPELL_LOCK_1), false);
+                }
+
+                CureGroup(GetSpell(DEVOUR_MAGIC_1), diff);
+            }
+        }
+
+        void UpdateAI(uint32 diff) override
+        {
+            if (!GlobalUpdate(diff))
+                return;
+
+            if (Spell const* spell = me->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+            {
+                if (myType == BOT_PET_SUCCUBUS)
+                {
+                    if (Unit const* target = spell->m_targets.GetUnitTarget())
+                    {
+                        //Seduction interrupt
+                        if (spell->GetSpellInfo()->GetFirstRankSpell()->Id == SEDUCTION_1 && CCed(target))
+                            me->InterruptSpell(CURRENT_GENERIC_SPELL);
+                    }
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            DoPetActions(diff);
+            //CheckDrainMana(diff);
+
+            if (!CheckAttackTarget())
+                return;
+
+            if (IsCasting())
+                return;
+
+            DoPetAttack(diff);
+        }
+
+        void DoPetAttack(uint32 diff)
+        {
+            StartAttack(opponent, IsPetMelee());
+
+            float dist = me->GetDistance(opponent);
+            Unit const* u = opponent->GetVictim();
+            bool canDPS = petOwner->GetBotAI()->HasRole(BOT_ROLE_DPS);
+
+            if (myType == BOT_PET_IMP)
+            {
+                if (GetSpell(FIREBOLT_1) && canDPS && dist < 30)
+                {
+                    me->CastSpell(opponent, GetSpell(FIREBOLT_1), false);
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_VOIDWALKER)
+            {
+                if (IsSpellReady(TORMENT_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                    opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                    (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 20)) && IsInBotParty(u))
+                {
+                    me->CastSpell(opponent, GetSpell(TORMENT_1), false);
+                    SetSpellCooldown(TORMENT_1, 5000);
+                    return;
+                }
+
+                if (IsSpellReady(SUFFERING_1, diff) &&
+                    !(u == me && opponent->GetTypeId() == TYPEID_UNIT &&
+                    (opponent->ToCreature()->IsDungeonBoss() || opponent->ToCreature()->isWorldBoss())))
+                {
+                    std::list<Unit*> targets;
+                    petOwner->GetBotAI()->HelpGetNearbyTargetsList(targets, 9.f, 1, me);
+                    uint8 count = 0;
+                    for (std::list<Unit*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    {
+                        if (!((*itr)->GetVictim() && IsTank((*itr)->GetVictim())))
+                            if (++count > 1)
+                                break;
+                    }
+                    if (count < 2 && u && u != me && !IsSpellReady(TORMENT_1, diff, false) && !IsTank(u) && !CCed(opponent) && dist < 8 &&
+                        IsInBotParty(u))
+                    {
+                        count += 2;
+                    }
+
+                    if (count > 1)
+                    {
+                        me->CastSpell(me, GetSpell(SUFFERING_1), false);
+                        SetSpellCooldown(SUFFERING_1, 120000);
+                        return;
+                    }
+                }
+            }
+            else if (myType == BOT_PET_SUCCUBUS)
+            {
+                if (IsSpellReady(LASH_OF_PAIN_1, diff, false) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(LASH_OF_PAIN_1), false);
+                    //this could have worked if cast was triggered
+                    //SetSpellCooldown(LASH_OF_PAIN_1, 6000); //Demonic Power part 1
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_FELHUNTER)
+            {
+                if (IsSpellReady(SHADOW_BITE_1, diff, false) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(SHADOW_BITE_1), false);
+                    SetSpellCooldown(SHADOW_BITE_1, me->GetLevel() >= 35 ? 2000 : 6000); //improved felhunter part 2
+                    return;
+                }
+            }
+            else if (myType == BOT_PET_FELGUARD)
+            {
+                if (IsSpellReady(INTERCEPT_1, diff, false) && canDPS &&
+                    !HasBotCommandState(BOT_COMMAND_STAY) &&
+                    !(opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss()) &&
+                    dist > 8 && dist < 25 && !CCed(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(INTERCEPT_1), false);
+                    SetSpellCooldown(INTERCEPT_1, 30000);
+                    return;
+                }
+
+                if (IsSpellReady(ANGUISH_1, diff, false) && u && u != me && me->IsWithinMeleeRange(opponent) &&
+                    opponent->CanHaveThreatList() && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_TAUNT) &&
+                    (!IsTank(u) || (GetHealthPCT(u) < 30 && GetHealthPCT(me) > 20)) && IsInBotParty(u))
+                {
+                    me->CastSpell(opponent, GetSpell(ANGUISH_1), false);
+                    SetSpellCooldown(ANGUISH_1, 5000);
+                    return;
+                }
+
+                if (IsSpellReady(CLEAVE_1, diff, false) && canDPS && me->IsWithinMeleeRange(opponent))
+                {
+                    me->CastSpell(opponent, GetSpell(CLEAVE_1), false);
+                    SetSpellCooldown(CLEAVE_1, 6000);
+                    return;
+                }
+            }
+        }
+
+        void OnPetClassSpellGo(SpellInfo const* /*spellInfo*/) override
+        {
+        }
+
+        void SpellHit(WorldObject* wcaster, SpellInfo const* spell) override
+        {
+            Unit* caster = wcaster->ToUnit();
+            if (!caster)
+                return;
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(WorldObject* /*wtarget*/, SpellInfo const* /*spell*/) override
+        {
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType) override
+        {
+            bot_pet_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo*/) override
+        {
+            if (!u)
+                return;
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u) override
+        {
+            if (!u)
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset() override
+        {
+        }
+
+        void InitPetSpells() override
+        {
+            InitSpellMap(FIREBOLT_1);
+            InitSpellMap(BLOOD_PACT_1);
+            InitSpellMap(PHASE_SHIFT_1);
+            //InitSpellMap(FIRE_SHIELD_1);
+
+            InitSpellMap(TORMENT_1);
+            InitSpellMap(SACRIFICE_1);
+            InitSpellMap(CONSUME_SHADOWS_1);
+            InitSpellMap(SUFFERING_1);
+
+            InitSpellMap(LASH_OF_PAIN_1);
+            InitSpellMap(SOOTHING_KISS_1);
+            InitSpellMap(SEDUCTION_1);
+            InitSpellMap(LESSER_INVISIBILITY_1);
+
+            InitSpellMap(DEVOUR_MAGIC_1);
+            InitSpellMap(FEL_INTELLIGENCE_1);
+            InitSpellMap(SPELL_LOCK_1);
+            InitSpellMap(SHADOW_BITE_1);
+
+            InitSpellMap(ANGUISH_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(INTERCEPT_1);
+
+            InitSpellMap(SOUL_LINK_PET);
+        }
+
+        void ApplyPetPassives() const override
+        {
+            uint8 lvl = me->GetLevel();
+            switch (myType)
+            {
+                case BOT_PET_FELGUARD:
+                    RefreshAura(DEMONIC_FRENZY);
+                    break;
+                default:
+                    break;
+            }
+
+            RefreshAura(AVOIDANCE, lvl >= 60 ? 1 : 0);
+        }
+
+    private:
+    };
+};
+
+void AddSC_warlock_bot_pets()
+{
+    new warlock_pet_bot();
+}
diff --git a/src/server/game/AI/NpcBots/lib/bottraits.h b/src/server/game/AI/NpcBots/lib/bottraits.h
new file mode 100644
index 000000000..e58036ead
--- /dev/null
+++ b/src/server/game/AI/NpcBots/lib/bottraits.h
@@ -0,0 +1,156 @@
+#ifndef BOT_TRAITS_H
+#define BOT_TRAITS_H
+
+#include "botcommon.h"
+
+#include "Creature.h"
+#include "SpellAuraEffects.h"
+
+#include <array>
+#include <tuple>
+
+namespace NPCBots
+{
+
+template<typename T, std::size_t... Is>
+constexpr auto fixed_tuple_helper(std::index_sequence<Is...> const&) -> decltype(std::make_tuple(((void)Is, std::declval<T>())...));
+
+template<typename T, size_t N>
+struct fixed_tuple {
+    using tuple_type = decltype(fixed_tuple_helper<T>(std::make_index_sequence<N>{}));
+};
+
+template<typename T, std::size_t N, std::size_t... Is>
+typename fixed_tuple<T,N>::tuple_type to_tuple_helper(std::array<T, N>&& arr, std::index_sequence<Is...>&&)
+{
+    return std::make_tuple(arr[Is]...);
+}
+
+template<typename T, size_t N>
+typename fixed_tuple<T,N>::tuple_type to_tuple(std::array<T, N>&& arr)
+{
+    return to_tuple_helper(std::forward<std::array<T, N>>(arr), std::make_index_sequence<N>{});
+}
+
+template<typename T, std::size_t N, std::size_t... Is>
+typename fixed_tuple<typename T::second_type,N>::tuple_type to_spell_school_affect_bool_tuple_helper(std::array<T, N>&& arr, std::index_sequence<Is...>&&)
+{
+    return std::make_tuple(arr[Is].second...);
+}
+
+template<typename T, size_t N>
+typename fixed_tuple<typename T::second_type,N>::tuple_type to_spell_school_affect_bool_tuple(std::array<T, N>&& arr)
+{
+    return to_spell_school_affect_bool_tuple_helper(std::forward<std::array<T, N>>(arr), std::make_index_sequence<N>{});
+}
+
+template<typename T, std::size_t N, std::size_t... Is>
+std::array<typename T::second_type,N> to_spell_school_affect_bool_arr_helper(std::array<T, N>&& arr, std::index_sequence<Is...>&&)
+{
+    return std::array{ arr[Is].second... };
+}
+
+template<typename T, size_t N>
+std::array<typename T::second_type,N> to_spell_school_affect_bool_arr(std::array<T, N>&& arr)
+{
+    return to_spell_school_affect_bool_arr_helper(std::forward<std::array<T, N>>(arr), std::make_index_sequence<N>{});
+}
+
+}
+
+template<typename School, typename... Schools>
+std::enable_if_t<std::conjunction_v<std::is_same<School, SpellSchools>, std::is_same<Schools, SpellSchools>...>,
+    bool>
+all_schools_valid(School school, Schools... schools)
+{
+    if (school < SPELL_SCHOOL_NORMAL || school >= MAX_SPELL_SCHOOL)
+        return false;
+
+    if constexpr (sizeof...(Schools) > 0)
+        return all_schools_valid(schools...);
+    return true;
+}
+
+template<class...Schools>
+std::enable_if_t<std::conjunction_v<std::is_same<Schools, SpellSchools>...>,
+    std::array<std::pair<SpellSchools, bool>, sizeof...(Schools)>>
+CanAffectVictimSchools(Unit const* target, Schools... schools)
+{
+    static_assert(sizeof...(Schools) > 0, "need at least 1 spell school to check for");
+
+    using arr_type = std::array<std::pair<SpellSchools, bool>, sizeof...(Schools)>;
+    using arr_iter_type = typename arr_type::iterator;
+    arr_type results{ std::pair{schools, true}... };
+
+    if (!all_schools_valid(schools...))
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::CanAffectVictimSchools(): trying to check invalid spell school, first: %u", uint32(results.at(0).first));
+        return results;
+    }
+
+    if (Creature const* creature = target->ToCreature())
+    {
+        if (SpellSchoolMask immune_mask = SpellSchoolMask(creature->GetCreatureTemplate()->SpellSchoolImmuneMask))
+        {
+            for (uint8 i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
+            {
+                if (immune_mask & (1 << i))
+                {
+                    arr_iter_type ri = std::find(results.begin(), results.end(), std::pair{ SpellSchools(i), true });
+                    if (ri != results.end())
+                        ri->second = false;
+                }
+            }
+        }
+    }
+
+    for (AuraEffect const* immune_effect : target->GetAuraEffectsByType(SPELL_AURA_SCHOOL_IMMUNITY))
+    {
+        if (SpellSchoolMask immune_mask = SpellSchoolMask(immune_effect->GetMiscValue()))
+        {
+            for (uint8 i = 0; i < MAX_SPELL_SCHOOL; ++i)
+            {
+                if (immune_mask & (1 << i))
+                {
+                    arr_iter_type ri = std::find(results.begin(), results.end(), std::pair{ SpellSchools(i), true });
+                    if (ri != results.end())
+                        ri->second = false;
+                }
+            }
+        }
+    }
+    return results;
+}
+
+template<class...Schools>
+typename NPCBots::fixed_tuple<bool, sizeof...(Schools)>::tuple_type
+CanAffectVictimBools(Unit const* target, Schools... schools)
+{
+    return NPCBots::to_spell_school_affect_bool_tuple(CanAffectVictimSchools(target, schools...));
+}
+
+template<class...Schools>
+bool
+CanAffectVictimAny(Unit const* target, Schools... schools)
+{
+    using arr_type = std::array<std::pair<SpellSchools, bool>, sizeof...(Schools)>;
+    using pair_type = typename arr_type::value_type;
+
+    arr_type bools = CanAffectVictimSchools(target, schools...);
+
+    return std::any_of(bools.cbegin(), bools.cend(), [](pair_type const& p) { return p.second; });
+}
+
+template<class...Schools>
+bool
+CanAffectVictimAll(Unit const* target, Schools... schools)
+{
+    using arr_type = std::array<std::pair<SpellSchools, bool>, sizeof...(Schools)>;
+    using pair_type = typename arr_type::value_type;
+
+    arr_type bools = CanAffectVictimSchools(target, schools...);
+
+    return std::all_of(bools.cbegin(), bools.cend(), [](pair_type const& p) { return p.second; });
+}
+
+#endif
diff --git a/src/server/game/AI/SmartScripts/SmartScript.cpp b/src/server/game/AI/SmartScripts/SmartScript.cpp
index c4087ed21..5ec0f17ba 100644
--- a/src/server/game/AI/SmartScripts/SmartScript.cpp
+++ b/src/server/game/AI/SmartScripts/SmartScript.cpp
@@ -292,6 +292,9 @@ void SmartScript::ProcessAction(SmartScriptHolder& e, Unit* unit, uint32 var0, u
                         talkTarget = target->ToCreature();
                     }
                     else
+                    //npcbot: prevent using bots as talkers
+                    if (!target->ToCreature()->IsNPCBotOrPet())
+                    //end npcbot
                         talker = target->ToCreature();
                     break;
                 }
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index cdca72556..54ea4c3aa 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -748,6 +748,45 @@ enum RBACPermissions
     // IF YOU ADD NEW PERMISSIONS, ADD THEM IN MASTER BRANCH AS WELL!
     //
     // custom permissions 1000+
+    //NPCBot
+    RBAC_PERM_COMMAND_NPCBOT                                 = 70001,
+    RBAC_PERM_COMMAND_NPCBOT_ADD                             = 70002,
+    RBAC_PERM_COMMAND_NPCBOT_REMOVE                          = 70003,
+    RBAC_PERM_COMMAND_NPCBOT_SPAWN                           = 70004,
+    RBAC_PERM_COMMAND_NPCBOT_MOVE                            = 70005,
+    RBAC_PERM_COMMAND_NPCBOT_DELETE                          = 70006,
+    RBAC_PERM_COMMAND_NPCBOT_LOOKUP                          = 70007,
+    RBAC_PERM_COMMAND_NPCBOT_REVIVE                          = 70008,
+    RBAC_PERM_COMMAND_NPCBOT_RELOADCONFIG                    = 70009,
+    RBAC_PERM_COMMAND_NPCBOT_INFO                            = 70010,
+    RBAC_PERM_COMMAND_NPCBOT_HIDE                            = 70011,
+    RBAC_PERM_COMMAND_NPCBOT_UNHIDE                          = 70012,
+    RBAC_PERM_COMMAND_NPCBOT_RECALL                          = 70013,
+    RBAC_PERM_COMMAND_NPCBOT_KILL                            = 70014,
+    RBAC_PERM_COMMAND_NPCBOT_DEBUG_RAID                      = 70015,
+    RBAC_PERM_COMMAND_NPCBOT_DEBUG_MOUNT                     = 70016,
+    RBAC_PERM_COMMAND_NPCBOT_DEBUG_VISUAL                    = 70017,
+    RBAC_PERM_COMMAND_NPCBOT_DEBUG_STATES                    = 70018,
+    RBAC_PERM_COMMAND_NPCBOT_TOGGLE_FLAGS                    = 70019,
+    RBAC_PERM_COMMAND_NPCBOT_SET_FACTION                     = 70020,
+    RBAC_PERM_COMMAND_NPCBOT_SET_OWNER                       = 70021,
+    RBAC_PERM_COMMAND_NPCBOT_SET_SPEC                        = 70022,
+    RBAC_PERM_COMMAND_NPCBOT_COMMAND_STANDSTILL              = 70023,
+    RBAC_PERM_COMMAND_NPCBOT_COMMAND_STOPFULLY               = 70024,
+    RBAC_PERM_COMMAND_NPCBOT_COMMAND_FOLLOW                  = 70025,
+    RBAC_PERM_COMMAND_NPCBOT_ATTDISTANCE_SHORT               = 70026,
+    RBAC_PERM_COMMAND_NPCBOT_ATTDISTANCE_LONG                = 70027,
+    RBAC_PERM_COMMAND_NPCBOT_ATTDISTANCE_EXACT               = 70028,
+    RBAC_PERM_COMMAND_NPCBOT_FOLDISTANCE_EXACT               = 70029,
+    RBAC_PERM_COMMAND_NPCBOT_ORDER_CAST                      = 70030,
+    RBAC_PERM_COMMAND_NPCBOT_VEHICLE_EJECT                   = 70031,
+    RBAC_PERM_COMMAND_NPCBOT_DUMP_LOAD                       = 70032,
+    RBAC_PERM_COMMAND_NPCBOT_DUMP_WRITE                      = 70033,
+    RBAC_PERM_COMMAND_NPCBOT_SPAWNED                         = 70034,
+    RBAC_PERM_COMMAND_NPCBOT_COMMAND_WALK                    = 70035,
+    RBAC_PERM_COMMAND_NPCBOT_CREATENEW                       = 70036,
+    RBAC_PERM_COMMAND_NPCBOT_SEND                            = 70037,
+    //End NPCBot
     RBAC_PERM_MAX
 };
 
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 234148b02..8a17f1faa 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -41,6 +41,10 @@
 #include "WorldStatePackets.h"
 #include <cstdarg>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 void BattlegroundScore::AppendToPacket(WorldPacket& data)
 {
     data << uint64(PlayerGuid);
@@ -895,6 +899,22 @@ void Battleground::RemovePlayerAtLeave(ObjectGuid guid, bool Transport, bool Sen
         // remove from raid group if player is member
         if (Group* group = GetBgRaid(team))
         {
+            //npcbot
+            if (player && player->HaveBot())
+            {
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    Creature const* bot = itr->second;
+                    if (!bot || !group->IsMember(bot->GetGUID()))
+                        continue;
+
+                    group->RemoveMember(bot->GetGUID());
+                    UpdatePlayersCountByTeam(team, true);
+                    DecreaseInvitedCount(team);
+                }
+            }
+            //end npcbot
             if (!group->RemoveMember(guid))                // group was disbanded
                 SetBgRaid(team, nullptr);
         }
@@ -998,6 +1018,21 @@ void Battleground::AddPlayer(Player* player)
     if (!isInBattleground)
         UpdatePlayersCountByTeam(team, false);                  // +1 player
 
+    //npcbot
+    if (player->GetGroup() && player->HaveBot())
+    {
+        BotMap const* map = player->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature const* bot = itr->second;
+            if (!bot || !player->GetGroup()->IsMember(bot->GetGUID()))
+                continue;
+
+            UpdatePlayersCountByTeam(team, false);
+        }
+    }
+    //end npcbot
+
     WorldPacket data;
     sBattlegroundMgr->BuildPlayerJoinedBattlegroundPacket(&data, player);
     SendPacketToTeam(team, &data, player, false);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index a49ea023e..7d1a6dcaa 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -30,6 +30,13 @@
 #include "Player.h"
 #include "World.h"
 
+//npcbot
+//non-PCH
+#include "Creature.h"
+#include "botmgr.h"
+#include "botdatamgr.h"
+//end npcbot
+
 /*********************************************************/
 /***            BATTLEGROUND QUEUE SYSTEM              ***/
 /*********************************************************/
@@ -183,6 +190,24 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
             pl_info.GroupInfo        = ginfo;
             // add the pinfo to ginfo's list
             ginfo->Players[member->GetGUID()]  = &pl_info;
+
+            //npcbot: queue bots (bg only)
+            if (arenateamid || !member->HaveBot())
+                continue;
+
+            BotMap const* map = member->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Creature const* bot = itr->second;
+                if (!bot || !grp->IsMember(bot->GetGUID()))
+                    continue;
+
+                PlayerQueueInfo& pl_info = m_QueuedPlayers[bot->GetGUID()];
+                pl_info.LastOnlineTime   = lastOnlineTime;
+                pl_info.GroupInfo        = ginfo;
+                ginfo->Players[bot->GetGUID()]  = &pl_info;
+            }
+            //end npcbot
         }
     }
     else
@@ -375,6 +400,24 @@ void BattlegroundQueue::RemovePlayer(ObjectGuid guid, bool decreaseInvitedCount)
         }
     }
 
+    //npcbot: removing bot: return
+    if (!guid.IsPlayer())
+        return;
+
+    //npcbot: remove player's bots if queued
+    if (!group->Players.empty())
+    {
+        std::vector<ObjectGuid> botguids;
+        botguids.reserve(BotMgr::GetMaxNpcBots() / 2);
+        BotDataMgr::GetNPCBotGuidsByOwner(botguids, guid);
+        for (std::vector<ObjectGuid>::const_iterator ci = botguids.begin(); ci != botguids.end() && !group->Players.empty(); ++ci)
+        {
+            if (m_QueuedPlayers.find(*ci) != m_QueuedPlayers.end())
+                RemovePlayer(*ci, decreaseInvitedCount);
+        }
+    }
+    //end npcbot
+
     // remove group queue info if needed
     if (group->Players.empty())
     {
@@ -453,6 +496,16 @@ bool BattlegroundQueue::InviteGroupToBG(GroupQueueInfo* ginfo, Battleground* bg,
         // loop through the players
         for (std::map<ObjectGuid, PlayerQueueInfo*>::iterator itr = ginfo->Players.begin(); itr != ginfo->Players.end(); ++itr)
         {
+            //npcbot: invite bots
+            if (itr->first.IsCreature())
+            {
+                bg->IncreaseInvitedCount(ginfo->Team);
+                TC_LOG_DEBUG("bg.battleground", "Battleground: invited NPCBot %s to BG instance %u bgtype %u",
+                    itr->first.ToString().c_str(), bg->GetInstanceID(), bg->GetTypeID());
+                continue;
+            }
+            //end npcbot
+
             // get the player
             Player* player = ObjectAccessor::FindConnectedPlayer(itr->first);
             // if offline, skip him, this should not happen - player is removed from queue when he logs out
diff --git a/src/server/game/Combat/CombatManager.cpp b/src/server/game/Combat/CombatManager.cpp
index fa297239c..bc5dd2f72 100644
--- a/src/server/game/Combat/CombatManager.cpp
+++ b/src/server/game/Combat/CombatManager.cpp
@@ -21,6 +21,10 @@
 #include "CreatureAI.h"
 #include "Player.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 /*static*/ bool CombatManager::CanBeginCombat(Unit const* a, Unit const* b)
 {
     // Checks combat validity before initial reference creation.
@@ -207,12 +211,33 @@ bool CombatManager::SetInCombatWith(Unit* who, bool addSecondUnitSuppressed)
     CombatReference* ref;
     if (_owner->IsControlledByPlayer() && who->IsControlledByPlayer())
         ref = new PvPCombatReference(_owner, who);
+    //npcbot: follow pvp rules
+    else if ((_owner->ToCreature() && _owner->ToCreature()->IsNPCBotOrPet() && who->IsControlledByPlayer()) ||
+        (who->ToCreature() && who->ToCreature()->IsNPCBotOrPet() && _owner->IsControlledByPlayer()) ||
+        (_owner->ToCreature() && _owner->ToCreature()->IsNPCBotOrPet() &&
+        who->ToCreature() && who->ToCreature()->IsNPCBotOrPet()))
+        ref = new PvPCombatReference(_owner, who);
+    //end npcbot
     else
         ref = new CombatReference(_owner, who);
 
     if (addSecondUnitSuppressed)
         ref->Suppress(who);
 
+    //npcbot
+    /*
+    if (_owner->GetTypeId() == TYPEID_PLAYER && _owner->ToPlayer()->HaveBot())
+    {
+        BotMap const* map = _owner->ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            itr->second->SetInCombatWith(who);
+            if (Unit* botPet = itr->second->GetBotsPet())
+                botPet->SetInCombatWith(who);
+        }
+    }*/
+    //end npcbot
+
     // ...and insert it into both managers
     PutReference(who->GetGUID(), ref);
     who->GetCombatManager().PutReference(_owner->GetGUID(), ref);
@@ -386,6 +411,18 @@ bool CombatManager::UpdateOwnerCombatState() const
 
     if (combatState)
     {
+        //npcbot: party combat hook
+        Player* playerOwner = nullptr;
+        if (_owner->GetTypeId() == TYPEID_PLAYER && _owner->ToPlayer()->HaveBot())
+            playerOwner = _owner->ToPlayer();
+        else if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBotOrPet() &&
+            !_owner->ToCreature()->IsFreeBot())
+            playerOwner = _owner->ToCreature()->GetBotOwner();
+
+        if (playerOwner)
+            BotMgr::OnBotPartyEngage(playerOwner);
+        //end npcbot
+
         _owner->SetUnitFlag(UNIT_FLAG_IN_COMBAT);
         _owner->AtEnterCombat();
         if (_owner->GetTypeId() != TYPEID_UNIT)
diff --git a/src/server/game/Combat/ThreatManager.cpp b/src/server/game/Combat/ThreatManager.cpp
index d1eaa2301..504cf58bb 100644
--- a/src/server/game/Combat/ThreatManager.cpp
+++ b/src/server/game/Combat/ThreatManager.cpp
@@ -32,6 +32,10 @@
 #include "WorldPacket.h"
 #include <algorithm>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 #include "Hacks/boost_1_74_fibonacci_heap.h"
 BOOST_1_74_FIBONACCI_HEAP_MSVC_COMPILE_FIX(ThreatManager::threat_list_heap::value_type)
 
@@ -170,6 +174,11 @@ void ThreatReference::UnregisterAndFree()
             if (tWho->GetSummonerGUID().IsPlayer())
                 return false;
 
+    //npcbot - npcbots and their pets cannot have threatlist
+    if (cWho->IsNPCBot() || cWho->IsNPCBotPet())
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -626,6 +635,11 @@ void ThreatManager::ProcessAIUpdates()
 
         if (Player* modOwner = victim->GetSpellModOwner())
             modOwner->ApplySpellMod(spell->Id, SPELLMOD_THREAT, threat);
+
+        //npcbot: threat mods
+        if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI())
+            BotMgr::ApplyBotThreatMods(victim, spell, threat);
+        //end npcbot
     }
 
     // modifiers by effect school
diff --git a/src/server/game/Conditions/ConditionMgr.cpp b/src/server/game/Conditions/ConditionMgr.cpp
index d3336d5b1..ca9c9aeea 100644
--- a/src/server/game/Conditions/ConditionMgr.cpp
+++ b/src/server/game/Conditions/ConditionMgr.cpp
@@ -33,6 +33,10 @@
 #include "SpellMgr.h"
 #include "World.h"
 
+//npcbot
+#include "bot_ai.h"
+//end npcbot
+
 char const* const ConditionMgr::StaticSourceTypeData[CONDITION_SOURCE_TYPE_MAX] =
 {
     "None",
@@ -147,6 +151,11 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo) const
         }
         case CONDITION_ITEM:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot())
+                condMeets = true;
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
             {
                 // don't allow 0 items (it's checked during table load)
@@ -158,6 +167,11 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo) const
         }
         case CONDITION_ITEM_EQUIPPED:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot())
+                condMeets = true; //for now
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
                 condMeets = player->HasItemOrGemWithIdEquipped(ConditionValue1, 1);
             break;
@@ -167,6 +181,15 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo) const
             break;
         case CONDITION_REPUTATION_RANK:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot() &&
+                object->ToCreature()->GetBotAI() && !object->ToCreature()->IsFreeBot())
+            {
+                if (FactionEntry const* faction = sFactionStore.LookupEntry(ConditionValue1))
+                    condMeets = (ConditionValue2 & (1 << object->ToCreature()->GetBotOwner()->GetReputationMgr().GetRank(faction)));
+            }
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
             {
                 if (FactionEntry const* faction = sFactionStore.LookupEntry(ConditionValue1))
@@ -176,12 +199,23 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo) const
         }
         case CONDITION_ACHIEVEMENT:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot())
+                condMeets = true;
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
                 condMeets = player->HasAchieved(ConditionValue1);
             break;
         }
         case CONDITION_TEAM:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot() &&
+                object->ToCreature()->GetBotAI() && !object->ToCreature()->IsFreeBot())
+                condMeets = object->ToCreature()->GetBotOwner()->GetTeam() == ConditionValue1;
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
                 condMeets = player->GetTeam() == ConditionValue1;
             break;
@@ -200,12 +234,22 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo) const
         }
         case CONDITION_GENDER:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot())
+                condMeets = object->ToCreature()->GetGender() == ConditionValue1;
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
                 condMeets = player->GetNativeGender() == ConditionValue1;
             break;
         }
         case CONDITION_SKILL:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->IsNPCBot())
+                condMeets = true;
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
                 condMeets = player->HasSkill(ConditionValue1) && player->GetBaseSkillValue(ConditionValue1) >= ConditionValue2;
             break;
@@ -280,6 +324,11 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo) const
             break;
         case CONDITION_SPELL:
         {
+            //npcbot
+            if (object->GetTypeId() == TYPEID_UNIT && object->ToCreature()->GetBotAI())
+                condMeets = object->ToCreature()->GetBotAI()->HasSpell(sSpellMgr->GetSpellInfo(ConditionValue1)->GetFirstRankSpell()->Id);
+            else
+            //end npcbot
             if (Player* player = object->ToPlayer())
                 condMeets = player->HasSpell(ConditionValue1);
             break;
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index 2997c8b8a..0abc29985 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -115,7 +115,7 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -338,7 +338,7 @@ void LoadDBCStores(const std::string& dataPath)
     LOAD_DBC(sHolidaysStore,                      "Holidays.dbc");
     LOAD_DBC(sItemStore,                          "Item.dbc");
     LOAD_DBC(sItemBagFamilyStore,                 "ItemBagFamily.dbc");
-    //LOAD_DBC(sItemDisplayInfoStore,               "ItemDisplayInfo.dbc");     -- not used currently
+    LOAD_DBC(sItemDisplayInfoStore,               "ItemDisplayInfo.dbc");
     //LOAD_DBC(sItemCondExtCostsStore,              "ItemCondExtCosts.dbc");
     LOAD_DBC(sItemExtendedCostStore,              "ItemExtendedCost.dbc");
     LOAD_DBC(sItemLimitCategoryStore,             "ItemLimitCategory.dbc");
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index 0ac62982c..17ef7818d 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -145,7 +145,7 @@ TC_GAME_API extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptSto
 TC_GAME_API extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 TC_GAME_API extern DBCStorage <ItemEntry>                    sItemStore;
 TC_GAME_API extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
-//TC_GAME_API extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+TC_GAME_API extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;
 TC_GAME_API extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 TC_GAME_API extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 TC_GAME_API extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index aed1ec744..043dca7d7 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -40,6 +40,13 @@
 #include "World.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botcommon.h"
+#include "botmgr.h"
+#include "Chat.h"
+#include "Creature.h"
+//end npcbot
+
 namespace lfg
 {
 
@@ -466,6 +473,46 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                         joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
                     ++memberCount;
                     players.insert(plrg->GetGUID());
+
+                    //npcbot
+                    if (!plrg->HaveBot())
+                        continue;
+                    //add npcbots
+                    BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (!grp->IsMember(itr->first))
+                            continue;
+
+                        //disabled in config
+                        if (!BotMgr::IsNpcBotDungeonFinderEnabled())
+                        {
+                            (ChatHandler(plrg->GetSession())).SendSysMessage("Using npcbots in Dungeon Finder is restricted. Contact your administration.");
+
+                            if (plrg->GetGUID() != grp->GetLeaderGUID())
+                                if (Player* leader = ObjectAccessor::FindPlayer(grp->GetLeaderGUID()))
+                                    (ChatHandler(leader->GetSession())).PSendSysMessage("There is a npcbot in your group (owner: %s). Using npcbots in Dungeon Finder is restricted. Contact your administration.",
+                                        plrg->GetName().c_str());
+
+                            joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            break;
+                        }
+
+                        if (/*Creature* bot = */ObjectAccessor::GetCreature(*plrg, itr->first))
+                        {
+                            //if (!(bot->GetBotRoles() & ( 1 | 2 | 4 ))) //(BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL)
+                            //{
+                            //    //no valid roles - reqs are not met
+                            //    (ChatHandler(plrg->GetSession())).PSendSysMessage("Your bot %s does not have any viable roles assigned.", bot->GetName().c_str());
+                            //    joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            //    continue;
+                            //}
+
+                            ++memberCount;
+                            players.insert(itr->first);
+                        }
+                    }
+                    //end npcbot
                 }
             }
 
@@ -563,6 +610,9 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
         SetState(gguid, LFG_STATE_ROLECHECK);
         // Send update to player
         LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_JOIN_QUEUE, dungeons, comment);
+        //npcbot
+        std::map<ObjectGuid, uint8> brolemap;
+        //end npcbot
         for (GroupReference* itr = grp->GetFirstMember(); itr != nullptr; itr = itr->next())
         {
             if (Player* plrg = itr->GetSource())
@@ -576,10 +626,57 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                 if (!debugNames.empty())
                     debugNames.append(", ");
                 debugNames.append(plrg->GetName());
+
+                //npcbot
+                if (!plrg->HaveBot())
+                    continue;
+                //add npcbots
+                BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    ObjectGuid bguid = itr->first;
+                    if (players.find(bguid) == players.end() || !grp->IsMember(bguid))
+                        continue;
+
+                    Creature* bot = ObjectAccessor::GetCreature(*plrg, bguid);
+                    if (!bot)
+                        continue;
+
+                    SetState(bguid, LFG_STATE_ROLECHECK);
+                    if (!isContinue)
+                        SetSelectedDungeons(bguid, dungeons);
+                    roleCheck.roles[bguid] = 0;
+                    if (!debugNames.empty())
+                        debugNames.append(", ");
+                    debugNames.append(bot->GetName());
+
+                    //fill possible roles (as if player selected all roles possible for class)
+                    uint8 broles = PLAYER_ROLE_DAMAGE;
+                    if (bot->GetBotClass() == CLASS_WARRIOR || bot->GetBotClass() == CLASS_PALADIN ||
+                        bot->GetBotClass() == CLASS_DEATH_KNIGHT || bot->GetBotClass() == CLASS_DRUID ||
+                        (bot->GetBotRoles() & BOT_ROLE_TANK))
+                        broles |= PLAYER_ROLE_TANK;
+                    if (bot->GetBotClass() == CLASS_PRIEST || bot->GetBotClass() == CLASS_DRUID ||
+                        bot->GetBotClass() == CLASS_SHAMAN || bot->GetBotClass() == CLASS_PALADIN ||
+                        (bot->GetBotRoles() & BOT_ROLE_HEAL))
+                        broles |= PLAYER_ROLE_HEALER;
+                    //remove unneeded / occupied roles so players can go with role they choose
+                    if (roles & PLAYER_ROLE_TANK)
+                        broles &= ~PLAYER_ROLE_TANK;
+                    if (roles & PLAYER_ROLE_HEALER)
+                        broles &= ~PLAYER_ROLE_HEALER;
+
+                    brolemap[bguid] = broles;
+                }
+                //end npcbot
             }
         }
         // Update leader role
         UpdateRoleCheck(gguid, guid, roles);
+        //npcbot - update bots' roles
+        for (std::map<ObjectGuid, uint8>::const_iterator it = brolemap.begin(); it != brolemap.end(); ++it)
+            UpdateRoleCheck(gguid, it->first, it->second);
+        //end npcbot
     }
     else                                                   // Add player to queue
     {
@@ -716,6 +813,9 @@ void LFGMgr::UpdateRoleCheck(ObjectGuid gguid, ObjectGuid guid /* = ObjectGuid::
         if (Player* player = ObjectAccessor::FindPlayer(guid))
             roles = FilterClassRoles(player, roles);
         else
+        //npcbot: allow bots to pass through, bot roles are checked elsewhere
+        if (guid.IsPlayer())
+        //end npcbot
             return;
     }
 
@@ -967,6 +1067,63 @@ void LFGMgr::MakeNewGroup(LfgProposal const& proposal)
         if (!player)
             continue;
 
+        //npcbot - handle player's bots
+        if (player->HaveBot())
+        {
+            Group* group = player->GetGroup();
+            if (group && group != grp)
+                Player::RemoveFromGroup(group, pguid);
+
+            if (!grp)
+            {
+                grp = new Group();
+                grp->ConvertToLFG();
+                grp->Create(player);
+                ObjectGuid gguid = grp->GetGUID();
+                SetState(gguid, LFG_STATE_PROPOSAL);
+                sGroupMgr->AddGroup(grp);
+            }
+            else if (group != grp)
+                grp->AddMember(player);
+
+            grp->SetLfgRoles(pguid, proposal.players.find(pguid)->second.role);
+
+            // Add the cooldown spell if queued for a random dungeon
+            if (dungeon->type == LFG_TYPE_RANDOM)
+                player->CastSpell(player, LFG_SPELL_DUNGEON_COOLDOWN, false);
+
+            for (GuidList::const_iterator itr2 = players.begin(); itr2 != players.end(); ++itr2)
+            {
+                ObjectGuid bguid = (*itr2);
+                if (bguid.IsPlayer())
+                    continue;
+                Creature* bot = player->GetBotMgr()->GetBot(bguid);
+                if (!bot)
+                    continue;
+
+                player->GetBotMgr()->AddBotToGroup(bot);
+                grp->SetLfgRoles(bguid, proposal.players.find(bguid)->second.role);
+            }
+
+            if (grp->GetMembersCount() >= 5)
+            {
+                uint8 pcount = 0;
+                for (GroupReference const* gitr = grp->GetFirstMember(); gitr != nullptr; gitr = gitr->next())
+                    if (gitr->GetSource())
+                        ++pcount;
+                if (pcount <= 1)
+                {
+                    //only one player in group
+                    ChatHandler ch(player->GetSession());
+                    ch.SendSysMessage("You are the only player in your group, loot method set to Free For All");
+                    grp->SetLootMethod(FREE_FOR_ALL);
+                }
+            }
+
+            continue;
+        }
+        //end npcbot
+
         Group* group = player->GetGroup();
         if (group && group != grp)
             group->RemoveMember(player->GetGUID());
@@ -1041,6 +1198,29 @@ void LFGMgr::UpdateProposal(uint32 proposalId, ObjectGuid guid, bool accept)
     if (itProposalPlayer == proposal.players.end())
         return;
 
+    //npcbot - player accepted proposal
+    //make its bots accept too
+    if (accept && guid.IsPlayer())
+    {
+        if (Player* player = ObjectAccessor::FindConnectedPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                for (LfgProposalPlayerContainer::iterator itPlayers = proposal.players.begin(); itPlayers != proposal.players.end(); ++itPlayers)
+                {
+                    ObjectGuid bguid = itPlayers->first;
+                    if (bguid.IsPlayer())
+                        continue;
+                    if (!player->GetBotMgr()->GetBot(bguid))
+                        continue;
+
+                    itPlayers->second.accept = LfgAnswer(accept);
+                }
+            }
+        }
+    }
+    //end npcbot
+
     LfgProposalPlayer& player = itProposalPlayer->second;
     player.accept = LfgAnswer(accept);
 
diff --git a/src/server/game/DungeonFinding/LFGScripts.cpp b/src/server/game/DungeonFinding/LFGScripts.cpp
index 75dd4abd0..534f8fcce 100644
--- a/src/server/game/DungeonFinding/LFGScripts.cpp
+++ b/src/server/game/DungeonFinding/LFGScripts.cpp
@@ -106,6 +106,9 @@ void LFGPlayerScript::OnMapChanged(Player* player)
     {
         Group* group = player->GetGroup();
         if (group && group->GetMembersCount() == 1)
+        //npcbot
+        if (!player->GetSession()->PlayerLoading())
+        //end npcbot
         {
             sLFGMgr->LeaveLfg(group->GetGUID());
             group->Disband();
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index d7f2bec6d..77d8dcaf4 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -56,6 +56,11 @@
 CreatureMovementData::CreatureMovementData() : Ground(CreatureGroundMovementType::Run), Flight(CreatureFlightMovementType::None), Swim(true), Rooted(false), Chase(CreatureChaseMovementType::Run),
 Random(CreatureRandomMovementType::Walk), InteractionPauseTimer(sWorld->getIntConfig(CONFIG_CREATURE_STOP_FOR_PLAYER)) { }
 
+//npcbot
+#include "bot_ai.h"
+#include "bpet_ai.h"
+//end npcbot
+
 std::string CreatureMovementData::ToString() const
 {
     char const* const GroundStates[] = { "None", "Run", "Hover" };
@@ -269,6 +274,11 @@ Creature::Creature(bool isWorldObject): Unit(isWorldObject), MapObject(), m_grou
 
     ResetLootMode(); // restore default loot mode
     m_isTempWorldObject = false;
+
+    //npcbot
+    bot_AI = nullptr;
+    bot_pet_AI = nullptr;
+    //end npcbot
 }
 
 void Creature::AddToWorld()
@@ -657,6 +667,29 @@ void Creature::SetPhaseMask(uint32 newPhaseMask, bool update)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (bot_AI)
+    {
+        if (!bot_AI->canUpdate)
+        {
+            return;
+        }
+
+        bot_AI->CommonTimers(diff);
+    }
+    else if (bot_pet_AI)
+    {
+        if (!bot_pet_AI->canUpdate)
+        {
+            //needed for delayed unsummon
+            m_Events.Update(diff);
+            return;
+        }
+
+        bot_pet_AI->CommonTimers(diff);
+    }
+    //end npcbot
+
     if (IsAIEnabled() && m_triggerJustAppeared && m_deathState != DEAD)
     {
         if (m_respawnCompatibilityMode && m_vehicleKit)
@@ -679,6 +712,10 @@ void Creature::Update(uint32 diff)
             break;
         case DEAD:
         {
+            //npcbot
+            if (bot_AI || bot_pet_AI)
+                break;
+            //end npcbot
             if (!m_respawnCompatibilityMode)
             {
                 TC_LOG_ERROR("entities.unit", "Creature %s in wrong state: DEAD (3)", GetGUID().ToString().c_str());
@@ -731,6 +768,16 @@ void Creature::Update(uint32 diff)
             if (IsEngaged())
                 Unit::AIUpdateTick(diff);
 
+            //npcbot: update dead bots
+            if (bot_AI)
+            {
+                bot_AI->UpdateDeadAI(diff);
+                break;
+            }
+            else if (bot_pet_AI)
+                break;
+            //end npcbot
+
             if (m_groupLootTimer && lootingGroupLowGUID)
             {
                 if (m_groupLootTimer <= diff)
@@ -745,6 +792,10 @@ void Creature::Update(uint32 diff)
             }
             else if (m_corpseRemoveTime <= GameTime::GetGameTime())
             {
+                //npcbot: do not remove corpse
+                if (IsNPCBotOrPet())
+                    break;
+                //end npcbot
                 RemoveCorpse(false);
                 TC_LOG_DEBUG("entities.unit", "Removing corpse... %u ", GetEntry());
             }
@@ -756,6 +807,9 @@ void Creature::Update(uint32 diff)
 
             // creature can be dead after Unit::Update call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
+            //npcbot - skip dead state for bots (handled by AI)
+            if (!bot_AI && !bot_pet_AI)
+            //end npcbot
             if (!IsAlive())
                 break;
 
@@ -807,8 +861,18 @@ void Creature::Update(uint32 diff)
                 }
             }
 
+            if (bot_AI)
+            {
+                //TC_LOG_ERROR("entities.unit", "creature update for %u", m_spawnId);
+            }
+
             Unit::AIUpdateTick(diff);
 
+            //npcbot: skip regeneration
+            if (bot_AI || bot_pet_AI)
+                break;
+            //end npcbot
+
             // creature can be dead after UpdateAI call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
             if (!IsAlive())
@@ -994,6 +1058,11 @@ bool Creature::AIM_Create(CreatureAI* ai /*= nullptr*/)
 {
     Motion_Initialize();
 
+    //npcbot: prevent overriding bot_AI
+    if (bot_AI || bot_pet_AI)
+        return false;
+    //end npcbot
+
     SetAI(ai ? ai : FactorySelector::SelectAI(this));
 
     return true;
@@ -1266,7 +1335,19 @@ void Creature::SetLootRecipient(Unit* unit, bool withGroup)
     if (unit->GetTypeId() != TYPEID_PLAYER && !unit->IsVehicle())
         return;
 
+    /*
     Player* player = unit->GetCharmerOrOwnerPlayerOrPlayerItself();
+    */
+    //npcbot - loot recipient of bot's vehicle is owner
+    Player* player = nullptr;
+    if (unit->IsVehicle() && unit->GetCharmerGUID().IsCreature() && unit->GetCreatorGUID().IsPlayer())
+    {
+        if (Unit* uowner = unit->GetCreator())
+            player = uowner->ToPlayer();
+    }
+    else
+        player = unit->GetCharmerOrOwnerPlayerOrPlayerItself();
+    //end npcbot
     if (!player)                                             // normal creature, no player involved
         return;
 
@@ -1637,6 +1718,11 @@ bool Creature::LoadFromDB(ObjectGuid::LowType spawnId, Map* map, bool addToMap,
 
     m_deathState = ALIVE;
 
+    //npcbot: remove respawn time if any
+    if (IsNPCBotOrPet())
+        map->RemoveRespawnTime(SPAWN_TYPE_CREATURE, spawnId, nullptr, true);
+    //end npcbot
+
     m_respawnTime = GetMap()->GetCreatureRespawnTime(m_spawnId);
 
     if (!m_respawnTime && !map->IsSpawnGroupActive(data->spawnGroupData->groupId))
@@ -1684,6 +1770,24 @@ bool Creature::LoadFromDB(ObjectGuid::LowType spawnId, Map* map, bool addToMap,
     // checked at creature_template loading
     m_defaultMovementType = MovementGeneratorType(data->movementType);
 
+    //npcbot
+    if (IsNPCBot())
+    {
+        //prevent loading npcbot twice (grid unload/load case)
+        if (sWorld->GetMaxPlayerCount() > 0)
+            return false;
+
+        TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+        ASSERT(!IsInWorld());
+
+        //don't allow removing dead bot's corpse
+        m_respawnCompatibilityMode = true;
+        m_corpseDelay = 0;
+        m_respawnDelay = 0;
+        setActive(true);
+    }
+    //end npcbot
+
     if (addToMap && !GetMap()->AddToMap(this))
         return false;
     return true;
@@ -1697,6 +1801,11 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -1843,6 +1952,11 @@ bool Creature::IsInvisibleDueToDespawn() const
     if (IsAlive() || isDying() || m_corpseRemoveTime > GameTime::GetGameTime())
         return false;
 
+    //npcbot
+    if (bot_AI || bot_pet_AI)
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -1956,6 +2070,11 @@ void Creature::setDeathState(DeathState s)
 
     if (s == JUST_DIED)
     {
+        //npcbot
+        if (bot_AI)
+            bot_AI->UnsummonAll();
+        //end npcbot
+
         m_corpseRemoveTime = GameTime::GetGameTime() + m_corpseDelay;
 
         uint32 respawnDelay = m_respawnDelay;
@@ -2435,6 +2554,12 @@ void Creature::SaveRespawnTime(uint32 forceDelay)
         ri.type = SPAWN_TYPE_CREATURE;
         ri.spawnId = m_spawnId;
         ri.respawnTime = m_respawnTime;
+
+        //npcbot: save entry for checks
+        if (IsNPCBot())
+            ri.entry = GetEntry();
+        //end npcbot
+
         GetMap()->SaveRespawnInfoDB(ri);
         return;
     }
@@ -2596,6 +2721,16 @@ void Creature::SendZoneUnderAttackMessage(Player* attacker)
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    //npcbot - bot block value is fully calculated inside botAI
+    if (bot_AI)
+    {
+        uint32 blockValue = bot_AI->GetShieldBlockValue();
+        blockValue += GetTotalAuraModifier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE);
+        blockValue *= GetTotalAuraMultiplier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE_PCT);
+        return uint32(blockValue);
+    }
+    //end npcbot
+
     return (GetLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -3218,6 +3353,13 @@ void Creature::ReleaseSpellFocus(Spell const* focusSpell, bool withDelay)
         if (!HasUnitFlag2(UNIT_FLAG2_CANNOT_TURN))
             ReacquireSpellFocusTarget();
     }
+    //npcbot: bots and botpets do not use delay
+    else if (IsNPCBot() || IsNPCBotPet())
+    {
+        if (!HasUnitFlag2(UNIT_FLAG2_CANNOT_TURN))
+            ReacquireSpellFocusTarget();
+    }
+    //end npcbot
     else // don't allow re-target right away to prevent visual bugs
         _spellFocusInfo.Delay = withDelay ? 1000 : 1;
 
@@ -3402,3 +3544,320 @@ void Creature::ExitVehicle(Position const* /*exitPosition*/)
     // exited position so it won't run away (home) and evade if it's hostile
     SetHomePosition(GetPosition());
 }
+
+//NPCBOT
+bool Creature::LoadBotCreatureFromDB(ObjectGuid::LowType spawnId, Map* map, bool addToMap)
+{
+    CreatureData const* data = sObjectMgr->GetCreatureData(spawnId);
+    if (!data)
+    {
+        TC_LOG_ERROR("sql.sql", "Bot creature (GUID: %u) not found in table `creature`, can't load. ", spawnId);
+        return false;
+    }
+
+    m_spawnId = spawnId;
+    ASSERT(map->GetInstanceId() == 0);
+
+    m_respawnCompatibilityMode = true;
+    m_creatureData = data;
+    m_wanderDistance = data->wander_distance;
+
+    if (!Create(map->GenerateLowGuid<HighGuid::Unit>(), map, data->phaseMask, data->id, data->spawnPoint, data, 0U , !m_respawnCompatibilityMode))
+        return false;
+
+    //We should set first home position, because then AI calls home movement
+    SetHomePosition(*this);
+
+    m_deathState = ALIVE;
+    m_respawnTime = 0;
+
+    SetSpawnHealth();
+
+    // checked at creature_template loading
+    m_defaultMovementType = MovementGeneratorType(data->movementType);
+
+    TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+    ASSERT(!IsInWorld());
+
+    m_corpseDelay = 0;
+    m_respawnDelay = 0;
+    setActive(true);
+
+    if (addToMap && !GetMap()->AddToMap(this))
+        return false;
+
+    return true;
+}
+
+uint8 Creature::GetBotClass() const
+{
+    return bot_AI ? bot_AI->GetBotClass() : GetClass();
+}
+
+Player* Creature::GetBotOwner() const
+{
+    return bot_AI ? bot_AI->GetBotOwner() : bot_pet_AI ? bot_pet_AI->GetPetsOwner()->GetBotOwner() : nullptr;
+}
+Unit* Creature::GetBotsPet() const
+{
+    return bot_AI ? bot_AI->GetBotsPet() : nullptr;
+}
+
+bool Creature::IsNPCBot() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT;
+}
+
+bool Creature::IsNPCBotPet() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT_PET;
+}
+
+bool Creature::IsNPCBotOrPet() const
+{
+    return IsNPCBot() || IsNPCBotPet();
+}
+
+bool Creature::IsFreeBot() const
+{
+    return bot_AI ? bot_AI->IAmFree() : bot_pet_AI ? bot_pet_AI->IAmFree() : false;
+}
+
+uint32 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    else if (bot_pet_AI)
+        bot_pet_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+}
+void Creature::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+}
+void Creature::ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCostMods(spellInfo, cost);
+}
+void Creature::ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCastTimeMods(spellInfo, casttime);
+}
+void Creature::ApplyCreatureSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellRadiusMods(spellInfo, radius);
+    else if (bot_pet_AI)
+        bot_pet_AI->ApplyBotPetSpellRadiusMods(spellInfo, radius);
+}
+void Creature::ApplyCreatureSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellRangeMods(spellInfo, maxrange);
+}
+void Creature::ApplyCreatureSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellMaxTargetsMods(spellInfo, targets);
+}
+void Creature::ApplyCreatureSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellChanceOfSuccessMods(spellInfo, chance);
+}
+
+void Creature::ApplyCreatureEffectMods(WorldObject const* wtarget, SpellInfo const* spellInfo, uint8 effIndex, float& value) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotEffectMods(wtarget, spellInfo, effIndex, value);
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::BotStopMovement()
+{
+    if (IsInWorld())
+    {
+        GetMotionMaster()->Clear();
+        GetMotionMaster()->MoveIdle();
+    }
+    StopMoving();
+    DisableSpline();
+}
+
+bool Creature::CanParry() const
+{
+    return bot_AI ? bot_AI->CanParry() : true;
+}
+
+bool Creature::CanDodge() const
+{
+    return bot_AI ? bot_AI->CanDodge() : true;
+}
+//unused
+bool Creature::CanBlock() const
+{
+    return bot_AI ? bot_AI->CanBlock() : true;
+}
+//unused
+bool Creature::CanCrit() const
+{
+    return bot_AI ? bot_AI->CanCrit() : true;
+}
+bool Creature::CanMiss() const
+{
+    return bot_AI ? bot_AI->CanMiss() : true;
+}
+
+float Creature::GetCreatureParryChance() const
+{
+    return bot_AI ? bot_AI->GetBotParryChance() : 5.0f;
+}
+float Creature::GetCreatureDodgeChance() const
+{
+    return bot_AI ? bot_AI->GetBotDodgeChance() : 5.0f;
+}
+float Creature::GetCreatureBlockChance() const
+{
+    return bot_AI ? bot_AI->GetBotBlockChance() : 5.0f;
+}
+float Creature::GetCreatureCritChance() const
+{
+    return bot_AI ? bot_AI->GetBotCritChance() : 0.0f;
+}
+float Creature::GetCreatureMissChance() const
+{
+    return bot_AI ? bot_AI->GetBotMissChance() : 5.0f;
+}
+float Creature::GetCreatureArmorPenetrationCoef() const
+{
+    return bot_AI ? bot_AI->GetBotArmorPenetrationCoef() : 0.0f;
+}
+uint32 Creature::GetCreatureExpertise() const
+{
+    return bot_AI ? bot_AI->GetBotExpertise() : 0;
+}
+uint32 Creature::GetCreatureSpellPenetration() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPenetration() : 0;
+}
+uint32 Creature::GetCreatureSpellPower() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPower() : 0;
+}
+uint32 Creature::GetCreatureDefense() const
+{
+    return bot_AI ? bot_AI->GetBotDefense() : GetMaxSkillValueForLevel();
+}
+int32 Creature::GetCreatureResistanceBonus(SpellSchoolMask mask) const
+{
+    return bot_AI ? bot_AI->GetBotResistanceBonus(mask) : 0;
+}
+
+uint8 Creature::GetCreatureComboPoints() const
+{
+    return bot_AI ? bot_AI->GetBotComboPoints() : 0;
+}
+
+float Creature::GetCreatureAmmoDPS() const
+{
+    return bot_AI ? bot_AI->GetBotAmmoDPS() : 0.0f;
+}
+
+bool Creature::IsTempBot() const
+{
+    return bot_AI && bot_AI->IsTempBot();
+}
+
+MeleeHitOutcome Creature::BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    return bot_AI ? bot_AI->BotRollCustomMeleeOutcomeAgainst(victim, attType) : RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void Creature::CastCreatureItemCombatSpell(DamageInfo const& damageInfo)
+{
+    if (bot_AI)
+        bot_AI->CastBotItemCombatSpell(damageInfo);
+}
+
+bool Creature::HasSpellCooldown(uint32 spell_id) const
+{
+    if (bot_AI)
+        return !bot_AI->IsSpellReady(sSpellMgr->GetSpellInfo(spell_id)->GetFirstRankSpell()->Id, bot_AI->GetLastDiff(), false);
+    else if (bot_pet_AI)
+        return !bot_pet_AI->IsSpellReady(sSpellMgr->GetSpellInfo(spell_id)->GetFirstRankSpell()->Id, bot_pet_AI->GetLastDiff(), false);
+
+    return false;
+}
+void Creature::AddBotSpellCooldown(uint32 spellId, uint32 cooldown)
+{
+    if (bot_AI)
+        bot_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+    else if (bot_pet_AI)
+        bot_pet_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+}
+void Creature::ReleaseBotSpellCooldown(uint32 spellId)
+{
+    if (bot_AI)
+        bot_AI->ReleaseSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id);
+    else if (bot_pet_AI)
+        bot_pet_AI->ReleaseSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id);
+}
+
+void Creature::SpendBotRunes(SpellInfo const* spellInfo, bool didHit)
+{
+    if (bot_AI)
+        bot_AI->SpendRunes(spellInfo, didHit);
+}
+
+//equips
+Item* Creature::GetBotEquips(uint8 slot) const
+{
+    return bot_AI ? bot_AI->GetEquips(slot) : nullptr;
+}
+Item* Creature::GetBotEquipsByGuid(ObjectGuid itemGuid) const
+{
+    return bot_AI ? bot_AI->GetEquipsByGuid(itemGuid) : nullptr;
+}
+float Creature::GetBotAverageItemLevel() const
+{
+    return bot_AI ? bot_AI->GetAverageItemLevel() : 0.0f;
+}
+
+//static
+bool Creature::IsBotCustomSpell(uint32 spellId)
+{
+    return bot_ai::IsBotCustomSpell(spellId);
+}
+//END NPCBOT
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 8a65ca537..8b2c02612 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -28,6 +28,11 @@
 #include "MapObject.h"
 #include <list>
 
+// npcbot
+class bot_ai;
+class bot_pet_ai;
+//end npcbot
+
 class CreatureAI;
 class CreatureGroup;
 class Group;
@@ -374,6 +379,75 @@ class TC_GAME_API Creature : public Unit, public GridObject<Creature>, public Ma
 
         void ExitVehicle(Position const* exitPosition = nullptr) override;
 
+        //NPCBots
+        bool LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap = true);
+        Player* GetBotOwner() const;
+        Unit* GetBotsPet() const;
+        bool IsNPCBot() const;
+        bool IsNPCBotPet() const;
+        bool IsNPCBotOrPet() const;
+        bool IsFreeBot() const;
+        uint8 GetBotClass() const;
+        uint32 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_pet_ai* GetBotPetAI() const { return bot_pet_AI; }
+        void SetBotAI(bot_ai* ai) { bot_AI = ai; }
+        void SetBotPetAI(bot_pet_ai* ai) { bot_pet_AI = ai; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyCreatureSpellRadiusMods(SpellInfo const* spellInfo, float& radius) const;
+        void ApplyCreatureSpellRangeMods(SpellInfo const* spellInfo, float& maxrange) const;
+        void ApplyCreatureSpellMaxTargetsMods(SpellInfo const* spellInfo, uint32& targets) const;
+        void ApplyCreatureSpellChanceOfSuccessMods(SpellInfo const* spellInfo, float& chance) const;
+        void ApplyCreatureEffectMods(WorldObject const* wtarget, SpellInfo const* spellInfo, uint8 effIndex, float& value) const;
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void BotStopMovement();
+
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanBlock() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+
+        float GetCreatureParryChance() const;
+        float GetCreatureDodgeChance() const;
+        float GetCreatureBlockChance() const;
+        float GetCreatureCritChance() const;
+        float GetCreatureMissChance() const;
+        float GetCreatureArmorPenetrationCoef() const;
+        uint32 GetCreatureExpertise() const;
+        uint32 GetCreatureSpellPenetration() const;
+        uint32 GetCreatureSpellPower() const;
+        uint32 GetCreatureDefense() const;
+        int32 GetCreatureResistanceBonus(SpellSchoolMask mask) const;
+        uint8 GetCreatureComboPoints() const;
+        float GetCreatureAmmoDPS() const;
+
+        bool IsTempBot() const;
+
+        MeleeHitOutcome BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        void CastCreatureItemCombatSpell(DamageInfo const& damageInfo);
+
+        bool HasSpellCooldown(uint32 spellId) const;
+        void AddBotSpellCooldown(uint32 spellId, uint32 cooldown);
+        void ReleaseBotSpellCooldown(uint32 spellId);
+
+        void SpendBotRunes(SpellInfo const* spellInfo, bool didHit);
+
+        Item* GetBotEquips(uint8 slot) const;
+        Item* GetBotEquipsByGuid(ObjectGuid itemGuid) const;
+        float GetBotAverageItemLevel() const;
+
+        static bool IsBotCustomSpell(uint32 spellId);
+        //End NPCBots
+
     protected:
         bool CreateFromProto(ObjectGuid::LowType guidlow, uint32 entry, CreatureData const* data = nullptr, uint32 vehId = 0);
         bool InitEntry(uint32 entry, CreatureData const* data = nullptr);
@@ -428,6 +502,11 @@ class TC_GAME_API Creature : public Unit, public GridObject<Creature>, public Ma
         bool CanAlwaysSee(WorldObject const* obj) const override;
 
     private:
+        //bot system
+        bot_ai* bot_AI;
+        bot_pet_ai* bot_pet_AI;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0, Seconds forceRespawnTimer = 0s);
         bool CheckNoGrayAggroConfig(uint32 playerLevel, uint32 creatureLevel) const; // No aggro from gray creatures
 
diff --git a/src/server/game/Entities/Creature/CreatureData.h b/src/server/game/Entities/Creature/CreatureData.h
index 96c6e2a7c..a58011f50 100644
--- a/src/server/game/Entities/Creature/CreatureData.h
+++ b/src/server/game/Entities/Creature/CreatureData.h
@@ -204,8 +204,8 @@ enum CreatureFlagsExtra : uint32
     CREATURE_FLAG_EXTRA_UNUSED_23            = 0x00800000,
     CREATURE_FLAG_EXTRA_UNUSED_24            = 0x01000000,
     CREATURE_FLAG_EXTRA_UNUSED_25            = 0x02000000,
-    CREATURE_FLAG_EXTRA_UNUSED_26            = 0x04000000,
-    CREATURE_FLAG_EXTRA_UNUSED_27            = 0x08000000,
+    CREATURE_FLAG_EXTRA_NPCBOT               = 0x04000000,       // custom flag for NPCBots (not confirmed safe)
+    CREATURE_FLAG_EXTRA_NPCBOT_PET           = 0x08000000,       // custom flag for NPCBot pets (not confirmed safe)
     CREATURE_FLAG_EXTRA_DUNGEON_BOSS         = 0x10000000,       // creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)
     CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING   = 0x20000000,       // creature ignore pathfinding
     CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK   = 0x40000000,       // creature is immune to knockback effects
@@ -214,7 +214,7 @@ enum CreatureFlagsExtra : uint32
     // Masks
     CREATURE_FLAG_EXTRA_UNUSED               = (CREATURE_FLAG_EXTRA_UNUSED_22 |
                                                 CREATURE_FLAG_EXTRA_UNUSED_23 | CREATURE_FLAG_EXTRA_UNUSED_24 | CREATURE_FLAG_EXTRA_UNUSED_25 |
-                                                CREATURE_FLAG_EXTRA_UNUSED_26 | CREATURE_FLAG_EXTRA_UNUSED_27 | CREATURE_FLAG_EXTRA_UNUSED_31), // SKIP
+                                                CREATURE_FLAG_EXTRA_UNUSED_31), // SKIP
 
     CREATURE_FLAG_EXTRA_DB_ALLOWED           = (0xFFFFFFFF & ~(CREATURE_FLAG_EXTRA_UNUSED | CREATURE_FLAG_EXTRA_DUNGEON_BOSS)) // SKIP
 };
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 8bac61ba1..2c9bf0caa 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -26,6 +26,10 @@
 #include "Pet.h"
 #include "Player.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 TempSummon::TempSummon(SummonPropertiesEntry const* properties, WorldObject* owner, bool isWorldObject) :
 Creature(isWorldObject), m_Properties(properties), m_type(TEMPSUMMON_MANUAL_DESPAWN),
 m_timer(0), m_lifetime(0), m_canFollowOwner(true), m_visibleBySummonerOnly(false)
@@ -196,6 +200,12 @@ void TempSummon::InitStats(uint32 duration)
     if (!m_Properties)
         return;
 
+    //npcbot: skip deleting/reassigning player totems
+    //normally no creatorGUID is assigned at this point, perform full check anyway for compatibilty reasons
+    if (!(m_Properties->Slot && m_Properties->Slot >= SUMMON_SLOT_TOTEM_FIRE && m_Properties->Slot < MAX_TOTEM_SLOT &&
+        GetCreatorGUID() && GetCreatorGUID().IsCreature() && owner && owner->GetTypeId() == TYPEID_PLAYER &&
+        owner->ToPlayer()->HaveBot() && owner->ToPlayer()->GetBotMgr()->GetBot(GetCreatorGUID())))
+    //end npcbot
     if (owner)
     {
         if (uint32 slot = m_Properties->Slot)
@@ -272,6 +282,19 @@ void TempSummon::UnSummon(uint32 msTime)
             owner->ToGameObject()->AI()->SummonedCreatureDespawn(this);
     }
 
+    //npcbot
+    //if (IsNPCBot())
+    //{
+    //    //TC_LOG_ERROR("entities.player", "TempSummon::UnSummon(): Trying to unsummon Bot %s (guidLow: %u owner: %s)", GetName().c_str(), GetGUIDLow(), GetBotOwner()->GetName().c_str());
+    //    if (IsTempBot())
+    //        if (IS_CREATURE_GUID(GetCreatorGUID()))
+    //            if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+    //                if (bot->ToCreature()->IsNPCBot())
+    //                    bot->ToCreature()->OnBotDespawn(this);
+    //    return;
+    //}
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
@@ -322,6 +345,15 @@ void Minion::InitStats(uint32 duration)
 
     SetReactState(REACT_PASSIVE);
 
+    //npcbot
+    //do not add bot totem to player's controlled list
+    //client indicator will be OwnerGUID
+    if (m_Properties && m_Properties->Slot && m_Properties->Slot >= SUMMON_SLOT_TOTEM_FIRE && m_Properties->Slot < MAX_TOTEM_SLOT &&
+        GetCreatorGUID() && GetCreatorGUID().IsCreature() && GetOwner() && GetOwner()->GetTypeId() == TYPEID_PLAYER &&
+        GetOwner()->ToPlayer()->HaveBot() && GetOwner()->ToPlayer()->GetBotMgr()->GetBot(GetCreatorGUID()))
+        return;
+    //end npcbot
+
     SetCreatorGUID(GetOwner()->GetGUID());
     SetFaction(GetOwner()->GetFaction());
 
diff --git a/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp b/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp
index 13fcc0cb5..e5cc13d60 100644
--- a/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp
+++ b/src/server/game/Entities/Creature/enuminfo_CreatureData.cpp
@@ -57,8 +57,8 @@ TC_API_EXPORT EnumText EnumUtils<CreatureFlagsExtra>::ToString(CreatureFlagsExtr
         case CREATURE_FLAG_EXTRA_UNUSED_23: return { "CREATURE_FLAG_EXTRA_UNUSED_23", "CREATURE_FLAG_EXTRA_UNUSED_23", "" };
         case CREATURE_FLAG_EXTRA_UNUSED_24: return { "CREATURE_FLAG_EXTRA_UNUSED_24", "CREATURE_FLAG_EXTRA_UNUSED_24", "" };
         case CREATURE_FLAG_EXTRA_UNUSED_25: return { "CREATURE_FLAG_EXTRA_UNUSED_25", "CREATURE_FLAG_EXTRA_UNUSED_25", "" };
-        case CREATURE_FLAG_EXTRA_UNUSED_26: return { "CREATURE_FLAG_EXTRA_UNUSED_26", "CREATURE_FLAG_EXTRA_UNUSED_26", "" };
-        case CREATURE_FLAG_EXTRA_UNUSED_27: return { "CREATURE_FLAG_EXTRA_UNUSED_27", "CREATURE_FLAG_EXTRA_UNUSED_27", "" };
+        case CREATURE_FLAG_EXTRA_NPCBOT: return { "CREATURE_FLAG_EXTRA_NPCBOT", "CREATURE_FLAG_EXTRA_NPCBOT", "creature is a NPCBot" };
+        case CREATURE_FLAG_EXTRA_NPCBOT_PET: return { "CREATURE_FLAG_EXTRA_NPCBOT_PET", "CREATURE_FLAG_EXTRA_NPCBOT_PET", "creature is a NPCBot's pet" };
         case CREATURE_FLAG_EXTRA_DUNGEON_BOSS: return { "CREATURE_FLAG_EXTRA_DUNGEON_BOSS", "CREATURE_FLAG_EXTRA_DUNGEON_BOSS", "creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)" };
         case CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING: return { "CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING", "CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING", "creature ignore pathfinding" };
         case CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK: return { "CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK", "CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK", "creature is immune to knockback effects" };
@@ -101,8 +101,8 @@ TC_API_EXPORT CreatureFlagsExtra EnumUtils<CreatureFlagsExtra>::FromIndex(size_t
         case 23: return CREATURE_FLAG_EXTRA_UNUSED_23;
         case 24: return CREATURE_FLAG_EXTRA_UNUSED_24;
         case 25: return CREATURE_FLAG_EXTRA_UNUSED_25;
-        case 26: return CREATURE_FLAG_EXTRA_UNUSED_26;
-        case 27: return CREATURE_FLAG_EXTRA_UNUSED_27;
+        case 26: return CREATURE_FLAG_EXTRA_NPCBOT;
+        case 27: return CREATURE_FLAG_EXTRA_NPCBOT_PET;
         case 28: return CREATURE_FLAG_EXTRA_DUNGEON_BOSS;
         case 29: return CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING;
         case 30: return CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK;
@@ -142,8 +142,8 @@ TC_API_EXPORT size_t EnumUtils<CreatureFlagsExtra>::ToIndex(CreatureFlagsExtra v
         case CREATURE_FLAG_EXTRA_UNUSED_23: return 23;
         case CREATURE_FLAG_EXTRA_UNUSED_24: return 24;
         case CREATURE_FLAG_EXTRA_UNUSED_25: return 25;
-        case CREATURE_FLAG_EXTRA_UNUSED_26: return 26;
-        case CREATURE_FLAG_EXTRA_UNUSED_27: return 27;
+        case CREATURE_FLAG_EXTRA_NPCBOT: return 26;
+        case CREATURE_FLAG_EXTRA_NPCBOT_PET: return 27;
         case CREATURE_FLAG_EXTRA_DUNGEON_BOSS: return 28;
         case CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING: return 29;
         case CREATURE_FLAG_EXTRA_IMMUNITY_KNOCKBACK: return 30;
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 056ced889..8aa8702a2 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1001,6 +1001,11 @@ void WorldObject::setActive(bool on)
     if (GetTypeId() == TYPEID_PLAYER)
         return;
 
+    //npcbot: bots should never be removed from active
+    if (on == false && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return;
+    //end npcbot
+
     m_isActive = on;
 
     if (on && !IsInWorld())
@@ -1645,7 +1650,9 @@ bool WorldObject::CanDetect(WorldObject const* obj, bool ignoreStealth, bool che
 {
     WorldObject const* seer = this;
 
-    // If a unit is possessing another one, it uses the detection of the latter
+    //npcbot: master's invisibility should not affect bots' sight
+    if (!(GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot()))
+    //end npcbot
     // Pets don't have detection, they use the detection of their masters
     if (Unit const* thisUnit = ToUnit())
     {
@@ -1928,6 +1935,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summonerUnit);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summonerUnit);
             break;
         case UNIT_MASK_MINION:
@@ -1941,6 +1953,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
         return nullptr;
     }
 
+    //npcbot: totem emul step 2
+    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+        summon->SetCreatorGUID(summoner->GetGUID()); // see TempSummon::InitStats()
+    //end npcbot
+
     summon->SetCreatedBySpell(spellId);
 
     summon->SetHomePosition(pos);
@@ -1952,6 +1969,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 3
+    if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->IsNPCBot())
+        summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     // call MoveInLineOfSight for nearby creatures
     Trinity::AIRelocationNotifier notifier(*summon);
     Cell::VisitAllObjects(summon, notifier, GetVisibilityRange());
@@ -2279,12 +2301,36 @@ float WorldObject::ApplyEffectModifiers(SpellInfo const* spellInfo, uint8 effInd
                 break;
         }
     }
+
+    //npcbot: handle effect mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyCreatureEffectMods(this, spellInfo, effIndex, value);
+    //end npcbot
+
     return value;
 }
 
 int32 WorldObject::CalcSpellDuration(SpellInfo const* spellInfo) const
 {
     uint8 comboPoints = 0;
+    //npcbot
+    if (ToCreature() && ToCreature()->IsNPCBot())
+        comboPoints = ToCreature()->GetCreatureComboPoints();
+    else
+    //npcbot: combo points support for spell duration (vehicle)
+    if (ToCreature() && ToCreature()->IsVehicle() && ToCreature()->GetCharmerGUID().IsCreature() &&
+        spellInfo->GetDuration() != spellInfo->GetMaxDuration())
+    {
+        Unit const* bot = ToCreature()->GetCharmer();
+        if (bot && bot->ToCreature()->IsNPCBot())
+        {
+            comboPoints = bot->ToCreature()->GetCreatureComboPoints();
+            //TC_LOG_ERROR("scripts", "CalcSpellDuration bot %s veh spell %u cp %u",
+            //    bot->GetName().c_str(), spellProto->Id, uint32(comboPoints));
+        }
+    }
+    else
+    //end npcbot
     if (Unit const* unit = ToUnit())
         comboPoints = unit->GetComboPoints();
 
@@ -2403,6 +2449,11 @@ void WorldObject::ModSpellCastTime(SpellInfo const* spellInfo, int32& castTime,
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, castTime, spell);
 
+    //npcbot - apply bot spell cast time mods
+    if (castTime > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellInfo, castTime);
+    //end npcbot
+
     Unit const* unitCaster = ToUnit();
     if (!unitCaster)
         return;
@@ -2428,6 +2479,11 @@ void WorldObject::ModSpellDurationTime(SpellInfo const* spellInfo, int32& durati
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, duration, spell);
 
+    //npcbot - apply bot spell cast time mods
+    if (duration > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellInfo, duration);
+    //end npcbot
+
     Unit const* unitCaster = ToUnit();
     if (!unitCaster)
         return;
@@ -2496,6 +2552,11 @@ SpellMissInfo WorldObject::MagicSpellHitResult(Unit* victim, SpellInfo const* sp
     if (Unit const* unit = ToUnit())
         HitChance += int32(unit->m_modSpellHitChance * 100.0f);
 
+    //npcbot: spell hit chance bonus
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        HitChance -= int32(ToCreature()->GetCreatureMissChance() * 100.f);
+    //end npcbot
+
     RoundToInterval(HitChance, 0, 10000);
 
     int32 tmp = 10000 - HitChance;
@@ -2827,6 +2888,15 @@ SpellCastResult WorldObject::CastSpell(CastSpellTargetArg const& targets, uint32
         return SPELL_FAILED_BAD_TARGETS;
     }
 
+    //npcbot
+    if (Creature::IsBotCustomSpell(spellId) && !(ToCreature() && (ToCreature()->IsNPCBot() || ToCreature()->IsNPCBotPet())))
+    {
+        TC_LOG_ERROR("entities.unit", "CastSpell: NpcBot system custom spell %u by caster: %s), aborted. Please report",
+            spellId, GetGUID().ToString().c_str());
+        return SPELL_FAILED_SPELL_UNAVAILABLE;
+    }
+    //end npcbot
+
     Spell* spell = new Spell(this, info, args.TriggerFlags, args.OriginalCaster);
     for (auto const& pair : args.SpellValueOverrides)
         spell->SetSpellValue(pair.first, pair.second);
@@ -2856,6 +2926,11 @@ bool WorldObject::IsValidAttackTarget(WorldObject const* target, SpellInfo const
     if (target->GetTypeId() == TYPEID_PLAYER && target->ToPlayer()->IsGameMaster())
         return false;
 
+    //npcbot: can't attack unit if controlled by a GM (bots, pets, possible others)
+    if (unitTarget && unitTarget->IsControlledByPlayer() && unitTarget->GetFaction() == 35)
+        return false;
+    //end npcbot
+
     Unit const* unit = ToUnit();
     // visibility checks (only units)
     if (unit)
@@ -2907,6 +2982,14 @@ bool WorldObject::IsValidAttackTarget(WorldObject const* target, SpellInfo const
             return false;
     }
 
+    //npcbot: CvC case fix for bots, still a TODO
+    if (unit && unitTarget && !unit->HasUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED) &&
+        !unitTarget->HasUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED) &&
+        ((GetTypeId() == TYPEID_UNIT && (ToCreature()->IsNPCBot() || ToCreature()->IsNPCBotPet())) ||
+        (target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->IsNPCBot() || target->ToCreature()->IsNPCBotPet()))))
+        return GetReactionTo(target) <= REP_NEUTRAL || target->GetReactionTo(this) <= REP_NEUTRAL;
+    //end npcbot
+
     // CvC case - can attack each other only when one of them is hostile
     if (unit && !unit->HasUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED) && unitTarget && !unitTarget->HasUnitFlag(UNIT_FLAG_PLAYER_CONTROLLED))
         return IsHostileTo(unitTarget) || unitTarget->IsHostileTo(this);
diff --git a/src/server/game/Entities/Player/KillRewarder.cpp b/src/server/game/Entities/Player/KillRewarder.cpp
index 65b9fffc0..37c8714c5 100644
--- a/src/server/game/Entities/Player/KillRewarder.cpp
+++ b/src/server/game/Entities/Player/KillRewarder.cpp
@@ -26,6 +26,10 @@
 #include "Pet.h"
 #include "Player.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
  // == KillRewarder ====================================================
  // KillRewarder encapsulates logic of rewarding player upon kill with:
  // * XP;
@@ -153,6 +157,17 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         // 4.2.2. Apply auras modifying rewarded XP (SPELL_AURA_MOD_XP_PCT).
         xp *= player->GetTotalAuraMultiplier(SPELL_AURA_MOD_XP_PCT);
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_reduction = BotMgr::GetNpcBotXpReduction())
+            {
+                uint32 ratePct = std::max<int32>(100 - ((player->GetNpcBotsCount() - 1) * xp_reduction), 10);
+                xp = xp * ratePct / 100;
+            }
+        }
+        //end npcbot
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 444f00206..079660055 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -104,6 +104,11 @@
 #include "WorldSession.h"
 #include "WorldStatePackets.h"
 
+//npcbot
+#include "botmgr.h"
+#include "botdatamgr.h"
+//end npcbot
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -399,6 +404,10 @@ Player::Player(WorldSession* session): Unit(true)
     m_reputationMgr = new ReputationMgr(this);
 
     m_groupUpdateTimer.Reset(5000);
+
+    /////////////// NPCBot System //////////////////
+    _botMgr = nullptr;
+    ///////////// End NPCBot System ////////////////
 }
 
 Player::~Player()
@@ -435,6 +444,14 @@ Player::~Player()
     delete m_reputationMgr;
     delete _cinematicMgr;
 
+    //npcbot
+    if (_botMgr)
+    {
+        delete _botMgr;
+        _botMgr = nullptr;
+    }
+    //end npcbot
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1346,6 +1363,10 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+    //NpcBot mod: Update
+    if (_botMgr)
+        _botMgr->Update(p_time);
+    //end Npcbot
 }
 
 void Player::setDeathState(DeathState s)
@@ -1796,6 +1817,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
+            //bot: teleport npcbots
+            if (HaveBot())
+                _botMgr->OnTeleportFar(mapid, x, y, z, orientation);
+            //end bot
+
             // remove all dyn objects
             RemoveAllDynObjects();
 
@@ -1991,6 +2017,25 @@ bool Player::IsImmunedToSpellEffect(SpellInfo const* spellInfo, SpellEffectInfo
     return Unit::IsImmunedToSpellEffect(spellInfo, spellEffectInfo, caster, requireImmunityPurgesEffectAttribute);
 }
 
+//NPCBOT
+bool Player::HaveBot() const
+{
+    return _botMgr && _botMgr->HaveBot();
+}
+uint8 Player::GetNpcBotsCount() const
+{
+    return _botMgr ? _botMgr->GetNpcBotsCount() : 0;
+}
+void Player::RemoveAllBots(uint8 removetype)
+{
+    if (_botMgr) _botMgr->RemoveAllBots(removetype);
+}
+void Player::UpdatePhaseForBots()
+{
+    if (_botMgr) _botMgr->UpdatePhaseForBots();
+}
+//END NPCBOT
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2293,6 +2338,11 @@ Creature* Player::GetNPCIfCanInteractWith(ObjectGuid const& guid, NPCFlags npcFl
     if (creature->GetCharmerGUID())
         return nullptr;
 
+    //npcbot
+    if (creature->IsNPCBot() && creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        return creature;
+    //end npcbot
+
     // not unfriendly/hostile
     if (creature->GetReactionTo(this) <= REP_UNFRIENDLY)
         return nullptr;
@@ -2416,6 +2466,11 @@ void Player::SetGameMaster(bool on)
         m_serverSideVisibilityDetect.SetValue(SERVERSIDE_VISIBILITY_GM, SEC_PLAYER);
     }
 
+    //npcbot: pet is handled already, bots are not, so do it
+    if (HaveBot())
+        _botMgr->OnOwnerSetGameMaster(on);
+    //end npcbot
+
     UpdateObjectVisibility();
 }
 
@@ -2497,6 +2552,64 @@ void Player::RemoveFromGroup(Group* group, ObjectGuid guid, RemoveMethod method
     if (!group)
         return;
 
+    //npcbot - player is being removed from group - remove bots from that group
+    if (Player* player = ObjectAccessor::FindPlayer(guid))
+    {
+        if (player->HaveBot())
+        {
+            //uint8 players = 0;
+            //Group::MemberSlotList const& members = group->GetMemberSlots();
+            //for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+            //{
+            //    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+            //        ++players;
+            //}
+
+            //remove npcbots and set up new group if needed
+            player->GetBotMgr()->RemoveAllBotsFromGroup();
+            group = player->GetGroup();
+            if (!group)
+                return; //group has been disbanded
+        }
+    }
+    //npcbot - deleting player from db: remove bots
+    else if (guid.IsPlayer())
+    {
+        std::vector<ObjectGuid> botguids;
+        botguids.reserve(BotMgr::GetMaxNpcBots() / 2 + 1);
+        BotDataMgr::GetNPCBotGuidsByOwner(botguids, guid);
+        for (std::vector<ObjectGuid>::const_iterator ci = botguids.begin(); ci != botguids.end(); ++ci)
+        {
+            if (group->IsMember(*ci))
+            {
+                if (!group->RemoveMember(*ci, method, kicker, reason))
+                    return;
+            }
+        }
+    }
+    //npcbot - bot is being removed from group - find master and remove bot through botmap
+    //else if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Creature*)NULL))
+    else if (guid.IsCreature())
+    {
+        for (GroupReference* itr = group->GetFirstMember(); itr != nullptr; itr = itr->next())
+        {
+            if (Player* member = itr->GetSource())
+            {
+                if (!member->HaveBot())
+                    continue;
+
+                if (Creature* bot = member->GetBotMgr()->GetBot(guid))
+                {
+                    member->GetBotMgr()->RemoveBotFromGroup(bot);
+                    return;
+                }
+            }
+        }
+        //ASSERT(!bot->IsFreeBot());
+        //bot->GetBotOwner()->GetBotMgr()->RemoveBotFromGroup(bot, false);
+        //return;
+    }
+
     group->RemoveMember(guid, method, kicker, reason);
 }
 
@@ -2665,6 +2778,11 @@ void Player::GiveLevel(uint8 level)
     SendQuestGiverStatusMultiple();
 
     sScriptMgr->OnPlayerLevelChanged(this, oldLevel);
+
+    //npcbot: force bots to update stats
+    if (HaveBot())
+        _botMgr->SetBotsShouldUpdateStats();
+    //end npcbot
 }
 
 bool Player::IsMaxLevel() const
@@ -4405,6 +4523,12 @@ void Player::DeleteFromDB(ObjectGuid playerguid, uint32 accountId, bool updateRe
             trans->Append(stmt);
 
             Corpse::DeleteFromDB(playerguid, trans);
+
+            //npcbot - erase npcbots
+            uint32 newOwner = 0;
+            BotDataMgr::UpdateNpcBotDataAll(guid, NPCBOT_UPDATE_OWNER, &newOwner);
+            //end npcbot
+
             break;
         }
         // The character gets unlinked from the account, the name gets freed up and appears as deleted ingame
@@ -6813,6 +6937,36 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_SPECIAL_PVP_KILL, 1, 0, victim);
         }
+        //npcbot: honor for bots
+        else if (victim->ToCreature()->IsNPCBot() && !victim->ToCreature()->IsTempBot())
+        {
+            Creature const* bot = victim->ToCreature();
+
+            uint32 check1 = GetFaction();
+            uint32 check2 = bot->GetFaction();
+
+            if (!bot->IsFreeBot())
+            {
+                check1 = GetTeam();
+                check2 = bot->GetBotOwner()->GetTeam();
+            }
+
+            if (check1 == check2 && !sWorld->IsFFAPvPRealm())
+                return false;
+
+            uint8 k_level = GetLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->GetLevel();
+
+            if (v_level <= k_grey)
+                return false;
+
+            victim_guid.Clear(); // Don't show HK: <rank> message, only log.
+
+            //TODO: honor gain rate
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+        }
+        //end npcbot
         else
         {
             if (!victim->ToCreature()->IsRacialLeader())
@@ -21723,6 +21877,18 @@ bool Player::BuyItemFromVendorSlot(ObjectGuid vendorguid, uint32 vendorslot, uin
         return false;
     }
 
+    // npcbot
+    if (HaveBot())
+    {
+        if (!(pProto->AllowableClass & (GetClassMask() | GetBotMgr()->GetAllNpcBotsClassMask())) &&
+            pProto->Bonding == BIND_WHEN_PICKED_UP && !IsGameMaster())
+        {
+            SendBuyError(BUY_ERR_CANT_FIND_ITEM, nullptr, item, 0);
+            return false;
+        }
+    }
+    else
+    // end npcbot
     if (!(pProto->AllowableClass & GetClassMask()) && pProto->Bonding == BIND_WHEN_PICKED_UP && !IsGameMaster())
     {
         SendBuyError(BUY_ERR_CANT_FIND_ITEM, nullptr, item, 0);
@@ -21996,6 +22162,11 @@ void Player::UpdatePvP(bool state, bool _override)
         pvpInfo.EndTimer = GameTime::GetGameTime();
         SetPvP(state);
     }
+
+    //npcbot: update pvp flags for bots
+    if (HaveBot())
+        _botMgr->UpdatePvPForBots();
+    //end npcbot
 }
 
 void Player::UpdatePotionCooldown(Spell* spell)
@@ -23860,6 +24031,11 @@ bool Player::isHonorOrXPTarget(Unit* victim) const
 
     if (Creature const* creature = victim->ToCreature())
     {
+        //npcbot: count npcbots at xp targets (DEPRECATED)
+        if (victim->ToCreature()->IsNPCBotOrPet())
+            return true;
+        //end npcbots
+
         if (creature->IsCritter() || creature->IsTotem())
             return false;
     }
@@ -24268,6 +24444,21 @@ bool Player::inRandomLfgDungeon() const
 
 void Player::SetBattlegroundOrBattlefieldRaid(Group* group, int8 subgroup)
 {
+    //npcbot: add bots to new group
+    if (HaveBot() && GetGroup())
+    {
+        BotMap const* map = GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature const* bot = itr->second;
+            if (!bot || !GetGroup()->IsMember(bot->GetGUID()))
+                continue;
+
+            ASSERT(group->AddMember((Player*)bot));
+        }
+    }
+    //end npcbot
+
     //we must move references from m_group to m_originalGroup
     SetOriginalGroup(GetGroup(), GetSubGroup());
 
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 673374441..2ef6a37c8 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -81,6 +81,10 @@ enum ItemClass : uint8;
 enum LootError : uint8;
 enum LootType : uint8;
 
+// NpcBot mod
+class BotMgr;
+// end NpcBot mod
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2195,6 +2199,19 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
 
         std::string GetDebugInfo() const override;
 
+        /*****************************************************************/
+        /***                        NPCBOT SYSTEM                      ***/
+        /*****************************************************************/
+        void SetBotMgr(BotMgr* mgr) { ASSERT (!_botMgr); _botMgr = mgr; }
+        BotMgr* GetBotMgr() const { return _botMgr; }
+        bool HaveBot() const;
+        uint8 GetNpcBotsCount() const;
+        void RemoveAllBots(uint8 removetype = 0);
+        void UpdatePhaseForBots();
+        /*****************************************************************/
+        /***                      END NPCBOT SYSTEM                    ***/
+        /*****************************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         GuidList WhisperList;
@@ -2450,6 +2467,14 @@ class TC_GAME_API Player : public Unit, public GridObject<Player>
         TimeTracker m_groupUpdateTimer;
 
     private:
+        /*****************************************************************/
+        /***                        NPCBOT SYSTEM                      ***/
+        /*****************************************************************/
+        BotMgr* _botMgr;
+        /*****************************************************************/
+        /***                      END NPCBOT SYSTEM                    ***/
+        /*****************************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index 08cf8ca86..2b3be75d4 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -25,6 +25,11 @@
 #include "SpellInfo.h"
 #include "TotemPackets.h"
 
+//npcbot
+#include "botmgr.h"
+#include "ObjectAccessor.h"
+//end npcbot
+
 Totem::Totem(SummonPropertiesEntry const* properties, Unit* owner) : Minion(properties, owner, false)
 {
     m_unitTypeMask |= UNIT_MASK_TOTEM;
@@ -34,6 +39,20 @@ Totem::Totem(SummonPropertiesEntry const* properties, Unit* owner) : Minion(prop
 
 void Totem::Update(uint32 time)
 {
+    //npcbot: do not despawn bot totem if master is dead
+    Creature const* botOwner = (GetOwner()->GetTypeId() == TYPEID_PLAYER && GetOwner()->ToPlayer()->HaveBot()) ?
+        GetOwner()->ToPlayer()->GetBotMgr()->GetBot(GetCreatorGUID()) : nullptr;
+
+    if (botOwner)
+    {
+        if (!botOwner->IsAlive() || !IsAlive())
+        {
+            UnSummon();
+            return;
+        }
+    }
+    else
+    //end npcbot
     if (!GetOwner()->IsAlive() || !IsAlive())
     {
         UnSummon();                                         // remove self
@@ -152,6 +171,13 @@ void Totem::UnSummon(uint32 msTime)
     if (IsAlive())
         setDeathState(DEAD);
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (GetCreatorGUID() && GetCreatorGUID().IsCreature())
+        if (Creature* bot = ObjectAccessor::GetCreature(*GetOwner(), GetCreatorGUID()))
+            if (bot->IsNPCBot())
+                bot->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index 142affc27..1309ad38a 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -1110,16 +1110,58 @@ void Creature::CalculateMinMaxDamage(WeaponAttackType attType, bool normalized,
     float weaponMinDamage = GetWeaponDamageRange(attType, MINDAMAGE);
     float weaponMaxDamage = GetWeaponDamageRange(attType, MAXDAMAGE);
 
+    //npcbot: support for feral form
+    if (IsNPCBot() && IsInFeralForm())
+    {
+        float att_speed = GetAPMultiplier(attType, false);
+        uint8 lvl = GetLevel();
+        if (lvl > 60)
+            lvl = 60;
+
+        weaponMinDamage = lvl*0.85f*att_speed;
+        weaponMaxDamage = lvl*1.25f*att_speed;
+    }
+    else
+    //end npcbot
     if (!CanUseAttackType(attType)) // disarm case
     {
+        //npcbot: mimic player-like disarm (retain damage)
+        if (IsNPCBot())
+        {
+            // Main hand melee is always usable, but disarm reduces damage drastically
+            if (attType == BASE_ATTACK)
+            {
+                weaponMinDamage *= 0.25f;
+                weaponMaxDamage *= 0.25f;
+            }
+            else
+            {
+                weaponMinDamage = 0.0f;
+                weaponMaxDamage = 0.0f;
+            }
+        }
+        else
+        {
+        //end npcbot
         weaponMinDamage = 0.0f;
         weaponMaxDamage = 0.0f;
+        //npcbot
+        }
+    }
+    //end npcbot
+    //npcbot: support for ammo
+    else if (attType == RANGED_ATTACK)
+    {
+        float att_speed = GetAPMultiplier(attType, false);
+        weaponMinDamage += GetCreatureAmmoDPS() * att_speed;
+        weaponMaxDamage += GetCreatureAmmoDPS() * att_speed;
+    //end npcbot
     }
 
     float attackPower      = GetTotalAttackPowerValue(attType);
     float attackSpeedMulti = GetAPMultiplier(attType, normalized);
-    float baseValue        = GetFlatModifierValue(unitMod, BASE_VALUE) + (attackPower / 14.0f) * variance;
-    float basePct          = GetPctModifierValue(unitMod, BASE_PCT) * attackSpeedMulti;
+    float baseValue        = GetFlatModifierValue(unitMod, BASE_VALUE) + (attackPower / 14.0f) * variance * attackSpeedMulti;
+    float basePct          = GetPctModifierValue(unitMod, BASE_PCT);
     float totalValue       = GetFlatModifierValue(unitMod, TOTAL_VALUE);
     float totalPct         = addTotalPct ? GetPctModifierValue(unitMod, TOTAL_PCT) : 1.0f;
     float dmgMultiplier    = GetCreatureTemplate()->ModDamage; // = ModDamage * _GetDamageMod(rank);
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 99222f018..b6acf963d 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -80,6 +80,10 @@
 #include "WorldSession.h"
 #include <cmath>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 float baseMoveSpeed[MAX_MOVE_TYPE] =
 {
     2.5f,                  // MOVE_WALK
@@ -716,6 +720,26 @@ bool Unit::HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel) cons
     if (UnitAI* attackerAI = attacker ? attacker->GetAI() : nullptr)
         attackerAI->DamageDealt(victim, damage, damagetype);
 
+    //npcbot
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+        BotMgr::OnBotDamageTaken(attacker, victim, damage, cleanDamage , damagetype, spellProto);
+    //end npcbot
+    //npcbot: damage dealt hook for crits and spells
+    if (attacker && attacker->GetTypeId() == TYPEID_UNIT && attacker->ToCreature()->IsNPCBot())
+        BotMgr::OnBotDamageDealt(attacker, victim, damage, cleanDamage, damagetype, spellProto);
+    //end npcbot
+
+    //npcbot: damage tracker hook
+    if (damage > 0 && damage < victim->GetHealth())
+    {
+        Player const* botowner = victim->GetTypeId() == TYPEID_PLAYER ? victim->ToPlayer() :
+            victim->ToCreature()->IsNPCBot() && !victim->ToCreature()->IsFreeBot() ? victim->ToCreature()->GetBotOwner() : nullptr;
+
+        if (botowner && botowner->GetBotMgr() && (botowner->HaveBot() || (botowner->GetGroup() && botowner->GetGroup()->IsMember(victim->GetGUID()))))
+            botowner->GetBotMgr()->TrackDamage(victim, damage);
+    }
+    //end npcbot
+
     // Hook for OnDamage Event
     sScriptMgr->OnDamage(attacker, victim, damage);
 
@@ -728,6 +752,11 @@ bool Unit::HasBreakableByDamageCrowdControlAura(Unit* excludeCasterChannel) cons
                     controlledAI->OwnerAttackedBy(attacker);
     }
 
+    //npcbot
+    if (attacker && attacker != victim && victim->IsVehicle() && victim->IsAlive())
+        BotMgr::OnVehicleAttackedBy(attacker, victim);
+    //end npcbot
+
     if (Player* player = victim->ToPlayer())
         if (player->GetCommandStatus(CHEAT_GOD))
             return 0;
@@ -1010,6 +1039,18 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+                //NpcBot mod: apply bot damage mods
+                if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+                {
+                    //TODO: rename to ApplyBotDamageMultiplierPhysical
+                    ToCreature()->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+                    if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                        damage *= BotMgr::GetBotDamageModPhysical();
+                    else if (damageSchoolMask & SPELL_SCHOOL_MASK_MAGIC)
+                        damage *= BotMgr::GetBotDamageModSpell();
+                }
+                //End NpcBot
+
                 if (crit)
                 {
                     damageInfo->HitInfo |= SPELL_HIT_TYPE_CRIT;
@@ -1061,6 +1102,17 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+                //NpcBot mod: apply bot damage mods
+                if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+                {
+                    ToCreature()->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+                    if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
+                        damage *= BotMgr::GetBotDamageModPhysical();
+                    else if (damageSchoolMask & SPELL_SCHOOL_MASK_MAGIC)
+                        damage *= BotMgr::GetBotDamageModSpell();
+                }
+                //End NpcBot
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1205,6 +1257,17 @@ void Unit::CalculateMeleeDamage(Unit* victim, CalcDamageInfo* damageInfo, Weapon
         // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
         sScriptMgr->ModifyMeleeDamage(damageInfo->Target, damageInfo->Attacker, damage);
 
+        //NpcBot mod: apply bot damage mods
+        if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+        {
+            damageInfo->Damages[i].Damage = damage;
+            //damage is unused. TODO: remove this redundant argument
+            ToCreature()->ApplyBotDamageMultiplierMelee(damageInfo->Damages[i].Damage, *damageInfo);
+            damage = damageInfo->Damages[i].Damage;
+            damage *= BotMgr::GetBotDamageModPhysical();
+        }
+        //End NpcBot
+
         // Calculate armor reduction
         if (Unit::IsDamageReducedByArmor(SpellSchoolMask(damageInfo->Damages[i].DamageSchoolMask)))
         {
@@ -1215,6 +1278,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, CalcDamageInfo* damageInfo, Weapon
             damageInfo->Damages[i].Damage = damage;
     }
 
+    //NpcBot mod: check custom melee outcome
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        damageInfo->HitOutCome = ToCreature()->BotRollMeleeOutcomeAgainst(damageInfo->Target, damageInfo->AttackType);
+    else
+    //End NpcBot
     damageInfo->HitOutCome = RollMeleeOutcomeAgainst(damageInfo->Target, damageInfo->AttackType);
 
     switch (damageInfo->HitOutCome)
@@ -1506,6 +1574,13 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
         DamageInfo dmgInfo(*damageInfo);
         ToPlayer()->CastItemCombatSpell(dmgInfo);
     }
+    //npcbot - CastItemCombatSpell for bots
+    else if (ToCreature()->IsNPCBot())
+    {
+        DamageInfo dmgInfo(*damageInfo);
+        ToCreature()->CastCreatureItemCombatSpell(dmgInfo);
+    }
+    //end npcbot
 
     // Do effect if any damage done to target
     if (damageInfo->Damages[0].Damage + damageInfo->Damages[1].Damage)
@@ -1629,6 +1704,15 @@ void Unit::HandleEmoteCommand(Emote emoteId)
         }
     }
 
+    //npcbot: armor penetration modifier
+    if (attacker && attacker->GetTypeId() == TYPEID_UNIT && attacker->ToCreature()->IsNPCBot())
+    {
+        // SPELL_AURA_MOD_ARMOR_PENETRATION_PCT is handled in class mods
+        // No cap
+        armor -= CalculatePct(armor, attacker->ToCreature()->GetCreatureArmorPenetrationCoef());
+    }
+    //end npcbot
+
     if (armor < 0.0f)
         armor = 0.0f;
 
@@ -1731,6 +1815,14 @@ void Unit::HandleEmoteCommand(Emote emoteId)
             victimResistance += float(unitCaster->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, schoolMask));
     }
 
+    //npcbot - spell resist and spell penetration for bots
+    if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        victimResistance -= caster->ToCreature()->GetCreatureSpellPenetration();
+
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+        victimResistance += victim->ToCreature()->GetCreatureResistanceBonus(schoolMask);
+    //end npcbot
+
     // holy resistance exists in pve and comes from level difference, ignore template values
     if (schoolMask & SPELL_SCHOOL_MASK_HOLY)
         victimResistance = 0.0f;
@@ -1882,6 +1974,10 @@ void Unit::HandleEmoteCommand(Emote emoteId)
         if (float manaMultiplier = absorbAurEff->GetSpellEffectInfo().CalcValueMultiplier(absorbAurEff->GetCaster()))
             manaReduction = int32(float(manaReduction) * manaMultiplier);
 
+        //npcbot: fix absorption with 'manaMultiplier' < 1.0 (Mana Shield 35064)
+        manaReduction = std::max<decltype(manaReduction)>(manaReduction, 1);
+        //end npcbot
+
         int32 manaTaken = -damageInfo.GetVictim()->ModifyPower(POWER_MANA, -manaReduction);
 
         // take case when mana has ended up into account
@@ -2160,6 +2256,15 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
     int32 block_chance = int32(GetUnitBlockChance(attType, victim) * 100.0f);
     int32 parry_chance = int32(GetUnitParryChance(attType, victim) * 100.0f);
 
+    //npcbot - expertise
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        int32 reductionFromExpertise = ToCreature()->GetCreatureExpertise() * 100 / 4;
+        dodge_chance -= reductionFromExpertise;
+        parry_chance -= reductionFromExpertise;
+    }
+    //end npcbot
+
     // melee attack table implementation
     // outcome priority:
     //   1. >    2. >    3. >       4. >    5. >   6. >       7. >  8.
@@ -2174,7 +2279,28 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
     // only creatures can dodge if attacker is behind
     bool canDodge = victim->GetTypeId() != TYPEID_PLAYER || canParryOrBlock;
 
+    //npcbot: player rules for dodge
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot() && !canParryOrBlock)
+        canDodge = false;
+    //end npcbot
+
     // if victim is casting or cc'd it can't avoid attacks
+    //npcbot: allow some bot classes to parry while casting
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBot())
+    {
+        if (victim->HasUnitState(UNIT_STATE_CONTROLLED))
+        {
+            canDodge = false;
+            canParryOrBlock = false;
+        }
+        else if (victim->IsNonMeleeSpellCast(false, false, true))
+        {
+            canDodge = false;
+            canParryOrBlock = BotMgr::CanBotParryWhileCasting(victim->ToCreature());
+        }
+    }
+    else
+    //end npcbot
     if (victim->IsNonMeleeSpellCast(false, false, true) || victim->HasUnitState(UNIT_STATE_CONTROLLED))
     {
         canDodge = false;
@@ -2210,6 +2336,9 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackTy
 
     // 4. GLANCING
     // Max 40% chance to score a glancing blow against mobs of the same or higher level (only players and pets, not for ranged weapons).
+    //npcbot: no glances on npcbots and their pets
+    if (!(victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->IsNPCBotOrPet()))
+    //end npcbot
     if ((GetTypeId() == TYPEID_PLAYER || IsPet()) &&
         victim->GetTypeId() != TYPEID_PLAYER && !victim->IsPet() &&
         GetLevel() <= victim->GetLevelForTarget(this))
@@ -2561,6 +2690,10 @@ uint32 Unit::GetDefenseSkillValue(Unit const* target) const
         value += uint32(ToPlayer()->GetRatingBonusValue(CR_DEFENSE_SKILL));
         return value;
     }
+    //npcbot - defense
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return ToCreature()->GetCreatureDefense();
+    //end npcbot
     else
         return GetMaxSkillValueForLevel(target);
 }
@@ -2583,6 +2716,14 @@ float Unit::GetUnitDodgeChance(WeaponAttackType attType, Unit const* victim) con
         if (!victim->IsTotem())
         {
             chance = 5.0f;
+            //npcbot - custom dodge chance instead of bunch of auras and remove base chance
+            if (victim->ToCreature()->IsNPCBot())
+            {
+                if (!victim->ToCreature()->CanDodge())
+                    return 0.f;
+                chance = victim->ToCreature()->GetCreatureDodgeChance();
+            }
+            //end npcbot
             chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
 
             if (skillDiff <= 10)
@@ -2635,6 +2776,14 @@ float Unit::GetUnitParryChance(WeaponAttackType attType, Unit const* victim) con
         if (!victim->IsTotem() && !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY))
         {
             chance = 5.0f;
+            //npcbot - custom parry chance instead of bunch of auras
+            if (victim->ToCreature()->IsNPCBot())
+            {
+                if (!victim->ToCreature()->CanParry())
+                    return 0.f;
+                chance = victim->ToCreature()->GetCreatureParryChance();
+            }
+            //end npcbot
             chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
 
             if (skillDiff <= 10)
@@ -2661,6 +2810,11 @@ float Unit::GetUnitMissChance() const
     if (Player const* player = ToPlayer())
         miss_chance += player->GetMissPercentageFromDefense();
 
+    //npcbot: defense skill bonus
+    if (Creature const* creature = ToCreature())
+        miss_chance += (creature->GetCreatureDefense() - GetLevel() * 5) * 0.04f;
+    //end npcbot
+
     return miss_chance;
 }
 
@@ -2689,6 +2843,10 @@ float Unit::GetUnitBlockChance(WeaponAttackType attType, Unit const* victim) con
         if (!victim->IsTotem() && !(victim->ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
         {
             chance = 5.0f;
+            //npcbot - custom block chance instead of bunch of auras and remove base chance
+            if (victim->ToCreature()->IsNPCBot())
+                chance = victim->ToCreature()->GetCreatureBlockChance();
+            //end npcbot
             chance += victim->GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
 
             if (skillDiff <= 10)
@@ -2729,6 +2887,10 @@ float Unit::GetUnitCriticalChanceDone(WeaponAttackType attackType) const
         if (!(ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_CRIT))
         {
             chance = 5.0f;
+            //npcbot - custom crit chance instead of bunch of auras and remove base chance
+            if (ToCreature()->IsNPCBot())
+                chance = ToCreature()->GetCreatureCritChance();
+            //end npcbot
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
         }
@@ -3833,6 +3995,11 @@ void Unit::RemoveAurasDueToSpellByDispel(uint32 spellId, uint32 dispellerSpellId
             // Call AfterDispel hook on AuraScript
             aura->CallScriptAfterDispel(&dispelInfo);
 
+            //npcbot: hook dispels
+            if (dispeller->GetTypeId() == TYPEID_UNIT && dispeller->ToCreature()->IsNPCBot())
+                BotMgr::OnBotDispelDealt(dispeller->ToUnit(), this, dispelInfo.GetRemovedCharges());
+            //end npcbot
+
             return;
         }
         else
@@ -5078,6 +5245,23 @@ std::vector<GameObject*> Unit::GetGameObjects(uint32 spellId) const
     return gameobjects;
 }
 
+//npcbot
+GameObject* Unit::GetFirstGameObjectById(uint32 id) const
+{
+    for (GameObjectList::const_iterator i = m_gameObj.begin(); i != m_gameObj.end(); ++i)
+        if ((*i)->GetEntry() == id)
+            return *i;
+
+    return nullptr;
+}
+
+void Unit::SetCreator(Unit* creator)
+{
+    SetCreatorGUID(creator ? creator->GetGUID() : ObjectGuid::Empty);
+    m_creator = creator;
+}
+//end npcbot
+
 void Unit::AddGameObject(GameObject* gameObj)
 {
     if (!gameObj || gameObj->GetOwnerGUID())
@@ -5600,6 +5784,9 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
 
     if (creature && !IsControlledByPlayer())
+    //npcbot - not for npcbots either
+    if (!creature->IsNPCBotOrPet())
+    //end npcbot
     {
         EngageWithTarget(victim); // ensure that anything we're attacking has threat
 
@@ -5701,6 +5888,19 @@ void Unit::CombatStopWithPets(bool includingCast)
 
     for (Unit* minion : m_Controlled)
         minion->CombatStop(includingCast);
+
+    //npcbot: combatstop for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            itr->second->CombatStop(includingCast);
+            if (Unit* botPet = itr->second->GetBotsPet())
+                botPet->CombatStop(includingCast);
+        }
+    }
+    //end npcbot
 }
 
 bool Unit::isAttackingPlayer() const
@@ -6300,6 +6500,11 @@ Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
     else if (GetTypeId() == TYPEID_UNIT && IsPet())
         player = GetOwner()->ToPlayer();
 
+    //npcbot: count bot owner
+    if (!player && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && !ToCreature()->IsFreeBot())
+        player = ToCreature()->GetBotOwner();
+    //end npcbot
+
     if (!player)
         return nullptr;
     Group* group = player->GetGroup();
@@ -6328,6 +6533,25 @@ Unit* Unit::GetNextRandomRaidMemberOrPet(float radius)
             if (Target != this && IsWithinDistInMap(Target, radius) && Target->IsAlive() && !IsHostileTo(Target))
                 nearMembers.push_back(Target);
 
+            //npcbot: push bots and bot pets
+            if (Target->HaveBot())
+            {
+                BotMap const* botMap = Target->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = botMap->begin(); it != botMap->end(); ++it)
+                {
+                    if (group->IsMember(it->second->GetGUID()))
+                    {
+                        if (it->second != this && it->second->IsAlive() &&
+                            IsWithinDistInMap(it->second, radius) && !IsHostileTo(it->second))
+                            nearMembers.push_back(it->second);
+                        //if (Unit* botpet = it->second->GetBotsPet())
+                        //    if (botpet != this && botpet->IsAlive() && IsWithinDistInMap(botpet, radius) && !IsHostileTo(botpet))
+                        //        nearMembers.push_back(botpet);
+                    }
+                }
+            }
+            //end npcbot
+
         // Push player's pet to vector
         if (Unit* pet = Target->GetGuardianPet())
             if (pet != this && IsWithinDistInMap(pet, radius) && pet->IsAlive() && !IsHostileTo(pet))
@@ -6599,6 +6823,11 @@ float Unit::SpellDamagePctDone(Unit* victim, SpellInfo const* spellProto, Damage
     // Done total percent damage auras
     float DoneTotalMod = 1.0f;
 
+    //npcbot: do not affect bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+    { /*do nothing*/ }
+    else
+    //end npcbot
     // Pet damage?
     if (GetTypeId() == TYPEID_UNIT && !IsPet())
         DoneTotalMod *= ToCreature()->GetSpellDamageMod(ToCreature()->GetCreatureTemplate()->rank);
@@ -6932,6 +7161,11 @@ uint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, ui
         // multiplicative bonus, for example Dispersion + Shadowform (0.10*0.85=0.085)
         TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, spellProto->GetSchoolMask());
 
+        //npcbot - damage taken modifier
+        if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+            TakenTotalMod *= BotMgr::GetBotDamageTakenMod(ToCreature(), true);
+        //end npcbot
+
         // From caster spells
         if (caster)
         {
@@ -6968,6 +7202,11 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask) const
 {
     int32 DoneAdvertisedBenefit = GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_DAMAGE_DONE, schoolMask);
 
+    //npcbot: apply bot spellpower
+    if ((schoolMask & SPELL_SCHOOL_MASK_MAGIC) && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        DoneAdvertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     if (GetTypeId() == TYPEID_PLAYER)
     {
         // Base value
@@ -6996,6 +7235,9 @@ float Unit::SpellCritChanceDone(SpellInfo const* spellInfo, SpellSchoolMask scho
 {
     //! Mobs can't crit with spells. (Except player controlled)
     if (GetTypeId() == TYPEID_UNIT && !GetSpellModOwner())
+        //npcbot - allow bots to crit
+        if (!ToCreature()->IsNPCBotOrPet())
+        //end npcbot
         return 0.0f;
 
     // not critting spell
@@ -7223,6 +7465,11 @@ float Unit::SpellCritChanceTaken(Unit const* caster, SpellInfo const* spellInfo,
         });
     }
 
+    //npcbot - apply bot spell crit mods
+    if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ApplyBotCritMultiplierAll(this, crit_chance, spellInfo, schoolMask, attackType);
+    //end npcbot
+
     return std::max(crit_chance, 0.0f);
 }
 
@@ -7444,6 +7691,11 @@ uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, ui
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
+    //npcbot - healing bonus done for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        ToCreature()->ApplyBotDamageMultiplierHeal(victim, heal, spellProto, damagetype, stack);
+    //end npcbot
+
     return uint32(std::max(heal, 0.0f));
 }
 
@@ -7584,6 +7836,11 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask) const
         return false;
     });
 
+    //npcbot: apply bot spellpower to healing
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        advertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -8022,6 +8279,11 @@ uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackT
     // ..taken
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, attacker->GetMeleeDamageSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        TakenTotalMod *= BotMgr::GetBotDamageTakenMod(ToCreature(), false);
+    //end npcbot
+
     // .. taken pct (special attacks)
     if (spellProto)
     {
@@ -8156,6 +8418,25 @@ void Unit::Mount(uint32 mount, uint32 VehicleId, uint32 creatureEntry)
 
     SetUnitFlag(UNIT_FLAG_MOUNT);
 
+    //npcbot
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        if (VehicleId)
+        {
+            TC_LOG_ERROR("scripts", "NPCBot::Mount mounting %u, vehicle %u (%u)", mount, VehicleId, creatureEntry);
+            if (CreateVehicleKit(VehicleId, creatureEntry))
+            {
+                // Send others that we now have a vehicle
+                WorldPacket data(SMSG_PLAYER_VEHICLE_DATA, GetPackGUID().size()+4);
+                data << GetPackGUID();
+                data << uint32(VehicleId);
+                SendMessageToSet(&data, true);
+                GetVehicleKit()->InstallAllAccessories(false);
+            }
+        }
+    }
+    else
+    //end npcbot
     if (Player* player = ToPlayer())
     {
         // mount as a vehicle
@@ -8226,6 +8507,19 @@ void Unit::Dismount()
     SendMessageToSet(&data, true);
 
     // dismount as a vehicle
+    //npcbot
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot() && GetVehicleKit())
+    {
+        //TC_LOG_ERROR("scripts", "NPCBot::Dismount dismounting vehicle %u (base %u, cre %u)",
+        //    GetVehicleKit()->GetVehicleInfo()->m_ID, GetVehicleKit()->GetBase()->GetEntry(), GetVehicleKit()->GetCreatureEntry());
+        data.Initialize(SMSG_PLAYER_VEHICLE_DATA, 8 + 4);
+        data << GetPackGUID();
+        data << uint32(0);
+        SendMessageToSetInRange(&data, GetVisibilityRange(), /*not used*/true);
+        RemoveVehicleKit();
+    }
+    else
+    //end npcbot
     if (GetTypeId() == TYPEID_PLAYER && GetVehicleKit())
     {
         // Send other players that we are no longer a vehicle
@@ -8469,6 +8763,12 @@ bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
                 if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                     return true;
 
+    //npcbot - bots are always visible for owner
+    if (Creature const* bot = ToCreature())
+        if ((bot->GetBotAI() || bot->GetBotPetAI()) && seer->GetGUID() == bot->GetBotOwner()->GetGUID())
+            return true;
+    //end npcbot
+
     return false;
 }
 
@@ -8847,6 +9147,12 @@ bool Unit::ApplyDiminishingToDuration(SpellInfo const* auraSpellInfo, bool trigg
 
         if (target->IsAffectedByDiminishingReturns() && source->GetTypeId() == TYPEID_PLAYER)
             duration = limitDuration;
+
+        //npcbot: limit duration if casted by npcbots
+        if (target->GetTypeId() == TYPEID_PLAYER && source->GetTypeId() == TYPEID_UNIT &&
+            source->ToCreature()->IsNPCBotOrPet())
+            duration = limitDuration;
+        //end npcbots
     }
 
     float mod = 1.0f;
@@ -8923,6 +9229,17 @@ uint32 Unit::GetCreatureType() const
             return raceEntry->CreatureType;
         }
     }
+    //npcbot: support for druid's shapeshifting
+    else if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        ShapeshiftForm form = GetShapeshiftForm();
+        SpellShapeshiftFormEntry const* ssEntry = sSpellShapeshiftFormStore.LookupEntry(form);
+        if (ssEntry && ssEntry->CreatureType > 0)
+            return ssEntry->CreatureType;
+        else
+            return CREATURE_TYPE_HUMANOID;
+    }
+    //end npcbot
     else
         return ToCreature()->GetCreatureTemplate()->type;
 }
@@ -10103,6 +10420,14 @@ void Unit::ProcSkillsAndReactives(bool isVictim, Unit* procTarget, uint32 typeMa
                     ModifyAuraState(AURA_STATE_DEFENSE, true);
                     StartReactiveTimer(REACTIVE_DEFENSE);
                 }
+                //npcbot - update reactives for bots (victim)
+                if ((hitMask & PROC_HIT_PARRY) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->IsNPCBot() && ToCreature()->GetBotClass() == CLASS_HUNTER)
+                {
+                    ModifyAuraState(AURA_STATE_HUNTER_PARRY, true);
+                    StartReactiveTimer(REACTIVE_HUNTER_PARRY);
+                }
+                //end npcbot
             }
             else // For attacker
             {
@@ -10117,6 +10442,16 @@ void Unit::ProcSkillsAndReactives(bool isVictim, Unit* procTarget, uint32 typeMa
                     AddComboPoints(procTarget, 1);
                     StartReactiveTimer(REACTIVE_WOLVERINE_BITE);
                 }
+
+                //npcbot - update reactives for bots (attacker)
+                if ((hitMask & (PROC_HIT_DODGE | PROC_HIT_PARRY)) && GetTypeId() == TYPEID_UNIT &&
+                    ToCreature()->IsNPCBot() && ToCreature()->GetBotClass() == CLASS_WARRIOR)
+                {
+                    AddComboPoints(procTarget, 1);
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+                //TODO REACTIVE_WOLVERINE_BITE for bot hunter pets
+                //end npcbot
             }
         }
     }
@@ -10496,6 +10831,32 @@ void Unit::ClearComboPointHolders()
         (*m_ComboPointHolders.begin())->ClearComboPoints(); // this also removes it from m_comboPointHolders
 }
 
+//npcbot
+void Unit::ClearReactive(ReactiveType reactive)
+{
+    m_reactiveTimer[reactive] = 0;
+
+    switch (reactive)
+    {
+        case REACTIVE_DEFENSE:
+            if (HasAuraState(AURA_STATE_DEFENSE))
+                ModifyAuraState(AURA_STATE_DEFENSE, false);
+            break;
+        case REACTIVE_HUNTER_PARRY:
+            if (GetClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+            break;
+        case REACTIVE_OVERPOWER:
+            if (GetClass() == CLASS_WARRIOR)
+                ClearComboPoints();
+            break;
+        default:
+            break;
+        //TODO WOLVERINE_BITE clear
+    }
+}
+//end npcbot
+
 void Unit::ClearAllReactives()
 {
     for (uint8 i = 0; i < MAX_REACTIVE; ++i)
@@ -10625,6 +10986,9 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
 {
     // Not apply this to creature cast spells with casttime == 0
     if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !IsPet())
+        //npcbot - skip bots
+        if (!ToCreature()->IsNPCBotOrPet())
+        //end npcbot
         return 3500;
 
     if (CastingTime > 7000) CastingTime = 7000;
@@ -10903,6 +11267,14 @@ bool Unit::InitTamedPet(Pet* pet, uint8 level, uint32 spell_id)
 
     // find player: owner of controlled `this` or `this` itself maybe
     Player* player = nullptr;
+    //npcbot - loot recipient of bot's vehicle is owner
+    if (attacker && attacker->IsVehicle() && attacker->GetCharmerGUID().IsCreature() && attacker->GetCreatorGUID().IsPlayer())
+    {
+        if (Unit* uowner = attacker->GetCreator())
+            player = uowner->ToPlayer();
+    }
+    else
+    //end npcbot
     if (attacker)
         player = attacker->GetCharmerOrOwnerPlayerOrPlayerItself();
 
@@ -11084,6 +11456,12 @@ bool Unit::InitTamedPet(Pet* pet, uint8 level, uint32 spell_id)
         // at original death (not at SpiritOfRedemtionTalent timeout)
         plrVictim->SetPvPDeath(player != nullptr);
 
+        //npcbot - bots should not cause durability loss
+        if (durabilityLoss && attacker && attacker->GetTypeId() == TYPEID_UNIT && attacker->ToCreature()->GetBotAI() &&
+            !sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP))
+            durabilityLoss = false;
+        //end npcbot
+
         // only if not player and not controlled by player pet. And not at BG
         if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
         {
@@ -11886,6 +12264,16 @@ bool Unit::IsInPartyWith(Unit const* unit) const
     else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT) ||
         (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT))
         return true;
+    //npcbot
+    else if (u1->GetTypeId() == TYPEID_PLAYER && u1->ToPlayer()->HaveBot() && u1->ToPlayer()->GetBotMgr()->GetBot(u2->GetGUID()))
+        return true;
+    else if (u2->GetTypeId() == TYPEID_PLAYER && u2->ToPlayer()->HaveBot() && u2->ToPlayer()->GetBotMgr()->GetBot(u1->GetGUID()))
+        return true;
+    else if (u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetBotAI() && !u1->ToCreature()->IsFreeBot())
+        return u1->ToCreature()->GetBotOwner()->IsInPartyWith(u2);
+    else if (u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetBotAI() && !u2->ToCreature()->IsFreeBot())
+        return u2->ToCreature()->GetBotOwner()->IsInPartyWith(u1);
+    //end npcbot
 
     return u1->GetTypeId() == TYPEID_UNIT && u2->GetTypeId() == TYPEID_UNIT && u1->GetFaction() == u2->GetFaction();
 }
@@ -11905,6 +12293,16 @@ bool Unit::IsInRaidWith(Unit const* unit) const
     else if ((u2->GetTypeId() == TYPEID_PLAYER && u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT) ||
             (u1->GetTypeId() == TYPEID_PLAYER && u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetCreatureTemplate()->type_flags & CREATURE_TYPE_FLAG_TREAT_AS_RAID_UNIT))
         return true;
+    //npcbot
+    else if (u1->GetTypeId() == TYPEID_PLAYER && u1->ToPlayer()->HaveBot() && u1->ToPlayer()->GetBotMgr()->GetBot(u2->GetGUID()))
+        return true;
+    else if (u2->GetTypeId() == TYPEID_PLAYER && u2->ToPlayer()->HaveBot() && u2->ToPlayer()->GetBotMgr()->GetBot(u1->GetGUID()))
+        return true;
+    else if (u1->GetTypeId() == TYPEID_UNIT && u1->ToCreature()->GetBotAI() && !u1->ToCreature()->IsFreeBot())
+        return u1->ToCreature()->GetBotOwner()->IsInRaidWith(u2);
+    else if (u2->GetTypeId() == TYPEID_UNIT && u2->ToCreature()->GetBotAI() && !u2->ToCreature()->IsFreeBot())
+        return u2->ToCreature()->GetBotOwner()->IsInRaidWith(u1);
+    //end npcbot
 
     return u1->GetTypeId() == TYPEID_UNIT && u2->GetTypeId() == TYPEID_UNIT && u1->GetFaction() == u2->GetFaction();
 }
@@ -11933,6 +12331,19 @@ void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
                 if (Guardian* pet = Target->GetGuardianPet())
                     if (pet->IsAlive())
                         TagUnitMap.push_back(pet);
+
+                //npcbot: count bots
+                if (!Target->HaveBot())
+                    continue;
+
+                BotMap const* map = Target->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    if (group->GetMemberGroup(it->second->GetGUID()) == subgroup &&
+                        it->second->IsAlive() && IsInMap(it->second) && !IsHostileTo(it->second))
+                        TagUnitMap.push_back(it->second);
+                }
+                //end npcbot
             }
         }
     }
@@ -11943,6 +12354,18 @@ void Unit::GetPartyMembers(std::list<Unit*> &TagUnitMap)
         if (Guardian* pet = owner->GetGuardianPet())
             if ((pet == this || IsInMap(pet)) && pet->IsAlive())
                 TagUnitMap.push_back(pet);
+
+        //npcbot: count bots
+        if (owner->GetTypeId() == TYPEID_PLAYER && owner->ToPlayer()->HaveBot())
+        {
+            BotMap const* map = owner->ToPlayer()->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+            {
+                if (it->second->IsAlive() && IsInMap(it->second) && !IsHostileTo(it->second))
+                    TagUnitMap.push_back(it->second);
+            }
+        }
+        //end npcbot
     }
 }
 
@@ -12035,6 +12458,11 @@ void Unit::SendPlaySpellImpact(ObjectGuid guid, uint32 id) const
 
 bool Unit::CanApplyResilience() const
 {
+    //npcbot: allow bots' damage to be mitigated by target's resilience
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBotOrPet())
+        return true;
+    //end npcbot
+
     return !IsVehicle() && GetOwnerGUID().IsPlayer();
 }
 
@@ -12117,6 +12545,16 @@ float Unit::MeleeSpellMissChance(Unit const* victim, WeaponAttackType attType, i
     //calculate miss chance
     float missChance = victim->GetUnitMissChance();
 
+    //npcbot - custom miss chance instead of bunch of auras
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+    {
+        if (!ToCreature()->CanMiss())
+            return 0.f;
+
+        missChance += ToCreature()->GetCreatureMissChance();
+    }
+    //end npcbot
+
     // melee attacks while dual wielding have +19% chance to miss
     if (!spellId && haveOffhandWeapon())
         missChance += 19.0f;
@@ -12173,6 +12611,11 @@ void Unit::SetPhaseMask(uint32 newPhaseMask, bool update)
             if ((*itr)->GetTypeId() == TYPEID_UNIT)
                 (*itr)->SetPhaseMask(newPhaseMask, true);
 
+        //npcbot: update for temporarily uncontrolled bots (teleport, taxi)
+        if (GetTypeId() == TYPEID_PLAYER)
+            ToPlayer()->UpdatePhaseForBots();
+        //end npcbot
+
         for (uint8 i = 0; i < MAX_SUMMON_SLOT; ++i)
             if (m_SummonSlot[i])
                 if (Creature* summon = GetMap()->GetCreature(m_SummonSlot[i]))
@@ -12427,6 +12870,183 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form, uint32 spellId) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetBotOwner() && ToCreature()->GetBotOwner()->ToPlayer())
+    {
+        //this has to be modified after implementation of bots' appearances which will include player bytes emulation
+        Player const* player = ToCreature()->GetBotOwner();
+        //let's make druids look according to player but base model must be selected based on our race
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (GetRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (GetRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (GetGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (GetRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (GetRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (GetGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(GetRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftFormEntry const* formEntry = sSpellShapeshiftFormStore.LookupEntry(form);
@@ -13117,6 +13737,19 @@ void Unit::StopAttackFaction(uint32 faction_id)
 
     for (Unit* minion : m_Controlled)
         minion->StopAttackFaction(faction_id);
+
+    //npcbot: stopattackfaction for bots
+    if (GetTypeId() == TYPEID_PLAYER && ToPlayer()->HaveBot())
+    {
+        BotMap const* map = ToPlayer()->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            itr->second->StopAttackFaction(faction_id);
+            if (Unit* botPet = itr->second->GetBotsPet())
+                botPet->StopAttackFaction(faction_id);
+        }
+    }
+    //end npcbot
 }
 
 void Unit::OutDebugInfo() const
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index b7d8afcf4..1a78421aa 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -316,7 +316,7 @@ struct PlayerMovementPendingChange
     } knockbackInfo; // used if knockback
 };
 
-enum CombatRating
+enum CombatRating : uint8
 {
     CR_WEAPON_SKILL             = 0,
     CR_DEFENSE_SKILL            = 1,
@@ -1254,6 +1254,14 @@ class TC_GAME_API Unit : public WorldObject
         ObjectGuid GetCharmedGUID() const { return GetGuidValue(UNIT_FIELD_CHARM); }
         Unit* GetCharmed() const { return m_charmed; }
 
+        //npcbot
+        void SetControlledByPlayer(bool set) { m_ControlledByPlayer = set; }
+        GameObject* GetFirstGameObjectById(uint32 id) const;
+        void SetCreator(Unit* creator);
+        Unit* GetCreator() const { return m_creator; }
+        Unit* m_creator = nullptr;
+        //end npcbot
+
         bool IsControlledByPlayer() const { return m_ControlledByPlayer; }
         Player* GetControllingPlayer() const;
         ObjectGuid GetCharmerOrOwnerGUID() const override { return IsCharmed() ? GetCharmerGUID() : GetOwnerGUID(); }
@@ -1826,6 +1834,11 @@ class TC_GAME_API Unit : public WorldObject
 
         std::string GetDebugInfo() const override;
 
+        //npcbot
+        bool HasReactive(ReactiveType reactive) const { return m_reactiveTimer[reactive] > 0; }
+        void ClearReactive(ReactiveType reactive);
+        //end npcbot
+
     protected:
         explicit Unit (bool isWorldObject);
 
diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
index 9277b8d49..3fbb540b9 100755
--- a/src/server/game/Entities/Vehicle/Vehicle.cpp
+++ b/src/server/game/Entities/Vehicle/Vehicle.cpp
@@ -33,6 +33,10 @@
 #include "Unit.h"
 #include "Util.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 Vehicle::Vehicle(Unit* unit, VehicleEntry const* vehInfo, uint32 creatureEntry) :
 UsableSeatNum(0), _me(unit), _vehicleInfo(vehInfo), _creatureEntry(creatureEntry), _status(STATUS_NONE)
 {
@@ -512,10 +516,21 @@ Vehicle* Vehicle::RemovePassenger(Unit* unit)
     if (seat->second.SeatInfo->Flags & VEHICLE_SEAT_FLAG_PASSENGER_NOT_SELECTABLE && !seat->second.Passenger.IsUninteractible)
         unit->RemoveUnitFlag(UNIT_FLAG_UNINTERACTIBLE);
 
+    //npcbot
+    if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetBotAI())
+        BotMgr::OnBotExitVehicle(unit->ToCreature(), this);
+    //end npcbot
+
     seat->second.Passenger.Reset();
 
     if (_me->GetTypeId() == TYPEID_UNIT && unit->GetTypeId() == TYPEID_PLAYER && seat->second.SeatInfo->Flags & VEHICLE_SEAT_FLAG_CAN_CONTROL)
+    {
+        //npcbot
+        if (unit->ToPlayer()->HaveBot())
+            BotMgr::OnBotOwnerExitVehicle(unit->ToPlayer(), this);
+        //end npcbot
         _me->RemoveCharmedBy(unit);
+    }
 
     if (_me->IsInWorld())
     {
@@ -831,6 +846,16 @@ bool VehicleJoinEvent::Execute(uint64, uint32)
             else
                 Target->GetBase()->RemoveNpcFlag(UNIT_NPC_FLAG_SPELLCLICK);
         }
+        //npcbot: do not allow other passengers on bot vehicles
+        if (Passenger->GetTypeId() == TYPEID_UNIT && Passenger->ToCreature()->IsNPCBot()/* &&
+            (Seat->second.SeatInfo->m_flags & VEHICLE_SEAT_FLAG_CAN_CONTROL)*/)
+        {
+            if (Target->GetBase()->GetTypeId() == TYPEID_PLAYER)
+                Target->GetBase()->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_PLAYER_VEHICLE);
+            else
+                Target->GetBase()->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_SPELLCLICK);
+        }
+        //end npcbot
     }
 
     Passenger->InterruptNonMeleeSpells(false);
@@ -867,6 +892,11 @@ bool VehicleJoinEvent::Execute(uint64, uint32)
     Passenger->m_movementInfo.transport.seat = Seat->first;
     Passenger->m_movementInfo.transport.guid = Target->GetBase()->GetGUID();
 
+    //npcbot
+    if (Passenger->GetTypeId() == TYPEID_UNIT && Passenger->ToCreature()->GetBotAI())
+        BotMgr::OnBotEnterVehicle(Passenger->ToCreature(), Target);
+    //end npcbot
+
     if (Target->GetBase()->GetTypeId() == TYPEID_UNIT && Passenger->GetTypeId() == TYPEID_PLAYER &&
         veSeat->HasFlag(VEHICLE_SEAT_FLAG_CAN_CONTROL))
     {
@@ -877,6 +907,10 @@ bool VehicleJoinEvent::Execute(uint64, uint32)
             Abort(0);
             return true;
         }
+        //npcbot
+        if (Passenger->ToPlayer()->HaveBot())
+            BotMgr::OnBotOwnerEnterVehicle(Passenger->ToPlayer(), Target);
+        //end npcbot
     }
 
     Passenger->SendClearTarget();                            // SMSG_BREAK_TARGET
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 46d9cf9d9..8ab23f48f 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -1192,6 +1192,11 @@ void ObjectMgr::CheckCreatureTemplate(CreatureTemplate const* cInfo)
         const_cast<CreatureTemplate*>(cInfo)->expansion = 0;
     }
 
+    //npcbot: skip flags check and damage multiplier
+    if (cInfo->flags_extra & (CREATURE_FLAG_EXTRA_NPCBOT | CREATURE_FLAG_EXTRA_NPCBOT_PET))
+        return;
+    //end npcbot
+
     if (uint32 badFlags = (cInfo->flags_extra & ~CREATURE_FLAG_EXTRA_DB_ALLOWED))
     {
         TC_LOG_ERROR("sql.sql", "Table `creature_template` lists creature (Entry: %u) with disallowed `flags_extra` %u, removing incorrect flag.", cInfo->Entry, badFlags);
@@ -8977,6 +8982,82 @@ SkillRangeType GetSkillRangeType(SkillRaceClassInfoEntry const* rcEntry)
     return SKILL_RANGE_LEVEL;
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->FemaleDisplayID;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->MaleDisplayID;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 875949faf..69b17b7be 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -173,6 +173,21 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele> GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef std::unordered_map<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1226,6 +1241,8 @@ class TC_GAME_API ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
+
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1487,6 +1504,8 @@ class TC_GAME_API ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string_view name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         Trainer::Trainer const* GetTrainer(uint32 creatureId) const;
         std::vector<Trainer::Trainer const*> const& GetClassTrainers(uint8 classId) const { return _classTrainers.at(classId); }
 
@@ -1650,6 +1669,8 @@ class TC_GAME_API ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void LoadQuestRelationsHelper(QuestRelations& map, std::string const& table);
diff --git a/src/server/game/Grids/Notifiers/GridNotifiers.h b/src/server/game/Grids/Notifiers/GridNotifiers.h
index 5448b8e93..2e63d6e9a 100644
--- a/src/server/game/Grids/Notifiers/GridNotifiers.h
+++ b/src/server/game/Grids/Notifiers/GridNotifiers.h
@@ -892,6 +892,10 @@ namespace Trinity
                     player = u->ToPlayer();
                 else if (u->IsPet() && u->GetOwner())
                     player = u->GetOwner()->ToPlayer();
+                //npcbot: find bot owner
+                else if (u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->IsNPCBotOrPet() && !u->ToCreature()->IsFreeBot())
+                    player = u->ToCreature()->GetBotOwner();
+                //end npcbot
 
                 if (!player)
                     return false;
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 791960fac..630726ea8 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -42,6 +42,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botdatamgr.h"
+//end npcbot
+
 Roll::Roll(ObjectGuid _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
 totalPlayersRolling(0), totalNeed(0), totalGreed(0), totalPass(0), itemSlot(0),
@@ -163,6 +167,15 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //npcbot - set loot mode on create
+    //TC_LOG_ERROR("entities.player", "Group::Create(): new group with leader %s", leader->GetName().c_str());
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+    {
+        if (!isLFGGroup())
+            m_lootMethod = FREE_FOR_ALL;
+    }
+    else
+    //end npcbot
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -282,6 +295,37 @@ void Group::LoadMemberFromDB(ObjectGuid::LowType guidLow, uint8 memberFlags, uin
     sLFGMgr->SetupGroupMember(member.guid, GetGUID());
 }
 
+//npcbot
+void Group::LoadCreatureMemberFromDB(uint32 entry, uint8 memberFlags, uint8 subgroup, uint8 roles)
+{
+    MemberSlot member;
+    member.guid = BotDataMgr::GetNPCBotGuid(entry);
+
+    // skip non-existed bot
+    if (member.guid == ObjectGuid::Empty)
+    {
+        CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT_GROUP_MEMBER);
+        stmt->setUInt32(0, entry);
+        CharacterDatabase.Execute(stmt);
+        return;
+    }
+
+    CreatureTemplate const* ct = sObjectMgr->GetCreatureTemplate(entry);
+    ASSERT(ct);
+
+    member.name = ct->Name;
+    member.group = subgroup;
+    member.flags = memberFlags;
+    member.roles = roles;
+
+    m_memberSlots.push_back(member);
+
+    SubGroupCounterIncrease(subgroup);
+
+    //sLFGMgr->SetupGroupMember(member.guid, GetGUID());
+}
+//end npcbot
+
 void Group::ConvertToLFG()
 {
     m_groupType = GroupType(m_groupType | GROUPTYPE_LFG | GROUPTYPE_LFG_RESTRICTED);
@@ -422,6 +466,27 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    //npcbot - check if trying to add bot
+    //TC_LOG_ERROR("entities.player", "Group::AddMember(): new member %s", player->GetName().c_str());
+    if (!player->GetGUID().IsPlayer())
+    {
+        // insert into the table if we're not a battleground group
+        if (!isBGGroup() && !isBFGroup())
+        {
+            CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT_GROUP_MEMBER);
+
+            stmt->setUInt32(0, m_dbStoreId);
+            stmt->setUInt32(1, player->GetEntry());
+            stmt->setUInt8(2, member.flags);
+            stmt->setUInt8(3, member.group);
+            stmt->setUInt8(4, member.roles);
+
+            CharacterDatabase.Execute(stmt);
+        }
+    }
+    else
+    {
+    //end npcbot
     player->SetGroupInvite(nullptr);
     if (player->GetGroup())
     {
@@ -455,10 +520,17 @@ bool Group::AddMember(Player* player)
 
         CharacterDatabase.Execute(stmt);
     }
+    //npcbot
+    }
+    //end npcbot
 
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    //npcbot - check 2
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -534,6 +606,9 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    //npcbot
+    }
+    //end npcbot
 
     return true;
 }
@@ -564,6 +639,47 @@ bool Group::RemoveMember(ObjectGuid guid, RemoveMethod const& method /*= GROUP_R
     if (isLFGGroup() && method == GROUP_REMOVEMETHOD_KICK)
         return !m_memberSlots.empty();
 
+    //npcbot: skip group size check before removing a bot
+    if (!guid.IsPlayer())
+    {
+        // Remove bot from group in DB
+        if (!isBGGroup() && !isBFGroup())
+        {
+            CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT_GROUP_MEMBER);
+            stmt->setUInt32(0, guid.GetEntry());
+            CharacterDatabase.Execute(stmt);
+            DelinkMember(guid);
+
+        }
+        // Update subgroup
+        member_witerator slot = _getMemberWSlot(guid);
+        if (slot != m_memberSlots.end())
+        {
+            SubGroupCounterDecrease(slot->group);
+            m_memberSlots.erase(slot);
+        }
+
+        SendUpdate();
+
+        // do not disband raid group if bot owner logging out within dungeon
+        // 1-player raid groups will not happen unless player is gm - bots will rejoin at login
+        if (GetMembersCount() < 2 && isRaidGroup() && !(isBGGroup() || isBFGroup()) && GetLeaderGUID())
+        {
+            Player const* player = ObjectAccessor::FindPlayer(GetLeaderGUID());
+            Map const* map = player ? player->FindMap() : nullptr;
+            if (!(map && map->IsDungeon() && player && player->GetSession()->PlayerLogout()))
+                Disband();
+        }
+        else if (GetMembersCount() < 2 && !(isLFGGroup() || isBGGroup() || isBFGroup()))
+        {
+            Disband();
+            return false;
+        }
+
+        return true;
+    }
+    else
+    //end npcbot
     // remove member and change leader (if need) only if strong more 2 members _before_ member remove (BG/BF allow 1 member group)
     if (GetMembersCount() > ((isBGGroup() || isLFGGroup() || isBFGroup()) ? 1u : 2u))
     {
@@ -672,6 +788,9 @@ bool Group::RemoveMember(ObjectGuid guid, RemoveMethod const& method /*= GROUP_R
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot: prevent group from being disbanded due to checking only players count
+        if (GetMembersCount() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
@@ -2550,12 +2669,26 @@ void Group::SetGroupMemberFlag(ObjectGuid guid, bool apply, GroupMemberFlags fla
     ToggleGroupMemberFlag(slot, flag, apply);
 
     // Preserve the new setting in the db
+    //npcbot
+    if (!guid.IsPlayer())
+    {
+        CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_GROUP_MEMBER_FLAG);
+        stmt->setUInt8(0, slot->flags);
+        stmt->setUInt32(1, guid.GetEntry());
+        CharacterDatabase.Execute(stmt);
+    }
+    else
+    {
+    //end npcbot
     CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
 
     stmt->setUInt8(0, slot->flags);
     stmt->setUInt32(1, guid.GetCounter());
 
     CharacterDatabase.Execute(stmt);
+    //npcbot
+    }
+    //end npcbot
 
     // Broadcast the changes to the group
     SendUpdate();
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index d316bfead..7a91ab080 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -190,6 +190,9 @@ class TC_GAME_API Group
         bool Create(Player* leader);
         void LoadGroupFromDB(Field* field);
         void LoadMemberFromDB(ObjectGuid::LowType guidLow, uint8 memberFlags, uint8 subgroup, uint8 roles);
+        //npcbot
+        void LoadCreatureMemberFromDB(uint32 entry, uint8 memberFlags, uint8 subgroup, uint8 roles);
+        //end npcbot
         bool AddInvite(Player* player);
         void RemoveInvite(Player* player);
         void RemoveAllInvites();
@@ -336,6 +339,10 @@ class TC_GAME_API Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //npcbots
+        ObjectGuid const* GetTargetIcons() const { return m_targetIcons; }
+        //end npcbots
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Groups/GroupMgr.cpp b/src/server/game/Groups/GroupMgr.cpp
index d7d40913a..33f9764e8 100644
--- a/src/server/game/Groups/GroupMgr.cpp
+++ b/src/server/game/Groups/GroupMgr.cpp
@@ -133,7 +133,14 @@ void GroupMgr::LoadGroups()
         // Delete all groups whose leader does not exist
         CharacterDatabase.DirectExecute("DELETE FROM `groups` WHERE leaderGuid NOT IN (SELECT guid FROM characters)");
         // Delete all groups with less than 2 members
+        //npcbot: adjust this
+        /*
+        //end npcbot
         CharacterDatabase.DirectExecute("DELETE FROM `groups` WHERE guid NOT IN (SELECT guid FROM group_member GROUP BY guid HAVING COUNT(guid) > 1)");
+        //npcbot
+        */
+        CharacterDatabase.DirectExecute("DELETE FROM `groups` WHERE guid NOT IN (SELECT guid from group_member GROUP BY guid HAVING (SELECT (SELECT COUNT(guid) FROM group_member) + (SELECT COUNT(guid) FROM characters_npcbot_group_member)) > 1)");
+        //end npcbot
 
         //                                                        0              1           2             3                 4      5          6      7         8       9
         QueryResult result = CharacterDatabase.Query("SELECT g.leaderGuid, g.lootMethod, g.looterGuid, g.lootThreshold, g.icon1, g.icon2, g.icon3, g.icon4, g.icon5, g.icon6"
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index 840c21874..d779a8d97 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -38,6 +38,10 @@
 #include "World.h"
 #include "WorldPacket.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket& recvData)
 {
     ObjectGuid guid;
@@ -254,6 +258,22 @@ void WorldSession::HandleBattlemasterJoinOpcode(WorldPacket& recvData)
             member->SendDirectMessage(&data);
             TC_LOG_DEBUG("bg.battleground", "Battleground: player joined queue for bg queue type %u bg type %u: GUID %s, NAME %s",
                 bgQueueTypeId, bgTypeId, member->GetGUID().ToString().c_str(), member->GetName().c_str());
+
+            //npcbot: list bots
+            if (!member->HaveBot())
+                continue;
+
+            BotMap const* map = member->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Creature const* bot = itr->second;
+                if (!bot || !grp->IsMember(bot->GetGUID()))
+                    continue;
+
+                TC_LOG_DEBUG("bg.battleground", "Battleground: NPCBot joined queue for bg queue type %u bg type %u: GUID %s, NAME %s (owner: %s)",
+                    bgQueueTypeId, bgTypeId, bot->GetGUID().ToString().c_str(), bot->GetName().c_str(), member->GetName().c_str());
+            }
+            //end npcbot
         }
         TC_LOG_DEBUG("bg.battleground", "Battleground: group end");
     }
diff --git a/src/server/game/Handlers/ItemHandler.cpp b/src/server/game/Handlers/ItemHandler.cpp
index 407f50143..eb3fb6ae6 100644
--- a/src/server/game/Handlers/ItemHandler.cpp
+++ b/src/server/game/Handlers/ItemHandler.cpp
@@ -30,6 +30,10 @@
 #include "World.h"
 #include "WorldPacket.h"
 
+// npcbot
+#include "botmgr.h"
+//end npcbot
+
 void WorldSession::HandleSplitItemOpcode(WorldPacket& recvData)
 {
     //TC_LOG_DEBUG("network", "WORLD: CMSG_SPLIT_ITEM");
@@ -658,6 +662,15 @@ void WorldSession::SendListInventory(ObjectGuid vendorGuid)
         {
             if (ItemTemplate const* itemTemplate = sObjectMgr->GetItemTemplate(item->item))
             {
+                // npcbot
+                if (_player->HaveBot())
+                {
+                    if (!(itemTemplate->AllowableClass & (_player->GetClassMask() | _player->GetBotMgr()->GetAllNpcBotsClassMask())) &&
+                        itemTemplate->Bonding == BIND_WHEN_PICKED_UP && !_player->IsGameMaster())
+                        continue;
+                }
+                else
+                // end npcbot
                 if (!(itemTemplate->AllowableClass & _player->GetClassMask()) && itemTemplate->Bonding == BIND_WHEN_PICKED_UP && !_player->IsGameMaster())
                     continue;
                 // Only display items in vendor lists for the team the
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index 3991676dc..4bc8da951 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -39,6 +39,12 @@
 #include "World.h"
 #include "WorldPacket.h"
 
+//npcbot
+#include "bot_ai.h"
+#include "botdatamgr.h"
+#include "botmgr.h"
+//end npcbot
+
 void WorldSession::HandleClientCastFlags(WorldPacket& recvPacket, uint8 castFlags, SpellCastTargets& targets)
 {
     // some spell cast packet including more data (for projectiles?)
@@ -631,6 +637,109 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //npcbot
+    if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->GetClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+
+        //npcbot minion without a record in outfits table
+        //OR
+        //npcbot's mirror image
+        Creature const* bot = unit->ToCreature();
+        if (!bot->IsNPCBot() && unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
+            if (Unit const* creator = unit->GetAuraEffectsByType(SPELL_AURA_CLONE_CASTER).front()->GetCaster())
+                if (creator->GetTypeId() == TYPEID_UNIT && creator->ToCreature()->IsNPCBot())
+                    bot = creator->ToCreature();
+
+        if (bot->IsNPCBot())
+        {
+            NpcBotAppearanceData const* appearData = BotDataMgr::SelectNpcBotAppearance(unit->GetEntry());
+
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetDisplayId());                                      // displayId
+            data << uint8(unit->GetRace());                                            // race
+            data << uint8(appearData ? appearData->gender : (uint8)unit->GetGender()); // gender
+            data << uint8(bot->GetBotAI()->GetPlayerClass());                          // class
+            data << uint8(appearData ? appearData->skin : 0);                          // skin
+            data << uint8(appearData ? appearData->face : 0);                          // face
+            data << uint8(appearData ? appearData->hair : 0);                          // hair
+            data << uint8(appearData ? appearData->haircolor : 0);                     // haircolor
+            data << uint8(appearData ? appearData->features : 0);                      // facialhair
+            data << uint32(0);                                                         // guildId
+
+            static uint8 const botItemSlots[MAX_CREATURE_OUTFIT_DISPLAYS] =
+            {
+                BOT_SLOT_HEAD,
+                BOT_SLOT_SHOULDERS,
+                BOT_SLOT_BODY,
+                BOT_SLOT_CHEST,
+                BOT_SLOT_WAIST,
+                BOT_SLOT_LEGS,
+                BOT_SLOT_FEET,
+                BOT_SLOT_WRIST,
+                BOT_SLOT_HANDS,
+                BOT_SLOT_BACK,
+                0//tabard
+            };
+
+            // Display items in visible slots
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+            {
+                uint8 slot = botItemSlots[i];
+                //Items not displayed on bot: tabard, head, back
+                if (slot == 0 ||
+                    (slot == BOT_SLOT_HEAD && BotMgr::ShowEquippedHelm() == false) ||
+                    (slot == BOT_SLOT_BACK && BotMgr::ShowEquippedCloak() == false))
+                {
+                    data << uint32(0);
+                    continue;
+                }
+
+                uint32 display_id = bot->GetBotAI()->GetEquipDisplayId(slot);
+                if (display_id)
+                    data << uint32(display_id);
+                else
+                {
+                    //don't allow to go naked
+                    if (slot == BOT_SLOT_CHEST)
+                        data << uint32(CHEST_HALISCAN);
+                    else if (slot == BOT_SLOT_LEGS)
+                        data << uint32(LEGS_HALISCAN);
+                    else
+                        data << uint32(0);
+                }
+            }
+
+            SendPacket(&data);
+            return;
+        }
+    }
+    //end npcbot
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
 
diff --git a/src/server/game/Instances/InstanceScript.cpp b/src/server/game/Instances/InstanceScript.cpp
index 5d207925e..32ef352cb 100644
--- a/src/server/game/Instances/InstanceScript.cpp
+++ b/src/server/game/Instances/InstanceScript.cpp
@@ -39,6 +39,10 @@
 #include <cstdarg>
 #include <sstream>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 BossBoundaryData::~BossBoundaryData()
 {
     for (const_iterator it = begin(); it != end(); ++it)
@@ -632,6 +636,15 @@ void InstanceScript::DoRemoveAurasDueToSpellOnPlayer(Player* player, uint32 spel
 
     player->RemoveAurasDueToSpell(spell);
 
+    //npcbot: include bots
+    if (player->HaveBot())
+    {
+        for (auto const& bitr : *player->GetBotMgr()->GetBotMap())
+            if (bitr.second && bitr.second->IsInWorld())
+                DoRemoveAurasDueToSpellOnNPCBot(bitr.second, spell);
+    }
+    //end npcbot
+
     if (!includePets)
         return;
 
@@ -667,6 +680,15 @@ void InstanceScript::DoCastSpellOnPlayer(Player* player, uint32 spell, bool incl
 
     player->CastSpell(player, spell, true);
 
+    //npcbot: include bots
+    if (player->HaveBot())
+    {
+        for (auto const& bitr : *player->GetBotMgr()->GetBotMap())
+            if (bitr.second && bitr.second->IsInWorld())
+                DoCastSpellOnNPCBot(bitr.second, spell);
+    }
+    //end npcbot
+
     if (!includePets)
         return;
 
@@ -688,6 +710,24 @@ void InstanceScript::DoCastSpellOnPlayer(Player* player, uint32 spell, bool incl
     }
 }
 
+//npcbot: hooks
+void InstanceScript::DoRemoveAurasDueToSpellOnNPCBot(Creature* bot, uint32 spell)
+{
+    ASSERT(bot && bot->IsNPCBot() && bot->IsInWorld() && !bot->IsFreeBot());
+    bot->RemoveAurasDueToSpell(spell);
+    if (Unit* botpet = bot->GetBotsPet())
+        botpet->RemoveAurasDueToSpell(spell);
+}
+
+void InstanceScript::DoCastSpellOnNPCBot(Creature* bot, uint32 spell)
+{
+    ASSERT(bot && bot->IsNPCBot() && bot->IsInWorld() && !bot->IsFreeBot());
+    bot->CastSpell(bot, spell, true);
+    if (Unit* botpet = bot->GetBotsPet())
+        botpet->CastSpell(botpet, spell, true);
+}
+//end npcbot
+
 bool InstanceScript::ServerAllowsTwoSideGroups()
 {
     return sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GROUP);
diff --git a/src/server/game/Instances/InstanceScript.h b/src/server/game/Instances/InstanceScript.h
index bd9349887..4c3b5860e 100644
--- a/src/server/game/Instances/InstanceScript.h
+++ b/src/server/game/Instances/InstanceScript.h
@@ -197,6 +197,13 @@ class TC_GAME_API InstanceScript : public ZoneScript
         // Called when a player successfully leaves the instance.
         virtual void OnPlayerLeave(Player* /*player*/) { }
 
+        //npcbot: map hooks
+        virtual void OnNPCBotEnter(Creature* /*bot*/) { }
+        virtual void OnNPCBotLeave(Creature* /*bot*/) { }
+        void DoRemoveAurasDueToSpellOnNPCBot(Creature* bot, uint32 spell);
+        void DoCastSpellOnNPCBot(Creature* bot, uint32 spell);
+        //end npcbot
+
         // Handle open / close objects
         // * use HandleGameObject(0, boolen, GO); in OnObjectCreate in instance scripts
         // * use HandleGameObject(GUID, boolen, nullptr); in any other script
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 58dcc7e66..f54a5553b 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -54,6 +54,11 @@
 #include "Hacks/boost_1_74_fibonacci_heap.h"
 BOOST_1_74_FIBONACCI_HEAP_MSVC_COMPILE_FIX(RespawnListContainer::value_type)
 
+//npcbot
+#include "botdatamgr.h"
+#include "botmgr.h"
+//end npcbot
+
 u_map_magic MapMagic        = { {'M','A','P','S'} };
 uint32 MapVersionMagic      = 10;
 u_map_magic MapAreaMagic    = { {'A','R','E','A'} };
@@ -3642,7 +3647,26 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+        //npcbot - count npcbots as group members (event if not in group)
+        {
+            if (itr->GetSource()->HaveBot() && BotMgr::LimitBots(this))
+            {
+                ++count;
+                BotMap const* botmap = itr->GetSource()->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = botmap->begin(); itr != botmap->end(); ++itr)
+                {
+                    Creature* cre = itr->second;
+                    if (!cre || !cre->IsInWorld() || cre->FindMap() != this || cre->IsTempBot())
+                        continue;
+                    ++count;
+                }
+                continue;
+            }
+        //end npcbot
             ++count;
+        //npcbot
+        }
+        //end npcbot
     return count;
 }
 
@@ -3708,6 +3732,10 @@ void Map::AddToActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->incUnloadActiveLock();
+        //npcbot
+        else if (c->IsNPCBot())
+            EnsureGridLoadedForActiveObject(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())), c);
+        //end npcbot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -3735,10 +3763,19 @@ void Map::RemoveFromActive(Creature* c)
     if (!c->IsPet() && c->GetSpawnId())
     {
         float x, y, z;
+        //npcbot: prevent crash from accessing deleted creatureData
+        if (c->IsNPCBot())
+            c->GetHomePosition().GetPosition(x, y, z);
+        else
+        //end npcbot
         c->GetRespawnPosition(x, y, z);
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->decUnloadActiveLock();
+        //npcbot
+        else if (c->IsNPCBot())
+            EnsureGridLoaded(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())));
+        //end npcbot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -4434,6 +4471,11 @@ void Map::SaveRespawnTime(SpawnObjectType type, ObjectGuid::LowType spawnId, uin
 
 void Map::SaveRespawnInfoDB(RespawnInfo const& info, CharacterDatabaseTransaction dbTrans)
 {
+    //npcbot: DO NOT save npcbots respawn time
+    if (info.type == SPAWN_TYPE_CREATURE && BotDataMgr::SelectNpcBotData(info.entry))
+        return;
+    //end npcbot
+
     CharacterDatabasePreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_RESPAWN);
     stmt->setUInt16(0, info.type);
     stmt->setUInt32(1, info.spawnId);
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index f80aded95..82d8fb627 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -34,6 +34,10 @@
 #include "WorldSession.h"
 #include "Opcodes.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 MapManager::MapManager()
     : _nextInstanceId(0), _scheduledScripts(0)
 {
@@ -51,6 +55,10 @@ void MapManager::Initialize()
     // Start mtmaps if needed.
     if (num_threads > 0)
         m_updater.activate(num_threads);
+
+    //npcbot: load bots
+    BotMgr::Initialize();
+    //end npcbot
 }
 
 void MapManager::InitializeVisibilityDistanceInfo()
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index 636e121c2..cfe835525 100644
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -819,6 +819,26 @@ void MotionMaster::MoveJump(float x, float y, float z, float o, float speedXY, f
     if (speedXY < 0.01f)
         return;
 
+    //npcbot: blademaser only (disabled)
+    /*
+    if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBot())
+    {
+        Movement::MoveSplineInit init(_owner);
+        init.MoveTo(x, y, z, false);
+        init.SetParabolic(speedZ, 0);
+        init.SetFacing(o);
+        init.SetOrientationFixed(true);
+        init.SetVelocity(speedXY);
+
+        GenericMovementGenerator* movement = new GenericMovementGenerator(std::move(init), EFFECT_MOTION_TYPE, EVENT_JUMP);
+        movement->Priority = MOTION_PRIORITY_HIGHEST;
+        movement->BaseUnitState = UNIT_STATE_JUMPING;
+        Add(movement);
+        return;
+    }
+    */
+    //end npcbot
+
     float moveTimeHalf = speedZ / Movement::gravity;
     float max_height = -Movement::computeFallElevation(moveTimeHalf, false, -speedZ);
 
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.cpp b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
index cc7e30c12..37341afb8 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
@@ -315,6 +315,23 @@ bool OPvPCapturePoint::Update(uint32 diff)
     if (!fact_diff)
         return false;
 
+    //npcbots - count bots as players but 2 times less affect and only if there is a players difference
+    uint32 botsCount[2];
+
+    for (uint8 team = 0; team != 2; ++team)
+    {
+        botsCount[team] = 0;
+
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(*itr))
+                botsCount[team] += player->GetNpcBotsCount();
+        }
+    }
+
+    fact_diff += 0.5f * ((float)botsCount[0] - (float)botsCount[1]) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    //end npcbot
+
     uint32 Challenger = 0;
     float maxDiff = m_maxSpeed * diff;
 
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index be8494df7..ddf4e9504 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -43,6 +43,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 // Trait which indicates whether this script type
 // must be assigned in the database.
 template<typename>
@@ -1043,6 +1047,10 @@ void ScriptMgr::Initialize()
     // LFGScripts
     lfg::AddSC_LFGScripts();
 
+    //npcbot: load bot scripts here
+    AddNpcBotScripts();
+    //end npcbot
+
     // Load all static linked scripts through the script loader function.
     ASSERT(_script_loader_callback,
            "Script loader callback wasn't registered!");
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index b0f641b80..6d85a6d51 100644
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -90,6 +90,8 @@ enum XPColorChar : uint8;
 
 #define VISIBLE_RANGE       166.0f                          //MAX visible range (size of grid)
 
+#define MOD_PRESENT_NPCBOTS 1
+
 /*
     @todo Add more script type classes.
 
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 968e31498..994ecb5d9 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -56,6 +56,10 @@
 #include "WorldSocket.h"
 #include <zlib.h>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 namespace {
 
 std::string const DefaultPlayerName = "<none>";
@@ -491,6 +495,10 @@ void WorldSession::LogoutPlayer(bool save)
     m_playerLogout = true;
     m_playerSave = save;
 
+    //npcbot - free all bots and remove from botmap
+    _player->RemoveAllBots();
+    //end npcbots
+
     if (_player)
     {
         if (ObjectGuid lguid = _player->GetLootGUID())
@@ -1656,6 +1664,16 @@ uint32 WorldSession::DosProtection::GetMaxPacketCounterAllowed(uint16 opcode) co
             maxPacketCounterAllowed = PLAYER_SLOTS_COUNT;
             break;
         }
+        //npcbot: prevent kicks when too many bots spawned in one spot
+        case CMSG_GET_MIRRORIMAGE_DATA:
+        {
+            if (BotMgr::GetBotInfoPacketsLimit() > -1)
+                maxPacketCounterAllowed = BotMgr::GetBotInfoPacketsLimit();
+            else
+                maxPacketCounterAllowed = 100;
+            break;
+        }
+        //end npcbot
         default:
         {
             maxPacketCounterAllowed = 100;
diff --git a/src/server/game/Spells/Auras/SpellAuraEffects.cpp b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
index 0d7f35138..af82eab21 100644
--- a/src/server/game/Spells/Auras/SpellAuraEffects.cpp
+++ b/src/server/game/Spells/Auras/SpellAuraEffects.cpp
@@ -1843,6 +1843,10 @@ void AuraEffect::HandleAuraModShapeshift(AuraApplication const* aurApp, uint8 mo
             case FORM_DEFENSIVESTANCE:
             case FORM_BERSERKERSTANCE:
             {
+                //npcbot: skip this, handled inside class ai
+                if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBot())
+                    break;
+                //end npcbot
                 uint32 Rage_val = 0;
                 // Defensive Tactics
                 if (form == FORM_DEFENSIVESTANCE)
@@ -1878,6 +1882,10 @@ void AuraEffect::HandleAuraModShapeshift(AuraApplication const* aurApp, uint8 mo
 
     if (target->GetTypeId() == TYPEID_PLAYER)
         target->ToPlayer()->InitDataForForm();
+    //npcbot: skip bots (handled inside AI)
+    else if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBotOrPet())
+    {}
+    //end npcbot
     else
         target->UpdateDisplayPower();
 
@@ -1892,6 +1900,11 @@ void AuraEffect::HandleAuraModShapeshift(AuraApplication const* aurApp, uint8 mo
         // and also HandleAuraModDisarm is not triggered
         if (!target->CanUseAttackType(BASE_ATTACK))
         {
+            //npcbot: skip bots (handled inside AI)
+            if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBotOrPet())
+            {}
+            else
+            //end npcbot
             if (Item* pItem = target->ToPlayer()->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
                 target->ToPlayer()->_ApplyWeaponDamage(EQUIPMENT_SLOT_MAINHAND, pItem->GetTemplate(), apply);
         }
@@ -2771,6 +2784,17 @@ void AuraEffect::HandleAuraModTotalThreat(AuraApplication const* aurApp, uint8 m
 
     Unit* target = aurApp->GetTarget();
 
+    //npcbot: handle for bots
+    if (target->IsAlive() && target->GetTypeId() == TYPEID_UNIT &&
+        target->ToCreature()->IsNPCBotOrPet())
+    {
+        Unit* caster = GetCaster();
+        if (caster && caster->IsAlive())
+            caster->GetThreatManager().UpdateMyTempModifiers();
+        return;
+    }
+    //end npcbot
+
     if (!target->IsAlive() || target->GetTypeId() != TYPEID_PLAYER)
         return;
 
@@ -5118,6 +5142,14 @@ void AuraEffect::HandlePeriodicDamageAurasTick(Unit* target, Unit* caster) const
 
     if (GetAuraType() == SPELL_AURA_PERIODIC_DAMAGE)
     {
+        //npcbot: Black Arrow damage on targets below 20%
+        if (GetSpellInfo()->SpellFamilyName == SPELLFAMILY_WARLOCK && (GetSpellInfo()->SpellFamilyFlags[1] & 0x4) &&
+            target->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT))
+        {
+            damage *= 5;
+        }
+        //end npcbot
+
         // leave only target depending bonuses, rest is handled in calculate amount
         if (GetBase()->GetType() == DYNOBJ_AURA_TYPE)
             damage = caster->SpellDamageBonusDone(target, GetSpellInfo(), damage, DOT, GetSpellEffectInfo(), { }, GetBase()->GetStackAmount());
@@ -5644,6 +5676,46 @@ void AuraEffect::HandleProcTriggerSpellAuraProc(AuraApplication* aurApp, ProcEve
     if (SpellInfo const* triggeredSpellInfo = sSpellMgr->GetSpellInfo(triggerSpellId))
     {
         TC_LOG_DEBUG("spells.aura.effect", "AuraEffect::HandleProcTriggerSpellAuraProc: Triggering spell %u from aura %u proc", triggeredSpellInfo->Id, GetId());
+
+        //npcbot
+        Aura const* triggeredByAura = aurApp->GetBase();
+        int32 basepoints0 = 0;
+        switch (triggerSpellId)
+        {
+            // Quest - Self Healing from resurrect (invisible in log)
+            case 25155:
+            {
+                switch (GetId())
+                {
+                    //Vampiric Aura
+                    case 20810:
+                    {
+                        DamageInfo const* dinfo = eventInfo.GetDamageInfo();
+                        uint32 damage = dinfo->GetDamage();
+                        if (!damage)
+                            return;
+
+                        // 100% / 25%
+                        if (triggerTarget->GetGUID() == triggeredByAura->GetCasterGUID())
+                            basepoints0 = int32(damage);
+                        else
+                            basepoints0 = int32(damage / 4);
+
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints0);
+                        triggerCaster->CastSpell(triggerTarget, triggerSpellId, args);
+                        return;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            default:
+                break;
+        }
+        //end npcbot
+
         triggerCaster->CastSpell(triggerTarget, triggeredSpellInfo->Id, this);
     }
     else
diff --git a/src/server/game/Spells/Auras/SpellAuras.cpp b/src/server/game/Spells/Auras/SpellAuras.cpp
index 84b52d86a..c5e60ccb1 100644
--- a/src/server/game/Spells/Auras/SpellAuras.cpp
+++ b/src/server/game/Spells/Auras/SpellAuras.cpp
@@ -572,6 +572,10 @@ void Aura::_ApplyForTarget(Unit* target, Unit* caster, AuraApplication* auraApp)
             caster->GetSpellHistory()->StartCooldown(m_spellInfo, castItem ? castItem->GetEntry() : 0, nullptr, true);
         }
     }
+    //npcbot: infinity cd for bots
+    if (caster && m_spellInfo->IsCooldownStartedOnEvent() && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->AddBotSpellCooldown(m_spellInfo->Id, std::numeric_limits<uint32>::max());
+    //end npcbot
 }
 
 void Aura::_UnapplyForTarget(Unit* target, Unit* caster, AuraApplication* auraApp)
@@ -600,6 +604,11 @@ void Aura::_UnapplyForTarget(Unit* target, Unit* caster, AuraApplication* auraAp
     if (caster && GetSpellInfo()->IsCooldownStartedOnEvent())
         // note: item based cooldowns and cooldown spell mods with charges ignored (unknown existed cases)
         caster->GetSpellHistory()->SendCooldownEvent(GetSpellInfo());
+
+    //npcbot: release cd state for bots
+    if (caster && m_spellInfo->IsCooldownStartedOnEvent() && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ReleaseBotSpellCooldown(m_spellInfo->Id);
+    //end npcbot
 }
 
 // removes aura from all targets
@@ -1661,6 +1670,20 @@ void Aura::HandleAuraSpecificMods(AuraApplication const* aurApp, Unit* caster, b
                     case 47788: // Guardian Spirit
                         if (removeMode != AURA_REMOVE_BY_EXPIRE)
                             break;
+
+                        //npcbot: handle Glyph of Guardian Spirit proc for bots
+                        if (Creature* bot = caster->ToCreature())
+                        {
+                            if (bot->IsNPCBot() && bot->HasSpellCooldown(47788))
+                            {
+                                bot->AddBotSpellCooldown(47788, 60000);
+                                bot->GetSpellHistory()->ResetCooldown(GetSpellInfo()->Id, true);
+                                bot->GetSpellHistory()->AddCooldown(GetSpellInfo()->Id, 0, std::chrono::seconds(60));
+                                break;
+                            }
+                        }
+                        //end npcbot
+
                         if (caster->GetTypeId() != TYPEID_PLAYER)
                             break;
 
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index dfdc492b0..6720144cd 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -62,6 +62,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 extern SpellEffectHandlerFn SpellEffectHandlers[TOTAL_SPELL_EFFECTS];
 
 SpellDestination::SpellDestination()
@@ -531,6 +535,15 @@ m_caster((info->HasAttribute(SPELL_ATTR6_CAST_BY_CHARMER) && caster->GetCharmerO
                     m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetTemplate()->Damage[0].DamageType);
     }
 
+    //npcbot: ranged weapon dmg school
+    if (m_attackType == RANGED_ATTACK && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() &&
+        ((1<<(m_caster->ToCreature()->GetBotClass()-1)) & CLASSMASK_WAND_USERS))
+    {
+        if (Item const* pItem = m_caster->ToCreature()->GetBotEquips(2))
+            m_spellSchoolMask = SpellSchoolMask(1 << pItem->GetTemplate()->Damage[0].DamageType);
+    }
+    //end npcbot
+
     if (originalCasterGUID)
         m_originalCasterGUID = originalCasterGUID;
     else
@@ -1179,6 +1192,12 @@ void Spell::SelectImplicitConeTargets(SpellEffectInfo const& spellEffectInfo, Sp
             {
                 if (Unit* unitCaster = m_caster->ToUnit())
                     maxTargets += unitCaster->GetTotalAuraModifierByAffectMask(SPELL_AURA_MOD_MAX_AFFECTED_TARGETS, m_spellInfo);
+
+                //npcbot - apply bot spell max targets mods
+                if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                    m_caster->ToCreature()->ApplyCreatureSpellMaxTargetsMods(m_spellInfo, maxTargets);
+                //end npcbot
+
                 Trinity::Containers::RandomResize(targets, maxTargets);
             }
 
@@ -1485,6 +1504,10 @@ void Spell::SelectImplicitCasterObjectTargets(SpellEffectInfo const& spellEffect
         case TARGET_UNIT_PET:
             if (Unit* unitCaster = m_caster->ToUnit())
                 target = unitCaster->GetGuardianPet();
+            //npcbot: allow bot pet as target
+            if (!target && m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+                target = m_caster->ToCreature()->GetBotsPet();
+            //end npcbot
             break;
         case TARGET_UNIT_SUMMONER:
             if (Unit* unitCaster = m_caster->ToUnit())
@@ -1552,6 +1575,11 @@ void Spell::SelectImplicitChainTargets(SpellEffectInfo const& spellEffectInfo, S
     if (Player* modOwner = m_caster->GetSpellModOwner())
         modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_JUMP_TARGETS, maxTargets, this);
 
+    //npcbot - apply bot spell max targets mods
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->ApplyCreatureSpellMaxTargetsMods(m_spellInfo, maxTargets);
+    //end npcbot
+
     if (maxTargets > 1)
     {
         // mark damage multipliers as used
@@ -2554,6 +2582,13 @@ void Spell::TargetInfo::DoDamageAndTriggers(Spell* spell)
                     if (!spell->m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET) && !spell->m_spellInfo->HasAttribute(SPELL_ATTR4_CANT_TRIGGER_ITEM_SPELLS))
                         caster->ToPlayer()->CastItemCombatSpell(*spellDamageInfo);
             }
+
+            //npcbot
+            if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot() && (procSpellType & (PROC_SPELL_TYPE_DAMAGE | PROC_SPELL_TYPE_NO_DMG_HEAL)) &&
+                !(spell->m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) && !spell->m_spellInfo->HasAttribute(SPELL_ATTR4_CANT_TRIGGER_ITEM_SPELLS) &&
+                (spell->m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || spell->m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+                caster->ToCreature()->CastCreatureItemCombatSpell(*spellDamageInfo);
+            //end npcbot
         }
 
         // set hitmask for finish procs
@@ -2590,6 +2625,15 @@ void Spell::TargetInfo::DoDamageAndTriggers(Spell* spell)
         else if (spell->m_caster->GetTypeId() == TYPEID_GAMEOBJECT && spell->m_caster->ToGameObject()->AI())
             spell->m_caster->ToGameObject()->AI()->SpellHitTarget(_spellHitTarget, spell->m_spellInfo);
 
+        //npcbot: vehicle spell hits
+        if (spell->m_caster->GetTypeId() == TYPEID_UNIT && spell->m_caster->ToCreature()->IsVehicle() && spell->m_caster->ToCreature()->GetCharmerGUID().IsCreature())
+        {
+            Unit const* bot = spell->m_caster->ToCreature()->GetCharmer();
+            if (bot && bot->ToCreature()->IsNPCBot())
+                bot->ToCreature()->AI()->SpellHitTarget(_spellHitTarget, spell->m_spellInfo);
+        }
+        //end npcbot
+
         if (HitAura)
         {
             if (AuraApplication* aurApp = HitAura->GetApplicationOfTarget(_spellHitTarget->GetGUID()))
@@ -2937,6 +2981,11 @@ bool Spell::UpdateChanneledTargetList()
         if (Player* modOwner = m_caster->GetSpellModOwner())
             modOwner->ApplySpellMod(m_spellInfo->Id, SPELLMOD_RANGE, range, this);
 
+        //npcbot: apply range mods
+        if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+            m_caster->ToCreature()->ApplyCreatureSpellRangeMods(m_spellInfo, range);
+        //end npcbot
+
         // add little tolerance level
         range += std::min(MAX_SPELL_RANGE_TOLERANCE, range*0.1f); // 10% but no more than MAX_SPELL_RANGE_TOLERANCE
     }
@@ -3290,6 +3339,11 @@ void Spell::_cast(bool skipCheck)
             SendCastResult(res, p1, p2);
             SendInterrupted(0);
 
+            //npcbot - hook for spellcast finish (unsuccessful)
+            if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBotOrPet())
+                BotMgr::OnBotSpellGo(m_caster->ToCreature(), this, false);
+            //end npcbot
+
             if (modOwner)
                 modOwner->SetSpellModTakingSpell(this, false);
 
@@ -3445,6 +3499,17 @@ void Spell::_cast(bool skipCheck)
         handle_immediate();
     }
 
+    //npcbot - hook for spellcast finish
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBotOrPet())
+        BotMgr::OnBotSpellGo(m_caster->ToCreature(), this);
+    //npcbot - hook for master's spellcast finish
+    else if (m_caster->GetTypeId() == TYPEID_PLAYER && m_caster->ToPlayer()->HaveBot())
+        BotMgr::OnBotOwnerSpellGo(m_caster->ToPlayer(), this);
+    //npcbot - hook for master's vehicle spellcast finish
+    else if (m_caster->ToUnit() && m_caster->ToUnit()->IsVehicle())
+        BotMgr::OnVehicleSpellGo(m_caster->ToUnit(), this);
+    //end npcbot
+
     CallScriptAfterCastHandlers();
 
     if (std::vector<int32> const* spell_triggered = sSpellMgr->GetSpellLinked(m_spellInfo->Id))
@@ -3724,6 +3789,12 @@ void Spell::SendSpellCooldown()
     if (m_caster->GetTypeId() == TYPEID_GAMEOBJECT)
         return;
 
+    //npcbot: handled by AI
+    if (m_caster->GetTypeId() == TYPEID_UNIT &&
+        (m_caster->ToCreature()->IsNPCBot() || m_caster->ToCreature()->IsNPCBotPet()))
+        return;
+    //end npcbot
+
     m_caster->ToUnit()->GetSpellHistory()->HandleCooldowns(m_spellInfo, m_CastItem, this);
 }
 
@@ -3901,6 +3972,9 @@ void Spell::finish(bool ok)
 
     // Stop Attack for some spells
     if (m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET))
+    //npcbot: disable for npcbots
+    if (!(unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot()))
+    //end npcbot
         unitCaster->AttackStop();
 }
 
@@ -4756,9 +4830,39 @@ void Spell::TakePower()
         }
     }
 
+    //npcbot: handle SPELLMOD_SPELL_COST_REFUND_ON_FAIL (druid Primal Precision)
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotClass() == CLASS_DRUID)
+    {
+        if (powerType == POWER_ENERGY/* || powerType == POWER_RAGE || powerType == POWER_RUNE*/)
+        {
+            if (ObjectGuid targetGUID = m_targets.GetUnitTargetGUID())
+            {
+                //auto ihit = std::find_if(std::being());
+                for (std::vector<TargetInfo>::iterator ihit= m_UniqueTargetInfo.begin(); ihit != m_UniqueTargetInfo.end(); ++ihit)
+                {
+                    if (ihit->TargetGUID == targetGUID && ihit->MissCondition != SPELL_MISS_NONE)
+                    {
+                        hit = false;
+                        //Primal Precision: 80% refund
+                        if ((m_spellInfo->SpellFamilyFlags[0] & 0x800000) || (m_spellInfo->SpellFamilyFlags[1] & 0x10000080))
+                            m_powerCost = m_powerCost / 5;
+                    }
+                    break;
+                }
+            }
+        }
+    }
+    //end npcbot
+
     if (powerType == POWER_RUNE)
     {
         TakeRunePower(hit);
+
+        //npcbot: spend runes (pass hit result)
+        if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotClass() == CLASS_DEATH_KNIGHT)
+            m_caster->ToCreature()->SpendBotRunes(m_spellInfo, hit);
+        //end npcbot
+
         return;
     }
 
@@ -5115,6 +5219,18 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
             else
                 return SPELL_FAILED_NOT_READY;
         }
+
+        //npcbot
+        if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() &&
+            m_caster->ToCreature()->HasSpellCooldown(m_spellInfo->Id))
+        {
+            //TC_LOG_ERROR("spells", "%s has cd of %u on %s", m_caster->GetName().c_str(), m_caster->ToCreature()->GetCreatureSpellCooldownDelay(m_spellInfo->Id), m_spellInfo->SpellName[0]);
+            if (m_triggeredByAuraSpell)
+                return SPELL_FAILED_DONT_REPORT;
+            else
+                return SPELL_FAILED_NOT_READY;
+        }
+        //end npcbot
     }
 
     if (m_spellInfo->HasAttribute(SPELL_ATTR7_IS_CHEAT_SPELL) && m_caster->IsUnit() && !m_caster->ToUnit()->HasUnitFlag2(UNIT_FLAG2_ALLOW_CHEAT_SPELLS))
@@ -5314,6 +5430,11 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
         {
             if (spellEffectInfo.TargetA.GetTarget() == TARGET_UNIT_PET)
             {
+                //npcbot: allow bot pet as target
+                if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot() && m_caster->ToCreature()->GetBotsPet())
+                    break;
+                else
+                //end npcbot
                 if (!unitCaster->GetGuardianPet())
                 {
                     if (m_triggeredByAuraSpell)              // not report pet not existence for triggered spells
@@ -5341,6 +5462,11 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
                 return SPELL_FAILED_NOT_IN_ARENA;
 
     // zone check
+    //npcbot: do not check location for bots (to avoid crash introduced in TC rev. 5cb8409f1ee57e8d)
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+    {}
+    else
+    //end npcbot
     if (m_caster->GetTypeId() != TYPEID_PLAYER || !m_caster->ToPlayer()->IsGameMaster())
     {
         uint32 zone, area;
@@ -6079,6 +6205,14 @@ SpellCastResult Spell::CheckCast(bool strict, uint32* param1 /*= nullptr*/, uint
     {
         if (Unit* unitCaster = m_caster->ToUnit())
         {
+            //npcbot
+            if (unitCaster->ToCreature() && unitCaster->ToCreature()->IsNPCBot())
+            {
+                if (!unitCaster->ToCreature()->GetCreatureComboPoints())
+                    return SPELL_FAILED_NO_COMBO_POINTS;
+            }
+            else
+            //end npcbot
             if (m_spellInfo->NeedsExplicitUnitTarget())
             {
                 if (!unitCaster->GetComboPoints(m_targets.GetUnitTarget()))
@@ -6418,6 +6552,11 @@ SpellCastResult Spell::CheckRange(bool strict) const
     float minRange, maxRange;
     std::tie(minRange, maxRange) = GetMinMaxRange(strict);
 
+    //npcbot: apply range mods
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->IsNPCBot())
+        m_caster->ToCreature()->ApplyCreatureSpellRangeMods(m_spellInfo, maxRange);
+    //end npcbot
+
     // dont check max_range to strictly after cast
     if (m_spellInfo->RangeEntry && m_spellInfo->RangeEntry->Flags != SPELL_RANGE_MELEE && !strict)
         maxRange += std::min(MAX_SPELL_RANGE_TOLERANCE, maxRange*0.1f); // 10% but no more than MAX_SPELL_RANGE_TOLERANCE
@@ -7731,6 +7870,13 @@ SpellCastResult Spell::CanOpenLock(SpellEffectInfo const& spellEffectInfo, uint3
                     skillValue = m_CastItem || m_caster->GetTypeId() != TYPEID_PLAYER ?
                         0 : m_caster->ToPlayer()->GetSkillValue(skillId);
 
+                    //npcbot: use bot skill if cast through gossip
+                    if (m_originalCasterGUID)
+                        if (Unit const* unit = ObjectAccessor::GetUnit(*m_caster, m_originalCasterGUID))
+                            if (unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetBotClass() == CLASS_ROGUE)
+                                skillValue = std::max<int32>(skillValue, int32(unit->GetLevel() * 5));
+                    //end npcbot
+
                     // skill bonus provided by casting spell (mostly item spells)
                     // add the effect base points modifier from the spell cast (cheat lock / skeleton key etc.)
                     if (spellEffectInfo.TargetA.GetTarget() == TARGET_GAMEOBJECT_ITEM_TARGET || spellEffectInfo.TargetB.GetTarget() == TARGET_GAMEOBJECT_ITEM_TARGET)
diff --git a/src/server/game/Spells/Spell.h b/src/server/game/Spells/Spell.h
index f71c88291..ab7778348 100644
--- a/src/server/game/Spells/Spell.h
+++ b/src/server/game/Spells/Spell.h
@@ -413,6 +413,9 @@ class TC_GAME_API Spell
 
         UsedSpellMods m_appliedMods;
 
+        //npcbot
+        int32 GetTimer() const { return m_timer; }
+        //end npcbot
         int32 GetCastTime() const { return m_casttime; }
         bool IsAutoRepeat() const { return m_autoRepeat; }
         void SetAutoRepeat(bool rep) { m_autoRepeat = rep; }
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 0c8a93f05..f9bd81e7a 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -500,6 +500,17 @@ void Spell::EffectSchoolDMG()
                     damage += int32(energy * multiple);
                     damage += int32(CalculatePct(unitCaster->ToPlayer()->GetComboPoints() * ap, 7));
                 }
+                //npcbot: Ferocious Bite support
+                else if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot() && (m_spellInfo->SpellFamilyFlags[0] & 0x800000) && m_spellInfo->SpellVisual[0] == 6587)
+                {
+                    // converts each extra point of energy into ($f1+$AP/410) additional damage
+                    float ap = unitCaster->GetTotalAttackPowerValue(BASE_ATTACK);
+                    float multiple = ap / 410 + effectInfo->DamageMultiplier;
+                    int32 energy = -(unitCaster->ModifyPower(POWER_ENERGY, -30));
+                    damage += int32(energy * multiple);
+                    damage += int32(CalculatePct(unitCaster->ToCreature()->GetCreatureComboPoints() * ap, 7));
+                }
+                //end npcbot
                 // Wrath
                 else if (m_spellInfo->SpellFamilyFlags[0] & 0x00000001)
                 {
@@ -562,6 +573,52 @@ void Spell::EffectSchoolDMG()
                                 damage += combo * 40;
                         }
                     }
+                    //npcbot: Envenom support
+                    else if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    {
+                        // consume from stack dozes not more that have combo-points
+                        if (uint8 combo = unitCaster->ToCreature()->GetCreatureComboPoints())
+                        {
+                            // Lookup for Deadly poison (only attacker applied)
+                            if (AuraEffect const* aurEff = unitTarget->GetAuraEffect(SPELL_AURA_PERIODIC_DAMAGE, SPELLFAMILY_ROGUE, 0x00010000, 0, 0, unitCaster->GetGUID()))
+                            {
+                                // count consumed deadly poison doses at target
+                                bool needConsume = true;
+                                uint32 spellId = aurEff->GetId();
+
+                                uint32 doses = aurEff->GetBase()->GetStackAmount();
+                                if (doses > combo)
+                                    doses = combo;
+
+                                // Master Poisoner
+                                Unit::AuraEffectList const& auraList = unitCaster->GetAuraEffectsByType(SPELL_AURA_MOD_AURA_DURATION_BY_DISPEL_NOT_STACK);
+                                for (Unit::AuraEffectList::const_iterator iter = auraList.begin(); iter != auraList.end(); ++iter)
+                                {
+                                    if ((*iter)->GetSpellInfo()->SpellFamilyName == SPELLFAMILY_ROGUE && (*iter)->GetSpellInfo()->SpellIconID == 1960)
+                                    {
+                                        uint32 chance = (*iter)->GetSpellInfo()->GetEffect(EFFECT_2).CalcValue(unitCaster);
+
+                                        if (chance && roll_chance_i(chance))
+                                            needConsume = false;
+
+                                        break;
+                                    }
+                                }
+
+                                if (needConsume)
+                                    for (uint32 i = 0; i < doses; ++i)
+                                        unitTarget->RemoveAuraFromStack(spellId, unitCaster->GetGUID());
+
+                                damage *= doses;
+                                damage += int32(unitCaster->GetTotalAttackPowerValue(BASE_ATTACK) * 0.09f * combo);
+                            }
+
+                            // Eviscerate and Envenom Bonus Damage (item set effect)
+                            if (unitCaster->HasAura(37169))
+                                damage += combo * 40;
+                        }
+                    }
+                    //end npcbot
                 }
                 // Eviscerate
                 else if (m_spellInfo->SpellFamilyFlags[0] & 0x00020000)
@@ -578,6 +635,20 @@ void Spell::EffectSchoolDMG()
                                 damage += combo*40;
                         }
                     }
+                    //npcbot: Eviscerate support
+                    else if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    {
+                        if (uint32 combo = unitCaster->ToCreature()->GetCreatureComboPoints())
+                        {
+                            float ap = unitCaster->GetTotalAttackPowerValue(BASE_ATTACK);
+                            damage += std::lroundf(ap * combo * 0.07f);
+
+                            // Eviscerate and Envenom Bonus Damage (item set effect)
+                            if (unitCaster->HasAura(37169))
+                                damage += combo*40;
+                        }
+                    }
+                    //end npcbot
                 }
                 break;
             }
@@ -628,6 +699,27 @@ void Spell::EffectSchoolDMG()
                             damage += irand(int32(dmg_min), int32(dmg_max));
                         damage += int32(caster->GetAmmoDPS() * caster->GetAttackTime(RANGED_ATTACK) * 0.001f);
                     }
+                    //npcbot: calculate bot weapon damage
+                    if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    {
+                        if (Item* item = unitCaster->ToCreature()->GetBotEquips(2/*BOT_SLOT_RANGED*/))
+                        {
+                            ItemTemplate const* weaponTemplate = item->GetTemplate();
+                            float dmg_min = 0.f;
+                            float dmg_max = 0.f;
+                            for (uint8 i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+                            {
+                                dmg_min += weaponTemplate->Damage[i].DamageMin;
+                                dmg_max += weaponTemplate->Damage[i].DamageMax;
+                            }
+                            if (dmg_max == 0.0f && dmg_min > dmg_max)
+                                damage += int32(dmg_min);
+                            else
+                                damage += irand(int32(dmg_min), int32(dmg_max));
+                            damage += int32(unitCaster->ToCreature()->GetCreatureAmmoDPS() * weaponTemplate->Delay * 0.001f);
+                        }
+                    }
+                    //end npcbot
                 }
                 break;
             }
@@ -733,6 +825,60 @@ void Spell::EffectTriggerSpell()
         // special cases
         switch (triggered_spell_id)
         {
+            //npcbot: triggered heal/energize calculation (effect)
+            // Quest - Self Healing from resurrect (invisible in log)
+            case 25155:
+            {
+                switch (m_spellInfo->Id)
+                {
+                    //Replenish Life (Regenerating Aura)
+                    case 34756:
+                    {
+                        //cannot target self
+                        if (unitCaster == unitTarget)
+                            return;
+
+                        // % of max health
+                        int32 basepoints0 = 0.01f * unitTarget->GetMaxHealth() * effectInfo->BasePoints;
+                        //TC_LOG_ERROR("entities.unit", "TriggerSpell(%u from %u): %s on %s base val %i,",
+                        //    triggered_spell_id, m_spellInfo->Id, m_caster->GetName().c_str(), unitTarget->GetName().c_str(), int32(basepoints0));
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints0);
+                        unitTarget->CastSpell(unitTarget, triggered_spell_id, args);
+                        return;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            // Energize (invisible in log)
+            case 60628:
+            {
+                switch (m_spellInfo->Id)
+                {
+                    //Replenish Mana
+                    case 33394:
+                    {
+                        //cannot target self
+                        if (unitCaster == unitTarget)
+                            return;
+
+                        // % of max mana
+                        int32 basepoints0 = effectInfo->BasePoints;
+                        //TC_LOG_ERROR("entities.unit", "TriggerSpell(%u from %u): %s on %s base val %i,",
+                        //    triggered_spell_id, m_spellInfo->Id, m_caster->GetName().c_str(), unitTarget->GetName().c_str(), int32(basepoints0));
+                        CastSpellExtraArgs args(true);
+                        args.AddSpellBP0(basepoints0);
+                        unitTarget->CastSpell(unitTarget, triggered_spell_id, args);
+                        return;
+                    }
+                    default:
+                        break;
+                }
+                break;
+            }
+            //end npcbot
             // Mirror Image
             case 58832:
             {
@@ -1127,6 +1273,11 @@ void Spell::EffectPowerDrain()
     if (powerType == POWER_MANA)
         power -= unitTarget->GetSpellCritDamageReduction(power);
 
+    //npcbot: handle Obsidian Destroyer's Drain Mana (target is friendly, amount is only limited by caster's max mana)
+    if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->GetBotClass() == 13 && powerType == POWER_MANA)
+        power = unitCaster->GetMaxPower(powerType);
+    //end npcbot
+
     int32 newDamage = -(unitTarget->ModifyPower(powerType, -int32(power)));
 
     // Don't restore from self drain
@@ -3066,6 +3217,14 @@ void Spell::EffectWeaponDmg()
                     if (Item* item = unitCaster->ToPlayer()->GetWeaponForAttack(m_attackType, true))
                         if (item->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
                             totalDamagePercentMod *= 1.5f;
+
+                //npcbot: handle bot weapons
+                // 50% more damage with daggers
+                if (unitCaster->GetTypeId() == TYPEID_UNIT && unitCaster->ToCreature()->IsNPCBot())
+                    if (Item const* weapon = unitCaster->ToCreature()->GetBotEquips(m_attackType))
+                        if (weapon->GetTemplate()->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER)
+                            totalDamagePercentMod *= 1.5f;
+                //end npcbot
             }
             // Mutilate (for each hand)
             else if (m_spellInfo->SpellFamilyFlags[1] & 0x6)
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index cabad3bd6..9ca42cbd0 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -31,6 +31,10 @@
 #include "SpellMgr.h"
 #include "Vehicle.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
 {
     switch (objType)
@@ -439,9 +443,38 @@ int32 SpellEffectInfo::CalcValue(WorldObject const* caster /*= nullptr*/, int32
     // random damage
     if (casterUnit)
     {
+        //npcbot: Life Burst heal tempfix 2013
+        float pointsPerComboPoint = PointsPerComboPoint;
+        if (_spellInfo->Id == 57143 && EffectIndex == EFFECT_1)
+        {
+            basePoints = 2500;
+            value = float(basePoints);
+            pointsPerComboPoint = 2500.f;
+        }
+        //npcbot: bonus amount from combo points and specific mods
+        if (casterUnit->GetTypeId() == TYPEID_UNIT && casterUnit->ToCreature()->IsNPCBot())
+        {
+            if (uint8 comboPoints = casterUnit->ToCreature()->GetCreatureComboPoints())
+                value += pointsPerComboPoint * comboPoints;
+        }
+        //npcbot: bonus amount from combo points (vehicle)
+        else if (casterUnit->IsVehicle() && casterUnit->GetTypeId() == TYPEID_UNIT && casterUnit->GetCharmerGUID().IsCreature() &&
+            PointsPerComboPoint)
+        {
+            Unit const* bot = casterUnit->GetCharmer();
+            if (bot && bot->ToCreature()->IsNPCBot())
+                if (uint8 comboPoints = bot->ToCreature()->GetCreatureComboPoints())
+                    value += pointsPerComboPoint * comboPoints;
+        }
+        //npcbot: bonus amount from combo points
+        else if (uint8 comboPoints = casterUnit->GetComboPoints())
+            value += pointsPerComboPoint * comboPoints;
+        //end npcbot
+        /*
         // bonus amount from combo points
         if (uint8 comboPoints = casterUnit->GetComboPoints())
             value += PointsPerComboPoint * comboPoints;
+        */
     }
 
     if (caster)
@@ -519,6 +552,11 @@ float SpellEffectInfo::CalcValueMultiplier(WorldObject* caster, Spell* spell /*=
     if (Player* modOwner = (caster ? caster->GetSpellModOwner() : nullptr))
         modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_VALUE_MULTIPLIER, multiplier, spell);
 
+    //npcbot - apply bot spell effect value mult mods
+    if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        BotMgr::ApplyBotEffectValueMultiplierMods(caster->ToCreature(), _spellInfo, EffectIndex, multiplier);
+    //end npcbot
+
     return multiplier;
 }
 
@@ -551,6 +589,11 @@ float SpellEffectInfo::CalcRadius(WorldObject* caster /*= nullptr*/, Spell* spel
 
         if (Player* modOwner = caster->GetSpellModOwner())
             modOwner->ApplySpellMod(_spellInfo->Id, SPELLMOD_RADIUS, radius, spell);
+
+        //npcbot - apply bot spell radius mods
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBotOrPet())
+            caster->ToCreature()->ApplyCreatureSpellRadiusMods(_spellInfo, radius);
+        //end npcbot
     }
 
     return radius;
@@ -1682,6 +1725,9 @@ SpellCastResult SpellInfo::CheckTarget(WorldObject const* caster, WorldObject co
 
     // corpseOwner and unit specific target checks
     if (HasAttribute(SPELL_ATTR3_ONLY_TARGET_PLAYERS) && unitTarget->GetTypeId() != TYPEID_PLAYER)
+        //npcbot: allow to target bots
+        if (!(unitTarget->GetTypeId() == TYPEID_UNIT && unitTarget->ToCreature()->IsNPCBot()))
+        //end npcbot
        return SPELL_FAILED_TARGET_NOT_PLAYER;
 
     if (!IsAllowingDeadTarget() && !unitTarget->IsAlive())
@@ -3239,6 +3285,11 @@ int32 SpellInfo::CalcPowerCost(WorldObject const* caster, SpellSchoolMask school
         }
     }
 
+    //npcbot - apply bot spell cost mods
+    if (powerCost > 0 && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        caster->ToCreature()->ApplyCreatureSpellCostMods(this, powerCost);
+    //end npcbot
+
     // PCT mod from user auras by school
     powerCost = int32(powerCost * (1.0f + unitCaster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER + school)));
     if (powerCost < 0)
diff --git a/src/server/game/Spells/SpellMgr.cpp b/src/server/game/Spells/SpellMgr.cpp
index ebcab3221..8fa27435f 100644
--- a/src/server/game/Spells/SpellMgr.cpp
+++ b/src/server/game/Spells/SpellMgr.cpp
@@ -2984,6 +2984,18 @@ void SpellMgr::LoadSpellInfoCorrections()
 {
     uint32 oldMSTime = getMSTime();
 
+    //npcbot: corrections for Gunship Battle Shoot: should be able to target creatures (Hurl Axe can)
+    ApplySpellFix({
+        70162,  // Shoot 10N
+        72566,  // Shoot 25N
+        72567,  // Shoot 10H
+        72568   // Shoot 25H
+        }, [](SpellInfo* spellInfo)
+    {
+        spellInfo->AttributesEx3 &= ~SPELL_ATTR3_ONLY_TARGET_PLAYERS;
+        spellInfo->TargetAuraSpell = 0;
+    });
+
     // Some spells have no amplitude set
     {
         ApplySpellFix({
diff --git a/src/server/scripts/Commands/cs_npc.cpp b/src/server/scripts/Commands/cs_npc.cpp
index e4ee87db7..c320e7b4a 100644
--- a/src/server/scripts/Commands/cs_npc.cpp
+++ b/src/server/scripts/Commands/cs_npc.cpp
@@ -119,6 +119,16 @@ public:
         if (!sObjectMgr->GetCreatureTemplate(id))
             return false;
 
+        //npcbot
+        CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(id);
+        if (cinfo && ((cinfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT) || (cinfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT_PET)))
+        {
+            handler->PSendSysMessage("You tried to spawn creature %u, which is part of NPCBots mod. To spawn bots use '.npcbot spawn' instead.", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        //end npcbot
+
         Player* chr = handler->GetSession()->GetPlayer();
         Map* map = chr->GetMap();
 
@@ -301,6 +311,16 @@ public:
                 handler->SetSentErrorMessage(true);
                 return false;
             }
+
+            //npcbot
+            if (creature->IsNPCBotOrPet())
+            {
+                handler->SendSysMessage("Selected creature has botAI assigned, use '.npcbot delete' instead");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            //end npcbot
+
             if (TempSummon* summon = creature->ToTempSummon())
             {
                 summon->UnSummon();
@@ -601,6 +621,17 @@ public:
             return false;
         }
 
+        //npcbot
+        CreatureTemplate const* ct = sObjectMgr->GetCreatureTemplate(data->id);
+        ASSERT(ct);
+        if ((ct->flags_extra & (CREATURE_FLAG_EXTRA_NPCBOT | CREATURE_FLAG_EXTRA_NPCBOT_PET)) != 0)
+        {
+            handler->PSendSysMessage("creature %u (id %u) is a part of NPCBots mod. Use '.npcbot move' instead", lowguid, data->id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        //end npcbot
+
         // update position in memory
         sObjectMgr->RemoveCreatureFromGrid(lowguid, data);
         const_cast<CreatureData*>(data)->spawnPoint.Relocate(*player);
diff --git a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp
index b60826b64..cf9d5a7b9 100644
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjalAI.cpp
@@ -994,6 +994,11 @@ void hyjalAI::DoOverrun(uint32 faction, const uint32 diff)
             {
                 for (std::list<Creature*>::const_iterator itr = creatures.begin(); itr != creatures.end(); ++itr)
                 {
+                    //npcbot: prevent bots from getting UNIT_FLAG_NON_ATTACKABLE
+                    if ((*itr)->IsNPCBotOrPet())
+                        continue;
+                    //end npcbot
+
                     if ((*itr) && (*itr)->IsAlive())
                     {
                         (*itr)->CastSpell(*itr, SPELL_TELEPORT_VISUAL, true);
diff --git a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
index 38511e9ea..0baa1fd48 100644
--- a/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
+++ b/src/server/scripts/Kalimdor/CavernsOfTime/BattleForMountHyjal/hyjal_trash.cpp
@@ -200,6 +200,14 @@ hyjal_trashAI::hyjal_trashAI(Creature* creature) : EscortAI(creature)
 
 void hyjal_trashAI::DamageTaken(Unit* done_by, uint32& damage, DamageEffectType /*damageType*/, SpellInfo const* /*spellInfo = nullptr*/)
 {
+    //npcbot:
+    if (done_by && done_by->GetTypeId() == TYPEID_UNIT && done_by->ToCreature()->IsNPCBotOrPet())
+    {
+        damageTaken += damage;
+        instance->SetData(DATA_RAIDDAMAGE, damage);
+    }
+    else
+    //end npcbot
     if (!done_by || done_by->GetTypeId() == TYPEID_PLAYER || done_by->IsPet())
     {
         damageTaken += damage;
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/boss_icecrown_gunship_battle.cpp b/src/server/scripts/Northrend/IcecrownCitadel/boss_icecrown_gunship_battle.cpp
index 36324199d..05429cf4b 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/boss_icecrown_gunship_battle.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/boss_icecrown_gunship_battle.cpp
@@ -38,6 +38,10 @@
 #include "Vehicle.h"
 #include <G3D/Vector3.h>
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 enum Texts
 {
     // High Overlord Saurfang
@@ -614,6 +618,10 @@ struct gunship_npc_AI : public ScriptedAI
     {
         if (Instance->GetBossState(DATA_ICECROWN_GUNSHIP_BATTLE) != IN_PROGRESS)
             return false;
+        //npcbot: allow to attack bots whereever they are
+        if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->IsNPCBotOrPet())
+            return true;
+        //end npcbot
         return target->HasAura(Instance->GetData(DATA_TEAM_IN_INSTANCE) == HORDE ? SPELL_ON_ORGRIMS_HAMMER_DECK : SPELL_ON_SKYBREAKER_DECK);
     }
 
@@ -744,6 +752,15 @@ class npc_gunship : public CreatureScript
                     hull->CastSpell(hull, explosionSpell, TRIGGERED_FULL_MASK);
                 }
 
+                //npcbot: kill bots
+                Transport::PassengerSet const& allpassengers = me->GetTransport()->GetPassengers();
+                for (Transport::PassengerSet::const_iterator citr = allpassengers.begin(); citr != allpassengers.end(); ++citr)
+                {
+                    if ((*citr)->GetTypeId() == TYPEID_PLAYER && (*citr)->ToPlayer()->HaveBot())
+                        (*citr)->ToPlayer()->GetBotMgr()->KillAllBots();
+                }
+                //end npcbot
+
                 creatures.clear();
                 GetCreatureListWithEntryInGrid(creatures, me, _teamInInstance == HORDE ? NPC_HORDE_GUNSHIP_CANNON : NPC_ALLIANCE_GUNSHIP_CANNON, 200.0f);
                 for (std::list<Creature*>::iterator itr = creatures.begin(); itr != creatures.end(); ++itr)
@@ -1511,6 +1528,17 @@ struct npc_gunship_boarding_addAI : public gunship_npc_AI
             return !me->_IsTargetAcceptable(player) || !me->CanStartAttack(player, true);
         });
 
+        //npcbot: allow bots as targets
+        auto npcbot_check = [this](Creature const* creature) {
+            return creature->IsNPCBotOrPet() && me->_IsTargetAcceptable(creature) && me->CanStartAttack(creature, true);
+        };
+        Creature* anybot = nullptr;
+        Trinity::CreatureSearcher botsearcher(me, anybot, npcbot_check);
+        Cell::VisitWorldObjects(me, botsearcher, 70.0f);
+        if (anybot)
+            return true;
+        //end npcbot
+
         return !players.empty();
     }
 
diff --git a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
index 849d8c8b5..e3b7be66d 100644
--- a/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
+++ b/src/server/scripts/Northrend/IcecrownCitadel/instance_icecrown_citadel.cpp
@@ -202,6 +202,19 @@ class instance_icecrown_citadel : public InstanceMapScript
                 DoRemoveAurasDueToSpellOnPlayer(player, TeamInInstance == ALLIANCE ? SPELL_STRENGHT_OF_WRYNN : SPELL_HELLSCREAMS_WARSONG, true, true);
             }
 
+            //npcbot: handle bot map transfer
+            void OnNPCBotEnter(Creature* bot) override
+            {
+                if (IsFactionBuffActive)
+                    DoCastSpellOnNPCBot(bot, TeamInInstance == ALLIANCE ? SPELL_STRENGHT_OF_WRYNN : SPELL_HELLSCREAMS_WARSONG);
+            }
+
+            void OnNPCBotLeave(Creature* bot) override
+            {
+                DoRemoveAurasDueToSpellOnNPCBot(bot, TeamInInstance == ALLIANCE ? SPELL_STRENGHT_OF_WRYNN : SPELL_HELLSCREAMS_WARSONG);
+            }
+            //end npcbot
+
             void OnCreatureCreate(Creature* creature) override
             {
                 if (creature->IsGuardian() && creature->GetOwnerGUID().IsPlayer())
@@ -210,6 +223,14 @@ class instance_icecrown_citadel : public InstanceMapScript
                         creature->CastSpell(creature, TeamInInstance == ALLIANCE ? SPELL_STRENGHT_OF_WRYNN : SPELL_HELLSCREAMS_WARSONG, true);
                 }
 
+                //npcbot: handle bot pets
+                if (creature->IsNPCBotPet())
+                {
+                    if (IsFactionBuffActive)
+                        creature->CastSpell(creature, TeamInInstance == ALLIANCE ? SPELL_STRENGHT_OF_WRYNN : SPELL_HELLSCREAMS_WARSONG, true);
+                }
+                //end npcbot
+
                 switch (creature->GetEntry())
                 {
                     case NPC_NERUBAR_BROODKEEPER:
diff --git a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
index 0367f0b59..4b77a9b96 100644
--- a/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
+++ b/src/server/scripts/Northrend/Naxxramas/boss_four_horsemen.cpp
@@ -565,7 +565,7 @@ struct boss_four_horsemen_lady : public boss_four_horsemen_baseAI
         if (me->HasUnitState(UNIT_STATE_CASTING))
             return;
 
-        if (Unit* target = SelectTarget(SelectTargetMethod::MinDistance, 0, 45.0f, true))
+        if (Unit* target = SelectTarget(SelectTargetMethod::MinDistance, 0, 45.0f))
             DoCast(target, SPELL_SHADOW_BOLT);
         else
         {
@@ -624,7 +624,7 @@ struct boss_four_horsemen_sir : public boss_four_horsemen_baseAI
         if (me->HasUnitState(UNIT_STATE_CASTING))
             return;
 
-        if (Unit* target = SelectTarget(SelectTargetMethod::MinDistance, 0, 45.0f, true))
+        if (Unit* target = SelectTarget(SelectTargetMethod::MinDistance, 0, 45.0f))
             DoCast(target, SPELL_HOLY_BOLT);
         else
         {
diff --git a/src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp b/src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp
index 0b59044f9..4a99fbb60 100644
--- a/src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp
+++ b/src/server/scripts/Outland/BlackTemple/boss_warlord_najentus.cpp
@@ -158,6 +158,23 @@ struct boss_najentus : public BossAI
                     target->SummonGameObject(GO_NAJENTUS_SPINE, *target, QuaternionData(), 30s);
                     Talk(SAY_NEEDLE);
                 }
+                //npcbot: try selecting npcbot
+                else if (Unit* bottarget = SelectTarget(SelectTargetMethod::Random, 1, [=](Unit const* target) -> bool {
+                    if (!target || target->GetTypeId() != TYPEID_UNIT || !target->ToCreature()->IsNPCBot() ||
+                        target->ToCreature()->IsFreeBot() ||
+                        !me->IsWithinCombatRange(target, 200.0f))
+                        return false;
+
+                    return true;
+                    }))
+                {
+                    DoCast(bottarget, SPELL_IMPALING_SPINE, true);
+                    _spineTargetGUID = bottarget->GetGUID();
+                    //must let target summon, otherwise you cannot click the spine
+                    bottarget->SummonGameObject(GO_NAJENTUS_SPINE, *bottarget, QuaternionData(), 30s);
+                    Talk(SAY_NEEDLE);
+                }
+                //end npcbot
                 events.Repeat(Seconds(20), Seconds(25));
                 break;
             case EVENT_NEEDLE:
diff --git a/src/server/scripts/Spells/spell_dk.cpp b/src/server/scripts/Spells/spell_dk.cpp
index 567032401..d78c4b8e8 100644
--- a/src/server/scripts/Spells/spell_dk.cpp
+++ b/src/server/scripts/Spells/spell_dk.cpp
@@ -360,6 +360,13 @@ private:
             return;
 
         amount = talentSpell->GetEffect(EFFECT_0).CalcValue(owner);
+        //npcbot: take bot attack power into account
+        if (Creature const* bot = owner->ToCreature())
+        {
+            if (bot->IsNPCBot())
+                amount += int32(2 * bot->GetTotalAttackPowerValue(BASE_ATTACK));
+        }
+        //end npcbot
         if (Player* player = owner->ToPlayer())
             amount += int32(2 * player->GetTotalAttackPowerValue(BASE_ATTACK));
     }
@@ -1848,6 +1855,16 @@ private:
     void Absorb(AuraEffect* /*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
     {
         // You have a chance equal to your Parry chance
+        //npcbot handle creature case (and prevent crashes)
+        Unit* target = GetTarget();
+        if (target->GetTypeId() == TYPEID_UNIT)
+        {
+            if (dmgInfo.GetDamageType() == SPELL_DIRECT_DAMAGE &&
+                roll_chance_f(target->ToCreature()->GetCreatureParryChance()))
+                absorbAmount = CalculatePct(dmgInfo.GetDamage(), absorbPct);
+        }
+        else
+        //end npcbot
         if ((dmgInfo.GetDamageType() == SPELL_DIRECT_DAMAGE) && roll_chance_f(GetTarget()->GetFloatValue(PLAYER_PARRY_PERCENTAGE)))
             absorbAmount = CalculatePct(dmgInfo.GetDamage(), absorbPct);
     }
diff --git a/src/server/scripts/Spells/spell_druid.cpp b/src/server/scripts/Spells/spell_druid.cpp
index 9efa58725..f747a7702 100644
--- a/src/server/scripts/Spells/spell_druid.cpp
+++ b/src/server/scripts/Spells/spell_druid.cpp
@@ -31,6 +31,11 @@
 #include "SpellMgr.h"
 #include "SpellScript.h"
 
+//npcbot
+#include "Creature.h"
+#include "Group.h"
+//end npcbot
+
 enum DruidSpells
 {
     SPELL_DRUID_BEAR_FORM_PASSIVE           = 1178,
@@ -1195,6 +1200,10 @@ class spell_dru_rip : public AuraScript
     bool Load() override
     {
         Unit* caster = GetCaster();
+        //npcbot
+        if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
         return caster && GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -1204,6 +1213,22 @@ class spell_dru_rip : public AuraScript
 
         if (Unit* caster = GetCaster())
         {
+            //npcbot
+            if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            {
+                uint8 botcp = caster->ToCreature()->GetCreatureComboPoints();
+                // Idol of Feral Shadows. Can't be handled as SpellMod due its dependency from CPs
+                if (AuraEffect const* auraEffIdolOfFeralShadows = caster->GetAuraEffect(SPELL_DRUID_IDOL_OF_FERAL_SHADOWS, EFFECT_0))
+                    amount += botcp * auraEffIdolOfFeralShadows->GetAmount();
+                // Idol of Worship. Can't be handled as SpellMod due its dependency from CPs
+                else if (AuraEffect const* auraEffIdolOfWorship = caster->GetAuraEffect(SPELL_DRUID_IDOL_OF_WORSHIP, EFFECT_0))
+                    amount += botcp * auraEffIdolOfWorship->GetAmount();
+
+                amount += int32(CalculatePct(caster->GetTotalAttackPowerValue(BASE_ATTACK), botcp));
+                return;
+            }
+            //end npcbot
+
             // 0.01 * $AP * cp
             uint8 cp = caster->ToPlayer()->GetComboPoints();
 
@@ -1752,6 +1777,41 @@ class spell_dru_t10_restoration_4p_bonus : public SpellScript
 
     void FilterTargets(std::list<WorldObject*>& targets)
     {
+        //npcbot
+        if (Creature* bot = GetCaster()->ToCreature())
+        {
+            if (bot->IsFreeBot())
+            {
+                targets.clear();
+                targets.push_back(bot);
+                return;
+            }
+
+            targets.remove(GetExplTargetUnit());
+            std::list<Unit*> tempTargets;
+            Group const* gr = bot->GetBotOwner()->GetGroup();
+            if (gr && !gr->IsMember(bot->GetGUID()))
+                gr = nullptr;
+
+            if (gr)
+                for (std::list<WorldObject*>::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+                    if (gr->IsMember((*itr)->GetGUID()))
+                        tempTargets.push_back((*itr)->ToUnit());
+
+            if (tempTargets.empty())
+            {
+                targets.clear();
+                FinishCast(SPELL_FAILED_DONT_REPORT);
+                return;
+            }
+
+            Unit* target = Trinity::Containers::SelectRandomContainerElement(tempTargets);
+            targets.clear();
+            targets.push_back(target);
+            return;
+        }
+        //end npcbot
+
         if (!GetCaster()->ToPlayer()->GetGroup())
         {
             targets.clear();
@@ -1803,6 +1863,12 @@ class spell_dru_t10_restoration_4p_bonus_dummy : public AuraScript
         if (!healInfo || !healInfo->GetHeal())
             return false;
 
+        //npcbot: support for Item - Druid T10 Restoration 4P Bonus (Rejuvenation)
+        Creature* creCaster = eventInfo.GetActor()->ToCreature();
+        if (creCaster && creCaster->IsNPCBot())
+            return true;
+        //end npcbot
+
         Player* caster = eventInfo.GetActor()->ToPlayer();
         if (!caster)
             return false;
diff --git a/src/server/scripts/Spells/spell_generic.cpp b/src/server/scripts/Spells/spell_generic.cpp
index e5d16284a..c75c09aa3 100644
--- a/src/server/scripts/Spells/spell_generic.cpp
+++ b/src/server/scripts/Spells/spell_generic.cpp
@@ -247,6 +247,11 @@ class spell_gen_arena_drink : public AuraScript
 
     bool Load() override
     {
+        //npcbot
+        if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
+
         return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -268,6 +273,14 @@ class spell_gen_arena_drink : public AuraScript
         if (!regen)
             return;
 
+        //npcbot
+        if (GetCaster()->GetTypeId() == TYPEID_UNIT)
+        {
+            isPeriodic = false;
+            return;
+        }
+        //end npcbot
+
         // default case - not in arena
         if (!GetCaster()->ToPlayer()->InArena())
             isPeriodic = false;
@@ -279,6 +292,14 @@ class spell_gen_arena_drink : public AuraScript
         if (!regen)
             return;
 
+        //npcbot
+        if (GetCaster()->GetTypeId() == TYPEID_UNIT)
+        {
+            regen->ChangeAmount(amount);
+            return;
+        }
+        //end npcbot
+
         // default case - not in arena
         if (!GetCaster()->ToPlayer()->InArena())
             regen->ChangeAmount(amount);
@@ -3631,6 +3652,10 @@ class spell_gen_vehicle_scaling : public AuraScript
 
     bool Load() override
     {
+        //npcbot
+        if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
         return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -3653,7 +3678,19 @@ class spell_gen_vehicle_scaling : public AuraScript
                 break;
         }
 
+        //npcbot
+        /*
+        //end npcbot
         float avgILvl = caster->ToPlayer()->GetAverageItemLevel();
+        //npcbot
+        */
+        float avgILvl;
+        if (caster->GetTypeId() == TYPEID_PLAYER)
+            avgILvl = caster->ToPlayer()->GetAverageItemLevel();
+        else
+            avgILvl = caster->ToCreature()->GetBotAverageItemLevel();
+        //end npcbot
+
         if (avgILvl < baseItemLevel)
             return;                     /// @todo Research possibility of scaling down
 
diff --git a/src/server/scripts/Spells/spell_hunter.cpp b/src/server/scripts/Spells/spell_hunter.cpp
index 09b314d7f..b1b94aefd 100644
--- a/src/server/scripts/Spells/spell_hunter.cpp
+++ b/src/server/scripts/Spells/spell_hunter.cpp
@@ -1122,6 +1122,22 @@ class spell_hun_sniper_training : public AuraScript
 
     void HandleUpdatePeriodic(AuraEffect* aurEff)
     {
+        //npcbot: handle creatures, remove dead trigger
+        if (!GetUnitOwner()->IsAlive())
+            return;
+        if (Creature const* bot = GetUnitOwner()->ToCreature())
+        {
+            if (!bot->IsNPCBot())
+                return;
+
+            int32 baseAmount = aurEff->GetBaseAmount();
+            int32 amount = bot->isMoving() ?
+                bot->CalculateSpellDamage(aurEff->GetSpellEffectInfo(), &baseAmount) :
+                aurEff->GetAmount() - 1;
+            aurEff->SetAmount(amount);
+            return;
+        }
+        //end npcbot
         if (Player* playerTarget = GetUnitOwner()->ToPlayer())
         {
             int32 baseAmount = aurEff->GetBaseAmount();
diff --git a/src/server/scripts/Spells/spell_item.cpp b/src/server/scripts/Spells/spell_item.cpp
index 2cf9d7bc5..e62bd70f3 100644
--- a/src/server/scripts/Spells/spell_item.cpp
+++ b/src/server/scripts/Spells/spell_item.cpp
@@ -38,6 +38,10 @@
 #include "SpellMgr.h"
 #include "SpellScript.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 enum GenericData
 {
     SPELL_ARCANITE_DRAGONLING           = 19804,
@@ -3654,6 +3658,14 @@ class spell_item_death_choice : public AuraScript
         float str = caster->GetStat(STAT_STRENGTH);
         float agi = caster->GetStat(STAT_AGILITY);
 
+        //npcbot: try get stats
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        {
+            str = BotMgr::GetBotStat(caster->ToCreature(), BOT_STAT_MOD_STRENGTH);
+            agi = BotMgr::GetBotStat(caster->ToCreature(), BOT_STAT_MOD_AGILITY);
+        }
+        //end npcbot
+
         switch (aurEff->GetId())
         {
             case SPELL_DEATH_CHOICE_NORMAL_AURA:
@@ -3800,6 +3812,17 @@ class spell_item_darkmoon_card_greatness : public AuraScript
         float agi = caster->GetStat(STAT_AGILITY);
         float intl = caster->GetStat(STAT_INTELLECT);
         float spi = caster->GetStat(STAT_SPIRIT);
+
+        //npcbot: try get stats
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+        {
+            str = BotMgr::GetBotStat(caster->ToCreature(), BOT_STAT_MOD_STRENGTH);
+            agi = BotMgr::GetBotStat(caster->ToCreature(), BOT_STAT_MOD_AGILITY);
+            intl = BotMgr::GetBotStat(caster->ToCreature(), BOT_STAT_MOD_INTELLECT);
+            spi = BotMgr::GetBotStat(caster->ToCreature(), BOT_STAT_MOD_SPIRIT);
+        }
+        //end npcbot
+
         float stat = 0.0f;
 
         uint32 spellTrigger = SPELL_DARKMOON_CARD_STRENGTH;
diff --git a/src/server/scripts/Spells/spell_mage.cpp b/src/server/scripts/Spells/spell_mage.cpp
index 545dc8d08..96efbbf1c 100644
--- a/src/server/scripts/Spells/spell_mage.cpp
+++ b/src/server/scripts/Spells/spell_mage.cpp
@@ -1161,6 +1161,12 @@ class spell_mage_summon_water_elemental : public SpellScript
     void HandleDummy(SpellEffIndex /*effIndex*/)
     {
         Unit* caster = GetCaster();
+
+        //npcbot: prevent default handler for bots
+        if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            return;
+        //end npcbot
+
         // Glyph of Eternal Water
         if (caster->HasAura(SPELL_MAGE_GLYPH_OF_ETERNAL_WATER))
             caster->CastSpell(caster, SPELL_MAGE_SUMMON_WATER_ELEMENTAL_PERMANENT, true);
diff --git a/src/server/scripts/Spells/spell_paladin.cpp b/src/server/scripts/Spells/spell_paladin.cpp
index 5f7f1303c..ee7e18817 100644
--- a/src/server/scripts/Spells/spell_paladin.cpp
+++ b/src/server/scripts/Spells/spell_paladin.cpp
@@ -32,6 +32,10 @@
 #include "SpellMgr.h"
 #include "SpellScript.h"
 
+//npcbot
+#include "Creature.h"
+//end npcbot
+
 enum PaladinSpells
 {
     SPELL_PALADIN_DIVINE_PLEA                    = 54428,
@@ -164,6 +168,12 @@ class spell_pal_ardent_defender : public AuraScript
     {
         _absorbPct = GetEffectInfo(EFFECT_0).CalcValue();
         _healPct = GetEffectInfo(EFFECT_1).CalcValue();
+
+        //npcbot - allow for npcbots
+        if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
+
         return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -178,6 +188,40 @@ class spell_pal_ardent_defender : public AuraScript
         Unit* victim = GetTarget();
         int32 remainingHealth = victim->GetHealth() - dmgInfo.GetDamage();
         uint32 allowedHealth = victim->CountPctFromMaxHealth(35);
+
+        //npcbot - calc for bots
+        if (victim->GetTypeId() == TYPEID_UNIT/* && victim->ToCreature()->IsNPCBot()*/)
+        {
+            if (remainingHealth <= 0 && !victim->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL) &&
+                !victim->ToCreature()->HasSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
+            {
+                // Cast healing spell, completely avoid damage
+                absorbAmount = dmgInfo.GetDamage();
+
+                float defenseSkillValue = victim->GetDefenseSkillValue();
+                // Max heal when defense skill denies critical hits from raid bosses
+                // Formula: max defense at level + 140 (rating from gear)
+                float reqDefForMaxHeal = victim->GetMaxSkillValueForLevel() + 140.0f;
+                float defenseFactor = std::min(1.0f, defenseSkillValue / reqDefForMaxHeal);
+
+                CastSpellExtraArgs args(aurEff);
+                args.AddSpellBP0(victim->CountPctFromMaxHealth(lroundf(_healPct * defenseFactor)));
+                victim->CastSpell(victim, PAL_SPELL_ARDENT_DEFENDER_HEAL, args);
+                victim->GetSpellHistory()->AddCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, 0, std::chrono::minutes(2));
+            }
+            else if (remainingHealth < int32(allowedHealth))
+            {
+                // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                uint32 damageToReduce = (victim->GetHealth() < allowedHealth)
+                    ? dmgInfo.GetDamage()
+                    : allowedHealth - remainingHealth;
+                absorbAmount = CalculatePct(damageToReduce, _absorbPct);
+            }
+
+            return;
+        }
+        //end npcbot
+
         // If damage kills us
         if (remainingHealth <= 0 && !victim->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
         {
@@ -458,6 +502,23 @@ class spell_pal_divine_sacrifice : public AuraScript
     {
         if (Unit* caster = GetCaster())
         {
+            //npcbot: handle for bots
+            if (caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+            {
+                Player const* owner = caster->ToCreature()->GetBotOwner();
+                if (!owner || owner->GetTypeId() != TYPEID_PLAYER)
+                    return false;
+
+                if (owner->GetGroup())
+                    groupSize = owner->GetGroup()->GetMembersCount();
+                else
+                    groupSize = 1 + owner->GetNpcBotsCount();
+
+                remainingAmount = (caster->CountPctFromMaxHealth(GetEffectInfo(EFFECT_2).CalcValue(caster)) * groupSize);
+                minHpPct = GetEffectInfo(EFFECT_1).CalcValue(caster);
+                return true;
+            }
+            //end npcbot
             if (caster->GetTypeId() == TYPEID_PLAYER)
             {
                 if (caster->ToPlayer()->GetGroup())
@@ -1473,6 +1534,9 @@ class spell_pal_righteous_defense : public SpellScript
     {
         Unit* caster = GetCaster();
         if (caster->GetTypeId() != TYPEID_PLAYER)
+            //npcbot: this player check makes no sense
+            if (!(caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot()))
+            //end npcbot
             return SPELL_FAILED_DONT_REPORT;
 
         if (Unit* target = GetExplTargetUnit())
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index ba55c1cbc..cae2088d9 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -787,6 +787,10 @@ class spell_pri_penance : public SpellScript
 
     bool Load() override
     {
+        //npcbot
+        if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
         return GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -829,6 +833,10 @@ class spell_pri_penance : public SpellScript
     SpellCastResult CheckCast()
     {
         Player* caster = GetCaster()->ToPlayer();
+        //npcbot: check for player makes no sense
+        if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+            caster = (Player*)GetCaster();
+        //end npcbot
         if (Unit* target = GetExplTargetUnit())
             if (!caster->IsFriendlyTo(target))
             {
@@ -1001,6 +1009,10 @@ class spell_pri_renew : public AuraScript
 
     bool Load() override
     {
+        //npcbot
+        if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
         return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
     }
 
diff --git a/src/server/scripts/Spells/spell_rogue.cpp b/src/server/scripts/Spells/spell_rogue.cpp
index bf46ebf02..56de8298c 100644
--- a/src/server/scripts/Spells/spell_rogue.cpp
+++ b/src/server/scripts/Spells/spell_rogue.cpp
@@ -33,6 +33,10 @@
 #include "SpellMgr.h"
 #include "SpellScript.h"
 
+//npcbot
+#include "Creature.h"
+//end npcbot
+
 enum RogueSpells
 {
     SPELL_ROGUE_BLADE_FLURRY_EXTRA_ATTACK       = 22482,
@@ -110,6 +114,10 @@ class spell_rog_cheat_death : public AuraScript
     bool Load() override
     {
         absorbChance = GetEffectInfo(EFFECT_0).CalcValue();
+        //npcbot
+        if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
         return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
     }
 
@@ -121,6 +129,27 @@ class spell_rog_cheat_death : public AuraScript
 
     void Absorb(AuraEffect* /*aurEff*/, DamageInfo & dmgInfo, uint32 & absorbAmount)
     {
+        //npcbot
+        if (Creature* bot = GetTarget()->ToCreature())
+        {
+            if (dmgInfo.GetDamage() < bot->GetHealth() || bot->HasSpellCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) ||
+                bot->GetSpellHistory()->HasCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) || !roll_chance_i(absorbChance))
+                return;
+
+            bot->CastSpell(bot, SPELL_ROGUE_CHEAT_DEATH_COOLDOWN, true);
+            bot->GetSpellHistory()->AddCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN, 0, std::chrono::minutes(1));
+
+            uint32 health10 = bot->CountPctFromMaxHealth(10);
+
+            if (bot->GetHealth() > health10)
+                absorbAmount = dmgInfo.GetDamage() - bot->GetHealth() + health10;
+            else
+                absorbAmount = dmgInfo.GetDamage();
+
+            return;
+        }
+        //end npcbot
+
         Player* target = GetTarget()->ToPlayer();
         if (dmgInfo.GetDamage() < target->GetHealth() || target->GetSpellHistory()->HasCooldown(SPELL_ROGUE_CHEAT_DEATH_COOLDOWN) || !roll_chance_i(absorbChance))
             return;
@@ -563,6 +592,10 @@ class spell_rog_rupture : public SpellScriptLoader
             {
                 Unit* caster = GetCaster();
                 BonusDuration = 0;
+                //npcbot
+                if (caster && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
                 return caster && caster->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -582,6 +615,18 @@ class spell_rog_rupture : public SpellScriptLoader
                         0.0375f         // 5 points: ${($m1 + $b1*5 + 0.0375 * $AP) * 8} damage over 16 secs
                     };
 
+                    //npcbot
+                    if (caster->GetTypeId() == TYPEID_UNIT)
+                    {
+                        uint8 cp = caster->ToCreature()->GetCreatureComboPoints();
+                        if (cp > 5)
+                            cp = 5;
+
+                        amount += int32(caster->GetTotalAttackPowerValue(BASE_ATTACK) * attackpowerPerCombo[cp]);
+                        return;
+                    }
+                    //end npcbot
+
                     uint8 cp = caster->ToPlayer()->GetComboPoints();
                     if (cp > 5)
                         cp = 5;
@@ -702,6 +747,12 @@ class spell_rog_setup : public AuraScript
             if (eventInfo.GetActor() == target->GetSelectedUnit())
                 return true;
 
+        //npcbot
+        if (Creature* creature = GetTarget()->ToCreature())
+            if (creature->IsNPCBot())
+                return true;
+        //end npcbot
+
         return false;
     }
 
@@ -902,6 +953,11 @@ class spell_rog_honor_among_thieves_proc_aura : public AuraScript
         if (!caster)
             return;
 
+        //npcbot
+        if (Creature* bot = caster->ToCreature())
+            bot->CastSpell(nullptr, SPELL_ROGUE_HONOR_AMONG_THIEVES_2, true);
+        //end npcbot
+
         if (Player* player = caster->ToPlayer())
             player->CastSpell(nullptr, SPELL_ROGUE_HONOR_AMONG_THIEVES_2, true);
     }
diff --git a/src/server/scripts/Spells/spell_shaman.cpp b/src/server/scripts/Spells/spell_shaman.cpp
index 74bed44d1..e486c1dd2 100644
--- a/src/server/scripts/Spells/spell_shaman.cpp
+++ b/src/server/scripts/Spells/spell_shaman.cpp
@@ -407,6 +407,16 @@ class spell_sha_earthbind_totem : public AuraScript
     {
         if (!GetCaster())
             return;
+
+        //npcbot: workaround for bots
+        if (ObjectGuid creatorGuid = GetCaster()->GetCreatorGUID())
+            if (!creatorGuid.IsPlayer())
+                if (Creature const* bot = ObjectAccessor::GetCreature(*GetCaster(), creatorGuid))
+                    if (AuraEffect const* aur = bot->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 2289, 0))
+                        if (roll_chance_i(aur->GetBaseAmount()))
+                            GetTarget()->CastSpell(nullptr, SPELL_SHAMAN_TOTEM_EARTHEN_POWER, true);
+        //end npcbot
+
         if (Player* owner = GetCaster()->GetCharmerOrOwnerPlayerOrPlayerItself())
             if (AuraEffect* aur = owner->GetDummyAuraEffect(SPELLFAMILY_SHAMAN, 2289, 0))
                 if (roll_chance_i(aur->GetBaseAmount()))
@@ -590,6 +600,23 @@ class spell_sha_flametongue_weapon : public AuraScript
 
     bool CheckProc(ProcEventInfo& eventInfo)
     {
+        //npcbot: handle bot enchant check
+        Creature* bot = eventInfo.GetActor()->ToCreature();
+        if (bot && bot->IsNPCBot())
+        {
+            Item* item = bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID());
+            if (!item)
+                return false;
+
+            WeaponAttackType attType = bot->GetBotEquips(0/*BOT_SLOT_MAINHAND*/) == item ? BASE_ATTACK : OFF_ATTACK;
+            if ((attType == BASE_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)) ||
+                (attType == OFF_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_OFFHAND_ATTACK)))
+                return false;
+
+            return true;
+        }
+        //end npcbot
+
         Player* player = eventInfo.GetActor()->ToPlayer();
         if (!player)
             return false;
@@ -613,6 +640,42 @@ class spell_sha_flametongue_weapon : public AuraScript
     {
         PreventDefaultAction();
 
+        //npcbot: handle bot enchant proc
+        Creature* bot = eventInfo.GetActor()->ToCreature();
+        if (bot && bot->IsNPCBot())
+        {
+            Unit* target = eventInfo.GetProcTarget();
+            WeaponAttackType attType;
+            if (eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)
+                attType = BASE_ATTACK;
+            else
+                attType = OFF_ATTACK;
+
+            Item* item = ASSERT_NOTNULL(bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID()));
+
+            float basePoints = aurEff->GetSpellEffectInfo().CalcValue();
+
+            float attackSpeed = bot->GetAttackTime(attType) / 1000.f;
+            float fireDamage = basePoints / 100.0f;
+            fireDamage *= attackSpeed;
+
+            RoundToInterval(fireDamage, basePoints / 77.0f, basePoints / 25.0f);
+            float spellPowerBonus = bot->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_FIRE);
+            spellPowerBonus += target->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_DAMAGE_TAKEN, SPELL_SCHOOL_MASK_FIRE);
+
+            float const factorMod = bot->CalculateSpellpowerCoefficientLevelPenalty(GetSpellInfo());
+            float const spCoeff = 0.03811f;
+            spellPowerBonus *= spCoeff * attackSpeed * factorMod;
+
+            CastSpellExtraArgs args(aurEff);
+            args
+                .SetCastItem(item)
+                .AddSpellBP0(fireDamage + spellPowerBonus);
+            bot->CastSpell(target, SPELL_SHAMAN_FLAMETONGUE_ATTACK, args);
+            return;
+        }
+        //end npcbot
+
         Player* player = eventInfo.GetActor()->ToPlayer();
         Unit* target = eventInfo.GetProcTarget();
         WeaponAttackType attType = BASE_ATTACK;
@@ -1834,6 +1897,23 @@ class spell_sha_windfury_weapon : public AuraScript
 
     bool CheckProc(ProcEventInfo& eventInfo)
     {
+        //npcbot: handle bot enchant check
+        Creature* bot = eventInfo.GetActor()->ToCreature();
+        if (bot && bot->IsNPCBot())
+        {
+            Item* item = bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID());
+            if (!item)
+                return false;
+
+            WeaponAttackType attType = bot->GetBotEquips(0/*BOT_SLOT_MAINHAND*/) == item ? BASE_ATTACK : OFF_ATTACK;
+            if ((attType == BASE_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)) ||
+                (attType == OFF_ATTACK && !(eventInfo.GetTypeMask() & PROC_FLAG_DONE_OFFHAND_ATTACK)))
+                return false;
+
+            return true;
+        }
+        //end npcbot
+
         Player* player = eventInfo.GetActor()->ToPlayer();
         if (!player)
             return false;
@@ -1857,6 +1937,53 @@ class spell_sha_windfury_weapon : public AuraScript
     {
         PreventDefaultAction();
 
+        //npcbot: handle bot enchant proc
+        Creature* bot = eventInfo.GetActor()->ToCreature();
+        if (bot && bot->IsNPCBot())
+        {
+            uint32 spellId = 0;
+            WeaponAttackType attType;
+            if (eventInfo.GetTypeMask() & PROC_FLAG_DONE_MAINHAND_ATTACK)
+            {
+                spellId = SPELL_SHAMAN_WINDFURY_ATTACK_MH;
+                attType = BASE_ATTACK;
+            }
+            else
+            {
+                spellId = SPELL_SHAMAN_WINDFURY_ATTACK_OH;
+                attType = OFF_ATTACK;
+            }
+
+            Item* item = ASSERT_NOTNULL(bot->GetBotEquipsByGuid(GetAura()->GetCastItemGUID()));
+
+            int32 enchantId = static_cast<int32>(item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
+            int32 extraAttackPower = 0;
+            SpellInfo const* spellInfo = sSpellMgr->AssertSpellInfo(SPELL_SHAMAN_WINDFURY_WEAPON_R1);
+            while (spellInfo)
+            {
+                if (spellInfo->GetEffect(EFFECT_0).MiscValue == enchantId)
+                {
+                    extraAttackPower = spellInfo->GetEffect(EFFECT_1).CalcValue(bot);
+                    break;
+                }
+                spellInfo = spellInfo->GetNextRankSpell();
+            }
+
+            if (!extraAttackPower)
+                return;
+
+            int32 amount = static_cast<int32>(extraAttackPower / 14.f * bot->GetAttackTime(attType) / 1000.f);
+
+            CastSpellExtraArgs args(aurEff);
+            args.AddSpellBP0(amount);
+            // Attack twice
+            for (uint8 i = 0; i < 2; ++i)
+                bot->CastSpell(eventInfo.GetProcTarget(), spellId, args);
+
+            return;
+        }
+        //end npcbot
+
         Player* player = eventInfo.GetActor()->ToPlayer();
 
         uint32 spellId = 0;
diff --git a/src/server/scripts/Spells/spell_warrior.cpp b/src/server/scripts/Spells/spell_warrior.cpp
index 1ea3ca520..cb92af9ae 100644
--- a/src/server/scripts/Spells/spell_warrior.cpp
+++ b/src/server/scripts/Spells/spell_warrior.cpp
@@ -31,6 +31,10 @@
 #include "SpellMgr.h"
 #include "SpellScript.h"
 
+//npcbot
+#include "Creature.h"
+//end npcbot
+
 enum WarriorSpells
 {
     SPELL_WARRIOR_BLADESTORM_PERIODIC_WHIRLWIND     = 50622,
@@ -265,6 +269,12 @@ class spell_warr_deep_wounds_aura : public AuraScript
         if (!damageInfo)
             return false;
 
+        //npcbot: allow for bots
+        if (eventInfo.GetActor()->GetTypeId() == TYPEID_UNIT &&
+            eventInfo.GetActor()->ToCreature()->IsNPCBot())
+            return true;
+        //end npcbot
+
         return eventInfo.GetActor()->GetTypeId() == TYPEID_PLAYER;
     }
 
diff --git a/src/server/shared/DataStores/DBCStructure.h b/src/server/shared/DataStores/DBCStructure.h
index 56ea11415..4979ef8b2 100644
--- a/src/server/shared/DataStores/DBCStructure.h
+++ b/src/server/shared/DataStores/DBCStructure.h
@@ -896,13 +896,14 @@ struct ItemBagFamilyEntry
     //uint32 Name_lang_mask;                                // 17
 };
 
-/*
 struct ItemDisplayInfoEntry
 {
-    uint32 ID;                                              // 0
+/*
+  */uint32 ID;/*                                            // 0
     char const* ModelName[2];                               // 1-2
     char const* ModelTexture[2];                            // 3-4
-    char const* InventoryIcon[2];                           // 5-6
+  */char const* InventoryIcon;/*                            // 5
+    char const* InventoryIcon2;                             // 6
     uint32 GeosetGroup[3];                                  // 7-9
     uint32 Flags;                                           // 10
     uint32 SpellVisualID;                                   // 11
@@ -911,8 +912,8 @@ struct ItemDisplayInfoEntry
     char const* Texture[8];                                 // 15-22
     int32 ItemVisual;                                       // 23
     uint32 ParticleColorID;                                 // 24
-};
 */
+};
 
 /*
 struct ItemCondExtCostsEntry
diff --git a/src/server/shared/DataStores/DBCfmt.h b/src/server/shared/DataStores/DBCfmt.h
index 69d4e5f8d..35c8ca003 100644
--- a/src/server/shared/DataStores/DBCfmt.h
+++ b/src/server/shared/DataStores/DBCfmt.h
@@ -76,7 +76,7 @@ char constexpr GtRegenMPPerSptfmt[] = "f";
 char constexpr Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
 char constexpr Itemfmt[] = "niiiiiii";
 char constexpr ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-//char constexpr ItemDisplayTemplateEntryfmt[] = "nxxxxxxxxxxixxxxxxxxxxx";
+char constexpr ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 //char constexpr ItemCondExtCostsEntryfmt[] = "xiii";
 char constexpr ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char constexpr ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
diff --git a/src/server/shared/SharedDefines.h b/src/server/shared/SharedDefines.h
index 0bdd89004..1665c94a6 100644
--- a/src/server/shared/SharedDefines.h
+++ b/src/server/shared/SharedDefines.h
@@ -194,7 +194,14 @@ enum UnitClass
     UNIT_CLASS_MAGE                     = 8
 };
 
+//npcbot
+/*
+//end npcbot
 #define CLASSMASK_ALL_CREATURES ((1<<(UNIT_CLASS_WARRIOR-1)) | (1<<(UNIT_CLASS_PALADIN-1)) | (1<<(UNIT_CLASS_ROGUE-1)) | (1<<(UNIT_CLASS_MAGE-1)))
+//npcbot
+*/
+#define CLASSMASK_ALL_CREATURES CLASSMASK_ALL_PLAYABLE
+//end npcbot
 
 #define CLASSMASK_WAND_USERS ((1<<(CLASS_PRIEST-1))|(1<<(CLASS_MAGE-1))|(1<<(CLASS_WARLOCK-1)))
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 442681e64..d7df598ea 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -4147,3 +4147,317 @@ Metric.OverallStatusInterval = 1
 
 #
 ###################################################################################################
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    NpcBot.Enable
+#        Description: Enables NpcBot system.
+#        Default:     1 - enable
+#                     0 - disable
+
+NpcBot.Enable = 1
+
+#
+#    NpcBot.MaxBots
+#        Description: Maximum number of bots allowed for players.
+#        Default:     1
+#        Max:         39
+
+NpcBot.MaxBots = 1
+
+#
+#    NpcBot.MaxBotsPerClass
+#        Description: Maximum bots of each class allowed for players.
+#        Default:     0 - no limit
+
+NpcBot.MaxBotsPerClass = 0
+
+#
+#    NpcBot.Botgiver.FilterRaces
+#        Description: Make botgiver only offer bots of player faction (normal classes).
+#        Default:     0 - disable
+
+NpcBot.Botgiver.FilterRaces = 0
+
+#
+#    NpcBot.BaseFollowDistance
+#        Description: Default bot follow distance.
+#        Note:        This parameter determines bots' formation size, distance at which bots
+#                     will chase and attack enemies.
+#        Note2:       This parameter is set for each player at login.
+#        Default:     30
+
+NpcBot.BaseFollowDistance = 30
+
+#
+#    NpcBot.XpReduction
+#        Description: XP percent penalty for each bot used starting with second.
+#        Example:     3 bots, xp reduction is 20: ((3-1)*20) = 40%, 60% exp gained only.
+#        Note:        Maximum overall xp reduction is 90%.
+#        Default:     0
+
+NpcBot.XpReduction = 0
+
+#
+#    NpcBot.HealTargetIconMask
+#    NpcBot.TankTargetIconMask
+#    NpcBot.OffTankTargetIconMask
+#    NpcBot.DPSTargetIconMask
+#    NpcBot.RangedDPSTargetIconMask
+#    NpcBot.NoDPSTargetIconMask
+#        Description: Icon number bitmask which bots use to search for primary attack
+#                     target, (off-)tanking target, target to heal and protect (out of party),
+#                     or target to try to not damage.
+#        Note:        Many creatures cannot accept heal.
+#        Note2:       While icon is active NPCBot ddealers/tanks will ignore any other targets
+#                     and will not break from combat to follow you.
+#        Note3:       If you set multiple targets only one target at a time will be used.
+#        Example:     To check Star, Triangle and Square we need 1 + 8 + 32 = 41.
+#        Default:     0 (Disable)
+#                     1 - Star
+#                     2 - Circle
+#                     4 - Diamond
+#                     8 - Triangle
+#                     16 - Moon
+#                     32 - Square
+#                     64 - Cross
+#                     128 - Skull
+
+NpcBot.HealTargetIconMask = 0
+NpcBot.TankTargetIconMask = 0
+NpcBot.OffTankTargetIconMask = 0
+NpcBot.DPSTargetIconMask = 0
+NpcBot.RangedDPSTargetIconMask = 0
+NpcBot.NoDPSTargetIconMask = 0
+
+#
+#    NpcBot.Mult.Damage.Physical
+#    NpcBot.Mult.Damage.Spell
+#    NpcBot.Mult.Healing
+#    NpcBot.Mult.HP
+#        Description: Multipliers for bots' damage, healing, etc. Allows to balance bots vs players.
+#        Default:     1.0
+#        Minimum:     0.1
+#        Maximum:    10.0
+
+NpcBot.Mult.Damage.Physical = 1.0
+NpcBot.Mult.Damage.Spell    = 1.0
+NpcBot.Mult.Healing         = 1.0
+NpcBot.Mult.HP              = 1.0
+
+#
+#    NpcBot.Enable.Dungeon
+#    NpcBot.Enable.Raid
+#    NpcBot.Enable.BG
+#    NpcBot.Enable.Arena
+#    NpcBot.Enable.DungeonFinder
+#        Description: Allow bots to enter PvE/PvP areas and Dungeon Finder query.
+#        Default:     1 - (NpcBot.Enable.Dungeon)
+#                     0 - (NpcBot.Enable.Raid)
+#                     0 - (NpcBot.Enable.BG)
+#                     0 - (NpcBot.Enable.Arena)
+#                     1 - (NpcBot.Enable.DungeonFinder)
+
+NpcBot.Enable.Dungeon       = 1
+NpcBot.Enable.Raid          = 0
+NpcBot.Enable.BG            = 0
+NpcBot.Enable.Arena         = 0
+NpcBot.Enable.DungeonFinder = 1
+
+#
+#    NpcBot.Limit.Dungeon
+#    NpcBot.Limit.Raid
+#        Description: Enable/Disable instance players limitation rules for bots.
+#        Default:     1 - (NpcBot.Limit.Dungeon)
+#                     1 - (NpcBot.Limit.Raid)
+
+NpcBot.Limit.Dungeon = 1
+NpcBot.Limit.Raid    = 1
+
+#
+#    NpcBot.Cost
+#        Description: Bot recruitment cost (in copper).
+#        Note:        This value is for level 80 characters, for lower levels cost is reduced.
+#        Default:     1000000 (100 gold)
+
+NpcBot.Cost = 1000000
+
+#
+#    NpcBot.UpdateDelay.Base
+#        Description: Base delay between bot AI update cycles (in milliseconds).
+#        Note:        This parameter allows you to increase reaction time and slow down bots
+#                     in general. This may be useful if you want to balance bots in PvP.
+#        Note2:       This value is added on top of existing semi-randomized delay.
+#        Default:     0 (No additional delay)
+
+NpcBot.UpdateDelay.Base = 0
+
+#
+#    NpcBot.EngageDelay.DPS
+#    NpcBot.EngageDelay.Heal
+#        Description: Delay for first healing / non-tank damage after target was engaged
+#                     by tank (in milliseconds).
+#        Note:        This does not affect only bosses - all combat except PvP will be affected.
+#        Note2:       This value affects all owned bots and is set for every player at login.
+#        Default:     0 - (No delay)
+#                     1000 - (1 second)
+
+NpcBot.EngageDelay.DPS  = 0
+NpcBot.EngageDelay.Heal = 0
+
+#
+#    NpcBot.PvP
+#        Description: Allow bots to attack player-controlled units (players, pets, bots, etc.).
+#        Note:        This rule only applies to player-controlled bots.
+#        Default:     1
+
+NpcBot.PvP = 1
+
+#
+#    NpcBot.Movements.InterruptFood
+#        Description: Remove food and drink auras when starting to move.
+#        Note:        Bots don't use food or drink if not standing still.
+#        Default:     0 - (Do not interrupt)
+#                     1 - (Interrupt food and drink)
+
+NpcBot.Movements.InterruptFood = 0
+
+#
+#    NpcBot.EquipmentDisplay.Enable
+#        Description: Enable displaying equipment changes other than weapons on bot models.
+#        Note:        Client limits equipment updates to
+#                     1) relog
+#                     2) taking a taxi flight
+#                     3) teleporting between maps
+#                     4) not seeing this bot for 3 minutes
+#                     5) bot changing displayId (polymorph, shapeshift, etc.)
+#        Note2:       If client registers (5) of a single bot 3+ times
+#                     said client may crash at exiting game (Error #132) unless (4) happens.
+#        Note3:       Changing this setting requires server restart.
+#        Note4:       Bots having no equipment will not appear naked.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+NpcBot.EquipmentDisplay.Enable = 1
+
+#
+#    NpcBot.EquipmentDisplay.ShowCloak
+#    NpcBot.EquipmentDisplay.ShowHelm
+#        Description: Equipment display rules.
+#        Default:     1 - (NpcBot.EquipmentDisplay.ShowCloak)
+#                     1 - (NpcBot.EquipmentDisplay.ShowHelm)
+
+NpcBot.EquipmentDisplay.ShowCloak = 1
+NpcBot.EquipmentDisplay.ShowHelm  = 1
+
+#
+#    NpcBot.Transmog.Enable
+#        Description: Enable transmogrification of bots' equipment.
+#        Default:     0 - (Disabled)
+#                     1 - (Enabled)
+
+NpcBot.Transmog.Enable = 0
+
+#
+#    NpcBot.Transmog.MixArmorClasses
+#    NpcBot.Transmog.MixWeaponClasses
+#    NpcBot.Transmog.MixWeaponInventoryTypes
+#    NpcBot.Transmog.UseEquipmentSlots
+#        Description: Enable different armor/weapon types to be transmogrified from one to another
+#                     (i.e. plate to leather, axe to mace, dagger to polearm).
+#                     'NpcBot.Transmog.UseEquipmentSlots' makes transmog affect equipment slots
+#                     instead of item IDs and forces all other options.
+#        Default:     0 - (NpcBot.Transmog.MixArmorClasses)
+#                     0 - (NpcBot.Transmog.MixWeaponClasses)
+#                     0 - (NpcBot.Transmog.MixWeaponInventoryTypes)
+#                     0 - (NpcBot.Transmog.UseEquipmentSlots)
+
+NpcBot.Transmog.MixArmorClasses = 0
+NpcBot.Transmog.MixWeaponClasses = 0
+NpcBot.Transmog.MixWeaponInventoryTypes = 0
+NpcBot.Transmog.UseEquipmentSlots = 0
+
+#
+#    NpcBot.Gossip.ShowEquipmentListItems
+#        Description: Send whisper message with clickable items list in equipment gossip menu.
+#        Default:     0 - (Disable)
+#                     1 - (Enable)
+
+NpcBot.Gossip.ShowEquipmentListItems = 0
+
+#
+#    NpcBot.NewClasses.<Class>.Enable
+#        Description: Allow players to hire bots of non-standard classes.
+#        Note:        Some bot abilities may be unbalanced or game breaking.
+#        Default:     1 - (NpcBot.NewClasses.Blademaster.Enable)
+#                     1 - (NpcBot.NewClasses.ObsidianDestroyer.Enable)
+#                     1 - (NpcBot.NewClasses.Archmage.Enable)
+#                     1 - (NpcBot.NewClasses.Dreadlord.Enable)
+#                     1 - (NpcBot.NewClasses.SpellBreaker.Enable)
+#                     1 - (NpcBot.NewClasses.DarkRanger.Enable)
+#                     1 - (NpcBot.NewClasses.Necromancer.Enable)
+#                     1 - (NpcBot.NewClasses.SeaWitch.Enable)
+
+NpcBot.NewClasses.Blademaster.Enable       = 1
+NpcBot.NewClasses.ObsidianDestroyer.Enable = 1
+NpcBot.NewClasses.Archmage.Enable          = 1
+NpcBot.NewClasses.Dreadlord.Enable         = 1
+NpcBot.NewClasses.SpellBreaker.Enable      = 1
+NpcBot.NewClasses.DarkRanger.Enable        = 1
+NpcBot.NewClasses.Necromancer.Enable       = 1
+NpcBot.NewClasses.SeaWitch.Enable          = 1
+
+#
+#    NpcBot.Stats.Limits.Enable
+#        Description: Enable or disable stats limits for bots.
+#        Default:     0 - Disabled
+
+NpcBot.Stats.Limits.Enable = 0
+
+#
+#    NpcBot.Stats.Limits.<Stat>
+#        Description: Set dodge, parry, block and crit chance percentage limit for bots.
+#        Note:        Some bot classes may ignore some of these values.
+#        Note2:       Auras can still increase these stats above limit.
+#        Default:     95.0 (95%)
+
+NpcBot.Stats.Limits.Dodge = 95.0
+NpcBot.Stats.Limits.Parry = 95.0
+NpcBot.Stats.Limits.Block = 95.0
+NpcBot.Stats.Limits.Crit  = 95.0
+
+#
+#    NpcBot.InfoPacketsLimit
+#        Description: This is a workaround for known issue #5.
+#                     If more than 100 bots are spawned in a single spot players trying
+#                     to approach them will be kicked by AntiDOS protection due to
+#                     'flooding' CMSG_GET_MIRRORIMAGE_DATA packets. This setting
+#                     overrides packets limit per tick for that request type.
+#        Note:        If you care about your server stability at all, use this only as a
+#                     temporary solution and spread your bots spawn points properly.
+#        Default:     -1  - (use default limit set by TC devs)
+#                     500 - (500 bots in one spot won't get you kicked)
+
+NpcBot.InfoPacketsLimit = -1
+
+#
+#    NpcBot.OwnershipExpireTime
+#        Description: Maxmum time since last account login (in seconds) before bot ownership
+#                     is automatically cancelled (at server loading).
+#        Note:        All items will be refund and mailed back to player.
+#        Default:     0 - (Disabled)
+#                     604800 - (7 Days)
+
+NpcBot.OwnershipExpireTime = 0
+
+#
+#    NpcBot.EnrageOnDismiss
+#        Description: Enable Berserk buff when bot is dismissed and related hostile reaction.
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+NpcBot.EnrageOnDismiss = 1
+
+#
+###################################################################################################
