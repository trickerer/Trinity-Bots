From c4144bf45e895df10b743e6ecc1dab2a80ac1f8c Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@gmail.com>
Date: Thu, 12 Dec 2013 15:39:59 +0700
Subject: [PATCH] NPCBots

---
 sql/Bots/auth_rbac.sql                             |   25 +
 sql/Bots/character_NPC_bots.sql                    |   28 +
 ...world_bot_helper_locales_gossip_menu_option.sql |   92 +
 sql/Bots/world_bots.sql                            |  555 +++
 sql/Bots/world_creature_template_outfits.sql       |   42 +
 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp    |  121 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |  594 +++
 src/server/game/AI/NpcBots/bot_ai.cpp              | 5019 ++++++++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |  605 +++
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp | 1698 +++++++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        | 1195 +++++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       | 1167 +++++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         | 1007 ++++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      | 1125 +++++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       | 1042 ++++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  884 ++++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       | 1381 ++++++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  547 +++
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      | 1144 +++++
 src/server/game/AI/NpcBots/botcommands.cpp         |  475 ++
 src/server/game/AI/NpcBots/bothelper.cpp           |  421 ++
 src/server/game/AI/NpcBots/bothelper.h             |   32 +
 src/server/game/Accounts/RBAC.h                    |   13 +
 src/server/game/CMakeLists.txt                     |    1 +
 src/server/game/Entities/Creature/Creature.cpp     |  193 +
 src/server/game/Entities/Creature/Creature.h       |   54 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    8 +
 src/server/game/Entities/Object/Object.cpp         |   11 +
 src/server/game/Entities/Player/Player.cpp         | 1006 ++++
 src/server/game/Entities/Player/Player.h           |   62 +
 src/server/game/Entities/Totem/Totem.cpp           |    7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |    4 +
 src/server/game/Entities/Unit/Unit.cpp             |  214 +
 src/server/game/Globals/ObjectMgr.cpp              |   76 +
 src/server/game/Globals/ObjectMgr.h                |   20 +
 src/server/game/Groups/Group.cpp                   |   12 +
 src/server/game/Groups/Group.h                     |    3 +
 src/server/game/Handlers/CharacterHandler.cpp      |   31 +
 src/server/game/Handlers/MiscHandler.cpp           |   35 +
 src/server/game/Handlers/NPCHandler.cpp            |   33 +
 src/server/game/Handlers/SpellHandler.cpp          |   30 +
 src/server/game/Maps/Map.cpp                       |    3 +
 src/server/game/Scripting/ScriptLoader.cpp         |   30 +
 src/server/game/Server/WorldSession.cpp            |   17 +
 src/server/game/Server/WorldSession.h              |   25 +
 src/server/game/World/World.cpp                    |    3 +
 src/server/scripts/Spells/spell_priest.cpp         |    4 +
 .../Database/Implementation/CharacterDatabase.cpp  |   14 +
 .../Database/Implementation/CharacterDatabase.h    |   10 +
 .../Database/Implementation/WorldDatabase.cpp      |    4 +
 .../shared/Database/Implementation/WorldDatabase.h |    4 +
 src/server/worldserver/worldserver.conf.dist       |  104 +
 52 files changed, 21230 insertions(+), 0 deletions(-)
 create mode 100644 sql/Bots/auth_rbac.sql
 create mode 100644 sql/Bots/character_NPC_bots.sql
 create mode 100644 sql/Bots/world_bot_helper_locales_gossip_menu_option.sql
 create mode 100644 sql/Bots/world_bots.sql
 create mode 100644 sql/Bots/world_creature_template_outfits.sql
 create mode 100644 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.cpp
 create mode 100644 src/server/game/AI/NpcBots/bothelper.h

diff --git a/sql/Bots/auth_rbac.sql b/sql/Bots/auth_rbac.sql
new file mode 100644
index 0000000..5804f0f
--- /dev/null
+++ b/sql/Bots/auth_rbac.sql
@@ -0,0 +1,25 @@
+SET @NPCB_PERM := '1000';
+
+DELETE FROM `rbac_permissions` WHERE `id` BETWEEN @NPCB_PERM AND @NPCB_PERM+8;
+INSERT INTO `rbac_permissions` (`id`,`name`) VALUES
+(@NPCB_PERM+0,'npcbot'),
+(@NPCB_PERM+1,'npcbot add'),
+(@NPCB_PERM+2,'npcbot remove'),
+(@NPCB_PERM+3,'npcbot reset'),
+(@NPCB_PERM+4,'npcbot command'),
+(@NPCB_PERM+5,'npcbot distance'),
+(@NPCB_PERM+6,'npcbot info'),
+(@NPCB_PERM+7,'npcbot helper'),
+(@NPCB_PERM+8,'npcbot revive');
+
+DELETE FROM `rbac_linked_permissions` WHERE `linkedId` BETWEEN @NPCB_PERM AND @NPCB_PERM+8;
+INSERT INTO `rbac_linked_permissions` (`id`,`linkedId`) VALUES
+('199',@NPCB_PERM+0), -- player command .npcbot
+('199',@NPCB_PERM+1), -- player command .npcbot add
+('199',@NPCB_PERM+2), -- player command .npcbot remove
+('199',@NPCB_PERM+3), -- player command .npcbot reset
+('199',@NPCB_PERM+4), -- player command .npcbot command
+('199',@NPCB_PERM+5), -- player command .npcbot distance
+('199',@NPCB_PERM+6), -- player command .npcbot info
+('199',@NPCB_PERM+7), -- player command .npcbot helper
+('198',@NPCB_PERM+8); -- moderator command .npcbot revive
diff --git a/sql/Bots/character_NPC_bots.sql b/sql/Bots/character_NPC_bots.sql
new file mode 100644
index 0000000..486eeae
--- /dev/null
+++ b/sql/Bots/character_NPC_bots.sql
@@ -0,0 +1,28 @@
+DROP TABLE IF EXISTS `character_npcbot`;
+CREATE TABLE `character_npcbot` (
+  `owner` int(10) default NULL,
+  `entry` int(10) default NULL,
+  `race` tinyint(3) default NULL,
+  `class` tinyint(3) default NULL,
+  `roles` tinyint(3) default NULL,
+  `equipMhEx` int(10) default NULL,
+  `equipOhEx` int(10) default NULL,
+  `equipRhEx` int(10) default NULL,
+  `equipHead` int(10) default NULL,
+  `equipShoulders` int(10) default NULL,
+  `equipChest` int(10) default NULL,
+  `equipWaist` int(10) default NULL,
+  `equipLegs` int(10) default NULL,
+  `equipFeet` int(10) default NULL,
+  `equipWrist` int(10) default NULL,
+  `equipHands` int(10) default NULL,
+  `equipBack` int(10) default NULL,
+  `equipBody` int(10) default NULL,
+  `equipFinger1` int(10) default NULL,
+  `equipFinger2` int(10) default NULL,
+  `equipTrinket1` int(10) default NULL,
+  `equipTrinket2` int(10) default NULL,
+  `equipNeck` int(10) default NULL,
+  `active` tinyint(3) default NULL,
+  PRIMARY KEY  (`owner`,`entry`)
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/Bots/world_bot_helper_locales_gossip_menu_option.sql b/sql/Bots/world_bot_helper_locales_gossip_menu_option.sql
new file mode 100644
index 0000000..a9f5c6b
--- /dev/null
+++ b/sql/Bots/world_bot_helper_locales_gossip_menu_option.sql
@@ -0,0 +1,92 @@
+delete from `locales_gossip_menu_option` where `menu_id` = '60000';
+
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','1','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player','Abandon my Player',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','2','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player','Recruit a Player',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','3','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion','Abandon my Minion',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','4','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion','Recruit a Minion',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','5','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots','Tell me about these bots',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','6','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL','ADD ALL',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','7','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL','REMOVE ALL',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','8','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ','Recruit a Warrior ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','9','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ','Recruit a Hunter ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','10','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ','Recruit a Paladin ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','11','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ','Recruit a Shaman ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','12','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ','Recruit a Rogue ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','13','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ','Recruit a Druid ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','14','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ','Recruit a Mage ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','15','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ','Recruit a Priest ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','16','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ','Recruit a Warlock ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','17','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ','Recruit a Death Knight ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','18','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots','To see list of Playerbot commands whisper \'help\' to one of your playerbots',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','19','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb','To see list of available npcbot commands type .npcbot or .npcb',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','20','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan','You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','21','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them','If you want your npcbots to heal someone out of your party set any raid target icon on them',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','22','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ','If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','23','star','star','star','star','star','star','star','star',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','24','circle','circle','circle','circle','circle','circle','circle','circle',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','25','diamond','diamond','diamond','diamond','diamond','diamond','diamond','diamond',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','26','triangle','triangle','triangle','triangle','triangle','triangle','triangle','triangle',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','27','moon','moon','moon','moon','moon','moon','moon','moon',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','28','square','square','square','square','square','square','square','square',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','29','cross','cross','cross','cross','cross','cross','cross','cross',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','30','skull','skull','skull','skull','skull','skull','skull','skull',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','31','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon','unknown icon',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','32','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available','no more bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','33','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available','more bot available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','34','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available','more bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','35','bot available','bot available','bot available','bot available','bot available','bot available','bot available','bot available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+insert into `locales_gossip_menu_option` (`menu_id`, `id`, `option_text_loc1`, `option_text_loc2`, `option_text_loc3`, `option_text_loc4`, `option_text_loc5`, `option_text_loc6`, `option_text_loc7`, `option_text_loc8`, `box_text_loc1`, `box_text_loc2`, `box_text_loc3`, `box_text_loc4`, `box_text_loc5`, `box_text_loc6`, `box_text_loc7`, `box_text_loc8`) values('60000','36','bots available','bots available','bots available','bots available','bots available','bots available','bots available','bots available',NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
+
+
+-- Custom section
+-- to change text displayed in botgiver's dialog you shoul
+-- 1) translate text to your language
+-- 2) place translated text in empty quotes below, (id = original id in `locales_gossip_menu_option`)
+-- 3) replace `option_text_loc1` with your locale index
+-- LOCALE_koKR        `option_text_loc1`
+-- LOCALE_frFR          `option_text_loc2`
+-- LOCALE_deDE        `option_text_loc3`
+-- LOCALE_zhCN        `option_text_loc4`
+-- LOCALE_zhTW       `option_text_loc5`
+-- LOCALE_esES         `option_text_loc6`
+-- LOCALE_esMX       `option_text_loc7`
+-- LOCALE_ruRU        `option_text_loc8`
+-- 4) run the queue below lol
+-- 5) you most likely need to save your translation for later
+
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 1;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 2;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 3;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 4;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 5;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 6;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 7;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 8;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 9;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 10;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 11;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 12;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 13;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 14;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 15;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 16;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 17;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 18;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 19;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 20;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 21;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 22;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 23;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 24;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 25;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 26;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 27;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 28;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 29;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 30;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 31;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 32;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 33;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 34;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 35;
+-- UPDATE `locales_gossip_menu_option` SET `option_text_loc1` = ' ' WHERE `menu_id` = 60000 AND `id` = 36;
diff --git a/sql/Bots/world_bots.sql b/sql/Bots/world_bots.sql
new file mode 100644
index 0000000..5c4ddd2
--- /dev/null
+++ b/sql/Bots/world_bots.sql
@@ -0,0 +1,555 @@
+
+-- GENERAL --
+
+-- Cleanup old version
+-- delete from `creature_template` where entry between 60001 and 60248;
+-- delete from `creature_equip_template` where entry between 60001 and 60248;
+
+delete from `creature_template` where entry between 70001 and 70248;
+
+insert into `creature_template`
+(`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`,
+`minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`,
+`rangeattacktime`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`,
+`type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`,
+`spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`,
+`questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`)
+values
+('70001','0','0','0','0','0','5001','0','5001','0','Khelden','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70002','0','0','0','0','0','1294','0','1294','0','Zaldimar','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70003','0','0','0','0','0','1484','0','1484','0','Maginor','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70004','0','0','0','0','0','3344','0','3344','0','Anetta','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70005','0','0','0','0','0','1495','0','1495','0','Laurena','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70006','0','0','0','0','0','1295','0','1295','0','Josetta','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70007','0','0','0','0','0','3345','0','3345','0','Drusilla','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70008','0','0','0','0','0','1930','0','1930','0','Alamar','Warlock Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70009','0','0','0','0','0','1469','0','1469','0','Demisette','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70010','0','0','0','0','0','12749','0','12749','0','Nalesette','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70011','0','0','0','0','0','3401','0','3401','0','Branstock','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70012','0','0','0','0','0','3395','0','3395','0','Thorgas','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70013','0','0','0','0','0','3343','0','3343','0','Llane','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70014','0','0','0','0','0','3399','0','3399','0','Thran','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70015','0','0','0','0','0','1300','0','1300','0','Lyria','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70016','0','0','0','0','0','3351','0','3351','0','Jorik','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70017','0','0','0','0','0','3407','0','3407','0','Solm','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70018','0','0','0','0','0','1297','0','1297','0','Keryn','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70019','0','0','0','0','0','1507','0','1507','0','Osborne','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70020','0','0','0','0','0','3346','0','3346','0','Sammuel','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70021','0','0','0','0','0','3393','0','3393','0','Bob','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70022','0','0','0','0','0','1299','0','1299','0','Wilhelm','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70023','0','0','0','0','0','1499','0','1499','0','Brisombre','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70024','0','0','0','0','0','10216','0','10216','0','Marry','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70025','0','0','0','0','0','4552','0','4552','0','Haromm','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70026','0','0','0','0','0','4567','0','4567','0','Kartosh','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70027','0','0','0','0','0','3429','0','3429','0','MaxanAnvol','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70028','0','0','0','0','0','10215','0','10215','0','Magis','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70029','0','0','0','0','0','3431','0','3431','0','GranVivehache','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70030','0','0','0','0','0','1622','0','1622','0','Azar','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70031','0','0','0','0','0','3436','0','3436','0','Hogral','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70032','0','0','0','0','0','3053','0','3053','0','Kelstrum','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70033','0','0','0','0','0','1578','0','1578','0','Dannal','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70034','0','0','0','0','0','1579','0','1579','0','SombreDuesten','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70035','0','0','0','0','0','1592','0','1592','0','Isabella','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70036','0','0','0','0','0','1581','0','1581','0','Maximillion','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70037','0','0','0','0','0','1604','0','1604','0','Rupert','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70038','0','0','0','0','0','1600','0','1600','0','Cain','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70039','0','0','0','0','0','1602','0','1602','0','SombreBeryl','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70041','0','0','0','0','0','10548','0','10548','0','Milituus','Mage Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70042','0','0','0','0','0','2810','0','2810','0','Lexington','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70043','0','0','0','0','0','2123','0','2123','0','Siln','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70044','0','0','0','0','0','19598','0','19598','0','Umbrua','Shaman Bot','','0','80','80','2','1640','1640','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70045','0','0','0','0','0','2102','0','2102','0','Tigor','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70046','0','0','0','0','0','2082','0','2082','0','Beram','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70047','0','0','0','0','0','2106','0','2106','0','Turak','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70048','0','0','0','0','0','2121','0','2121','0','Sheal','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70049','0','0','0','0','0','2115','0','2115','0','Kym','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70050','0','0','0','0','0','2112','0','2112','0','Kary','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70051','0','0','0','0','0','2087','0','2087','0','Holt','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70052','0','0','0','0','0','2105','0','2105','0','Urek','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70053','0','0','0','0','0','2103','0','2103','0','Torm','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70054','0','0','0','0','0','2096','0','2096','0','Sark','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70055','0','0','0','0','0','17211','0','17211','0','Kerra','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70056','0','0','0','0','0','2139','0','2139','0','Miles Welsh','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70057','0','0','0','0','0','2138','0','2138','0','Malakai','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70058','0','0','0','0','0','2137','0','2137','0','Cobb','Priest Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70059','0','0','0','0','0','2134','0','2134','0','Shymm','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','143','145','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70060','0','0','0','0','0','6058','0','6058','0','Ursyn','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70061','0','0','0','0','0','2135','0','2135','0','Thurston','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70062','0','0','0','0','0','3793','0','3793','0','Harutt','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70063','0','0','0','0','0','3819','0','3819','0','Gart','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','8','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70064','0','0','0','0','0','3810','0','3810','0','Lanka','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70065','0','0','0','0','0','10180','0','10180','0','Meela','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70066','0','0','0','0','0','3794','0','3794','0','Krang','Warrior Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70067','0','0','0','0','0','10734','0','10734','0','Gennia','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70068','0','0','0','0','0','3811','0','3811','0','Yaw','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70069','0','0','0','0','0','3816','0','3816','0','Narm','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70070','0','0','0','0','0','1880','0','1880','0','Frang','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70071','0','0','0','0','0','1882','0','1882','0','Jenshan','Hunter Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70072','0','0','0','0','0','1884','0','1884','0','Nartok','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70073','0','0','0','0','0','1878','0','1878','0','Shikrik','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70074','0','0','0','0','0','3743','0','3743','0','Tarshaw','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70075','0','0','0','0','0','3744','0','3744','0','Thotar','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70076','0','0','0','0','0','3745','0','3745','0','Dhugru','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70077','0','0','0','0','0','3746','0','3746','0','Swart','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70078','0','0','0','0','0','1324','0','1324','0','Groldar','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70079','0','0','0','0','0','1325','0','1325','0','Mirket','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70080','0','0','0','0','0','1326','0','1326','0','Zevrost','Warlock Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70081','0','0','0','0','0','1360','0','1360','0','Kardris','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70082','0','0','0','0','0','1373','0','1373','0','Ormak','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70083','0','0','0','0','0','1374','0','1374','0','Grezz','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70084','0','0','0','0','0','1375','0','1375','0','Sorek','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70085','0','0','0','0','0','4231','0','4231','0','Siantsu','Shaman Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70086','0','0','0','0','0','4239','0','4239','0','Xorjuul','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70087','0','0','0','0','0','4241','0','4241','0','Siandur','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70088','0','0','0','0','0','4242','0','4242','0','Zelmak','Warrior Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70089','0','0','0','0','0','7915','0','7915','0','ClaudeErksine','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70090','0','0','0','0','0','1721','0','1721','0','Alyissia','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70091','0','0','0','0','0','1725','0','1725','0','FrahunMurmombre','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70092','0','0','0','0','0','1733','0','1733','0','Shanda','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70093','0','0','0','0','0','1732','0','1732','0','Mardant','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70094','0','0','0','0','0','1707','0','1707','0','Kyra','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70095','0','0','0','0','0','1704','0','1704','0','Jannok','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70096','0','0','0','0','0','1708','0','1708','0','Laurna','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70097','0','0','0','0','0','1706','0','1706','0','Kal','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70098','0','0','0','0','0','4296','0','4296','0','Harruk','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70099','0','0','0','0','0','4299','0','4299','0','Reban','Hunter bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70100','0','0','0','0','0','4304','0','4304','0','Bolyun','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70101','0','0','0','0','0','1897','0','1897','0','Taijin','Priest Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70102','0','0','0','0','0','4068','0','4068','0','Kenjai','Priest Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70103','0','0','0','0','0','2066','0','2066','0','Danlaar','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70104','0','0','0','0','0','2196','0','2196','0','Ariasta','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70105','0','0','0','0','0','2198','0','2198','0','Sildanair','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70106','0','0','0','0','0','2200','0','2200','0','Astarii','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70107','0','0','0','0','0','2201','0','2201','0','Jandria','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70108','0','0','0','0','0','2202','0','2202','0','Lariia','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70109','0','0','0','0','0','2231','0','2231','0','Syurna','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70110','0','0','0','0','0','7669','0','7669','0','Elissa','Mage Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70111','0','0','0','0','0','2252','0','2252','0','Erion','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70112','0','0','0','0','0','2243','0','2243','0','Anishar','Rogue Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70113','0','0','0','0','0','2250','0','2250','0','Denatharion','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70114','0','0','0','0','0','2255','0','2255','0','Fylerian','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70115','0','0','0','0','0','2416','0','2416','0','Caelyb','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70116','0','0','0','0','0','2675','0','2675','0','Kaal','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70117','0','0','0','0','0','16800','0','16800','0','Lana','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70118','0','0','0','0','0','2646','0','2646','0','Richard','Warlock Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70119','0','0','0','0','0','10214','0','10214','0','Kaelystia','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','6','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70120','0','0','0','0','0','2644','0','2644','0','Pierce','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70121','0','0','0','0','0','2657','0','2657','0','Anastasia','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70122','0','0','0','0','0','2620','0','2620','0','Chris','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70123','0','0','0','0','0','2658','0','2658','0','Angela','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70124','0','0','0','0','0','2614','0','2614','0','Baltus','Warrior Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70125','0','0','0','0','0','3054','0','3054','0','Kelv','Warrior Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70126','0','0','0','0','0','3055','0','3055','0','Bilban','Warrior Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70127','0','0','0','0','0','3056','0','3056','0','Daera','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70128','0','0','0','0','0','3072','0','3072','0','Olmin','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70129','0','0','0','0','0','3073','0','3073','0','Regnus','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70130','0','0','0','0','0','3086','0','3086','0','Theodrus','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70131','0','0','0','0','0','3066','0','3066','0','Braenna','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70132','0','0','0','0','0','3085','0','3085','0','Toldren','Priest Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70134','0','0','0','0','0','3108','0','3108','0','Bink','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70135','0','0','0','0','0','10214','0','10214','0','Juli','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70136','0','0','0','0','0','3109','0','3109','0','Nittegousse','Mage Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70137','0','0','0','0','0','3089','0','3089','0','Valgar','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70138','0','0','0','0','0','3088','0','3088','0','Beldruk','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70139','0','0','0','0','0','3087','0','3087','0','Brandur','Paladin Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70140','0','0','0','0','0','3101','0','3101','0','Hulfdan','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70141','0','0','0','0','0','3100','0','3100','0','Ormyr','Rogue Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70142','0','0','0','0','0','3113','0','3113','0','Phenwick','Rogue Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70143','0','0','0','0','0','3115','0','3115','0','Coeurdechardon','Warlock Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70144','0','0','0','0','0','3116','0','3116','0','Eglantin','Warlock Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70145','0','0','0','0','0','3122','0','3122','0','Alexander','Warlock Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70146','0','0','0','0','0','3280','0','3280','0','Wu','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70147','0','0','0','0','0','3287','0','3287','0','Ilsa','Warrior Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70148','0','0','0','0','0','3283','0','3283','0','Joshua','Priest Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70149','0','0','0','0','0','3284','0','3284','0','Arthur','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70150','0','0','0','0','0','3289','0','3289','0','Katherine','Paladin Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70151','0','0','0','0','0','3291','0','3291','0','Deline','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70152','0','0','0','0','0','3286','0','3286','0','Sandahl','Warlock Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70153','0','0','0','0','0','3292','0','3292','0','Jennea','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70154','0','0','0','0','0','19803','0','19803','0','Elsharin','Mage Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70155','0','0','0','0','0','3299','0','3299','0','Kaerbrus','Hunter Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70156','0','0','0','0','0','3300','0','3300','0','Sheldras','Druid Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70157','0','0','0','0','0','3301','0','3301','0','Theridran','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70158','0','0','0','0','0','3312','0','3312','0','Einris','Hunter Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70159','0','0','0','0','0','3309','0','3309','0','Ulfir','Hunter Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70160','0','0','0','0','0','3310','0','3310','0','Thorfin','Hunter Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70161','0','0','0','0','0','10171','0','10171','0','UnThuwa','Mage Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70162','0','0','0','0','0','4524','0','4524','0','Pephredo','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70163','0','0','0','0','0','4522','0','4522','0','Enyo','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70164','0','0','0','0','0','4526','0','4526','0','Mai','Mage Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70165','0','0','0','0','0','4523','0','4523','0','Deino','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70166','0','0','0','0','0','4665','0','4665','0','Birgitte','Mage Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70167','0','0','0','0','0','12849','0','12849','0','Thuul','Mage Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70168','0','0','0','0','0','4690','0','4690','0','Zayus','Priest Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70169','0','0','0','0','0','10473','0','10473','0','Xyera','Priest Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70170','0','0','0','0','0','4711','0','4711','0','Urkyo','Priest Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70171','0','0','0','0','0','6060','0','6060','0','Uthelnay','Mage Bot','','0','80','80','2','126','126','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70172','0','0','0','0','0','6072','0','6072','0','Dink','Mage Bot','','0','80','80','2','875','875','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70173','0','0','0','0','0','6071','0','6071','0','Darnath','Warrior Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70174','0','0','0','0','0','7356','0','7356','0','Karman','Paladin Bot','','0','80','80','2','894','894','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70175','0','0','0','0','0','11037','0','11037','0','Evencane','Warrior Bot','','0','80','80','2','894','894','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70176','0','0','0','0','0','7357','0','7357','0','Jannos','Druid Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70177','0','0','0','0','0','7538','0','7538','0','Alenndaar','Hunter Bot','','0','80','80','2','1076','1076','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70178','0','0','0','0','0','10738','0','10738','0','Golhine','Druid Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70179','0','0','0','0','0','9337','0','9337','0','Hesuwa','Hunter Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70180','0','0','0','0','0','9336','0','9336','0','Xao\'tsu','Hunter Bot','','0','80','80','2','29','29','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','2','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70181','0','0','0','0','0','9338','0','9338','0','Belia','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','3','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70182','0','0','0','0','0','10245','0','10245','0','Dargh','Hunter Bot','','0','80','80','2','55','55','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70183','0','0','0','0','0','11044','0','11044','0','Meideros','Priest Bot','','0','80','80','2','80','80','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70184','0','0','0','0','0','11048','0','11048','0','Presse','Priest Bot','','0','80','80','2','1076','1076','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70185','0','0','0','0','0','11053','0','11053','0','Rohan','Priest Bot','','0','80','80','2','122','122','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','3','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70186','0','0','0','0','0','12053','0','12053','0','Loganaar','Druid Bot','','0','80','80','2','994','994','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70187','0','0','0','0','0','13171','0','13171','0','Romano','Rogue Bot','','0','80','80','2','12','12','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70188','0','0','0','0','0','13341','0','13341','0','Sagorne','Shaman Bot','','0','80','80','2','104','104','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70189','0','0','0','0','0','15522','0','15522','0','Julia','Mage Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70190','0','0','0','0','0','16811','0','16811','0','Ithelis','Paladin Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70191','0','0','0','0','0','15524','0','15524','0','Invocateur','Warlock Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70192','0','0','0','0','0','15518','0','15518','0','Matrone','Priest Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70193','0','0','0','0','0','2659','0','2659','0','Eclaireur','Rogue Bot','','0','80','80','2','68','68','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70194','0','0','0','0','0','15520','0','15520','0','Sallina','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70195','0','0','0','0','0','16685','0','16685','0','Noellene','Paladin Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70196','0','0','0','0','0','16707','0','16707','0','Ponaris','Priest Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70197','0','0','0','0','0','16222','0','16222','0','Keilnei','Hunter Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70198','0','0','0','0','0','16223','0','16223','0','Valaatu','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70199','0','0','0','0','0','16224','0','16224','0','Aurelon','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70200','0','0','0','0','0','16225','0','16225','0','Zalduun','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70201','0','0','0','0','0','16226','0','16226','0','Kore','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70202','0','0','0','0','0','16787','0','16787','0','Alamma','Warlock Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70203','0','0','0','0','0','16800','0','16800','0','Talionia','Warlock Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3500','2000','8','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warlock_bot','0'),
+('70204','0','0','0','0','0','16831','0','16831','0','Zanien','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','9','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70205','0','0','0','0','0','16781','0','16781','0','Zaedana','Mage Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70206','0','0','0','0','0','16824','0','16824','0','Quithas','Mage Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70207','0','0','0','0','0','16739','0','16739','0','Harene','Druid Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70208','0','0','0','0','0','16778','0','16778','0','Tana','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70209','0','0','0','0','0','16816','0','16816','0','Oninath','Hunter Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70210','0','0','0','0','0','16829','0','16829','0','Bachi','Paladin Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70211','0','0','0','0','0','16767','0','16767','0','Zelanis','Rogue Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70212','0','0','0','0','0','16798','0','16798','0','Elara','Rogue Bot','','0','80','80','2','1604','1604','1','1.2','1.3','1','0','1','2','0','0','1','1600','2000','4','0','0','0','0','0','0','4','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','rogue_bot','0'),
+('70213','0','0','0','0','0','16858','0','16858','0','Shalannius','Druid Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2200','2000','2','0','0','0','0','0','0','11','6','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','druid_bot','0'),
+('70214','0','0','0','0','0','17434','0','17434','0','Deremiis','Hunter Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70215','0','0','0','0','0','17247','0','17247','0','Caedmos','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70216','0','0','0','0','0','17225','0','17225','0','Baatun','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70217','0','0','0','0','0','17212','0','17212','0','Ahonan','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70218','0','0','0','0','0','17598','0','17598','0','Firmanvaar','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70219','0','0','0','0','0','16860','0','16860','0','Actron','Hunter Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70220','0','0','0','0','0','17213','0','17213','0','Behomat','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70221','0','0','0','0','0','17600','0','17600','0','Nobundo','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70222','0','0','0','0','0','17599','0','17599','0','Tuluun','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70223','0','0','0','0','0','16914','0','16914','0','Sulaa','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70224','0','0','0','0','0','17215','0','17215','0','Ruada','Warrior Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','3','5','0','0','1','3400','2000','1','0','0','0','0','0','0','1','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','warrior_bot','0'),
+('70225','0','0','0','0','0','17233','0','17233','0','Semid','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70226','0','0','0','0','0','17232','0','17232','0','Guvan','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70227','0','0','0','0','0','17234','0','17234','0','Tullas','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70228','0','0','0','0','0','17488','0','17488','0','Killac','Hunter bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','3','0','0','1','2800','2000','2','0','0','0','0','0','0','3','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','hunter_bot','0'),
+('70229','0','0','0','0','0','17226','0','17226','0','Jol','Paladin Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70230','0','0','0','0','0','17248','0','17248','0','Fallat','Priest Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','priest_bot','0'),
+('70231','0','0','0','0','0','17243','0','17243','0','Harnan','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70232','0','0','0','0','0','17241','0','17241','0','Bati','Mage Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','1','0','0','1','3800','2000','8','0','0','0','0','0','0','8','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','mage_bot','0'),
+('70233','0','0','0','0','0','17792','0','17792','0','Hobahken','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70234','0','0','0','0','0','6820','0','6820','0','Gurrag','Shaman Bot','','0','80','80','2','1638','1638','1','1.2','1.3','1','0','1','2','0','0','1','2600','2000','2','0','0','0','0','0','0','7','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','shaman_bot','0'),
+('70235','0','0','0','0','0','19596','0','19596','0','Auberose','Paladin Bot','','0','80','80','2','1602','1602','1','1.2','1.3','1','0','2','4','0','0','1','2300','2000','2','0','0','0','0','0','0','2','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','0','1','1048688','paladin_bot','0'),
+('70236','0','0','0','0','0','10335','10335','10335','10335','Afina','Priest Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3600','2000','8','0','0','0','0','0','0','5','2','0','0','0','7','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','priest_bot','0'),
+('70237','0','0','0','0','0','26939','26939','26939','26939','Imhadria','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70238','0','0','0','0','0','28039','28039','28039','28039','Mynx','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','0.8','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70239','0','0','0','0','0','26688','26688','26688','26688','Lankral','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','1','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70240','0','0','0','0','0','26195','26195','26195','26195','Silver','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70241','0','0','0','0','0','27402','27402','27402','27402','Vereth','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','0.8','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','5','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70242','0','0','0','0','0','27189','27189','27189','27189','Arly','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','7','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70243','0','0','0','0','0','26217','26217','26217','26217','Setaal','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','11','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70244','0','0','0','0','0','28842','28842','28842','28842','Illyrie','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','4','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70245','0','0','0','0','0','28840','28840','28840','28840','Zor\'be','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','8','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70246','0','0','0','0','0','25512','25512','25512','25512','Datura','Death Knight Bot','','0','80','80','2','35','35','1','1.2','1.3','1','0','1','1','0','0','1','3300','2000','1','0','0','0','0','0','0','6','10','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','death_knight_bot','0'),
+('70247','0','0','0','0','0','1132','0','1132','0','Voidwalker','Warlock\'s Pet Bot',NULL,'0','80','80','2','14','14','0','1.2','1.3','1','0','2','3','0','0','1','2000','2000','2','0','0','0','16','0','0','1','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','0','1','1','1048688','voidwalker_bot','0'),
+('70248','0','0','0','0','0','1105','0','0','0','Hunter\'s Pet',NULL,NULL,'0','80','80','0','14','14','0','1.1','1.14286','1','0','87','117','0','214','1','2000','0','1','0','0','0','7','0','0','1','0','61','90','21','1','1','0','0','0','0','0','0','0','0','0','5708','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','0','0','0','0','0','0','0','149','1','0','0','','0');
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where entry between 70001 and 70248;
+
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70001','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70002','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70003','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70004','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70005','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70006','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70007','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70008','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70009','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70010','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70011','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70012','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70013','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70014','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70015','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70016','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70017','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70018','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70019','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70020','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70021','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70022','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70023','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70024','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70025','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70026','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70027','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70028','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70029','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70030','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70031','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70032','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70033','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70034','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70035','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70036','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70037','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70038','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70039','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70041','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70042','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70043','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70044','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70045','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70046','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70047','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70048','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70049','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70050','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70051','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70052','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70053','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70054','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70055','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70056','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70057','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70058','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70059','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70060','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70061','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70062','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70063','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70064','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70065','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70066','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70067','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70068','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70069','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70070','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70071','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70072','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70073','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70074','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70075','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70076','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70077','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70078','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70079','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70080','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70081','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70082','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70083','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70084','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70085','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70086','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70087','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70088','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70089','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70090','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70091','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70092','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70093','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70094','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70095','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70096','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70097','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70098','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70099','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70100','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70101','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70102','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70103','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70104','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70105','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70106','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70107','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70108','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70109','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70110','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70111','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70112','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70113','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70114','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70115','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70116','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70117','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70118','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70119','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70120','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70121','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70122','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70123','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70124','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70125','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70126','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70127','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70128','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70129','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70130','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70131','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70132','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70134','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70135','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70136','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70137','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70138','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70139','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70140','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70141','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70142','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70143','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70144','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70145','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70146','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70147','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70148','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70149','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70150','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70151','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70152','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70153','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70154','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70155','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70156','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70157','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70158','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70159','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70160','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70161','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70162','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70163','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70164','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70165','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70166','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70167','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70168','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70169','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70170','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70171','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70172','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70173','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70174','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70175','1','7723','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70176','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70177','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70178','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70179','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70180','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70181','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70182','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70183','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70184','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70185','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70186','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70187','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70188','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70189','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70190','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70191','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70192','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70193','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70194','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70195','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70196','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70197','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70198','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70199','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70200','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70201','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70202','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70203','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70204','1','31186','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70205','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70206','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70207','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70208','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70209','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70210','1','12584','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70211','1','6633','820','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70212','1','13984','6448','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70213','1','25622','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70214','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70215','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70216','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70217','1','28367','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70218','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70219','1','2291','0','2825');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70220','1','18002','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70221','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70222','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70223','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70224','1','27903','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70225','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70226','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70227','1','12584','18825','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70229','1','18876','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70230','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70231','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70232','1','18842','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70233','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70234','1','18203','18202','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70235','1','29175','18826','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70236','1','31289','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70237','1','13505','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70238','1','12775','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70239','1','24044','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70240','1','43601','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70241','1','23499','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70242','1','38632','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70243','1','34891','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70244','1','38632','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70245','1','50798','0','0');
+insert into `creature_equip_template` (`entry`, `id`, `itemEntry1`, `itemEntry2`, `itemEntry3`) values('70246','1','12592','0','0');
+
+-- -- -- Update 18.09.13 - Equips for shamans
+-- Orcs and Draenei. Mainhand: Cudgel of Furious Justice, Offhand: Azure-Shield of Coldarra
+UPDATE `creature_equip_template` SET `itemEntry1` = '50050', `itemEntry2` = '29266', `itemEntry3` = '0' WHERE `entry` IN (SELECT entry FROM `creature_template` WHERE (`entry` BETWEEN '70000' AND '70238') AND `trainer_class` = '7' AND (`trainer_race` = '2' OR `trainer_race` = '11'));
+-- Taurens and some Draenei. De-Raged Waraxe (Two-Hand)
+UPDATE `creature_equip_template` SET `itemEntry1` = '41816', `itemEntry2` = '0', `itemEntry3` = '0' WHERE `entry` IN (SELECT entry FROM `creature_template` WHERE (`entry` BETWEEN '70000' AND '70238') AND `trainer_class` = '7' AND (`trainer_race` = '6' OR `entry` IN (70218,70222,70223,70233)));
+
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+-- Add flags_extra
+SET @EX_NO_BLOCK = 16;
+SET @EX_NO_CRUSH = 32;
+SET @EX_NO_XP = 64;
+SET @EX_DIMINISH = 1048576;
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=5, minlevel:=80, maxlevel:=80, baseattacktime:=3300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Death Knight Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4, minlevel:=80, maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Druid Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=3, minlevel:=80, maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Hunter Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=80, maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Mage Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=2, maxdmg:=4, minlevel:=80, maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Paladin Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=80, maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Priest Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=2, minlevel:=80, maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Rogue Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=2, minlevel:=80, maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Shaman Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=1, maxdmg:=1, minlevel:=80, maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Warlock Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:=3, maxdmg:=5, minlevel:=80, maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry >= 70000 && entry < 70249 and subname='Warrior Bot';
+
+-- DK           -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK            -- DK           -- DK            -- DK          -- DK            -- DK           -- DK           -- DK            -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK           -- DK           -- DK            -- DK           -- DK            -- DK           -- DK           -- DK
+-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid
+-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter
+-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage
+-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin
+-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest
+-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue
+-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman
+-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock
+-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior
+
+-- pets
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 2, maxdmg:= 3, minlevel:=80, maxlevel:=80, baseattacktime:=2000, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, AIName='' where entry between 70001 and 70248 and name='Voidwalker';
diff --git a/sql/Bots/world_creature_template_outfits.sql b/sql/Bots/world_creature_template_outfits.sql
new file mode 100644
index 0000000..df8a9b1
--- /dev/null
+++ b/sql/Bots/world_creature_template_outfits.sql
@@ -0,0 +1,42 @@
+
+
+    -- --------------------------------------------------------
+    -- Host:                         localhost
+    -- Server version:               5.6.10 - MySQL Community Server (GPL)
+    -- Server OS:                    Win64
+    -- HeidiSQL Version:             8.0.0.4491
+    -- --------------------------------------------------------
+
+    /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+    /*!40101 SET NAMES utf8 */;
+    /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+    /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+    -- Dumping structure for table e2_w.creature_template_outfits
+    CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+      `entry` INT(10) UNSIGNED NOT NULL,
+      `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+      `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+      `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+      `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+      PRIMARY KEY  (`entry`)
+    ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+    -- Data exporting was unselected.
+    /*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+    /*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+    /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
new file mode 100644
index 0000000..81b07aa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
@@ -0,0 +1,121 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Bot Quest npc Airen by Graff onlysuffering@gmail.com
+Complete - 0%
+TODO:
+*/
+#define ACT                 GOSSIP_ACTION_INFO_DEF
+
+class Airen_chapter1 : public CreatureScript
+{
+public:
+    Airen_chapter1() : CreatureScript("npc_Airen_qI") { }
+
+    CreatureAI* GetAI(Creature* creature) const OVERRIDE
+    {
+        return new Airen_AI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, "nothing here", 6000, ACT + 1, "nothing here either", 0 * COPPER, true);
+        player->PlayerTalkClass->SendGossipMenu(creature->GetEntry(), creature->GetGUID());
+
+        std::ostringstream msg;
+        msg << "..." << player->GetName() << ", huh?";
+        bot_ai::BotSpeak(msg.str(), CHAT_MSG_WHISPER, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1)
+                {
+                    if (!player->HasEnoughMoney(1 * COPPER))
+                    {
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, 0, 0);
+                        break;
+                    }
+                    player->ModifyMoney(-(1 * COPPER));
+                }
+
+                break;
+            }
+            default:
+                break;
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        std::string answer = "asd";
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1 && code == answer)
+                    bot_ai::BotSpeak("hehe", CHAT_MSG_YELL, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+                break;
+            }
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct Airen_AI : public ScriptedAI
+    {
+        Airen_AI(Creature* creature) : ScriptedAI(creature) { }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->DisappearAndDie(); }
+
+        void UpdateAI(uint32 /*diff*/)
+        {
+        }
+
+        void Reset()
+        {
+            me->SetCreateHealth(213000213);
+            me->SetMaxHealth(me->GetCreateHealth());
+            me->SetFullHealth();
+
+            me->setPowerType(POWER_RAGE);
+            me->SetMaxPower(POWER_RAGE, 10000);
+            me->SetPower(POWER_RAGE, me->GetMaxPower(POWER_RAGE));
+        }
+
+        void DamageTaken(Unit* /*u*/, uint32& damage)
+        {
+            damage = me->GetHealth() > 1 ? 1 : 0;
+        }
+    };
+};
+
+void AddSC_BotQuests_chapter1()
+{
+    new Airen_chapter1();
+}
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..37e36d6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,594 @@
+/*
+Name: bot_GridNotifiers
+%Complete: 95+
+Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+
+uint8 PvP = 1;
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u->IsWithinDistInMap(me, m_range) &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) < REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                if (!checksteal)
+                {
+                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                }
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    SpellInfo const* Info = aura->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        const std::string name = Info->SpellName[0];
+                        if (name == "Vengeance" || name == "Bloody Vengeance")
+                            continue;
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+        { if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+        bool operator()(Unit* u)
+        {
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
+            {
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    if (aura->GetId() == spell)
+                        if (caster == 0 || aura->GetCasterGUID() == caster)
+                            return true;
+                }
+            }
+            return false;
+        }
+    private:
+        uint64 const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        Group const* gr;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u == mytar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->isFrozen() ||
+                u->isInRoots() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118)))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514)))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == CLASS_HUNTER)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513)))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetVictim() == u)
+                return false;
+            if (me->GetTypeId() == TYPEID_UNIT)
+                if (Player* mymaster = me->ToCreature()->GetBotOwner())
+                    if (mymaster->GetVictim() == u)
+                        return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER && u->isFeared())
+                return false;
+            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to AOE damage
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_DISORIENTED)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210)))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386)))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991)))//scatter shot
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->GetVictim() == u && u->GetVictim() == me)
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            //most horrible hacks
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON &&
+                (m_spellId == 2812 || m_spellId == 10318 || //holy
+                m_spellId == 27139 || m_spellId == 48816 || //wra
+                m_spellId == 48817 ||                       //th or
+                m_spellId == 10326))                        //turn evil
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        uint32 m_spellId;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+        { if (!spell) return; }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u == curtar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackle undead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        Unit const* curtar;
+        float m_range;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, bool friendly = false, uint32 spell = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_friend(friendly), m_spell(spell) {}
+        bool operator()(Unit* u)
+        {
+            if (!m_friend && !PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!m_friend && !u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCasted(false))
+                return false;
+            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                return false;
+            if (m_spell == 10326 && //turn evil
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (m_spell == 20066 && //repentance
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bool m_friend;
+        uint32 m_spell;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (!u->IsInCombat())
+                return false;
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) < REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801))) return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, float mindist, bot_ai const* m_ai, bool forCC) :
+        me(unit), max_range(maxdist), min_range(mindist), ai(m_ai), m_forCC(forCC) { }
+        bool operator()(Unit* u)
+        {
+            if (!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI())))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!ai->CanBotAttack(u))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (m_forCC && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (ai->IsInBotParty(u->GetVictim()))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float max_range, min_range;
+        bot_ai const* ai;
+        bool m_forCC;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..84ef966
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,5019 @@
+#include "bot_ai.h"
+#include "bot_GridNotifiers.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GameEventMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Implement virtual inventory for bots
+Better equipment implementation
+Convert doCast events (CD etc.) into SpellHit()- and SpellHitTarget()-based
+Implement Racial Abilities
+Quests
+I NEED MORE
+*/
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+bot_minion_ai::bot_minion_ai(Creature* creature) : bot_ai(creature)
+{
+    Potion_cd = 0;
+    pvpTrinket_cd = 30000;
+    rezz_cd = 0;
+    evade_cd = 0;
+    myangle = 0.f;
+    mana_cd = uint32(-1);
+    health_cd = uint32(-1);
+    _classinfo = new PlayerClassLevelInfo();
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+    for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+    {
+        _ctc[i].first = 0;
+        _ctc[i].second = 0;
+    }
+}
+bot_minion_ai::~bot_minion_ai()
+{
+    delete _classinfo;
+}
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai() { }
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    master = me->GetBotOwner();
+    _roleMask = 0;
+    m_spellpower = 0;
+    m_block = 1;
+    m_expertise = 0;
+    m_spellpen = 0;
+    haste = 0;
+    hit = 0.f;
+    regen_mp5 = 0.f;
+    m_botSpellInfo = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    checkAurasTimer = 20;
+    roleTimer = 0;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid = 0;
+    currentSpell = 0;
+    tempMana = 0;
+    dmgmult_melee = sConfigMgr->GetFloatDefault("Bot.DamageMult.Melee", 1.0);
+    dmgmult_spell = sConfigMgr->GetFloatDefault("Bot.DamageMult.Spell", 1.0) * 0.75f;
+    dmgmult_melee = std::max(dmgmult_melee, 0.01f);
+    dmgmult_spell = std::max(dmgmult_spell, 0.01f);
+    dmgmult_melee = std::min(dmgmult_melee, 10.f);
+    dmgmult_spell = std::min(dmgmult_spell, 10.f);
+    dmgmod_melee = Creature::_GetDamageMod(me->GetCreatureTemplate()->rank);
+    dmgmod_spell = me->GetSpellDamageMod(me->GetCreatureTemplate()->rank);
+    healTargetIconFlags = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+    PvP = sConfigMgr->GetIntDefault("Bot.PvP", 1);
+}
+bot_ai::~bot_ai() { }
+
+SpellCastResult bot_ai::CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (InDuel(victim))
+        return SPELL_FAILED_DONT_REPORT;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (!CheckImmunities(spellId, victim))
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (Powers(spellInfo->PowerType) == me->getPowerType() &&
+        (int32)me->GetPower(me->getPowerType()) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_DONT_REPORT;
+
+    switch (botclass)
+    {
+        case CLASS_PALADIN:
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_DRUID:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_DONT_REPORT;
+            break;
+        case CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_DONT_REPORT;
+            break;
+        case CLASS_ROGUE:
+        case CLASS_HUNTER:
+        case CLASS_DEATH_KNIGHT:
+        default:
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, uint64 originalCaster)
+{
+    if (spellId == 0) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting()) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    if (spellId == MANAPOTION)
+    {
+        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            removeFeralForm(true);
+    }
+
+    if (spellId != HEALINGPOTION && spellId != MANAPOTION)
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+    {
+        //std::ostringstream msg;
+        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+        //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+        me->Relocate(victim);
+    }
+
+    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags, originalCaster);
+    spell->prepare(&targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        //delete spell; //crash due to invalid event added to master's eventmap
+        return false;
+    }
+
+    currentSpell = spellId;
+
+    if (me->GetBotClass() == CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM || GetBotStance() == DEATH_KNIGHT_UNHOLY_PRESENCE)
+        value = int32(1000.f - 1000.f*(float(haste) / 100.f));
+    else
+        value = int32(1500.f - 1500.f*(float(haste) / 100.f));
+
+    GC_Timer = std::max<uint32>(value, 500);
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::_calculatePos(Position& pos)
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float mydist, angle;
+
+    if (IsTank())
+    {
+        mydist = frand(3.5f, 6.5f); //stand a bit farther
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
+    }
+    else if (IsMelee())
+    {
+        mydist = frand(0.2f, 1.f);
+        angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
+    }
+    else
+    {
+        mydist = frand(0.15f, 0.8f);
+        angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
+    }
+    //myangle = angle used last time
+    //if difference between last angle and cur angle is too big, use new angle
+    //else use last angle (prevent constant struggling)
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
+    mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
+    angle += master->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        master->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < master->GetPositionZ())
+                z += 0.25f; //prevent going underground
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //            T
+    //           TTT
+    //    mmmmmmmm mmmmmmmm
+    //   mmmmmmm MMM mmmmmmm
+    //   mmmmm rrrrrrr mmmmm
+    //    ddd rrrrrrrrr ddd
+    //     ddddddddddddddd
+    //       ddddddddddd
+    //
+    //MMM - player
+    //TTT - bot tank
+    //m - melee (warrior, paladin, deathknight, ench shaman)
+    //d - default (druid, rogue, hunter)
+    //r - ranged/support (priest, warlock, mage, elem shaman)
+}
+// Movement set
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 25) return;
+        if (!newpos)
+            _calculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (me->isDead() || IAmDead())
+        return;
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 25) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Buffs And Heal (really)
+void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        if (!master->IsInWorld() || master->IsBeingTeleported())
+            return;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(master, GetHealthPCT(master), diff))
+            return;
+        if (BuffTarget(master, diff))
+            return;
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature* cre = u->ToCreature())
+                if (cre->GetIAmABot() || cre->IsPet())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (!tPlayer->IsAlive()) continue;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature* cre = u->ToCreature())
+                    if (cre->GetIAmABot() || cre->IsPet())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (healTargetIconFlags & GroupIconsFlags[i])
+            {
+                if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
+                {
+                    if (Unit* unit = sObjectAccessor->FindUnit(guid))
+                    {
+                        if (unit->IsAlive() && me->GetMap() == unit->FindMap() &&
+                            master->GetVictim() != unit && unit->GetVictim() != master &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            HealTarget(unit, GetHealthPCT(unit), diff);
+                            //CureTarget(unit, getCureSpell(), diff);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Target is either player or its corpse
+void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (IsCasting()) return;
+    if (rezz_cd > 0) return;
+
+    //sLog->outBasic("RezGroup by %s", me->GetName().c_str());
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit* target = master;
+        if (master->IsAlive()) return;
+        if (master->isRessurectRequested()) return; //resurrected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", master->GetGUID());
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        Unit* target = tPlayer;
+        if (!tPlayer || tPlayer->IsAlive()) continue;
+        if (tPlayer->isRessurectRequested()) continue; //resurrected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (master->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+            if (tPlayer != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += tPlayer->GetName();
+                me->MonsterWhisper(rezstr.c_str(), master->GetGUID());
+            }
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //sLog->outBasic("%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    Group* pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        if (CureTarget(master, cureSpell, diff))
+            return;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
+{
+    return _canCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_minion_ai::_canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || !target->IsAlive()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::_getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
+{
+    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+//protected
+bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid, bool exclude) const
+{
+    ASSERT(spellId);
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_FATAL("entities.player", "bot_ai::HasAuraName(uint32): no spellInfo found for spell %u!", spellId);
+        ASSERT(false);
+    }
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+    std::string const name = spellInfo->SpellName[loc];
+
+    return _hasAuraName(unit, name, casterGuid, exclude);
+}
+//private
+bool bot_ai::_hasAuraName(Unit* unit, std::string const spell, uint64 casterGuid, bool exclude) const
+{
+    ASSERT(unit);
+    ASSERT(spell.length() != 0);
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+
+    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
+    SpellInfo const* spellInfo;
+    std::string name;
+
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        spellInfo = itr->second->GetSpellInfo();
+        name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player* player, Unit* unit) const
+{
+    if (!IsInBotParty(player)) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        if (unit->ToCreature()->GetIAmABot())
+        {
+            botstring << "minion bot, master: ";
+            std::string const& ownername = unit->ToCreature()->GetBotOwner()->GetName();
+            botstring << ownername;
+        }
+        else if (unit->ToCreature()->GetIAmABotsPet())
+        {
+            Player* owner = unit->ToCreature()->GetBotOwner();
+            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUIDLow() << ')';
+        }
+    }
+    ch.PSendSysMessage("ListAuras for %s, %s", unit->GetName().c_str(), botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && spellInfo->GetNextRankSpell())
+            rank = talentcost;
+        else if (learnSpellInfo && learnSpellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+
+        ch.PSendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        ch.PSendSysMessage("%s: %.1f", mystat.c_str(), unit->GetTotalStatValue(Stats(i)));
+    }
+    ch.PSendSysMessage("Melee AP: %.1f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %.1f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %.1f pct", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %.1f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %.1f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("block: %.1f pct", unit->GetUnitBlockChance());
+    ch.PSendSysMessage("block value: %u", unit->GetShieldBlockValue());
+    ch.PSendSysMessage("Damage taken melee: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+    ch.PSendSysMessage("Damage range mainhand: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    ch.PSendSysMessage("Damage range offhand: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    ch.PSendSysMessage("Damage range ranged: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+    ch.PSendSysMessage("Damage mult mainhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult offhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    ch.PSendSysMessage("Damage mult ranged: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    ch.PSendSysMessage("Attack time mainhand: %.2f", float(unit->GetAttackTime(BASE_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time offhand: %.2f", float(unit->GetAttackTime(OFF_ATTACK))/1000.f);
+    ch.PSendSysMessage("Attack time ranged: %.2f", float(unit->GetAttackTime(RANGED_ATTACK))/1000.f);
+    if (unit == me)
+        ch.PSendSysMessage("melee damage mult: %.3f", dmgmult_melee);
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("spellpower: %u", m_spellpower/* - m_spellpower % 50*/);
+        ch.PSendSysMessage("spell damage mult: %.3f", dmgmult_spell);
+        ch.PSendSysMessage("mana regen: %.2f", regen_mp5/* - (int32(regen_mp5) % 45)*/);
+        ch.PSendSysMessage("haste: %u *10 pct", haste);
+        ch.PSendSysMessage("hit: +%.2f pct", hit);
+        ch.PSendSysMessage("expertise: %i (-%.2f pct)", m_expertise, float(m_expertise) * 0.25f);
+        ch.PSendSysMessage("spell penetration: %i", m_spellpen);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, me->GetResistance(SpellSchools(i)));
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint8 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+
+        //ch.PSendSysMessage("CTCs:");
+        //for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+        //{
+        //    if (!_ctc[i].first)
+        //        continue;
+
+        //    if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(_ctc[i].first))
+        //    {
+        //        std::ostringstream msg;
+        //        msg << uint32(CalcCTC(_ctc[i].first)) << " pct to cast ";
+        //        _AddSpellLink(player, spellInfo, msg);
+        //        msg << " on damage deal";
+        //        ch.PSendSysMessage(msg.str().c_str());
+        //    }
+        //}
+
+        //debug
+        //if (IsPetAI()) GetPetAI()->ListSpells(&ch);
+    }
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::SetStats(bool force, bool shapeshift)
+{
+    uint8 myclass = me->GetBotClass();
+    uint8 mylevel = master->getLevel();
+    if (myclass == CLASS_DRUID)
+        myclass = GetBotStance();
+    if (myclass != DRUID_BEAR_FORM && myclass != DRUID_CAT_FORM && (master->isDead() || (!shouldUpdateStats && !force))) return;
+    /*sLog->outBasic("SetStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    mylevel = std::min<uint8>(mylevel, 80);
+
+    //Do not remove this code under any circumstances! You've been warned.
+    if (myclass == CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        //ApplyPassives(me->GetBotClass());
+
+        //need to find a way to remove all passives before reapply (except levelups)
+        //!!!this is only for gm's (players are not supposed to lower their level)
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    uint8 tempclass = myclass == DRUID_BEAR_FORM || myclass == DRUID_CAT_FORM ? CLASS_DRUID : myclass;
+    sObjectMgr->GetPlayerClassLevelInfo(tempclass, mylevel, _classinfo);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass());//use creature class
+    float value;
+    if (force)
+        for (uint8 i = STAT_STAMINA; i < MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i)));
+
+    //MAXSTAT
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value; //Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f); //base value for all stats is 18 (isn't counted in any way)
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+        case CLASS_WARRIOR:      ap_mod = 1.3f; spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+        case CLASS_DEATH_KNIGHT: ap_mod = 1.2f; spp_mod = 0.0f; armor_mod = 1.05f; crit_mod = 1.1f; haste_mod = 1.05f; dodge_mod = 0.6f;  parry_mod = 1.95f;  break;
+        case CLASS_PALADIN:      ap_mod = 1.0f; spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+        case CLASS_ROGUE:        ap_mod = 1.5f; spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;
+        case CLASS_HUNTER:       ap_mod = 1.7f; spp_mod = 0.2f; armor_mod = 1.0f;  crit_mod = 1.2f; haste_mod = 1.85f; dodge_mod = 1.3f;  parry_mod = 1.2f;  break;
+        case CLASS_SHAMAN:       ap_mod = 1.1f; spp_mod = 0.5f; armor_mod = 1.1f;  crit_mod = 1.1f; haste_mod = 1.45f; dodge_mod = 1.1f;  parry_mod = 1.4f;  break;
+        case CLASS_DRUID:        ap_mod = 0.0f; spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_MAGE:         ap_mod = 0.0f; spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_PRIEST:       ap_mod = 0.0f; spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case CLASS_WARLOCK:      ap_mod = 0.0f; spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+        case DRUID_BEAR_FORM:    ap_mod = 2.0f; spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+        case DRUID_CAT_FORM:     ap_mod = 1.5f; spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+        default:                 ap_mod = 0.0f; spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.00f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+
+    //ARMOR
+    //sLog->outBasic("Unpdating %s's ARMOR: ", me->GetName().c_str());
+    //sLog->outBasic("armor mod: %f", armor_mod);
+    armor_mod *= (master->GetModifierValue(UNIT_MOD_ARMOR, BASE_PCT) + master->GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT))/2.f;
+    //sLog->outBasic("armor mod * master's modifier: %f", armor_mod);
+    value = float(classstats->BaseArmor / 2);
+    //sLog->outBasic("base armor: %f", value);
+    value += float(master->GetArmor())/5.f;
+    //sLog->outBasic("base armor + 1/5 of master's armor: %f", value);
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        value += _stats[i][BOT_ITEM_MOD_ARMOR];
+
+    if (IsTank())
+        armor_mod += 0.5f;
+    if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+        armor_mod += 0.6f;
+
+    value *= armor_mod;
+    //sLog->outBasic("multiplied by armor mod (total base armor): %f", value);
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //sLog->outBasic("Unpdating %s's RESISTANCES: ", me->GetName().c_str());
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+
+        for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+            value += 2.5f * (_stats[j][BOT_ITEM_MOD_RESIST_HOLY + (i - 1)]);
+
+        //sLog->outBasic("master's resistance %u: %f, setting %f (triple) to bot", uint32(UNIT_MOD_RESISTANCE_START + i), value, value*3);
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value * 2.f + float(mylevel * 2));
+        //me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_PCT, 1.f);
+        me->UpdateResistances(i);
+    }
+    //DAMAGE TAKEN
+    float directReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    float magicReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC);
+    value = (directReduction + magicReduction)/2.f; // average
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value; //get reduction even if master's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    if (mylevel > 77)
+        value += float(mylevel - 78)*6.f;// + 2 stacks for high level
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    value = 0.f;
+    for (uint8 i = CR_HASTE_MELEE; i != CR_HASTE_SPELL + 1; ++i)
+        if (float rating = std::min<float>(master->GetRatingBonusValue(CombatRating(i)), 30.f))
+            if (rating > value) //master got some haste
+                value = rating; //get hightest pct
+    for (uint8 i = EQUIPMENT_SLOT_BACK; i < EQUIPMENT_SLOT_END; ++i)
+        if (Item* item = master->GetItemByPos(0, i)) //inventory weapons
+            if (item->GetTemplate()->ItemLevel >= 277) //bears ICC 25H LK items or Wrathful items
+                value += 9.f; //only weapons so we can add 1 to 3 stacks (rogue, warr, sham...)
+
+    if (mylevel >= 70)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //25.5 HR = 1% haste at 80 (12.75 for bot)
+            float tempval = _stats[i][ITEM_MOD_HASTE_MELEE_RATING] + _stats[i][ITEM_MOD_HASTE_RANGED_RATING] + _stats[i][ITEM_MOD_HASTE_SPELL_RATING] + _stats[i][ITEM_MOD_HASTE_RATING];
+            value += 3.f * (tempval / (25.5f * (float(mylevel - 40) / 40.f)));
+        }
+    }
+
+    value *= haste_mod;
+    if (IsMeleeClass(myclass))
+        value *= 0.67f; //nerf melee haste by 1/3
+    value = value/10.f + float(mylevel/39);//get bonus at 39 and 78
+    if (myclass == DRUID_CAT_FORM) //give cat lots of haste
+        value += float(mylevel/16); //or 20 (+ 4-5 stacks);
+    RefreshAura(HASTE,  uint8(value) + uint8(myclass == CLASS_SHAMAN) * 2); //spell haste
+    RefreshAura(HASTE2, uint8(value) + uint8(myclass == CLASS_ROGUE)); //melee haste
+    if (myclass == CLASS_ROGUE || myclass == CLASS_HUNTER)
+        RefreshAura(HASTE3, uint8(value) + uint8(myclass == CLASS_HUNTER) * 2); //ranged haste
+    haste = uint8(value); //for show only
+
+    //HIT
+    int32 melee_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE) + master->GetRatingBonusValue(CR_HIT_MELEE);
+    int32 spell_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_HIT_CHANCE) + master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, SPELL_SCHOOL_MASK_SPELL) + master->GetRatingBonusValue(CR_HIT_SPELL);
+    value = std::min<float>(25.0f, float(melee_hit > spell_hit ? melee_hit : spell_hit) * 1.5f); //hightest, buff hit chance for bots
+
+    if (mylevel >= 20)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //32.5 HR = 1% hit at 80
+            float tempval = _stats[i][ITEM_MOD_HIT_MELEE_RATING] + _stats[i][ITEM_MOD_HIT_RANGED_RATING] + _stats[i][ITEM_MOD_HIT_SPELL_RATING] + _stats[i][ITEM_MOD_HIT_RATING];
+            value += 5.f * (tempval / (32.5f * (float(mylevel - 10) / 70.f)));
+        }
+    }
+
+    hit = value;
+    RefreshAura(PRECISION,  int8(hit) + mylevel / 39); //melee
+    RefreshAura(PRECISION2, int8(hit) + mylevel / 39); //spell
+
+    //EXPERTISE
+    if (ap_mod > 0.f) //don't bother casters
+    {
+        m_expertise = std::min<int32>(80, (master->GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) + master->GetRatingBonusValue(CR_EXPERTISE)) * 2); //lots of expertise for bots
+
+        if (mylevel >= 20)
+        {
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                //~8.0 ER = 1 expertise at 80
+                float tempval = _stats[i][ITEM_MOD_EXPERTISE_RATING];
+                m_expertise += int32(2.f * (tempval / (8.0f * (float(mylevel - 10) / 70.f))));
+            }
+        }
+
+        if (m_expertise < 20)
+            RefreshAura(EXPERTISE,  int8(m_expertise / 5)  + mylevel / 39); //5  expertise + 10
+        else
+            RefreshAura(EXPERTISE2, int8(m_expertise / 10) + mylevel / 39); //10 expertise + 20
+    }
+    else
+        m_expertise = 0;
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = std::min<float>(50.0f, master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me));
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if can
+
+    if (mylevel >= 10)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //45 CR = 1% crit at 80
+            float tempval = _stats[i][ITEM_MOD_CRIT_MELEE_RATING] + _stats[i][ITEM_MOD_CRIT_RANGED_RATING] + _stats[i][ITEM_MOD_CRIT_SPELL_RATING] + _stats[i][ITEM_MOD_CRIT_RATING];
+            value += 1.5f * (tempval / (45.f * (float(mylevel - 5) / 75.f)));
+        }
+    }
+
+    value *= crit_mod;
+    RefreshAura(CRITS, int8(value / 5.f) + 1);
+    if (myclass == CLASS_PRIEST)
+        RefreshAura(HOLYCRIT, int8(value / 7.f)); //add holy crit to healers
+
+    //PARRY
+    value = 0.5f * master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
+
+    if (mylevel >= 30)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //67 PR = 1% parry at 80
+            float tempval = _stats[i][ITEM_MOD_PARRY_RATING];
+            value += 1.5f * (tempval / (67.f * (float(mylevel - 20) / 60.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
+            value += 1.5f * (tempval / (125.f * (float(mylevel - 20) / 60.f)));
+        }
+    }
+
+    value *= parry_mod;
+    if (IsTank() && myclass != DRUID_CAT_FORM && myclass != DRUID_BEAR_FORM) //feral cannot parry so let it be base 5%
+        value += 10.f;
+    //Forceful Deflection: 12.5% (half of base 25%) of strength (use max stat) goes to parry rating (~1% parry per 67 rating at 80)
+    if (myclass == CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+        value += (stat / 8.f) / (float(mylevel) - (13.f / (float(mylevel - 40) / 40.f))); //~20 at 55, ~34 at 60 and 67 at 80
+    if (value > 35.f)
+        value = 35.f;
+    float parryAndDodge = value; //set temp value, this is needed to keep total avoidance within 40%
+    RefreshAura(PARRY, int8(value/5.f)); //5% per stack aplied
+
+    //DODGE
+    value = 0.5f * master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
+
+    if (mylevel >= 20)
+    {
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //53 DR = 1% dodge at 80
+            float tempval = _stats[i][ITEM_MOD_DODGE_RATING];
+            value += 1.5f * (tempval / (53.f * (float(mylevel - 10) / 70.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
+            value += 1.5f * (tempval / (125.f * (float(mylevel - 10) / 70.f)));
+        }
+    }
+
+    value *= dodge_mod;
+    if (IsTank())
+        value += 10.f;
+    if (value > 35.f)
+        value = 35.f;
+    if (parryAndDodge + value > 35.f)
+        value = 35.f - parryAndDodge; //do not allow avoidance to be more than 40% (base 5+5)
+    RefreshAura(DODGE, int8(value / 5.f));
+
+    //BLOCK
+    if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+    {
+        value = master->GetFloatValue(PLAYER_BLOCK_PERCENTAGE);
+        if (mylevel >= 10)
+        {
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                //16.5 BR = 1% block at 80
+                float tempval = _stats[i][ITEM_MOD_BLOCK_RATING];
+                value += 1.5f * (tempval / (16.5f * (float(mylevel - 5) / 75.f)));
+                //125 DR = 1% block/parry/dodge at 80
+                tempval = _stats[i][ITEM_MOD_DEFENSE_SKILL_RATING];
+                value += 2.5f * (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+            }
+        }
+
+        if (IsTank())
+            value += 15.f;
+        value = std::min<float>(value, 75.0f);
+        RefreshAura(BLOCK, int8(value / 5.f));
+
+        //BLOCK VALUE
+        float tempval = float(mylevel + mylevel / 4);
+        //tempval += master->GetShieldBlockValue();
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            tempval += 0.75f * (_stats[i][ITEM_MOD_STRENGTH]);
+            tempval += 1.25f * (_stats[i][ITEM_MOD_BLOCK_VALUE]);
+        }
+
+        //Shield Mastery
+        if (mylevel >= 20 && myclass == CLASS_WARRIOR)
+            tempval *= 1.3f;
+
+        tempval = std::max<float>(tempval - 10.f, 1.f);
+
+        m_block = uint32(tempval);
+    }
+    else
+        m_block = 1;
+
+    //MANA
+    _OnManaUpdate(shapeshift);
+
+    //MANA REGEN
+    if (mylevel >= 40 && (me->getPowerType() == POWER_MANA || me->getPowerType() == POWER_RUNIC_POWER))
+    {
+        regen_mp5 = 0.5f * master->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+        //TOO COMPLICATED
+        //regen_mp5 = (master->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + sqrt(master->GetStat(STAT_INTELLECT)) * master->OCTRegenMPPerSpirit()) / 5.f;
+        //Unit::AuraEffectList const& regenAura = master->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        //for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+        //    regen_mp5 += master->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() / 500.f;
+        //regen_mp5 *= 0.8f;//custom modifier
+        float regen_mp5_a = stat * 0.2f;
+        //regen_mp5 += master->GetTotalStatValue(STAT_SPIRIT) * 0.1f;
+        regen_mp5 = regen_mp5 > regen_mp5_a ? regen_mp5 : regen_mp5_a;
+
+        //unknown values
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            regen_mp5 += 2.f * (_stats[i][ITEM_MOD_MANA_REGENERATION]);
+            regen_mp5 += 1.f * (_stats[i][ITEM_MOD_SPIRIT]);
+        }
+
+        if (myclass == CLASS_HUNTER && mylevel > 20)
+            regen_mp5 += 45.f * ((mylevel - 20) / 15 + 1);
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel / 20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel / 20);
+        }
+    }
+
+    //SPELL PENETRATION
+    if (mylevel >= 30 && spp_mod > 0.f)
+    {
+        m_spellpen = std::min<int32>(200, master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_TARGET_RESISTANCE, SPELL_SCHOOL_MASK_SPELL) / 2);
+
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            //~1 SPPR = 1 spell penetration
+            m_spellpen += 5 * _stats[i][ITEM_MOD_SPELL_PENETRATION];
+        }
+
+        if (m_spellpen < 25)
+            RefreshAura(SPELL_PEN_5,  int8(m_spellpen / 5)  + mylevel / 20); //5  sppen + 20
+        else
+            RefreshAura(SPELL_PEN_20, int8(m_spellpen / 20) + mylevel / 40); //20 sppen + 40
+    }
+    else
+        m_spellpen = 0;
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod > 0.f)
+    {
+        //sLog->outBasic("Updating spellpower for %s:", me->GetName().c_str());
+        //sLog->outBasic("spp_mod: %f", spp_mod);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+            if (power > sppower || i == SPELL_SCHOOL_HOLY)
+                sppower = power;
+        }
+        //sLog->outBasic("Master's spell power: %i", sppower);
+        atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+        atpower *= 0.67f;
+        //sLog->outBasic("Master's 2/3 of attack power: %f", atpower);
+        m_spellpower = sppower > atpower ? sppower : atpower;
+        //sLog->outBasic("Chosen stat value: %i", m_spellpower);
+
+        m_spellpower /= 3; //reduce spellpower since we have items
+
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            m_spellpower += 2 * (_stats[i][ITEM_MOD_SPELL_POWER]);
+
+        m_spellpower = int32(float(m_spellpower) * spp_mod);
+        //sLog->outBasic("spellpower * mod: %i", m_spellpower);
+
+        if (myclass == CLASS_MAGE)
+            RefreshAura(FIREDAM_86, (m_spellpower / 4) / 86 + (mylevel >= 78) * 2); //(86,172,258,344,430,516,602,688...) // fire spp, do not touch this
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower / 50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower / 150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower / 250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->SetStats(force);
+
+    shouldUpdateStats = false;
+}
+void bot_pet_ai::SetStats(bool force)
+{
+    uint8 mylevel = master->getLevel();
+    uint8 petType = GetPetType(me);
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+    //TC_LOG_ERROR("entities.player", "SetStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        //ApplyPassives(me->GetBotClass());
+
+        //need to find a way to remove all passives before reapply (except levelups)
+        //!!!this is only for gm's (players are not supposed to lower their level)
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    ////INIT STATS
+    //uint8 botclass = m_creatureOwner->GetBotClass();
+    //sObjectMgr->GetPlayerClassLevelInfo(botclass, m_creatureOwner->getLevel(), _classinfo);
+    //const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->GetBotClass());//use creature class
+    //if (force)
+    //    for (uint8 i = STAT_STRENGTH; i < MAX_STATS; i++)
+    //        me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i))*0.5f);
+
+    //MAXSTAT
+    float value;
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+    stat = std::max(stat - 18.f, 0.f);//remove base
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //Other   x1.0  -- use as default
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
+        default:                        ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
+    }
+    //case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+    //case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+    //case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+    //case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+    //case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+    //case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+    //case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    //case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+    //case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39)) / 41.f;// gain spell power slowly
+
+    //DAMAGE
+    if (ap_mod > 0.f)//do not bother casters
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            case CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        //Calculate ap
+        //set base strength
+        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+        //calc attack power (strength and minion's spd)
+        atpower = me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH) * 2.f + value * ap_mod;
+        //set value
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage();
+    }
+
+    //ARMOR
+    value = float(basearmor);
+    //get minion's armor and give 35% to pet (just as for real pets)
+    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE) * 0.35f;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f * (value * 2.5f + float(mylevel * 2)));
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    //just get minion's reduction and apply to pet
+    value = m_creatureOwner->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    if (value > 1.f)
+        value -= 1.f;
+    else
+        value = 1.f - value; //get reduction even if owner's is 1.0+
+    value = std::min(0.42f, value);
+    value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+    RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+
+    //HEALTH
+    _OnHealthUpdate();
+
+//////RATINGS//////
+    //ok now, pet receives 100% of its master's ratings
+
+    //HASTE
+    haste = m_creatureOwner->GetBotAI()->GetHaste();
+    RefreshAura(HASTE,  haste);//spell haste
+    RefreshAura(HASTE2, haste);//melee haste
+
+    //HIT
+    hit = m_creatureOwner->GetBotAI()->GetHitRating();
+    RefreshAura(PRECISION,  int8(hit) + mylevel / 39);//melee
+    RefreshAura(PRECISION2, int8(hit) + mylevel / 39);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    if (crit_mod != 1.0f)
+        value *= crit_mod;
+    RefreshAura(CRITS, int8(value / 5.f) + mylevel / 39);
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    if (IsTank())
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    float parryAndDodge = value; //set temp value, this is needed to keep total avoidance within 75%
+    RefreshAura(PARRY, int8(value / 5.f));
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f; //remove base chance if possible
+    if (IsTank())
+        value += 10.f;
+    if (value > 65.f)
+        value = 65.f;
+    if (parryAndDodge + value > 65.f)
+        value = 65.f - parryAndDodge; //do not allow avoidance to be more than 75% (base 5+5)
+    RefreshAura(DODGE, int8(value / 5.f));
+
+    //MANA
+    _OnManaUpdate(false);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        //let regen rate be same as stats rate x0.3
+        regen_mp5 = m_creatureOwner->GetBotAI()->GetManaRegen() * 0.3f;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5 / 100.f) + mylevel / 20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5 / 45.f)  + mylevel / 20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetSpellPower());
+                break;
+            case CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                value = 0.f;
+                break;
+        }
+        m_spellpower = int32(value * spp_mod);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower / 50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower / 150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower / 250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    shouldUpdateStats = false;
+}
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            me->MonsterWhisper("Standing Still.", player->GetGUID());
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            me->MonsterWhisper("Following!", player->GetGUID());
+            break;
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit* unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    //cheap check
+    if (Group* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (healTargetIconFlags & GroupIconsFlags[i])
+                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL &&
+                            master->GetVictim() != unit &&
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature* cre = unit->ToCreature())
+    {
+        //npcbot/npcbot's pet case
+        if (Player* owner = cre->GetBotOwner())
+        {
+            if (owner == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            uint64 ownerGuid = unit->GetOwnerGUID();
+            //controlled by group member
+            if (Group* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spell, int8 count) const
+{
+    if (!spell)
+        return false;
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (!spellInfo)
+        return false;
+    //if (!spellInfo->IsPassive())
+    //{
+    //    TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): %s received spell %u (%s) which is not a passive spell!", target->GetName().c_str(), spell, spellInfo->SpellName[0]);
+    //    //return false;
+    //}
+    if (me->HasAura(spell))
+        me->RemoveAurasDueToSpell(spell);
+
+    //if (count > 15)
+    //    TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): %s's aura count for spell %u (%s) is greater than 15... (%i)", target->GetName().c_str(), spell, spellInfo->SpellName, count);
+
+    for (uint8 i = 0; i < count; ++i)
+        me->AddAura(spellInfo, MAX_EFFECT_MASK, me);
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_minion_ai::CheckAuras(bool force)
+{
+    opponent = me->GetVictim(); //safe
+
+    if (!force)
+        _updateRations(); //safe
+
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY && opponent && !CCed(me, true))
+        {
+            if (IsMelee())
+            {
+                if (me->GetDistance(opponent) > 1.5f)
+                    GetInPosition(true);
+            }
+            else
+            {
+                CalculateAttackPos(opponent, attackpos);
+                if (me->GetDistance(attackpos) > 8)
+                    GetInPosition(true, opponent, &attackpos);
+            }
+        }
+        if (shouldUpdateStats)
+            SetStats(false);
+        else
+        {
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+            clear_cd = 15;
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent)
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                _calculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); //check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat())
+            {
+                if (me->GetBotClass() == CLASS_HUNTER)
+                {
+                    if (me->GetSheath() != SHEATH_STATE_RANGED)
+                        me->SetSheath(SHEATH_STATE_RANGED);
+                }
+                else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                    me->SetSheath(SHEATH_STATE_MELEE);
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+        _updateMountedState();
+        _updateStandState();
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    if (checkAurasTimer > 0) return;
+    checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true);
+                    break;
+            }
+        }
+    }
+    if (clear_cd > 0)
+        --clear_cd;
+    else
+        clear_cd = 15;
+
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit* target, int8 byspell) const
+{
+    if (!target)
+        return false;
+    if (!PvP && (target->ToPlayer() || (target->ToCreature() && target->ToCreature()->GetBotAI())))
+        return false;
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY && master->GetVictim() == target && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//uses follow distance if range isn't set
+Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //check if no need to change target
+    Unit* u = master->GetVictim();
+    Unit* mytar = me->GetVictim();
+    if (!mytar && IsMinionAI())
+        if (Creature* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s, PvP = %u", me->GetName().c_str(), PvP);
+
+    if (u && u == mytar)
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u) && !(!PvP && (u->ToPlayer() || (u->ToCreature() && u->ToCreature()->GetBotAI()))))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    Group* gr = master->GetGroup();
+    if (!gr)
+    {
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+            u = bot->GetVictim();
+            if (u && CanBotAttack(u, byspell) &&
+                (bot->IsInCombat() || u->IsInCombat()) &&
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+            if (!pet || !pet->InSamePhase(me)) continue;
+            u = pet->GetVictim();
+            if (u && CanBotAttack(u, byspell) &&
+                (pet->IsInCombat() || u->IsInCombat()) &&
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+        }
+    }
+    else
+    {
+        for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+        {
+            Player* pl = ref->GetSource();
+            if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+            if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+            u = pl->GetVictim();
+            if (u && pl != master && CanBotAttack(u, byspell) &&
+                (pl->IsInCombat() || u->IsInCombat()) &&
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                return u;
+            }
+            if (!pl->HaveBot()) continue;
+            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = pl->GetBotMap(i)->_Cre();
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                if (!bot->IsInWorld()) continue;
+                if (me->GetMap() != bot->FindMap()) continue;
+                u = bot->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (bot->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                if (!pet || !pet->InSamePhase(me)) continue;
+                if (!pet->IsInWorld()) continue;
+                if (me->GetMap() != pet->FindMap()) continue;
+                u = pet->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (pet->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
+        reset = true;
+    }
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
+{
+    bool byspell = false, ranged = !IsMelee(), reset = false;
+
+    if (IsMinionAI())
+    {
+        switch (botOrPetType)
+        {
+            case CLASS_DRUID:
+                byspell = me->GetShapeshiftForm() == FORM_NONE ||
+                    me->GetShapeshiftForm() == FORM_TREE ||
+                    me->GetShapeshiftForm() == FORM_MOONKIN;
+                ranged = byspell;
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+            case CLASS_SHAMAN:
+                byspell = true;
+            default:
+                break;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                break;
+        }
+    }
+
+    opponent = _getTarget(byspell, ranged, reset);
+    if (!opponent)
+    {
+        me->AttackStop();
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    if (me->GetIAmABotsPet())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 28 ? 28.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    uint8 followdist = master->GetBotFollowDist();
+    bool ranged = !IsMelee();
+    if (ranged)
+    {
+        if (newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > (me->GetBotClass() == CLASS_HUNTER ? 4 : 8))
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else if (!me->HasUnitState(UNIT_STATE_CHASE) || !me->HasUnitState(UNIT_STATE_CHASE_MOVE))
+        me->GetMotionMaster()->MoveChase(newtarget);
+
+    if (newtarget != me->GetVictim())
+        me->Attack(newtarget, !ranged);
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS))
+            DoMeleeAttackIfReady();
+    }
+    else
+        Evade();
+}
+
+bool bot_ai::MoveBehind(Unit &target) const
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return false;
+    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target.HasInArc(M_PI, me)                       &&
+        !IsTank()                                       &&
+        (me->GetBotClass() == CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
+    {
+        float x(0),y(0),z(0);
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_minion_ai::_updateMountedState()
+{
+    if (GetBotCommandState() != COMMAND_FOLLOW)
+        return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType &= ~INHABIT_AIR;
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        //me->RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
+        me->Dismount();
+        return;
+    }
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+    //fly
+    //if ((master->IsMounted() && master->HasAuraType(SPELL_AURA_FLY))/* || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)*/)
+    //{
+    //    if (!me->IsMounted() || !me->HasAuraType(SPELL_AURA_FLY))
+    //    {
+    //        //if (me->GetBotClass() == CLASS_DRUID && InitSpell(FLY_FORM))//TODO
+    //        //{
+    //        //}
+    //        //else
+    //        {
+    //            uint32 mount = 0;
+    //            Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    //            if (!mounts.empty())
+    //                mount = mounts.front()->GetId();
+    //            if (mount)
+    //            {
+    //                if (me->HasAuraType(SPELL_AURA_MOUNTED))
+    //                        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    //                if (doCast(me, mount))
+    //                {
+    //                    if (Feasting())
+    //                    {
+    //                        me->RemoveAurasDueToSpell(DRINK);
+    //                        me->RemoveAurasDueToSpell(EAT);
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    //}
+    ////ground
+    /*else */
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
+            else
+                mount = mounts.front()->GetId();
+        }
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::_updateStandState() const
+{
+    if (master->getStandState() == UNIT_STAND_STATE_STAND &&
+        me->getStandState() == UNIT_STAND_STATE_SIT &&
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if ((master->getStandState() == UNIT_STAND_STATE_SIT || Feasting()) && !me->IsInCombat() && !me->isMoving() &&
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+
+}
+//RATIONS
+void bot_minion_ai::_updateRations()
+{
+    if (mana_cd > RATIONS_CD)
+        mana_cd = uint32(-1);
+    if (health_cd > RATIONS_CD)
+        health_cd = uint32(-1);
+
+    if (me->IsInCombat() || CCed(me))
+    {
+        if (health_cd <= RATIONS_CD && me->HasAura(EAT))
+        {
+            health_cd = uint32(-1);
+            me->RemoveAurasDueToSpell(EAT);
+        }
+        if (mana_cd <= RATIONS_CD && me->HasAura(DRINK))
+        {
+            mana_cd = uint32(-1);
+            me->RemoveAurasDueToSpell(DRINK);
+        }
+
+        return;
+    }
+
+    //drink
+    if (me->getPowerType() == POWER_MANA && !me->IsMounted() && !me->isMoving() &&
+        !me->IsInCombat() && !IsCasting() && urand(0, 100) < 20 && GetManaPCT(me) < 80 &&
+        !me->HasAura(DRINK))
+    {
+        mana_cd = RATIONS_CD;
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (mana_cd == 0 && me->getPowerType() == POWER_MANA && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+    {
+        mana_cd = RATIONS_CD;
+        me->ModifyPower(POWER_MANA, me->GetMaxPower(POWER_MANA) / (RATIONS_CD / 40)/*1000/40=25*/); //4% per second
+    }
+
+    //eat
+    if (!me->IsMounted() && !me->isMoving() && !me->IsInCombat() && !IsCasting() &&
+        urand(0, 100) < 20 && GetHealthPCT(me) < 80 &&
+        !me->HasAura(EAT))
+    {
+        health_cd = RATIONS_CD;
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (health_cd == 0 && me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+    {
+        health_cd = RATIONS_CD;
+        me->SetHealth(me->GetHealth() + me->GetMaxHealth() / (RATIONS_CD / 50)/*1000/50=20*/); //5% per second
+    }
+
+    //check
+    if (health_cd <= RATIONS_CD && me->GetHealth() >= me->GetMaxHealth() && me->HasAura(EAT))
+    {
+        health_cd = uint32(-1);
+        me->RemoveAurasDueToSpell(EAT);
+    }
+
+    if (mana_cd <= RATIONS_CD && me->getPowerType() == POWER_MANA &&
+        me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) &&
+        me->HasAura(DRINK))
+    {
+        mana_cd = uint32(-1);
+        me->RemoveAurasDueToSpell(DRINK);
+    }
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives(uint8 botOrPetType) const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    //movement speed
+    if (master->HasAuraType(SPELL_AURA_MOD_SPEED_ALWAYS) ||
+        master->HasAuraType(SPELL_AURA_MOD_SPEED_NOT_STACK) ||
+        master->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED))
+        RefreshAura(BOAR);
+
+    //apply +healing taken
+    if (master->getLevel() >= 40)
+        RefreshAura(BOR);//+40%
+
+    if (IsMinionAI())
+    {
+        //apply -threat mod
+        switch (botOrPetType)
+        {
+            case CLASS_WARRIOR:
+            case CLASS_DEATH_KNIGHT:
+                RefreshAura(RCP, 1 * !IsTank()); //-27%
+                break;
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_ROGUE:
+            case CLASS_HUNTER:
+            case CLASS_SHAMAN:
+                RefreshAura(RCP, 3 * !IsTank()); //-87%
+                break;
+            default:
+                RefreshAura(RCP, 2 * !IsTank()); //-54%
+                break;
+        }
+        //apply +threat mod
+        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 1 * IsTank()); //+43%
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_VOIDWALKER:
+                RefreshAura(DEFENSIVE_STANCE_PASSIVE, 2 * IsTank());
+                break;
+            default:
+                break;
+        }
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit* target) const
+{
+    if (!target) return false;
+    bool isbot = target->GetTypeId() == TYPEID_UNIT && (target->ToCreature()->GetIAmABot() || target->ToCreature()->GetIAmABotsPet());
+    Player* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+}
+//Used to find target for priest's dispels and mage's spellsteal (also shaman's purge in future)
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return NULL;
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindStunTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit* bot_minion_ai::FindCastingTarget(float maxdist, float mindist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    CastingUnitCheck check(me, mindist, maxdist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (IsCasting())
+        return NULL;
+
+    Unit* unit = NULL;
+    Group* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = master->GetBotMap(i)->_Cre();
+            if (!bot || !bot->IsAlive() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+            if (!bot || !bot->IsAlive() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+
+Unit* bot_minion_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitLastSearcher <TranquilTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+
+void bot_minion_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, float mindist, bool forCC) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyHostileUnitCheck check(me, maxdist, mindist, this, forCC);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+}
+
+//////////
+//Internal
+//////////
+//Using rist-rank spell as source, returns spell of max rank allowed for given caster
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_FATAL("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using rist-rank spell as source, returns spell of max rank allowed for given caster in given spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_FATAL("entities.player", "InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->getLevel();
+    uint32 spellId = 0;
+
+    while (info != NULL && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    //if (spellId != 0)
+    //{
+        BotSpell newSpell;
+        newSpell.first = spellId;
+        newSpell.second = GetSpellCooldown(basespell);
+        spells[basespell] = newSpell;
+    //}
+}
+//Using rist-rank spell as source, return current spell id
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.first : 0;
+}
+//Using rist-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.second : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD, uint32 forcedTime) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+    {
+        return
+        ((*itr).second.first != 0 &&
+        (!checkGCD || GC_Timer <= diff) &&
+        (*itr).second.second <= (forcedTime ? forcedTime : diff));
+    }
+
+    return false;
+}
+//Using rist-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    BotSpellMap::iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+        (*itr).second.second = msCooldown;
+}
+//Using rist-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpellMap::iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+    {
+        //spells.erase(itr); //usafe possible
+        (*itr).second.first = 0;
+        //(*itr).second.second = 0; //unneeded
+    }
+}
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+        if ((*itr).second.second > diff)
+            (*itr).second.second -= diff;
+}
+//Health magement for minions
+//Including health calcs, set and regeneration
+void bot_minion_ai::_OnHealthUpdate() const
+{
+    uint8 myclass = me->GetBotClass();
+    uint8 mylevel = master->getLevel();
+    if (myclass == CLASS_DRUID)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealthPct();// needs for regeneration
+    uint32 m_basehp = _classinfo->basehealth;
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+    float stammod;
+    switch (myclass)
+    {
+        case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case DRUID_BEAR_FORM:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 16.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 13.f;
+                    break;
+                default: stammod = 9.8f; break;
+            }
+            break;
+        case CLASS_PALADIN:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 15.5f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 12.5f;
+                    break;
+                case CLASS_PALADIN:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 9.f; break;
+            }
+            break;
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 9.8f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 8.f;
+                    break;
+                default: stammod = 5.f; break;
+            }
+            break;
+        case CLASS_DRUID: case DRUID_CAT_FORM: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            switch (master->getClass())
+            {
+                case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                    stammod = 12.f;
+                    break;
+                case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                    stammod = 9.8f;
+                    break;
+                default: stammod = 8.f; break;
+            }
+            break;
+        default:
+            TC_LOG_FATAL("entities.player", "bmai::_OnHealthUpdate(): unknown 'myclass' value (%u)", myclass);
+            stammod = 10.f;
+            break;
+    }
+    stammod -= 0.3f;
+    stammod *= 0.75f;
+    //TC_LOG_ERROR("entities.player", "stammod: %f", stammod);
+
+    //manually pick up stamina from bot's buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        stamValue += 1.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_STAMINA]);
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue * 10.f);
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        hp_add += 3.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_HEALTH]);
+
+    //pick up master's stamina from items
+    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) - 0.1f), 1.f);
+    float base_stam = master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE);
+    base_stam = std::max(base_stam - 18.f, 0.f); //remove base stamina (not calculated into health)
+    stamValue = base_stam * master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT) * total_pct;
+    //TC_LOG_ERROR("entities.player", "stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    hp_add += int32(stamValue * stammod);
+    //float stamstat = stat * 0.5f;
+    //if (stamValue > stamstat)
+    //{
+    //    //sLog->outBasic("selected stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    //    hp_add += int32(stamValue * stammod);
+    //}
+    //else
+    //{
+    //    //sLog->outBasic("selected stat to health add: stamStat (%f), value: %f", stamstat, stamstat*stammod);
+    //    hp_add += int32(stamstat * stammod);
+    //}
+    //sLog->outBasic("health to add after master's stat mod: %i", hp_add);
+    int32 miscVal = me->getGender() * mylevel;
+    //TC_LOG_ERROR("entities.player", "health to remove from gender mod: %i", -miscVal);
+    hp_add -= miscVal;//less hp for females lol
+    //TC_LOG_ERROR("entities.player", "health to add after gender mod: %i", hp_add);
+    //miscVal = myrace*(mylevel/5);
+    //TC_LOG_ERROR("entities.player", "health to add from race mod: %i", miscVal);
+    //hp_add += miscVal;//draenei tanks lol
+    //TC_LOG_ERROR("entities.player", "health to add after race mod: %i", hp_add);
+    miscVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel / 5);
+    //TC_LOG_ERROR("entities.player", "health to remove from slot mod: %i", -miscVal);
+    hp_add -= miscVal;
+    //TC_LOG_ERROR("entities.player", "health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add; //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+    uint32 bonuspct = 0;
+    bonuspct += 35 * IsTank();
+    bonuspct += 8 * (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE);
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth();//will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100 + me->getLevel() / 2); //regenerate
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate(bool shapeshift)
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+    uint8 myclass = me->GetBotClass();
+    uint8 mylevel = master->getLevel();
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana > 0 ? _classinfo->basemana : me->GetCreateMana();
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+    me->SetCreateMana(m_basemana); //set base mana, critical
+    float manamod = 15.f; //here we set mana multiplier from intellect as we gain mana from MASTER's stats mostly
+    switch (myclass)
+    {
+        case CLASS_HUNTER:                     manamod =  8.5f; break;
+        case CLASS_PALADIN:                    manamod =  4.5f; break;
+        case CLASS_SHAMAN:                     manamod = 13.5f; break;
+        case CLASS_DRUID:                      manamod = 12.5f; break;
+        case CLASS_PRIEST:                     manamod = 16.5f; break;
+        case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 10.5f; break;
+        default:                                                break;
+    }
+
+    manamod *= 0.75f; //custom
+
+    //TC_LOG_ERROR("entities.player", "Manamod: %f", manamod);
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT);
+    intValue = std::max(intValue - 18.f, 1.f); //remove base int (not calculated into mana)
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        intValue += 1.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_INTELLECT]);
+        m_basemana += 3.f * (static_cast<BotStat>(_stats[i])[ITEM_MOD_MANA]);
+    }
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to mana add: Int (%f), value: %f", intValue, intValue * manamod);
+    m_basemana += intValue * 15.f;
+    //pick up master's intellect from items if master has mana
+    if (master->getPowerType() == POWER_MANA)
+    {
+        float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT) - 0.1f), 1.f);
+        intValue = std::max(master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE) - 18.f, 1.f); //remove base int (not calculated into mana)
+        intValue = intValue * master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT) * total_pct;
+    }
+    else // pick up maxstat
+        intValue = stat * 0.5f;
+    //TC_LOG_ERROR("entities.player", "mana add from master's stat: %f", intValue * manamod);
+    m_basemana += intValue * manamod;
+    //TC_LOG_ERROR("entities.player", "base mana + mana from master's intellect or stat: %f", m_basemana);
+    //intValue = me->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT);
+    //sLog->outBasic("Intellect from buffs: %f", intValue);
+    //m_basemana += uint32(intValue) * manamod;
+    //sLog->outBasic("base mana + mana from intellect + mana from buffs: %u", m_basemana);
+    uint8 otherVal = me->getGender() * 3 * mylevel;
+    //TC_LOG_ERROR("entities.player", "mana to add from gender mod: %u", otherVal);
+    m_basemana += float(otherVal); //more mana for females lol
+    //TC_LOG_ERROR("entities.player", "base mana after gender mod: %f", m_basemana);
+    otherVal = master->GetNpcBotSlot(me->GetGUID()) * (mylevel / 5); //only to make mana unique
+    //TC_LOG_ERROR("entities.player", "mana to remove from slot mod: %i", -int8(otherVal));
+    m_basemana -= otherVal;
+    //TC_LOG_ERROR("entities.player", "base mana after slot mod: %f", m_basemana);
+    float m_totalmana = m_basemana;
+    //TC_LOG_ERROR("entities.player", "total mana to set: %f", m_totalmana);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_totalmana);
+    me->UpdateMaxPower(POWER_MANA);
+    //TC_LOG_ERROR("entities.player", "Overall mana to set: %u", me->GetMaxPower(POWER_MANA));
+    if (tempMana)
+    {
+        me->SetPower(POWER_MANA, tempMana);
+        if (shapeshift == false)
+            tempMana = 0;
+    }
+    else
+        me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+    //No Regen
+}
+//Melee damage for minions (melee classes only)
+//Calculation is based on master's attack power if melee/hunter or spellpower
+void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (ap_mod < 0.1f) return; //do not bother casters
+    //sLog->outBasic("_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
+    float my_ap_mod = ap_mod;
+    float mod = master->getClass() == CLASS_HUNTER ? (master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT))/2.f :
+        (master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT))/2.f;
+    mod = std::max(mod, 1.f); // x1 is Minimum
+    mod = std::min(mod, 2.5f); // x2.5 is Maximum
+    //sLog->outBasic("got base damage modifier: %f", mod);
+    mod -= (mod - 1.f)*0.33f;//reduce bonus by 33%
+    //sLog->outBasic("damage modifier truencated to %f, applying", mod);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        me->SetModifierValue(UnitMods(UNIT_MOD_DAMAGE_MAINHAND + i), BASE_VALUE, static_cast<BotStat>(_stats[i])[BOT_ITEM_MOD_DAMAGE]);
+
+    me->SetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT, mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);
+    //me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);//NUY
+    mod = (mod - 1.f)*0.5f;
+    //sLog->outBasic("reduced damage modifier to gain bonus: %f", mod);
+    //sLog->outBasic("base ap modifier is %f", my_ap_mod);
+    my_ap_mod *= 0.5f;
+    //sLog->outBasic("ap modifier multiplied to %f", my_ap_mod);
+    my_ap_mod += my_ap_mod > 0.f ? mod : 0.f; //add reduced master's multiplier if can have damage
+    //sLog->outBasic("ap modifier + mod = %f", my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_PCT, my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_PCT, my_ap_mod);
+
+    int32 sppower = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+        if (power > sppower)
+            sppower = power;
+    }
+    //sLog->outBasic("master's spellpower is %i, multiplying...", sppower);
+    sppower *= 1.5f;
+    //sLog->outBasic("got spellpower of %i", sppower);
+    //atpower = float(master->GetInt32Value(master->getClass() == CLASS_HUNTER ? UNIT_FIELD_RANGED_ATTACK_POWER : UNIT_FIELD_ATTACK_POWER));
+    float atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+    //sLog->outBasic("master's base attack power is %f", atpower);
+    atpower = sppower > atpower ? sppower : atpower; //highest stat is used (either 1.5x spellpower or attack power)
+    //sLog->outBasic("chosen attack power stat value: %f", atpower);
+    //sLog->outBasic("expected attack power: %f", atpower*ap_mod);
+    atpower *= 0.333f; //reduce damage since we can have weapons
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        atpower += static_cast<BotStat>(_stats[i])[ITEM_MOD_ATTACK_POWER] + static_cast<BotStat>(_stats[i])[ITEM_MOD_RANGED_ATTACK_POWER] +
+            static_cast<BotStat>(_stats[i])[ITEM_MOD_STRENGTH] * 2 + static_cast<BotStat>(_stats[i])[ITEM_MOD_AGILITY] * 2;
+    }
+
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    if (myclass == CLASS_HUNTER || myclass == CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+    me->UpdateAttackPowerAndDamage();
+    //sLog->outBasic("listing stats: ");
+    //sLog->outBasic("attack power main hand: %f", me->GetTotalAttackPowerValue(BASE_ATTACK));
+    //sLog->outBasic("attack power off hand: %f", me->GetTotalAttackPowerValue(OFF_ATTACK));
+    //sLog->outBasic("attack power ranged: %f", me->GetTotalAttackPowerValue(RANGED_ATTACK));
+    //sLog->outBasic("damage multiplier main hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier off hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier ranged: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    //sLog->outBasic("Damage range main hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    //sLog->outBasic("Damage range off hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    //sLog->outBasic("Damage range ranged: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate() const
+{
+    uint8 mylevel = master->getLevel();
+    float hp_mult = 10.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            hp_mult = 11.f;
+            break;
+        default:
+            break;
+    }
+    float pct = me->GetHealthPct();// needs for regeneration
+    //Use simple checks and calcs
+    //0.3 hp for bots (inaccurate but cheap)
+    uint32 m_basehp = me->GetCreateHealth() / 2;
+    //pick up stamina from buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    stamValue = std::max(stamValue - 18.f, 1.f); //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue * hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth()) * 0.3f;
+    uint8 miscVal = GetPetType(me)*mylevel;
+    hp_add -= miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (IsTank())
+        m_totalhp = (m_totalhp * 135) / 100; //35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth(); //will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+    if (!me->IsInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100 + me->getLevel() / 2); //regenerate
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate(bool /*shapeshift*/)
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+
+    uint8 mylevel = master->getLevel();
+
+    float mana_mult = 15.f;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:
+            mana_mult = 11.5f;
+            break;
+        default:
+            break;
+    }
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    //Use simple checks and calcs
+    //0.3 mana for bots (inaccurate but cheap)
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += (std::max<float>(me->GetTotalStatValue(STAT_INTELLECT) - 18.f, 1.f))*mana_mult; //remove base stamina (not calculated into mana)
+    m_basemana += float(m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana())*0.3f;
+    m_basemana -= float(GetPetType(me)*mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA))*pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+void bot_ai::SendPartyEvadeAbort() const
+{
+    for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        if (Creature* bot = master->GetBotMap(i)->_Cre())
+            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+                ai->SetEvadeTimer(50);
+}
+//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally interrupts casted spell if target is dead for bot and it's pet
+void bot_minion_ai::_evade()
+{
+    if (me->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
+
+    if (Rand() > 10) return;
+    if (!master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
+    if (CheckAttackTarget(me->GetBotClass()))
+        return;
+    //ChatHandler ch(master);
+    //ch.PSendSysMessage("_evade() by bot %s", me->GetName().c_str());
+    if (master->IsInCombat())
+    {
+        HostileRefManager& mgr = master->getHostileRefManager();
+        if (!mgr.isEmpty())
+        {
+            std::set<Unit*> Set;
+            HostileReference* ref = mgr.getFirst();
+            while (ref)
+            {
+                if (ref->GetSource() && ref->GetSource()->GetOwner())
+                    Set.insert(ref->GetSource()->GetOwner());
+                ref = ref->next();
+            }
+            for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit* unit = (*i);
+                if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                {
+                    //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), master->GetName().c_str());
+                    mgr.deleteReference(unit);
+                }
+            }
+        }
+    }
+    else
+    {
+        SendPartyEvadeAbort();
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature* cre = master->GetBotMap(i)->_Cre();
+            if (!cre) continue;
+            if (cre->IsInCombat())
+            {
+                cre->DeleteThreatList();
+                HostileRefManager& mgr = cre->getHostileRefManager();
+                if (!mgr.isEmpty())
+                {
+                    std::set<Unit*> Set;
+                    HostileReference* ref = mgr.getFirst();
+                    while (ref)
+                    {
+                        if (ref->GetSource() && ref->GetSource()->GetOwner())
+                            Set.insert(ref->GetSource()->GetOwner());
+                        ref = ref->next();
+                    }
+                    for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = (*i);
+                        if (!unit->InSamePhase(me)) continue;
+                        if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), cre->GetName().c_str());
+                            mgr.deleteReference(unit);
+                        }
+                    }
+                }
+                //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+                //{
+                //    if (cre->IsInCombat())
+                //    {
+                //        //ch.PSendSysMessage("_evade(): %s's HostileRef is empty! Combatstop!", cre->GetName().c_str());
+                //        cre->ClearInCombat();
+                //    }
+                //}
+            }
+
+            Creature* m_botsPet = cre->GetBotsPet();
+            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
+            m_botsPet->DeleteThreatList();
+            HostileRefManager& mgr = m_botsPet->getHostileRefManager();
+            if (!mgr.isEmpty())
+            {
+                std::set<Unit*> Set;
+                HostileReference* ref = mgr.getFirst();
+                while (ref)
+                {
+                    if (ref->GetSource() && ref->GetSource()->GetOwner())
+                        Set.insert(ref->GetSource()->GetOwner());
+                    ref = ref->next();
+                }
+                for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = (*i);
+                    if (!unit->InSamePhase(me)) continue;
+                    if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        //ch.PSendSysMessage("_evade(): %s's hostile reference is removed from %s!", unit->GetName().c_str(), m_botsPet->GetName().c_str());
+                        mgr.deleteReference(unit);
+                    }
+                }
+            }
+            //if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+            //{
+            //    if (m_botsPet->IsInCombat())
+            //    {
+            //        //ch.PSendSysMessage("_evade(): %s's HostileRef is empty! Combatstop!", pet->GetName().c_str());
+            //        m_botsPet->ClearInCombat();
+            //    }
+            //}
+        }
+    }
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* /*caster*/, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            me->SetBotsPetDied();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType |= INHABIT_AIR;
+                //me->AddUnitMovementFlag(MOVEMENTFLAG_HOVER);
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+            }
+            else
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.25f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT)
+        {
+            shouldUpdateStats = true;
+        }
+        else
+        {
+            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+                auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+                doHealth = true;
+            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY ||
+                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+                doMana = true;
+        }
+    }
+}
+//Messed up
+//Hp + Mana update
+//target update
+//returns fake wait time between overall AI updates (if it is even understandable)
+uint8 bot_ai::GetWait()
+{
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+    CheckAuras(true);
+    //0 to 2 plus 1 for every 3 bots except first one
+    return (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+}
+//Damage Mods
+//1) Apply class-specified damage/crit chance/crit damage bonuses
+//2) Apply bot damage multiplier
+//3) Remove Creature damage multiplier (make independent from original config)
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& /*damageinfo*/) const
+{
+    //ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_melee/dmgmod_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(float(damage)*dmgmult_spell/dmgmod_spell);
+}
+void bot_ai::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    //Only for damage effects which can scale (TC check)
+    bool canEffectScale = false;
+    switch (spellInfo->Effects[effect_index].Effect)
+    {
+        case SPELL_EFFECT_SCHOOL_DAMAGE:
+        //case SPELL_EFFECT_DUMMY:
+        //case SPELL_EFFECT_POWER_DRAIN:
+        //case SPELL_EFFECT_HEALTH_LEECH:
+        case SPELL_EFFECT_HEAL:
+        case SPELL_EFFECT_WEAPON_DAMAGE:
+        //case SPELL_EFFECT_POWER_BURN:
+        //case SPELL_EFFECT_SCRIPT_EFFECT:
+        case SPELL_EFFECT_NORMALIZED_WEAPON_DMG:
+        //case SPELL_EFFECT_FORCE_CAST_WITH_VALUE:
+        //case SPELL_EFFECT_TRIGGER_SPELL_WITH_VALUE:
+        //case SPELL_EFFECT_TRIGGER_MISSILE_SPELL_WITH_VALUE:
+            canEffectScale = true;
+            break;
+        default:
+            break;
+    }
+    switch (spellInfo->Effects[effect_index].ApplyAuraName)
+    {
+        case SPELL_AURA_PERIODIC_DAMAGE:
+        //case SPELL_AURA_DUMMY:
+        //case SPELL_AURA_PERIODIC_HEAL:
+        //case SPELL_AURA_DAMAGE_SHIELD:
+        case SPELL_AURA_PROC_TRIGGER_DAMAGE:
+        //case SPELL_AURA_PERIODIC_LEECH:
+        //case SPELL_AURA_PERIODIC_MANA_LEECH:
+        //case SPELL_AURA_SCHOOL_ABSORB:
+        //case SPELL_AURA_PERIODIC_TRIGGER_SPELL_WITH_VALUE:
+            canEffectScale = true;
+            break;
+        default:
+            break;
+    }
+
+    if (!canEffectScale)
+        return;
+
+    ApplyClassDamageMultiplierEffect(spellInfo, effect_index, value);
+
+    if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED)
+        value = value*dmgmult_melee/dmgmod_melee;
+    else if (spellInfo->DmgClass == SPELL_DAMAGE_CLASS_NONE || spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MAGIC)
+        value = value*dmgmult_spell/dmgmod_spell;
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature)
+{
+    if (creature->IsInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (player == creature->GetBotOwner())
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage equipment...", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage roles...", GOSSIP_SENDER_ROLES, GOSSIP_ACTION_INFO_DEF + 1);
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Use ability...", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+    }
+
+    switch (creature->GetBotClass())
+    {
+        case CLASS_MAGE:
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need food", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need drink", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        default:
+            break;
+    }
+
+    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+    player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, creature->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+{
+    if (!IsInBotParty(player))
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            me->MonsterSay("...", LANG_UNIVERSAL, player->GetGUID());
+            break;
+        }
+        case 1: //return to main menu
+        {
+            return bot_minion_ai::OnGossipHello(player, creature);
+        }
+        case GOSSIP_SENDER_CLASS: //food/drink (classes: MAGE)
+        {
+            //Prevent high-leveled consumables for low-level characters
+            Unit* checker;
+            if (player->getLevel() < me->getLevel())
+                checker = player;
+            else
+                checker = me;
+
+            // Conjure Refreshment rank 1
+            uint32 food = InitSpell(checker, 42955);
+            bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+            if (!food)
+            {
+                if (!iswater)// Conjure Food rank 1
+                    food = InitSpell(checker, 587);
+                else// Conjure Water rank 1
+                    food = InitSpell(checker, 5504);
+            }
+            if (!food)
+            {
+                std::string errorstr = "I can't conjure ";
+                errorstr += iswater ? "water" : "food";
+                errorstr += " yet";
+                me->MonsterWhisper(errorstr.c_str(), player->GetGUID());
+                //player->PlayerTalkClass->ClearMenus();
+                //return OnGossipHello(player, me);
+                break;
+            }
+            SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+            Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+            SpellCastTargets targets;
+            targets.SetUnitTarget(player);
+            //TODO implement checkcast for bots
+            SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+            if (result != SPELL_CAST_OK)
+            {
+                foodspell->finish(false);
+                delete foodspell;
+                me->MonsterWhisper("I can't do it right now", player->GetGUID());
+            }
+            else
+            {
+                aftercastTargetGuid = player->GetGUID();
+                foodspell->prepare(&targets);
+                me->MonsterWhisper("Here you go...", player->GetGUID());
+            }
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show me your inventory", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+            //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Create itemset", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Main hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_MAINHAND);
+            if (CanUseOffHand())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Off-hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_OFFHAND);
+            if (CanUseRanged())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Ranged...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+
+            //armor
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Head...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HEAD);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shoulders...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_SHOULDERS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Chest...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_CHEST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Waist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WAIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Legs...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_LEGS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Feet...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FEET);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Wrist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WRIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Hands...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HANDS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BACK);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shirt...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BODY);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Neck...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_NECK);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (uint32 itemId = master->GetBotEquip(me, i))
+                {
+                    std::ostringstream msg;
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+                        _AddItemTemplateLink(master, proto, msg);
+                    else
+                        msg << "Unknown item";
+                    msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                    if (i < BOT_SLOT_RANGED && einfo && einfo->ItemEntry[i] == itemId)
+                        msg << " |cffe6cc80|h[!standard item!]|h|r";
+                    me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                }
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            if (uint32 itemId = master->GetBotEquip(me, slot))
+            {
+                std::ostringstream msg;
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+                    _AddItemTemplateLink(master, proto, msg);
+                else
+                    msg << "Unknown";
+
+                int8 id = 1;
+                EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+                if (slot < BOT_SLOT_RANGED && einfo && einfo->ItemEntry[slot] == itemId)
+                    msg << " |cffe6cc80|h[!standard item!]|h|r";
+
+                me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+            }
+
+            //break; //no break here - return to menu
+        }
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            std::set<uint32> itemList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                    if (CanEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF) && itemList.find(pItem->GetEntry()) == itemList.end())
+                        itemList.insert(pItem->GetEntry());
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                if (Bag* pBag = player->GetBagByPos(i))
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        if (Item* pItem = player->GetItemByPos(i, j))
+                            if (CanEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF) && itemList.find(pItem->GetEntry()) == itemList.end())
+                                itemList.insert(pItem->GetEntry());
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            std::ostringstream str;
+            str << "Equipped: ";
+            if (uint32 itemId = master->GetBotEquip(me, slot))
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+                    _AddItemTemplateLink(master, proto, str);
+                else
+                    str << "unknown item";
+
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+            }
+            else
+            {
+                str << "nothing";
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            //s2.2.1 add unequip option if have weapon
+            if (action - GOSSIP_ACTION_INFO_DEF <= BOT_SLOT_RANGED)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Use your old equipment", GOSSIP_SENDER_EQUIP_RESET, action);
+
+            //s2.2.2 add unequip option if have weapon
+            if (master->GetBotEquip(me, action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                ItemTemplate const* weap;
+                uint32 counter = 0;
+                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 4; //unequip, reset, current, back
+                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    weap = sObjectMgr->GetItemTemplate(*itr);
+                    if (weap)
+                    {
+                        std::ostringstream name;
+                        _AddItemTemplateLink(master, weap, name);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + weap->ItemId);
+                        ++counter;
+                    }
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip
+        {
+            if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_MAINHAND)
+            {
+                if (me->GetBotClass() == CLASS_WARRIOR || me->GetBotClass() == CLASS_DEATH_KNIGHT ||
+                    me->GetBotClass() == CLASS_ROGUE || (me->GetBotClass() == CLASS_SHAMAN && IsMelee()) ||
+                    me->GetBotClass() == CLASS_PALADIN || me->GetBotClass() == CLASS_HUNTER)
+                {
+                    me->MonsterSay("What, with my bare hands? No way", LANG_UNIVERSAL, player->GetGUID());
+                    break;
+                }
+            }
+            else if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_OFFHAND)
+            {
+                if (me->GetBotClass() == CLASS_ROGUE)
+                {
+                    me->MonsterSay("No. Never", LANG_UNIVERSAL, player->GetGUID());
+                    break;
+                }
+            }
+            else if (action - GOSSIP_ACTION_INFO_DEF == BOT_SLOT_RANGED)
+            {
+                if (me->GetBotClass() == CLASS_HUNTER)
+                {
+                    me->MonsterSay("Yeah, very funny...", LANG_UNIVERSAL, player->GetGUID());
+                    break;
+                }
+            }
+
+            if (Unequip(action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                me->MonsterSay("Hm...", LANG_UNIVERSAL, player->GetGUID());
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (ResetEquipment(action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                me->MonsterSay(RAND<char*>("Fine", "Very well", "Alright", "Yeah"), LANG_UNIVERSAL, player->GetGUID());
+            break;
+        }
+        //equips change s4b: Equip item
+        case GOSSIP_SENDER_EQUIP_BEGIN:     //1 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //2 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //3 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //4 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //5 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //6 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //7 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //8 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //9 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //10 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //11 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //12 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //13 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //15 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //17 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //18 - 1 neck
+        {
+            if (Equip(action - GOSSIP_ACTION_INFO_DEF, sender - GOSSIP_SENDER_EQUIP))
+                me->MonsterSay(RAND<char*>("Fine", "Very well", "Alright", "Yeah", "Good", "Okay"), LANG_UNIVERSAL, player->GetGUID());
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF);
+
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES: //ROLES 1: list
+        {
+            subMenu = true;
+
+            uint8 role = BOT_ROLE_TANK;
+
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + role + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+            {
+                uint32 spellId = GetSpell(basespell);
+                if (doCast(player, spellId))
+                {
+                    uint32 rec = sSpellMgr->GetSpellInfo(spellId)->GetRecoveryTime();
+                    rec = !rec ? 15000 : std::min<uint32>(rec, 90000);
+                    SetSpellCooldown(basespell, rec);
+                }
+            }
+
+            //break;
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                basespell = (*itr).first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, 0, false, 5000)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(GOSSIP_SERVE_MASTER, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        me->MonsterWhisper("Why am I trying to summon unknown pet!?", master->GetGUID());
+        return;
+    }
+    uint32 armor = 0;
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        me->MonsterWhisper("Failed to summon pet!", master->GetGUID());
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    stmt->setUInt32(0, originalentry);
+    stmt->setUInt8(1, mylevel);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt16();
+        uint32 mana = fields[1].GetUInt16();
+        armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt16();
+        uint32 agi = fields[4].GetUInt16();
+        uint32 sta = fields[5].GetUInt16();
+        uint32 inte = fields[6].GetUInt16();
+        uint32 spi = fields[7].GetUInt16();
+
+        m_botsPet->SetCreateHealth(hp);
+        m_botsPet->SetMaxHealth(hp);
+        m_botsPet->SetCreateMana(mana);
+        m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    }
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetUInt64Value(UNIT_FIELD_CREATEDBY, me->GetGUID());
+    m_botsPet->DeleteThreatList();
+    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    m_botsPet->AIM_Initialize();
+    m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    //petai->SetStats(mylevel, bot_pet_ai::GetPetType(m_botsPet), true);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+uint16 bot_ai::Rand() const
+{
+    return urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
+}
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return CLASS_MAGE;
+        default:
+            return CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
+    {
+        temptimer = GC_Timer;
+        if (doCast(me, PVPTRINKET))
+        {
+            pvpTrinket_cd = 120000; //2 minutes default pvp trinket CD
+            GC_Timer = temptimer;
+            return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (master->isDead())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (me->GetVictim())
+        return;
+    if (InDuel(attacker))
+        return;
+    bool byspell = false;
+    bool ranged = !IsMelee();
+    switch (me->GetBotClass())
+    {
+        case CLASS_DRUID:
+            byspell = GetBotStance() == CLASS_DRUID || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+        case CLASS_SHAMAN:
+            byspell = true;
+            break;
+        default:
+            break;
+    }
+    float maxdist = InitAttackRange(float(master->GetBotFollowDist()), ranged); //use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON; //reset AttackStart()
+    me->Attack(attacker, !ranged);
+}
+
+bool bot_minion_ai::CanUseOffHand() const
+{
+    //warriot can wield any offhand with titan's grip
+    if (me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60)
+        return true;
+
+    //no offhand: check we are using one-handed weapon in main hand
+    if (!me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0)))
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+                return true;
+    }
+    else if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1)))
+    {
+        //Now we have something in off-hand
+        //1 check if it is one-handed weapon
+        if (proto->Class == ITEM_CLASS_WEAPON &&
+            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+            return true;
+        //2 check of it is a shield
+        if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            return true;
+        //3 check of it is a 'held in off-hand' item
+        if (proto->InventoryType == INVTYPE_HOLDABLE)
+            return true;
+    }
+
+    //NO
+    return false;
+}
+
+bool bot_minion_ai::CanUseRanged() const
+{
+    return (me->GetBotClass() == CLASS_HUNTER/* || me->GetBotClass() == CLASS_ROGUE*/);
+    //return (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) != 0);
+}
+
+bool bot_minion_ai::CanEquip(ItemTemplate const* item, uint8 slot) const
+{
+    //prevent reequipping same items
+    if (item->ItemId == master->GetBotEquip(me, slot - 1))
+        return false;
+
+    //prevent equipping items with random properties (temp)
+    if (item->RandomProperty > 0 || item->RandomSuffix > 0)
+        //if (item->Quality >= ITEM_QUALITY_RARE)
+            return false;
+
+    //level requirements
+    if (me->getLevel() < item->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (!(item->AllowableClass & (1<<(me->GetBotClass()-1))))
+        return false;
+
+    //skip race requirements
+
+    if (item->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot > BOT_SLOT_RANGED)
+            return false;
+
+        if (slot == BOT_SLOT_OFFHAND && item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+            return false;
+
+        if (slot == BOT_SLOT_OFFHAND && me->GetBotClass() != CLASS_WARRIOR &&
+            me->GetBotClass() != CLASS_ROGUE && me->GetBotClass() != CLASS_HUNTER &&
+            me->GetBotClass() != CLASS_SHAMAN && me->GetBotClass() != CLASS_DEATH_KNIGHT)
+            return false;
+
+        if (slot == BOT_SLOT_MAINHAND && item->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+            me->GetBotClass() == CLASS_ROGUE)
+            return false;
+
+        if (/*proto->InventoryType == INVTYPE_THROWN ||*/
+            item->InventoryType == INVTYPE_RANGED ||
+            item->InventoryType == INVTYPE_RANGEDRIGHT)
+        {
+            return (slot == BOT_SLOT_RANGED && CanUseRanged());
+        }
+        else if (item->InventoryType == INVTYPE_2HWEAPON)
+        {
+            if (me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60)
+                return true;
+
+            if ((me->GetBotClass() == CLASS_MAGE || me->GetBotClass() == CLASS_PRIEST ||
+                me->GetBotClass() == CLASS_WARLOCK || me->GetBotClass() == CLASS_DRUID) &&
+                item->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                return false;
+
+            return (slot == BOT_SLOT_MAINHAND);
+        }
+        else if (item->InventoryType == INVTYPE_WEAPON ||
+            item->InventoryType == INVTYPE_WEAPONMAINHAND ||
+            item->InventoryType == INVTYPE_WEAPONOFFHAND)
+        {
+            return (slot == BOT_SLOT_MAINHAND ||
+                (slot == BOT_SLOT_OFFHAND && me->GetBotClass() != CLASS_PALADIN && CanUseOffHand()));
+        }
+    }
+    else if (item->Class == ITEM_CLASS_ARMOR)
+    {
+        switch (item->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                break;
+        }
+
+        if (item->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (slot == BOT_SLOT_OFFHAND)
+            {
+                return CanUseOffHand() &&
+                    (me->GetBotClass() == CLASS_WARRIOR ||
+                    me->GetBotClass() == CLASS_PALADIN ||
+                    me->GetBotClass() == CLASS_SHAMAN);
+            }
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_PLATE)
+        {
+            return (me->getLevel() >= 40 &&
+                (me->GetBotClass() == CLASS_WARRIOR ||
+                me->GetBotClass() == CLASS_DEATH_KNIGHT ||
+                me->GetBotClass() == CLASS_PALADIN));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MAIL)
+        {
+            if (me->GetBotClass() == CLASS_WARRIOR ||
+                me->GetBotClass() == CLASS_DEATH_KNIGHT ||
+                me->GetBotClass() == CLASS_PALADIN)
+                return true;
+
+            return (me->getLevel() >= 40 &&
+                (me->GetBotClass() == CLASS_SHAMAN ||
+                me->GetBotClass() == CLASS_HUNTER));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LEATHER)
+        {
+            return (me->GetBotClass() != CLASS_WARLOCK &&
+                me->GetBotClass() != CLASS_MAGE &&
+                me->GetBotClass() != CLASS_PRIEST);
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_CLOTH)
+        {
+            return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MISC)
+        {
+            if (item->InventoryType == INVTYPE_FEET && slot == BOT_SLOT_FEET)
+                return true;
+            if (item->InventoryType == INVTYPE_BODY && slot == BOT_SLOT_BODY)
+                return true;
+            if (item->InventoryType == INVTYPE_FINGER &&
+                (slot == BOT_SLOT_FINGER1 || slot == BOT_SLOT_FINGER2))
+                return true;
+            if (item->InventoryType == INVTYPE_TRINKET &&
+                (slot == BOT_SLOT_TRINKET1 || slot == BOT_SLOT_TRINKET2))
+                return true;
+            if (item->InventoryType == INVTYPE_NECK && slot == BOT_SLOT_NECK)
+                return true;
+            if (item->InventoryType == INVTYPE_HOLDABLE && slot == BOT_SLOT_OFFHAND)
+                return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LIBRAM)
+            return me->GetBotClass() == CLASS_PALADIN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_IDOL)
+            return me->GetBotClass() == CLASS_DRUID && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_TOTEM)
+            return me->GetBotClass() == CLASS_SHAMAN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_SIGIL)
+            return me->GetBotClass() == CLASS_DEATH_KNIGHT && slot == BOT_SLOT_RANGED;
+    }
+
+    return false;
+}
+
+bool bot_minion_ai::Unequip(uint8 slot)
+{
+    if (slot < BOT_SLOT_RANGED)
+    {
+        int8 id = 1;
+        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+        uint32 itemId = me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot);
+        if (!einfo || einfo->ItemEntry[slot] != me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot))
+        {
+            ItemPosCountVec dest;
+            uint32 no_space = 0;
+            InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+            if (msg != EQUIP_ERR_OK)
+            {
+                master->SendEquipError(msg, NULL, NULL, itemId);
+                return false;
+            }
+            Item* pItem = master->StoreNewItem(dest, itemId, true, 0);
+            if (!pItem)
+            {
+                master->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                return false;
+            }
+            master->SendNewItem(pItem, 1, true, false, false);
+        }
+
+        //only for non-standard items
+        if (!(einfo && einfo->ItemEntry[slot] == itemId))
+            RemoveItemBonuses(slot);
+
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), 2000); //without weapon
+        master->UpdateBotEquips(me, slot, 0);
+
+        if (slot + 1 == BOT_SLOT_OFFHAND)
+        {
+            if (me->CanDualWield())
+                me->SetCanDualWield(false);
+            if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else
+    {
+        uint32 itemId = master->GetBotEquip(me, slot);
+        if (itemId == 0)
+            return true; //nothing to unequip
+
+        ItemPosCountVec dest;
+        uint32 no_space = 0;
+        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+        if (msg != EQUIP_ERR_OK)
+        {
+            master->SendEquipError(msg, NULL, NULL, itemId);
+            return false;
+        }
+        Item* pItem = master->StoreNewItem(dest, itemId, true, 0);
+        if (!pItem)
+        {
+            master->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+            return false;
+        }
+        master->SendNewItem(pItem, 1, true, false, false);
+
+        RemoveItemBonuses(slot);
+
+        master->UpdateBotEquips(me, slot, 0);
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::Equip(uint32 itemId, uint8 slot)
+{
+    if (master->GetBotEquip(me, slot) == itemId)
+        return false;
+
+    if (!itemId)
+        return false;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return false;
+
+    if (slot < BOT_SLOT_RANGED)
+    {
+        int8 id = 1;
+        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+        if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot))
+        {
+            if (!Unequip(slot))
+            {
+                me->MonsterSay("You have no space for my current item", LANG_UNIVERSAL, master->GetGUID());
+                return false;
+            }
+        }
+
+        if (!einfo || einfo->ItemEntry[slot] != itemId)
+        {
+            if (!master->HasItemCount(itemId, 1))
+            {
+                std::ostringstream msg;
+                msg << "Cannot find ";
+                _AddItemTemplateLink(master, proto, msg);
+                msg << " (id: " << uint32(itemId) << ")!";
+                me->MonsterWhisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                return false;
+            }
+
+            master->DestroyItemCount(itemId, 1, true);
+        }
+
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, itemId);
+        me->SetAttackTime(WeaponAttackType(slot), einfo && einfo->ItemEntry[slot] == itemId ? me->GetCreatureTemplate()->baseattacktime : proto->Delay); //set attack speed
+        master->UpdateBotEquips(me, slot, itemId);
+
+        //only for non-standard items
+        if (!(einfo && einfo->ItemEntry[slot] == itemId))
+            ApplyItemBonuses(slot);
+
+        if (slot + 1 == BOT_SLOT_OFFHAND)
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (!me->CanDualWield())
+                    me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+        else if (slot + 1 == BOT_SLOT_MAINHAND && proto->InventoryType == INVTYPE_2HWEAPON &&
+            !(me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60))
+        {
+            //if have offhand unequip it
+            if (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+                Unequip(BOT_SLOT_OFFHAND - 1);
+        }
+    }
+    else
+    {
+        if (!Unequip(slot))
+        {
+            me->MonsterSay("You have no space for my current item", LANG_UNIVERSAL, master->GetGUID());
+            return false;
+        }
+
+        if (!master->HasItemCount(itemId, 1))
+        {
+            std::ostringstream msg;
+            msg << "Cannot find ";
+            _AddItemTemplateLink(master, proto, msg);
+            msg << " (id: " << uint32(itemId) << ")!";
+            me->MonsterWhisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+            return false;
+        }
+
+        master->DestroyItemCount(itemId, 1, true);
+
+        master->UpdateBotEquips(me, slot, itemId);
+        ApplyItemBonuses(slot);
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::ResetEquipment(uint8 slot)
+{
+    if (slot < BOT_SLOT_RANGED)
+    {
+        int8 id = 1;
+        EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+        if (!einfo || !einfo->ItemEntry[slot])
+            return Unequip(slot);
+
+        if (slot + 1 == BOT_SLOT_MAINHAND && !(me->GetBotClass() == CLASS_WARRIOR && me->getLevel() >= 60))
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[slot]))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON &&
+                    (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                    proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                    proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+                {
+                    if (!Unequip(BOT_SLOT_OFFHAND - 1))
+                        return false;
+                }
+            }
+        }
+
+        return Equip(einfo->ItemEntry[slot], slot);
+    }
+
+    return Unequip(slot);
+}
+
+void bot_minion_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    uint32 itemId = master->GetBotEquip(me, slot);
+    if (!itemId)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+
+    uint32 ssd_level = me->getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatMod[i] < 0)
+                continue;
+            statType = ssd->StatMod[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    for (uint8 i = 0; i != MAX_ITEM_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+        if (!spellData.SpellId)
+            continue;
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        if (spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+            continue;
+
+        for (uint8 j = 0; j != MAX_SPELL_EFFECTS; ++j)
+        {
+            if (spellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_SHIELD_BLOCKVALUE)
+                _stats[slot][ITEM_MOD_BLOCK_VALUE] += spellInfo->Effects[j].CalcValue();
+        }
+
+        if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+            continue;
+
+        bool exists = false;
+        for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
+        {
+            if (_ctc[j].first == spellInfo->Id)
+            {
+                exists = true;
+                break;
+            }
+        }
+        if (exists)
+            continue;
+
+        for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
+        {
+            if (_ctc[j].first == 0)
+            {
+                _ctc[j].first = spellInfo->Id;
+                _ctc[j].second = 0; //reset cd
+                break;
+            }
+        }
+    }
+
+    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] = proto->HolyRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] = proto->FireRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] = proto->NatureRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] = proto->FrostRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] = proto->ShadowRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] = proto->ArcaneRes;
+
+    if (proto->Class == ITEM_CLASS_WEAPON)
+        _stats[slot][BOT_ITEM_MOD_DAMAGE] = proto->Damage[0].DamageMin;
+    else if (proto->Class == ITEM_CLASS_ARMOR)
+        _stats[slot][BOT_ITEM_MOD_ARMOR] = proto->Armor;
+
+    if (proto->Block)
+        _stats[slot][ITEM_MOD_BLOCK_VALUE] += proto->Block;
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::RemoveItemBonuses(uint8 slot)
+{
+    uint32 itemId = master->GetBotEquip(me, slot);
+    if (!itemId)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    for (uint8 i = 0; i != MAX_ITEM_SPELLS; ++i)
+    {
+        if (uint32 spellId = proto->Spells[i].SpellId)
+        {
+            for (uint8 j = 0; j != MAX_BOT_CTC_SPELLS; ++j)
+            {
+                if (_ctc[j].first == spellId)
+                {
+                    _ctc[j].first = 0;
+                    break;
+                }
+            }
+        }
+    }
+
+    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] = 0;
+    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] = 0;
+
+    if (proto->Class == ITEM_CLASS_WEAPON)
+        _stats[slot][BOT_ITEM_MOD_DAMAGE] = 0;
+    else if (proto->Class == ITEM_CLASS_ARMOR)
+        _stats[slot][BOT_ITEM_MOD_ARMOR] = 0;
+
+    if (proto->Block)
+        _stats[slot][ITEM_MOD_BLOCK_VALUE] = 0;
+
+    shouldUpdateStats = true;
+}
+
+char const* bot_minion_ai::_getNameForSlot(uint8 slot) const
+{
+    switch (slot)
+    {
+        case BOT_SLOT_MAINHAND:
+            return "Main Hand Weapon";
+        case BOT_SLOT_OFFHAND:
+            return "Offhand Weapon";
+        case BOT_SLOT_RANGED:
+            return "Ranged Weapon";
+        case BOT_SLOT_HEAD:
+            return "Head";
+        case BOT_SLOT_SHOULDERS:
+            return "Shoulders";
+        case BOT_SLOT_CHEST:
+            return "Chest";
+        case BOT_SLOT_WAIST:
+            return "Waist";
+        case BOT_SLOT_LEGS:
+            return "Legs";
+        case BOT_SLOT_FEET:
+            return "Feet";
+        case BOT_SLOT_WRIST:
+            return "Wrist";
+        case BOT_SLOT_HANDS:
+            return "Hands";
+        case BOT_SLOT_BACK:
+            return "Back";
+        case BOT_SLOT_BODY:
+            return "Body";
+        case BOT_SLOT_FINGER1:
+            return "Finger1";
+        case BOT_SLOT_FINGER2:
+            return "Finger2";
+        case BOT_SLOT_TRINKET1:
+            return "Trinket1";
+        case BOT_SLOT_TRINKET2:
+            return "Trinket2";
+        case BOT_SLOT_NECK:
+            return "Neck";
+        default:
+            return "Unknown";
+    }
+}
+
+uint8 const bot_minion_ai::_onOffIcon(uint8 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+bool bot_minion_ai::CanHeal() const
+{
+    if (me->getPowerType() != POWER_MANA)
+        return false;
+
+    return
+        (me->GetBotClass() == CLASS_PRIEST || me->GetBotClass() == CLASS_DRUID ||
+        me->GetBotClass() == CLASS_SHAMAN || me->GetBotClass() == CLASS_PALADIN);
+}
+
+char const* bot_ai::GetRoleString(uint8 role) const
+{
+    switch (role)
+    {
+        case BOT_ROLE_NONE:
+            return "???";
+        case BOT_ROLE_TANK:
+            return "Tanking";
+        case BOT_ROLE_DPS:
+            return "DPS";
+        case BOT_ROLE_HEAL:
+            return "Heal";
+        //case BOT_ROLE_MELEE:
+        //    return "Melee";
+        case BOT_ROLE_RANGED:
+            return "Ranged";
+        default:
+        {
+            std::ostringstream str;
+            str << "role " << uint32(role);
+            return str.str().c_str();
+        }
+    }
+}
+
+void bot_ai::InitRoles()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_ROLES);
+    //"SELECT roles FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNC
+    stmt->setUInt32(0, master->GetGUIDLow());
+    stmt->setUInt32(1, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(me->GetBotClass()))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+        return;
+    }
+
+    Field* field = result->Fetch();
+    _roleMask = field[0].GetInt8();
+}
+
+void bot_ai::ToggleRole(uint8 role)
+{
+    if (roleTimer > 0)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+    //"UPDATE character_npcbot SET roles = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC
+    stmt->setUInt8(0, _roleMask);
+    stmt->setUInt32(1, master->GetGUIDLow());
+    stmt->setUInt32(2, me->GetEntry());
+    CharacterDatabase.Execute(stmt);
+
+    //Update passives
+    ApplyPassives(me->GetBotClass());
+}
+
+bool bot_ai::IsTank(Unit* unit) const
+{
+    if (!unit)
+        unit = me;
+
+    if (unit == me)
+        return (_roleMask & BOT_ROLE_TANK);
+
+    if (Creature* bot = unit->ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            return bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    if (Player* player = unit->ToPlayer())
+    {
+        if (Group* gr = player->GetGroup())
+        {
+            Group::MemberSlotList const& slots = gr->GetMemberSlots();
+            for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                if (itr->guid == player->GetGUID())
+                    return (*itr).flags & MEMBER_FLAG_MAINTANK;
+        }
+    }
+
+    return false;
+}
+
+//UTILITIES
+void bot_ai::_AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ":";
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+
+void bot_ai::_AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ":";
+
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+    //gems (3)
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+        if (!eId)
+            continue;
+
+        SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(eId);
+        if (!enchant) continue;
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 1: g1 = enchant->GemID;    break;
+            case 2: g2 = enchant->GemID;    break;
+            case 3: g3 = enchant->GemID;    break;
+        }
+    }
+    str << g1 << ":" << g2 << ":" << g3 << ":";
+
+    //temp enchantment, bonus enchantment and prismatic enchantment (3 + 1 unk)
+    str << "0:0:0:0:";
+
+    //reporter level
+    str << "0";
+
+    //name
+    std::string name = proto->Name1;
+    _LocalizeItem(forPlayer, name, proto->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+}
+
+void bot_ai::_AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+
+void bot_ai::_AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+
+void bot_ai::_AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cffffffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+
+void bot_ai::_AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUIDLow() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->name[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+//Advanced
+void bot_ai::BotSpeak(std::string const& text, uint8 msgtype, uint32 language, uint64 speaker, uint64 receiver)
+{
+    if (msgtype == CHAT_MSG_WHISPER)
+        language = LANG_UNIVERSAL;
+
+    std::string _text(text);
+    //sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    //BuildPlayerChat(&data, msgType, _text, language);
+    data << uint8(msgtype);
+    data << uint32(language);
+    data << uint64(speaker);
+    data << uint32(0);                 // constant unknown time
+    data << uint64(speaker);
+    data << uint32(text.length() + 1);
+    data << text;
+    data << uint8(0);
+
+    if (msgtype == CHAT_MSG_WHISPER)
+    {
+        ASSERT(receiver || "BotSpeak(): no receiver for whisper!");
+        ASSERT(IS_PLAYER_GUID(receiver) || "BotSpeak(): whisper receiver is not a player!");
+
+        if (Player* res = ObjectAccessor::FindPlayer(receiver))
+            res->GetSession()->SendPacket(&data);
+    }
+    else
+    {
+        if (Unit* snd = ObjectAccessor::FindUnit(speaker))
+        {
+            float dist = std::max<float>(sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL) * 0.5f);
+            Trinity::MessageDistDeliverer notifier(snd, &data, dist, false);
+            snd->VisitNearbyWorldObject(dist, notifier);
+        }
+    }
+    //SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..a8c93e8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,605 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+
+struct PlayerClassLevelInfo;
+struct BotClassLevelInfo
+{
+    BotClassLevelInfo() : basehealth(0), basemana(0) { }
+    uint32 basehealth;
+    uint32 basemana;
+};
+
+enum CommonValues
+{
+//MISC
+    BOT_ENTRY_BEGIN                     = 70001,
+    BOT_ENTRY_END                       = 70248,
+    BOT_ICON_ON                         = 9,//GOSSIP_ICON_BATTLE,
+    BOT_ICON_OFF                        = 7,//GOSSIP_ICON_TALK,
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"Uses a Holy elixir to heal the caster for 32000"
+    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
+    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
+    EAT                                 = 66478,//"Restores Health"
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    RATIONS_CD                          = 1000,//update rations every X milliseconds
+//COMMON PASSIVES
+  //1) "Increase(d) @whatever"
+    //SPELL_BONUS_10                      = 33021,//10spp
+    SPELL_BONUS_50                      = 45011,//50spp
+    SPELL_BONUS_150                     = 28141,//150spp
+    SPELL_BONUS_250                     = 69709,//250spp
+    FIREDAM_86                          = 33816,//86 fire spp
+    MANAREGEN45                         = 35867,//45 mp5
+    MANAREGEN100                        = 45216,//100 mp5
+    SPELL_PEN_5                         = 31921,//5 sppen
+    SPELL_PEN_20                        = 26283,//20 sppen
+  //2) Talents
+    HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
+    HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank 2 10% melee haste, bonus for rend (warriors only)
+    HASTE3   /*       "Haste"       */  = 29418,//rank 0 10% increased ranged attack speed
+    CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit
+    HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
+    DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
+    PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
+    BLOCK/*zzOLD Shield Specialization*/= 16253,//rank 1 5% block 10% amount, 3.3.5 & 4.3.4 deprecated
+    PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit
+    DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 6% reduced all damage taken
+    EXPERTISE /*Weapon Expertise-rogue*/= 30919,//rank 1 5 expertise
+    EXPERTISE2/*Weapon Expertise-rogue*/= 30920,//rank 2 10 expertise
+  //3) Pet/Special
+    THREAT   /*Tank Class Passive*/     = 57339,//+43% threat
+    BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    BOAR     /*Boar's Speed - pet*/     = 19596,//rank 1 +30% movement speed
+    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+    DEFENSIVE_STANCE_PASSIVE            = 7376, //+ 400% threat 10% damage reduction
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 2279, //"I live only to serve the master."
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES,
+    GOSSIP_SENDER_ROLES_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON MOUNTS SPELLS
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827
+};
+
+enum BotRoles
+{
+    BOT_ROLE_NONE                       = 0x00,
+    BOT_ROLE_TANK                       = 0x01,
+    BOT_ROLE_DPS                        = 0x02,
+    BOT_ROLE_HEAL                       = 0x04,
+    BOT_ROLE_RANGED                     = 0x08,
+    BOT_MAX_ROLE                        = 0x10
+};
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = 21,
+    WARRIOR_DEFENSIVE_STANCE            = 22,
+    WARRIOR_BERSERKER_STANCE            = 23,
+    DEATH_KNIGHT_BLOOD_PRESENCE         = 24,
+    DEATH_KNIGHT_FROST_PRESENCE         = 25,
+    DEATH_KNIGHT_UNHOLY_PRESENCE        = 26,
+    DRUID_BEAR_FORM                     = 27,
+    DRUID_CAT_FORM                      = 28,
+    //DRUID_TRAVEL_FORM                 = 29,   //NYI
+    //DRUID_FLY_FORM                    = 30,   //NYI
+    DRUID_MOONKIN_FORM                = 31      //NYI
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+    PET_TYPE_FIRE_ELEMENTAL,
+    PET_TYPE_EARTH_ELEMENTAL,
+//Hunter
+    PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 70247
+    //PET_SUCCUBUS                =
+};
+
+enum HunterBotPets
+{
+    PET_VULTURE                 = 70248
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860
+};
+
+enum BotEquipSlot
+{
+    BOT_SLOT_NONE               = 0,
+    BOT_SLOT_MAINHAND           = 1,
+    BOT_SLOT_OFFHAND            = 2,
+    BOT_SLOT_RANGED             = 3,
+    BOT_SLOT_HEAD               = 4,
+    BOT_SLOT_SHOULDERS          = 5,
+    BOT_SLOT_CHEST              = 6,
+    BOT_SLOT_WAIST              = 7,
+    BOT_SLOT_LEGS               = 8,
+    BOT_SLOT_FEET               = 9,
+    BOT_SLOT_WRIST              = 10,
+    BOT_SLOT_HANDS              = 11,
+    BOT_SLOT_BACK               = 12,
+    BOT_SLOT_BODY               = 13,
+    BOT_SLOT_FINGER1            = 14,
+    BOT_SLOT_FINGER2            = 15,
+    BOT_SLOT_TRINKET1           = 16,
+    BOT_SLOT_TRINKET2           = 17,
+    BOT_SLOT_NECK               = 18,
+    BOT_MAX_SLOTS,
+    BOT_INVENTORY_SIZE = BOT_MAX_SLOTS - 1
+};
+
+enum BotStatTypes
+{
+    //ItemProtoType.h
+    //ITEM_MOD_MANA                     = 0,
+    //ITEM_MOD_HEALTH                   = 1,
+    //ITEM_MOD_AGILITY                  = 3,
+    //ITEM_MOD_STRENGTH                 = 4,
+    //ITEM_MOD_INTELLECT                = 5,
+    //ITEM_MOD_SPIRIT                   = 6,
+    //ITEM_MOD_STAMINA                  = 7,
+    //ITEM_MOD_DEFENSE_SKILL_RATING     = 12,
+    //ITEM_MOD_DODGE_RATING             = 13,
+    //ITEM_MOD_PARRY_RATING             = 14,
+    //ITEM_MOD_BLOCK_RATING             = 15,
+    //ITEM_MOD_HIT_MELEE_RATING         = 16,
+    //ITEM_MOD_HIT_RANGED_RATING        = 17,
+    //ITEM_MOD_HIT_SPELL_RATING         = 18,
+    //ITEM_MOD_CRIT_MELEE_RATING        = 19,
+    //ITEM_MOD_CRIT_RANGED_RATING       = 20,
+    //ITEM_MOD_CRIT_SPELL_RATING        = 21,
+    //ITEM_MOD_HIT_TAKEN_MELEE_RATING   = 22,
+    //ITEM_MOD_HIT_TAKEN_RANGED_RATING  = 23,
+    //ITEM_MOD_HIT_TAKEN_SPELL_RATING   = 24,
+    //ITEM_MOD_CRIT_TAKEN_MELEE_RATING  = 25,
+    //ITEM_MOD_CRIT_TAKEN_RANGED_RATING = 26,
+    //ITEM_MOD_CRIT_TAKEN_SPELL_RATING  = 27,
+    //ITEM_MOD_HASTE_MELEE_RATING       = 28,
+    //ITEM_MOD_HASTE_RANGED_RATING      = 29,
+    //ITEM_MOD_HASTE_SPELL_RATING       = 30,
+    //ITEM_MOD_HIT_RATING               = 31,
+    //ITEM_MOD_CRIT_RATING              = 32,
+    //ITEM_MOD_HIT_TAKEN_RATING         = 33,
+    //ITEM_MOD_CRIT_TAKEN_RATING        = 34,
+    //ITEM_MOD_RESILIENCE_RATING        = 35,
+    //ITEM_MOD_HASTE_RATING             = 36,
+    //ITEM_MOD_EXPERTISE_RATING         = 37,
+    //ITEM_MOD_ATTACK_POWER             = 38,
+    //ITEM_MOD_RANGED_ATTACK_POWER      = 39,
+    ////ITEM_MOD_FERAL_ATTACK_POWER       = 40, not in 3.3
+    //ITEM_MOD_SPELL_HEALING_DONE       = 41,                 // deprecated
+    //ITEM_MOD_SPELL_DAMAGE_DONE        = 42,                 // deprecated
+    //ITEM_MOD_MANA_REGENERATION        = 43,
+    //ITEM_MOD_ARMOR_PENETRATION_RATING = 44,
+    //ITEM_MOD_SPELL_POWER              = 45,
+    //ITEM_MOD_HEALTH_REGEN             = 46,
+    //ITEM_MOD_SPELL_PENETRATION        = 47,
+    //ITEM_MOD_BLOCK_VALUE              = 48,
+    //END ItemProtoType.h
+
+    BOT_ITEM_MOD_DAMAGE                 = MAX_ITEM_MOD,
+    BOT_ITEM_MOD_ARMOR,
+    BOT_ITEM_MOD_RESIST_HOLY,
+    BOT_ITEM_MOD_RESIST_FIRE,
+    BOT_ITEM_MOD_RESIST_NATURE,
+    BOT_ITEM_MOD_RESIST_FROST,
+    BOT_ITEM_MOD_RESIST_SHADOW,
+    BOT_ITEM_MOD_RESIST_ARCANE,
+    BOT_ITEM_MOD_EX,
+    MAX_BOT_ITEM_MOD
+};
+
+#define MAX_BOT_CTC_SPELLS              1//(MAX_EQUIPMENT_ITEMS * MAX_ITEM_SPELLS)
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //Player* GetMaster() const { return master; }
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
+        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
+        bool IsInBotParty(Unit* unit) const;
+        bool CanBotAttack(Unit* target, int8 byspell = 0) const;
+        bool InDuel(Unit* target) const;
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        inline void SendPartyEvadeAbort() const;
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        inline float GetManaRegen() const { return regen_mp5; }
+        inline float GetHitRating() const { return hit; }
+        inline int32 GetSpellPower() const { return m_spellpower; }
+        inline uint8 GetHaste() const { return haste; }
+        inline uint32 GetShieldBlockValue() const { return m_block; }
+        virtual uint8 GetBotStance() const { return 0; }
+        inline uint8 GetBotRoles() const { return _roleMask; }
+        inline bool HasRole(uint8 role) const { return _roleMask & role; }
+        void ToggleRole(uint8 role);
+        char const* GetRoleString(uint8 role) const;
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+        void ApplyPassives(uint8 botOrPetType) const;
+
+        virtual void RemoveItemBonuses(uint8 /*slot*/) {}
+        virtual void ApplyItemBonuses(uint8 /*slot*/) {}
+
+        static inline bool CCed(Unit* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && target->HasUnitState(UNIT_STATE_ROOT)) : true;
+        }
+
+        virtual bool CanUseOffHand() const { return false; }
+        virtual bool CanUseRanged() const { return false; }
+        virtual bool CanEquip(ItemTemplate const* /*item*/, uint8 /*slot*/) const { return false; }
+        virtual bool Unequip(uint8 /*slot*/) { return false; }
+        virtual bool Equip(uint32 /*itemId*/, uint8 /*slot*/) { return false; }
+        virtual bool ResetEquipment(uint8 /*slot*/) { return false; }
+
+        static void BotSpeak(std::string const& text, uint8 msgtype, uint32 language, uint64 sender, uint64 receiver);
+
+    protected:
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true, uint32 forcedTime = 0) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+
+        void InitRoles();
+        bool IsTank(Unit* unit = NULL) const;
+
+        bool HasAuraName(Unit* unit, uint32 spellId, uint64 casterGuid = 0, bool exclude = false) const;
+        bool RefreshAura(uint32 spell, int8 count = 1) const;
+        bool CheckAttackTarget(uint8 botOrPetType);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, uint64 originalCaster = 0);
+        SpellCastResult CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
+        virtual void removeFeralForm(bool /*force*/ = false, bool /*init*/ = true, uint32 /*diff*/ = 0) {}
+
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        inline bool IsMeleeClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
+        inline bool IsTankingClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
+        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCasted(false, false, true)); }
+
+        void GetInPosition(bool force = false, Unit* newtarget = NULL, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+        void CheckAttackState();
+        inline virtual void Evade() {}
+
+        //virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const {}
+        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        virtual void CheckAuras(bool /*force*/ = false) {}
+        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        virtual void InitSpells() {}
+        virtual void InitPowers() {}
+        virtual void ApplyClassPassives() {}
+        virtual void _OnHealthUpdate() const = 0;
+        virtual void _OnManaUpdate(bool /*shapeshift*/ = false) = 0;
+        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
+
+        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
+        //virtual void CommonTimers(uint32 diff) = 0;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        virtual bool IsMelee() const { return HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED); }
+        virtual bool CanHeal() const { return false; }
+
+        uint8 GetWait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        uint16 Rand() const;
+        static inline uint32 GetLostHP(Unit* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static inline uint8 GetManaPCT(Unit* hTarget) { if (!hTarget || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100; return (hTarget->GetPower(POWER_MANA)*100/(hTarget->GetMaxPower(POWER_MANA) + 1)); }
+
+        typedef std::set<Unit*> AttackerSet;
+        typedef UNORDERED_MAP<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
+        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotCTCSpell;
+
+        BotStat _stats[BOT_MAX_SLOTS - 1];
+        BotCTCSpell _ctc[MAX_BOT_CTC_SPELLS];
+        uint32 CalcCTC(uint32 /*spellId*/) const { return 8; } //placeholder
+
+        //utilities
+        void _AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const;
+        void _AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str) const;
+        void _AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const;
+
+        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotSpell;
+        typedef UNORDERED_MAP<uint32 /*spellId_1*/, BotSpell /*spell*/> BotSpellMap;
+
+        BotSpellMap const& GetSpellMap() const { return spells; }
+
+        Player* master;
+        Unit* opponent;
+        CommandStates m_botCommandState;
+        SpellInfo const* m_botSpellInfo;
+        Position pos, attackpos;
+        float stat, atpower, maxdist, regen_mp5, hit,
+            ap_mod, spp_mod, crit_mod;
+        uint64 aftercastTargetGuid;
+        int32 cost, value, sppower, m_spellpower, m_expertise, m_spellpen;
+        uint32 GC_Timer, temptimer, checkAurasTimer, roleTimer, wait, currentSpell, tempMana, m_block;
+        uint8 clear_cd, haste, healTargetIconFlags;
+        bool doHealth, doMana, shouldUpdateStats;
+
+    private:
+        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
+        bool _hasAuraName(Unit* unit, const std::string spell, uint64 casterGuid = 0, bool exclude = false) const;
+        void _listAuras(Player* player, Unit* unit) const;
+        static inline float _getAttackDistance(float distance) { return distance > 0.f ? distance*0.72 : 0.f; }
+
+        BotSpellMap spells;
+        uint8 _roleMask;
+        float dmgmult_melee, dmgmult_spell;
+        float dmgmod_melee, dmgmod_spell;
+        uint64 m_TankGuid;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        void SummonBotsPet(uint32 entry);
+        inline bool IAmDead() const { return (!master || me->isDead()); }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
+        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force, bool shapeshift = false);
+        virtual uint8 GetBotStance() const { return me->GetBotClass(); }
+
+        static bool OnGossipHello(Player* player, Creature* creature);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+
+        void InitSpells() {}
+        void InitPowers() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+
+        void RemoveItemBonuses(uint8 slot);
+        void ApplyItemBonuses(uint8 slot);
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
+
+        bool CanUseOffHand() const;
+        bool CanUseRanged() const;
+        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
+        bool Unequip(uint8 slot);
+        bool Equip(uint32 itemId, uint8 slot);
+        bool ResetEquipment(uint8 slot);
+
+        bool CanHeal() const;
+
+    protected:
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
+        void RezGroup(uint32 REZZ, Player* gPlayer);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force ||
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        inline void Evade() { _evade(); }
+
+        virtual void BreakCC(uint32 diff);
+
+        void CommonTimers(uint32 diff)
+        {
+            if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
+            if (Potion_cd > diff)           Potion_cd -= diff;
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+            if (evade_cd != 0)              --evade_cd;
+
+            if (mana_cd > diff)             mana_cd -= diff;
+            else if (mana_cd > 0)           mana_cd = 0;
+            if (health_cd > diff)           health_cd -= diff;
+            else if (health_cd > 0)         health_cd = 0;
+
+            if (roleTimer > diff)           roleTimer -= diff;
+            else if (roleTimer > 0)         roleTimer = 0;
+
+            for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+            {
+                if (_ctc[i].second > diff)  _ctc[i].second -= diff;
+                else                        _ctc[i].second = 0;
+            }
+        }
+
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, bool isFriend = false, uint32 spellId = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL, float splashdist = 4) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist = 10, float mindist = 0, bool forCC = false) const;
+
+        uint32 Potion_cd;
+
+    private:
+        bool _canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
+        void _getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
+        void _calculatePos(Position& pos);
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        void _evade();
+        char const* _getNameForSlot(uint8 slot) const;
+        uint8 const _onOffIcon(uint8 role) const;
+        //BotClassLevelInfo classinfo;
+        PlayerClassLevelInfo* _classinfo;
+        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
+        uint32 mana_cd, health_cd, pvpTrinket_cd;
+        uint8 rezz_cd, evade_cd;
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force);
+
+        static uint8 GetPetType(Creature* pet);
+        static uint8 GetPetClass(Creature* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        //debug
+        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
+
+        void InitSpells() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+    protected:
+        void CommonTimers(uint32 diff)
+        {
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (roleTimer > diff)           roleTimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+        }
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 0000000..343bc68
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,1698 @@
+#include "bot_ai.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Death Knight NpcBot by Graff onlysuffering@gmail.com
+Complete - around 55%
+Note: Rune system adapted from TC
+TODO: REMEMBER ALREADY DK HAS MINIMUM LEVEL 55!
+*/
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    uint32 Cooldown;
+    //AuraEffect const* ConvertAura;
+};
+
+struct BotRunes
+{
+    BotRuneInfo runes[MAX_RUNES];
+    //uint8 runeState;          //UNUSED
+    //uint8 lastUsedRune;       //UNUSED
+
+    //void SetRuneState(uint8 index, bool set = true)
+    //{
+    //    if (set)
+    //        runeState |= (1 << index);    // usable
+    //    else
+    //        runeState &= ~(1 << index);   // on cooldown
+    //}
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct death_knight_botAI : public bot_minion_ai
+    {
+        death_knight_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_DEATH_KNIGHT) != SPELL_CAST_OK)
+                return false;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            int32 runecost[NUM_RUNE_TYPES];
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                runecost[i] = 0;
+
+            if (!triggered)
+            {
+                if (!HaveRunes(spellInfo, runecost))
+                    return false;
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result)
+            {
+                //std::ostringstream str;
+                //str << "Casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+                //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+                //Set cooldown for runes
+                if (!triggered)
+                {
+                    SpendRunes(runecost);
+                    ////debug
+                    //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                    //    if (runecost[i])
+                    //        TC_LOG_FATAL("entities.player", "doCast():: DK bot %s has casted spell %u (%s) without %u rune(s) (type %u)!",
+                    //            me->GetName().c_str(), spellId, spellInfo->SpellName[0], runecost[i], i);
+                }
+                //runic power gain: all dk spells are instant but some have no unit target so
+                //we gain runic power here instead of SpellHitTarget()
+                if (SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID))
+                    if (int32 rp = int32(src->runePowerGain * runicpowerIncomeMult))
+                        me->ModifyPower(POWER_RUNIC_POWER, int32(rp));
+            }
+
+            return result;
+        }
+
+        bool HaveRunes(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            CalcRuneCost(spellInfo, runecost);
+
+            if (runecost[RUNE_DEATH] != 0 && runecost[RUNE_DEATH] > GetDeathRunesCount())
+                return false;
+
+            return true;
+        }
+
+        void CalcRuneCost(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src)
+                return;
+
+            if (src->NoRuneCost())
+                return;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runecost[i] = src->RuneCost[i];
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes.runes[i].BaseRune;
+                if (_runes.runes[i].CurrentRune == rune && _runes.runes[i].Cooldown == 0 && runecost[rune] > 0)
+                    runecost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runecost[i] > 0)
+                    runecost[RUNE_DEATH] += runecost[i];
+
+            ////restore cost to allow cooldown set
+            //for (uint8 i = 0; i != RUNE_DEATH; ++i)
+            //    runecost[i] = src->RuneCost[i];
+        }
+
+        int32 GetDeathRunesCount() const
+        {
+            int32 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].CurrentRune == RUNE_DEATH && _runes.runes[i].Cooldown == 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].BaseRune == runetype && _runes.runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        void SpendRunes(int32* runecost)
+        {
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            {
+                if (runecost[i] <= 0)
+                    continue;
+
+                for (uint8 j = 0; j != MAX_RUNES && runecost[i] > 0; ++j)
+                {
+                    if (SpendRune(i))
+                        runecost[i]--;
+                }
+            }
+
+            if (GetCooledRunesCount(RUNE_BLOOD) > 1)
+            {
+                me->CastSpell(me, BLADE_BARRIER_AURA, true);
+            }
+        }
+
+        bool SpendRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].CurrentRune == runetype && _runes.runes[i].Cooldown == 0)
+                {
+                    _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                    //_runes.lastUsedRune = _runes.runes[i].CurrentRune;        //UNUSED
+                    //_runes.SetRuneState(i, false);                            //UNUSED
+                    //DK receives rune regen bonus from mana regen
+                    uint32 cooldown = RUNE_BASE_COOLDOWN - std::min<uint32>(uint32(GetManaRegen() * 10), RUNE_BASE_COOLDOWN);
+                    _runes.runes[i].Cooldown = cooldown;
+                    //std::ostringstream str;
+                    //str << "Spent rune " << uint32(i) << " (type: " << uint32(runetype) << ')';
+                    //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        bool HaveRune(uint8 runetype) const
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if ((_runes.runes[i].CurrentRune == runetype || _runes.runes[i].CurrentRune == RUNE_DEATH) &&
+                    _runes.runes[i].Cooldown == 0)
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void ConvertRune(uint8 runetype, uint8 count)
+        {
+            if (runetype == RUNE_DEATH)
+                return;
+
+            uint8 failcount = 0;
+            for (uint8 i = 0; i != MAX_RUNES && count > 0; ++i)
+            {
+                if (_runes.runes[i].BaseRune == runetype)
+                {
+                    if (_runes.runes[i].CurrentRune == RUNE_DEATH)
+                    {
+                        ++failcount;
+                        continue;
+                    }
+
+                    if (_runes.runes[i].Cooldown > 3000)
+                        _runes.runes[i].Cooldown -= 3000;
+
+                    _runes.runes[i].CurrentRune = RUNE_DEATH;
+                    --count;
+                }
+            }
+
+            if (!count && !failcount)
+                return;
+
+            //std::ostringstream str;
+            //str << "Failed to convert rune of type: " << uint32(runetype) << ")!";
+            //me->MonsterWhisper(str.str().c_str(), master->GetGUID());
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].Cooldown = 0;
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void InitRunes()
+        {
+            //_runes.runeState = 0;                   //UNUSED
+            //_runes.lastUsedRune = RUNE_BLOOD;       //UNUSED
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].BaseRune = runeSlotTypes[i];
+                _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                _runes.runes[i].Cooldown = 0;
+                //_runes.runes[i].ConvertAura = NULL; //UNUSED
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].Cooldown <= diff)
+                {
+                    _runes.runes[i].Cooldown = 0;
+                    //_runes.SetRuneState(i, true);     //UNUSED
+                }
+                else
+                    _runes.runes[i].Cooldown -= diff;
+            }
+        }
+
+        void modpower(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && runicpower < uint32(abs(mod)))
+            {
+                //debug set runic power to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                runicpower = mod ? mod * 10 : 0;
+            else
+                runicpower += mod * 10;
+
+            me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        uint32 getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            return runicpower;
+        }
+
+        uint8 GetBotStance() const { return Presence; }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void KilledUnit(Unit*) { }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRune(RUNE_FROST)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK) && me->GetDistance(master) < 50))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = NULL;
+
+            if (master->IsAlive() && IsMeleeClass(master->getClass()) && master->IsInCombat() &&
+                GetHealthPCT(master) > 80 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true))
+            {
+                if (Unit* u = master->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = master;
+            }
+
+            if (!target && IsMeleeClass(me->GetBotClass()) && GetHealthPCT(me) > 80 &&
+                me->getAttackers().empty() && !CCed(me, true))
+            {
+                if (Unit* u = me->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = me;
+            }
+
+            if (!target)
+            {
+                Group* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == master) continue;
+                        if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+                        if (!IsMeleeClass(tPlayer->getClass()) || !tPlayer->IsInCombat()) continue;
+                        if (GetHealthPCT(tPlayer) < 80 || me->GetDistance(tPlayer) > 30) continue;
+                        if (!tPlayer->getAttackers().empty() || CCed(tPlayer, true)) continue;
+                        if (Unit* u = tPlayer->GetVictim())
+                        {
+                            if (u->GetHealth() > (me->GetMaxHealth() * 2) / 3)
+                            {
+                                target = tPlayer;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                {
+                    me->MonsterWhisper("Hysteria on You!", target->GetGUID());
+                    SetSpellCooldown(HYSTERIA_1, 90000); //1.5 min for player
+                }
+                else
+                    SetSpellCooldown(HYSTERIA_1, 30000); //30 sec for bot
+
+                GC_Timer = 800;
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 2000); //fail
+        }
+
+        void CheckAntiMagicShell(uint32 diff)
+        {
+            if (!IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) || GetHealthPCT(me) > 55 ||
+                getpower() < 200 || IsCasting() || Rand() > 50)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+            uint8 count = 0;
+
+            for (AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+            {
+                if (!(*itr) || !(*itr)->IsAlive()) continue;
+                if (Spell* spell = (*itr)->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->m_targets.GetUnitTargetGUID() == me->GetGUID())
+                    {
+                        if ((*itr)->ToCreature() && (*itr)->ToCreature()->isWorldBoss())
+                        {
+                            cast = true;
+                            break;
+                        }
+
+                        if (++count >= 3)
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (cast)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                {
+                    SetSpellCooldown(ANTI_MAGIC_SHELL_1, 30000); //30 sec for bot
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(ANTI_MAGIC_SHELL_1, 1500); //fail
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30) //no GCD
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (Presence == newpresence)
+            {
+                presencetimer = 500;
+                return;
+            }
+
+            Presence = newpresence;
+
+            if (Presence == DEATH_KNIGHT_FROST_PRESENCE && HaveRune(RUNE_FROST))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, FROST_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+            else if (Presence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRune(RUNE_BLOOD))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOOD_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+
+            presencetimer = 500; //fail
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) &&/* Rand() < 75 &&*/
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                {
+                    SetSpellCooldown(LICHBORNE_1, 60000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+
+            if (me->getPowerType() != POWER_RUNIC_POWER)
+                InitPowers();
+
+            if (runicpowertimer <= diff)
+            {
+                if (!me->IsInCombat())
+                {
+                    if (getpower() > uint32(30 * runicpowerLossMult))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower - uint32(30 * runicpowerLossMult)); //-3 runic power every 2 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, 0);
+                }
+                runicpowertimer = 2000;
+            }
+            if (runicpowertimer2 <= diff)
+            {
+                if (me->IsInCombat())
+                {
+                    if (getpower() < me->GetMaxPower(POWER_RUNIC_POWER))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower + uint32(20 * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                }
+                runicpowertimer2 = 5000;
+            }
+
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckPresence(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff, false, (me->IsInCombat() ? 45000 : 0)) && Rand() < 30 &&
+                (me->IsInCombat() || (me->GetDistance(master) < 28 && master->IsWithinLOSInMap(me))))
+            {
+                Aura* horn = master->GetAura(GetSpell(HORN_OF_WINTER_1));
+                if (!horn || horn->GetDuration() < 5000)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                    {
+                        SetSpellCooldown(HORN_OF_WINTER_1, 60000);
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRune(RUNE_UNHOLY) && Rand() < 25)
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || (!me->IsInCombat() && bone->GetDuration() < 60000))
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                    {
+                        SetSpellCooldown(BONE_SHIELD_1, 30000);
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(BONE_SHIELD_1, 1000); //fail
+            }
+
+            if (me->IsInCombat())
+            {
+                //ICEBOUND FORTITUDE
+                if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && getpower() >= 200 &&
+                    GetHealthPCT(me) < std::min<uint32>(85, 45 + uint8(me->getAttackers().size()) * 7) &&
+                    Rand() < 40 + IsTank() * 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                    {
+                        GC_Timer = temptimer;
+                        SetSpellCooldown(ICEBOUND_FORTITUDE_1, 90000);
+                    }
+                }
+
+                CheckAntiMagicShell(diff);
+                CheckHysteria(diff);
+            }
+
+            if (!CheckAttackTarget(CLASS_DEATH_KNIGHT))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //SELFHEAL
+
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff) && GetHealthPCT(me) < 40 && Rand() < 50)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        SetSpellCooldown(EMPOWER_RUNE_WEAPON_1, 60000);
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                {
+                    SetSpellCooldown(RUNE_TAP_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 26/* && Rand() < 75*/)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false, 40000))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        SetSpellCooldown(EMPOWER_RUNE_WEAPON_1, 60000);
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                {
+                    SetSpellCooldown(VAMPIRIC_BLOOD_1, 40000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //END SELFHEAL
+
+            //MARK OF BLOOD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && HaveRune(RUNE_BLOOD) &&
+                u && GetHealthPCT(u) < 85 && opponent->GetHealth() > u->GetMaxHealth() / 3 &&
+                (IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 35 && !opponent->HasAura(MARK_OF_BLOOD_1) && IsInBotParty(u))
+            {
+                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
+                {
+                    SetSpellCooldown(MARK_OF_BLOOD_1, 90000); //1.5 min for bots
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //STRANGULATE
+            if (IsSpellReady(STRANGULATE_1, diff) && meleedist <= 30 && HaveRune(RUNE_BLOOD) &&
+                opponent->IsNonMeleeSpellCasted(false) && Rand() < 40)
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                if (doCast(opponent, GetSpell(STRANGULATE_1)))
+                {
+                    SetSpellCooldown(STRANGULATE_1, 40000); //-67% for bots
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(STRANGULATE_1, 500); //fail
+            }
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && dist < 30 && IsTank() &&
+                opponent->GetVictim() != me && Rand() < 70)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
+                {
+                    SetSpellCooldown(DARK_COMMAND_1, 6000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && opponent->GetVictim() != me) ||
+            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCasted(false)) &&
+            //    Rand() < 75)
+            //{
+            //    temptimer = GC_Timer;
+            //    if (doCast(opponent, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+            //CHAINS OF ICE
+            if (uint32 CHAINS_OF_ICE = GetSpell(CHAINS_OF_ICE_1))
+            {
+                if (GC_Timer <= diff && dist < 20 && HaveRune(RUNE_FROST) && opponent->isMoving() &&
+                    !CCed(opponent) && !IsTank(opponent->GetVictim()) && IsInBotParty(opponent->GetVictim()) && Rand() < 25)
+                {
+                    Aura* chains = opponent->GetAura(CHAINS_OF_ICE);
+                    if (!chains || chains->GetDuration() < chains->GetMaxDuration() / 4)
+                    {
+                        if (doCast(opponent, CHAINS_OF_ICE))
+                        {
+                            //Improved Chains of Ice: convert frost rune into death rune
+                            ConvertRune(RUNE_FROST, 1);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            //AOE SECTION
+
+            //HOWLING BLAST
+            if (IsSpellReady(HOWLING_BLAST_1, diff) && IsTank() && meleedist < 8 && HasRole(BOT_ROLE_DPS) &&
+                me->getAttackers().size() > 2 && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(HOWLING_BLAST_1)))
+                {
+                    SetSpellCooldown(HOWLING_BLAST_1, 7000);
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(HOWLING_BLAST_1, 500); //fail
+            }
+            //BLOOD BOIL
+            if (IsSpellReady(BLOOD_BOIL_1, diff) && HasRole(BOT_ROLE_DPS) && HaveRune(RUNE_BLOOD) && Rand() < (10 + 40 * IsTank()))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.5f);
+                if (targets.size() >= 5)
+                    if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                        return;
+            }
+            //DEATH AND DECAY
+            if (IsSpellReady(DEATH_AND_DECAY_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < (30 + 30 * IsTank()) &&
+                HaveRune(RUNE_BLOOD) && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST))
+            {
+                if (Unit* target = FindAOETarget(30, true))
+                {
+                    if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                    {
+                        SetSpellCooldown(DEATH_AND_DECAY_1, 15000); //improved by Morbidity
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(DEATH_AND_DECAY_1, 500); //fail
+            }
+
+            //END AOE SECTION
+
+            //ICY TOUCH
+            if (IsSpellReady(ICY_TOUCH_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && HaveRune(RUNE_FROST) && Rand() < 25 &&
+                !opponent->HasAura(FROST_FEVER_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
+                    return;
+            }
+            //DEATH COIL //custom cd condition
+            if (GetSpell(DEATH_COIL_1) && GC_Timer <= 600 && dist < 20 && HasRole(BOT_ROLE_DPS) &&
+                int32(getpower()) >= (400 + 200 * (GetSpell(RUNE_STRIKE_1) != 0 || GetSpell(MIND_FREEZE_1) != 0 || GetSpell(ANTI_MAGIC_SHELL_1) != 0) + 400 * (GetSpell(HUNGERING_COLD_1) != 0)) &&
+                Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //MELEE SECTION
+
+            //MIND FREEZE
+            if (IsSpellReady(MIND_FREEZE_1, diff, false) && meleedist <= 5 && getpower() >= 200 &&
+                opponent->IsNonMeleeSpellCasted(false) && Rand() < 60)
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(MIND_FREEZE_1)))
+                {
+                    SetSpellCooldown(MIND_FREEZE_1, 8000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HUNGERING COLD
+            if (IsSpellReady(HUNGERING_COLD_1, diff) && HasRole(BOT_ROLE_DPS) && getpower() >= 400 && Rand() < 20)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 0, true);
+                if (targets.size() >= 3)
+                {
+                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                    {
+                        SetSpellCooldown(HUNGERING_COLD_1, 45000);
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(HUNGERING_COLD_1, 500); //fail
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //RUNE STRIKE
+            if (IsSpellReady(RUNE_STRIKE_1, diff, false) && runestriketimer > me->getAttackTimer(BASE_ATTACK) &&
+                HasRole(BOT_ROLE_DPS) && meleedist <= 5 && getpower() >= 200/* && Rand() < 75*/)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
+                {
+                    SetSpellCooldown(RUNE_STRIKE_1, me->getAttackTimer(BASE_ATTACK)); //only one per swing
+                    runestriketimer = 0; //do not remove aura, just disable ability
+                    GC_Timer = temptimer;
+                }
+            }
+            //PLAGUE STRIKE
+            if (IsSpellReady(PLAGUE_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && HaveRune(RUNE_UNHOLY) && Rand() < 35 &&
+                !opponent->HasAura(BLOOD_PLAGUE_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
+                    return;
+            }
+
+            //DISEASE SECTION
+            uint32 diseases = opponent->GetDiseasesByCaster(me->GetGUID());
+
+            //PESTILENCE //custom cd condition
+            if (GetSpell(PESTILENCE_1) && pestilencetimer == 0 && HasRole(BOT_ROLE_DPS) && GC_Timer <= 600 &&
+                diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 15)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f);
+                if (targets.size() > 2)
+                {
+                    if (doCast(opponent, GetSpell(PESTILENCE_1)))
+                    {
+                        pestilencetimer = 10000;
+                        return;
+                    }
+                }
+
+                pestilencetimer = 1000; //fail
+            }
+            //DEATH STRIKE
+            if (IsSpellReady(DEATH_STRIKE_1, diff) && diseases > 0 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) &&
+                GetHealthPCT(me) < (91 - 10 * diseases) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
+                    return;
+            }
+            //OBLITERATE
+            if (IsSpellReady(OBLITERATE_1, diff) && diseases > 2 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(OBLITERATE_1)))
+                    return;
+            }
+            //BLOOD STRIKE //custom
+            if (BLOOD_STRIKE && GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 25)
+            {
+                if (doCast(opponent, BLOOD_STRIKE))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+                if (spellId == GetSpell(RUNE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+                if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    /*spellId == GetSpell(SCOURGE_STRIKE_1) || */spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 0.09f;
+                //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+                if (spellId == GetSpell(DEATH_STRIKE_1))
+                    aftercrit += 0.06f;
+                //Rime (part 1 melee): 15% additional critical chance for Obliterate
+                if (lvl >= 68 && spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 15.f;
+                //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    aftercrit += 6.f;
+
+                //Annihilation: 3% additional critical chance for melee special abilities
+                if (lvl >= 57)
+                    aftercrit += 0.03f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if (lvl >= 68 &&
+                    (spellId == GetSpell(BLOOD_BOIL_1) || spellId == BLOOD_STRIKE ||
+                    spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(HEART_STRIKE_1)))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike and Obliterate
+                if (lvl >= 69 &&
+                    (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    spellId == GetSpell(OBLITERATE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Glypg of Plague Strike: 20% bonus damage for Plague Strike
+            if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                pctbonus += 0.2f;
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets (Heart Strike too for bots)
+            //warning unsafe
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                if (damageinfo.target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
+                    pctbonus += 0.2f;
+            //Increased Blood Strike Damage: 90 bonus damage for Blood Strike and Heart Strike
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1) && me->GetPower(POWER_RUNIC_POWER) >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<uint32>(me->GetPower(POWER_RUNIC_POWER), 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (spellId == GetSpell(OBLITERATE_1))
+                pctbonus += 0.25f;
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if (lvl >= 60)
+            {
+                if (spellId == BLOOD_STRIKE)
+                    pctbonus += 0.15f;
+                else if (spellId == GetSpell(HEART_STRIKE_1))
+                    pctbonus += 0.45f;
+                else if (spellId == GetSpell(BLOOD_BOIL_1))
+                    pctbonus += 0.3f;
+            }
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1))
+                pctbonus += 0.3f;
+            //Merciless Combat (melee): 12% bonus damage for Obliterate on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 && spellId == GetSpell(OBLITERATE_1) && damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike (make Heart strike too)
+            if (lvl >= 69 && (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 59)
+            {
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    pctbonus += 0.3f;
+                //else if (spellId == GetSpell(SCOURGE_STRIKE_1))
+                //    pctbonus += 0.2f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rime (part 1 spell): 15% additional critical chance for Icy Touch
+                if (lvl >= 68 && spellId == GetSpell(ICY_TOUCH_1))
+                    aftercrit += 15.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Howling Blast
+                if (lvl >= 69 && spellId == GetSpell(HOWLING_BLAST_1))
+                    pctbonus += 0.45f / 1.5f;
+
+                //Runic Focus: 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+            }
+
+            //Improved Icy Touch: 15% bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                pctbonus += 0.15f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (spellId == GetSpell(DEATH_COIL_1))
+                fdamage += 80.f;
+            //Black Ice: 10% bonus damage for all Shadow and Frost spells
+            if (lvl >= 58 &&
+                ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                pctbonus += 0.1f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike
+            //warning unsafe
+            if (lvl >= 63 && (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetDiseasesByCaster(me->GetGUID()) > 0)
+                pctbonus += 0.2f;
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast and Frost Strike on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 &&
+                (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Tundra Stalker (spell): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Morbidity: 15% damage bonus for Death Coil
+            if (lvl >= 58 && spellId == GetSpell(DEATH_COIL_1))
+                pctbonus += 0.15f;
+
+            //temp
+            if (spellId == GetSpell(RUNE_TAP_1))
+                pctbonus += 1.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float& value) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pct_mod = 1.f;
+
+            //Periodic damage bonuses
+            if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            {
+                //float ticksnum = float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+
+                //Increased Plague Strike DoT Damage (id 54802): increased DoT damage by 100
+                if (spellId == BLOOD_PLAGUE_AURA)
+                    value += 100.f;
+                //Glyph of Icy Touch: 20% bonus damage for Frost Fever
+                if (spellId == FROST_FEVER_AURA)
+                    pct_mod += 0.2f;
+                //Black Ice: 10% bonus damage for all Shadow and Frost spells
+                if (lvl >= 58 &&
+                    ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                    pct_mod += 0.1f;
+                //Glyph of Unholy Blight: 40% damage bonus for Unholy Blight (100% for bot)
+                if (spellId == UNHOLY_BLIGHT_AURA)
+                    pct_mod += 1.f;
+            }
+            //Heal bonuses
+            if (spellInfo->Effects[effect_index].Effect == SPELL_EFFECT_HEAL)
+            {
+                //Improved Rune Tap: 100% bonus healing from Rune Tap
+                if (spellId == GetSpell(RUNE_TAP_1))
+                    pct_mod += 1.f;
+            }
+
+            value *= pct_mod;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (3 for bot)
+            if (spellId == GetSpell(HORN_OF_WINTER_1))
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 180000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    me->AddAura(44755, target); //snowflakes
+            }
+
+            if (target == me)
+                return;
+
+            //Epidemic: 10 sec bonus duration for all diseases
+            if (spellId == FROST_FEVER_AURA || spellId == BLOOD_PLAGUE_AURA ||
+                spellId == CRYPT_FEVER_AURA || spellId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 10000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike (up to 30% for bot)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+            {
+                if (GetSpell(DEATH_COIL_1) && me->getLevel() >= 65 && irand(1,100) <= (me->getLevel() - 50))
+                {
+                    //debug: dk bot cannot cast without runic power even triggered spells
+                    modpower(40);
+                    me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown (25% for bot, screw runes part)
+            if (spellId == GetSpell(OBLITERATE_1))
+            {
+                if (me->getLevel() >= 67 && urand(1,100) <= 25)
+                    ResetSpellCooldown(HOWLING_BLAST_1);
+            }
+            //Chillblains Improved: increase duration by 10 sec (disable on players)
+            if (spellId == ICY_CLUTCH)
+            {
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* chill = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = chill->GetDuration() + 10000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Blood of the North (part 2): Blood Strike and Pestilence convert Blood Rune to Dark Rune (make Heart Strike too)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) || GetSpell(spellId == PESTILENCE_1))
+            {
+                if (me->getLevel() >= 69)
+                    ConvertRune(RUNE_BLOOD, 1);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == RUNE_STRIKE_ACIVATION_AURA)
+            {
+                //Rune Strike activation and timer set
+                runestriketimer = 10000;
+            }
+            if (spellId == GetSpell(ANTI_MAGIC_SHELL_1))
+            {
+                //Glyph of Anti-Magic Shell: 2 sec increased duration (5 for bot)
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    uint32 dur = shell->GetDuration() + 5000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(VAMPIRIC_BLOOD_1))
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* blood = me->GetAura(spellId))
+                {
+                    uint32 dur = blood->GetDuration() + 5000;
+                    blood->SetDuration(dur);
+                    blood->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(BONE_SHIELD_1))
+            {
+                //Glyph of Bone Shield: 1 bonus charge (2 for bot, 7 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                {
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+                }
+            }
+            if (spellId == ICY_TALONS_AURA1 || spellId == ICY_TALONS_AURA2 ||
+                spellId == ICY_TALONS_AURA3 || spellId == ICY_TALONS_AURA4 || spellId == ICY_TALONS_AURA5)
+            {
+                //Icy Talons: Synchronize with Epidemic, add 10 sec duration
+                if (Aura* talons = me->GetAura(spellId))
+                {
+                    uint32 dur = talons->GetDuration() + 10000;
+                    talons->SetDuration(dur);
+                    talons->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(OBLITERATE_1))
+            {
+                //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+                ConvertRune(RUNE_UNHOLY, 1);
+                ConvertRune(RUNE_FROST, 1);
+            }
+            if (spellId == GetSpell(ICEBOUND_FORTITUDE_1))
+            {
+                //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration (18 for bot)
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    uint32 dur = fort->GetDuration() + 18000;
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (me->HasAura(IMPROVED_BLOOD_PRESENCE_AURA))
+                {
+                    int32 bp0 = int32(damage / 25); //4%
+                    me->CastCustomSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, &bp0, NULL, NULL, true);
+                }
+
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+            runestriketimer = 0;
+            pestilencetimer = 0;
+
+            Presence = BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+            me->setPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                InitPowers();
+                InitRunes();
+                ApplyPassives(CLASS_DEATH_KNIGHT);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (runestriketimer > diff)             runestriketimer -= diff;
+            else                                    runestriketimer = 0;
+            if (pestilencetimer > diff)             pestilencetimer -= diff;
+            else                                    pestilencetimer = 0;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitPowers()
+        {
+            if (master->getLevel() >= 70)
+                RefreshAura(RUNIC_POWER_MASTERY,5);
+            else if (master->getLevel() >= 58)
+                RefreshAura(RUNIC_POWER_MASTERY,4);
+            else
+                me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            if (runicpower)
+                me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+  /*Talent*/InitSpellMap(HEART_STRIKE_1);
+
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+  /*Talent*/lvl >= 63 ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1, true);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+  /*Talent*/InitSpellMap(LICHBORNE_1, true);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+  /*Talent*/InitSpellMap(RUNE_TAP_1, true);
+  /*Talent*/lvl >= 58 ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+  /*Talent*/InitSpellMap(MARK_OF_BLOOD_1, true);
+  /*Talent*/InitSpellMap(VAMPIRIC_BLOOD_1, true);
+  /*Talent*/lvl >= 59 ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            //InitSpellMap(UNHOLY_PRESENCE_1, true);
+
+  /*Custom*/BLOOD_STRIKE = lvl >= 65 ? GetSpell(HEART_STRIKE_1) : InitSpell(me, BLOOD_STRIKE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            if (level >= 58)
+                RefreshAura(GLYPH_OF_CHAINS_OF_ICE);
+            if (level >= 80)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,4);
+            else if (level >= 77)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,3);
+            else if (level >= 68)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH,2);
+            else if (level >= 58)
+                RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH);
+            if (level >= 65)
+                RefreshAura(GLYPH_OF_HEART_STRIKE);
+            if (level >= 68)
+                RefreshAura(GLYPH_OF_RUNE_TAP,2);
+            else if (level >= 60)
+                RefreshAura(GLYPH_OF_RUNE_TAP);
+            if (level >= 63)
+                RefreshAura(GLYPH_OF_HOWLING_BLAST);
+            if (level >= 57)
+                RefreshAura(BUTCHERY);
+            if (level >= 58)
+                RefreshAura(SCENT_OF_BLOOD);
+            if (level >= 59)
+                RefreshAura(VENDETTA);
+            if (level >= 65)
+                RefreshAura(BLOODY_VENGEANCE3);
+            else if (level >= 60)
+                RefreshAura(BLOODY_VENGEANCE2);
+            else if (level >= 57)
+                RefreshAura(BLOODY_VENGEANCE1);
+            if (level >= 60)
+                RefreshAura(ABOMINATIONS_MIGHT);
+            if (level >= 67)
+                RefreshAura(IMPROVED_BLOOD_PRESENCE);
+            if (level >= 65)
+                RefreshAura(BLOODWORMS,2);
+            //if (level >= 66)
+            //    RefreshAura(IMPROVED_DEATH_STRIKE);
+            if (level >= 57)
+                RefreshAura(TOUGHNESS);
+            if (level >= 57)
+                RefreshAura(ANNIHILATION);
+            if (level >= 60)
+                RefreshAura(ICY_TALONS);
+            if (level >= 68)
+                RefreshAura(CHILL_OF_THE_GRAVE,2);
+            else if (level >= 58)
+                RefreshAura(CHILL_OF_THE_GRAVE);
+            if (level >= 64)
+                RefreshAura(IMPROVED_ICY_TALONS);
+            if (level >= 68)
+                RefreshAura(CHILBLAINS);
+            if (level >= 69)
+                RefreshAura(ACCLIMATION);
+            if (level >= 63)
+                RefreshAura(NECROSIS5);
+            else if (level >= 62)
+                RefreshAura(NECROSIS4);
+            else if (level >= 61)
+                RefreshAura(NECROSIS3);
+            else if (level >= 60)
+                RefreshAura(NECROSIS2);
+            else if (level >= 59)
+                RefreshAura(NECROSIS1);
+            if (level >= 65)
+                RefreshAura(BLOOD_CAKED_BLADE3);
+            else if (level >= 62)
+                RefreshAura(BLOOD_CAKED_BLADE2);
+            else if (level >= 60)
+                RefreshAura(BLOOD_CAKED_BLADE1);
+            if (level >= 67)
+                RefreshAura(DIRGE,2);
+            else if (level >= 61)
+                RefreshAura(DIRGE);
+            if (level >= 61)
+                RefreshAura(UNHOLY_BLIGHT);
+            if (level >= 62)
+                RefreshAura(DESECRATION);
+            if (level >= 64)
+                RefreshAura(CRYPT_FEVER);
+            if (level >= 68)
+                RefreshAura(EBON_PLAGUEBRINGER);
+            if (level >= 67)
+                RefreshAura(WANDERING_PLAGUE);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 BLOOD_STRIKE;
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2, runestriketimer, pestilencetimer;
+/*misc*/uint32 runicpower;
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 Presence;
+
+        BotRunes _runes;
+
+        enum DeathKnightBaseSpells
+        {
+            BLOOD_STRIKE_1                      = 45902,
+            ICY_TOUCH_1                         = 45477,
+            PLAGUE_STRIKE_1                     = 45462,
+            DEATH_STRIKE_1                      = 49998,
+            OBLITERATE_1                        = 49020,
+            RUNE_STRIKE_1                       = 56815,
+            HEART_STRIKE_1                      = 55050,
+
+            BLOOD_BOIL_1                        = 48721,
+            DEATH_AND_DECAY_1                   = 43265,
+            HOWLING_BLAST_1                     = 49184,
+
+            DEATH_COIL_1                        = 47541,
+            DEATH_GRIP_1                        = 49576,
+            PESTILENCE_1                        = 50842,
+            MIND_FREEZE_1                       = 47528,
+            STRANGULATE_1                       = 47476,
+            CHAINS_OF_ICE_1                     = 45524,
+            ICEBOUND_FORTITUDE_1                = 48792,
+            DARK_COMMAND_1                      = 56222,
+            ANTI_MAGIC_SHELL_1                  = 48707,
+            ARMY_OF_THE_DEAD_1                  = 42650,
+            LICHBORNE_1                         = 49039,
+            HUNGERING_COLD_1                    = 49203,
+
+            PATH_OF_FROST_1                     = 3714,
+            HORN_OF_WINTER_1                    = 57330,
+            BONE_SHIELD_1                       = 49222,
+            RUNE_TAP_1                          = 48982,
+            EMPOWER_RUNE_WEAPON_1               = 47568,
+            MARK_OF_BLOOD_1                     = 49005,
+            VAMPIRIC_BLOOD_1                    = 55233,
+            HYSTERIA_1                          = 49016,
+
+            BLOOD_PRESENCE_1                    = 48266,
+            FROST_PRESENCE_1                    = 48263
+            //UNHOLY_PRESENCE_1                   = 48265
+        };
+        enum DeathKnightPassives
+        {
+        //Talents
+            BUTCHERY                            = 49483,//rank 2
+            SCENT_OF_BLOOD                      = 49509,//rank 3
+            VENDETTA                            = 55136,//rank 3
+            BLOODY_VENGEANCE1                   = 48988,
+            BLOODY_VENGEANCE2                   = 49503,
+            BLOODY_VENGEANCE3                   = 49504,
+            ABOMINATIONS_MIGHT                  = 53138,//rank 2
+            IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+            BLOODWORMS                          = 49543,//rank 3
+            IMPROVED_DEATH_STRIKE               = 62908,//rank 2
+            TOUGHNESS                           = 49789,//rank 5
+            ANNIHILATION                        = 51473,//rank 3
+            ICY_TALONS                          = 50887,//rank 5
+            CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+            IMPROVED_ICY_TALONS                 = 55610,
+            CHILBLAINS                          = 50043,//rank 3
+            ACCLIMATION                         = 50152,//rank 3
+            NECROSIS1                           = 51459,
+            NECROSIS2                           = 51462,
+            NECROSIS3                           = 51463,
+            NECROSIS4                           = 51464,
+            NECROSIS5                           = 51465,
+            BLOOD_CAKED_BLADE1                  = 49219,
+            BLOOD_CAKED_BLADE2                  = 49227,
+            BLOOD_CAKED_BLADE3                  = 49228,
+            DIRGE                               = 51206,//rank 2
+            UNHOLY_BLIGHT                       = 49194,
+            DESECRATION                         = 55667,//rank 2
+            CRYPT_FEVER                         = 49632,//rank 3
+            EBON_PLAGUEBRINGER                  = 51161,//rank 3
+            WANDERING_PLAGUE                    = 49655,//rank 3
+        //Special
+  /*Talent*/RUNIC_POWER_MASTERY                 = 50147,//rank 2
+            FROST_FEVER                         = 59921,
+            BLOOD_PLAGUE                        = 59879,
+        //Other
+            GLYPH_OF_CHAINS_OF_ICE              = 58620,//damage proc
+            CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+            GLYPH_OF_HEART_STRIKE               = 58616,//snare 50% for 10 sec
+            GLYPH_OF_RUNE_TAP                   = 59327,//10% heal for party
+            GLYPH_OF_HOWLING_BLAST              = 63335 //frost fever on targets
+        };
+        enum DeathKnightSpecial
+        {
+            FROST_FEVER_AURA                    = 55095,
+            BLOOD_PLAGUE_AURA                   = 55078,
+            CRYPT_FEVER_AURA                    = 50510,//rank 3
+            EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+            RUNE_STRIKE_ACIVATION_AURA          = 56817,
+
+            IMPROVED_BLOOD_PRESENCE_AURA        = 63611,
+            BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+            BLADE_BARRIER_AURA                  = 64859,//rank 5
+            UNHOLY_BLIGHT_AURA                  = 50536,
+
+            ICY_TALONS_AURA1                    = 50882,//rank 1
+            ICY_TALONS_AURA2                    = 58575,//rank 2
+            ICY_TALONS_AURA3                    = 58576,//rank 3
+            ICY_TALONS_AURA4                    = 58577,//rank 4
+            ICY_TALONS_AURA5                    = 58578,//rank 5
+
+            DEATH_COIL_ENEMY                    = 47632,
+            ICY_CLUTCH                          = 50436 //rank 3 Chilblains proc
+        };
+        //enum RunePlacing
+        //{
+        //    RUNE_BLOOD_FIRST,
+        //    RUNE_BLOOD_SECOND,
+        //    RUNE_UNHOLY_FIRST,
+        //    RUNE_UNHOLY_SECOND,
+        //    RUNE_FROST_FIRST,
+        //    RUNE_FROST_SECOND,
+        //    NO_RUNE
+        //};
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..8d1d0d4
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1195 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+
+            m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (me->GetShapeshiftForm() == FORM_NONE && swiftness && m_botSpellInfo->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == GetSpell(BEAR_FORM_1) || GetSpell(spellId == CAT_FORM_1))
+            {
+                me->ModifyPower(POWER_MANA, - int32(m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask())));
+                mana = me->GetPower(POWER_MANA);
+                if (Unit* u = me->GetVictim())
+                    GetInPosition(true, u);
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result &&
+                //spellId != GetSpell(BEAR_FORM_1) && spellId != GetSpell(spellId == CAT_FORM_1) &&
+                spellId != MANAPOTION && spellId != WARSTOMP_1 &&
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { removeFeralForm(true, false); master->SetNpcBotDied(me->GetGUID()); }
+
+        uint8 GetBotStance() const
+        {
+            switch (me->GetShapeshiftForm())
+            {
+                case FORM_BEAR:
+                case FORM_DIREBEAR:
+                    return DRUID_BEAR_FORM;
+                case FORM_CAT:
+                    return DRUID_CAT_FORM;
+            }
+
+            return CLASS_DRUID;
+        }
+
+        void warstomp(uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (IsSpellReady(WARSTOMP_1, diff, false)) return;
+            if (me->GetShapeshiftForm() != FORM_NONE)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit* u = me->SelectNearestTarget(5);
+                if (u && u->IsInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP_1))
+                    {
+                        SetSpellCooldown(WARSTOMP_1, 30000); //30sec
+                        return;
+                    }
+                }
+            }
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(me, WARSTOMP_1))
+                        SetSpellCooldown(WARSTOMP_1, 30000); //30sec
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            if (Group* pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit* u = master->GetVictim();
+            if (master->getAttackers().size() > 4 ||
+              (!master->getAttackers().empty() &&
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool force = false, bool init = true, uint32 diff = 0)
+        {
+            if (!force && formtimer > diff) return;
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_DIREBEAR:
+                    case FORM_BEAR:
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        break;
+                    case FORM_CAT:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(ENERGIZE);
+                        break;
+                    default:
+                        break;
+                }
+                setStats(CLASS_DRUID, init);
+            }
+        }
+
+        bool IsMelee() const
+        {
+            if (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM)
+                return true;
+
+            return bot_ai::IsMelee();
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_BEAR_1)))
+            {
+                SetSpellCooldown(MANGLE_BEAR_1, 6000);
+                return;
+            }
+
+            if (IsSpellReady(SWIPE_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 75 &&
+                doCast(opponent, GetSpell(SWIPE_1)))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_ENERGY) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_CAT_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_CAT_1)))
+            {
+                SetSpellCooldown(MANGLE_CAT_1, 6000);
+                return;
+            }
+            if (IsSpellReady(RAKE_1, diff) && energy > 40 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RAKE_1)))
+            {
+                SetSpellCooldown(RAKE_1, 10000);
+                return;
+            }
+            if (IsSpellReady(SHRED_1, diff) && energy > 60 && HasRole(BOT_ROLE_DPS) && !opponent->HasInArc(M_PI, me) && Rand() < 50 &&
+                doCast(opponent, GetSpell(SHRED_1)))
+            {
+                SetSpellCooldown(SHRED_1, 12000);
+                return;
+            }
+            if (IsSpellReady(RIP_1, diff) && energy > 30 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RIP_1)))
+            {
+                SetSpellCooldown(RIP_1, 15000);
+                return;
+            }
+            if (IsSpellReady(CLAW_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                doCast(opponent, GetSpell(CLAW_1)))
+                return;
+        }//end doCatActions
+
+        void doBalanceActions(uint32 diff)
+        {
+            removeFeralForm(true, true);
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (IsSpellReady(HURRICANE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 35)
+            {
+                Unit* target = FindAOETarget(30, true);
+                if (target && doCast(target, GetSpell(HURRICANE_1)))
+                {
+                    SetSpellCooldown(HURRICANE_1, 5000);
+                    return;
+                }
+                SetSpellCooldown(HURRICANE_1, 2000); //fail
+            }
+            if (uint32 FAERIE_FIRE = GetSpell(FAERIE_FIRE_1))
+            {
+                if (GC_Timer <= diff &&
+                    opponent->getAttackers().size() > 1 &&//check if faerie fire is not useless 50/50
+                    Rand() < 20 && !HasAuraName(opponent, FAERIE_FIRE_1))
+                {
+                    if (doCast(opponent, FAERIE_FIRE))
+                        return;
+                }
+            }
+            if (IsSpellReady(MOONFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 20 &&
+                !HasAuraName(opponent, MOONFIRE_1, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(MOONFIRE_1)))
+                {
+                    SetSpellCooldown(MOONFIRE_1, 5000);
+                    return;
+                }
+            }
+            if (IsSpellReady(STARFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(STARFIRE_1)))
+                {
+                    SetSpellCooldown(STARFIRE_1, 11000);
+                    return;
+                }
+            }
+            if (IsSpellReady(WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                if (doCast(opponent, GetSpell(WRATH_1)))
+                {
+                    SetSpellCooldown(WRATH_1, uint32(sSpellMgr->GetSpellInfo(GetSpell(WRATH_1))->CalcCastTime()/100 * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1));
+                    return;
+                }
+            }
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false);
+            if (!tranq && !growt) return false;
+            if (Rand() > 30) return false;
+            Group* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+            {
+                SetSpellCooldown(TRANQUILITY_1, 60000);
+                return true;
+            }
+            if (LHPcount > 0 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+            {
+                SetSpellCooldown(WILD_GROWTH_1, 6000);
+                return true;
+            }
+            return false;
+        }//end MassGroupHeal
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if ((me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR) &&
+                me->getPowerType() != POWER_RAGE)
+                me->setPowerType(POWER_RAGE);
+            if (me->GetShapeshiftForm() == FORM_CAT && me->getPowerType() != POWER_ENERGY)
+                me->setPowerType(POWER_ENERGY);
+            if (me->GetShapeshiftForm() == FORM_NONE && me->getPowerType() != POWER_MANA)
+                me->setPowerType(POWER_MANA);
+            if (IAmDead()) return;
+            CheckAttackState();
+
+            if (me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer2 <= diff)
+                {
+                    if (me->IsInCombat() && me->getLevel() >= 30)
+                    {
+                        if (rage < 990)
+                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000);
+                    }
+                    ragetimer2 = 2000;
+                }
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(power, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (Potion_cd <= diff && me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            //CureTarget(master, GetSpell(CURE_POISON_1), diff);
+            CureGroup(master, GetSpell(CURE_POISON_1), diff);
+
+            if (!CheckAttackTarget(CLASS_DRUID))
+                return;
+
+            //debug
+            opponent = me->GetVictim();
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting()) return; //Casting heal or something
+            CheckRoots(diff);
+
+            if (DamagePossible() && opponent != NULL)
+            {
+                Unit* u = opponent->GetVictim();
+                //if the target is attacking us, we want to go bear
+                if (GetSpell(BEAR_FORM_1) && !CCed(opponent) &&
+                    ((u == me || (IsTank() && IsInBotParty(u))) ||
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2)))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_DIREBEAR &&
+                        me->GetShapeshiftForm() != FORM_BEAR &&
+                        formtimer <= diff &&
+                        doCast(me, GetSpell(BEAR_FORM_1)))
+                    {
+                        setStats(DRUID_BEAR_FORM);
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_DIREBEAR ||
+                        me->GetShapeshiftForm() == FORM_BEAR)
+                        doBearActions(diff);
+                }
+                else
+                if (GetSpell(CAT_FORM_1) && master->GetVictim() != opponent && u &&
+                    IsTank(u) && u != me &&
+                    opponent->GetMaxHealth() < u->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, GetSpell(CAT_FORM_1)))
+                        {
+                            setStats(DRUID_CAT_FORM);
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                        doCatActions(diff);
+                }
+                else if (!IsTank())
+                    doBalanceActions(diff);
+            }
+            else if (!IsTank())
+                doBalanceActions(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (IsTank() && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false; //do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
+                (hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) &&
+                (target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)) && RefreshAura(CRIT_50, 2))
+                {
+                    swiftness = true;
+                    SetSpellCooldown(NATURES_SWIFTNESS_1, 120000); //2 min
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1), true))
+                        Heal_Timer = 3000;
+                    return true;
+                }
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false, 3000) &&
+                (hp < 25 || GetLostHP(target) > 5000) &&
+                (HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1)))
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                {
+                    SetSpellCooldown(SWIFTMEND_1, 10000);
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, GetSpell(REGROWTH_1)))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && GetSpell(NOURISH_1))
+            {
+                switch (urand(1,3))
+                {
+                    case 1:
+                    case 2:
+                        if (doCast(target, GetSpell(NOURISH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                }
+            }
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            bool regrowth = IsSpellReady(REGROWTH_1, diff);
+            if ( ( (hp < 80 || GetLostHP(target) > 3500 || tanking) &&
+                regrowth && !HasAuraName(target, REGROWTH_1, me->GetGUID()) )
+                ||
+                (HasAuraName(target, REGROWTH_1, me->GetGUID()) && HasAuraName(target, REJUVENATION_1, me->GetGUID()) &&
+                (hp < 70 || GetLostHP(target) > 3000) && regrowth))
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                {
+                    SetSpellCooldown(REGROWTH_1, 2000);
+                    return true;
+                }
+            }
+            if (GetSpell(REJUVENATION_1) && GC_Timer <= diff && hp > 25 &&
+                (hp < 90 || GetLostHP(target) > 2000 || tanking) &&
+                !HasAuraName(target, REJUVENATION_1, me->GetGUID()))
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (IsSpellReady(SWIFTMEND_1, diff, false) && doCast(target, GetSpell(SWIFTMEND_1)))
+                            SetSpellCooldown(SWIFTMEND_1, 10000);
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) &&
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) ||
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH_1) && HasAuraName(target, REJUVENATION_1)) ||
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
+            {
+                if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+                    if (!HasAuraName(target, MARK_OF_THE_WILD_1))
+                        if (doCast(target, MARK_OF_THE_WILD))
+                            return true;
+                if (uint32 THORNS = GetSpell(THORNS_1))
+                    if (!HasAuraName(target, THORNS_1))
+                        if (doCast(target, THORNS))
+                            return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || me->IsMounted()) return;
+
+            RezGroup(GetSpell(REVIVE_1), master);
+
+            //if (Feasting()) return;
+
+            //if (BuffTarget(master, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+            //if (BuffTarget(me, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+        }
+
+        void doInnervate(uint32 diff, uint8 minmanaval = 30)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 15)
+                return;
+            if (me->GetShapeshiftForm() != FORM_NONE && (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            uint32 INNERVATE = GetSpell(INNERVATE_1);
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
+                iTarget = master;
+            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
+                GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
+                iTarget = me;
+
+            Group* group = master->GetGroup();
+            if (!iTarget && !group) //first check master's bots
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    Creature* bot = master->GetBotMap(i)->_Cre();
+                    if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
+                    if (me->GetExactDist(bot) > 30) continue;
+                    if (bot->getPowerType() != POWER_MANA) continue;
+                    if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                    {
+                        iTarget = bot;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget && group) //cycle through player members...
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->getPowerType() != POWER_MANA) continue;
+                    if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
+                    {
+                        iTarget = tPlayer;
+                        break;
+                    }
+                    if (iTarget)
+                        break;
+                }
+            }
+            if (!iTarget && group) //... and their bots.
+            {
+                for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (!bot || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (bot->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                    if (iTarget)
+                        break;
+                }
+            }
+
+            //fail
+            if (!iTarget)
+            {
+                SetSpellCooldown(INNERVATE_1, 3000);
+                return;
+            }
+
+            if (doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    me->MonsterWhisper("Innervate on You!", iTarget->GetGUID());
+                else
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                }
+
+                SetSpellCooldown(INNERVATE_1, iTarget->GetTypeId() == TYPEID_PLAYER ? 60000 : 20000); //1 min if player and 20 sec if bot
+            }
+        }
+
+        void CheckRoots(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 35) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1);
+            if (!ENTANGLING_ROOTS) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || me->IsMounted() || IsCasting() || Rand() > 10) return;
+
+            Group* gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->isRessurectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", master->GetGUID());
+                    SetSpellCooldown(REBIRTH_1, me->getLevel() >= 60 ? 300000 : 600000); //5-10 min (improved possible)
+                }
+                return;
+            }
+            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                Unit* target = tPlayer;
+                if (!tPlayer || tPlayer->IsAlive()) continue;
+                if (tPlayer->isRessurectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (!target || !target->IsInWorld()) continue;
+                if (master->GetMap() != target->FindMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+                    SetSpellCooldown(REBIRTH_1, me->getLevel() >= 60 ? 300000 : 600000); //5-10 min (improved possible)
+                    return;
+                }
+            }
+        }
+
+        void setStats(uint8 form, bool init = true)
+        {
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    me->SetBotClass(DRUID_BEAR_FORM);
+                    if (me->getPowerType() != POWER_RAGE)
+                    {
+                        me->setPowerType(POWER_RAGE);
+                        me->SetMaxPower(POWER_RAGE, 1000);
+                    }
+                    if (me->getLevel() >= 15)
+                        me->SetPower(POWER_RAGE, 200);
+                    else
+                        me->SetPower(POWER_RAGE, 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                    break;
+                case DRUID_CAT_FORM:
+                    me->SetBotClass(DRUID_CAT_FORM);
+                    if (me->getPowerType() != POWER_ENERGY)
+                    {
+                        me->setPowerType(POWER_ENERGY);
+                        me->SetMaxPower(POWER_ENERGY, 100);
+                        me->SetPower(POWER_ENERGY, 0);
+                    }
+                    if (me->getLevel() >= 15)
+                        me->SetPower(POWER_ENERGY, 60);
+                    else
+                        me->SetPower(POWER_ENERGY, 0);
+                    if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                    RefreshAura(ENERGIZE, me->getLevel()/40 + master->Has310Flyer(false));
+                    break;
+                case CLASS_DRUID:
+                    me->SetBotClass(CLASS_DRUID);
+                    if (me->getPowerType() != POWER_MANA)
+                        me->setPowerType(POWER_MANA);
+                    if (init)
+                        me->SetPower(POWER_MANA, mana);
+                    break;
+            }
+
+            SetStats(false);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            formtimer = 0;
+
+            clearcast = false;
+            swiftness = false;
+
+            power = POWER_MANA;
+
+            mana = 0;
+            rage = 0;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+            ragetimer2 = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_DRUID);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+            InitSpellMap(WARSTOMP_1, true);
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+     /*tal*/lvl >= 40 ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+            InitSpellMap(RIP_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(INNERVATE_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 78)
+                RefreshAura(SPELLDMG2, 3); //+18%
+            else if (level >= 65)
+                RefreshAura(SPELLDMG2, 2); //+12%
+            else if (level >= 50)
+                RefreshAura(SPELLDMG2); //+6%
+            if (level >= 45)
+                RefreshAura(NATURAL_PERFECTION3); //4%
+            else if (level >= 43)
+                RefreshAura(NATURAL_PERFECTION2); //3%
+            else if (level >= 41)
+                RefreshAura(NATURAL_PERFECTION1); //2%
+            if (level >= 50)
+                RefreshAura(LIVING_SEED3); //100%
+            else if (level >= 48)
+                RefreshAura(LIVING_SEED2); //66%
+            else if (level >= 46)
+                RefreshAura(LIVING_SEED1); //33%
+            if (level >= 55)
+                RefreshAura(REVITALIZE3, 5); //75% (15%)x5
+            else if (level >= 53)
+                RefreshAura(REVITALIZE2, 3); //30% (10%)x3
+            else if (level >= 51)
+                RefreshAura(REVITALIZE1, 3); //15%  (5%)x3
+            if (level >= 70)
+                RefreshAura(OMEN_OF_CLARITY, 3); //x3
+            else if (level >= 40)
+                RefreshAura(OMEN_OF_CLARITY, 2); //x2
+            else if (level >= 20)
+                RefreshAura(OMEN_OF_CLARITY); //x1
+            if (level >= 45)
+                RefreshAura(GLYPH_SWIFTMEND); //no comsumption
+            if (level >= 40)
+                RefreshAura(GLYPH_INNERVATE); //no comsumption
+            if (level >= 20)
+                RefreshAura(NATURESGRACE);
+            if (level >= 78)
+            {
+                RefreshAura(T9_RESTO_P4_BONUS);
+                RefreshAura(T8_RESTO_P4_BONUS);
+                RefreshAura(T9_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P4_BONUS);
+            }
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case CURE_POISON_1:
+                case INNERVATE_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Timers/other
+/*Heal*/uint32 Heal_Timer;
+/*Misc*/uint32 formtimer, ragetimer, ragetimer2;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power; uint32 mana, rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211,
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAERIE_FIRE_1                       = 770,
+            CURE_POISON_1                       = 8946,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            REVITALIZE3                         = 48545,//rank 3
+  /*Talent*/LEADER_OF_THE_PACK                  = 24932,
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434 //50% spell crit
+        };
+        enum DruidSpecial
+        {
+            HURRICANE_DAMAGE                    = 42231,
+  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
+            //NATURESGRACEBUFF                    = 16886,
+            OMEN_OF_CLARITY_BUFF                = 16870 //434 deprecated
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..75fabbd
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,1167 @@
+#include "bot_ai.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 35%
+TODO:
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = NULL;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                target = FindCastingTarget(15, 0, false, GetSpell(SCATTER_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff, true, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(WYVERN_STING_1));
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                {
+                    SetSpellCooldown(WYVERN_STING_1, 40000);
+                    return;
+                }
+            }
+            //if (!target && FREEZING_ARROW && Trap_cd <= 10000 && Rand() < 40)
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW);
+            //    temptimer = GC_Timer;
+            //    if (target && doCast(target, FREEZING_ARROW))
+            //    {
+            //        Trap_cd = 20000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            if (!target && IsSpellReady(SCARE_BEAST_1, diff, true, 7500) && Rand() < 35)
+            {
+                target = FindCastingTarget(30, 0, false, GetSpell(SCARE_BEAST_1));
+                if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+                {
+                    SetSpellCooldown(SCARE_BEAST_1, 15000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false, 7500) && Rand() < 30)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(SILENCING_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    SetSpellCooldown(SILENCING_SHOT_1, 15000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(15))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCATTER_SHOT_1, 1000); //fail
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(35))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                {
+                    SetSpellCooldown(WYVERN_STING_1, 40000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(WYVERN_STING_1, 1000); //fail
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with traps
+            if (!GetSpell(FREEZING_ARROW_1) || Trap_cd > diff || IsCasting() || Rand() > 75)
+                return;
+
+            if (Unit* target = FindStunTarget(40))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 1000; //fail
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (!GetSpell(FROST_TRAP_1) || Trap_cd > diff || IsCasting() || Rand() > 90)
+                return;
+
+            Unit* target = me->GetVictim();
+            if (!(target && me->GetDistance(target) < 6 && me->HasInArc(M_PI, target) &&
+                IsInBotParty(target->GetVictim())))
+                target = NULL;
+            if (!target)
+                target = FindAOETarget(3.f, true);
+
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FROST_TRAP_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 500; //fail
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 35)
+                return;
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1), true))
+                {
+                    SetSpellCooldown(SCARE_BEAST_1, 15000); //-50% for bot
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void CheckAspects(uint32 diff)
+        {
+            if (Aspect_Timer > diff || GC_Timer > diff || IsCasting() || Feasting() || Rand() > 35)
+                return;
+
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            if (!ASPECT_OF_THE_VIPER && !ASPECT_OF_THE_PACK)
+                return;
+
+            uint32 needaspect = 0;
+            uint8 pct = GetManaPCT(me);
+
+            if (ASPECT_OF_THE_VIPER && pct < 25)
+                needaspect = ASPECT_OF_THE_VIPER;
+            else if (ASPECT_OF_THE_PACK && (pct > 70 || !Aspect))
+                needaspect = ASPECT_OF_THE_PACK;
+
+            if (!needaspect || (needaspect == Aspect && HasAuraName(me, needaspect)))
+            {
+                Aspect_Timer = 2000;
+                return;
+            }
+
+            if (Aspect)
+                me->RemoveAurasDueToSpell(Aspect);
+
+            if (doCast(me, needaspect))
+            {
+                Aspect = needaspect;
+                GC_Timer = 800;
+                return;
+            }
+        }
+
+        void doDefend(uint32 diff)
+        {
+            //No GCD abilities
+            if (!IsSpellReady(FEIGN_DEATH_1, diff, false) && !IsSpellReady(DETERRENCE_1, diff, false))
+                return;
+            if (IsTank() || Rand() > 35)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                {
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                    {
+                        cast = true;
+                        //need feign death
+                        SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), diff + 500));
+                    }
+                }
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast || b_attackers.empty())
+            {
+                //delay next try
+                SetSpellCooldown(FEIGN_DEATH_1, std::max<uint32>(GetSpellCooldown(FEIGN_DEATH_1), 1000));
+                SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), 1000));
+                return;
+            }
+
+            if (IsSpellReady(FEIGN_DEATH_1, diff, false) && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                {
+                    SetSpellCooldown(FEIGN_DEATH_1, 20000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(DETERRENCE_1, diff, false))
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                {
+                    SetSpellCooldown(DETERRENCE_1, 60000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckAutoShot()
+        {
+            //Auto Shot is always present
+            //if (!AUTO_SHOT)
+            //    return;
+
+            Unit* target = me->GetVictim();
+            if (!target)
+                return;
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsCasting())
+                return;
+
+            if (Spell* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id != AUTO_SHOT_1)
+                {
+                    ////casting some other autorepeat spell, wtf?
+                    //TC_LOG_ERROR("entities.player", "CheckAutoShot(): Bot %s is casting autorepeatable spell %u (%s) during check!",
+                    //    me->GetName().c_str(), shot->GetSpellInfo()->Id, shot->GetSpellInfo()->SpellName[0]);
+                    return;
+                }
+                else if (shot->m_targets.GetUnitTarget() != target)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+
+            float dist = me->GetExactDist(target);
+            if (dist < 5 || dist > 35)
+                return;
+
+            temptimer = GC_Timer;
+            if (doCast(target, AUTO_SHOT_1))
+            {
+                GC_Timer = temptimer;
+                return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff, false) || Rand() > 35) //No GCD
+                return;
+
+            //First check current target
+            Unit* target = me->GetVictim();
+            if (target)
+            {
+                Unit::AuraMap const &auras = target->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                {
+                    SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(target->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        temptimer = GC_Timer;
+                        //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                        if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                        {
+                            SetSpellCooldown(TRANQ_SHOT_1, 6000); //with glyph
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+
+            target = FindTranquilTarget();
+            if (target)
+            {
+                temptimer = GC_Timer;
+                //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                {
+                    SetSpellCooldown(TRANQ_SHOT_1, 6000); //with glyph
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(TRANQ_SHOT_1, 2000); //fail
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (!IsSpellReady(SILENCING_SHOT_1, diff, false) || IsCasting() || Rand() > 50) //No GCD
+                return;
+
+            Unit* target = me->GetVictim();
+            if (target && target->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    SetSpellCooldown(SILENCING_SHOT_1, 15000); //-5 sec for bot
+                    GC_Timer = temptimer;
+                    //return;
+                }
+
+                return; //succeed or failed, our hightest priority target casts spell and it must be interrupted above all else
+            }
+
+            target = FindCastingTarget(35, 5);
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    SetSpellCooldown(SILENCING_SHOT_1, 15000); //-5 sec for bot
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SILENCING_SHOT_1, 1000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (GetManaPCT(me) < 40 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Deterrence check
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+            {
+                if (!me->isMoving())
+                    GetInPosition(true);
+                return;
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckTranquil(diff);
+                CheckSilence(diff);
+            }
+
+            if (!CheckAttackTarget(CLASS_HUNTER))
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            CheckAutoShot();
+            CheckScare(diff);
+            CheckScatter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //special
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist < 15 && Rand() < 60)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    SetSpellCooldown(SCATTER_SHOT_1, 20000);
+                    GC_Timer = temptimer;
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    return;
+                }
+            }
+
+            //MELEE SECTION
+            if (!(meleedist > 5))
+            {
+                //TRAPS
+                CheckTraps(diff);
+
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1), true))
+                    {
+                        SetSpellCooldown(RAPTOR_STRIKE_1, 6000);
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
+                    Rand() < 80 && !opponent->HasAuraWithMechanic(/*(1<<MECHANIC_SNARE)|*/(1<<MECHANIC_ROOT)))
+                {
+                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
+                    {
+                        GC_Timer = 1000;
+                        return;
+                    }
+                }
+                //DISENGAGE
+                if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() &&
+                    !me->getAttackers().empty() && me->HasInArc(M_PI, *me->getAttackers().begin()) && Rand() < 30)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(DISENGAGE_1)))
+                    {
+                        SetSpellCooldown(DISENGAGE_1, 16000); //improved, with glyph
+                        GC_Timer = temptimer;
+                    }
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK
+            if (IsSpellReady(HUNTERS_MARK_1, diff, false) && Rand() < 25 &&
+                !HasAuraName(opponent, HUNTERS_MARK_1)) //100 yd range so don't check it
+            {
+                //Hunter's Mark has exclusive GCD
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
+                {
+                    markTarget = opponent;
+                    SetSpellCooldown(HUNTERS_MARK_1, 2000); //1500 + 500 for bot
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+
+            //FREEZING ARROW
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //attack range check 1
+            if (!(meleedist < 45))
+                return;
+
+            //KILL SHOT //No GCD
+            if (IsSpellReady(KILL_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && GetHealthPCT(opponent) < 20 && Rand() < 95)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
+                {
+                    SetSpellCooldown(KILL_SHOT_1, 8000); //with glyph
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            //attack range check 2
+            if (!(meleedist < 35))
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
+                {
+                    SetSpellCooldown(CONCUSSIVE_SHOT_1, 10000); //improved
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //DISTRACTING SHOT
+            if (Unit* u = opponent->GetVictim())
+            {
+                if (IsSpellReady(DISTRACTING_SHOT_1, diff, false) && IsTank() && u != me && !CCed(opponent) &&
+                    Rand() < 75 && IsInBotParty(u))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
+                    {
+                        SetSpellCooldown(DISTRACTING_SHOT_1, 8000);
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+            //BLACK ARROW //custom cd condition
+            //Black Arrow shares cooldown with traps, but we'll have it only partially
+            if (IsSpellReady(BLACK_ARROW_1, diff) && Trap_cd <= 10000 && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < 75)
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                {
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 2 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                {
+                    SetSpellCooldown(RAPID_FIRE_1, 90000); //1.5 min for bot
+                    GC_Timer = temptimer;
+                }
+            }
+            //EXPLOSIVE SHOT
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
+                {
+                    SetSpellCooldown(EXPLOSIVE_SHOT_1, 6000);
+                    return;
+                }
+
+                SetSpellCooldown(EXPLOSIVE_SHOT_1, 500); //fail
+            }
+            //SCORPID STING //custom cd condition
+            if (uint32 SCORPID_STING = GetSpell(SCORPID_STING_1))
+            {
+                if (GC_Timer <= diff && (ScorpidSting_Timer <= diff || stingTargetGuid != opponent->GetGUID()))
+                {
+                    Aura* sSting = opponent->GetAura(SCORPID_STING);
+                    if (sSting && sSting->GetDuration() > 3000)
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        SetSpellCooldown(SCORPID_STING_1, 2000);
+                    }
+                    else if (Rand() < 40 && doCast(opponent, SCORPID_STING))
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        SetSpellCooldown(SCORPID_STING_1, 18000);
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+            }
+            //CHIMERA SHOT TODO:
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && stingTargetGuid == opponent->GetGUID() &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                {
+                    SetSpellCooldown(CHIMERA_SHOT_1, 9000); //with glyph
+                    return;
+                }
+            }
+            //MULTI-SHOT
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 60)
+            {
+                if (Unit* target = FindSplashTarget(35, opponent))
+                {
+                    if (doCast(target, GetSpell(MULTISHOT_1)))
+                    {
+                        SetSpellCooldown(MULTISHOT_1, 8000); //with glyph
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(MULTISHOT_1, 1000); //fail
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 25)
+            {
+                if (Unit* target = FindAOETarget(35, true, false))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                    {
+                        SetSpellCooldown(VOLLEY_1, 5000);
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(VOLLEY_1, 1000); //fail
+            }
+            //AIMED SHOT
+            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
+                {
+                    SetSpellCooldown(AIMED_SHOT_1, 8000); //with glyph
+                    return;
+                }
+            }
+            //ARCANE SHOT
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
+                {
+                    SetSpellCooldown(ARCANE_SHOT_1, 6000);
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+                if (lvl >= 40 && spellId == GetSpell(AIMED_SHOT_1))
+                    aftercrit += 10.f;
+                //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+                if (lvl >= 40 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1)))
+                    aftercrit += 12.f;
+                //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+                if (lvl >= 15 && (spellId == GetSpell(ARCANE_SHOT_1)/* || spellId == GetSpell(STEADY_SHOT_1)*/ || spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+                    aftercrit += 4.f;
+                //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+                if (lvl >= 50 && spellId == GetSpell(KILL_SHOT_1))
+                    aftercrit += 15.f;
+                //Point of No Escape: 6% additional critical chance on victims of any kind of frost trap (crew this condition)
+                if (lvl >= 50)
+                    aftercrit += 6.f;
+
+                //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+                if (lvl >= 10 && (spellId == GetSpell(RAPTOR_STRIKE_1)/* || spellId == GetSpell(MONGOOSE_BITE_1) || spellId == GetSpell(COUNTERATTACK_1)*/))
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && attackType == RANGED_ATTACK)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if (lvl >= 55 &&
+                    (spellId == GetSpell(AIMED_SHOT_1) ||
+                    spellId == GetSpell(ARCANE_SHOT_1) ||
+                    //spellId == GetSpell(STEADY_SHOT_1) ||
+                    spellId == GetSpell(KILL_SHOT_1) ||
+                    spellId == GetSpell(CHIMERA_SHOT_1)))
+                    pctbonus += 0.05f;
+            }
+
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if (lvl >= 35 && attackType == RANGED_ATTACK)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && spellId == GetSpell(ARCANE_SHOT_1))
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1)) &&
+                me->HasAura(RAPID_KILLING_BUFF))
+                pctbonus += 0.2f;
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley (removed in SpellHitTarget())
+            if (lvl >= 30 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1) ||
+                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(VOLLEY_DAMAGE_1))))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if (lvl >= 55 && attackType == RANGED_ATTACK && damageinfo.target == markTarget)
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot (handled here) and Black Arrow (can be handler in ApplyClassDamageMultiplierEffect())
+            if (lvl >= 25 && spellId == GetSpell(EXPLOSIVE_SHOT_1))
+                pctbonus += 0.06f;
+            //Sniper Training (part 2): 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot (screw aura stuff, just increase)
+            if (lvl >= 50 &&
+                (spellId == GetSpell(AIMED_SHOT_1) ||
+                //spellId == GetSpell(STEADY_SHOT_1) ||
+                //spellId == GetSpell(BLACK_ARROW_1) ||//cannot be handled here
+                spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value (50%) while ability crits
+            if (lvl >= 40)
+                (static_cast<ManaRestoreList>(TotH))[spellId] = crit && attackType == RANGED_ATTACK ? spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()) / 2 : 0;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (target == me)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value while ability crits
+            if (me->getLevel() >= 40 && TotH[spellId] > 0 && uint32(TotH[spellId]) < me->GetMaxPower(POWER_MANA))
+            {
+                me->EnergizeBySpell(me, THRILL_OF_THE_HUNT_EFFECT, TotH[spellId], POWER_MANA);
+                TotH[spellId] = 0;
+            }
+
+            if (spellId == GetSpell(WING_CLIP_1))
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (spellId == GetSpell(CONCUSSIVE_SHOT_1))
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+
+            //Rapid Killing: use up buff manually
+            if (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1))
+            {
+                if (me->HasAura(RAPID_KILLING_BUFF))
+                    me->RemoveAura(RAPID_KILLING_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(RAPID_FIRE_1))
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                if (Aura* rapid = me->GetAura(spellId))
+                {
+                    uint32 dur = rapid->GetDuration() + 4000;
+                    rapid->SetDuration(dur);
+                    rapid->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Trap_cd = 0;
+
+            ScorpidSting_Timer = 0;
+            Aspect_Timer = 0;
+
+            Aspect = 0;
+
+            stingTargetGuid = 0;
+
+            markTarget = NULL;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_HUNTER);
+             }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (Trap_cd > diff)                     Trap_cd -= diff;
+
+            if (ScorpidSting_Timer > diff)          ScorpidSting_Timer -= diff;
+            if (Aspect_Timer > diff)                Aspect_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(AUTO_SHOT_1, true);
+            InitSpellMap(TRANQ_SHOT_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SCORPID_STING_1);
+            //InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+            InitSpellMap(DETERRENCE_1);
+            //InitSpellMap(ASPECT_OF_THE_VIPER_1);
+  /*Custom*///ASPECT_OF_THE_PACK                      = ASPECT_OF_THE_VIPER ? ASPECT_OF_THE_PACK_1 : 0;
+  /*Custom*/lvl >= 20 ? InitSpellMap(ASPECT_OF_THE_PACK_1, true) : RemoveSpell(ASPECT_OF_THE_PACK_1);
+            //InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 20)
+                RefreshAura(RAPID_KILLING); //20%
+            if (level >= 30)
+                RefreshAura(CONCUSSIVE_BARRAGE); //100%
+            if (level >= 40)
+                RefreshAura(PIERCING_SHOTS); //30%
+            if (level >= 40)
+                RefreshAura(TRUESHOT_AURA); //10%
+            if (level >= 45)
+                RefreshAura(RAPID_RECUPERATION); //4%
+            if (level >= 45)
+                RefreshAura(MASTER_MARKSMAN); //5%
+            if (level >= 70)
+                RefreshAura(WILD_QUIVER,3); //36%
+            else if (level >= 60)
+                RefreshAura(WILD_QUIVER,2); //24%
+            else if (level >= 50)
+                RefreshAura(WILD_QUIVER); //12%
+            if (level >= 15)
+                RefreshAura(SUREFOOTED); //30%
+            if (level >= 15)
+                RefreshAura(ENTRAPMENT); //4 sec
+            if (level >= 67)
+                RefreshAura(MASTER_TACTICIAN5,3); //30%
+            else if (level >= 58)
+                RefreshAura(MASTER_TACTICIAN5,2); //20%
+            else if (level >= 50)
+                RefreshAura(MASTER_TACTICIAN5); //10%
+            else if (level >= 49)
+                RefreshAura(MASTER_TACTICIAN4); //8%
+            else if (level >= 48)
+                RefreshAura(MASTER_TACTICIAN3); //6%
+            else if (level >= 47)
+                RefreshAura(MASTER_TACTICIAN2); //4%
+            else if (level >= 46)
+                RefreshAura(MASTER_TACTICIAN1); //2%
+            if (level >= 45)
+                RefreshAura(NOXIOUS_STINGS); //50%
+            if (level >= 55)
+                RefreshAura(HUNTING_PARTY); //100%
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case RAPID_FIRE_1:
+                case FROST_TRAP_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_VIPER_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef UNORDERED_MAP<uint32 /*spellId*/, int32 /*manaCost*/> ManaRestoreList;
+        ManaRestoreList TotH;
+        uint32 Trap_cd;
+        uint32 ScorpidSting_Timer, Aspect_Timer;
+        uint32 Aspect;
+        uint64 stingTargetGuid;
+        Unit* markTarget;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SILENCING_SHOT_1                    = 34490,
+            CHIMERA_SHOT_1                      = 53209,
+            ARCANE_SHOT_1                       = 3044,
+            AIMED_SHOT_1                        = 19434,
+            KILL_SHOT_1                         = 53351,
+            EXPLOSIVE_SHOT_1                    = 53301,
+            MULTISHOT_1                         = 2643,
+            VOLLEY_1                            = 1510,
+            SCATTER_SHOT_1                      = 1991,
+            CONCUSSIVE_SHOT_1                   = 5116,
+            DISTRACTING_SHOT_1                  = 20736,
+            SCORPID_STING_1                     = 3043,
+            //VIPER_STING_1                       = 3034,
+            RAPID_FIRE_1                        = 3045,
+            WING_CLIP_1                         = 2974,
+            RAPTOR_STRIKE_1                     = 2973,
+            DISENGAGE_1                         = 781,
+            FROST_TRAP_1                        = 13809,
+            FREEZING_ARROW_1                    = 60192,
+            WYVERN_STING_1                      = 19386,
+            BLACK_ARROW_1                       = 3674,
+            HUNTERS_MARK_1                      = 1130,
+            SCARE_BEAST_1                       = 1513,
+            FEIGN_DEATH_1                       = 5384,
+            DETERRENCE_1                        = 19263,
+            ASPECT_OF_THE_PACK_1                = 36613,//Aspect of the Spirit Hunter
+            ASPECT_OF_THE_VIPER_1               = 34074
+            //ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+        };
+
+        enum HunterPassives
+        {
+        //Talents
+            RAPID_KILLING                       = 34949,//rank 2
+            CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+            PIERCING_SHOTS                      = 53238,//rank 3
+            TRUESHOT_AURA                       = 19506,
+            RAPID_RECUPERATION                  = 53232,//rank 2
+            MASTER_MARKSMAN                     = 34489,//rank 5
+            WILD_QUIVER                         = 53217,//rank 3
+            SUREFOOTED                          = 24283,//rank 3
+            ENTRAPMENT                          = 19388,//rank 3
+            MASTER_TACTICIAN1                   = 34506,
+            MASTER_TACTICIAN2                   = 34507,
+            MASTER_TACTICIAN3                   = 34508,
+            MASTER_TACTICIAN4                   = 34838,
+            MASTER_TACTICIAN5                   = 34839,
+            NOXIOUS_STINGS                      = 53297,//rank 3
+            HUNTING_PARTY                       = 53292 //rank 3
+        };
+
+        enum HunterSpecial
+        {
+            IMPROVED_CONCUSSION                 = 28445,
+            IMPROVED_WING_CLIP_NORMAL           = 47168,
+            IMPROVED_WING_CLIP_EX               = 35963,
+
+            RAPID_KILLING_BUFF                  = 35099,//rank 2
+            THRILL_OF_THE_HUNT_EFFECT           = 34720,
+            FROST_TRAP_AURA                     = 13810,
+            FREEZING_ARROW_EFFECT               = 60210,
+            //FREEZING_TRAP_EFFECT_1              = 3355,
+            //FREEZING_TRAP_EFFECT_2              = 14308,
+            //FREEZING_TRAP_EFFECT_3              = 14309,
+            VOLLEY_DAMAGE_1                     = 42243 //rank 1
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..c565956
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,1007 @@
+#include "bot_ai.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                if (cost)
+                    clearcast = true;
+            }
+
+            return result;
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void Counter()
+        {
+            Unit* u = me->GetVictim();
+            bool cSpell = IsSpellReady(COUNTERSPELL_1, NULL, false, 5000);
+            bool blast = IsSpellReady(FIREBLAST_1, NULL, false, 3000) && HasRole(BOT_ROLE_DPS) && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCasted(false) &&
+                ((cSpell && me->GetDistance(u) < 30) || (blast && me->GetDistance(u) < 30)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, GetSpell(COUNTERSPELL_1)))
+                    SetSpellCooldown(COUNTERSPELL_1, 15000);
+                else if (blast && doCast(u, GetSpell(FIREBLAST_1)))
+                    SetSpellCooldown(FIREBLAST_1, 6000);
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCasted(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                    {
+                        SetSpellCooldown(COUNTERSPELL_1, 15000);
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 25) return;
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting())
+                return;
+
+            if (uint32 DAMPENMAGIC = GetSpell(DAMPENMAGIC_1))
+            {
+                if (!HasAuraName(me, DAMPENMAGIC) &&
+                    doCast(me, DAMPENMAGIC))
+                    return;
+            }
+
+            if (ICEARMOR && !HasAuraName(me, ICEARMOR) &&
+                doCast(me, ICEARMOR))
+                return;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+
+            if (uint32 ARCANEINTELLECT = GetSpell(ARCANEINTELLECT_1))
+            {
+                if (target->getPowerType() == POWER_MANA && !HasAuraName(target, ARCANEINTELLECT) &&
+                    doCast(target, ARCANEINTELLECT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me) && (!GetSpell(ICEBLOCK_1) || !me->HasAura(GetSpell(ICEBLOCK_1)))) return; //TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureGroup(master, GetSpell(REMOVE_CURSE_1), diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit* u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            uint32 ICE_BARRIER = GetSpell(ICE_BARRIER_1);
+            if (IsSpellReady(ICE_BARRIER_1, diff, false) && u && u->GetVictim() == me && u->GetDistance(me) < 8 &&
+                !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    SetSpellCooldown(ICE_BARRIER_1, 25000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!IsSpellReady(ICE_BARRIER_1, diff, false) &&
+                IsSpellReady(BLINK_1, diff, false, 3000) && u && u->GetVictim() == me &&
+                u->GetDistance(me) < 6 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    SetSpellCooldown(BLINK_1, 13000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //ICEBLOCK
+            if (uint32 ICEBLOCK = GetSpell(ICEBLOCK_1))
+            {
+                if (IsSpellReady(ICEBLOCK_1, diff, false, 57000))
+                {
+                    if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) &&
+                        me->HasAura(ICEBLOCK))
+                        me->RemoveAurasDueToSpell(ICEBLOCK);
+                }
+
+                if (IsSpellReady(ICEBLOCK_1, diff, false) && !b_attackers.empty() && Rand() < 50 &&
+                    (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) &&
+                    !me->HasAura(ICEBLOCK))
+                {
+                    if (me->IsNonMeleeSpellCasted(true))
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(me, ICEBLOCK))
+                    {
+                        SetSpellCooldown(ICEBLOCK_1, 60000);
+                        Nova_cd = 0; //Glyph of Iceblock
+                        return;
+                    }
+                }
+            }
+
+            if (IsCasting()) return;
+
+            float dist = me->GetExactDist(opponent);
+
+            uint32 FROSTBOLT = GetSpell(FROSTBOLT_1);
+            uint32 FIREBALL = GetSpell(FIREBALL_1);
+            uint32 BLASTWAVE = GetSpell(BLASTWAVE_1);
+            uint32 FROSTNOVA = GetSpell(FROSTNOVA_1);
+            BOLT = (CCed(opponent, true) || !FROSTBOLT) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FROSTBOLT && BLASTWAVE && dist > 5 ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            if (IsSpellReady(COMBUSTION_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*6 ||
+                m_attackers.size() > 1 || b_attackers.size() > 2) &&
+                Rand() < 15 && !HasAuraName(me, COMBUSTION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                {
+                    SetSpellCooldown(COMBUSTION_1, 60000);
+                    GC_Timer = temptimer;
+                    //Reset timers for fun
+                    ResetSpellCooldown(FIREBLAST_1);
+                    ResetSpellCooldown(DRAGONBREATH_1);
+                    Nova_cd = 0;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (IsSpellReady(PYROBLAST_1, diff) && opponent->IsPolymorphed() && HasRole(BOT_ROLE_DPS) &&
+                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent) &&
+                dist < 35 && Rand() < 75 &&
+                doCast(opponent, GetSpell(PYROBLAST_1)))
+            {
+                SetSpellCooldown(PYROBLAST_1, 7500);
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), uint32(float(sSpellMgr->GetSpellInfo(GetSpell(PYROBLAST_1))->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 400)));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(6.3f);
+            if (NOVA && Nova_cd <= diff && HasRole(BOT_ROLE_DPS) && u && Rand() < 75 && !CCed(u, true) && IsInBotParty(u->GetVictim()))
+            {
+                if (doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    GetInPosition(true);
+                    return;
+                }
+            }
+            //living bomb
+            if (IsSpellReady(LIVINGBOMB_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 35 && opponent->GetHealth() > me->GetHealth()/2 &&
+                Rand() < 45 && !HasAuraName(opponent, LIVINGBOMB_1, me->GetGUID()) &&
+                doCast(opponent, GetSpell(LIVINGBOMB_1)))
+            {
+                SetSpellCooldown(LIVINGBOMB_1, 6000);
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (IsSpellReady(CONEOFCOLD_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 50 &&
+                me->HasInArc(M_PI*0.75f, opponent) &&
+                doCast(opponent, GetSpell(CONEOFCOLD_1)))
+            {
+                SetSpellCooldown(CONEOFCOLD_1, 8000);
+                GC_Timer = 500;
+                GetInPosition(true);
+                return;
+            }
+            //dragon's breath
+            if (IsSpellReady(DRAGONBREATH_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) &&
+                ((me->HasInArc(M_PI*0.75f, opponent) && dist < 7) ||
+                (u && u != opponent && me->HasInArc(M_PI*0.75f, u) && IsInBotParty(u->GetVictim()))) &&
+                doCast(me, GetSpell(DRAGONBREATH_1)))
+            {
+                SetSpellCooldown(DRAGONBREATH_1, 25000);
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) &&
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) &&
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (IsSpellReady(FIREBLAST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                Rand() < 20 + 80*(!opponent->isFrozen() && !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(FIREBLAST_1)))
+                {
+                    SetSpellCooldown(FIREBLAST_1, 6000);
+                    GC_Timer = 500;
+                    return;
+                }
+            }
+            //flamestrike - use Improved Flamestrike for instant cast
+            if (IsSpellReady(FLAMESTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->HasAura(FIRESTARTERBUFF) && Rand() < 25)
+            {
+                Unit* FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, GetSpell(FLAMESTRIKE_1), true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 300;
+                    return;
+                }
+            }
+            //blizzard
+            if (IsSpellReady(BLIZZARD_1, diff, false) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 40)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                {
+                    SetSpellCooldown(BLIZZARD_1, 5000);
+                    return;
+                }
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Frost or Fire Bolt
+            if (BOLT && Bolt_cd <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 75 &&
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), Bolt_cd + 200));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //Arcane Missiles
+            if (IsSpellReady(ARCANEMISSILES_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && dist < 20 && Rand() < 15 &&
+                doCast(opponent, GetSpell(ARCANEMISSILES_1)))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500 && GetSpell(POLYMORPH_1))
+            {
+                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 35 && Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff, false) && !me->isMoving() && me->getAttackers().empty() &&
+                    doCast(me, GetSpell(EVOCATION_1)))
+                {
+                    SetSpellCooldown(EVOCATION_1, 60000);
+                    return;
+                }
+                if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                    {
+                        Potion_cd = POTION_CD;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted()) return;
+            if (!IsSpellReady(BLINK_1, diff, false) || me->getLevel() < 20 || IsCasting()) return;
+
+            if (!me->IsInCombat() && me->GetExactDist(master) > std::max<uint8>(master->GetBotFollowDist(), 35) &&
+                me->HasInArc(M_PI*0.75f, master))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    SetSpellCooldown(BLINK_1, 13000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist(master) > 15)
+            {
+                if (Unit* op = me->SelectNearestTarget(7))
+                {
+                    if (op->GetVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLINK_1)))
+                        {
+                            SetSpellCooldown(BLINK_1, 13000);
+                            GC_Timer = temptimer;
+                        }
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || me->getLevel() < 20 || IsCasting() || Rand() < 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUSMAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 2))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                    target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || pPlayer->IsInWorld() || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->getPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            for (uint8 i = 0; i != pPlayer->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pPlayer->GetBotMap(i)->_Cre();
+                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
+                                if (cre->getPowerType() == POWER_MANA && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Combustion: 10% per stack
+                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                        aftercrit += float(combustion->GetStackAmount()*10);
+                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+                if (lvl >= 10 &&
+                    (spellId == GetSpell(FIREBLAST_1) ||
+                    spellId == GetSpell(CONEOFCOLD_1)/* ||
+                    spellId == ARCANEBLAST ||
+                    spellId == SCORCH*/))
+                    aftercrit += 6.f;
+                //World In Flames: 6% additional critical chance for
+                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(FLAMESTRIKE_1) ||
+                    spellId == GetSpell(PYROBLAST_1) ||
+                    spellId == GetSpell(BLASTWAVE_1) ||
+                    spellId == GetSpell(DRAGONBREATH_1)/* ||
+                    spellId == ARCANEXPLOSION ||
+                    spellId == LIVINGBOMB ||    //cannot be handled here
+                    spellId == BLIZZARD*/))    //cannot be handled here
+                    aftercrit += 6.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == GetSpell(CONEOFCOLD_1))
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (aftercastTargetGuid != 0)
+            {
+                //only players for now
+                if (!IS_PLAYER_GUID(aftercastTargetGuid))
+                {
+                    aftercastTargetGuid = 0;
+                    return;
+                }
+
+                Player* pTarget = sObjectAccessor->FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid = 0;
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUIDLow());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            //Winter Veil addition
+            uint32 spellId = spell->Id;
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                if (spellId == GetSpell(FROSTBOLT_1) && urand(1,100) <= 10)
+                    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = 0;
+            NOVA = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_MAGE);
+           }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (Bolt_cd > diff)                     Bolt_cd -= diff;
+            if (Nova_cd > diff)                     Nova_cd -= diff;
+
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            //InitSpellMap(INVISIBILITY_1);
+            InitSpellMap(FIREBALL_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLASTWAVE_1) : RemoveSpell(BLASTWAVE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(DRAGONBREATH_1) : RemoveSpell(DRAGONBREATH_1);
+            InitSpellMap(FIREBLAST_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(LIVINGBOMB_1) : RemoveSpell(LIVINGBOMB_1);
+            InitSpellMap(DAMPENMAGIC_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROSTNOVA_1);
+            InitSpellMap(CONEOFCOLD_1);
+            InitSpellMap(BLIZZARD_1);
+ /*Special*/ICEARMOR = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+            InitSpellMap(ICEBLOCK_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUSMAGIC_1) : RemoveSpell(FOCUSMAGIC_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //Dam+(-Hit)
+            if (level >= 50)
+                RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
+            else if (level >= 25)
+                RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
+            else if (level >= 10)
+                RefreshAura(ARCTIC_WINDS); //+5%/-5%
+            //CHILL
+            if (level >= 30)
+                RefreshAura(WINTERS_CHILL3); //100%
+            else if (level >= 25)
+                RefreshAura(WINTERS_CHILL2); //66%
+            else if (level >= 20)
+                RefreshAura(WINTERS_CHILL1); //33%
+            //Imp Blizzard
+            if (level >= 20)
+                RefreshAura(IMPROVED_BLIZZARD); //50% slow
+            //Frostbite
+            if (level >= 80)
+                FROSTBITE = FROSTBITE3;
+            else if (level >= 50)
+                FROSTBITE = FROSTBITE2;
+            else if (level >= 10)
+                FROSTBITE = FROSTBITE1;
+            if (level >= 60)
+                RefreshAura(FROSTBITE,3); //3x
+            else if (level >= 30)
+                RefreshAura(FROSTBITE,2); //2x
+            else if (level >= 10)
+                RefreshAura(FROSTBITE); //1x
+            //Shattered Barrier
+            if (level >= 45)
+                RefreshAura(SHATTERED_BARRIER);
+            //Bonus
+            if (level >= 65)
+                RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
+            else if (level >= 55)
+                RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
+            else if (level >= 45)
+                RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
+            else if (level >= 35)
+                RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
+            //Absorb
+            if (level >= 50)
+                RefreshAura(INCANTERS_ABSORPTION3);
+            else if (level >= 45)
+                RefreshAura(INCANTERS_ABSORPTION2);
+            else if (level >= 40)
+                RefreshAura(INCANTERS_ABSORPTION1);
+            //Shatter
+            if (level >= 35)
+                RefreshAura(SHATTER3);
+            else if (level >= 30)
+                RefreshAura(SHATTER2);
+            else if (level >= 25)
+                RefreshAura(SHATTER1);
+            //ClearCasting
+            if (level >= 75)
+                RefreshAura(CLEARCAST,3); //30%
+            else if (level >= 40)
+                RefreshAura(CLEARCAST,2); //20%
+            else if (level >= 15)
+                RefreshAura(CLEARCAST); //10%
+            //Fingers
+            if (level >= 45)
+                RefreshAura(FINGERS_OF_FROST); //15%
+            //Potency
+            if (level >= 40)
+                RefreshAura(ARCANE_POTENCY2); //30% bonus
+            else if (level >= 35)
+                RefreshAura(ARCANE_POTENCY1); //15% bonus
+            //Ignite
+            if (level >= 15)
+                RefreshAura(IGNITE);
+            //Impact
+            if (level >= 60)
+                RefreshAura(IMPACT,2);
+            else if (level >= 20)
+                RefreshAura(IMPACT);
+            //Imp. Counterspell
+            if (level >= 35)
+                RefreshAura(IMPROVED_COUNTERSPELL2); //4 sec
+            else if (level >= 25)
+                RefreshAura(IMPROVED_COUNTERSPELL1); //2 sec
+            //Firestarter
+            if (level >= 55)
+                RefreshAura(FIRESTARTER2); //100% chance
+            else if (level >= 45)
+                RefreshAura(FIRESTARTER1); //50% chance
+            //Spells
+            if (GetSpell(LIVINGBOMB_1))
+                RefreshAura(GLYPH_LIVING_BOMB);
+            if (GetSpell(POLYMORPH_1))
+                RefreshAura(GLYPH_POLYMORPH);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUSMAGIC_1:
+                case FROSTARMOR_1:
+                case ICEARMOR_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 ICEARMOR;
+/*exc.*/uint32 BOLT, NOVA;
+/*exc.*/uint32 FROSTBITE;
+        //Timers
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells
+        {
+            DAMPENMAGIC_1                       = 604,
+            ARCANEINTELLECT_1                   = 1459,
+            ARCANEMISSILES_1                    = 5143,
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646
+        };
+
+        enum MagePassives
+        {
+        //Talents
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+        //Special
+            GLYPH_POLYMORPH                     = 56375
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..66847b8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,1125 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45-50%
+TODO: Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void HOFGroup(Player* pTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOF_1, diff) || IsCasting() || Rand() > 60)
+                return;
+
+            if (Group* pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = tPlayer->GetBotMap(i)->_Cre();
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOF_1, diff)) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF_1)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura* aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, GetSpell(HOF_1)))
+                    {
+                        if (target->ToCreature())
+                            SetSpellCooldown(HOF_1, 10000); //10 sec for selfcast after stun
+                        else
+                            SetSpellCooldown(HOF_1, 15000); //improved
+                        return true;
+                    }
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) ||
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = GetSpell(CLEANSE_1) &&
+                        (spellInfo->Dispel == DISPEL_MAGIC ||
+                        spellInfo->Dispel == DISPEL_DISEASE ||
+                        spellInfo->Dispel == DISPEL_POISON) ? GetSpell(CLEANSE_1) : GetSpell(HOF_1);
+
+                    if (doCast(target, spell))
+                    {
+                        if (spell == GetSpell(HOF_1))
+                        {
+                            if (target->ToCreature())
+                                SetSpellCooldown(HOF_1, 5000); //5 sec for bots
+                            else
+                                SetSpellCooldown(HOF_1, 15000); //improved
+                        }
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player* hTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOS_1, diff) || IsCasting() || Rand() > 30)
+                return;
+
+            if (Group* pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* HOSPlayer = itr->GetSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot())
+                        bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (IsTank(HOSPlayer)) continue; //tanks do not need it
+                    if (!HOSPlayer->IsInWorld() || master->GetMap() != HOSPlayer->FindMap() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS_1)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff))
+                            return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->FindMap()) continue;
+                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                    for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* cre = pl->GetBotMap(i)->_Cre();
+                        if (!cre || cre->isDead()) continue;
+                        if (IsTank(cre)) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS_1)) continue; //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff))
+                                return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOS_1, diff) || Rand() > 50) return false;
+            if (IsTank(target)) return false; //tanks do not need it
+            if (IsCasting()) return false; //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS_1)) return false; //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue; //too small threat
+                //if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, GetSpell(HOS_1)))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586)))); //Fade
+                SetSpellCooldown(HOS_1, target->ToCreature() ? 10000 : 25000);
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOLY_SHOCK_1, diff)) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed()))
+                return false; //do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+            {
+                if (urand(1,100) > 20) //Daybreak: 20% to not trigger HS CD, only GCD
+                    SetSpellCooldown(HOLY_SHOCK_1, 5000);
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
+            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (IsSpellReady(HAND_OF_PROTECTION_1, diff, false) && target->GetTypeId() == TYPEID_PLAYER &&
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master) &&
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) &&
+                me->GetExactDist(target) < 30 &&
+                !HasAuraName(target, HAND_OF_PROTECTION_1) &&
+                !HasAuraName(target, FORBEARANCE_AURA))
+            {
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    me->MonsterWhisper("BOP on you!", target->GetGUID());
+                    SetSpellCooldown(HAND_OF_PROTECTION_1, 60000); //1 min
+
+                    //debug
+                    if (!HasAuraName(target, FORBEARANCE_AURA))
+                        me->AddAura(FORBEARANCE_AURA, target);
+                    if (HasAuraName(target, FORBEARANCE_AURA) && !HasAuraName(target, HAND_OF_PROTECTION_1))
+                        me->AddAura(GetSpell(HAND_OF_PROTECTION_1), target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION_1))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && hp < 20 &&
+                            target->GetTypeId() == TYPEID_PLAYER &&
+                            (target->IsInCombat() || !target->getAttackers().empty()) &&
+                            !HasAuraName(target, FORBEARANCE_AURA))
+                        {
+                            if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                            {
+                                me->MonsterWhisper("Lay of Hands on you!", target->GetGUID());
+                                SetSpellCooldown(LAY_ON_HANDS_1, 150000); //2.5 min
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HS(target, diff))
+                            return true;
+                }
+            }
+
+            Unit* u = target->GetVictim();
+            if (IsSpellReady(SACRED_SHIELD_1, diff) && target->GetTypeId() == TYPEID_PLAYER &&
+                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->IsInCombat())) &&
+                !HasAuraName(target, SACRED_SHIELD_1) &&
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master))
+            {
+                Unit* aff = FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 50, 1);//use players since we cast only on them
+                if ((!aff || (aff->getAttackers().empty() && !IsTank(aff))) &&
+                    doCast(target, GetSpell(SACRED_SHIELD_1)))
+                {
+                    SetSpellCooldown(SACRED_SHIELD_1, 3000);
+                    return true;
+                }
+            }
+            if ((hp < 85 || GetLostHP(target) > 6000))
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!GetSpell(FLASH_OF_LIGHT_1) && hp < 85))
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            if ((hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            //HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff, false))
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    SetSpellCooldown(DIVINE_PLEA_1, 45000);
+
+            CureTarget(me, GetSpell(CLEANSE_1), diff); //maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff); //maybe unnecessary
+            CureTarget(master,  GetSpell(CLEANSE_1), diff); //maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master,  GetSpell(CLEANSE_1), diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (IsSpellReady(SEAL_OF_COMMAND_1, diff, false) && Rand() < 20 && !HasAuraName(me, SEAL_OF_COMMAND_1) &&
+                doCast(me, GetSpell(SEAL_OF_COMMAND_1)))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted())
+                return;
+
+            RezGroup(GetSpell(REDEMPTION_1), master);
+
+            if (Feasting())
+                return;
+
+            //aura
+            if (master->IsAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+                uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura* devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == CLASS_MAGE ||
+                    master->getClass() == CLASS_PRIEST ||
+                    master->getClass() == CLASS_WARLOCK ||
+                    master->getClass() == CLASS_DRUID || devAura) &&
+                    !concAura &&
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (HasAuraName(target, BLESSING_OF_WISDOM_1, me->GetGUID()) ||
+                HasAuraName(target, BLESSING_OF_KINGS_1, me->GetGUID()) ||
+                HasAuraName(target, BLESSING_OF_SANCTUARY_1, me->GetGUID()) ||
+                HasAuraName(target, BLESSING_OF_MIGHT_1, me->GetGUID()))
+                return false;
+            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
+            //    return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+            bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM_1) || HasAuraName(target, GREATER_BLESSING_OF_WISDOM_1);
+            bool kings = HasAuraName(target, BLESSING_OF_KINGS_1) || HasAuraName(target, GREATER_BLESSING_OF_KINGS_1);
+            bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY_1) || HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY_1);
+            bool might = (HasAuraName(target, BLESSING_OF_MIGHT_1) || HasAuraName(target, GREATER_BLESSING_OF_MIGHT_1) || HasAuraName(target, BATTLESHOUT_1));
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->ToPlayer()->getClass();
+            else if (target->ToCreature())
+                Class = target->ToCreature()->GetBotClass();
+            switch (Class)
+            {
+                case CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    break;
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                case CLASS_ROGUE:
+                case CLASS_HUNTER:
+                case CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            temptimer = GC_Timer;
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff, false, 25000) && doCast(target, GetSpell(REPENTANCE_1)))
+                    SetSpellCooldown(REPENTANCE_1, 45000);
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff, false))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                    SetSpellCooldown(REPENTANCE_1, 45000);
+            }
+            GC_Timer = temptimer;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff, false, 25000) ? FindCastingTarget(20, 0, false, REPENTANCE_1) : NULL;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            else if (IsSpellReady(TURN_EVIL_1, diff, false, 1500))
+            {
+                target = FindCastingTarget(20, 0, false, TURN_EVIL_1);
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(TURN_EVIL_1), true))
+                {
+                    SetSpellCooldown(TURN_EVIL_1, 3000);
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (IsSpellReady(HOLY_WRATH_1, diff, false, 8000) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, false, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                {
+                    SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff, /*true*/false, 7000))
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    SetSpellCooldown(HAMMER_OF_JUSTICE_1, 65000 - master->getLevel()*500); //25 sec on 80
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1), true))
+            {
+                SetSpellCooldown(TURN_EVIL_1, 3000);
+                return;
+            }
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                !CCed(opponent) &&
+                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
+                GetHealthPCT(me) < 90 &&
+                doCast(opponent, GetSpell(TURN_EVIL_1), true))
+            {
+                SetSpellCooldown(TURN_EVIL_1, 3000);
+                return;
+            }
+        }
+
+        void Wrath(uint32 diff)
+        {
+            if (!IsSpellReady(HOLY_WRATH_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                me->GetExactDist(opponent) <= 8 && doCast(me, GetSpell(HOLY_WRATH_1)))
+                SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
+            else
+            {
+                Unit* target = FindUndeadCCTarget(8, GetSpell(HOLY_WRATH_1));
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    SetSpellCooldown(HOLY_WRATH_1, 23000 - me->getLevel() * 100); //23 - 0...8 sec (15 sec on 80 as with glyph)
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //HAMMER OF WRATH //custom GCD check
+            if (IsSpellReady(HOW_1, diff, false) && GC_Timer <= 300 && HasRole(BOT_ROLE_DPS) && Rand() < 30 && GetHealthPCT(opponent) < 19 &&
+                me->GetExactDist(opponent) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HOW_1)))
+                {
+                    SetSpellCooldown(HOW_1, 6000); //6 sec
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(HANDOFRECKONING_1, diff, false) && me->GetExactDist(opponent) < 30 &&
+                HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) && Rand() < 50 &&
+                (IsInBotParty(u) || IsTank()))
+            {
+                Creature* cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !IsMeleeClass(u->getClass())) ||
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || IsTank()) &&
+                    doCast(opponent, GetSpell(HANDOFRECKONING_1)))
+                {
+                    SetSpellCooldown(HANDOFRECKONING_1, IsTank() ? 4000 : 8000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) &&
+                me->GetExactDist(opponent) < 10 && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {
+                    SetSpellCooldown(HAMMER_OF_JUSTICE_1, 65000 - master->getLevel()*500); //25 sec on 80
+                    return;
+                }
+            }
+
+            if (IsSpellReady(JUDGEMENT_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 10 &&
+                Rand() < 50 && me->HasAura(GetSpell(SEAL_OF_COMMAND_1)))
+            {
+                if (doCast(opponent, GetSpell(JUDGEMENT_1)))
+                {
+                    SetSpellCooldown(JUDGEMENT_1, 7000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 7 &&
+                !opponent->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                {
+                    SetSpellCooldown(CONSECRATION_1, 8000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > (master->GetMaxHealth()*2)/3 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {
+                    SetSpellCooldown(AVENGING_WRATH_1, 60000); //1 min
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 5)
+            {
+                if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
+                {
+                    SetSpellCooldown(CRUSADER_STRIKE_1, 12000 - me->getLevel() * 100);//4 sec on 80
+                    return;
+                }
+            }
+
+            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 30 &&
+                (!IsTank() || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
+            {
+                if (doCast(opponent, GetSpell(EXORCISM_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                {
+                    SetSpellCooldown(EXORCISM_1, 7000);
+                    return;
+                }
+            }
+
+            Wrath(diff);
+
+            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 7)
+            {
+                if (doCast(opponent, GetSpell(DIVINE_STORM_1)))
+                {
+                    SetSpellCooldown(DIVINE_STORM_1, 10000 - me->getLevel()/4 * 100); //10 - 2 sec
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+                if (lvl >= 45 && (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                    aftercrit += 18.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if (lvl >= 25 && spellId == GetSpell(EXORCISM_1))
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if (lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellId == GetSpell(CRUSADER_STRIKE_1) ||
+                spellId == GetSpell(DIVINE_STORM_1)))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+                if (lvl >= 45 && spellId == GetSpell(HOW_1))
+                    aftercrit += 50.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if ((spellId == GetSpell(EXORCISM_1) || spellId == GetSpell(FLASH_OF_LIGHT_1)) &&
+                me->HasAura(THE_ART_OF_WAR_BUFF))
+            {
+                //Art of War: consume buff
+                me->RemoveAura(THE_ART_OF_WAR_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            if (spellId == GetSpell(BLESSING_OF_KINGS_1) || spellId == GetSpell(BLESSING_OF_MIGHT_1) ||
+                spellId == GetSpell(BLESSING_OF_WISDOM_1) || spellId == GetSpell(BLESSING_OF_SANCTUARY_1))
+            {
+                //Blessings duration 1h
+                if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    bless->SetDuration(dur);
+                    bless->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(HOF_1))
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            //Custom OnHit() handlers
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //The Art of War: 20% on autoattack
+                if (me->getLevel() >= 33)
+                    if (urand(1,100) <= 20)
+                        me->CastSpell(me, THE_ART_OF_WAR_BUFF, true);
+            }
+
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_PALADIN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+            InitSpellMap(CLEANSE_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+  /*Talent*/lvl >= 45 ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+  /*Talent*/lvl >= 25 ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+            InitSpellMap(JUDGEMENT_1);
+            InitSpellMap(CONSECRATION_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+            InitSpellMap(HOW_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HOF_1);
+            InitSpellMap(HOS_1);
+            InitSpellMap(HANDOFRECKONING_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //1 - SPD 3% crit 3%
+            if (level >= 78)
+                RefreshAura(SPELLDMG,5); //+15%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG,4); //+12%
+            else if (level >= 55)
+                RefreshAura(SPELLDMG,3); //+9%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG,2); //+6%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG); //+3%
+            //2 - SPD 6%
+            if (level >= 55)
+                RefreshAura(SPELLDMG2,3); //+18%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG2,2); //+12%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG2); //+6%
+            //Talents
+            if (level >= 55)
+                RefreshAura(PURE);
+            if (level >= 35)
+                RefreshAura(WISE);
+            if (level >= 50)
+                RefreshAura(RECKONING5); //10%
+            else if (level >= 45)
+                RefreshAura(RECKONING4); //8%
+            else if (level >= 40)
+                RefreshAura(RECKONING3); //6%
+            else if (level >= 35)
+                RefreshAura(RECKONING2); //4%
+            else if (level >= 30)
+                RefreshAura(RECKONING1); //2%
+            //if (level >= 50)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE3);
+            //else if (level >= 47)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE2);
+            //else if (level >= 45)
+            //    RefreshAura(RIGHTEOUS_VENGEANCE1);
+            if (level >= 30)
+                RefreshAura(VENGEANCE3);
+            else if (level >= 27)
+                RefreshAura(VENGEANCE2);
+            else if (level >= 25)
+                RefreshAura(VENGEANCE1);
+            if (level >= 60)
+                RefreshAura(SHOFL3);
+            else if (level >= 55)
+                RefreshAura(SHOFL2);
+            else if (level >= 50)
+                RefreshAura(SHOFL1);
+            if (level >= 45)
+                RefreshAura(SACRED_CLEANSING);
+            if (level >= 35)
+                RefreshAura(DIVINE_PURPOSE);
+            if (level >= 25)
+                RefreshAura(VINDICATION2);
+            else if (level >= 20)
+                RefreshAura(VINDICATION1);
+            if (level >= 30)
+                RefreshAura(LAYHANDS);
+            if (level >= 20)
+                RefreshAura(FANATICISM,2); //-60% aggro
+            if (level >= 15)
+                RefreshAura(GLYPH_HOLY_LIGHT); //10% heal
+            //if (level >= 70)
+            //    RefreshAura(PALADIN_T9_2P_BONUS); //Righteous Vengeance Crits
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HOF_1:
+                case SACRED_SHIELD_1:
+                case HOLY_SHOCK_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HOS_1:
+                case SEAL_OF_COMMAND_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_COMMAND_1                   = 20375,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_1                         = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            PURE/*Judgements of the Pure*/      = 54155,
+            WISE/*Judgements of the Wise*/      = 31878,
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452 ,//rank 1
+            VINDICATION2                        = 26016,//rank 2
+            LAYHANDS  /*Improved LOH rank 2*/   = 20235,
+            FANATICISM                          = 31881,//rank 3
+            //RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            //RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            //RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHOFL1      /*Sheath of Light*/     = 53501,//rank 1
+            SHOFL2                              = 53502,//rank 2
+            SHOFL3                              = 53503,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937,
+        //other
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511 //rank3 6% dam
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA,
+            DEVOTIONAURA,
+            CONCENTRATIONAURA,
+
+            THE_ART_OF_WAR_BUFF                 = 59578,
+            FORBEARANCE_AURA                    = 25771,
+
+            GREATER_BLESSING_OF_MIGHT_1         = 25782,
+            GREATER_BLESSING_OF_WISDOM_1        = 25894,
+            GREATER_BLESSING_OF_KINGS_1         = 25898,
+            GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+            BATTLESHOUT_1                       = 6673
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..5e2cda6
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,1042 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (!player->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 35) return false;
+
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                Group* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->FindMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                {
+                    SetSpellCooldown(DIVINE_HYMN_1, 180000); //3 min
+                    return true;
+                }
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                Group* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->GetMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(PRAYER_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff, false) || IsCasting() || Rand() > 50)
+                return false;
+            if (me->GetExactDist(target) > 40)
+                return false;
+            if (target->getAttackers().empty() && GetHealthPCT(target) > 33 &&
+                !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+            {
+                if (me->getLevel() >= 30 || (target->ToCreature() && target->ToCreature()->GetBotAI()))
+                    SetSpellCooldown(PW_SHIELD_1, 1000);
+                else
+                    SetSpellCooldown(PW_SHIELD_1, 4000);
+                GC_Timer = 800;
+                return true;
+            }
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (GetManaPCT(me) < 33 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, DISPELMAGIC, diff);
+            CureGroup(master, GetSpell(CURE_DISEASE_1), diff);
+            //ShieldGroup(master);
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 &&
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) &&
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->GetVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                float dist = me->GetExactDist(opponent);
+                if (HasRole(BOT_ROLE_DPS) && dist < 30)
+                {
+                    if (IsSpellReady(SW_DEATH_1, diff, false) && Rand() < 50 &&
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) &&
+                        doCast(opponent, GetSpell(SW_DEATH_1)))
+                    {
+                        SetSpellCooldown(SW_DEATH_1, 8000);
+                        return;
+                    }
+                    if (IsSpellReady(SW_PAIN_1, diff) && Rand() < 25 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(SW_PAIN_1)))
+                        return;
+                    if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && Rand() < 50 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
+                        return;
+                    if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && !Devcheck && Rand() < 30 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/3 &&
+                        !HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
+                        return;
+                    if (IsSpellReady(MIND_BLAST_1, diff) && Rand() < 35 &&
+                        (!GetSpell(VAMPIRIC_TOUCH_1) || HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())) &&
+                        doCast(opponent, GetSpell(MIND_BLAST_1)))
+                    {
+                        SetSpellCooldown(MIND_BLAST_1, 6000);
+                        return;
+                    }
+                    if (IsSpellReady(MIND_FLAY_1, diff, false) && !me->isMoving() && Rand() < 20 &&
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/5 ||
+                        (HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) && HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))) &&
+                        doCast(opponent, GetSpell(MIND_FLAY_1)))
+                    {
+                        SetSpellCooldown(MIND_FLAY_1, 2500);
+                        return;
+                    }
+                    if (IsSpellReady(MIND_SEAR_1, diff, false) && !me->isMoving() && !opponent->isMoving() && dist < 35 && Rand() < 50 &&
+                        HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))
+                    {
+                        if (Unit* u = FindSplashTarget(30, opponent))
+                            if (doCast(u, GetSpell(MIND_SEAR_1)))
+                                return;
+                    }
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff, false) &&
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                opponent->GetHealth() > me->GetMaxHealth()/5 && !CCed(opponent) && Rand() < 30 &&
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR_1))
+            {
+                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
+                {
+                    SetSpellCooldown(PSYCHIC_HORROR_1, 60000);
+                    return;
+                }
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 98)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //GUARDIAN SPIRIT
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && target->IsInCombat() &&
+                !target->getAttackers().empty() && hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) &&
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master) &&
+                Rand() < 80 && !target->HasAura(GetSpell(GUARDIAN_SPIRIT_1)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        me->MonsterWhisper("Guardian Spirit on you!", target->GetGUID());
+                        SetSpellCooldown(GUARDIAN_SPIRIT_1, 90000); //1.5 min
+                    }
+                    else
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                        SetSpellCooldown(GUARDIAN_SPIRIT_1, 30000); //30 sec for creatures
+                    }
+
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && IsSpellReady(PAIN_SUPPRESSION_1, diff, false) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 50 &&
+                !target->HasAura(GetSpell(PAIN_SUPPRESSION_1)))
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        me->MonsterWhisper("Pain Suppression on you!", target->GetGUID());
+                        SetSpellCooldown(PAIN_SUPPRESSION_1, 60000); //60 sec
+                    }
+                    else
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardin Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                        SetSpellCooldown(PAIN_SUPPRESSION_1, 15000); //15 sec for creatures
+                    }
+
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) &&
+                ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (IsSpellReady(PENANCE_1, diff, false) && !me->isMoving() && Rand() < 80 &&
+                    (target->GetTypeId() != TYPEID_PLAYER ||
+                    !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) &&
+                    doCast(target, GetSpell(PENANCE_1)))
+                {
+                    SetSpellCooldown(PENANCE_1, 8000);
+                    return true;
+                }
+                else if (HEAL && Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && Rand() < 70 &&
+                    doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff) &&
+                ((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) &&
+                doCast(target, GetSpell(FLASH_HEAL_1)))
+                return true;
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) &&
+                ((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) &&
+                !HasAuraName(target, RENEW_1, me->GetGUID()) &&
+                doCast(target, GetSpell(RENEW_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsInWorld() || target->isDead() ||
+                GC_Timer > diff || me->GetExactDist(target) > 30 || Rand() > 20)
+                return false;
+
+            if (IsSpellReady(FEAR_WARD_1, false) && !target->HasAura(GetSpell(FEAR_WARD_1)) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+            {
+                SetSpellCooldown(FEAR_WARD_1, target->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000); //30sec for bots
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                uint32 INNER_FIRE = GetSpell(INNER_FIRE_1);
+                if (INNER_FIRE && !me->HasAura(INNER_FIRE) &&
+                    doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                uint32 VAMPIRIC_EMBRACE = GetSpell(VAMPIRIC_EMBRACE_1);
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) &&
+                    doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!HasAuraName(target, PW_FORTITUDE) &&
+                    doCast(target, PW_FORTITUDE))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!HasAuraName(target, SHADOW_PROTECTION) &&
+                    doCast(target, SHADOW_PROTECTION))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if (!HasAuraName(target, DIVINE_SPIRIT) &&
+                    doCast(target, DIVINE_SPIRIT))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Rand() > 50)
+                return;
+
+            RezGroup(GetSpell(RESURRECTION_1), master);
+
+            //if (Feasting())
+            //    return;
+
+            //if (BuffTarget(master, diff))
+            //    return;
+            //if (BuffTarget(me, diff))
+            //    return;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!DISPELMAGIC || CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, DISPELMAGIC))
+                CheckDispelTimer = 1000;
+
+            CheckDispelTimer = 3000; //fail
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (!IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 SHACKLE_UNDEAD = GetSpell(SHACKLE_UNDEAD_1);
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+            {
+                Shackle_Timer = 1500;
+                return;
+            }
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                Shackle_Timer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                        SetSpellCooldown(SILENCE_1, 30000);
+            }
+            else if (IsSpellReady(PSYCHIC_HORROR_1, diff, false, 20000))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                        SetSpellCooldown(PSYCHIC_HORROR_1, 60000);
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff, false))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                    {
+                        SetSpellCooldown(PSYCHIC_SCREAM_1, 22000);
+                        return;
+                    }
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                    {
+                        SetSpellCooldown(PSYCHIC_SCREAM_1, 22000);
+                        return;
+                    }
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 98 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff, false) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(FADE_1)))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            SetSpellCooldown(FADE_1, 10000);
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!IsSpellReady(DISPERSION_1, diff) || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (GetManaPCT(me) < 30) ||
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                    SetSpellCooldown(DISPERSION_1, 60000);
+                GC_Timer = temptimer;
+                return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 2000); //fail
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //434 new
+                //Improved Fire Blast (part 1): 8% additional crit chance for Fire Blast
+                //if (lvl >= 11 && spellId == FLAMESTRIKE)
+                //    aftercrit += 8.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Ice Shards: 50% additional crit damage bonus for Frost spells
+                //else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                //    pctbonus += 0.333f;
+            }
+            //Twin Disciplines (damage part): 6% bonus damage for shadow and holy spells
+            if (lvl >= 13)
+                if ((SPELL_SCHOOL_MASK_HOLY & spellInfo->GetSchoolMask()) ||
+                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.06f;
+            //Twisted Faith (part 1): 2% bonus damage for shadow spells
+            if (lvl >= 21 && (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask()))
+                pctbonus += 0.02f;
+            //Mind Melt (part 1): 30% bonus damage for Shadow Word: Death
+            if (lvl >= 41 && spellId == GetSpell(SW_DEATH_1))
+                pctbonus += 0.3f;
+
+            //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+            if (lvl >= 25 && spellId == GetSpell(MIND_FLAY_1))
+                pctbonus += 0.1f;
+
+            //other
+            if (spellId == SW_DEATH_BACKLASH)
+            {
+                //T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                if (lvl >= 60) //buffed
+                    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 40% reduced backlash damage
+                if (lvl >= 50)
+                    pctbonus -= 0.4f;
+
+                pctbonus = std::min<float>(pctbonus, 1.0f);
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Strength of Soul: direct heals reduce Weakened Soul duration on target by 4 sec
+            if (spellId == HEAL || spellId == GetSpell(FLASH_HEAL_1))
+            {
+                if (me->getLevel() >= 51)
+                {
+                    if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+                    {
+                        if (soul->GetDuration() > 4000)
+                            soul->SetDuration(soul->GetDuration() - 4000);
+                        else
+                            target->RemoveAura(soul, AURA_REMOVE_BY_EXPIRE);
+                    }
+                }
+            }
+
+            //Pain and Suffering (part 1, 335 version): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if (spellId == GetSpell(MIND_FLAY_1))
+                if (me->getLevel() >= 51)
+                    if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                        pain->RefreshDuration();
+
+            if (spellId == GetSpell(FEAR_WARD_1))
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(GetSpell(FEAR_WARD_1), me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+
+            if (spellId == GetSpell(INNER_FIRE_1) || spellId == GetSpell(VAMPIRIC_EMBRACE_1) || spellId == GetSpell(PW_FORTITUDE_1) ||
+                spellId == GetSpell(SHADOW_PROTECTION_1) || spellId == GetSpell(DIVINE_SPIRIT_1))
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Shackle_Timer = 0;
+
+            CheckDispelTimer = 0;
+            DevcheckTimer = 0;
+
+            Devcheck = false;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_PRIEST);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+
+            if (CheckDispelTimer > diff)            CheckDispelTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DISPELMAGIC = lvl >= 70 ? MASS_DISPEL_1 : InitSpell(me, DISPEL_MAGIC_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+            InitSpellMap(MIND_SEAR_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            HEAL = lvl >= 40 ? InitSpell(me, GREATER_HEAL_1) : lvl >= 16 ? InitSpell(me, NORMAL_HEAL_1) : InitSpell(me, LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+        }
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 65)
+                RefreshAura(BORROWED_TIME); //25%haste/40%bonus
+            if (level >= 55)
+                RefreshAura(DIVINE_AEGIS); //30%
+            if (level >= 55)
+                RefreshAura(EMPOWERED_RENEW3); //15%
+            else if (level >= 50)
+                RefreshAura(EMPOWERED_RENEW2); //10%
+            else if (level >= 45)
+                RefreshAura(EMPOWERED_RENEW1); //5%
+            if (level >= 45)
+                RefreshAura(BODY_AND_SOUL1); //30%
+            if (level >= 50)
+                RefreshAura(PAINANDSUFFERING3); //100%
+            else if (level >= 48)
+                RefreshAura(PAINANDSUFFERING2); //66%
+            else if (level >= 45)
+                RefreshAura(PAINANDSUFFERING1); //33%
+            if (level >= 50)
+                RefreshAura(MISERY3); //3%
+            else if (level >= 48)
+                RefreshAura(MISERY2); //2%
+            else if (level >= 45)
+                RefreshAura(MISERY1); //1%
+            if (level >= 45)
+                RefreshAura(GRACE); //100%
+            if (level >= 35)
+                RefreshAura(IMPROVED_DEVOURING_PLAGUE); //30%
+            if (level >= 25)
+                RefreshAura(INSPIRATION3); //10%
+            else if (level >= 23)
+                RefreshAura(INSPIRATION2); //6%
+            else if (level >= 20)
+                RefreshAura(INSPIRATION1); //3%
+            if (level >= 30)
+                RefreshAura(SHADOW_WEAVING3); //100%
+            else if (level >= 28)
+                RefreshAura(SHADOW_WEAVING2); //66%
+            else if (level >= 25)
+                RefreshAura(SHADOW_WEAVING1); //33%
+            if (level >= 15)
+            {
+                RefreshAura(GLYPH_SW_PAIN);
+                RefreshAura(GLYPH_PW_SHIELD); //20% heal
+            }
+            if (level >= 40)
+                RefreshAura(SHADOWFORM); //allows dots to crit, passive
+            if (level >= 70)
+                RefreshAura(PRIEST_T10_2P_BONUS);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DISPEL_MAGIC_1:
+                case MASS_DISPEL_1:
+                case CURE_DISEASE_1:
+                case FEAR_WARD_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case LESSER_HEAL_1:
+                case NORMAL_HEAL_1:
+                case GREATER_HEAL_1:
+                case RENEW_1:
+                case FLASH_HEAL_1:
+                case PRAYER_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 DISPELMAGIC, HEAL;
+        uint32 Heal_Timer, Shackle_Timer;
+/*Misc*/uint16 CheckDispelTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770 //33% renew
+        };
+        enum PriestSpecial
+        {
+            IMPROVED_DEVOURING_PLAGUE_DAMAGE= 63675,
+            MIND_SEAR_DAMAGE                = 49821,
+            SW_DEATH_BACKLASH               = 32409,
+            WEAKENED_SOUL_DEBUFF            = 6788
+        };
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..b725e45
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,884 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 25% maybe...
+TODO:
+*/
+#define DMGMIN              1
+#define DMGMAX              2
+#define MAX_COMBO_POINTS    5
+#define EVISCERATE_MAX_RANK 12
+const uint32 EVSCRDamage[EVISCERATE_MAX_RANK+1][MAX_COMBO_POINTS+1][DMGMAX+1] =
+{
+    { { 0,0,0 }, { 0,0,0 },     { 0,0,0 },      { 0,0,0 },       { 0,0,0 },       { 0,0,0 }       },
+    { { 0,0,0 }, { 0,6,11 },    { 0,12,16 },    { 0,17,22 },     { 0,22,28 },     { 0,28,34 }     },
+    { { 0,0,0 }, { 0,14,23 },   { 0,26,34 },    { 0,37,46 },     { 0,48,58 },     { 0,60,70 }     },
+    { { 0,0,0 }, { 0,25,49 },   { 0,45,59 },    { 0,64,79 },     { 0,83,99 },     { 0,103,119 }   },
+    { { 0,0,0 }, { 0,41,62 },   { 0,73,93 },    { 0,104,125 },   { 0,135,157 },   { 0,167,189 }   },
+    { { 0,0,0 }, { 0,60,91 },   { 0,106,136 },  { 0,151,182 },   { 0,196,228 },   { 0,242,274 }   },
+    { { 0,0,0 }, { 0,93,138 },  { 0,165,209 },  { 0,236,281 },   { 0,307,353 },   { 0,379,425 }   },
+    { { 0,0,0 }, { 0,144,213 }, { 0,255,323 },  { 0,365,434 },   { 0,475,545 },   { 0,586,656 }   },
+    { { 0,0,0 }, { 0,199,296 }, { 0,351,447 },  { 0,502,599 },   { 0,653,751 },   { 0,805,903 }   },
+    { { 0,0,0 }, { 0,224,333 }, { 0,395,503 },  { 0,565,674 },   { 0,735,845 },   { 0,906,1016 }  },
+    { { 0,0,0 }, { 0,245,366 }, { 0,431,551 },  { 0,616,737 },   { 0,801,923 },   { 0,987,1109 }  },
+    { { 0,0,0 }, { 0,405,614 }, { 0,707,915 },  { 0,1008,1217 }, { 0,1309,1519 }, { 0,1611,1821 } },
+    { { 0,0,0 }, { 0,497,752 }, { 0,868,1122 }, { 0,1238,1493 }, { 0,1608,1864 }, { 0,1979,2235 } }
+};
+#define RUPTURE_MAX_RANK    9
+const uint32 RuptureDamage[RUPTURE_MAX_RANK+1][MAX_COMBO_POINTS+1] =
+{
+    { 0, 0,   0,   0,    0,    0    },
+    { 0, 41,  61,  86,   114,  147  },
+    { 0, 61,  91,  128,  170,  219  },
+    { 0, 89,  131, 182,  240,  307  },
+    { 0, 129, 186, 254,  331,  419  },
+    { 0, 177, 256, 350,  457,  579  },
+    { 0, 273, 381, 506,  646,  803  },
+    { 0, 325, 461, 620,  800,  1003 },
+    { 0, 489, 686, 914,  1171, 1459 },
+    { 0, 581, 816, 1088, 1395, 1739 }
+};
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { comboPoints = 0; tempComboPoints = 0; master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 /*diff*/)
+        {}
+
+        //This method should be used to emulate energy usage reduction
+        void modenergy(int32 mod, bool set = false)
+        {
+            //can't set enery to -x (2 cases)
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && energy < uint32(abs(mod)))
+            {
+                mod = 0;
+                set = true;
+            }
+
+            if (set)
+                energy = mod;
+            else
+                energy += mod;
+
+            energy = std::min<uint32>(energy, 100);
+            me->SetPower(POWER_ENERGY, energy);
+        }
+
+        uint32 getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+            return energy;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_ROGUE))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            comboPoints = std::min<uint8>(comboPoints, 5);
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //Blade Flurry (434 deprecated)
+            if (IsSpellReady(BLADE_FLURRY_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                Rand() < 30 && getenergy() >= 25 && FindSplashTarget(7, opponent))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                {
+                    SetSpellCooldown(BLADE_FLURRY_1, 75000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //KICK
+            if (IsSpellReady(KICK_1, diff, false) && meleedist <= 5 && Rand() < 80 && getenergy() >= 25 &&
+                opponent->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KICK_1)))
+                {
+                    SetSpellCooldown(KICK_1, 8000); //improved
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //SHADOWSTEP
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 30 && getenergy() >= 10)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
+                {
+                    SetSpellCooldown(SHADOWSTEP_1, 20000);
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //BACKSTAB
+            if (IsSpellReady(BACKSTAB_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 4 &&
+                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(BACKSTAB_1)))
+                    return;
+            }
+            //SINISTER STRIKE
+            if (IsSpellReady(SINISTER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 5 &&
+                Rand() < 25 && getenergy() >= 45)
+            {
+                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //SLICE AND DICE
+            if (IsSpellReady(SLICE_DICE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && comboPoints > 1 && getenergy() >= 25 &&
+                (b_attackers.size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //KIDNEY SHOT
+            if (IsSpellReady(KIDNEY_SHOT_1, diff) && meleedist <= 5 && comboPoints > 0 &&
+                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCasted(false)))
+            {
+                if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
+                    return;
+            }
+            //EVISCERATE
+            if (IsSpellReady(EVISCERATE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 2 &&
+                getenergy() >= 35 && Rand() < comboPoints*15)
+            {
+                uint32 EVISCERATE = GetSpell(EVISCERATE_1);
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(EVISCERATE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float combo = float(comboPoints);
+                int32 damage = int32(urand(EVSCRDamage[rank][comboPoints][DMGMIN], EVSCRDamage[rank][comboPoints][DMGMAX]));//base damage
+                damage += irand(int32(ap*combo*0.03f), int32(ap*combo*0.07f));//ap bonus
+
+                currentSpell = EVISCERATE;
+                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false);
+                return;
+            }
+            //MUTILATE
+            //if (isTimerReady(Mutilate_Timer) && energy>60)
+            //{
+            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            //    // for now use same formula as evicerate
+            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+            //    // compensate for lack of attack power
+            //    damage = damage*(rand()%4+1);
+
+            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //    //doCast (me, MUTILATE);
+            //    Mutilate_Timer = 10;
+            //    comboPoints+=3;
+            //    energy -= 60;
+            //}
+
+            //RUPTURE
+            if (IsSpellReady(RUPTURE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 3 && getenergy() >= 25 &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < (50 + 70 * opponent->isMoving()))
+            {
+                uint32 RUPTURE = GetSpell(RUPTURE_1);
+                //no damage range for rupture
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(RUPTURE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float AP_per_combo[6] = {0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f};
+                float divider[6] = {0.0f, 4.f, 5.f, 6.f, 7.f, 8.f};//duration/2 = number of ticks
+                int32 damage = int32(RuptureDamage[rank][comboPoints]/divider[comboPoints]);//base damage
+                damage += int32(ap*AP_per_combo[comboPoints]);//ap bonus is strict - applied to every tick
+
+                currentSpell = RUPTURE;
+                me->CastCustomSpell(opponent, RUPTURE, &damage, NULL, NULL, false);
+                return;
+            }
+            //DISMANTLE
+            if (IsSpellReady(DISMANTLE_1, diff, false) && meleedist <= 5 && opponent->GetTypeId() == TYPEID_PLAYER &&
+                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) || opponent->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DISMANTLE_1)))
+                {
+                    SetSpellCooldown(DISMANTLE_1, 60000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Puncturing Wounds: 30% additional critical chance for Backstab
+                if (lvl >= 15 && spellId == GetSpell(BACKSTAB_1))
+                    aftercrit += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (spellId == GetSpell(MUTILATE_1))
+                    aftercrit += 15.f;
+                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+                else if (spellId == GetSpell(EVISCERATE_1))
+                    aftercrit += 10.f;
+                //Improved Ambush: 60% additional critical chance for Ambush
+                //else if (spellId == AMBUSH)
+                //    crit_chance += 60.f;
+                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
+                    aftercrit += 6.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 && !(spellInfo->Attributes & SPELL_ATTR0_ONLY_STEALTHED) &&
+                    spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS))
+                    pctbonus += 0.15f;
+            }
+            //Shadowstep: 20% bonus damage to all abilities once
+            //if (shadowstep == true)
+            //{
+            //    shadowstep = false;
+            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
+            //    pctbonus += 0.2f;
+            //}
+            //Find Weakness: 6% bonus damage to all abilities
+            if (lvl >= 45)
+                pctbonus += 0.06f;
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Imoroved Eviscerate: 20% damage bonus for Eviscerate
+            if (spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == GARROTE || spellId == AMBUSH*/)
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 30 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(EVISCERATE_1)))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (spellId == GetSpell(RUPTURE_1)/* || spellId == GARROTE*/))
+                pctbonus += 0.3f;
+            //Serrated Blades: 30% bonus damage for Rupture
+            if (lvl >= 20 && spellId == GetSpell(RUPTURE_1))
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 50 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == SHIV || spellId == HEMMORHAGE || spellId == GOUGE*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            uint32 WOUND_POISON = GetSpell(WOUND_POISON_1);
+            uint32 MIND_NUMBING_POISON = GetSpell(MIND_NUMBING_POISON_1);
+            if (!WOUND_POISON && !MIND_NUMBING_POISON)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                if (victim && me->GetExactDist(victim) <= 40)
+                {
+                    switch (rand()%2)
+                    {
+                        case 0:
+                            break;
+                        case 1:
+                        {
+                            switch (rand()%2)
+                            {
+                                case 0:
+                                    if (WOUND_POISON)
+                                    {
+                                        currentSpell = WOUND_POISON;
+                                        DoCast(victim, WOUND_POISON, true);
+                                    }
+                                    break;
+                                case 1:
+                                    if (MIND_NUMBING_POISON)
+                                    {
+                                        currentSpell = MIND_NUMBING_POISON;
+                                        DoCast(victim, MIND_NUMBING_POISON, true);
+                                    }
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //combo points use up
+            if (spellId == GetSpell(SLICE_DICE_1))
+            {
+                SetSpellCooldown(SLICE_DICE_1, 15000 + (tempComboPoints-1)*4500);
+                GC_Timer = 800;
+
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    uint32 dur = dice->GetDuration();
+                    dur += tempComboPoints * 3000; //use cp
+                    dur += 6000; // Glyph of Slice and Dice
+                    dur = (dur * 3) / 2; //Improved Slice and Dice
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(RUPTURE_1))
+            {
+                SetSpellCooldown(RUPTURE_1, 8000 + (tempComboPoints-1)*2000 + 4000);
+                GC_Timer = 800;
+
+                if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                {
+                    uint32 dur = rupture->GetDuration() + tempComboPoints*2000; //use cp
+                    dur += 4000; //Glyph of Rupture
+                    rupture->SetDuration(dur);
+                    rupture->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(KIDNEY_SHOT_1))
+            {
+                SetSpellCooldown(KIDNEY_SHOT_1, 20000);
+
+                if (Aura* kidney = target->GetAura(GetSpell(KIDNEY_SHOT_1), me->GetGUID()))
+                {
+                    uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
+                    kidney->SetDuration(dur);
+                    kidney->SetMaxDuration(dur);
+                }
+            }
+
+            if (currentSpell == 0)
+                return;
+
+            //BONUS CP MANAGEMENT
+
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
+            //Relentless Strikes
+            if (spell->NeedsComboPoints())
+            {
+                //std::ostringstream msg;
+                //msg << "casting ";
+                //if (spellId == EVISCERATE)
+                //    msg << "Eviscerate, ";
+                //else if (spellId == RUPTURE)
+                //    msg << "Rupture, ";
+                //else if (spellId == SLICE_DICE)
+                //    msg << "Slice and Dice, ";
+                //else if (spellId == KIDNEY_SHOT)
+                //    msg << "Kidney Shot, ";
+                ////else if (spellId == EXPOSE_ARMOR)
+                ////    msg << "Expose Armor, ";
+                ////else if (spellId == ENVENOM)
+                ////    msg << "Envenom, ";
+                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    currentSpell = RELENTLESS_STRIKES_EFFECT;
+                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
+                }
+                tempComboPoints = comboPoints;
+                //CP adding effects are handled before actual finisher so use temp value
+                //std::ostringstream msg2;
+                //msg2 << "cp set to 0";
+                if (tempAddCP)
+                {
+                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
+                    comboPoints = tempAddCP;
+                    tempAddCP = 0;
+                }
+                else
+                    comboPoints = 0;
+                //me->MonsterWhisper(msg2.str().c_str(), master->GetGUID());
+            }
+            else if (spellId == GetSpell(SINISTER_STRIKE_1) ||
+                spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == GOUGE ||
+                spellId == HEMORRHAGE*/)
+            {
+                ++comboPoints;
+                //std::ostringstream msg;
+                //msg << "1 cp generated ";
+                //if (spellId == SINISTER_STRIKE)
+                //    msg << "(Sinister Strike)";
+                //else if (spellId == BACKSTAB)
+                //    msg << "(Backstab)";
+                //msg << " set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == AMBUSH*/)
+            {
+                comboPoints += 2;
+                //std::ostringstream msg;
+                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == SEAL_FATE_EFFECT || spellId == RUTHLESSNESS_EFFECT)
+            {
+                ++tempAddCP;
+                //std::ostringstream msg;
+                //msg << "1 temp cp generated ";
+                //if (spellId == SEAL_FATE_EFFECT)
+                //    msg << "(Seal Fate)";
+                //else if (spellId == RUTHLESSNESS_EFFECT)
+                //    msg << "(Ruthleness)";
+                //me->MonsterWhisper(msg.str().c_str(), master->GetGUID());
+            }
+
+            //Glyph of Sinister Strike (20% to add cp on hit)
+            //Seal Fate means crit so this glyph is enabled from lvl 35)
+            //as addition always add cp on ss crit
+            if (currentSpell == GetSpell(SINISTER_STRIKE_1) && (spellId == SEAL_FATE_EFFECT || urand(0,100) >= 20))
+            {
+                ++tempAddCP;
+                //me->MonsterWhisper("1 temp cp generated (glyph of SS)", master->GetGUID());
+            }
+
+            //ENERGY COST REDUCTION
+
+            if (spellId == GetSpell(SINISTER_STRIKE_1))
+            {
+                //Improved Sinister Strike
+                //instead of restoring energy we should override current value
+                if (me->getLevel() >= 10)
+                    modenergy(-40, true);//45 - 5
+            }
+            //Slaughter from the Shadows energy restore
+            //instead of restoring energy we should override current value
+            if (me->getLevel() >= 55)
+            {
+                if (spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/)
+                    modenergy(-40, true);
+                //else if (spellId == HEMORRHAGE)
+                //    modenergy(-30, true);
+            }
+
+            //OTHER
+
+            if (spellId == GetSpell(EVISCERATE_1))
+            {
+                //Eviscerate speedup
+                GC_Timer = 800;
+
+                //Serrated Blades: Eviscerate has 20% chance per cp to refresh Rupture
+                //getting cheaty - remove roll
+                //getting cheaty - increase duration
+                //if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                    {
+                        int32 dur = rupture->GetMaxDuration() + 2000;
+                        dur = std::min<int32>(dur, 30000);
+                        rupture->SetDuration(dur);
+                        rupture->SetMaxDuration(dur);
+                        SetSpellCooldown(RUPTURE_1, dur - 2000);
+                    }
+                }
+            }
+
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration
+            //getting cheaty - increase duration
+            if (spellId == GetSpell(EVISCERATE_1)/* || spellId == ENVENOM*/)
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 dur = dice->GetMaxDuration() + 2000;
+                    dur = std::min<int32>(dur, 59000);
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                    SetSpellCooldown(SLICE_DICE_1, dur - 2000);
+                }
+            }
+
+            //Murderous Intent: When Backstabbing enemy that is below 35% hp, instantly restoring 30 energy
+            if (spellId == GetSpell(BACKSTAB_1))
+            {
+                if (target->HealthBelowPct(35))
+                {
+                    //since talent doesn't work just restore energy manually
+                    //DoCast(me, MURDEROUS_INTENT_EFFECT, true);
+                    modenergy(30);
+                }
+            }
+
+            //Waylay
+            if ((spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/) &&
+                me->getLevel() >= 20)
+            {
+                DoCast(target, WAYLAY_EFFECT, true);
+            }
+
+            //if (spellId == SHADOWSTEP)
+            //{
+            //    Shadowstep_eff_Timer = 10000;
+            //    shadowstep = true;
+            //}
+
+            //move behind on Kidney Shot and Gouge (optionally)
+            if (spellId == GetSpell(KIDNEY_SHOT_1)/* || spellId == GOUGE*/)
+                if (MoveBehind(*target))
+                    wait = 3;
+
+            if (spellId == currentSpell)
+                currentSpell = 0;
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            comboPoints = 0;
+            tempComboPoints = 0;
+            tempAddCP = 0;
+
+            tempDICE = false;
+            //shadowstep = false;
+
+            me->setPowerType(POWER_ENERGY);
+            //10 energy gained per stack
+            RefreshAura(GLADIATOR_VIGOR, 10);
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_ROGUE);
+            }
+
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
+            //else if (shadowstep)                    shadowstep = false;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(SLICE_DICE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(KICK_1);
+            InitSpellMap(RUPTURE_1);
+            InitSpellMap(KIDNEY_SHOT_1);
+            lvl >= 50 ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 50 ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            InitSpellMap(DISMANTLE_1);
+            lvl >= 30 ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //if (level >= 78)
+            //    RefreshAura(ROGUE_ARMOR_ENERGIZE,2);
+            //else if (level >= 60)
+            //    RefreshAura(ROGUE_ARMOR_ENERGIZE);
+            if (level >= 70)
+                RefreshAura(COMBAT_POTENCY5,2);
+            else if (level >= 55)
+                RefreshAura(COMBAT_POTENCY5);
+            else if (level >= 52)
+                RefreshAura(COMBAT_POTENCY4);
+            else if (level >= 49)
+                RefreshAura(COMBAT_POTENCY3);
+            else if (level >= 47)
+                RefreshAura(COMBAT_POTENCY2);
+            else if (level >= 45)
+                RefreshAura(COMBAT_POTENCY1);
+            if (level >= 35)
+                RefreshAura(SEAL_FATE5);
+            else if (level >= 32)
+                RefreshAura(SEAL_FATE4);
+            else if (level >= 29)
+                RefreshAura(SEAL_FATE3);
+            else if (level >= 27)
+                RefreshAura(SEAL_FATE2);
+            else if (level >= 25)
+                RefreshAura(SEAL_FATE1);
+            if (level >= 78)
+                RefreshAura(VITALITY,4);
+            else if (level >= 70)
+                RefreshAura(VITALITY,3);
+            else if (level >= 55)
+                RefreshAura(VITALITY,2);
+            else if (level >= 40)
+                RefreshAura(VITALITY);
+            if (level >= 55)
+                RefreshAura(TURN_THE_TABLES);
+            if (level >= 40)
+                RefreshAura(DEADLY_BREW);
+            if (level >= 35)
+                RefreshAura(BLADE_TWISTING1);//allow rank 1 only
+            if (level >= 35)
+                RefreshAura(QUICK_RECOVERY2);
+            else if (level >= 30)
+                RefreshAura(QUICK_RECOVERY1);
+            if (level >= 30)
+                RefreshAura(IMPROVED_KIDNEY_SHOT);
+            if (level >= 10)
+                RefreshAura(GLYPH_BACKSTAB);
+            if (level >= 10)
+                RefreshAura(SURPRISE_ATTACKS);
+
+            //On 25 get Glyph of Vigor
+            if (level >= 25)
+                RefreshAura(ROGUE_VIGOR,2);
+            else if (level >= 20)
+                RefreshAura(ROGUE_VIGOR);
+        }
+
+    private:
+        uint32 energy;
+        uint8 comboPoints, tempComboPoints, tempAddCP;
+        bool tempDICE/*, shadowstep*/;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1757,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,
+  /*Talent*/MUTILATE_1                          = 1329,
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+            BLADE_FLURRY_1                      = 33735,
+        //Special
+            WOUND_POISON_1                      = 13218,
+            MIND_NUMBING_POISON_1               = 5760
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE1                          = 14189,
+            SEAL_FATE2                          = 14190,
+            SEAL_FATE3                          = 14193,
+            SEAL_FATE4                          = 14194,
+            SEAL_FATE5                          = 14195,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            COMBAT_POTENCY4                     = 35552,
+            COMBAT_POTENCY5                     = 35553,
+            QUICK_RECOVERY1                     = 31244,
+            QUICK_RECOVERY2                     = 31245,
+            BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            VITALITY                            = 61329,//rank 3
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+            TURN_THE_TABLES                     = 51629,//rank 3
+            SURPRISE_ATTACKS                    = 32601,
+            ROGUE_VIGOR                         = 14983,
+            //Other
+            //ROGUE_ARMOR_ENERGIZE/*Deathmantle*/ = 27787,
+            GLADIATOR_VIGOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800
+        };
+
+        enum RogueSpecial
+        {
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
+            TURN_THE_TABLES_EFFECT              = 52910,//'rank 3'
+            WAYLAY_EFFECT                       = 51693,
+            //434
+            MURDEROUS_INTENT_EFFECT             = 79132
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..bebe1aa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,1381 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 30%
+TODO:
+*/
+enum TotemSlot
+{
+    T_FIRE  = 0,//m_SummonSlot[1]
+    T_EARTH = 1,//m_SummonSlot[2]
+    T_WATER = 2,//m_SummonSlot[3]
+    T_AIR   = 3,//m_SummonSlot[4]
+    MAX_TOTEMS
+};
+struct TotemParam
+{
+    TotemParam() : effradius(0.f) {}
+    Position pos;
+    float effradius;
+};
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+
+            bool maelstrom = false;
+            if (!triggered)
+                maelstrom = (MaelstromCount >= 5 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1)));
+
+            triggered |= maelstrom;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered, me->GetGUID());
+
+            if (result && maelstrom)
+            {
+                MaelstromCount = 0;
+                me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF, 0, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            return result;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+
+        bool Shielded(Unit* target) const
+        {
+            return
+                (HasAuraName(target, WATER_SHIELD_1) ||
+                HasAuraName(target, EARTH_SHIELD_1) ||
+                HasAuraName(target, LIGHTNING_SHIELD_1));
+        }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (!IsSpellReady(BLOODLUST_1, diff, false) || me->GetDistance(master) > 18 || IsCasting() || Rand() > 15)
+                return;
+            if (!me->IsInCombat() || !master->IsInCombat())
+                return;
+
+            if (HasAuraName(master, BLOODLUST_1))
+            {
+                SetSpellCooldown(BLOODLUST_1, GetSpellCooldown(BLOODLUST_1) + 3000);
+                return;
+            }
+
+            if (Unit* u = me->GetVictim())
+            {
+                Creature* cre = u->ToCreature();
+                if (u->GetMaxHealth() > me->GetHealth() * 2 ||
+                    (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                    me->getAttackers().size() + master->getAttackers().size() > 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(BLOODLUST_1)))
+                    {
+                        GC_Timer = temptimer;
+                        SetSpellCooldown(BLOODLUST_1, 180000); //3 min
+                        return;
+                    }
+                }
+            }
+
+            SetSpellCooldown(BLOODLUST_1, 2000); //fail
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            //update rate
+            if (Rand() > 25)
+                return;
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    if (master->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius &&
+                        me->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius)
+                    {
+                        Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                        if (!to)
+                        {
+                            _totems[i].first = 0;
+                            //TC_LOG_ERROR("entities.player", "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
+                            continue;
+                        }
+
+                        to->ToTotem()->UnSummon();
+                    }
+                }
+            }
+            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
+                return;
+            //Summon
+            //TODO: role-based totems (attack/heal)
+            if (me->IsInCombat())
+            {
+                if (GetSpell(WINDFURY_TOTEM_1) && !_totems[T_AIR].first && !master->m_SummonSlot[T_AIR+1])
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(WINDFURY_TOTEM_1)))
+                    {
+                        if (me->getLevel() >= 57)
+                            GC_Timer = temptimer;
+                        return;
+                    }
+                }
+
+                if (!_totems[T_EARTH].first && !master->m_SummonSlot[T_EARTH+1])
+                {
+                    if (GetSpell(STRENGTH_OF_EARTH_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STRENGTH_OF_EARTH_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(STONESKIN_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STONESKIN_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+
+                if (!_totems[T_FIRE].first && !master->m_SummonSlot[T_FIRE+1])
+                {
+                    if (IsSpellReady(TOTEM_OF_WRATH_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(TOTEM_OF_WRATH_1)))
+                        {
+                            //bot's poor AI cannot use totems wisely so just reduce CD on this
+                            SetSpellCooldown(TOTEM_OF_WRATH_1, 30000); //30 sec, old 5 min
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (IsSpellReady(SEARING_TOTEM_1, diff, false))
+                    {
+                        if (Unit* u = me->GetVictim())
+                        {
+                            if (HasRole(BOT_ROLE_DPS) && me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(me, GetSpell(SEARING_TOTEM_1)))
+                                {
+                                    SetSpellCooldown(SEARING_TOTEM_1, 20000);
+                                    if (me->getLevel() >= 57)
+                                        GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            if (!me->isMoving() && !master->isMoving())
+            {
+                if (!_totems[T_WATER].first && !master->m_SummonSlot[T_WATER+1])
+                {
+                    uint8 manapct = GetManaPCT(master);
+                    uint8 hppct = GetHealthPCT(master);
+                    if (GetSpell(HEALINGSTREAM_TOTEM_1) && hppct < 98 && master->getPowerType() != POWER_MANA &&
+                        (hppct < 25 || manapct > hppct))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(HEALINGSTREAM_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(MANASPRING_TOTEM_1) && (manapct < 97 || GetManaPCT(me) < 90))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(MANASPRING_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 15)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                {
+                    GC_Timer = temptimer;
+                    SetSpellCooldown(THUNDERSTORM_1, 25000); //45 - 20 = 25 sec for mana restore
+                }
+                return;
+            }
+
+            //case 2: knock attackers
+            if (IsTank()) //pretty stupid idea I think
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetExactDist((*iter)) > 9) continue;
+                if (CCed(*iter)) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                {
+                    GC_Timer = temptimer;
+                    SetSpellCooldown(THUNDERSTORM_1, 40000); //45 - 5 = 40 sec for knock
+                }
+                return;
+            }
+        }
+
+        void CheckManaTide(uint32 diff)
+        {
+            if (!IsSpellReady(MANA_TIDE_TOTEM_1, diff, false) || IsCasting() || Rand() > 20)
+                return;
+
+            Group* group = master->GetGroup();
+            if (!group)
+                return;
+
+            uint8 LMPcount = 0;
+            uint8 members = group->GetMembersCount();
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 20) continue;
+                if (tPlayer->getPowerType() != POWER_MANA) continue;
+                if (GetManaPCT(tPlayer) < 35)
+                {
+                    ++LMPcount;
+                    if (LMPcount > 3 || LMPcount > members / 3) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                        if (bot && bot->IsInWorld() && bot->getPowerType() == POWER_MANA &&
+                            bot->GetExactDist(me) < 20 && GetManaPCT(bot) < 35)
+                        {
+                            ++LMPcount;
+                            if (LMPcount > 3 || LMPcount > members / 3) break;
+                        }
+                    }
+                }
+            }
+
+            if (LMPcount > 3 || LMPcount > members / 3)
+            {
+                if (_totems[T_WATER].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[T_WATER].first);
+                    if (!to)
+                        _totems[T_WATER].first = 0;
+                    else
+                        to->ToTotem()->UnSummon();
+                }
+                if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1)))
+                {
+                    SetSpellCooldown(MANA_TIDE_TOTEM_1, 60000); //1 min
+                    return;
+                }
+            }
+
+            SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckThunderStorm(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, CURE_TOXINS, diff);
+            CheckManaTide(diff);
+            CheckTotems(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckDispel(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff myself
+            if (GetSpell(LIGHTNING_SHIELD_1) && !IsTank() && !Shielded(me))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LIGHTNING_SHIELD_1)))
+                    GC_Timer = temptimer;
+            }
+            //heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_SHAMAN))
+                return;
+
+            CheckHexy2(diff);
+
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || Rand() > 60)
+                return;
+
+            Unit* u = me->GetVictim();
+            if (u && u->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(u, GetSpell(WIND_SHEAR_1)))
+                {
+                    SetSpellCooldown(WIND_SHEAR_1, 5000); //improved
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (Unit* target = FindCastingTarget(25))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                {
+                    SetSpellCooldown(WIND_SHEAR_1, 5000);
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (IsCasting()) return;
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && IsMelee() && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
+                {
+                    SetSpellCooldown(STORMSTRIKE_1, 6000); //improved
+                    return;
+                }
+            }
+            //SHOCKS
+            if ((GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                IsSpellReady(FLAME_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && Rand() < 30)
+            {
+                temptimer = GC_Timer;
+
+                bool canFlameShock = (GetSpell(FLAME_SHOCK_1) != 0);
+                if (canFlameShock)
+                {
+                    if (Aura* fsh = opponent->GetAura(GetSpell(FLAME_SHOCK_1), me->GetGUID()))
+                        if (fsh->GetDuration() > 3000)
+                            canFlameShock = false;
+                }
+
+                if (canFlameShock)
+                {
+                    if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
+                    {
+                        SetSpellCooldown(FLAME_SHOCK_1, 3000); //improved twice
+                        SetSpellCooldown(EARTH_SHOCK_1, 3000); //improved twice
+                        SetSpellCooldown(FROST_SHOCK_1, 3000); //improved twice
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                else if (GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1))
+                {
+                    uint32 SHOCK = !GetSpell(FROST_SHOCK_1) ? GetSpell(EARTH_SHOCK_1) : RAND(GetSpell(EARTH_SHOCK_1), GetSpell(FROST_SHOCK_1));
+                    if (SHOCK && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)) &&
+                        !opponent->HasAura(SHOCK))
+                    {
+                        if (doCast(opponent, SHOCK))
+                        {
+                            SetSpellCooldown(FLAME_SHOCK_1, 3000); //improved twice
+                            SetSpellCooldown(EARTH_SHOCK_1, 3000); //improved twice
+                            SetSpellCooldown(FROST_SHOCK_1, 3000); //improved twice
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
+                {
+                    SetSpellCooldown(LAVA_BURST_1, 8000);
+                    return;
+                }
+            }
+
+            if (GetManaPCT(me) < 15 || (MaelstromCount < 5 && IsMelee()))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
+                {
+                    SetSpellCooldown(CHAIN_LIGHTNING_1, 3500); //improved
+                    return;
+                }
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30)
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(opponent, LIGHTNING_BOLT))
+                {
+                    SetSpellCooldown(LIGHTNING_BOLT_1, uint32(float(sSpellMgr->GetSpellInfo(LIGHTNING_BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200));
+                    return;
+                }
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer <= diff)
+            {
+                Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+                HexyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHexy2(uint32 diff)
+        {
+            if (Hexy == false && me->GetVictim() && IsSpellReady(HEX_1, diff, false))
+            {
+                if (Unit* target = FindPolyTarget(20, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(HEX_1)))
+                    {
+                        Hexy = true;
+                        SetSpellCooldown(HEX_1, 30000); //45 - 15 = 30 sec for bots
+                        HexyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer <= diff)
+            {
+                Unit* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 2);
+                Earthy = (u && (IsTank(u) || u == master));
+                EarthyCheckTimer = 1000;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 50 || me->IsMounted()) return;
+
+            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1), master);
+
+            if (Feasting()) return;
+
+            if (Shielded(me) && Rand() < 25)
+            {
+                Aura* shield = NULL;
+                uint32 SHIELD = HasRole(BOT_ROLE_DPS) ? GetSpell(LIGHTNING_SHIELD_1) : 0;
+                if (SHIELD)
+                    shield = me->GetAura(SHIELD);
+                if (!shield && IsTank() && GetSpell(EARTH_SHIELD_1))
+                {
+                    SHIELD = GetSpell(EARTH_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (!shield && GetSpell(WATER_SHIELD_1))
+                {
+                    SHIELD = GetSpell(WATER_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (shield && shield->GetCharges() < 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, SHIELD))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!GetSpell(WATER_WALKING_1) && !GetSpell(WATER_BREATHING_1) && !GetSpell(EARTH_SHIELD_1))
+                return false;
+
+            if (GC_Timer > diff || !target || !target->IsAlive() || Rand() > 40)
+                return false;
+
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && (target == master || IsTank(target)) &&
+                (target->IsInCombat() || !target->isMoving()) &&
+                me->GetExactDist(target) < 40 && Rand() < 75)
+            {
+                bool cast = !Shielded(target);
+                if (!cast)
+                    if (Aura* eShield = target->GetAura(GetSpell(EARTH_SHIELD_1)))
+                        if (eShield->GetCharges() < 5)
+                            cast = true;
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                {
+                    Earthy = true;
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->GetExactDist(target) > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff, false) || IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, GetSpell(PURGE_1)))
+                SetSpellCooldown(PURGE_1, 1000);
+
+            SetSpellCooldown(PURGE_1, 3000);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 97)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //PLACEHOLDER: Instant spell req. interrupt current spell
+
+            if (IsCasting()) return false;
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) &&
+                ((hp > 70 && hp < 85) || hp < 50 || GetLostHP(target) > 1800) && Rand() < 75)
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                hp > 40 && (hp < 75 || GetLostHP(target) > 4000) && Rand() < 65)
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) &&
+                ((hp > 40 && hp < 90) || GetLostHP(target) > 1300) && Rand() < 120)
+            {
+                if (IsSpellReady(RIPTIDE_1, diff, false) && (hp < 85 || GetLostHP(target) > 2500) &&
+                    !target->HasAura(GetSpell(RIPTIDE_1)))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(target, GetSpell(RIPTIDE_1), true))
+                    {
+                        SetSpellCooldown(RIPTIDE_1, 5000);
+                        if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                }
+                else if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                //if (lvl >= 15 && spellId == CLEAVE /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                //    aftercrit += 15.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm,
+                if (lvl >= 30 &&
+                    (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                    spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                    spellId == GetSpell(THUNDERSTORM_1)))
+                    aftercrit += 5.f;
+                //Tidal Mastery (part 2): 5% additional critical chance for lightning spells
+                if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & spellInfo->GetSchoolMask()))
+                    aftercrit += 5.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if (lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+
+            //flat damage mods (temp)
+            ////Shamanism: 25% bonus damage from bonus damage effects for Lightning Bolt, Chain Lightning and Lava Burst
+            //if (lvl >= 55 &&
+            //    (spellId == LIGHTNING_BOLT ||
+            //    spellId == CHAIN_LIGHTNING ||
+            //    spellId == LAVA_BURST))
+            //    fdamage += float(m_spellpower / 4);
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void OnBotDespawn(Creature* summon)
+        {
+            if (!summon)
+            {
+                UnsummonAll();
+                return;
+            }
+
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            _totems[slot].first = 0;
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            totem->SetCreatorGUID(me->GetGUID());
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            float radius = 0.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
+                    radius = entry->RadiusMax;
+
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second.pos.Relocate(*summon);
+            _totems[slot].second.effradius = std::max<float>(radius, 20.f) + 5.f;
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
+            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
+
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            master->m_SummonSlot[++slot] = 0;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon improved: 10% to gain full stack and 30% to add an extra stack
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                {
+                    uint32 stacks = mwb->GetStackAmount();
+                    if (stacks < 5)
+                    {
+                        if (urand(1,100) <= 10)
+                            mwb->ModStackAmount(5);
+                        if (urand(1,100) <= 30)
+                            mwb->ModStackAmount(1);
+                    }
+
+                    MaelstromCount = mwb->GetStackAmount();
+                }
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (spellId == GetSpell(LIGHTNING_SHIELD_1) ||
+                spellId == GetSpell(EARTH_SHIELD_1)/* ||
+                spellId == GetSpell(WATER_SHIELD_1)*/)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 12);
+                }
+            }
+            //Lightning Overload: 20% cast SAME spell with no mana! make sure this does not proc on itself!
+            if (me->getLevel() >= 40 && (spellId == GetSpell(LIGHTNING_SHIELD_1) || spellId == GetSpell(CHAIN_LIGHTNING_1)))
+            {
+                bool cast = (urand(1,100) <= 20);
+                if (spellId == GetSpell(LIGHTNING_BOLT_1))
+                {
+                    if (LOvBolt == false)
+                    {
+                        if (cast)
+                        {
+                            LOvBolt = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvBolt = false;
+                }
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1))
+                {
+                    if (LOvChain == false)
+                    {
+                        if (cast)
+                        {
+                            LOvChain = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvChain = false;
+                }
+            }
+            if (spellId == GetSpell(STORMSTRIKE_1))
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(target, WINDFURY_PROC, true);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(victim, WINDFURY_PROC, true);
+                }
+            }
+
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first != 0)
+                {
+                    Unit* to = sObjectAccessor->FindUnit(_totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void Reset()
+        {
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            MaelstromTimer = 0;
+            WindfuryTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            LOvBolt = false;
+            LOvChain = false;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_SHAMAN);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount > 0)        MaelstromCount = 0;
+
+            if (WindfuryTimer > diff)           WindfuryTimer -= diff;
+            else                                WindfuryTimer = 0;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            CURE_TOXINS = lvl >= 39 ? CLEANSE_SPIRIT_1 : InitSpell(me, CURE_TOXINS_1);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+     /*NYI*///InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+  /*CUSTOM*/lvl >= 60 ? InitSpellMap(BLOODLUST_1) : RemoveSpell(BLOODLUST_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(STONESKIN_TOTEM_1) : RemoveSpell(STONESKIN_TOTEM_1);
+            InitSpellMap(HEALINGSTREAM_TOTEM_1);
+            InitSpellMap(MANASPRING_TOTEM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SEARING_TOTEM_1) : RemoveSpell(SEARING_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 58)
+                RefreshAura(ELEMENTAL_WARDING,2); //12%
+            else if (level >= 15)
+                RefreshAura(ELEMENTAL_WARDING); //6%
+            if (level >= 18)
+                RefreshAura(ELEMENTAL_DEVASTATION3); //9%
+            else if (level >= 15)
+                RefreshAura(ELEMENTAL_DEVASTATION2); //6%
+            else if (level >= 12)
+                RefreshAura(ELEMENTAL_DEVASTATION1); //3%
+            if (level >= 30)
+                RefreshAura(ANCESTRAL_KNOWLEDGE,3); //30%
+            else if (level >= 20)
+                RefreshAura(ANCESTRAL_KNOWLEDGE,2); //20%
+            else if (level >= 10)
+                RefreshAura(ANCESTRAL_KNOWLEDGE); //10%
+            if (level >= 25)
+                RefreshAura(TOUGHNESS); //10%, 30%
+            if (level >= 29)
+                RefreshAura(FLURRY5); //30%
+            else if (level >= 28)
+                RefreshAura(FLURRY4); //24%
+            else if (level >= 27)
+                RefreshAura(FLURRY3); //18%
+            else if (level >= 26)
+                RefreshAura(FLURRY2); //12%
+            else if (level >= 25)
+                RefreshAura(FLURRY1); //6%
+            if (level >= 50)
+                RefreshAura(WEAPON_MASTERY,3); //30%
+            else if (level >= 40)
+                RefreshAura(WEAPON_MASTERY,2); //20%
+            else if (level >= 30)
+                RefreshAura(WEAPON_MASTERY); //10%
+            if (level >= 45)
+                RefreshAura(STATIC_SHOCK,2); //12%
+            else if (level >= 41)
+                RefreshAura(STATIC_SHOCK); //6%
+            if (level >= 20)
+                RefreshAura(ANCESTRAL_HEALING); //10%
+            if (level >= 50)
+                RefreshAura(ANCESTRAL_AWAKENING); //30%
+
+            if (level >= 70)
+                RefreshAura(SHAMAN_T10_RESTO_4P); //25%
+
+            if (level >= 40)
+            {
+                if (level >= 70)
+                    RefreshAura(MAELSTROM_WEAPON5,2);
+                else if (level >= 60)
+                    RefreshAura(MAELSTROM_WEAPON5);
+                else if (level >= 55)
+                    RefreshAura(MAELSTROM_WEAPON4);
+                else if (level >= 50)
+                    RefreshAura(MAELSTROM_WEAPON3);
+                else if (level >= 45)
+                    RefreshAura(MAELSTROM_WEAPON2);
+                else// if (level >= 40)
+                    RefreshAura(MAELSTROM_WEAPON1);
+
+                RefreshAura(UNLEASHED_RAGE);
+                RefreshAura(IMPROVED_STORMSTRIKE); //20%
+                RefreshAura(ELEMENTAL_OATH);
+            }
+
+            EARTHLIVING_WEAPON =
+                level >= 70 ? EARTHLIVING_WEAPON_PASSIVE_6 :
+                level >= 50 ? EARTHLIVING_WEAPON_PASSIVE_5 :
+                level >= 30 ? EARTHLIVING_WEAPON_PASSIVE_4 : 0;
+            if (EARTHLIVING_WEAPON)
+            {
+                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_4);
+                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_5);
+                me->RemoveAurasDueToSpell(EARTHLIVING_WEAPON_PASSIVE_6);
+                RefreshAura(EARTHLIVING_WEAPON, 3);
+            }
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CURE_TOXINS_1:
+                case CLEANSE_SPIRIT_1:
+                case BLOODLUST_1:
+                case WATER_SHIELD_1:
+                case MANA_TIDE_TOTEM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::pair<uint64 /*guid*/, TotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 CURE_TOXINS;
+        uint32 EARTHLIVING_WEAPON;
+        //Timers
+        uint32 HexyCheckTimer, EarthyCheckTimer, MaelstromTimer, WindfuryTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy, LOvChain, LOvBolt;
+
+        enum ShamanBaseSpells
+        {
+            HEALING_WAVE_1                      = 331,
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEALING_WAVE_1               = 8004,
+            RIPTIDE_1                           = 61295,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            CURE_TOXINS_1                       = 526,
+            CLEANSE_SPIRIT_1                    = 51886,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            FROST_SHOCK_1                       = 8056,
+            STORMSTRIKE_1                       = 17364,
+            LIGHTNING_BOLT_1                    = 403,
+            CHAIN_LIGHTNING_1                   = 421,
+            LAVA_BURST_1                        = 51505,
+            THUNDERSTORM_1                      = 51490,
+            LIGHTNING_SHIELD_1                  = 324,
+            EARTH_SHIELD_1                      = 974,
+            WATER_SHIELD_1                      = 52127,
+            WATER_BREATHING_1                   = 131,
+            WATER_WALKING_1                     = 546,
+            //BLOODLUST_1                         = 54516,//custom, moved to specials
+            PURGE_1                             = 370,
+            WIND_SHEAR_1                        = 57994,
+            HEX_1                               = 51514,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+            STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+            TOTEM_OF_WRATH_1                    = 30706,
+            MANA_TIDE_TOTEM_1                   = 16190
+        };
+
+        enum ShamanPassives
+        {
+            //Elemental
+            ELEMENTAL_DEVASTATION1              = 30160,
+            ELEMENTAL_DEVASTATION2              = 29179,
+            ELEMENTAL_DEVASTATION3              = 29180,
+            ELEMENTAL_WARDING                   = 28998,//rank 3
+            ELEMENTAL_OATH                      = 51470,//rank 2
+            //Enchancement
+            ANCESTRAL_KNOWLEDGE                 = 17489,//rank 5
+            TOUGHNESS                           = 16309,//rank 5
+            FLURRY1                             = 16256,
+            FLURRY2                             = 16281,
+            FLURRY3                             = 16282,
+            FLURRY4                             = 16283,
+            FLURRY5                             = 16284,
+            WEAPON_MASTERY                      = 29086,//rank 3
+            UNLEASHED_RAGE                      = 30809,//rank 3
+            STATIC_SHOCK                        = 51527,//rank 3
+            IMPROVED_STORMSTRIKE                = 51522,//rank 2
+            MAELSTROM_WEAPON1                   = 51528,
+            MAELSTROM_WEAPON2                   = 51529,
+            MAELSTROM_WEAPON3                   = 51530,
+            MAELSTROM_WEAPON4                   = 51531,
+            MAELSTROM_WEAPON5                   = 51532,
+            //Restoration
+            ANCESTRAL_HEALING                   = 16240,//rank 3
+            ANCESTRAL_AWAKENING                 = 51558,//rank 3
+            //Special
+            SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+        };
+
+        enum ShamanSpecial
+        {
+            //2 extra white attacks
+            //100 yd
+            //"Increases attack power for 1.50 sec"
+            //Warning! can proc even from itself!
+            WINDFURY_PROC                       = 32910,
+            //"Increases melee,ranged and spell casting speed by 35%
+            //for all party members. Lasts 20 sec."
+            //250 mana, 20 yd
+            //affects raid
+            //no penalty
+            BLOODLUST_1                         = 54516,
+            //20% chance to put HoT on healed target over 12 sec
+            EARTHLIVING_WEAPON_PASSIVE_4        = 52005,//348 base hp
+            EARTHLIVING_WEAPON_PASSIVE_5        = 52007,//456 base hp
+            EARTHLIVING_WEAPON_PASSIVE_6        = 52008,//652 base hp
+
+            MAELSTROM_WEAPON_BUFF               = 53817,
+            STORMSTRIKE_DAMAGE                  = 32175,
+            STORMSTRIKE_DAMAGE_OFFHAND          = 32176
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..250088f
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,547 @@
+#include "bot_ai.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 3%
+TODO:
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->SetBotsPetDied(); master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+            feartimer = std::max<uint32>(feartimer, 1000);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            ////if pet is dead or unreachable
+            //Creature* m_botsPet = me->GetBotsPet();
+            //if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+            //    if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+            //        SummonBotsPet(PET_VOIDWALKER);
+
+            //TODO: implement healthstone
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            //TODO: add more damage spells
+
+            if (feartimer <= diff && GC_Timer <= diff)
+            { CheckFear(); feartimer = 2000; }
+
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 25)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(RAIN_OF_FIRE_1)))
+                {
+                    SetSpellCooldown(RAIN_OF_FIRE_1, 5000);
+                    return;
+                }
+                SetSpellCooldown(RAIN_OF_FIRE_1, 2000);//fail
+            }
+
+            float dist = me->GetExactDist(opponent);
+
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < 30 && Rand() < 15 &&
+                !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(opponent, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (IsSpellReady(CORRUPTION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(CORRUPTION_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(CORRUPTION_1)))
+                return;
+
+            if (IsSpellReady(HAUNT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(HAUNT_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(HAUNT_1)))
+            {
+                SetSpellCooldown(HAUNT_1, 8000);
+                return;
+            }
+
+            if (GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (GetSpellCooldown(CONFLAGRATE_1) <= 8000 && doCast(opponent, GetSpell(IMMOLATE_1)))
+                    return;
+                else if (doCast(opponent, GetSpell(UNSTABLE_AFFLICTION_1)))
+                    return;
+            }
+
+            if (IsSpellReady(CONFLAGRATE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 35 &&
+                HasAuraName(opponent, IMMOLATE_1) &&
+                doCast(opponent, GetSpell(CONFLAGRATE_1)))
+            {
+                SetSpellCooldown(CONFLAGRATE_1, 8000);
+                return;
+            }
+
+            if (IsSpellReady(CHAOS_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50 &&
+                doCast(opponent, GetSpell(CHAOS_BOLT_1)))
+            {
+                SetSpellCooldown(CHAOS_BOLT_1, me->getLevel() < 80 ? 10000 : 8000);
+                return;
+            }
+
+            if (IsSpellReady(SHADOW_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 &&
+                doCast(opponent, GetSpell(SHADOW_BOLT_1)))
+                return;
+        }
+
+        uint8 Afflicted(Unit* target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Shatter: frozen targets crit
+                //if (lvl >= 11 && damageinfo.target && damageinfo.target->isFrozen())
+                //    aftercrit *= 4.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Spell Power: 50% additional crit damage bonus for All spells
+                //if (lvl >= 55)
+                //    pctbonus += 0.333f;
+            }
+            //if (lvl >= 11 && spellId == FROSTBOLT && damageinfo.target && damageinfo.target->isFrozen())
+            //    pctbonus *= 0.2f;
+
+            ////Spellpower bonus damage (temp)
+            //if (m_spellpower > 0)
+            //{
+            //    if (spellId == SHADOW_BOLT)
+            //        fdamage += m_spellpower * 1.38f;
+            //    else if (spellId == IMMOLATE)
+            //        fdamage += m_spellpower * 0.75f; //guessed
+            //    else if (spellId == CONFLAGRATE)
+            //        fdamage += m_spellpower * 2.75f; //guessed
+            //    else if (spellId == CHAOS_BOLT)
+            //        fdamage += m_spellpower * 2.25f * 1.24f;
+            //    else if (spellId == RAIN_OF_FIRE || spellId == 42223)
+            //        fdamage += m_spellpower * 0.25f * 4.f;
+            //    else if (spellId == HAUNT)
+            //        fdamage += m_spellpower * 1.75f;
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+
+            //float pct_mod = 1.f;
+
+            //Spellpower bonus damage (temp)
+            //if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            //{
+            //    if (spellId == CORRUPTION)
+            //        value += m_spellpower * 1.35f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == IMMOLATE)
+            //        value += m_spellpower * 1.59f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == UNSTABLE_AFFLICTION)
+            //        value += m_spellpower * 1.68f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //}
+
+            //value *= pct_mod;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            feartimer = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_WARLOCK);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (feartimer > diff)                   feartimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            lvl >= 40 ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+            InitSpellMap(CORRUPTION_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+            InitSpellMap(FEAR_1);
+        }
+
+        //TODO
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+        uint32 feartimer;
+
+        enum WarlockBaseSpells
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //TORMENT
+            if (IsSpellReady(TORMENT_1, diff, false) && meleedist < 5 && !IsTank(opponent->GetVictim()))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TORMENT_1)))
+                {
+                    SetSpellCooldown(TORMENT_1, 5000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            if (master && m_creatureOwner)
+            {
+                SetStats(true);
+                ApplyPassives(PET_TYPE_VOIDWALKER);
+                ApplyClassPassives();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            InitSpellMap(TORMENT_1);
+        }
+
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..56f6556
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1144 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 40-45%
+TODO: Thunder Clap, Piercing Howl, Challenging Shout, other tanking stuff
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature) { }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            if (ragetimer2 <= diff)
+            {
+                if (me->IsInCombat() && me->getLevel() >= 20)
+                {
+                    if (getrage() < 990)
+                        me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000);//max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat() && !HasAuraName(me, BLOODRAGE_1))
+                {
+                    if (getrage() > uint32(10.f*rageLossMult))
+                        me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 1500;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckIntervene(diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_WARRIOR))
+            {
+                if (!IsTank() && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() &&
+                    stancetimer <= diff && Rand() < 25)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (IsSpellReady(BATTLESHOUT_1, diff) && getrage() > 100 && Rand() < 30 &&
+                !HasAuraName(master, BATTLESHOUT_1) && !HasAuraName(master, BLESSING_OF_MIGHT_1) &&
+                !HasAuraName(master, GREATER_BLESSING_OF_MIGHT_1) && master->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(BATTLESHOUT_1)))
+                {
+                    SetSpellCooldown(BATTLESHOUT_1, 25000);
+                    return;
+                }
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && getrage() < 600 &&
+                Rand() < 20 && !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                {
+                    SetSpellCooldown(BLOODRAGE_1, 40000);
+                    GC_Timer = temptimer;
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u)
+        {
+            //victorious state emulation
+            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, VICTORIOUS_SPELL, true))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < uint32(abs(mod)))
+            {
+                //debug set rage to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                rage = mod ? mod*10 : 0;
+            else
+                rage += mod*10;
+
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        uint32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            return rage;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (IsSpellReady(BERSERKERRAGE_1, diff) && Rand() < 35 && !me->HasAura(ENRAGED_REGENERATION_1) &&
+                    doCast(me, GetSpell(BERSERKERRAGE_1)))
+                {
+                    SetSpellCooldown(BERSERKERRAGE_1, 25000);
+                    if (me->getLevel() >= 40)
+                        doCast(me, 58096, true); //Berserker Rage Effect (434 unused)
+                    return;
+                }
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep defensive stance if tank
+            if (IsTank() && defensiveStance != true && stancetimer <= diff)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && getrage() > 150 && GetHealthPCT(me) < 40 &&
+                Rand() < 40 && me->HasAuraWithMechanic(uint32(1<<MECHANIC_ENRAGED)))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                {
+                    SetSpellCooldown(ENRAGED_REGENERATION_1, 90000);
+                    GC_Timer = 500;
+                    return;
+                }
+            }
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                (me->getLevel() >= 50 ||
+                (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            {
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 29)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+                {
+                    SetSpellCooldown(CHARGE_1, 12000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (IsSpellReady(INTERCEPT_1, diff, false) && !IsTank() &&
+                getrage() > 100 && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                !CCed(opponent) && (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, GetSpell(INTERCEPT_1)))
+                {
+                    SetSpellCooldown(INTERCEPT_1, 20000);
+                    return;
+                }
+            }
+            //SelfHeal 2
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && VICTORIOUS && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                (b_attackers.size() <= 1 || (GetHealthPCT(me) < std::max<int32>(100 - b_attackers.size() * 10, 75))))
+            {
+                if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
+                    return;
+            }
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && getrage() > 250)
+            {
+                if (opponent->IsNonMeleeSpellCasted(false, false, true) && dist <= 8 &&
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
+                    {
+                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
+                        return;
+                    }
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->getClass() != CLASS_DEATH_KNIGHT &&
+                    master->getClass() != CLASS_WARRIOR &&
+                    master->getClass() != CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                    {
+                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
+                        return;
+                    }
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 0) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 0 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                    {
+                        SetSpellCooldown(INTIMIDATING_SHOUT_1, 45000);
+                        return;
+                    }
+                }
+            }//end FEAR
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50 && getrage() > 50 && meleedist <= 5 &&
+                (battleStance || stancetimer <= diff))
+            {
+                if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
+                {
+                    if (battleStance || stanceChange(diff, 1))
+                    {
+                        if (doCast(opponent, GetSpell(OVERPOWER_1)))
+                        {
+                            me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && Rand() < 50 && getrage() > 100 && meleedist <= 5 && opponent->isMoving() &&
+                (battleStance || berserkerStance || stancetimer <= diff) &&
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //UBERS
+            //Dont use RETA unless capable circumstances
+            if (HasRole(BOT_ROLE_DPS) && Rand() < 20)
+            {
+                if (IsSpellReady(RETALIATION_1, diff) && b_attackers.size() > 4 &&
+                    (battleStance || stanceChange(diff, 1)))
+                {
+                    if (doCast(me, GetSpell(RETALIATION_1)))
+                    {
+                        SetSpellCooldown(RETALIATION_1, 150000);
+                        SetSpellCooldown(RECKLESSNESS_1, 150000);
+                        return;
+                    }
+                }
+                //Dont use RECKL unless capable circumstances
+                if (IsSpellReady(RECKLESSNESS_1, diff) && !IsTank() &&
+                    (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth() * 10) &&
+                    (berserkerStance || stanceChange(diff, 3)))
+                {
+                    if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    {
+                        SetSpellCooldown(RETALIATION_1, 150000);
+                        SetSpellCooldown(RECKLESSNESS_1, 150000);
+                        return;
+                    }
+                }
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATHWISH_1, diff) && getrage() > 100 && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetHealth()/2 && Rand() < 20 &&
+                !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                if (doCast(me, GetSpell(DEATHWISH_1)))
+                {
+                    SetSpellCooldown(DEATHWISH_1, 144000);
+                    return;
+                }
+            }
+            //TAUNT //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && !IsTank(u) && dist <= 30 &&
+                !CCed(opponent) && !IsTankingClass(u->getClass()) && (IsInBotParty(u) || IsTank()) &&
+                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TAUNT_1), true))
+                {
+                    SetSpellCooldown(TAUNT_1, 8000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && getrage() > 150 && meleedist <= 5 &&
+                Rand() < 70 &&GetHealthPCT(opponent) < 20 &&
+                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, GetSpell(EXECUTE_1)))
+                {
+                    //sudden death
+                    if (me->getLevel() >= 50 && getrage() <= 400)
+                        modrage(10, true);
+                    else if (getrage() > 300)
+                        modrage(-30);
+                    else
+                        modrage(0, true);
+                    return;
+                }
+            }
+            //SUNDER //custom cd condition
+            if (GetSpell(SUNDER_1) && GC_Timer <= diff && getrage() > 150 &&
+                (getrage() > 500 || IsSpellReady(SUNDER_1,diff, false)) &&
+                meleedist <= 5 && IsTank() && opponent->GetHealth() > me->GetMaxHealth() && Rand() < 35)
+            {
+                Aura* sunder = opponent->GetAura(GetSpell(SUNDER_1), me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) &&
+                    doCast(opponent, GetSpell(SUNDER_1)))
+                {
+                    SetSpellCooldown(SUNDER_1, 7000);
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //SS //no GCD //no rage (glyph)
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 25 &&
+                (battleStance || berserkerStance || stancetimer <= diff) &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1), true))
+                {
+                    SetSpellCooldown(SWEEPING_STRIKES_1, 30000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && getrage() >= 250 && HasRole(BOT_ROLE_DPS) && !IsTank() && Rand() < 50 &&
+               (FindSplashTarget(7, opponent) || (getrage() > 800 && dist <= 7)) &&
+               (berserkerStance || stancetimer <= diff))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                {
+                    SetSpellCooldown(WHIRLWIND_1, 6500);
+                    return;
+                }
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+               getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS_1)) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                {
+                    SetSpellCooldown(BLADESTORM_1, 60000);
+                    return;
+                }
+            }
+            //Mortal Strike
+            if (IsSpellReady(MORTALSTRIKE_1, diff) && getrage() > 300 && HasRole(BOT_ROLE_DPS) && meleedist <= 5)
+            {
+                if (doCast(opponent, GetSpell(MORTALSTRIKE_1)))
+                {
+                    SetSpellCooldown(MORTALSTRIKE_1, 7000);
+                    ResetSpellCooldown(SLAM_1); //reset here
+                }
+            }
+            //Slam
+            if (IsSpellReady(SLAM_1, diff))
+            {
+                bool triggered = (GetSpellCooldown(MORTALSTRIKE_1) == 7000);
+                if (getrage() > 150 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && Rand() < (30 + triggered * 30))
+                {
+                    if (doCast(opponent, GetSpell(SLAM_1), true))
+                    {
+                        SetSpellCooldown(SLAM_1, 3000); //must be > 7000/2
+                        modrage(-15);
+                        return;
+                    }
+                }
+            }
+            //PUMMEL
+            if (IsSpellReady(PUMMEL_1, diff, false) && Rand() < 80 && getrage() > 100 && meleedist <= 5 &&
+                opponent->IsNonMeleeSpellCasted(false) &&
+                (berserkerStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(opponent, GetSpell(PUMMEL_1)))
+                {
+                    SetSpellCooldown(PUMMEL_1, 10000);
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && Rand() < 50 && getrage() > 100 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                opponent->GetHealth() > me->GetHealth()/2 &&
+                !opponent->HasAura(GetSpell(REND_1), me->GetGUID()) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(REND_1)))
+                    return;
+            }
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && getrage() > 200 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && Rand() < 30)
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, GetSpell(CLEAVE_1)))
+                {
+                    SetSpellCooldown(CLEAVE_1, me->getAttackTimer(BASE_ATTACK)); //once per swing, prevents rage loss
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            else {}//HEROIC STRIKE placeholder
+            //DISARM DEPRECATED
+            /*if (disarm_cd <= diff && meleedist < 5 &&
+                (opponent->GetVictim()->GetGUID() == master->GetGUID() ||
+                opponent->GetVictim()->GetGUID() == m_creature->GetGUID()) &&
+                getrage() > 15 &&
+                !HasAuraName(opponent, GetSpellName(DISARM)) &&
+                GC_Timer <= diff)
+            {
+                if (opponent->getClass() == CLASS_ROGUE  ||
+                    opponent->getClass() == CLASS_WARRIOR   ||
+                    opponent->getClass() == CLASS_SHAMAN    ||
+                    opponent->getClass() == CLASS_PALADIN)
+                {
+                    if (defensiveStance == true)
+                    {
+                        doCast(opponent, DISARM, true);
+                        //rage -= 100;
+                        disarm_cd = DISARM_CD;
+                    }
+                    else stanceChange(diff, 2);
+                }
+            }*/
+        }//end Attack
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (IsSpellReady(INTERVENE_1, diff, false) && getrage() > 100 &&
+                Rand() < (IsTank() ? 80 : 30) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 24 && mydist > 19 && (defensiveStance || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            SetSpellCooldown(INTERVENE_1, 20000);
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                Group* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            SetSpellCooldown(INTERVENE_1, 20000);
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || IsTank(tPlayer)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 24 || dist < 10) continue;
+                        if (defensiveStance || stanceChange(diff, 2))
+                        {
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                            {
+                                SetSpellCooldown(INTERVENE_1, 20000);
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                        {
+                            Creature* bot = tPlayer->GetBotMap(i)->_Cre();
+                            if (!bot || !bot->IsInWorld() || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || IsTank(bot)) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if (defensiveStance || stanceChange(diff, 2))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(bot, GetSpell(INTERVENE_1)))
+                                {
+                                    SetSpellCooldown(INTERVENE_1, 20000 / 2);
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (!(stancetimer <= diff) || !stance)
+                return false;
+
+            if (stance == 5)
+            {
+                if (urand(1,100) > 50)
+                    stance = 1;
+                else
+                    stance = me->getLevel() < 30 ? 1 : (urand(1,100) > 75 ? 3 : 1);
+            }
+            else if (stance == 4)
+            {
+                if (urand(1,100) > 50)
+                    stance = 1;
+                else
+                    stance = IsTank() ? 2 : 1;
+            }
+
+            if (stance == 2 && me->getLevel() < 10)
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            temptimer = GC_Timer;
+            //stance mastery impl
+            uint32 temprage = 0;
+            uint32 myrage = me->GetPower(POWER_RAGE);
+            if (me->getLevel() >= 20)
+                temprage = myrage > 250 ? 250 : myrage;
+            else if (me->getLevel() >= 15)
+                temprage = myrage > 100 ? 100 : myrage;
+            switch (stance)
+            {
+                case 1:
+                    if (doCast(me, GetSpell(BATTLESTANCE_1)))
+                    {
+                        if (me->HasAura(BATTLESTANCE_1))
+                        {
+                            battleStance = true;
+                            defensiveStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 2:
+                    if (doCast(me, GetSpell(DEFENSIVESTANCE_1)))
+                    {
+                        if (me->HasAura(DEFENSIVESTANCE_1))
+                        {
+                            defensiveStance = true;
+                            battleStance = false;
+                            berserkerStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 3:
+                    if (doCast(me, GetSpell(BERSERKERSTANCE_1)))
+                    {
+                        if (me->HasAura(BERSERKERSTANCE_1))
+                        {
+                            berserkerStance = true;
+                            battleStance = false;
+                            defensiveStance = false;
+                            me->SetPower(POWER_RAGE, temprage);
+                            stancetimer = 2100 - me->getLevel()*20;//500 on 80
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                if (lvl >= 15 && spellId == GetSpell(CLEAVE_1) /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                    aftercrit += 15.f;
+                //Improved Overpower: 50% additional critical chance for Overpower
+                if (lvl >= 20 && spellId == GetSpell(OVERPOWER_1))
+                    aftercrit += 50.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+            }
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (spellId == GetSpell(REND_1))
+                pctbonus += 0.2f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if (lvl >= 40 && spellId == GetSpell(WHIRLWIND_1))
+                pctbonus += 0.2f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if (lvl >= 45 && (spellId == GetSpell(OVERPOWER_1)/* || spellId == REVENGE*/))
+                pctbonus += 0.2f;
+            //Improved Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if (lvl >= 55 && (spellId == GetSpell(WHIRLWIND_1) || spellId == GetSpell(SLAM_1) /*|| spellId == BLOODTHIRST*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            switch (spell->Id)
+            {
+                case VICTORIOUS_SPELL:
+                    VICTORIOUS = true;
+                    break;
+                default:
+                    break;
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(OVERPOWER_1))
+            {
+                //Unrelenting Assault
+                if (UNRELENTING_ASSAULT && target->HasUnitState(UNIT_STATE_CASTING))
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
+            }
+            if (spellId == GetSpell(BATTLESHOUT_1)/* || spellId == COMMANDINGSHOUT*/)
+            {
+                //Glyph of Battle/Command + 2 min duration (8 for bots)
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = shout->GetDuration() + 480000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(REND_1))
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(INTERVENE_1))
+            {
+                //Glyph of Intervene + 1 bonus charge (2 for bots)
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                {
+                    vene->SetCharges(vene->GetCharges() + 2);
+                }
+            }
+            if (spellId == GetSpell(VICTORY_RUSH_1))
+            {
+                me->RemoveAura(VICTORIOUS_SPELL);
+                VICTORIOUS = false;
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& /*damage*/, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                for (uint8 i = 0; i != MAX_BOT_CTC_SPELLS; ++i)
+                {
+                    if (_ctc[i].first && !_ctc[i].second)
+                    {
+                        if (urand(1,100) <= CalcCTC(_ctc[i].first))
+                            _ctc[i].second = 1000;
+
+                        if (_ctc[i].second > 0)
+                            me->CastSpell(victim, _ctc[i].first, true);
+                    }
+                }
+            }
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            if (master)
+            {
+                SetStats(true);
+                InitRoles();
+                ApplyPassives(CLASS_WARRIOR);
+            }
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            CommonTimers(diff);
+            SpellTimers(diff);
+
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+            //InitSpellMap(DISARM_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKERRAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+            InitSpellMap(BATTLESHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MORTALSTRIKE_1) : RemoveSpell(MORTALSTRIKE_1);
+            InitSpellMap(SLAM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_1) : RemoveSpell(SUNDER_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+            InitSpellMap(BATTLESTANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVESTANCE_1) : RemoveSpell(DEFENSIVESTANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKERSTANCE_1) : RemoveSpell(BERSERKERSTANCE_1);
+            InitSpellMap(RECKLESSNESS_1);
+            InitSpellMap(RETALIATION_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(DEATHWISH_1) : RemoveSpell(DEATHWISH_1);
+            InitSpellMap(VICTORY_RUSH_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 70)
+                RefreshAura(WC5); //10%
+            else if (level >= 68)
+                RefreshAura(WC4); //8%
+            else if (level >= 66)
+                RefreshAura(WC3); //6%
+            else if (level >= 64)
+                RefreshAura(WC2); //4%
+            else if (level >= 62)
+                RefreshAura(WC1); //2%
+            if (level >= 39)
+                RefreshAura(FLURRY5); //30%
+            else if (level >= 38)
+                RefreshAura(FLURRY4); //24%
+            else if (level >= 37)
+                RefreshAura(FLURRY3); //18%
+            else if (level >= 36)
+                RefreshAura(FLURRY2); //12%
+            else if (level >= 35)
+                RefreshAura(FLURRY1); //6%
+            if (level >= 60)
+                RefreshAura(SWORD_SPEC5,2);//twice
+            else if (level >= 50)
+                RefreshAura(SWORD_SPEC5);//once
+            else if (level >= 45)
+                RefreshAura(SWORD_SPEC4);//once
+            else if (level >= 40)
+                RefreshAura(SWORD_SPEC3);//once
+            else if (level >= 35)
+                RefreshAura(SWORD_SPEC2);//once
+            else if (level >= 30)
+                RefreshAura(SWORD_SPEC1);//once
+            if (level >= 60)
+                RefreshAura(RAMPAGE);
+            if (level >= 55)
+                RefreshAura(TRAUMA2); //30%
+            else if (level >= 35)
+                RefreshAura(TRAUMA1); //15%
+            if (level >= 35)
+                UNRELENTING_ASSAULT = true;
+            if (level >= 45)
+                RefreshAura(BLOOD_FRENZY);
+            if (level >= 40)
+                RefreshAura(SECOND_WIND);
+            if (level >= 40)
+                RefreshAura(TOUGHNESS,2); //-60%
+            else if (level >= 15)
+                RefreshAura(TOUGHNESS); //-30%
+            if (level >= 40)
+                RefreshAura(IMP_HAMSTRING,2); //30%
+            else if (level >= 35)
+                RefreshAura(IMP_HAMSTRING); //15%
+            if (level >= 30)
+                RefreshAura(TASTE_FOR_BLOOD3); //100%
+            else if (level >= 28)
+                RefreshAura(TASTE_FOR_BLOOD2); //66%
+            else if (level >= 25)
+                RefreshAura(TASTE_FOR_BLOOD1); //33%
+            if (level >= 30)
+                RefreshAura(BLOOD_CRAZE3);
+            else if (level >= 25)
+                RefreshAura(BLOOD_CRAZE2);
+            else if (level >= 20)
+                RefreshAura(BLOOD_CRAZE1);
+            //BloodRage Absorb
+            if (level >= 60)
+                RefreshAura(WARRIOR_T10_4P);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case ENRAGED_REGENERATION_1:
+                case BLOODRAGE_1:
+                case BERSERKERRAGE_1:
+                case BATTLESHOUT_1:
+                //case SWEEPING_STRIKES_1: //unable - need stance
+                case RETALIATION_1:
+                case RECKLESSNESS_1:
+                case DEATHWISH_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2;
+/*misc*/uint32 rage;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, UNRELENTING_ASSAULT, VICTORIOUS;
+
+        enum WarriorBaseSpells
+        {
+            //CHALLENGING_SHOUT_1                     = 1161,
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            //DISARM_1                                = 676,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+            MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,
+            SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,
+            DEFENSIVESTANCE_1                       = 71,
+            BERSERKERSTANCE_1                       = 2458,
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 22857,//20230, original warrior spell
+            DEATHWISH_1                             = 12292,
+            VICTORY_RUSH_1                          = 34428
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
+            UNRELENTING_ASSAULT_SPELL               = 65925,//64849
+            VICTORIOUS_SPELL                        = 32216,
+            //COLOSSUS_SMASH_EFFECT                   = 108126,
+            SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+
+            BLESSING_OF_MIGHT_1                     = 19740,
+            GREATER_BLESSING_OF_MIGHT_1             = 25782
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..61c2ab7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,475 @@
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npcbot related commands
+Category: commandscripts/custom/
+*/
+
+#include "bot_ai.h"
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "Group.h"
+#include "Language.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+class script_bot_commands : public CommandScript
+{
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand npcbotCommandTable[] =
+        {
+            { "add",        rbac::RBAC_PERM_COMMAND_NPCBOT_ADD,     false, &HandleNpcBotAddCommand,             "", NULL },
+            { "remove",     rbac::RBAC_PERM_COMMAND_NPCBOT_REMOVE,  false, &HandleNpcBotRemoveCommand,          "", NULL },
+            { "reset",      rbac::RBAC_PERM_COMMAND_NPCBOT_RESET,   false, &HandleNpcBotResetCommand,           "", NULL },
+            { "command",    rbac::RBAC_PERM_COMMAND_NPCBOT_CMD,     false, &HandleNpcBotCommandCommand,         "", NULL },
+            { "distance",   rbac::RBAC_PERM_COMMAND_NPCBOT_DIST,    false, &HandleNpcBotDistanceCommand,        "", NULL },
+            { "info",       rbac::RBAC_PERM_COMMAND_NPCBOT_INFO,    false, &HandleNpcBotInfoCommand,            "", NULL },
+            { "helper",     rbac::RBAC_PERM_COMMAND_NPCBOT_HELPER,  false, &HandleBotHelperCommand,             "", NULL },
+            { "revive",     rbac::RBAC_PERM_COMMAND_NPCBOT_REVIVE,  false, &HandleNpcBotReviveCommand,          "", NULL },
+            { NULL,         0,                                      false, NULL,                                "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "npcbot",     rbac::RBAC_PERM_COMMAND_NPCBOT,         false, NULL,                  "", npcbotCommandTable },
+            { NULL,         0,                                      false, NULL,                                "", NULL }
+        };
+        return commandTable;
+    }
+
+    //static bool HandleReloadEquipsCommand(ChatHandler* handler, const char* /*args*/)
+    //{
+    //    sLog->outInfo(LOG_FILTER_GENERAL, "Re-Loading Creature Equips...");
+    //    sObjectMgr->LoadEquipmentTemplates();
+    //    handler->SendGlobalGMSysMessage("DB table `creature_equip_template` (creature equipment) reloaded.");
+    //    return true;
+    //}
+
+    static bool HandleBotHelperCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        handler->SetSentErrorMessage(true);
+        if (/*player->IsInCombat() ||*/
+            player->isDead() ||
+            !player->IsAlive() ||
+            player->IsInFlight() ||
+            player->IsCharmed() ||
+            bot_ai::CCed(player))
+        {
+            handler->SendSysMessage("You cannot do this right now");
+            return false;
+        }
+        //close current menu
+        player->PlayerTalkClass->SendCloseGossip();
+        if (player->GetTrader())
+            player->GetSession()->SendCancelTrade();
+
+        BotHelper* hlpr = player->GetBotHelper();
+        if (!hlpr)
+        {
+            hlpr = new BotHelper(player);
+            player->SetBotHelper(hlpr);
+        }
+        return hlpr->OnGossipHello(player);
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
+        {
+            handler->PSendSysMessage("You should select self or one of your party members.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = CLASS_WARRIOR; i != MAX_CLASSES; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            for (uint8 pos = 0; pos != master->GetMaxNpcBots(); ++pos)
+            {
+                if (Creature* cre = master->GetBotMap(pos)->_Cre())
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            char const* bclass;
+            switch (i)
+            {
+            case CLASS_WARRIOR:         bclass = "Warriors";        break;
+            case CLASS_PALADIN:         bclass = "Paladins";        break;
+            case CLASS_MAGE:            bclass = "Mages";           break;
+            case CLASS_PRIEST:          bclass = "Priests";         break;
+            case CLASS_WARLOCK:         bclass = "Warlocks";        break;
+            case CLASS_DRUID:           bclass = "Druids";          break;
+            case CLASS_DEATH_KNIGHT:    bclass = "Death Knights";    break;
+            case CLASS_ROGUE:           bclass = "Rogues";          break;
+            case CLASS_SHAMAN:          bclass = "Shamans";         break;
+            case CLASS_HUNTER:          bclass = "Hunters";         break;
+            default:                    bclass = "Unknown Class";   break;
+            }
+            if (count > 0)
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
+            handler->PSendSysMessage("min: 0, max: 75");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 75)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->IsInCombat() && owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                {
+                    Creature* cre = owner->GetBotMap(i)->_Cre();
+                    if (!cre || !cre->IsInWorld()) continue;
+                    owner->SendBotCommandState(cre, COMMAND_FOLLOW);
+                }
+            }
+            Group* gr = owner->GetGroup();
+            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
+            {
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
+                    {
+                        pl->SetBotFollowDist(dist);
+                        if (!pl->IsInCombat() && pl->HaveBot())
+                        {
+                            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                            {
+                                Creature* cre = pl->GetBotMap(i)->_Cre();
+                                if (!cre || !cre->IsInWorld()) continue;
+                                pl->SendBotCommandState(cre, COMMAND_FOLLOW);
+                            }
+                        }
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        handler->SendSysMessage("follow distance should be between 0 and 75");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* cre = owner->GetBotMap(i)->_Cre();
+                if (!cre || !cre->IsInWorld()) continue;
+                owner->SendBotCommandState(cre, CommandStates(state));
+            }
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 guid = owner->GetTarget();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Remove selected npcbots. Select yourself to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (guid == owner->GetGUID())
+        {
+            if (owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                    owner->RemoveBot(owner->GetBotMap(i)->_Guid(), true);
+
+                if (!owner->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = ObjectAccessor::GetCreature(*owner, guid);
+        if (cre && cre->GetIAmABot())
+        {
+            Player* master = cre->GetBotOwner();
+            if (!master || (master->GetGUID() != owner->GetGUID()))
+            {
+                handler->PSendSysMessage("You can only remove your own bots");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            uint8 pos = master->GetNpcBotSlot(guid);
+            master->RemoveBot(cre->GetGUID(), true);
+            if (master->GetBotMap(pos)->_Cre() == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        handler->PSendSysMessage("You should select self or your npcbot!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        uint64 guid = owner->GetTarget();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (IS_PLAYER_GUID(guid))
+        {
+            master = owner;
+            all = true;
+        }
+        else if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && master->GetGUID() == owner->GetGUID())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                if (all)
+                    master->RemoveBot(master->GetBotMap(i)->_Guid());
+                else if (master->GetBotMap(i)->_Guid() == guid)
+                {
+                    master->RemoveBot(guid);
+                    break;
+                }
+            }
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    //For debug purposes only
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (owner->InBattleground())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in pvp matches");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!owner->IsInFlight() && owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature* bot = owner->GetBotMap(i)->_Cre();
+                if (bot && !bot->IsAlive())
+                {
+                    owner->SetBot(bot);
+                    owner->CreateBot(0, 0, 0, true);
+                }
+            }
+            handler->PSendSysMessage("NpcBots revived");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot revive");
+        handler->PSendSysMessage("Revive your npcbots if you are all hopelessly dead");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 sel = owner->GetTarget();
+        if (!*args || sel != owner->GetGUID())
+        {
+            handler->PSendSysMessage(".npcbot add");
+            handler->PSendSysMessage("Allows to create npcbot of given class, you should select yourself");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->RestrictBots())
+        {
+            handler->GetSession()->SendNotification("This place is restricted for NpcBots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->isDead())
+        {
+            owner->GetSession()->SendNotification("You're dead!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetGroup() && owner->GetGroup()->isRaidGroup() && owner->GetGroup()->IsFull())
+        {
+            handler->PSendSysMessage("Group is full, aborted");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->GetNpcBotsCount() >= owner->GetMaxNpcBots())
+        {
+            handler->PSendSysMessage("NpcBots limit exceed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* bclass = strtok((char*)args, " ");
+        uint8 botclass = CLASS_NONE;
+
+        if (!strncmp(bclass, "deathknight", 12) || !strncmp(bclass, "deathk", 7) || !strncmp(bclass, "death", 6) || !strncmp(bclass, "deat", 5) ||
+            !strncmp(bclass, "dea", 4) || !strncmp(bclass, "dk", 3) || !strncmp(bclass, "de", 3))
+            botclass = CLASS_DEATH_KNIGHT;
+        else if (!strncmp(bclass, "druid", 6) || !strncmp(bclass, "dru", 4) || !strncmp(bclass, "dr", 3))
+            botclass = CLASS_DRUID;
+        else if (!strncmp(bclass, "hunter", 7) || !strncmp(bclass, "hunt", 5) || !strncmp(bclass, "hun", 4) || !strncmp(bclass, "hu", 3))
+            botclass = CLASS_HUNTER;
+        else if (!strncmp(bclass, "mage", 5) || !strncmp(bclass, "ma", 3))
+            botclass = CLASS_MAGE;
+        else if (!strncmp(bclass, "paladin", 8) || !strncmp(bclass, "pal", 4) || !strncmp(bclass, "pa", 3))
+            botclass = CLASS_PALADIN;
+        else if (!strncmp(bclass, "priest", 7) || !strncmp(bclass, "pri", 4) || !strncmp(bclass, "pr", 3))
+            botclass = CLASS_PRIEST;
+        else if (!strncmp(bclass, "rogue", 6) || !strncmp(bclass, "rog", 4) || !strncmp(bclass, "ro", 3))
+            botclass = CLASS_ROGUE;
+        else if (!strncmp(bclass, "shaman", 7) || !strncmp(bclass, "sham", 5) || !strncmp(bclass, "sha", 4) || !strncmp(bclass, "sh", 3))
+            botclass = CLASS_SHAMAN;
+        else if (!strncmp(bclass, "warlock", 8) || !strncmp(bclass, "warl", 5) || !strncmp(bclass, "lock", 5))
+            botclass = CLASS_WARLOCK;
+        else if (!strncmp(bclass, "warrior", 8) || !strncmp(bclass, "warr", 5))
+            botclass = CLASS_WARRIOR;
+
+        if (botclass == CLASS_NONE)
+        {
+            handler->PSendSysMessage("Wrong bot class");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        else if (botclass == CLASS_DEATH_KNIGHT && owner->getLevel() < 55)
+        {
+            handler->PSendSysMessage("Death Knights will not join you until you reach level 55...");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint8 bots = owner->GetNpcBotsCount();
+        owner->CreateNPCBot(botclass);
+        owner->RefreshBot(0);
+        if (owner->GetNpcBotsCount() > bots)
+        {
+            if (owner->IsInCombat())
+                handler->PSendSysMessage("NpcBot successfully created (%s). Will appear out of combat", owner->GetName().c_str());
+            else
+                handler->PSendSysMessage("NpcBot successfully created (%s).", owner->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.cpp b/src/server/game/AI/NpcBots/bothelper.cpp
new file mode 100644
index 0000000..eaff56f
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.cpp
@@ -0,0 +1,421 @@
+/*
+Bot Helper by Graff (onlysuffering@gmail.com)
+Type: empty-type player-to-self dialog-like manager for npcbot mod
+Complete: ???
+Category: scripts/custom/bots
+*/
+
+#include "bothelper.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+
+const uint8 GroupIcons[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+enum HelperActions
+{
+    ACTION_ENABLE                                               = 1,
+    ACTION_DISABLE                                              = 2,
+    ACTION_TOGGLE                                               = 3
+};
+
+enum BotgiverTexIDs
+{
+    ABANDON_MINION                                              = 3,
+    RECRUIT_MINION                                              = 4,
+    HELP_STR                                                    = 5,
+    ADD_ALL                                                     = 6,
+    REMOVE_ALL                                                  = 7,
+    RECRUIT_WARRIOR                                             = 8,
+    RECRUIT_HUNTER                                              = 9,
+    RECRUIT_PALADIN                                             = 10,
+    RECRUIT_SHAMAN                                              = 11,
+    RECRUIT_ROGUE                                               = 12,
+    RECRUIT_DRUID                                               = 13,
+    RECRUIT_MAGE                                                = 14,
+    RECRUIT_PRIEST                                              = 15,
+    RECRUIT_WARLOCK                                             = 16,
+    RECRUIT_DEATH_KNIGHT                                        = 17,
+    ABOUT_BASIC_STR1                                            = 18,
+    ABOUT_BASIC_STR2                                            = 19,
+    //ABOUT_BASIC_STR3                                            = 20,
+    ABOUT_ICONS_STR1                                            = 21,
+    ABOUT_ICONS_STR2                                            = 22,
+    ICON_STRING_STAR                                            = 23,
+    ICON_STRING_CIRCLE                                          = 24,
+    ICON_STRING_DIAMOND                                         = 25,
+    ICON_STRING_TRIANGLE                                        = 26,
+    ICON_STRING_MOON                                            = 27,
+    ICON_STRING_SQUARE                                          = 28,
+    ICON_STRING_CROSS                                           = 29,
+    ICON_STRING_SKULL                                           = 30,
+    ICON_STRING_UNKNOWN                                         = 31,
+    NO_MORE_AVAILABLE                                           = 32,
+    ONE_MORE_AVAILABLE                                          = 33,
+    SOME_MORE_AVAILABLE                                         = 34,
+    ONE_AVAILABLE                                               = 35,
+    SOME_AVAILABLE                                              = 36,
+
+    ENABLE_STRING,
+    DISABLE_STRING,
+    TOGGLE_STRING,
+    BACK_STRING,
+    ALL_STRING,
+    MAX_STRINGS
+};
+
+enum HelperGossip
+{
+    SENDER_CREATE_NBOT_MENU                                     = 1,
+    SENDER_CREATE_NBOT                                          = 2,
+    SENDER_REMOVE_NBOT_MENU                                     = 7,
+    SENDER_REMOVE_NBOT                                          = 8,
+
+    SENDER_INFO_WHISPER                                         = 9,
+
+    SENDER_MAIN_PAGE,
+    MAX_SENDERS
+};
+
+BotHelper::BotHelper(Player* const master) : _master(master) { }
+BotHelper::~BotHelper() {}
+
+bool BotHelper::OnGossipSelect(Player* player, uint32 sender, uint32 action)
+{
+    switch (sender)
+    {
+        case SENDER_MAIN_PAGE:                          OnGossipHello(player);                              break;
+
+        case SENDER_CREATE_NBOT_MENU:                   SendCreateNPCBotMenu(player, action);               break;
+        case SENDER_CREATE_NBOT:                        SendCreateNPCBot(player, action);                   break;
+        case SENDER_REMOVE_NBOT_MENU:                   SendRemoveNPCBotMenu(player, action);               break;
+        case SENDER_REMOVE_NBOT:                        SendRemoveNPCBot(player, action);                   break;
+
+        case SENDER_INFO_WHISPER:                       SendBotHelpWhisper(player, action);                 break;
+
+        default:
+            break;
+    }
+    return true;
+}
+
+bool BotHelper::OnGossipHello(Player* player)
+{
+    player->PlayerTalkClass->ClearMenus(); //in case of return;
+
+    uint8 count = 0;
+
+    uint8 maxNBcount = player->GetMaxNpcBots();
+
+    bool allowNBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true) && !player->RestrictBots();
+
+    std::string tempstr;
+
+    if (player->HaveBot())
+    {
+        count = player->GetNpcBotsCount();
+        if (count > 0)
+        {
+            tempstr = "Abandon my Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(4, 0, GetLocaleStringForTextID(tempstr, ABANDON_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 4, "", 0);
+        }
+        if (count < maxNBcount && allowNBots)
+        {
+            tempstr = "Recruit a Minion";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+        }
+    }
+    else if (allowNBots && maxNBcount != 0)
+    {
+        tempstr = "Recruit a Minion";
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(2, 0, GetLocaleStringForTextID(tempstr, RECRUIT_MINION, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 2, "", 0);
+    }
+
+    tempstr = "Help";
+    player->PlayerTalkClass->GetGossipMenu().AddMenuItem(6, 0, GetLocaleStringForTextID(tempstr, HELP_STR, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_INFO_WHISPER, GOSSIP_ACTION_INFO_DEF + 6, "", 0);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+    return true;
+}
+
+void BotHelper::SendRemoveNPCBot(Player* player, uint32 action)
+{
+    int8 x = action - GOSSIP_ACTION_INFO_DEF;
+    if (x == 1)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        return;
+    }
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        if (!player->GetBotMap(i)->_Cre())
+            continue;
+        if (x == 2)
+        {
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+            break;
+        }
+        --x;
+    }
+    player->CLOSE_GOSSIP_MENU();
+}
+
+void BotHelper::SendRemoveNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    player->PlayerTalkClass->ClearMenus();
+    if (player->GetNpcBotsCount() == 1)
+    {
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            player->RemoveBot(player->GetBotMap(i)->_Guid(), true);
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    std::string tempstr = "REMOVE ALL";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, REMOVE_ALL, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + 1);
+
+    uint8 x = 2;
+    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+    {
+        Creature* bot = player->GetBotMap(i)->_Cre();
+        if (!bot) continue;
+        player->ADD_GOSSIP_ITEM(9, bot->GetName(), SENDER_REMOVE_NBOT, GOSSIP_ACTION_INFO_DEF + x);
+        ++x;
+    }
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + x);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendCreateNPCBot(Player* player, uint32 action)
+{
+    uint8 bot_class = 0;
+    if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+    else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+        bot_class = CLASS_WARRIOR;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+        bot_class = CLASS_HUNTER;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+        bot_class = CLASS_PALADIN;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+        bot_class = CLASS_SHAMAN;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+        bot_class = CLASS_ROGUE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+        bot_class = CLASS_DRUID;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+        bot_class = CLASS_MAGE;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+        bot_class = CLASS_PRIEST;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+        bot_class = CLASS_WARLOCK;
+    else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+        bot_class = CLASS_DEATH_KNIGHT;
+
+    if (bot_class != 0)
+        player->CreateNPCBot(bot_class);
+    player->CLOSE_GOSSIP_MENU();
+    return;
+}
+
+void BotHelper::SendCreateNPCBotMenu(Player* player, uint32 /*action*/)
+{
+    std::string cost = player->GetNpcBotCostStr();
+    player->PlayerTalkClass->ClearMenus();
+
+    std::string tempstr = "Recruit a Warrior ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_WARRIOR, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 2);
+    tempstr = "Recruit a Hunter ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_HUNTER, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 3);
+    tempstr = "Recruit a Paladin ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_PALADIN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 4);
+    tempstr = "Recruit a Shaman ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_SHAMAN, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 5);
+    tempstr = "Recruit a Rogue ";
+    player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_ROGUE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 6);
+    tempstr = "Recruit a Druid ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_DRUID, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 7);
+    tempstr = "Recruit a Mage ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_MAGE, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 8);
+    tempstr = "Recruit a Priest ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_PRIEST, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 9);
+    tempstr = "Recruit a Warlock ";
+    player->ADD_GOSSIP_ITEM(3, GetLocaleStringForTextID(tempstr, RECRUIT_WARLOCK, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 10);
+    if (player->getLevel() >= 55)
+    {
+        tempstr = "Recruit a Death Knight ";
+        player->ADD_GOSSIP_ITEM(9, GetLocaleStringForTextID(tempstr, RECRUIT_DEATH_KNIGHT, player->GetSession()->GetSessionDbLocaleIndex()) + cost, SENDER_CREATE_NBOT, GOSSIP_ACTION_INFO_DEF + 11);
+    }
+
+    std::ostringstream buff;
+    uint8 bots = player->GetNpcBotsCount();
+    uint8 maxNBcount = player->GetMaxNpcBots();
+    uint32 freeNBSlots = maxNBcount - bots;
+
+    if (freeNBSlots == 0)
+    {
+        tempstr = "no more bots available";
+        buff << GetLocaleStringForTextID(tempstr, NO_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+    }
+    else
+    {
+        buff << freeNBSlots;
+        buff << ' ';
+        if (freeNBSlots == 1)
+        {
+            if (bots == 0)
+            {
+                tempstr = "bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bot available";
+                buff << GetLocaleStringForTextID(tempstr, ONE_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+        else
+        {
+            if (bots == 0)
+            {
+                tempstr = "bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+            else
+            {
+                tempstr = "more bots available";
+                buff << GetLocaleStringForTextID(tempstr, SOME_MORE_AVAILABLE, player->GetSession()->GetSessionDbLocaleIndex());
+            }
+        }
+    }
+    player->ADD_GOSSIP_ITEM(0, buff.str(), SENDER_CREATE_NBOT_MENU, GOSSIP_ACTION_INFO_DEF + 12);
+
+    tempstr = "BACK";
+    player->ADD_GOSSIP_ITEM(0, GetLocaleStringForTextID(tempstr, BACK_STRING, player->GetSession()->GetSessionDbLocaleIndex()), SENDER_MAIN_PAGE, GOSSIP_ACTION_INFO_DEF + 13);
+
+    player->PlayerTalkClass->SendGossipMenu(8446, player->GetGUID());
+}
+
+void BotHelper::SendBotHelpWhisper(Player* player, uint32 /*action*/)
+{
+    player->CLOSE_GOSSIP_MENU();
+    ChatHandler ch(player->GetSession());
+    //Basic
+    std::string tempstr = "To see list of available npcbot commands type .npcbot or .npcb";
+    std::string msg2 = GetLocaleStringForTextID(tempstr, ABOUT_BASIC_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+    ch.SendSysMessage(msg2.c_str());
+    //Heal Icons
+    uint8 mask = sConfigMgr->GetIntDefault("Bot.HealTargetIconsMask", 8);
+    std::string msg4 = "";
+    if (mask == 255)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set any raid target icon on them";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR1, player->GetSession()->GetSessionDbLocaleIndex());
+        ch.SendSysMessage(msg4.c_str());
+    }
+    else if (mask != 0)
+    {
+        tempstr = "If you want your npcbots to heal someone out of your party set proper raid target icon on them, one of these: ";
+        msg4 = GetLocaleStringForTextID(tempstr, ABOUT_ICONS_STR2, player->GetSession()->GetSessionDbLocaleIndex());
+        std::string iconrow = "";
+        uint8 count = 0;
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (mask & GroupIcons[i])
+            {
+                if (count != 0)
+                    iconrow += ", ";
+                ++count;
+                switch (i)
+                {
+                    case 0:
+                        tempstr = "star";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_STAR, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 1:
+                        tempstr = "circle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CIRCLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 2:
+                        tempstr = "diamond";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_DIAMOND, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 3:
+                        tempstr = "triangle";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_TRIANGLE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 4:
+                        tempstr = "moon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_MOON, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 5:
+                        tempstr = "square";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SQUARE, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 6:
+                        tempstr = "cross";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_CROSS, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    case 7:
+                        tempstr = "skull";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_SKULL, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                    default:
+                        tempstr = "unknown icon";
+                        iconrow += GetLocaleStringForTextID(tempstr, ICON_STRING_UNKNOWN, player->GetSession()->GetSessionDbLocaleIndex());
+                        break;
+                }
+            }
+        }
+        msg4 += iconrow;
+        ch.SendSysMessage(msg4.c_str());
+    }
+}
+
+std::string BotHelper::GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx)
+{
+    if (textId >= MAX_STRINGS)
+    {
+        TC_LOG_ERROR("misc", "botgiver:GetLocaleStringForTextID:: unknown text id: %u!", textId);
+        return textValue;
+    }
+
+    if (localeIdx == DEFAULT_LOCALE)
+        return textValue; //use default
+
+    if (localeIdx < 0)
+    {
+        TC_LOG_ERROR("misc", "botgiver:GetLocaleStringForTextID:: unknown locale: %i! Sending default locale text...", localeIdx);
+        return textValue;
+    }
+
+    uint32 idxEntry = MAKE_PAIR32(60000, textId);
+    if (GossipMenuItemsLocale const* no = sObjectMgr->GetGossipMenuItemsLocale(idxEntry))
+        ObjectMgr::GetLocaleString(no->OptionText, localeIdx, textValue);
+    return textValue;
+}
diff --git a/src/server/game/AI/NpcBots/bothelper.h b/src/server/game/AI/NpcBots/bothelper.h
new file mode 100644
index 0000000..1310b4d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bothelper.h
@@ -0,0 +1,32 @@
+#ifndef _BOTHLP_H
+#define _BOTHLP_H
+
+#include "Common.h"
+
+class Player;
+
+class BotHelper
+{
+    public:
+        BotHelper(Player* const master);
+        ~BotHelper();
+
+        Player* GetOwner() const { return _master; }
+
+        static bool OnGossipHello(Player* player);
+        static bool OnGossipSelect(Player* player, uint32 sender, uint32 action);
+
+    private:
+        static void SendRemoveNPCBot(Player* player, uint32 action);
+        static void SendRemoveNPCBotMenu(Player* player, uint32 /*action*/);
+        static void SendCreateNPCBot(Player* player, uint32 action);
+        static void SendCreateNPCBotMenu(Player* player, uint32 /*action*/);
+
+
+        static void SendBotHelpWhisper(Player* player, uint32 /*action*/);
+        static std::string GetLocaleStringForTextID(std::string& textValue, uint32 textId, int32 localeIdx = 0);
+
+        Player* const _master;
+};
+
+#endif
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index b18996f..05064cd 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -680,6 +680,19 @@ enum RBACPermissions
     RBAC_PERM_COMMAND_WP_SHOW                                = 774,
 
     // custom permissions 1000+
+
+    //NpcBot command permissions
+    RBAC_PERM_COMMAND_NPCBOT                                 = 1000,
+    RBAC_PERM_COMMAND_NPCBOT_ADD                             = 1001,
+    RBAC_PERM_COMMAND_NPCBOT_REMOVE                          = 1002,
+    RBAC_PERM_COMMAND_NPCBOT_RESET                           = 1003,
+    RBAC_PERM_COMMAND_NPCBOT_CMD                             = 1004,
+    RBAC_PERM_COMMAND_NPCBOT_DIST                            = 1005,
+    RBAC_PERM_COMMAND_NPCBOT_INFO                            = 1006,
+    RBAC_PERM_COMMAND_NPCBOT_HELPER                          = 1007,
+    RBAC_PERM_COMMAND_NPCBOT_REVIVE                          = 1008,
+    //end NpcBot
+
     RBAC_PERM_MAX
 };
 
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index be39972..84047c4 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -130,6 +130,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index d927af3..2c33538 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -54,6 +54,9 @@
 
 #include "Transport.h"
 
+// npcbot
+#include "bot_ai.h"
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -166,6 +169,15 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_path_id(0), m_formation(NULL)
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
     _focusSpell = NULL;
+
+    //bot
+    m_bot_owner = NULL;
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    m_bot_class = CLASS_NONE;
+    bot_AI = NULL;
+    m_canUpdate = true;
+    //end bot
 }
 
 Creature::~Creature()
@@ -234,6 +246,8 @@ void Creature::RemoveCorpse(bool setSpawnTime)
 {
     if (getDeathState() != CORPSE)
         return;
+    if (bot_AI)
+        return;
 
     m_corpseRemoveTime = time(NULL);
     setDeathState(DEAD);
@@ -443,6 +457,11 @@ bool Creature::UpdateEntry(uint32 Entry, uint32 team, const CreatureData* data)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (!m_canUpdate && bot_AI)
+        return;
+    //end npcbot
+
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -1258,6 +1277,11 @@ bool Creature::LoadCreatureFromDB(uint32 guid, Map* map, bool addToMap)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (GetEntry() >= BOT_ENTRY_BEGIN && GetEntry() <= BOT_ENTRY_END) //temp hack
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -2115,6 +2139,9 @@ void Creature::SetInCombatWithZone()
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    if (bot_AI)
+        return bot_AI->GetShieldBlockValue();
+
     return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -2691,3 +2718,169 @@ void Creature::ReleaseFocus(Spell const* focusSpell)
         ClearUnitState(UNIT_STATE_ROTATING);
 }
 
+uint8 Creature::GetBotClass() const
+{
+    switch (m_bot_class)
+    {
+        case DRUID_BEAR_FORM:
+        case DRUID_CAT_FORM:
+        //case TRAVEL:
+        //case FLY:
+            return CLASS_DRUID;
+        default:
+            return m_bot_class;
+    }
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    if (!bot)
+    {
+        bot_AI->UnsummonAll();
+        IsAIEnabled = false;
+        bot_AI = NULL;
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+
+    m_bots_pet->SetCharmerGUID(0);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    m_bots_pet->SetIAmABot(false);
+    m_bot_owner->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+uint8 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI && IsAIEnabled)
+        bot_AI->SetBotCommandState(st, force);
+}
+CommandStates Creature::GetBotCommandState() const
+{
+    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierEffect(spellInfo, effect_index, value);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI && bot_AI->IsMinionAI();
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI && bot_AI->IsPetAI();
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsMinionAI() ? const_cast<bot_minion_ai*>(bot_AI->GetMinionAI()) : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return IsAIEnabled && bot_AI && bot_AI->IsPetAI() ? const_cast<bot_pet_ai*>(bot_AI->GetPetAI()) : NULL;
+}
+
+void Creature::InitBotAI(bool asPet)
+{
+    ASSERT(!bot_AI);
+
+    if (asPet)
+        bot_AI = (bot_pet_ai*)AI();
+    else
+        bot_AI = (bot_minion_ai*)AI();
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI)
+        bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::RemoveBotItemBonuses(uint8 slot)
+{
+    if (bot_AI)
+        bot_AI->RemoveItemBonuses(slot);
+}
+void Creature::ApplyBotItemBonuses(uint8 slot)
+{
+    if (bot_AI)
+        bot_AI->ApplyItemBonuses(slot);
+}
+bool Creature::CanUseOffHand() const
+{
+    return bot_AI && bot_AI->CanUseOffHand();
+}
+bool Creature::CanUseRanged() const
+{
+    return bot_AI && bot_AI->CanUseRanged();
+}
+bool Creature::CanEquip(ItemTemplate const* item, uint8 slot) const
+{
+    return bot_AI && bot_AI->CanEquip(item, slot);
+}
+bool Creature::Unequip(uint8 slot) const
+{
+    return bot_AI && bot_AI->Unequip(slot);
+}
+bool Creature::Equip(uint32 itemId, uint8 slot) const
+{
+    return bot_AI && bot_AI->Equip(itemId, slot);
+}
+bool Creature::ResetEquipment(uint8 slot) const
+{
+    return bot_AI && bot_AI->ResetEquipment(slot);
+}
+
+bool Creature::IsQuestBot() const
+{
+    return
+        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
+        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+}
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index cab00be..f68aee8 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -676,6 +681,46 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         void FocusTarget(Spell const* focusSpell, WorldObject const* target);
         void ReleaseFocus(Spell const* focusSpell);
 
+        //Bot commands
+        Player* GetBotOwner() const { return m_bot_owner; }
+        void SetBotOwner(Player* newowner) { m_bot_owner = newowner; }
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
+        uint8 GetBotClass() const;
+        uint8 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void InitBotAI(bool asPet = false);
+        void SetBotCommandState(CommandStates st, bool force = false);
+        CommandStates GetBotCommandState() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float &value) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void SetCanUpdate(bool can) { m_canUpdate = can; }
+        void RemoveBotItemBonuses(uint8 slot);
+        void ApplyBotItemBonuses(uint8 slot);
+        bool CanUseOffHand() const;
+        bool CanUseRanged() const;
+        bool CanEquip(ItemTemplate const* item, uint8 slot) const;
+        bool Unequip(uint8 slot) const;
+        bool Equip(uint32 itemId, uint8 slot) const;
+        bool ResetEquipment(uint8 slot) const;
+        //advanced
+        bool IsQuestBot() const;
+        //End Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, uint32 team, const CreatureData* data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
@@ -726,6 +771,15 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         bool CanAlwaysSee(WorldObject const* obj) const;
 
     private:
+        //bot system
+        Player* m_bot_owner;
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        uint8 m_bot_class;
+        bool m_canUpdate;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 9fee6b8..604bc08 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -253,6 +253,14 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName(), GetBotOwner()->GetName());
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index 675504c..b662d3a 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -2210,6 +2210,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -2231,6 +2236,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 91e2e9f..24ec1c0 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -78,6 +78,10 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+//Bot
+#include "Config.h"
+#include "bothelper.h"
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -520,6 +524,18 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_rate = player->GetNpcBotXpReduction())
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * xp_rate;
+                ratePct = std::max<int32>(ratePct, 10); // minimum
+                //ratePct = std::min<int32>(ratePct, 100); // maximum // dead code
+                xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -859,6 +875,28 @@ Player::Player(WorldSession* session): Unit(true)
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    _botHlpr = NULL;
+    m_botTimer = 500;
+    m_botCreateTimer = 500;
+    m_bot = NULL;
+    m_enableNpcBots = sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true);
+    m_followdist = sConfigMgr->GetIntDefault("Bot.BaseFollowDistance", 30);
+    m_maxNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.MaxNpcBots", 1), MAX_NPCBOTS);
+    uint8 maxcbots = sConfigMgr->GetIntDefault("Bot.MaxNpcBotsPerClass", 1);
+    m_maxClassNpcBots = maxcbots > 0 ? maxcbots : MAX_NPCBOTS;
+    m_xpReductionNpcBots = std::min<uint8>(sConfigMgr->GetIntDefault("Bot.XpReductionPercent", 0), 100);
+    m_enableNpcBotsArenas = sConfigMgr->GetBoolDefault("Bot.EnableInArenas", true);
+    m_enableNpcBotsBGs = sConfigMgr->GetBoolDefault("Bot.EnableInBGs", true);
+    m_enableNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.EnableInDungeons", true);
+    m_enableNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.EnableInRaids", true);
+    m_limitNpcBotsDungeons = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Dungeons", false);
+    m_limitNpcBotsRaids = sConfigMgr->GetBoolDefault("Bot.InstanceLimit.Raids", false);
+    m_NpcBotsCost = sConfigMgr->GetIntDefault("Bot.Cost", 0);
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        m_botmap[i] = new NpcBotMap();
+    ///////////////////// End Bot System ////////////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -913,6 +951,16 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    if (_botHlpr)
+    {
+        delete _botHlpr;
+        _botHlpr = NULL;
+    }
+
+    //Npcbot mod: delete botmap
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        delete m_botmap[i];
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1833,6 +1881,17 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //NpcBot mod: Update
+    if (m_botTimer > 0)
+    {
+        if (p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+    else
+        RefreshBot(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -2211,6 +2270,13 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         if (!sMapMgr->CanPlayerEnter(mapid, this, false))
             return false;
 
+        //Npcbot mod: prevent crash on InstanceMap::DestroyInstance()... Unit::RemoveFromWorld()
+        //if last player being kicked out of instance while having npcbots
+        //we must remove creature Before it will be removed in Map::UnloadAll()
+        if (GetMapId() != mapid)
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+                RemoveBot(m_botmap[i]->m_guid);
+
         //I think this always returns true. Correct me if I am wrong.
         // If the map is not created, assume it is possible to enter it.
         // It will be created in the WorldPortAck.
@@ -2444,6 +2510,916 @@ void Player::RemoveFromWorld()
     }
 }
 
+void Player::RefreshBot(uint32 diff)
+{
+    if (m_botTimer > 0)
+        return;
+
+    if (IsInFlight())
+        m_botTimer = 3000;
+
+    if (!HaveBot())
+        return;
+
+    //BOT REVIVE SUPPORT part 2
+    //Revive timer condition (maybe we should check whole party?)
+    bool partyInCombat = IsInCombat();
+    if (!partyInCombat)
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (Creature* bot = m_botmap[i]->m_creature)
+            {
+                if (bot->IsInCombat())
+                {
+                    partyInCombat = true;
+                    break;
+                }
+                else if (Creature* pet = bot->GetBotsPet())
+                {
+                    if (pet->IsInCombat())
+                    {
+                        partyInCombat = true;
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = m_botmap[i]->m_guid;
+        m_bot = m_botmap[i]->m_creature;
+
+        //BOT REVIVE SUPPORT part 2
+        //Do not allow bot to be revived if master is in battle
+        if (!partyInCombat)
+        {
+            if (m_botmap[i]->m_reviveTimer > diff)
+            {
+                if (!IsInCombat())
+                    m_botmap[i]->m_reviveTimer -= diff;
+            }
+            else if (m_botmap[i]->m_reviveTimer > 0)
+                m_botmap[i]->m_reviveTimer = 0;
+        }
+
+        if (!m_bot || !m_bot->IsInWorld())
+            continue;
+
+        //!!!BOT UPDATE HELPER!!!
+        m_bot->SetCanUpdate(true);
+        m_bot->IsAIEnabled = true;
+
+        //BOT REVIVE SUPPORT part 3
+        //Revive bot if possible
+        if (m_botmap[i]->m_reviveTimer == 0)
+        {
+            if (m_bot->isDead() && IsAlive() && !IsInCombat() && !InArena() && !IsInFlight() &&
+                !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !HasInvisibilityAura() && !HasStealthAura())
+            {
+                CreateBot(0, 0, 0, true); //revive
+                continue;
+            }
+
+            //delay next attempt
+            m_botmap[i]->m_reviveTimer = 500;
+        }
+
+        //BOT MUST DIE SUPPORT
+        if (IsInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
+        {
+            RemoveBot(guid, !IsInFlight());
+            continue;
+        }
+
+        //TELEPORT SUPPORT
+        if (!IsInFlight() && IsAlive() && (m_bot->IsAlive() || m_bot->GetMapId() != GetMapId() || RestrictBots()))
+        {
+            if (m_bot->GetMapId() != GetMapId() || RestrictBots())
+            {
+                RemoveBot(guid);
+                continue;
+            }
+            else if (m_bot->GetBotCommandState() != COMMAND_STAY)
+            {
+                if (GetDistance(m_bot) > SIZE_OF_GRIDS)
+                {
+                    ////This thing is not confirmed to be stable
+                    //m_bot->SetOwnerGUID(0);
+                    //m_bot->RemoveFromWorld();
+                    //m_bot->Relocate(this);
+                    ////Creature::AddToWorld(): Skip AIM_Initialize();
+                    //if (m_bot->GetZoneScript())
+                    //    m_bot->GetZoneScript()->OnCreatureCreate(m_bot);
+                    //sObjectAccessor->AddObject(m_bot);
+                    //m_bot->ToUnit()->AddToWorld();
+                    //m_bot->SetOwnerGUID(GetGUID());
+
+                    //This thing is unsafe
+                    m_bot->SetBotsPetDied();
+                    m_bot->OnBotDespawn(NULL);
+                    m_bot->InterruptNonMeleeSpells(true);
+                    m_bot->AttackStop();
+                    m_bot->RemoveAllAttackers();
+                    m_bot->DeleteThreatList();
+                    m_bot->ClearInCombat();
+
+                    m_bot->RemoveNotOwnSingleTargetAuras();
+                    //m_bot->RemoveAllGameObjects();
+                    //m_bot->RemoveAllDynObjects();
+                    //m_bot->ExitVehicle();
+                    //m_bot->UnsummonAllTotems();
+                    //m_bot->RemoveAllControlled();
+                    m_bot->RemoveAreaAurasDueToLeaveWorld();
+                    m_bot->DestroyForNearbyPlayers();
+                    m_bot->ClearUpdateMask(true);
+                    //sObjectAccessor->RemoveObject(m_bot);
+                    m_bot->Relocate(this);
+                    //sObjectAccessor->AddObject(m_bot);
+                    m_bot->ToUnit()->AddToWorld();
+                }
+            }
+        }
+
+        //Update bots manually and prevent from normal updates
+        //This will update bot's AI
+        m_bot->Update(diff);
+        m_bot->SetCanUpdate(false);
+
+        //Update bot's pet manually and prevent from normal updates
+        //This will update pet's AI
+        if (Creature* pet = m_bot->GetBotsPet())
+        {
+            pet->SetCanUpdate(true);
+            pet->IsAIEnabled = true;
+            pet->Update(diff);
+            pet->SetCanUpdate(false);
+        }
+
+        m_bot = NULL;
+    }//end for botmap
+
+    //BOT CREATION/RECREATION SUPPORT
+    if (m_botCreateTimer > diff)
+        m_botCreateTimer -= diff;
+    else
+    {
+        m_botCreateTimer = 250;
+
+        if (!IsInFlight() && IsAlive() && !IsInCombat() && GetBotMustBeCreated() && !RestrictBots())
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry != 0 && m_botmap[pos]->m_guid == 0)
+                    CreateBot(m_botmap[pos]->m_entry, m_botmap[pos]->m_race, m_botmap[pos]->m_class);
+    }
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips)
+{
+    if (m_enableNpcBots == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
+        ClearBotMustBeCreated(0, 0, true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == 0)
+        {
+            m_botmap[pos]->m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos]->m_entry = m_entry;
+            m_botmap[pos]->m_race = m_race;
+            m_botmap[pos]->m_class = m_class;
+
+            for (uint8 i = 0; i != 18; ++i)
+                m_botmap[pos]->equips[i] = equips[i];
+
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry != 0 &&
+            (m_botmap[pos]->m_guid == 0 || !sObjectAccessor->FindUnit(m_botmap[pos]->m_guid)))
+        {
+            m_botmap[pos]->m_guid = 0;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(uint64 guidOrSlot, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos]->m_guid == guidOrSlot) ||
+            (guid == false && pos == guidOrSlot) ||
+            fully)
+        {
+            m_botmap[pos]->m_guid = 0;
+            m_botmap[pos]->m_entry = 0;
+            m_botmap[pos]->m_race = 0;
+            m_botmap[pos]->m_class = 0;
+            m_botmap[pos]->m_creature = NULL;
+
+            for (uint8 i = 0; i != 18; ++i)
+                m_botmap[pos]->equips[i] = 0;
+
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
+{
+    if (guid == 0) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i]->m_guid == guid)
+        {
+            m_bot = m_botmap[i]->m_creature;
+            break;
+        }
+    }
+    if (!m_bot)
+        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+    if (m_bot)
+    {
+        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
+        Group* gr = GetGroup();
+        if (gr && gr->IsMember(guid))
+        {
+            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
+                gr->RemoveMember(guid);
+            else //just cleanup
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+                stmt->setUInt32(0, GUID_LOPART(guid));
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        m_bot->SetBotsPetDied();
+        m_bot->OnBotDespawn(NULL);
+        m_bot->SetCharmerGUID(0);
+        //m_bot->SetBotOwner(NULL);
+        m_bot->SetIAmABot(false);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+
+        if (final)//on logout or by command
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)//by command
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ACTIVE);
+                stmt->setUInt8(0, uint8(0));
+                stmt->setUInt32(1, GetGUIDLow());
+                stmt->setUInt32(2, m_bot->GetEntry());
+                CharacterDatabase.Execute(stmt);
+                //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_bot->GetEntry());
+            }
+        }
+        else
+        {
+            ModifyMoney(int64(GetNpcBotCost())); //temp restore money before retake
+
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos]->m_guid == guid)
+                {
+                    m_botmap[pos]->m_guid = 0;//reset guid so it can be set during recreation
+                    m_botmap[pos]->m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+}
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive)
+{
+    if (IsBeingTeleported() || IsInFlight()) return; //don't create bot yet
+    if (isDead() && !revive) return; //not to revive by command so abort
+    if (IsInCombat()) return;
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(m_bot->GetCreateHealth() / 6);//~15% of base health
+        if (m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
+        SetUInt32Value(UNIT_NPC_FLAGS, m_bot->GetCreatureTemplate()->npcflag);
+        ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        return;
+    }
+    if (m_enableNpcBots == false && revive == false)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        TC_LOG_ERROR("entities.player", "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName().c_str(), GetGUIDLow(), botentry, botrace, botclass);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        return;
+    }
+    //npcbot counter is already increased in SetBotMustBeCreated()
+    if (GetNpcBotsCount() > GetMaxNpcBots())
+    {
+        ChatHandler ch(GetSession());
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos]->m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    //instance limit check
+    if ((m_limitNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) || (m_limitNpcBotsRaids && GetMap()->IsRaid()))
+    {
+        InstanceMap* map = (InstanceMap*)GetMap();
+        uint32 count = 0;
+        Map::PlayerList const& plMap = map->GetPlayers();
+        for (Map::PlayerList::const_iterator itr = plMap.begin(); itr != plMap.end(); ++itr)
+            if (Player* player = itr->GetSource())
+                count += (1 + player->GetNpcBotsCount());
+
+        //check "more" cuz current bot is queued and we are to choose to remove it or not
+        if (count > map->GetMaxPlayers())
+        {
+            ChatHandler ch(GetSession());
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+                if (m_botmap[pos]->m_entry == botentry)
+                    ClearBotMustBeCreated(pos, false);
+            ch.PSendSysMessage("Instance players limit exceed");
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
+    {
+        ChatHandler ch(GetSession());
+        ch.PSendSysMessage("Your group is Full!");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry == botentry)
+            if (m_botmap[pos]->m_reviveTimer != 0)
+                return;
+
+    m_bot = SummonCreature(botentry, *this);
+
+    //check if we have free slot
+    bool _set = false;
+    uint8 slot = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_entry == botentry && m_botmap[pos]->m_guid == 0)
+        {
+            m_botmap[pos]->m_guid = m_bot->GetGUID();
+            m_botmap[pos]->m_creature = m_bot;//this will save some time but we need guid as well
+            slot = pos;
+            _set = true;
+            break;
+        }
+    }
+    if (!_set)
+    {
+        TC_LOG_ERROR("entities.player", "character %s (%u) is failed to create npcbot! Removing all bots", GetName().c_str(), GetGUIDLow());
+
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->AddObjectToRemoveList();
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            RemoveBot(m_botmap[pos]->m_guid, true);
+        ClearBotMustBeCreated(0, false, true);
+        return;
+    }
+
+    m_bot->SetBotOwner(this);
+
+    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
+
+    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    m_bot->SetBotClass(botclass);
+    m_bot->AIM_Initialize();
+    m_bot->InitBotAI();
+    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    InitBotEquips(m_bot);
+
+    //entry is unique for each master's bot so clean it up just in case
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+    uint8 i = 0;
+    stmt->setUInt32(i++, GetGUIDLow());
+    stmt->setUInt32(i++, botentry);
+    stmt->setUInt8(i++, botrace);
+    stmt->setUInt8(i++, botclass);
+    stmt->setUInt8(i++, m_bot->GetBotRoles());
+
+    for (uint8 j = 0; j != 18; ++j)
+        stmt->setUInt32(i++, m_botmap[slot]->equips[j]);
+
+    stmt->setUInt8(i++, uint8(1)); //active
+    CharacterDatabase.Execute(stmt);
+
+    //If we have a group, just add bot
+    if (Group* gr = GetGroup())
+    {
+        if (!gr->IsFull())
+        {
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else if (!gr->isRaidGroup()) //non-raid group is full
+        {
+            gr->ConvertToRaid();
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else //raid group is full
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(this))
+        {
+            delete gr;
+            return;
+        }
+        sGroupMgr->AddGroup(gr);
+        if (!gr->AddMember((Player*)m_bot))
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+
+    if (uint32 cost = GetNpcBotCost())
+        ModifyMoney(-(int32(cost)));
+
+    if (Group* gr = GetGroup())
+    {
+        Group::MemberSlotList const a = gr->GetMemberSlots();
+        //try to remove 'absent' bots
+        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
+        {
+            if (itr->guid == 0)
+                continue;
+            if (IS_PLAYER_GUID(itr->guid))
+                continue;
+            if (!sObjectAccessor->FindUnit(itr->guid))
+                gr->RemoveMember(itr->guid);
+        }
+    }
+} //end Player::CreateBot
+
+uint8 Player::GetNpcBotsCount() const
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_entry != 0)
+            ++bots;
+    return bots;
+}
+
+uint8 Player::GetMaxNpcBots() const
+{
+    return (GetSession()->GetSecurity() == SEC_PLAYER) ? m_maxNpcBots : MAX_NPCBOTS;
+}
+
+bool Player::HaveBot() const
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_entry != 0)
+            return true;
+    return false;
+}
+
+void Player::SendBotCommandState(Creature* cre, CommandStates state)
+{
+    if (!cre) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i]->m_creature == cre)
+            cre->SetBotCommandState(state, true);
+}
+//finds bot's slot into master's botmap
+int8 Player::GetNpcBotSlot(uint64 guid) const
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+            return pos;
+
+    return -1;
+}
+
+void Player::SetNpcBotDied(uint64 guid)
+{
+    if (!guid) return;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_guid == guid)
+        {
+            m_botmap[pos]->m_reviveTimer = 15000;
+            break;
+        }
+}
+
+bool Player::RestrictBots() const
+{
+    return
+        (!m_enableNpcBotsBGs && GetMap()->IsBattleground()) ||
+        (!m_enableNpcBotsArenas && GetMap()->IsBattleArena()) ||
+        (!m_enableNpcBotsDungeons && GetMap()->IsNonRaidDungeon()) ||
+        (!m_enableNpcBotsRaids && GetMap()->IsRaid());
+}
+
+uint32 Player::GetNpcBotCost() const
+{
+    return m_NpcBotsCost ? uint32((m_NpcBotsCost / 80.f) * getLevel()) : 0;
+}
+
+std::string Player::GetNpcBotCostStr() const
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost())
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+    return money.str();
+}
+
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    //check if we have too many bots of that class
+    if (HaveBot())
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i]->m_class == bot_class)
+                ++count;
+        if (count >= m_maxClassNpcBots)
+        {
+            //SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, m_maxClassNpcBots);
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+
+    //check if player cannot afford a bot
+    if (GetMoney() < GetNpcBotCost())
+    {
+        ChatHandler ch(GetSession());
+        std::string str = "You don't have enough money (";
+        str += GetNpcBotCostStr();
+        str += ")!";
+        ch.SendSysMessage(str.c_str());
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_TEMPLATE);
+    std::ostringstream classStr;
+
+    switch (bot_class)
+    {
+        case CLASS_ROGUE:
+            classStr << "rogue_bot";        break;
+        case CLASS_PRIEST:
+            classStr << "priest_bot";       break;
+        case CLASS_DRUID:
+            classStr << "druid_bot";        break;
+        case CLASS_SHAMAN:
+            classStr << "shaman_bot";       break;
+        case CLASS_MAGE:
+            classStr << "mage_bot";         break;
+        case CLASS_WARLOCK:
+            classStr << "warlock_bot";      break;
+        case CLASS_WARRIOR:
+            classStr << "warrior_bot";      break;
+        case CLASS_PALADIN:
+            classStr << "paladin_bot";      break;
+        case CLASS_HUNTER:
+            classStr << "hunter_bot";       break;
+        case CLASS_DEATH_KNIGHT:
+            classStr << "death_knight_bot"; break;
+        default:
+            ChatHandler ch(GetSession());
+            ch.PSendSysMessage("ERROR! unknown bot_class %u", bot_class);
+            ch.SetSentErrorMessage(true);
+            TC_LOG_ERROR("entities.player", "Player::CreateNPCBot() player %u(%s) tried to create bot of unknown/unsupported class %u!", GetGUIDLow(), GetName().c_str(), bot_class);
+            return;
+    }
+
+    uint8 index = 0;
+    stmt->setString(index++, classStr.str());
+    stmt->setUInt8(index++, bot_class);
+
+    //maybe we should remove this check? ;
+    switch (getRace())
+    {
+        case RACE_NONE:
+        case RACE_HUMAN:
+        case RACE_DWARF:
+        case RACE_NIGHTELF:
+        case RACE_GNOME:
+        case RACE_DRAENEI:
+            stmt->setUInt8(index++, uint8(1));
+            stmt->setUInt8(index++, uint8(3));
+            stmt->setUInt8(index++, uint8(4));
+            stmt->setUInt8(index++, uint8(7));
+            stmt->setUInt8(index++, uint8(11));
+            break;
+
+        case RACE_ORC:
+        case RACE_UNDEAD_PLAYER:
+        case RACE_TAUREN:
+        case RACE_TROLL:
+        case RACE_BLOODELF:
+            stmt->setUInt8(index++, uint8(2));
+            stmt->setUInt8(index++, uint8(5));
+            stmt->setUInt8(index++, uint8(6));
+            stmt->setUInt8(index++, uint8(8));
+            stmt->setUInt8(index++, uint8(10));
+            break;
+    }
+
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_FATAL("entities.player", "Player::CreateNPCBot() CANNOT create bot of class %u, not found in DB!", bot_class);
+        return;
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    //find a bot to add
+    //first check randomly selected bot, second check any bot we can add
+    typedef std::list< std::pair<uint32, uint8> > NpcBotsDataTemplate;
+    NpcBotsDataTemplate npcBotsData;
+    do
+    {
+        Field* fields = result->Fetch();
+        uint32 temp_entry = fields[0].GetUInt32();
+        uint8 temp_race = fields[1].GetUInt8();
+        npcBotsData.push_back(std::pair<uint32, uint8>(temp_entry, temp_race));
+    }
+    while (result->NextRow());
+
+    uint32 m_rand = urand(1, uint32(result->GetRowCount()));
+    uint32 tmp_rand = 1;
+    std::list< std::pair<uint32, uint8> >::const_iterator itr = npcBotsData.begin();
+    bool haveSameBot = false;
+    bool moveback = false;
+    bool forcedCheck = false;
+    bool secondCheck = false;
+    while (true)
+    {
+        if (itr == npcBotsData.end()) //end of list is reached (selected bot is checked)
+        {
+            moveback = true;
+            --itr; //tmp_rand is not needed anymore
+            continue;
+        }
+        if (moveback && itr == npcBotsData.begin()) //search is finished, nothing found
+            break;
+        if (tmp_rand == m_rand || haveSameBot)
+        {
+            bool canAdd = true;
+            for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            {
+                if (m_botmap[i]->m_entry == itr->first)
+                {
+                    haveSameBot = true;
+                    canAdd = false;
+                    if (!secondCheck)
+                        forcedCheck = true;
+                    secondCheck = true;
+                    break;
+                }
+            }
+            if (canAdd)
+            {
+                entry = itr->first;
+                bot_race = itr->second;
+                break;
+            }
+            if (forcedCheck)
+            {
+                itr = npcBotsData.begin(); //reset searcher pos
+                forcedCheck = false;
+                continue;
+            }
+        }
+        //move through
+        if (moveback)
+            --itr;
+        else
+        {
+            ++itr;
+            ++tmp_rand;
+        }
+    }
+
+    if (!entry || !bot_race)
+    {
+        ChatHandler ch(GetSession());
+        ch.SendSysMessage("No more bots of this class available");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    uint32 equips[18];
+    for (uint8 i = 0; i != 18; ++i)
+        equips[i] = 0;
+
+    //"SELECT equipMhEx, equipOhEx, equipRhEx FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+    stmt->setUInt32(0, GetGUIDLow());
+    stmt->setUInt32(1, entry);
+    result = CharacterDatabase.Query(stmt);
+    if (result)
+    {
+        Field* field = result->Fetch();
+        for (uint8 i = 0; i != 18; ++i)
+            equips[i] = field[i].GetUInt32();
+    }
+
+    SetBotMustBeCreated(entry, bot_race, bot_class, equips);
+}
+
+void Player::InitBotEquips(Creature* bot)
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(bot->GetEntry(), id);
+
+    uint8 slot = 0;
+    //Load stored equipment if any
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_creature == bot)
+        {
+            slot = pos;
+
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0, m_botmap[pos]->equips[0]);
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, m_botmap[pos]->equips[1]);
+            bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, m_botmap[pos]->equips[2]);
+
+            if (uint32 mh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0))
+            {
+                if (!einfo || einfo->ItemEntry[0] != mh)
+                {
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(mh))
+                    {
+                        bot->SetAttackTime(BASE_ATTACK, proto->Delay);
+                        bot->ApplyBotItemBonuses(0);
+                    }
+                }
+            }
+            if (uint32 oh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1))
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(oh))
+                {
+                    if (!einfo || einfo->ItemEntry[1] != oh)
+                        bot->ApplyBotItemBonuses(1);
+
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        bot->SetAttackTime(OFF_ATTACK, proto->Delay);
+                        bot->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+            if (uint32 rh = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2))
+            {
+                if (!einfo || einfo->ItemEntry[2] != rh)
+                {
+                    if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(rh))
+                    {
+                        bot->SetAttackTime(RANGED_ATTACK, proto->Delay);
+                        bot->ApplyBotItemBonuses(2);
+                    }
+                }
+            }
+
+            for (uint8 i = 3; i != 18; ++i)
+                bot->ApplyBotItemBonuses(i);
+
+            break;
+        }
+    }
+
+    //Load remaining items as defaults
+    if (einfo)
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            if (bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == 0 && einfo->ItemEntry[i] != 0)
+            {
+                bot->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+                if (i == 1) //off-hand
+                {
+                    if (einfo->ItemEntry[i] != 0 && bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i) == einfo->ItemEntry[i])
+                    {
+                        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                        {
+                            if (proto->Class == ITEM_CLASS_WEAPON)
+                            {
+                                bot->SetAttackTime(OFF_ATTACK, bot->GetBotClass() == CLASS_ROGUE ? 1400 : 1800);
+                                bot->SetCanDualWield(true);
+                            }
+                            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                            {
+                                if (bot->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                                    const_cast<CreatureTemplate*>(bot->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        //while creating new bot he has no equips but equip template so write these to bot map
+        m_botmap[slot]->equips[0] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0);
+        m_botmap[slot]->equips[1] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1);
+        m_botmap[slot]->equips[2] = bot->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2);
+    }
+}
+
+uint32 Player::GetBotEquip(Creature* bot, uint8 slot) const
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos]->m_creature == bot)
+            return m_botmap[pos]->equips[slot];
+
+    return 0;
+}
+
+void Player::UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos]->m_creature == bot)
+        {
+            m_botmap[pos]->equips[slot] = itemId;
+
+            //Commit to DB
+            PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+            uint8 i;
+            for (i = 0; i != 18; ++i)
+                stmt->setUInt32(i, m_botmap[pos]->equips[i]);
+
+            stmt->setUInt32(18, GetGUIDLow());
+            stmt->setUInt32(19, m_botmap[pos]->m_entry);
+            CharacterDatabase.Execute(stmt);
+
+            break;
+        }
+    }
+}
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2721,6 +3697,9 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
 
     // not enemy
     if (creature->IsHostileTo(this))
+    //npcbot
+    if (!creature->IsQuestBot())
+    //end npcbot
         return NULL;
 
     // not unfriendly
@@ -2925,6 +3904,26 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+                {
+                    if (Player* pl = ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
+
+                //remove npcbots so group will be disbanded if only 1 player
+                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                    player->RemoveBot(player->GetBotMap(i)->m_guid, players <= 1);
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+            }
+        }
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -4977,6 +5976,13 @@ void Player::DeleteFromDB(uint64 playerguid, uint32 accountId, bool updateRealmC
             stmt->setUInt32(0, guid);
             trans->Append(stmt);
 
+            //npcbot - erase npcbots
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOTS);
+            stmt->setUInt32(0, guid);
+            trans->Append(stmt);
+            //CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u'", guid);
+            //end npcbot
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 6aa19b5..2ab8c82 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -52,6 +52,11 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// NpcBot mod
+struct NpcBotMap;
+#define MAX_NPCBOTS 39
+class BotHelper;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2296,6 +2301,39 @@ class Player : public Unit, public GridObject<Player>
         std::string GetMapAreaAndZoneString();
         std::string GetCoordsMapAreaAndZoneString();
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotHelper(BotHelper* hlpr) { ASSERT (!_botHlpr); _botHlpr = hlpr; }
+        BotHelper* GetBotHelper() const { return _botHlpr; }
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        int8 GetNpcBotSlot(uint64 guid) const;
+        void SendBotCommandState(Creature* cre, CommandStates state);
+        bool HaveBot() const;
+        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature* cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount() const;
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, uint32 *equips);
+        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        uint8 GetBotFollowDist() const { return m_followdist; }
+        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
+        void SetNpcBotDied(uint64 guid);
+        NpcBotMap const* GetBotMap(uint8 pos) const { return m_botmap[pos]; }
+        uint8 GetMaxNpcBots() const;
+        uint8 GetNpcBotXpReduction() const { return m_xpReductionNpcBots; }
+        bool RestrictBots() const;
+        uint32 GetNpcBotCost() const;
+        std::string GetNpcBotCostStr() const;
+        void InitBotEquips(Creature* bot);
+        void UpdateBotEquips(Creature* bot, uint8 slot, uint32 itemId);
+        uint32 GetBotEquip(Creature* bot, uint8 slot) const;
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2557,6 +2595,30 @@ class Player : public Unit, public GridObject<Player>
         uint8 m_grantableLevels;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotHelper* _botHlpr;
+        Creature* m_bot;
+        int8 m_followdist;
+        uint8 m_maxNpcBots;
+        uint8 m_maxClassNpcBots;
+        uint8 m_xpReductionNpcBots;
+        bool m_enableNpcBots;
+        bool m_enableNpcBotsArenas;
+        bool m_enableNpcBotsBGs;
+        bool m_enableNpcBotsDungeons;
+        bool m_enableNpcBotsRaids;
+        bool m_limitNpcBotsDungeons;
+        bool m_limitNpcBotsRaids;
+        uint32 m_NpcBotsCost;
+        uint32 m_botTimer;
+        uint32 m_botCreateTimer;
+        NpcBotMap* m_botmap[MAX_NPCBOTS];
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index ddea24c..33bac8e 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -143,6 +143,13 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (IS_CREATURE_GUID(GetCreatorGUID()))
+        if (Unit* bot = sObjectAccessor->FindUnit(GetCreatorGUID()))
+            if (bot->ToCreature()->GetIAmABot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index d2b7fc6..22a59ef 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -181,6 +181,10 @@ bool Player::UpdateAllStats()
     for (int i = SPELL_SCHOOL_NORMAL; i < MAX_SPELL_SCHOOL; ++i)
         UpdateResistances(i);
 
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (Creature* bot = GetBotMap(i)->_Cre())
+            bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 343adec..3283056 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -342,6 +342,17 @@ void Unit::Update(uint32 p_time)
                 m_CombatTimer -= p_time;
         }
     }
+    // update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && !GetVictim() && (ToCreature()->GetIAmABot() || ToCreature()->GetIAmABotsPet()))
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
 
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
@@ -579,6 +590,12 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->GetIAmABot() && cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -993,6 +1010,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
         {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+
             // Physical Damage
             if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
             {
@@ -1050,6 +1072,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
+            //Npcbot mod: apply bot damage mods
+            if (Creature* bot = ToCreature())
+                if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                    bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+
             // If crit add critical bonus
             if (crit)
             {
@@ -1166,6 +1193,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     // Script Hook For CalculateMeleeDamage -- Allow scripts to change the Damage pre class mitigation calculations
     sScriptMgr->ModifyMeleeDamage(damageInfo->target, damageInfo->attacker, damage);
 
+    //Npcbot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -10430,6 +10462,7 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CREATURE_GUID(GetGUID()) && !(IsTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        if (!ToCreature()->GetIAmABot())
         return false;
 
     // not critting spell
@@ -13131,6 +13164,11 @@ bool Unit::HandleStatModifier(UnitMods unitMod, UnitModifierType modifierType, f
             break;
     }
 
+    if (Player* master = ToPlayer())
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            if (Creature* bot = master->GetBotMap(i)->_Cre())
+                bot->SetBotShouldUpdateStats();
+
     return true;
 }
 
@@ -16563,6 +16601,182 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
                 break;
         }
     }
+    else if (ToCreature() && ToCreature()->GetIAmABot())
+    {
+        Player const *player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 3d56225..691a1c9 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7736,6 +7736,82 @@ SkillRangeType GetSkillRangeType(SkillLineEntry const* pSkill, bool racial)
     }
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index bf835ed..1d130f8 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -144,6 +144,21 @@ struct GameTele
 
 typedef UNORDERED_MAP<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef UNORDERED_MAP<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -966,6 +981,7 @@ class ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1166,6 +1182,8 @@ class ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1310,6 +1328,8 @@ class ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void CheckScripts(ScriptsType type, std::set<int32>& ids);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 272fd89..b4c8c1a 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -106,6 +106,9 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -361,6 +364,8 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -376,6 +381,7 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    }
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -401,6 +407,8 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    if (IS_PLAYER_GUID(player->GetGUID()))
+    {
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -476,6 +484,7 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    }
 
     return true;
 }
@@ -599,6 +608,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod& method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 0f55aba..b859d56 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -307,6 +307,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 25164b8..7900249 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -48,6 +48,9 @@
 #include "WorldSession.h"
 
 
+//bot
+#include "Config.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -1027,6 +1030,34 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 
     m_playerLoading = false;
 
+    //the only place where we check if it has NPC bots
+    if (sConfigMgr->GetBoolDefault("Bot.EnableNpcBots", true))
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
+        stmt->setUInt32(0, pCurrChar->GetGUIDLow());
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+        if (result)
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            uint32 equips[18];
+            do
+            {
+                Field* fields = result->Fetch();
+                m_bot_entry = fields[0].GetUInt32();
+                m_bot_race = fields[1].GetUInt8();
+                m_bot_class = fields[2].GetInt8();
+                for (uint8 i = 0; i != 18; ++i)
+                    equips[i] = fields[i + 4].GetUInt32();
+
+                if (m_bot_entry && m_bot_race && m_bot_class)
+                    pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, equips);
+
+            } while (result->NextRow());
+        }
+    }
+
     sScriptMgr->OnPlayerLogin(pCurrChar);
     delete holder;
 }
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index 4da0d82..777a21c 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -56,6 +56,9 @@
 #include "Battlefield.h"
 #include "BattlefieldMgr.h"
 
+//Bot
+#include "bothelper.h"
+
 void WorldSession::HandleRepopRequestOpcode(WorldPacket& recvData)
 {
     TC_LOG_DEBUG("network", "WORLD: Recvd CMSG_REPOP_REQUEST Message");
@@ -111,6 +114,16 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             return;
         }
     }
+    //Bot
+    else if (IS_PLAYER_GUID(guid))
+    {
+        if (guid != _player->GetGUID())
+        {
+            TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) not found.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+    }
+    //end Bot
     else if (IS_GAMEOBJECT_GUID(guid))
     {
         go = _player->GetMap()->GetGameObject(guid);
@@ -148,6 +161,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelectCode(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str()))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            //_player->GetBotHelper()->OnCodedGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId), code.c_str());
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelectCode(_player, menuId, gossipListId, code.c_str());
@@ -162,6 +186,17 @@ void WorldSession::HandleGossipSelectOptionOpcode(WorldPacket& recvData)
             if (!sScriptMgr->OnGossipSelect(_player, unit, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId)))
                 _player->OnGossipSelect(unit, gossipListId, menuId);
         }
+        //Bot
+        else if (guid == _player->GetGUID())
+        {
+            if (!_player->GetBotHelper())
+            {
+                TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip select.", uint32(GUID_LOPART(guid)));
+                return;
+            }
+            _player->GetBotHelper()->OnGossipSelect(_player, _player->PlayerTalkClass->GetGossipOptionSender(gossipListId), _player->PlayerTalkClass->GetGossipOptionAction(gossipListId));
+        }
+        //end Bot
         else
         {
             go->AI()->GossipSelect(_player, menuId, gossipListId);
diff --git a/src/server/game/Handlers/NPCHandler.cpp b/src/server/game/Handlers/NPCHandler.cpp
index 39489e7..2808ee2 100644
--- a/src/server/game/Handlers/NPCHandler.cpp
+++ b/src/server/game/Handlers/NPCHandler.cpp
@@ -38,6 +38,9 @@
 #include "CreatureAI.h"
 #include "SpellInfo.h"
 
+//Bot
+#include "bothelper.h"
+
 enum StableResultCode
 {
     STABLE_ERR_MONEY        = 0x01,                         // "you don't have enough money"
@@ -295,6 +298,36 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket& recvData)
     uint64 guid;
     recvData >> guid;
 
+    //Bot
+    if (guid == _player->GetGUID())
+    {
+        if (!_player->GetBotHelper())
+        {
+            TC_LOG_ERROR("network", "WORLD: HandleGossipSelectOptionOpcode - Player (GUID: %u) do not have a helper on gossip hello.", uint32(GUID_LOPART(guid)));
+            return;
+        }
+        _player->GetBotHelper()->OnGossipHello(_player);
+        return;
+    }
+    else if (IS_CREATURE_GUID(guid))
+    {
+        if (Creature* qBot = ObjectAccessor::GetCreatureOrPetOrVehicle(*_player, guid))
+        {
+            if (qBot->IsQuestBot() &&
+                (_player->IsAlive() || qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_GHOST) &&
+                (qBot->IsAlive() || (qBot->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_DEAD_INTERACT)))
+            {
+                if (!sScriptMgr->OnGossipHello(_player, qBot))
+                {
+                    TC_LOG_ERROR("network", "WORLD: HandleGossipHelloOpcode - qBot %s (Entry: %u) returned false on gossip hello.",
+                        qBot->GetName().c_str(), qBot->GetEntry());
+                }
+                return;
+            }
+        }
+    }
+    //end Bot
+
     Creature* unit = GetPlayer()->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
     if (!unit)
     {
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index b264b0d..4fa119d 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -566,6 +566,36 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->ToCreature())
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+    //end bot
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
 
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 6f99ee0..b30ef0f 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2487,7 +2487,10 @@ uint32 Map::GetPlayersCountExceptGMs() const
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
         if (!itr->GetSource()->IsGameMaster())
+        {
             ++count;
+            count += itr->GetSource()->GetNpcBotsCount();
+        }
     return count;
 }
 
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 3b340f8..43c86e7 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1434,6 +1434,21 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+//Bots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_script_bot_commands();
+//advanced
+void AddSC_BotQuests_chapter1();
+//end Bots
 
 #endif
 
@@ -1441,6 +1456,21 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+    //Bots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_script_bot_commands();
+    //advanced
+    AddSC_BotQuests_chapter1();
+    //end Bots
 
 #endif
 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 82cc1c9..9b8e5e0 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -429,6 +429,20 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool save)
 {
+    uint8 nBotCount = 0;
+    if (_player)
+    {
+        //remove npcbots but do not delete from DB so they can be reacqured on next login
+        for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+        {
+            if (_player->GetBotMap(i)->_Guid())
+            {
+                _player->RemoveBot(_player->GetBotMap(i)->_Guid(), true, false);
+                ++nBotCount;
+            }
+        }
+    }
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -522,6 +536,9 @@ void WorldSession::LogoutPlayer(bool save)
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+            //bot d) if has no NpcBots or not in instance (trying to save instance)
+            if (nBotCount == 0 || !_player->GetMap()->Instanceable())
+            //end bot
             _player->RemoveFromGroup();
 
         //! Send update to group and reset stored max enchanting level
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 2d7ec9c..097e42a 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -192,6 +192,31 @@ class CharacterCreateInfo
         uint8 CharCount;
 };
 
+//npcbot
+struct NpcBotMap
+{
+    friend class Player;
+    protected:
+        NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0)
+        {
+            for (uint8 i = 0; i != 18; ++i)
+                equips[i] = 0;
+        }
+        uint64 m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature* m_creature;
+        uint32 m_reviveTimer;
+        uint32 equips[18];
+
+    public:
+        uint64 _Guid() const { return m_guid; }
+        Creature* _Cre() const { return m_creature; }
+        uint32 const getEquips(uint8 slot) const { return equips[slot]; }
+};
+//end bot mods
+
 /// Player session in the World
 class WorldSession
 {
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index d8dc19c..3aea810 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -1431,6 +1431,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 0d3da30..41db076 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -413,6 +413,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -455,6 +456,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -596,6 +599,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() OVERRIDE
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index da99d6c..6525546 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -600,4 +600,18 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_CHAR_PET_SLOT_BY_ID, "UPDATE character_pet SET slot = ? WHERE owner = ? AND id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_ID, "DELETE FROM character_pet WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_CHAR_PET_BY_SLOT, "DELETE FROM character_pet WHERE owner = ? AND (slot = ? OR slot > ?)", CONNECTION_ASYNC);
+
+    // Bot
+    PrepareStatement(CHAR_SEL_NPCBOTS, "SELECT entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND active = 1", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_DEL_NPCBOTS, "DELETE FROM character_npcbot WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "REPLACE INTO character_npcbot (owner, entry, race, class, roles, equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck, active) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_ACTIVE, "UPDATE character_npcbot SET active = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP, "SELECT equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_ROLES, "SELECT roles FROM character_npcbot WHERE owner = ? AND entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE character_npcbot SET roles = ? WHERE owner = ? AND entry = ?", CONNECTION_ASYNC);
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index aa47fb5..9c5c0c2 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -532,6 +532,16 @@ enum CharacterDatabaseStatements
     CHAR_DEL_ITEMCONTAINER_MONEY,
     CHAR_INS_ITEMCONTAINER_MONEY,
 
+    // Bot
+    CHAR_SEL_NPCBOTS,
+    CHAR_DEL_NPCBOTS,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_UPD_NPCBOT_ACTIVE,
+    CHAR_SEL_NPCBOT_EQUIP,
+    CHAR_SEL_NPCBOT_ROLES,
+    CHAR_UPD_NPCBOT_ROLES,
+
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.cpp b/src/server/shared/Database/Implementation/WorldDatabase.cpp
index f27ee2b..d1de3dd 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/shared/Database/Implementation/WorldDatabase.cpp
@@ -91,4 +91,8 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     // 0: uint8
     PrepareStatement(WORLD_SEL_REQ_XP, "SELECT xp_for_next_level FROM player_xp_for_level WHERE lvl = ?", CONNECTION_SYNCH);
+
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_TEMPLATE, "SELECT entry, trainer_race FROM creature_template WHERE scriptname = ? and trainer_class = ? and trainer_race IN (?, ?, ?, ?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
 }
diff --git a/src/server/shared/Database/Implementation/WorldDatabase.h b/src/server/shared/Database/Implementation/WorldDatabase.h
index 0126cdc..92cb76d 100644
--- a/src/server/shared/Database/Implementation/WorldDatabase.h
+++ b/src/server/shared/Database/Implementation/WorldDatabase.h
@@ -112,6 +112,10 @@ enum WorldDatabaseStatements
     WORLD_DEL_DISABLES,
     WORLD_SEL_REQ_XP,
 
+    // Bot
+    WORLD_SEL_NPCBOT_TEMPLATE,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 4e594fc..3e79acb 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2816,3 +2816,107 @@ PacketSpoof.BanDuration = 86400
 
 #
 ###################################################################################################
+
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#     Bot.EnableNpcBots
+#        Enable NpcBot system
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnableNpcBots = 1
+
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character (disabled for GM accounts)
+#        Default: 1
+#        Recomended: 4
+#        Max: 9
+#        Absolute Max: 39
+
+Bot.MaxNpcBots = 1
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        If set to 0, no restriction
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass = 1
+
+#    Bot.BaseFollowDistance
+#        Default follow distance set at login
+#        Default: 30
+
+Bot.BaseFollowDistance = 30
+
+#    Bot.XpReductionPercent
+#        Since bot party can be pretty large, it can become an exploit to farm xp so you can reduce xp gain here
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 90
+#        Default: 0
+
+Bot.XpReductionPercent = 0
+
+#    Bot.HealTargetIconsMask
+#        Icon number bitmask which bots are using to search for additional targets to heal (out of party)
+#        1 - Star
+#        2 - Circle
+#        4 - Diamond
+#        8 - Triangle
+#        16 - Moon
+#        32 - Square
+#        64 - Cross
+#        128 - Skull
+#        Example: to check Star, Triangle and Square we need 1+8+32 = 41
+#        Note that many creatures cannot accept heal
+#        Min: 0 (Disable)
+#        Max: 255 (Any Icon)
+#        Default: 8 (Triangle)
+
+Bot.HealTargetIconsMask = 8
+
+#    Bot.DamageMult
+#        Myltiplier for bot's damage dealt. Allows to balance bots' compared to players' damage
+#        Any damage done by bots will be modified
+#        Range: 0.01 - 10.0
+#        Default: 1.0
+
+Bot.DamageMult.Melee = 1.0
+Bot.DamageMult.Spell = 1.0
+
+#    Bot.EnableIn... Arenas/BGs/Dungeons/Raids
+#        Allows to restrict bots usage in PvE and/or PvP
+#        Default: true for all
+
+Bot.EnableInArenas = 1
+Bot.EnableInBGs = 1
+Bot.EnableInDungeons = 1
+Bot.EnableInRaids = 1
+
+#    Bot.InstanceLimit... Dungeons/Raids
+#        If set to 1 will apply instance players limitation to bots
+#        Default: false for all
+
+Bot.InstanceLimit.Dungeons = 0
+Bot.InstanceLimit.Raids = 0
+
+#    Bot.Cost
+#        Bot recruitment cost (in copper)
+#        Note: this value is set for lvl 80 characters. Cost will be reduced for lower levels
+#        Default: 0
+
+Bot.Cost = 0
+
+#    Bot.PvP
+#        If set to 0 bots will not attack  players or other bots
+#        Default: 1
+
+Bot.PvP = 1
+
+#
+###################################################################################################
-- 
1.7.6.msysgit.0

