From 415cb0077ca036abc0623b4c1f910fd31ed0f99a Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@mail.ru>
Date: Thu, 15 Dec 2011 13:23:33 +0700
Subject: [PATCH] BOTS

---
 sql/Bots/character_NPC_bots.sql                    |    9 +
 sql/Bots/world.bots.sql                            |  283 ++
 sql/Bots/world.script_bot_giver.sql                |    7 +
 src/server/game/AI/Bots/PlayerbotAI.cpp            | 4450 ++++++++++++++++++++
 src/server/game/AI/Bots/PlayerbotAI.h              |  284 ++
 src/server/game/AI/Bots/PlayerbotClassAI.cpp       |  599 +++
 src/server/game/AI/Bots/PlayerbotClassAI.h         |  162 +
 src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp |  325 ++
 src/server/game/AI/Bots/PlayerbotDeathKnightAI.h   |   61 +
 src/server/game/AI/Bots/PlayerbotDruidAI.cpp       |  676 +++
 src/server/game/AI/Bots/PlayerbotDruidAI.h         |   70 +
 src/server/game/AI/Bots/PlayerbotHunterAI.cpp      |  561 +++
 src/server/game/AI/Bots/PlayerbotHunterAI.h        |   70 +
 src/server/game/AI/Bots/PlayerbotMageAI.cpp        |  384 ++
 src/server/game/AI/Bots/PlayerbotMageAI.h          |   69 +
 src/server/game/AI/Bots/PlayerbotPaladinAI.cpp     |  536 +++
 src/server/game/AI/Bots/PlayerbotPaladinAI.h       |   70 +
 src/server/game/AI/Bots/PlayerbotPriestAI.cpp      |  400 ++
 src/server/game/AI/Bots/PlayerbotPriestAI.h        |   59 +
 src/server/game/AI/Bots/PlayerbotRogueAI.cpp       |  266 ++
 src/server/game/AI/Bots/PlayerbotRogueAI.h         |   41 +
 src/server/game/AI/Bots/PlayerbotShamanAI.cpp      |  555 +++
 src/server/game/AI/Bots/PlayerbotShamanAI.h        |   75 +
 src/server/game/AI/Bots/PlayerbotWarlockAI.cpp     |  410 ++
 src/server/game/AI/Bots/PlayerbotWarlockAI.h       |   57 +
 src/server/game/AI/Bots/PlayerbotWarriorAI.cpp     |  400 ++
 src/server/game/AI/Bots/PlayerbotWarriorAI.h       |   57 +
 src/server/game/AI/CoreAI/PetAI.cpp                |    2 +
 src/server/game/AI/ScriptedAI/PlayerbotClassAI.h   |  162 +
 src/server/game/CMakeLists.txt                     |    2 +
 src/server/game/Chat/Chat.cpp                      |   13 +
 src/server/game/Chat/Chat.h                        |    7 +
 src/server/game/Chat/Commands/Level0.cpp           |  573 +++
 src/server/game/Chat/Commands/Level1.cpp           |    5 +-
 src/server/game/Chat/Commands/Level3.cpp           |  201 +
 src/server/game/Entities/Creature/Creature.cpp     |   93 +
 src/server/game/Entities/Creature/Creature.h       |   73 +
 src/server/game/Entities/Creature/GossipDef.h      |    1 +
 .../game/Entities/Creature/TemporarySummon.cpp     |   12 +
 src/server/game/Entities/Object/Object.cpp         |   16 +-
 src/server/game/Entities/Player/Player.cpp         | 1172 +++++-
 src/server/game/Entities/Player/Player.h           |   52 +
 src/server/game/Entities/Unit/Unit.cpp             |   11 +-
 src/server/game/Globals/ObjectMgr.cpp              |   11 +-
 src/server/game/Globals/ObjectMgr.h                |    1 +
 src/server/game/Groups/Group.cpp                   |  118 +-
 src/server/game/Groups/Group.h                     |   19 +
 src/server/game/Maps/Map.cpp                       |   33 +-
 src/server/game/Quests/QuestDef.h                  |    4 +-
 src/server/game/Scripting/ScriptLoader.cpp         |   25 +
 src/server/game/Scripting/ScriptMgr.cpp            |   20 +-
 src/server/game/Scripting/ScriptMgr.h              |    5 +
 .../Server/Protocol/Handlers/CharacterHandler.cpp  |  180 +
 .../game/Server/Protocol/Handlers/ChatHandler.cpp  |   30 +-
 .../game/Server/Protocol/Handlers/GroupHandler.cpp |   42 +-
 .../game/Server/Protocol/Handlers/NPCHandler.cpp   |    1 +
 src/server/game/Server/WorldSession.cpp            |  111 +-
 src/server/game/Server/WorldSession.h              |   24 +
 src/server/scripts/Bots/CMakeLists.txt             |   26 +
 src/server/scripts/Bots/bot_ai.cpp                 | 1693 ++++++++
 src/server/scripts/Bots/bot_ai.h                   |  627 +++
 src/server/scripts/Bots/bot_druid_ai.cpp           |  997 +++++
 src/server/scripts/Bots/bot_druid_ai.h             |  106 +
 src/server/scripts/Bots/bot_hunter_ai.cpp          |  325 ++
 src/server/scripts/Bots/bot_hunter_ai.h            |   26 +
 src/server/scripts/Bots/bot_mage_ai.cpp            |  727 ++++
 src/server/scripts/Bots/bot_mage_ai.h              |  123 +
 src/server/scripts/Bots/bot_paladin_ai.cpp         |  989 +++++
 src/server/scripts/Bots/bot_paladin_ai.h           |  118 +
 src/server/scripts/Bots/bot_priest_ai.cpp          |  737 ++++
 src/server/scripts/Bots/bot_priest_ai.h            |   84 +
 src/server/scripts/Bots/bot_rogue_ai.cpp           |  325 ++
 src/server/scripts/Bots/bot_rogue_ai.h             |   32 +
 src/server/scripts/Bots/bot_shaman_ai.cpp          |  395 ++
 src/server/scripts/Bots/bot_shaman_ai.h            |   48 +
 src/server/scripts/Bots/bot_warlock_ai.cpp         |  403 ++
 src/server/scripts/Bots/bot_warlock_ai.h           |   36 +
 src/server/scripts/Bots/bot_warrior_ai.cpp         | 1131 +++++
 src/server/scripts/Bots/bot_warrior_ai.h           |  103 +
 src/server/scripts/Bots/script_bot_giver.cpp       |  294 ++
 src/server/scripts/CMakeLists.txt                  |    1 +
 src/server/shared/Common.h                         |    4 +
 src/server/worldserver/worldserver.conf.dist       |   77 +
 83 files changed, 23356 insertions(+), 26 deletions(-)
 create mode 100644 sql/Bots/character_NPC_bots.sql
 create mode 100644 sql/Bots/world.bots.sql
 create mode 100644 sql/Bots/world.script_bot_giver.sql
 create mode 100644 src/server/game/AI/Bots/PlayerbotAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotClassAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotClassAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotDeathKnightAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotDruidAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotDruidAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotHunterAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotHunterAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotMageAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotMageAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotPaladinAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotPaladinAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotPriestAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotPriestAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotRogueAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotRogueAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotShamanAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotShamanAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarlockAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarlockAI.h
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarriorAI.cpp
 create mode 100644 src/server/game/AI/Bots/PlayerbotWarriorAI.h
 create mode 100644 src/server/game/AI/ScriptedAI/PlayerbotClassAI.h
 create mode 100644 src/server/scripts/Bots/CMakeLists.txt
 create mode 100644 src/server/scripts/Bots/bot_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_ai.h
 create mode 100644 src/server/scripts/Bots/bot_druid_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_druid_ai.h
 create mode 100644 src/server/scripts/Bots/bot_hunter_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_hunter_ai.h
 create mode 100644 src/server/scripts/Bots/bot_mage_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_mage_ai.h
 create mode 100644 src/server/scripts/Bots/bot_paladin_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_paladin_ai.h
 create mode 100644 src/server/scripts/Bots/bot_priest_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_priest_ai.h
 create mode 100644 src/server/scripts/Bots/bot_rogue_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_rogue_ai.h
 create mode 100644 src/server/scripts/Bots/bot_shaman_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_shaman_ai.h
 create mode 100644 src/server/scripts/Bots/bot_warlock_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_warlock_ai.h
 create mode 100644 src/server/scripts/Bots/bot_warrior_ai.cpp
 create mode 100644 src/server/scripts/Bots/bot_warrior_ai.h
 create mode 100644 src/server/scripts/Bots/script_bot_giver.cpp

diff --git a/sql/Bots/character_NPC_bots.sql b/sql/Bots/character_NPC_bots.sql
new file mode 100644
index 0000000..4a4066c
--- /dev/null
+++ b/sql/Bots/character_NPC_bots.sql
@@ -0,0 +1,9 @@
+CREATE TABLE IF NOT EXISTS `character_npcbot` (
+  `guid` int(11) default NULL,
+  `owner` int(11) default NULL,
+  `entry` int(11) default NULL,
+  `race` tinyint(4) default NULL,
+  `class` tinyint(4) default NULL
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
diff --git a/sql/Bots/world.bots.sql b/sql/Bots/world.bots.sql
new file mode 100644
index 0000000..e518951
--- /dev/null
+++ b/sql/Bots/world.bots.sql
@@ -0,0 +1,283 @@
+
+delete from `creature_template` where entry >= 60001 && entry < 60239;
+
+insert  into `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction_A`,`faction_H`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`mindmg`,`maxdmg`,`dmgschool`,`attackpower`,`dmg_multiplier`,`baseattacktime`,`rangeattacktime`,`unit_class`,`unit_flags`,`dynamicflags`,`family`,
+`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`minrangedmg`,`maxrangedmg`,`rangedattackpower`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,
+`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`Health_mod`,`Mana_mod`,`Armor_mod`,`RacialLeader`,
+`questItem1`,`questItem2`,`questItem3`,`questItem4`,`questItem5`,`questItem6`,`movementId`,`RegenHealth`,`equipment_id`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`WDBVerified`) values 
+(60001,0,0,0,0,0,5001,0,5001,0,'Khelden','Mage Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,8,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60002,0,0,0,0,0,1294,0,1294,0,'Zaldimar','Mage Bot','',0,80,80,2,12,12,1,0.98,1.14286,1,0,5,10,0,54,1,1500,0,8,4608,0,0,0,0,8,1,21.5072,29.5724,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'mage_bot',0),
+(60003,0,0,0,0,0,1484,0,1484,0,'Maginor','Mage Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,4608,0,0,0,0,8,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60004,0,0,0,0,0,3344,0,3344,0,'Anetta','Priest Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,5,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60005,0,0,0,0,0,1495,0,1495,0,'Laurena','Priest Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,4608,0,0,0,0,5,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60006,0,0,0,0,0,1295,0,1295,0,'Josetta','Priest Bot','',0,80,80,2,12,12,1,0.98,1.14286,1,0,5,10,0,54,1,1500,0,8,4608,0,0,0,0,5,1,21.5072,29.5724,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'priest_bot',0),
+(60007,0,0,0,0,0,3345,0,3345,0,'Drusilla','Warlock Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,9,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60008,0,0,0,0,0,1930,0,1930,0,'Alamar','Warlock Bot','',0,80,80,2,875,875,1,1.07,1.14286,1,0,2,5,0,23,1,1960,2156,8,4608,0,0,0,0,9,7,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60009,0,0,0,0,0,1469,0,1469,0,'Demisette','Warlock Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,4608,0,0,0,0,9,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60010,0,0,0,0,0,12749,0,12749,0,'Nalesette','Hunter Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,23,48,0,247,1,1500,1500,2,4608,0,0,3,0,3,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,319,0,'hunter_bot',0),
+(60011,0,0,0,0,0,3401,0,3401,0,'Branstock','Priest Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,8,4608,0,0,0,0,5,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60012,0,0,0,0,0,3395,0,3395,0,'Thorgas','Hunter Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,2,4608,0,0,0,0,3,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60013,0,0,0,0,0,3343,0,3343,0,'Llane','Warrior Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,65,0,364,1,1500,0,1,4608,0,0,0,0,1,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,702,0,'warrior_bot',0),
+(60014,0,0,0,0,0,3399,0,3399,0,'Thran','Warrior Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,55,0,267,1,1960,2156,1,4608,0,0,0,0,1,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,702,0,'warrior_bot',0),
+(60015,0,0,0,0,0,1300,0,1300,0,'Lyria','Warrior Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,90,0,543,1,1500,0,1,4608,0,0,0,0,1,1,19.9584,27.4428,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,647,0,'warrior_bot',0),
+(60016,0,0,0,0,0,3351,0,3351,0,'Jorik','Rogue Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,75,0,1489,1,1500,0,4,4608,0,0,0,0,4,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60017,0,0,0,0,0,3407,0,3407,0,'Solm','Rogue Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,74,0,1489,1,1960,2156,4,4608,0,0,0,0,4,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60018,0,0,0,0,0,1297,0,1297,0,'Keryn','Rogue Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,53,0,1489,1,2000,0,4,4608,0,0,0,0,4,1,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,730,0,'rogue_bot',0),
+(60019,0,0,0,0,0,1507,0,1507,0,'Osborne','Rogue Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,1489,1,1500,0,4,4608,0,0,0,0,4,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,392,0,'rogue_bot',0),
+(60020,0,0,0,0,0,3346,0,3346,0,'Sammuel','Paladin Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,2,4608,0,0,0,0,2,1,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,429,0,'paladin_bot',0),
+(60021,0,0,0,0,0,3393,0,3393,0,'Bob','Paladin Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,2,4608,0,0,0,0,2,3,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,429,0,'paladin_bot',0),
+(60022,0,0,0,0,0,1299,0,1299,0,'Wilhelm','Paladin Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,9,0,45,1,1500,0,2,4608,0,0,0,0,2,1,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,426,0,'paladin_bot',0),
+(60023,0,0,0,0,0,1499,0,1499,0,'Brisombre','Paladin Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,2,4608,0,0,0,0,2,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,105,0,'paladin_bot',0),
+(60024,0,0,0,0,0,10216,0,10216,0,'Marry','Mage Bot','',0,80,80,2,875,875,1,1.07,1.14286,1,0,2,5,0,23,1,1960,2156,8,4608,0,0,0,0,8,7,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,3,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60025,0,0,0,0,0,4552,0,4552,0,'Haromm','Shaman Bot','',0,80,80,2,29,29,1,1.05,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,7,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1691,0,'shaman_bot',0),
+(60026,0,0,0,0,0,4567,0,4567,0,'Kartosh','Warlock Bot','',0,80,80,2,29,29,1,1.05,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60027,0,0,0,0,0,3429,0,3429,0,'MaxanAnvol','Priest Bot','',0,80,80,2,55,55,1,0.96,1.14286,1,0,3,9,0,42,1,1500,0,8,4608,0,0,0,0,5,3,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1315,0,'priest_bot',0),
+(60028,0,0,0,0,0,10215,0,10215,0,'Magis','Mage Bot','',0,80,80,2,875,875,1,1.1,1.14286,1,0,3,9,0,42,1,1500,0,8,4608,0,0,0,0,8,7,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60029,0,0,0,0,0,3431,0,3431,0,'GranVivehache','Warrior Bot','',0,80,80,2,55,55,1,0.96,1.14286,1,0,3,75,0,422,1,1500,0,1,4608,0,0,0,0,1,3,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,1309,0,'warrior_bot',0),
+(60030,0,0,0,0,0,1622,0,1622,0,'Azar','Paladin Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,2,4608,0,0,0,0,2,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,105,0,'paladin_bot',0),
+(60031,0,0,0,0,0,3436,0,3436,0,'Hogral','Rogue Bot','',0,80,80,2,55,55,1,0.97,1.14286,1,0,5,56,0,1489,1,2000,0,4,4608,0,0,0,0,4,3,19.9584,27.4428,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60032,0,0,0,0,0,3053,0,3053,0,'Kelstrum','Warrior Bot','',0,80,80,2,55,55,1,1.17,1.14286,1,0,27,57,0,294,1,1500,0,1,4608,0,0,0,0,1,3,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1853,0,'warrior_bot',0),
+(60033,0,0,0,0,0,1578,0,1578,0,'Dannal','Warrior Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,67,0,364,1,2000,0,1,4608,0,0,0,0,1,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,639,0,'warrior_bot',0),
+(60034,0,0,0,0,0,1579,0,1579,0,'SombreDuesten','Priest Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,5,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60035,0,0,0,0,0,1592,0,1592,0,'Isabella','Mage Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,8,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1022,0,'mage_bot',0),
+(60036,0,0,0,0,0,1581,0,1581,0,'Maximillion','Warlock Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,9,5,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,143,0,'warlock_bot',0),
+(60037,0,0,0,0,0,1604,0,1604,0,'Rupert','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,6,13,0,65,1,2000,0,8,4608,0,0,0,0,9,5,24.552,33.759,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1022,0,'warlock_bot',0),
+(60038,0,0,0,0,0,1600,0,1600,0,'Cain','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,6,12,0,59,1,2000,0,8,4608,0,0,0,0,8,5,23.0384,31.6778,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60039,0,0,0,0,0,1602,0,1602,0,'SombreBeryl','Priest Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,7,14,0,75,1,2000,0,8,4608,0,0,0,0,5,5,27.5264,37.8488,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60041,0,0,0,0,0,10548,0,10548,0,'Milituus','Mage Bot','',0,80,80,2,55,55,1,1.35,1.14286,1,0,27,57,0,294,1,2000,0,8,4608,0,0,0,0,8,3,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60042,0,0,0,0,0,2810,0,2810,0,'Lexington','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,19,40,0,205,1,2000,0,8,4608,0,0,0,0,8,5,51.128,70.301,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60043,0,0,0,0,0,2123,0,2123,0,'Siln','Shaman Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,7,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,586,0,'shaman_bot',0),
+(60044,0,0,0,0,0,19598,0,19598,0,'Umbrua','Shaman Bot','',0,80,80,2,1640,1640,1,1.125,1.14286,1,0,176,200,0,1235,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1627,0,'shaman_bot',0),
+(60045,0,0,0,0,0,2102,0,2102,0,'Tigor','Shaman Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,200,0,247,1,2000,0,2,4608,0,0,0,0,7,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,145,0,'shaman_bot',0),
+(60046,0,0,0,0,0,2082,0,2082,0,'Beram','Shaman Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,200,0,451,1,2000,0,2,4608,0,0,0,0,7,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,157,0,'shaman_bot',0),
+(60047,0,0,0,0,0,2106,0,2106,0,'Turak','Druid Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,11,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1069,0,'druid_bot',0),
+(60048,0,0,0,0,0,2121,0,2121,0,'Sheal','Druid Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60049,0,0,0,0,0,2115,0,2115,0,'Kym','Druid Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,123,248,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1034,0,'druid_bot',0),
+(60050,0,0,0,0,0,2112,0,2112,0,'Kary','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1200,2,4608,0,0,0,0,3,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,920,0,'hunter_bot',0),
+(60051,0,0,0,0,0,2087,0,2087,0,'Holt','Hunter Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1000,2,4608,0,0,0,0,3,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60052,0,0,0,0,0,2105,0,2105,0,'Urek','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1300,2,4608,0,0,0,0,3,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,6,0,'hunter_bot',0),
+(60053,0,0,0,0,0,2103,0,2103,0,'Torm','Warrior Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,1,4608,0,0,0,0,1,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,916,0,'warrior_bot',0),
+(60054,0,0,0,0,0,2096,0,2096,0,'Sark','Warrior Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,6,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,133,0,'warrior_bot',0),
+(60055,0,0,0,0,0,17211,0,17211,0,'Kerra','Warrior Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,491,18,0,'warrior_bot',0),
+(60056,0,0,0,0,0,2139,0,2139,0,'Miles Welsh','Priest Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,5,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,40,0,'priest_bot',0),
+(60057,0,0,0,0,0,2138,0,2138,0,'Malakai','Priest Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,65,0,'priest_bot',0),
+(60058,0,0,0,0,0,2137,0,2137,0,'Cobb','Priest Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1096,0,'priest_bot',0),
+(60059,0,0,0,0,0,2134,0,2134,0,'Shymm','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,8,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,143,145,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,108,0,'mage_bot',0),
+(60060,0,0,0,0,0,6058,0,6058,0,'Ursyn','Mage Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60061,0,0,0,0,0,2135,0,2135,0,'Thurston','Mage Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,129,0,'mage_bot',0),
+(60062,0,0,0,0,0,3793,0,3793,0,'Harutt','Warrior Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,40,99,0,637,1,2000,0,1,4608,0,0,0,0,1,6,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,1977,0,'warrior_bot',0),
+(60063,0,0,0,0,0,3819,0,3819,0,'Gart','Druid Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,3,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,15.2064,20.9088,100,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1073,0,'druid_bot',0),
+(60064,0,0,0,0,0,3810,0,3810,0,'Lanka','Hunter Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,5,9,0,45,1,2000,1460,2,4608,0,0,0,0,3,6,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,138,0,'hunter_bot',0),
+(60065,0,0,0,0,0,10180,0,10180,0,'Meela','Shaman Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,3,200,0,42,1,2000,0,2,4608,0,0,0,0,7,6,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,157,0,'shaman_bot',0),
+(60066,0,0,0,0,0,3794,0,3794,0,'Krang','Warrior Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,40,68,0,575,1,2000,0,1,4608,0,0,0,0,1,6,23.0384,31.6778,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1977,0,'warrior_bot',0),
+(60067,0,0,0,0,0,10734,0,10734,0,'Gennia','Druid Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,5,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,19.9584,27.4428,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1069,0,'druid_bot',0),
+(60068,0,0,0,0,0,3811,0,3811,0,'Yaw','Hunter Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,5,9,0,45,1,2000,1200,2,4608,0,0,0,0,3,6,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,127,0,'hunter_bot',0),
+(60069,0,0,0,0,0,3816,0,3816,0,'Narm','Shaman Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,5,200,0,54,1,2000,0,2,4608,0,0,0,0,7,6,21.5072,29.5724,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,446,0,'shaman_bot',0),
+(60070,0,0,0,0,0,1880,0,1880,0,'Frang','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,30,99,0,670,1,2000,2090,1,4608,0,0,0,0,1,2,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1977,0,'warrior_bot',0),
+(60071,0,0,0,0,0,1882,0,1882,0,'Jenshan','Hunter Bot','',0,80,80,2,126,126,1,0.95,1.14286,1,0,2,7,0,33,1,2000,2123,2,4608,0,0,0,0,3,8,13.5872,18.6824,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,193,0,'hunter_bot',0),
+(60072,0,0,0,0,0,1884,0,1884,0,'Nartok','Warlock Bot','',0,80,80,2,29,29,1,0.96,1.14286,1,0,3,9,0,38,1,2000,2112,8,4608,0,0,0,0,9,2,15.2064,20.9088,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1022,0,'warlock_bot',0),
+(60073,0,0,0,0,0,1878,0,1878,0,'Shikrik','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,3,200,0,42,1,2000,2101,2,4608,0,0,0,0,7,2,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,604,0,'shaman_bot',0),
+(60074,0,0,0,0,0,3743,0,3743,0,'Tarshaw','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,25,53,0,273,1,2000,1738,1,4608,0,0,0,0,1,2,59.7872,82.2074,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,642,0,'warrior_bot',0),
+(60075,0,0,0,0,0,3744,0,3744,0,'Thotar','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,6,15,0,72,1,2000,2035,2,4608,0,0,0,0,3,2,26.048,35.816,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,920,0,'hunter_bot',0),
+(60076,0,0,0,0,0,3745,0,3745,0,'Dhugru','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,21,43,0,220,1,2000,1804,8,4608,0,0,0,0,9,2,53.3984,73.4228,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60077,0,0,0,0,0,3746,0,3746,0,'Swart','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,6,200,0,65,1,2000,2046,2,4608,0,0,0,0,7,2,24.552,33.759,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,861,0,'shaman_bot',0),
+(60078,0,0,0,0,0,1324,0,1324,0,'Groldar','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60079,0,0,0,0,0,1325,0,1325,0,'Mirket','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60080,0,0,0,0,0,1326,0,1326,0,'Zevrost','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60081,0,0,0,0,0,1360,0,1360,0,'Kardris','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,200,0,451,1,2000,0,2,4608,0,0,0,0,7,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,586,0,'shaman_bot',0),
+(60082,0,0,0,0,0,1373,0,1373,0,'Ormak','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1551,2,4608,0,0,0,0,3,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,8,0,'hunter_bot',0),
+(60083,0,0,0,0,0,1374,0,1374,0,'Grezz','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,1865,0,'warrior_bot',0),
+(60084,0,0,0,0,0,1375,0,1375,0,'Sorek','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,1,4608,0,0,0,0,1,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,725,0,'warrior_bot',0),
+(60085,0,0,0,0,0,4231,0,4231,0,'Siantsu','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,200,0,247,1,2000,0,2,4608,0,0,0,0,7,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,170,0,'shaman_bot',0),
+(60086,0,0,0,0,0,4239,0,4239,0,'Xorjuul','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,2,4608,0,0,0,0,3,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60087,0,0,0,0,0,4241,0,4241,0,'Siandur','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,4608,0,0,0,0,3,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60088,0,0,0,0,0,4242,0,4242,0,'Zelmak','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1867,0,'warrior_bot',0),
+(60089,0,0,0,0,0,7915,0,7915,0,'ClaudeErksine','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,1610,1771,2,4608,0,0,3,0,3,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60090,0,0,0,0,0,1721,0,1721,0,'Alyissia','Warrior Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,50,87,0,322,1,2000,0,1,4608,0,0,0,0,1,4,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,639,0,'warrior_bot',0),
+(60091,0,0,0,0,0,1725,0,1725,0,'FrahunMurmombre','Rogue Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,5,43,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,220,0,'rogue_bot',0),
+(60092,0,0,0,0,0,1733,0,1733,0,'Shanda','Priest Bot','',0,80,80,2,80,80,1,0.96,1.14286,1,0,3,9,0,42,1,2000,0,8,4608,0,0,0,0,5,4,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60093,0,0,0,0,0,1732,0,1732,0,'Mardant','Druid Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,5,367,0,45,1,2000,0,2,4608,0,0,0,0,11,4,18.392,25.289,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,114,0,'druid_bot',0),
+(60094,0,0,0,0,0,1707,0,1707,0,'Kyra','Warrior Bot','',0,80,80,2,80,80,1,1.01,1.14286,1,0,25,87,0,422,1,2000,0,1,4608,0,0,0,0,1,4,30.4304,41.8418,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1913,0,'warrior_bot',0),
+(60095,0,0,0,0,0,1704,0,1704,0,'Jannok','Rogue Bot','',0,80,80,2,80,80,1,1.02,1.14286,1,0,9,73,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,31.856,43.802,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,628,0,'rogue_bot',0),
+(60096,0,0,0,0,0,1708,0,1708,0,'Laurna','Priest Bot','',0,80,80,2,80,80,1,1.03,1.14286,1,0,9,20,0,100,1,2000,0,8,4608,0,0,0,0,5,4,33.264,45.738,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60097,0,0,0,0,0,1706,0,1706,0,'Kal','Druid Bot','',0,80,80,2,80,80,1,1.03,1.14286,1,0,10,214,0,107,1,2000,0,2,4608,0,0,0,0,11,4,34.6544,47.6498,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'druid_bot',0),
+(60098,0,0,0,0,0,4296,0,4296,0,'Harruk','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,4608,0,0,3,0,3,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,344,0,'hunter_bot',0),
+(60099,0,0,0,0,0,4299,0,4299,0,'Reban','Hunter bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1100,2,4608,0,0,3,0,3,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,865,0,'hunter_bot',0),
+(60100,0,0,0,0,0,4304,0,4304,0,'Bolyun','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,23,48,0,247,1,2000,1235,2,4608,0,0,3,0,3,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60101,0,0,0,0,0,1897,0,1897,0,'Taijin','Priest Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,8,16,0,84,1,2000,2013,8,4608,0,0,0,0,5,8,28.9872,39.8574,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60102,0,0,0,0,0,4068,0,4068,0,'Kenjai','Priest Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,3,9,0,42,1,2000,2101,8,4608,0,0,0,0,5,8,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,458,0,'priest_bot',0),
+(60103,0,0,0,0,0,2066,0,2066,0,'Danlaar','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,19,40,0,205,1,2000,1382,2,4608,0,0,0,0,3,4,51.128,70.301,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1,0,'hunter_bot',0),
+(60104,0,0,0,0,0,2196,0,2196,0,'Ariasta','Warrior Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,822,0,'warrior_bot',0),
+(60105,0,0,0,0,0,2198,0,2198,0,'Sildanair','Warrior Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,281,0,'warrior_bot',0),
+(60106,0,0,0,0,0,2200,0,2200,0,'Astarii','Priest Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60107,0,0,0,0,0,2201,0,2201,0,'Jandria','Priest Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60108,0,0,0,0,0,2202,0,2202,0,'Lariia','Priest Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,5,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60109,0,0,0,0,0,2231,0,2231,0,'Syurna','Rogue Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,220,0,'rogue_bot',0),
+(60110,0,0,0,0,0,7669,0,7669,0,'Elissa','Mage Bot','',0,80,80,2,80,80,1,1.11,1.14286,1,0,19,40,0,205,1,2000,0,8,4608,0,0,0,0,8,4,51.128,70.301,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60111,0,0,0,0,0,2252,0,2252,0,'Erion','Rogue Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,277,0,'rogue_bot',0),
+(60112,0,0,0,0,0,2243,0,2243,0,'Anishar','Rogue Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,67,0,1489,1,2000,0,4,4608,0,0,0,0,4,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,1913,0,'rogue_bot',0),
+(60113,0,0,0,0,0,2250,0,2250,0,'Denatharion','Druid Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,267,0,345,1,2000,0,2,4608,0,0,0,0,11,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,258,0,'druid_bot',0),
+(60114,0,0,0,0,0,2255,0,2255,0,'Fylerian','Druid Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,348,0,247,1,2000,0,2,4608,0,0,0,0,11,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,358,0,'druid_bot',0),
+(60115,0,0,0,0,0,2416,0,2416,0,'Caelyb','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,23,48,0,247,1,2000,1186,2,4608,0,0,3,0,3,4,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1073,0,'hunter_bot',0),
+(60116,0,0,0,0,0,2675,0,2675,0,'Kaal','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,9,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60117,0,0,0,0,0,16800,0,16800,0,'Lana','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1784,0,'warlock_bot',0),
+(60118,0,0,0,0,0,2646,0,2646,0,'Richard','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,9,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1217,0,'warlock_bot',0),
+(60119,0,0,0,0,0,10214,0,10214,0,'Kaelystia','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,8,5,74.448,102.366,100,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,8388624,'mage_bot',0),
+(60120,0,0,0,0,0,2644,0,2644,0,'Pierce','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60121,0,0,0,0,0,2657,0,2657,0,'Anastasia','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60122,0,0,0,0,0,2620,0,2620,0,'Chris','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,4608,0,0,0,0,1,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,801,0,'warrior_bot',0),
+(60123,0,0,0,0,0,2658,0,2658,0,'Angela','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,1,4608,0,0,0,0,1,5,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1881,0,'warrior_bot',0),
+(60124,0,0,0,0,0,2614,0,2614,0,'Baltus','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,1,4608,0,0,0,0,1,5,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,1882,0,'warrior_bot',0),
+(60125,0,0,0,0,0,3054,0,3054,0,'Kelv','Warrior Bot','',0,80,80,2,55,55,1,1.17,1.14286,1,0,27,57,0,294,1,1560,1716,1,4608,0,0,0,0,1,3,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,136,0,'warrior_bot',0),
+(60126,0,0,0,0,0,3055,0,3055,0,'Bilban','Warrior Bot','',0,80,80,2,875,875,1,1.35,1.14286,1,0,27,57,0,294,1,1500,0,1,4608,0,0,0,0,1,7,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,675,0,'warrior_bot',0),
+(60127,0,0,0,0,0,3056,0,3056,0,'Daera','Hunter Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,1410,1551,2,4608,0,0,0,0,3,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60128,0,0,0,0,0,3072,0,3072,0,'Olmin','Hunter Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1033,2,4608,0,0,0,0,3,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60129,0,0,0,0,0,3073,0,3073,0,'Regnus','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1012,2,4608,0,0,0,0,3,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60130,0,0,0,0,0,3086,0,3086,0,'Theodrus','Priest Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60131,0,0,0,0,0,3066,0,3066,0,'Braenna','Priest Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60132,0,0,0,0,0,3085,0,3085,0,'Toldren','Priest Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,5,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60134,0,0,0,0,0,3108,0,3108,0,'Bink','Mage Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,7,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60135,0,0,0,0,0,10214,0,10214,0,'Juli','Mage Bot','',0,80,80,2,875,875,1,1.38,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,7,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60136,0,0,0,0,0,3109,0,3109,0,'Nittegousse','Mage Bot','',0,80,80,2,55,55,1,1.45,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,8,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60137,0,0,0,0,0,3089,0,3089,0,'Valgar','Paladin Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,2,4608,0,0,0,0,2,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,105,0,'paladin_bot',0),
+(60138,0,0,0,0,0,3088,0,3088,0,'Beldruk','Paladin Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,4608,0,0,0,0,2,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,799,0,'paladin_bot',0),
+(60139,0,0,0,0,0,3087,0,3087,0,'Brandur','Paladin Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,4608,0,0,0,0,2,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,799,0,'paladin_bot',0),
+(60140,0,0,0,0,0,3101,0,3101,0,'Hulfdan','Rogue Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,4608,0,0,0,0,4,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,1886,0,'rogue_bot',0),
+(60141,0,0,0,0,0,3100,0,3100,0,'Ormyr','Rogue Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,1489,1,2000,0,4,4608,0,0,0,0,4,3,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,220,0,'rogue_bot',0),
+(60142,0,0,0,0,0,3113,0,3113,0,'Phenwick','Rogue Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,1489,1,2000,0,4,4608,0,0,0,0,4,7,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,220,0,'rogue_bot',0),
+(60143,0,0,0,0,0,3115,0,3115,0,'Coeurdechardon','Warlock Bot','',0,80,80,2,55,55,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,9,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60144,0,0,0,0,0,3116,0,3116,0,'Eglantin','Warlock Bot','',0,80,80,2,875,875,1,1.38,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,7,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60145,0,0,0,0,0,3122,0,3122,0,'Alexander','Warlock Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,9,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60146,0,0,0,0,0,3280,0,3280,0,'Wu','Warrior Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,1500,0,1,4608,0,0,0,0,1,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,727,0,'warrior_bot',0),
+(60147,0,0,0,0,0,3287,0,3287,0,'Ilsa','Warrior Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,1500,0,1,4608,0,0,0,0,1,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,613,0,'warrior_bot',0),
+(60148,0,0,0,0,0,3283,0,3283,0,'Joshua','Priest Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,5,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60149,0,0,0,0,0,3284,0,3284,0,'Arthur','Paladin Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,2,4608,0,0,0,0,2,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,799,0,'paladin_bot',0),
+(60150,0,0,0,0,0,3289,0,3289,0,'Katherine','Paladin Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,4608,0,0,0,0,2,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,799,0,'paladin_bot',0),
+(60151,0,0,0,0,0,3291,0,3291,0,'Deline','Warlock Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,9,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60152,0,0,0,0,0,3286,0,3286,0,'Sandahl','Warlock Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,9,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60153,0,0,0,0,0,3292,0,3292,0,'Jennea','Mage Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60154,0,0,0,0,0,19803,0,19803,0,'Elsharin','Mage Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,4608,0,0,0,0,8,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60155,0,0,0,0,0,3299,0,3299,0,'Kaerbrus','Hunter Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,39,80,0,418,1,2000,1263,2,4608,0,0,0,0,3,4,72.2304,99.3168,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60156,0,0,0,0,0,3300,0,3300,0,'Sheldras','Druid Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,288,0,451,1,2000,0,2,4608,0,0,0,0,11,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1071,0,'druid_bot',0),
+(60157,0,0,0,0,0,3301,0,3301,0,'Theridran','Druid Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,467,0,345,1,2000,0,2,4608,0,0,0,0,11,4,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,258,0,'druid_bot',0),
+(60158,0,0,0,0,0,3312,0,3312,0,'Einris','Hunter Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,2000,1157,2,4608,0,0,0,0,3,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60159,0,0,0,0,0,3309,0,3309,0,'Ulfir','Hunter Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1379,2,4608,0,0,0,0,3,1,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60160,0,0,0,0,0,3310,0,3310,0,'Thorfin','Hunter Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1175,2,4608,0,0,0,0,3,1,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,298,0,'hunter_bot',0),
+(60161,0,0,0,0,0,10171,0,10171,0,'UnThuwa','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,6,12,0,59,1,2000,2057,8,4608,0,0,0,0,8,8,23.0384,31.6778,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'mage_bot',0),
+(60162,0,0,0,0,0,4524,0,4524,0,'Pephredo','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1551,8,4608,0,0,0,0,8,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,559,0,'mage_bot',0),
+(60163,0,0,0,0,0,4522,0,4522,0,'Enyo','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,8,4608,0,0,0,0,8,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,99,0,'mage_bot',0),
+(60164,0,0,0,0,0,4526,0,4526,0,'Mai','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,3,4,0,26,1,2000,2101,8,4608,0,0,0,0,8,8,16.808,23.111,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'mage_bot',0),
+(60165,0,0,0,0,0,4523,0,4523,0,'Deino','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,4608,0,0,0,0,8,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,21,0,'mage_bot',0),
+(60166,0,0,0,0,0,4665,0,4665,0,'Birgitte','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,27,57,0,294,1,1000,0,8,4608,0,0,0,0,8,5,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60167,0,0,0,0,0,12849,0,12849,0,'Thuul','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,27,57,0,294,1,1000,1716,8,4608,0,0,0,0,8,2,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60168,0,0,0,0,0,4690,0,4690,0,'Zayus','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,62,131,0,677,1,2000,1551,8,4608,0,0,0,0,5,2,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'priest_bot',0),
+(60169,0,0,0,0,0,10473,0,10473,0,'Xyera','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,8,4608,0,0,0,0,5,2,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,228,0,'priest_bot',0),
+(60170,0,0,0,0,0,4711,0,4711,0,'Urkyo','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,4608,0,0,0,0,5,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'priest_bot',0),
+(60171,0,0,0,0,0,6060,0,6060,0,'Uthelnay','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,4608,0,0,0,0,8,8,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1071,0,'mage_bot',0),
+(60172,0,0,0,0,0,6072,0,6072,0,'Dink','Mage Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,4608,0,0,0,0,8,7,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60173,0,0,0,0,0,6071,0,6071,0,'Darnath','Warrior Bot','',0,80,80,2,80,80,1,1.23,1.14286,1,0,36,77,0,394,1,2000,0,1,4608,0,0,0,0,1,4,70.664,97.163,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,277,0,'warrior_bot',0),
+(60174,0,0,0,0,0,7356,0,7356,0,'Karman','Paladin Bot','',0,80,80,2,894,894,1,1.25,1.14286,1,0,27,57,0,294,1,2000,0,2,4608,0,0,0,0,2,1,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,117,0,'paladin_bot',0),
+(60175,0,0,0,0,0,11037,0,11037,0,'Evencane','Warrior Bot','',0,80,80,2,894,894,1,1.25,1.14286,1,0,27,57,0,294,1,2000,0,1,4608,0,0,0,0,1,1,61.776,84.942,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,639,0,'warrior_bot',0),
+(60176,0,0,0,0,0,7357,0,7357,0,'Jannos','Druid Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,32,200,0,1034,1,2000,0,2,4608,0,0,0,0,11,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,119,0,'druid_bot',0),
+(60177,0,0,0,0,0,7538,0,7538,0,'Alenndaar','Hunter Bot','',0,80,80,2,1076,1076,1,1.05,1.14286,1,0,14,28,0,143,1,2000,1012,2,4608,0,0,0,0,3,4,41.3424,56.8458,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,886,0,'hunter_bot',0),
+(60178,0,0,0,0,0,10738,0,10738,0,'Golhine','Druid Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,42,288,0,451,1,2000,0,2,4608,0,0,0,0,11,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60179,0,0,0,0,0,9337,0,9337,0,'Hesuwa','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1178,2,4608,0,0,3,0,3,6,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,6,0,'hunter_bot',0),
+(60180,0,0,0,0,0,9336,0,9336,0,'Xao\'tsu','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,4608,0,0,3,0,3,2,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,886,0,'hunter_bot',0),
+(60181,0,0,0,0,0,9338,0,9338,0,'Belia','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1426,2,4608,0,0,3,0,3,3,56.672,77.924,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1081,0,'hunter_bot',0),
+(60182,0,0,0,0,0,10245,0,10245,0,'Dargh','Hunter Bot','',0,80,80,2,55,55,1,1.05,1.14286,1,0,12,25,0,128,1,1760,1936,2,4608,0,0,0,0,3,3,38.72,53.24,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,19,0,'hunter_bot',0),
+(60183,0,0,0,0,0,11044,0,11044,0,'Meideros','Priest Bot','',0,80,80,2,80,80,1,1.08,1.14286,1,0,16,32,0,164,1,2000,0,8,4608,0,0,0,0,5,4,45.144,62.073,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60184,0,0,0,0,0,11048,0,11048,0,'Presse','Priest Bot','',0,80,80,2,1076,1076,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,4,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60185,0,0,0,0,0,11053,0,11053,0,'Rohan','Priest Bot','',0,80,80,2,122,122,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,4608,0,0,0,0,5,3,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60186,0,0,0,0,0,12053,0,12053,0,'Loganaar','Druid Bot','',0,80,80,2,994,994,1,1.1,1.14286,1,0,33,269,0,353,1,2000,0,2,4608,0,0,0,0,11,4,67.32,92.565,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60187,0,0,0,0,0,13171,0,13171,0,'Romano','Rogue Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,4608,0,0,0,0,4,1,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,734,0,'rogue_bot',0),
+(60188,0,0,0,0,0,13341,0,13341,0,'Sagorne','Shaman Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,32,200,0,345,1,2000,0,2,4608,0,0,0,0,7,6,66.44,91.355,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,458,0,'shaman_bot',0),
+(60189,0,0,0,0,0,15522,0,15522,0,'Julia','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,8,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1022,0,'mage_bot',0),
+(60190,0,0,0,0,0,15511,0,15511,0,'Jesthenis','Paladin Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,2,4608,0,0,0,0,2,10,23.4783,32.7308,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1229,0,'paladin_bot',0),
+(60191,0,0,0,0,0,15524,0,15524,0,'Invocateur','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,9,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,1455,0,'warlock_bot',0),
+(60192,0,0,0,0,0,15518,0,15518,0,'Matrone','Priest Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,4608,0,0,0,0,5,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1306,0,'priest_bot',0),
+(60193,0,0,0,0,0,2659,0,2659,0,'Eclaireur','Rogue Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,62,99,0,1489,1,2000,0,4,4608,0,0,0,0,4,5,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1204,0,0,'rogue_bot',0),
+(60194,0,0,0,0,0,15520,0,15520,0,'Sallina','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,1543,2,4608,0,0,0,0,3,10,23.4783,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,27,0,'hunter_bot',0),
+(60195,0,0,0,0,0,16685,0,16685,0,'Noellene','Paladin Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,7,0,33,1,1500,0,2,4608,0,0,0,0,2,10,56.3478,78.5538,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,204,725,0,'paladin_bot',0),
+(60196,0,0,0,0,0,16707,0,16707,0,'Ponaris','Priest Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,7,0,33,1,1500,0,8,4608,0,0,0,0,5,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1096,0,'priest_bot',0),
+(60197,0,0,0,0,0,16222,0,16222,0,'Keilnei','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,1180,2,4608,0,0,0,0,3,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,1619,0,'hunter_bot',0),
+(60198,0,0,0,0,0,16223,0,16223,0,'Valaatu','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,0,8,4608,0,0,0,0,8,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1624,0,'mage_bot',0),
+(60199,0,0,0,0,0,16224,0,16224,0,'Aurelon','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,0,2,4608,0,0,0,0,2,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,1610,0,'paladin_bot',0),
+(60200,0,0,0,0,0,16225,0,16225,0,'Zalduun','Priest Bot','',0,80,80,2,1638,1638,1,1.25,1.14286,1,0,5,18,0,79,1,2000,0,8,4608,0,0,0,0,5,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1626,0,'priest_bot',0),
+(60201,0,0,0,0,0,16226,0,16226,0,'Kore','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,54,0,322,1,2000,0,1,4608,0,0,0,0,1,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1022,1618,0,'warrior_bot',0),
+(60202,0,0,0,0,0,16787,0,16787,0,'Alamma','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,9,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,0,0,'warlock_bot',0),
+(60203,0,0,0,0,0,16800,0,16800,0,'Talionia','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,4608,0,0,0,0,9,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,0,0,'warlock_bot',0),
+(60204,0,0,0,0,0,16831,0,16831,0,'Zanien','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,18,66,0,290,1,2000,1180,2,4608,0,0,0,0,9,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60205,0,0,0,0,0,16781,0,16781,0,'Zaedana','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,4608,0,0,0,0,8,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60206,0,0,0,0,0,16824,0,16824,0,'Quithas','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,8,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60207,0,0,0,0,0,16739,0,16739,0,'Harene','Druid Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,18,366,0,290,1,2000,0,2,4608,0,0,0,0,11,6,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,0,0,'druid_bot',0),
+(60208,0,0,0,0,0,16778,0,16778,0,'Tana','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,1168,2,4608,0,0,0,0,3,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60209,0,0,0,0,0,16816,0,16816,0,'Oninath','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,1000,1084,2,4608,0,0,0,0,3,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60210,0,0,0,0,0,16829,0,16829,0,'Bachi','Paladin Bot','',0,80,80,2,1604,1604,1,0.93,1.14286,1,0,38,68,0,367,1,2000,0,2,4608,0,0,0,0,2,10,8.624,11.858,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,0,0,'paladin_bot',0),
+(60211,0,0,0,0,0,16767,0,16767,0,'Zelanis','Rogue Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,62,80,0,1489,1,2000,0,4,4608,0,0,0,0,4,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1206,0,0,'rogue_bot',0),
+(60212,0,0,0,0,0,16798,0,16798,0,'Elara','Rogue Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,52,77,0,1489,1,2000,0,4,4608,0,0,0,0,4,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1204,0,0,'rogue_bot',0),
+(60213,0,0,0,0,0,16858,0,16858,0,'Shalannius','Druid Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,100,300,0,290,1,2000,0,2,4608,0,0,0,0,11,6,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,0,0,'druid_bot',0),
+(60214,0,0,0,0,0,17434,0,17434,0,'Deremiis','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,1076,2,4608,0,0,0,0,3,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60215,0,0,0,0,0,17247,0,17247,0,'Caedmos','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,8,4608,0,0,0,0,5,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60216,0,0,0,0,0,17225,0,17225,0,'Baatun','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,2,4608,0,0,0,0,2,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,0,0,'paladin_bot',0),
+(60217,0,0,0,0,0,17212,0,17212,0,'Ahonan','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,453,1,2000,0,1,4608,0,0,0,0,1,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,394,0,0,'warrior_bot',0),
+(60218,0,0,0,0,0,17598,0,17598,0,'Firmanvaar','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,200,0,79,1,2000,0,2,4608,0,0,0,0,7,11,28.1739,39.2769,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,1622,0,'shaman_bot',0),
+(60219,0,0,0,0,0,16860,0,16860,0,'Actron','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,1125,2,4608,0,0,0,0,3,11,46.9565,65.4615,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60220,0,0,0,0,0,17213,0,17213,0,'Behomat','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,1,4608,0,0,0,0,1,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1362,0,0,'warrior_bot',0),
+(60221,0,0,0,0,0,17600,0,17600,0,'Nobundo','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,21,200,0,345,1,2000,0,2,4608,0,0,0,0,7,11,346.02,481.06,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60222,0,0,0,0,0,17599,0,17599,0,'Tuluun','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,41,200,0,393,1,2000,0,2,4608,0,0,0,0,7,11,70.4348,98.1923,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,1086,0,'shaman_bot',0),
+(60223,0,0,0,0,0,16914,0,16914,0,'Sulaa','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,200,0,236,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60224,0,0,0,0,0,17215,0,17215,0,'Ruada','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,76,0,643,1,2000,0,1,4608,0,0,0,0,1,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1022,797,0,'warrior_bot',0),
+(60225,0,0,0,0,0,17233,0,17233,0,'Semid','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,0,8,4608,0,0,0,0,8,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1304,0,'mage_bot',0),
+(60226,0,0,0,0,0,17232,0,17232,0,'Guvan','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,26,1,2000,0,8,4608,0,0,0,0,5,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60227,0,0,0,0,0,17234,0,17234,0,'Tullas','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,0,2,4608,0,0,0,0,2,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,204,422,0,'paladin_bot',0),
+(60228,0,0,0,0,0,17488,0,17488,0,'Killac','Hunter bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,2,4608,0,0,0,0,3,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,'hunter_bot',0),
+(60229,0,0,0,0,0,17226,0,17226,0,'Jol','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,2,4608,0,0,0,0,2,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,0,0,'paladin_bot',0),
+(60230,0,0,0,0,0,17248,0,17248,0,'Fallat','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,5,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60231,0,0,0,0,0,17243,0,17243,0,'Harnan','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,4608,0,0,0,0,8,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60232,0,0,0,0,0,17241,0,17241,0,'Bati','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,4608,0,0,0,0,8,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60233,0,0,0,0,0,17792,0,17792,0,'Hobahken','Shaman Bot','',0,80,80,2,1638,1638,1,1.08,1.14286,1,0,18,200,0,290,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60234,0,0,0,0,0,6820,0,6820,0,'Gurrag','Shaman Bot','',0,80,80,2,1638,1638,1,1.08,1.14286,1,0,12,200,0,185,1,2000,0,2,4608,0,0,0,0,7,11,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60235,0,0,0,0,0,19596,0,19596,0,'Auberose','Paladin Bot','',0,80,80,2,1602,1602,1,1.1,1.14286,1,0,176,176,0,367,1,2000,0,2,4608,0,0,0,0,2,10,0,0,100,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,897,1552,0,'paladin_bot',0),
+(60236,0,0,0,0,0,10335,10335,10335,10335,'Afina','Priest Bot','',0,80,80,2,35,35,1,0.95,1.14286,1,0,12,25,0,128,1,10000,0,8,4608,0,0,0,0,5,2,40,53,100,7,1,0,0,0,100,100,100,100,100,100,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,0,0,0,0,0,0,0,0,1,1370,0,0,'priest_bot',0),
+(60237,0,0,0,0,0,1132,0,1132,0,'Voidwalker',NULL,NULL,0,80,80,2,14,14,0,1.1,1.14286,1,0,50,50,0,100,1,2000,0,1,0,0,16,0,0,1,0,23.0384,31.6778,100,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'PetAI',0,1,1.1,0.77,1,0,0,0,0,0,0,0,0,1,0,0,0,'',0),
+(60238,0,0,0,0,0,1105,0,0,0,'Hunter\'s Pet',NULL,NULL,0,80,80,0,14,14,1,1.1,1.14286,1,0,87,117,0,214,1,2000,0,1,0,0,7,0,0,1,0,61,90,21,1,1,0,0,0,0,0,0,0,0,0,5708,0,0,0,0,0,0,0,0,0,0,0,'PetAI',0,3,1,1,1,0,0,0,0,0,0,0,149,1,0,0,0,'',0);
+
+
+-- OPTIONAL UPDATE
+-- Updated values I thought should be closer to the bots values at least for my server.
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=50, mindmg:= 7, maxdmg:= 10,minlevel:=80,maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=0, dynamicflags:=8,  speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1.3, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Druid Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=110, mindmg:= 10, maxdmg:= 12,minlevel:=80,maxlevel:=80, baseattacktime:=2800, rangeattacktime:=1300, minrangedmg:=950, maxrangedmg:=1450, rangedattackpower:=5000, dynamicflags:=8,  speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=0.8, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Hunter Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=20, mindmg:= 4, maxdmg:= 5,minlevel:=80,maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=500, maxrangedmg:=900, rangedattackpower:=50, dynamicflags:=8, speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1.4, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Mage Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=130, mindmg:= 12, maxdmg:= 17,minlevel:=80,maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=80, dynamicflags:=8, speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1.2, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Paladin Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=20, mindmg:= 4, maxdmg:= 5,minlevel:=80,maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=300, maxrangedmg:=600, rangedattackpower:=50, dynamicflags:=8, speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1.7, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Priest Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=80, mindmg:= 7, maxdmg:= 11,minlevel:=80,maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=900, maxrangedmg:=1100, rangedattackpower:=4100, dynamicflags:=8,  speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Rogue Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=60, mindmg:= 6, maxdmg:= 9,minlevel:=80,maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0, maxrangedmg:=0, rangedattackpower:=70, dynamicflags:=8,  speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1.3, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Shaman Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=20, mindmg:= 4, maxdmg:= 6,minlevel:=80,maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=500, maxrangedmg:=900, rangedattackpower:=60, dynamicflags:=8,  speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1.4, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Warlock Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=160, mindmg:= 15, maxdmg:= 21,minlevel:=80,maxlevel:=80, baseattacktime:=3200, rangeattacktime:=2000, minrangedmg:=425, maxrangedmg:=625, rangedattackpower:=250, dynamicflags:=8,  speed_walk:=1.3, speed_run:=1.4286, resistance1:=0, resistance2:=0, resistance3:=0, resistance4:=0, resistance5:=0, resistance6:=0, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=96, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Warrior Bot';
+
+-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		
+-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	
+-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		
+-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	
+-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		
+-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		
+-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	
+-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	
+-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	
+
+-- EQUIPS --
+-- to return old values use this
+-- Warrior
+UPDATE `creature_equip_template` SET `itemEntry1`='27903' WHERE (`entry`='1022');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='43220' WHERE (`entry`='1022');
+UPDATE `creature_equip_template` SET `itemEntry1`='7723',`itemEntry2`='0',`itemEntry3`='0' WHERE (`entry`='110');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='27903',`itemEntry2`='0',`itemEntry3`='0' WHERE (`entry`='110');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='1905',`itemEntry2`='1905',`itemEntry3`='5856' WHERE (`entry`='110');
+UPDATE `creature_equip_template` SET `itemEntry1`='28367',`itemEntry2`='0' WHERE (`entry`='394');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='27903',`itemEntry2`='0' WHERE (`entry`='394');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='5305',`itemEntry2`='12980' WHERE (`entry`='394');
+UPDATE `creature_template` SET `equipment_id`='394' WHERE (`entry`='60055');
\ No newline at end of file
diff --git a/sql/Bots/world.script_bot_giver.sql b/sql/Bots/world.script_bot_giver.sql
new file mode 100644
index 0000000..ab5066b
--- /dev/null
+++ b/sql/Bots/world.script_bot_giver.sql
@@ -0,0 +1,7 @@
+
+DELETE FROM `creature_template` WHERE `entry`='60000';
+INSERT INTO creature_template
+  (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction_A, faction_H, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, equipment_id, mechanic_immune_mask, flags_extra, ScriptName, WDBVerified)
+VALUES
+  (60000, 0, 0, 0, 0, 0, 27541, 0, 27541, 0, "Lagretta", "Bot Officer", "", 0, 83, 83, 2, 35, 35, 1, "1.4", "1,14286", "0.4", 4, 228, 298, 0, 500, 1, 1500, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", 0, 3, "4.8", 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, "script_bot_giver", 12340);
+
diff --git a/src/server/game/AI/Bots/PlayerbotAI.cpp b/src/server/game/AI/Bots/PlayerbotAI.cpp
new file mode 100644
index 0000000..74ab509
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotAI.cpp
@@ -0,0 +1,4450 @@
+#include "Common.h"
+#include "Database/DatabaseEnv.h"
+#include "DBCStores.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "WorldPacket.h"
+#include "Spell.h"
+#include "Unit.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+#include "SharedDefines.h"
+#include "GossipDef.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "Group.h"
+#include <ctime>
+
+
+
+/*
+* Packets often compress the GUID (global unique identifier)
+* This function extracts the guid from the packet and decompresses it.
+* The first word (8 bits) in the packet represents how many words in the following packet(s) are part of
+* the guid and what weight they hold. I call it the mask. For example) if mask is 01001001,
+* there will be only 3 words. The first word is shifted to the left 0 times,
+* the second is shifted 3 times, and the third is shifted 6.
+*/
+uint64 extractGuid(WorldPacket &packet)
+{
+    uint8 mask; packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while(true)
+    {
+        if(mask & testMask)
+        {
+            uint8 word; packet >> word;
+            guid += (word << bit);
+        }
+        if(bit == 7) break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+//ChatHandler already implements some useful commands the master can call on bots
+//These commands are protected inside the ChatHandler class so this class provides access to the commands
+//we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+    public:
+        explicit PlayerbotChatHandler(Player *pMasterPlayer) : ChatHandler(pMasterPlayer){}
+
+        bool revive(const Player &botPlayer){ return HandleReviveCommand(botPlayer.GetName()); }
+        bool teleport(const Player &botPlayer){ return HandleSummonCommand(botPlayer.GetName()); }
+        bool teleport(Player &botPlayer, const WorldLocation &loc){ return botPlayer.TeleportTo(loc,TELE_TO_GM_MODE); }
+        bool uninvite(const char *str){ return HandlePlayerbotCommand(str); }
+        void sysmessage(const char *str){ SendSysMessage(str); }
+        bool acceptQuest(const char *str){ return HandleQuestAdd(str); }
+        bool abandonQuest(const char *str) { return HandleQuestRemove(str); }
+};
+
+PlayerbotAI::PlayerbotAI(Player *const master, Player *const bot): m_master(master), m_bot(bot),
+m_ignoreAIUpdatesUntilTime(0), m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+m_TimeDoneEating(0), m_TimeDoneDrinking(0), m_CurrentlyCastingSpellId(0), m_IsFollowingMaster(true),
+m_spellIdCommand(0), m_targetGuidCommand(0), m_classAI(0), isLooting(false), m_TimeRessurect(0),
+m_FeastSpamTimer(0)
+{
+
+    //If the player have a group, it's possible to add the bot.
+    if(master->GetGroup())
+    {
+        Group *m_group = master->GetGroup();
+        bool inGroup = false;
+        Group::MemberSlotList members = m_group->GetMemberSlots();
+
+        if(!m_group->IsFull() ||
+            m_group->IsMember(bot->GetGUID()) )
+        {
+            //check that bot is not already in the group, ie from a server crash
+            Group::MemberSlotList const &groupSlot = master->GetGroup()->GetMemberSlots();
+            for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *tPlayer = master->GetObjPlayer(itr->guid);
+                if(itr->guid == bot->GetGUID()) inGroup = true;
+            }
+            if(!inGroup) m_group->AddMember(bot);
+        } else {
+            //group is full so can't add bot
+            bot->Say("Group is full!", LANG_UNIVERSAL);
+        }
+    } else {
+        Group *m_group = new Group;
+       if(!m_group->Create(master))
+        {
+            return;
+        }
+        sGroupMgr->AddGroup(m_group);
+        if(!m_group->IsFull()) m_group->AddMember(bot);
+    }
+
+    //get class specific AI
+    switch(m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotPriestAI(master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotWarriorAI(master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotShamanAI(master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotRogueAI(master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotPaladinAI(master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotMageAI(master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotDruidAI(master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotWarlockAI(master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotHunterAI(master, m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            m_classAI = (PlayerbotClassAI *)new PlayerbotDeathKnightAI(master, m_bot, this);
+            break;
+    }
+
+    //load config variables
+    m_followDistanceMin = ConfigMgr::GetFloatDefault("Bot.FollowDistanceMin", 0.5f);
+    m_followDistanceMax = ConfigMgr::GetFloatDefault("Bot.FollowDistanceMax", 3.0f);
+    m_playerBotsFly = ConfigMgr::GetIntDefault("Bot.PlayerBotsFly", 0);
+
+    SetQuestNeedItems();
+    m_needEmblemList.clear();
+    m_needEmblemList[29434] = 200; // Badge of Justice
+    m_needEmblemList[40752] = 200; // Emblem of Heroism
+    m_needEmblemList[40753] = 200; // Emblem of Valor
+    m_needEmblemList[45624] = 200; // Emblem of Conquest
+    m_needEmblemList[47241] = 200; // Emblem of Triumph
+    m_needEmblemList[49426] = 200; // Emblem of Frost
+    m_needEmblemList[44990] = 200; // Champion's Seal
+    HandleCommand("help", *m_master);
+}
+PlayerbotAI::~PlayerbotAI(){}
+
+//finds spell ID for matching substring args
+//in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char *args, bool master) const
+{
+    if(!*args) return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if(!Utf8toWStr(namepart, wnamepart)) return 0;
+
+    //converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if(master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || sSpellMgr->GetSpellInfo(spellId)->IsPassive()) continue;
+
+        const SpellInfo *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if(!pSpellInfo) continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty() || !Utf8FitTo(name, wnamepart)) continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <=  0) ? true : false;
+
+        //if we already found a spell
+        bool useThisSpell = true;
+        if(foundSpellId > 0)
+        {
+            if(isExactMatch && !foundExactMatch){}
+            else if(usesNoReagents && !foundMatchUsesNoReagents){}
+            else if(spellId > foundSpellId){}
+            else useThisSpell = false;
+        }
+        if(useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::getSpellIdExact(const char *args, bool includePassive, bool master)
+{
+    if(!*args) return 0;
+    std::string namepart = args;
+    int loc = 0;
+    if(master) loc = m_master->GetSession()->GetSessionDbcLocale();
+    else loc = m_bot->GetSession()->GetSessionDbcLocale();
+    uint32 foundSpellId = (uint32) 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || ( !includePassive && sSpellMgr->GetSpellInfo(spellId)->IsPassive())) continue;
+        const SpellInfo *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if(!pSpellInfo) continue;
+        if(pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL) continue; //This is a learn spell
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if(name.empty()) continue;
+        if(strcmp(name.c_str(),namepart.c_str())) continue;
+        if(pSpellInfo->Reagent[0] <=  0 && !foundMatchUsesNoReagents){ foundSpellId = spellId; foundMatchUsesNoReagents = true; }
+        else if(spellId > foundSpellId) { foundSpellId = spellId; }
+    }
+    //sLog->outDebug(LOG_FILTER_NETWORKIO, "PBot Class %u - Found in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str());
+    if (foundSpellId > 70000) { sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Weird Spell in Search - [%u/%s]", m_bot->getClass(), foundSpellId, namepart.c_str()); }
+    return foundSpellId;
+}
+
+// finds quest ID for matching substring args
+uint32 PlayerbotAI::getQuestId(const char* args, bool remove) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart,wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+    uint32 questId = 0;
+    uint32 foundQuestId = 0;
+    bool foundExactMatch = false;
+    if (!m_questsSeen.empty() && !remove)
+    {
+        for (BotQuestsSeen::const_iterator iter = m_questsSeen.begin(); iter != m_questsSeen.end(); ++iter)
+        {
+            uint32 questId = iter->first;
+            const std::string name = iter->second;
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    else if (remove)
+    {
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo) continue;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty() || !Utf8FitTo(name, wnamepart))
+                continue;
+
+            bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+            // if we already found a quest
+            bool useThisQuest = true;
+            if (foundQuestId > 0)
+            {
+                if (isExactMatch && ! foundExactMatch)
+                {
+                }
+                else if (questId > foundQuestId)
+                {
+                }
+                else
+                    useThisQuest = false;
+            }
+            if (useThisQuest)
+            {
+                foundQuestId = questId;
+                foundExactMatch = isExactMatch;
+            }
+        }
+    }
+    return foundQuestId;
+}
+
+
+/*
+* Send a list of equipment that is in bot's inventor that is currently unequipped.
+* This is called when the master is inspecting the bot.
+*/
+void PlayerbotAI::SendNotEquipList(Player &player)
+{
+    //find all unequipped items and put them in
+    //a vector of dynamically created lists where the vector index is from 0-18
+    //and the list contains Item *that can be equipped to that slot
+    //Note: each dynamically created list in the vector must be deleted at end
+    //so NO EARLY RETURNS!
+    //see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    //is assigned to. (The first is EQUIPMENT_SLOT_HEAD = 0, and last is EQUIPMENT_SLOT_TABARD = 18)
+
+    std::list<Item *> *equip[19];
+    for(uint8 i = 0; i < 19; ++i) equip[i] = NULL;
+
+    //list out items in main backpack
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if(msg != EQUIP_ERR_OK) continue;
+
+        //the dest looks like it includes the old loc in the 8 higher bits
+        //so casting it to a uint8 strips them
+        uint8 equipSlot = uint8(dest);
+        if(!(equipSlot >= 0 && equipSlot < 19)) continue;
+
+        //create a list if one doesn't already exist
+        if(equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item *>;
+
+        std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(!pItem)
+                    continue;
+
+                uint16 equipSlot;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, equipSlot, pItem, !pItem->IsBag());
+                if(msg != EQUIP_ERR_OK)
+                    continue;
+                if(!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                //create a list if one doesn't already exist
+                if(equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item *>;
+
+                std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+        }
+    }
+
+    TellMaster("Here's all the items in my inventory that I can equip:");
+    ChatHandler ch(m_master);
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+    "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+    "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged", "tabard" };
+
+    //now send client all items that can be equipped by slot
+    for(uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if(equip[equipSlot] == NULL) continue;
+        std::list<Item *> *itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for(std::list<Item *>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            const ItemTemplate *const pItemTemplate = (*it)->GetTemplate();
+            out << " |cffffffff|Hitem:" << pItemTemplate->ItemId
+            << ":0:0:0:0:0:0:0" << "|h[" << pItemTemplate->Name1
+            << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+        if(itemListForEqSlot!=itemListForEqSlot) 
+        {
+            delete itemListForEqSlot; //delete list of Item *
+            break;
+        }
+    }
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    /* Testing
+    const char *oc = LookupOpcodeName(packet.GetOpcode());
+
+    std::ostringstream out;
+    out << "HandleMasterOutgoingPacket: " << oc;
+    //sLog->outError(out.str().c_str());
+    // Testing*/
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession)
+{
+    switch(packet.GetOpcode())
+    {
+        /*case CMSG_SET_SELECTION:
+        {
+            //sLog->outError("cmsg_set_selection");
+            return;
+        }*/
+
+        /*case CMSG_INSPECT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 guid; p >> guid;
+            Player *const bot = masterSession.GetPlayerBot(guid);
+            if(!bot) return;
+            bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+            //sLog->outBasic("PlayerBotAI: received CMSG_INSPECT");
+        }*/
+
+        //If master inspects one of his bots, give the master useful info in chat window
+        //such as inventory that can be equipped
+
+        case CMSG_PUSHQUESTTOPARTY:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 quest; p >> quest;
+            Player *pPlayer = masterSession.GetPlayer();
+            Quest const *pQuest = sObjectMgr->GetQuestTemplate(quest);
+            //sLog->outBasic("PlayerBotAI: received CMSG_PUSHQUESTTOPARTY");
+
+            if(pQuest)
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player *const bot = it->second;
+                    uint64 guid = it->first;
+                    uint32 unk1 = 0;
+
+                    WorldPacket data(MSG_QUEST_PUSH_RESULT, (8+4+4));
+                    //data << guid;
+                    data << pPlayer->GetGUID();
+                    data << quest;
+                    data << unk1;
+
+                    bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(data);
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+                }
+            return;
+        }
+
+        //handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 emoteNum;
+//            uint64 guid;
+            p >> emoteNum;
+
+            switch(emoteNum)
+            {
+                case TEXT_EMOTE_BONK:
+                {
+                    Player *const pPlayer = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(!pPlayer || !pPlayer->GetPlayerbotAI()) return;
+                    PlayerbotAI *const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(masterSession.GetPlayer());
+
+                    {
+                    std::ostringstream out;
+                    out << "clock(): " << (getMSTime())
+                    << " m_ignoreAIUpdatesUntilTime: " << (pBot->m_ignoreAIUpdatesUntilTime);
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                    << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "m_IsFollowingMaster: " << pBot->m_IsFollowingMaster;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsBeingTeleported(): " << pBot->m_bot->IsBeingTeleported();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    bool tradeActive = (pBot->m_bot->GetTrader()) ? true : false;
+                    out << "tradeActive: " << tradeActive;
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsCharmed(): " << pBot->m_bot->isCharmed();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "IsInCombat(): " << pBot->m_bot->isInCombat();
+                    ch.SendSysMessage(out.str().c_str());
+                    }{
+                    std::ostringstream out;
+                    out << "isLooting: " << pBot->isLooting;
+                    ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                    std::ostringstream out;
+                    out << "isPulling: " << pBot->GetClassAI()->isPulling();
+                    ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                }
+
+                case TEXT_EMOTE_EAT:
+                case TEXT_EMOTE_DRINK:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot) bot->GetPlayerbotAI()->Stay();
+                    else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Feast();
+                        }
+                    }
+                    return;
+                }
+
+                //emote to stay
+                case TEXT_EMOTE_STAND:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot) bot->GetPlayerbotAI()->Stay();
+                    else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Stay();
+                        }
+                    }
+                    return;
+                }
+
+                //324 is the followme emote (not defined in enum)
+                //if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXT_EMOTE_WAVE:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot)
+                    {
+                        bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                        bot->GetPlayerbotAI()->SetLooting(false);
+                    } else {
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                            bot->GetPlayerbotAI()->SetLooting(false);
+                        }
+                    }
+                    return;
+                }
+
+                case TEXT_EMOTE_SALUTE:
+                {
+                    Player *const bot = masterSession.GetPlayerBot(masterSession.GetPlayer()->GetSelection());
+                    if(bot)
+                        bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+                    //sLog->outBasic("PlayerBotAI: received CMSG_INSPECT");
+                }
+
+                /*case TEXT_EMOTE_TRAIN:
+                {
+                    //WorldPacket p(packet);
+                    //p.rpos(0); //reset reader
+                    uint32 quest; p >> quest;
+                    Player *pPlayer = masterSession.GetPlayer();
+                    Quest const *pQuest = sObjectMgr->GetQuestTemplate(quest);
+                    //sLog->outBasic("PlayerBotAI: received CMSG_PUSHQUESTTOPARTY");
+
+                    if(pQuest)
+                        for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player *const bot = it->second;
+                            uint64 guid = it->first;
+                            uint32 unk1 = 0;
+
+                            WorldPacket data(MSG_QUEST_PUSH_RESULT, (8+4+4));
+                            //data << guid;
+                            data << pPlayer->GetGUID();
+                            data << quest;
+                            data << unk1;
+
+                            bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(data);
+                            bot->GetPlayerbotAI()->SetQuestNeedItems();
+                        }
+                    return;
+                }*/
+                default: return;
+            }
+        } //end CMSG_TEXT_EMOTE
+
+        case CMSG_GROUP_UNINVITE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            std::string member; p >> member;
+            p.clear();
+
+            WorldPacket data(CMSG_GROUP_UNINVITE, 1);
+            PlayerbotChatHandler ch(masterSession.GetPlayer());
+            std::ostringstream out;
+            out << "remove " << member;
+            ch.uninvite(out.str().c_str());
+            //sLog->outBasic("PlayerBotAI: received CMSG_GROUP_UNINVITE");
+            return;
+        }
+
+        case CMSG_REPAIR_ITEM:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+            if(!pNpc)
+                return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if(!bot->IsInMap((WorldObject*) pNpc))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to repair items!");
+                    continue;
+                } else {
+                    bot->GetPlayerbotAI()->TellMaster("Repairing my items.");
+                    bot->DurabilityRepairAll(false, 0.0, false);
+                }
+
+            }
+            //sLog->outBasic("PlayerBotAI: received CMSG_REPAIR_ITEM");
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket incP(packet);
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+
+                Player *const bot = it->second;
+                if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                    continue;
+                } else {
+                    WorldPacket p;
+                   // p << guid << _totalcost << node_count;
+                    bot->GetPlayerbotAI()->Stay();  // clear any movement
+                    incP.rpos(0);
+                    bot->GetSession()->HandleActivateTaxiExpressOpcode(incP);
+                }
+
+            }
+            //sLog->outBasic("PlayerBotAI: received CMSG_ACTIVATETAXIEXPRESS");
+            return;
+        }
+
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket incP(packet);
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if (!bot->GetPlayerbotAI()->CanBotsFly()) return;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to fly!");
+                    continue;
+                } else {
+                    WorldPacket p;
+                   // p << guid << nodes[0] << nodes[1];
+                    bot->GetPlayerbotAI()->Stay();  // clear any movement
+                    incP.rpos(0);
+                    bot->GetSession()->HandleActivateTaxiOpcode(incP);
+                }
+
+            }
+            //sLog->outBasic("PlayerBotAI: received CMSG_ACTIVATETAXI");
+            return;
+        }
+
+        // when landing from a flight path
+        case CMSG_MOVE_SPLINE_DONE:
+        {
+            WorldPacket p(packet);
+            //p.rpos(0);  // reset reader
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+
+                if(!bot->IsInMap((WorldObject*) masterSession.GetPlayer()))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to land!");
+                    continue;
+                } else {
+                    p.rpos(0);  // reset reader
+                    p.appendPackGUID(bot->GetGUID());
+                    bot->GetSession()->HandleMoveSplineDoneOpcode(p);
+                    uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+                    uint32 mountDisplayId = sObjectMgr->GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+                    if (mountDisplayId==0) {
+                        bot->CleanupAfterTaxiFlight();
+                        bot->GetPlayerbotAI()->Follow(*masterSession.GetPlayer());
+                    }
+                }
+
+            }
+            //sLog->outBasic("PlayerBotAI: received CMSG_MOVE_SPLINE_DONE");
+            return;
+        }
+        case CMSG_LOOT:
+            {
+                //sLog->outBasic("PlayerBotAI: received CMSG_LOOT");
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 cGUID;
+                p >> cGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                Creature *cToLoot = m_master->GetMap()->GetCreature(cGUID);
+                if (!cToLoot)
+                    return;
+                /* for all master's bots */
+                for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                    it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    if (!bot->IsInMap((WorldObject*) cToLoot))
+                    {
+                        bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                        continue;
+                    }
+                    else
+                    {
+                        //bot->GetPlayerbotAI()->TellMaster("Checking for needed Quest Items.");
+                        bot->GetPlayerbotAI()->AddLootGUID(cGUID);
+                        bot->GetPlayerbotAI()->DoLoot();
+                    }
+                }
+                return;
+
+            }
+            break;
+
+        case CMSG_GAMEOBJ_USE:
+            {
+                //sLog->outBasic("PlayerBotAI: received CMSG_GAMEOBJ_USE");
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+               for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+//sLog->outError ("gameobject type = %u", obj->GetGoType());
+                    if( obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER )
+                    {
+                        bot->GetPlayerbotAI()->TurnInQuests( obj );
+                    }
+                    // add other go types here, i.e.:
+                    // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                }
+            }
+            break;
+
+        case CMSG_GAMEOBJ_REPORT_USE:
+            {
+                //sLog->outBasic("PlayerBotAI: received CMSG_GAMEOBJ_REPORT_USE");
+                WorldPacket p(packet);
+                p.rpos(0); // reset reader
+                uint64 objGUID;
+                p >> objGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                GameObject *obj = m_master->GetMap()->GetGameObject( objGUID );
+                if( !obj )
+                    return;
+
+                //Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+                //if (!pNpc) return;
+            /* For all master's bots */
+            for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot->IsInMap((WorldObject*) obj))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to check for needed Quest Items!");
+                    continue;
+                }
+                else
+                {
+                    //bot->GetPlayerbotAI()->TellMaster("Checking for needed Quest Items.");
+                    bot->GetPlayerbotAI()->AddLootGUID(objGUID);
+                    bot->GetPlayerbotAI()->DoLoot();
+                }
+            }
+            return;
+        }
+
+        //if master talks to an NPC
+        case CMSG_GOSSIP_HELLO:
+        case CMSG_QUESTGIVER_HELLO:
+            {
+                WorldPacket p(packet);
+                p.rpos(0); //reset reader
+                uint64 npcGUID;
+                p >> npcGUID;
+
+                Player *m_master = masterSession.GetPlayer();
+                //Object *const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT | TYPEMASK_GAMEOBJECT);
+                WorldObject* pNpc = ObjectAccessor::GetWorldObject( *m_master, npcGUID );
+                if(!pNpc)
+                    return;
+
+                // if its a flight master
+                if(pNpc->HasFlag( UNIT_NPC_FLAGS, UNIT_NPC_FLAG_FLIGHTMASTER ))
+                {
+                    for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                    {
+                        Player *const bot = it->second;
+                        if (bot->GetSession()->SendLearnNewTaxiNode((Creature*)pNpc))
+                            bot->GetPlayerbotAI()->TellMaster("Learned a new path.");
+                    }
+                    return;
+                }
+
+                // for all master's bots
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    bot->GetPlayerbotAI()->TurnInQuests( pNpc );
+                    bot->GetPlayerbotAI()->SetQuestNeedItems();
+
+                    bot->TalkedToCreature(pNpc->GetEntry(), pNpc->GetGUID());
+                }
+
+                return;
+        }
+
+        case CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY:
+        {
+            //sLog->outBasic("PlayerBotAI: received CMSG_QUESTGIVER_STATUS_MULTIPLE_QUERY");
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+           if (!masterSession.GetPlayer()->GetSelection()) return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                p.rpos(0); // reset reader
+                bot->GetSession()->HandleQuestgiverStatusMultipleQuery(p);
+            }
+
+
+        return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            //sLog->outBasic("PlayerBotAI: received CMSG_QUESTGIVER_ACCEPT_QUEST");
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint64 guid;
+            uint32 quest;
+            p >> guid >> quest;
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+            if (qInfo)
+            {
+                //for all master's bots
+                for(PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin(); it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                    else if (! bot->CanTakeQuest(qInfo, false))
+                    {
+                        if (! bot->SatisfyQuestStatus(qInfo, false))
+                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                        else
+                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                    }
+                    else if (! bot->SatisfyQuestLog(false))
+                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                    else if (! bot->CanAddQuest(qInfo, false))
+                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                    else
+                    {
+                        p.rpos(0); // reset reader
+                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+                        bot->GetPlayerbotAI()->SetQuestNeedItems();
+                    }
+                }
+            }
+
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+            {
+                //sLog->outBasic("PlayerBotAI: received CMSG_LIST_INVENTORY");
+                uint64 npcGUID;
+                WorldPacket p1(packet);
+                p1.rpos(0); /* reset reader */
+                p1 >> npcGUID;
+
+                Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*masterSession.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+                if (!pNpc) return;
+
+                /* for all master's bots */
+                for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                    it != masterSession.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+                    if (!bot->IsInMap((WorldObject*) pNpc))
+                    {
+                        bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                        continue;
+                    }
+                    else
+                    {
+                        uint32 TotalCost = 0;
+                        uint32 TotalSold = 0;
+                        std::ostringstream report;
+                        std::ostringstream canSell;
+                        canSell << "Items that are not trash and can be sold: ";
+                        // list out items in main backpack
+                        for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                        {
+                            Item* const item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                            if (!item)
+                                continue;
+
+                            if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR)
+                            {
+                                int32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+                                bot->ModifyMoney(cost);
+                                bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+                                bot->AddItemToBuyBackSlot(item);
+
+                                TotalSold = TotalSold + 1;
+                                TotalCost = TotalCost + cost;
+
+                                report << "Sold " << item->GetCount() << "x";
+                                report << " |cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r";
+                                report << " for ";
+
+                                uint32 gold = uint32(cost / 10000);
+                                cost -= (gold * 10000);
+                                uint32 silver = uint32(cost / 100);
+                                cost -= (silver * 100);
+
+                                if (gold > 0)
+                                {
+                                    report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                                }
+                                if (silver > 0)
+                                {
+                                    report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                                }
+                                report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                            }
+                            else if (item->GetTemplate()->SellPrice > 0)
+                            {
+                                canSell << "|cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r ";
+                            }
+                        }
+
+                        for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END;++bag)
+                        {
+                            const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                            if (pBag)
+                            {
+                                for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                                {
+                                    Item* const item = bot->GetItemByPos(bag, slot);
+                                    if (!item)
+                                        continue;
+
+                                    if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR)
+                                    {
+                                        int32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+                                        bot->ModifyMoney(cost);
+                                        bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+                                        bot->AddItemToBuyBackSlot(item);
+
+                                        TotalSold = TotalSold + 1;
+                                        TotalCost = TotalCost + cost;
+
+                                        report << "Sold " << item->GetCount() << "x";
+                                        report << " |cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r";
+                                        report << " for ";
+
+                                        uint32 gold = uint32(cost / 10000);
+                                        cost -= (gold * 10000);
+                                        uint32 silver = uint32(cost / 100);
+                                        cost -= (silver * 100);
+                                        if (gold > 0)
+                                        {
+                                            report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                                        }
+                                        if (silver > 0)
+                                        {
+                                            report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                                        }
+                                        report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                                    }
+                                    else if (item->GetTemplate()->SellPrice > 0)
+                                    {
+                                        canSell << "|cffffffff|Hitem:" << item->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << item->GetTemplate()->Name1 << "]|h|r ";
+                                    }
+                                }
+                            }
+                        }
+                        if (TotalSold > 0) {
+                            report << "Sold total " << TotalSold << " item(s) for ";
+                            uint32 gold = uint32(TotalCost / 10000);
+                            TotalCost -= (gold * 10000);
+                            uint32 silver = uint32(TotalCost / 100);
+                            TotalCost -= (silver * 100);
+                            if (gold > 0)
+                            {
+                                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                            }
+                            if (silver > 0)
+                            {
+                                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                            }
+                            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t";
+                            bot->GetPlayerbotAI()->TellMaster(report.str());
+                        }
+                        bot->GetPlayerbotAI()->TellMaster(canSell.str());
+                    }
+                }
+                return;
+
+            }
+
+        case CMSG_AREATRIGGER:
+        {
+            //sLog->outBasic("PlayerBotAI: received CMSG_AREATRIGGER");
+            uint32 Trigger_ID;
+            WorldPacket p1(packet);
+            p1.rpos(0); /* reset reader */
+            p1 >> Trigger_ID;
+
+            /* for all master's bots */
+            for (PlayerBotMap::const_iterator it = masterSession.GetPlayerBotsBegin();
+                it != masterSession.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                uint32 quest_id = sObjectMgr->GetQuestForAreaTrigger( Trigger_ID );
+                // The conditions that intentionally left unchecked are:
+                // Bot is alive or not
+                // Bot is in the trigger area or not
+                if( quest_id && bot->IsActiveQuest(quest_id) )
+                {
+                    Quest const* pQuest = sObjectMgr->GetQuestTemplate(quest_id);
+                    if( pQuest )
+                    {
+                        if(bot->GetQuestStatus(quest_id) == QUEST_STATUS_INCOMPLETE)
+                        {
+                            bot->AreaExploredOrEventHappens( quest_id );
+                            bot->GetPlayerbotAI()->TellMaster("Quest area explored");
+                        }
+                    }
+                }
+
+                if(sObjectMgr->IsTavernAreaTrigger(Trigger_ID))
+                {
+                    // set resting flag we are in the inn
+                    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_RESTING);
+                    bot->InnEnter(time(NULL), bot->GetMapId() , bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ());
+                    bot->SetRestType(REST_TYPE_IN_TAVERN);
+
+                    if(sWorld->IsFFAPvPRealm())
+                        bot->RemoveByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+                }
+            }
+            return;
+        }
+
+
+        default:
+        {
+            /*const char *oc = LookupOpcodeName(packet.GetOpcode());
+            ChatHandler ch(masterSession.GetPlayer());
+            ch.SendSysMessage(oc);
+
+            std::ostringstream out;
+            out << "HandleMasterIncomingPacket: " << oc;
+            //sLog->outError(out.str().c_str());
+
+            return;*/
+        }
+
+    }
+}
+
+//handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket &packet)
+{
+    switch(packet.GetOpcode())
+    {
+         case SMSG_TRADE_STATUS_EXTENDED:
+         {
+             //m_bot->GetSession()->SendTradeStatus(TRADE_STATUS_TRADE_ACCEPT);
+             return;
+         }
+
+
+        case SMSG_DUEL_WINNER:
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+
+        case SMSG_DUEL_COMPLETE:
+            SetIgnoreUpdateTime(4);
+            m_combatOrder = ORDERS_NONE;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+
+        case SMSG_DUEL_OUTOFBOUNDS:
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+
+        case SMSG_DUEL_REQUESTED:
+        {
+            SetIgnoreUpdateTime(0);
+            WorldPacket p(packet);
+            uint64 flagGuid; p >> flagGuid;
+            uint64 playerGuid; p >> playerGuid;
+            Player *const pPlayer = ObjectAccessor::FindPlayer(playerGuid);
+            if(canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket *const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+                //follow target in casting range
+                float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+                float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); //Using urand to get a random float is stupid. It takes uint32, not float.
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(playerGuid);
+                SetIgnoreUpdateTime(4);
+                m_combatOrder = ORDERS_KILL;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+            TellMaster("I can't use that.");
+            return;
+
+        case SMSG_SPELL_DELAYED:
+        {
+            //sLog->outDebug(LOG_FILTER_NETWORKIO, "Bot [%u] SMSG_SPELL_DELAYED",m_bot->GetGUIDLow());
+            WorldPacket p(packet);
+            //uint64 casterGuid = extractGuid(p); //somehow the caster guid is corrupt
+            //if(casterGuid != m_bot->GetGUID()) return;
+            //uint32 delayTime; p >> delayTime;
+            //sLog->outDebug(LOG_FILTER_NETWORKIO, "Bot [%u] caster [%u] Spell Delayed [%u]",m_bot->GetGUIDLow(), casterGuid, delayTime);
+            //m_ignoreAIUpdatesUntilTime +=  ((((float)delayTime) / 1000.0f ) + 0.1f) * CLOCKS_PER_SEC;
+            if(m_CurrentlyCastingSpellId > 0)
+            {
+                m_ignoreAIUpdatesUntilTime += 0.5f * 1000; //Until this is handled correctly, assume, delay is the default 0.5 secs
+            }
+            return;
+        }
+
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint64 casterGuid = extractGuid(p);
+            if(casterGuid != m_bot->GetGUID()) return;
+            uint32 spellId; p >> spellId;
+            if(m_CurrentlyCastingSpellId == spellId)
+            {
+                SetIgnoreUpdateTime(1);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        //if a change in speed was detected for the master
+        //make sure we have the same mount status
+        case SMSG_FORCE_RUN_SPEED_CHANGE:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            //uint64 guid; p >> guid;
+            Player *tPlayer = ObjectAccessor::FindPlayer(guid);
+            if(!tPlayer) return;
+            if (!m_master || !m_bot) return;
+            if(guid == m_bot->GetGUID()) return;
+            if(guid == m_master->GetGUID()) {
+                m_bot->GetPlayerbotAI()->UseMount();
+                SetIgnoreUpdateTime(2);
+            }
+            return;
+        }
+
+        //handle flying acknowledgement
+        case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if(guid != m_bot->GetGUID()) return;
+            m_bot->AddUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) + 0.1f, true);
+            return;
+        }
+
+        //handle dismount flying acknowledgement
+        case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid = extractGuid(p);
+            if(guid != m_bot->GetGUID()) return;
+            m_bot->RemoveUnitMovementFlag(MOVEMENTFLAG_FLYING);
+            //SetSpeed(MOVE_RUN, m_master->GetSpeedRate(MOVE_RUN), true);
+            return;
+        }
+
+        //If the leader role was given to the bot automatically give it to the master
+        //if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name; p >> name;
+            if(m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if(m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+                {
+                    p.resize(8);
+                    p << m_master->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                } else {
+                    p.clear(); //not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+                }
+            }
+            return;
+        }
+
+        //If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation; p >> operation;
+            std::string member; p >> member;
+            uint32 result; p >> result;
+            p.clear();
+            if(operation == PARTY_OP_LEAVE && member == m_master->GetName()) m_bot->GetSession()->HandleGroupDisbandOpcode(p); //packet not used
+            return;
+        }
+
+        //Automatically accept rez. Useful when bot dies, and a druid does a battle rez.
+        case SMSG_RESURRECT_REQUEST:
+        {
+            WorldPacket p, incP(packet);
+            uint8 status = 1;
+            uint64 rezzer; incP >> rezzer;
+            p << rezzer;
+            p << status;
+            m_bot->GetPlayerbotAI()->SetLooting(false);
+            m_bot->GetSession()->HandleResurrectResponseOpcode(p);
+            m_IsFollowingMaster = true;
+            m_TimeRessurect = 0;
+            return;
+        }
+
+        //Handle Group invites (auto accept if master is in group, otherwise decline & send message)
+        case SMSG_GROUP_INVITE:
+        {
+            if(m_bot->GetGroupInvite())
+            {
+                const Group *const grp = m_bot->GetGroupInvite();
+                if(!grp) return;
+                Player *const inviter = ObjectAccessor::FindPlayer(grp->GetLeaderGUID());
+                if(!inviter) return;
+                WorldPacket p;
+                if(!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += m_master->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); //packet not used
+                } else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p); //packet not used
+            }
+            return;
+        }
+
+        //Handle when another player opens the trade window with the bot
+        //also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if(m_bot->GetTrader() == NULL) break;
+            WorldPacket p(packet);
+            uint32 status; p >> status;
+            p.clear();
+
+            if(status == 4) { // TRADE_STATUS_TRADE_ACCEPT
+                if (!m_bot->GetTradeData()->IsAccepted() || !m_bot->GetTrader()->GetTradeData()->IsAccepted()) {
+                    m_bot->GetSession()->HandleAcceptTradeOpcode(p); //packet not used
+                }
+
+            } else if(status == 1) // TRADE_STATUS_BEGIN_TRADE
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); //packet not used
+
+                //if(!canObeyCommandFrom(*(m_bot->GetTrader())))
+                //{
+                    //SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    //return;
+                //}
+
+                //list out items available for trade
+                std::ostringstream out;
+
+                //list out items in main backpack
+                for(uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if(pItem && pItem->CanBeTraded())
+                    {
+                        const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                        std::string name = pItemTemplate->Name1;
+
+                        out << " |cffffffff|Hitem:" << pItemTemplate->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+                        if(pItem->GetCount() > 1)
+                            out << "x" << pItem->GetCount() << ' ';
+                    }
+                }
+                //list out items in other removable backpacks
+                for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if(pBag)
+                    {
+                        for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                            if(pItem && pItem->CanBeTraded())
+                            {
+                                const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                                const std::string name = pItemTemplate->Name1;
+
+                                //item link format: http://www.wowwiki.com/ItemString
+                                //itemId, enchantId, jewelId1, jewelId2, jewelId3, jewelId4, suffixId, uniqueId
+                                out << " |cffffffff|Hitem:" << pItemTemplate->ItemId << ":0:0:0:0:0:0:0" << "|h[" << name << "]|h|r";
+                                if(pItem->GetCount() > 1)
+                                    out << "x" << pItem->GetCount() << ' ';
+                            }
+                        }
+                    }
+                }
+
+                //calculate how much money bot has
+                uint32 copper = m_bot->GetMoney();
+                uint32 gold = uint32(copper / 10000);
+                copper -= (gold * 10000);
+                uint32 silver = uint32(copper / 100);
+                copper -= (silver * 100);
+
+                //send bot the message
+                std::ostringstream whisper;
+                whisper << "I have |cff00ff00" << gold
+                << "|r|cfffffc00g|r|cff00ff00" << silver
+                << "|r|cffcdcdcds|r|cff00ff00" << copper
+                << "|r|cffffd333c|r" << " and the following items:";
+                m_bot->GetPlayerbotAI()->SendWhisper(whisper.str(), *(m_bot->GetTrader()));
+                ChatHandler ch(m_bot->GetTrader());
+                ch.SendSysMessage(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+            uint64 castItemGuid = extractGuid(p);
+            uint64 casterGuid = extractGuid(p);
+            if(casterGuid != m_bot->GetGUID()) return;
+
+            uint32 spellId; p >> spellId;
+            uint16 castFlags; p >> castFlags;
+            uint32 msTime; p >> msTime;
+            uint8 numHit; p >> numHit;
+            if(m_CurrentlyCastingSpellId == spellId)
+            {
+                Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+                if(!pSpell) return;
+                if(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())
+                    SetIgnoreUpdateTime( (((float)pSpell->GetSpellInfo()->GetDuration() / 1000.0f) + 1.0f) );
+                else if(pSpell->IsAutoRepeat())
+                    SetIgnoreUpdateTime(6);
+                else {
+                    SetIgnoreUpdateTime(0.5f);
+                    m_CurrentlyCastingSpellId = 0;
+                }
+            }
+            return;
+        }
+
+        case SMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint32 text_emote;
+            uint64 guid;
+            p >> guid;
+            p >> text_emote;
+
+            switch(text_emote)
+            {
+                case TEXT_EMOTE_BOW:
+                {
+                    //Buff anyone who bows before me. Useful for players not in bot's group
+                    Player *pPlayer = ObjectAccessor::FindPlayer(guid);
+
+                    Player *const bot =ObjectAccessor::FindPlayer(pPlayer->GetSelection());
+
+                    if(bot && bot->GetGUID()==m_bot->GetGUID() &&
+                       bot->GetPlayerbotAI()->GetClassAI())
+                    {
+                        bot->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    }
+                    return;
+                }
+
+                default:
+                    m_bot->HandleEmoteCommand(text_emote);
+                    return;
+            }
+            return;
+        }
+
+        case MSG_MOVE_TELEPORT_ACK:
+            HandleTeleportAck();
+            return;
+
+        case SMSG_QUESTGIVER_STATUS_MULTIPLE:
+        {
+            return;
+        }
+
+        // used to communicate between bots
+        case SMSG_MESSAGECHAT:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint8 msgtype;
+            uint32 language;
+            uint64 guid;
+            uint32 language2;
+            uint64 guid2;
+            uint32 textlen;
+            std::string msg;
+
+            p>>msgtype; p>>language; p>>guid; p>>language2; p>>guid2; p>>textlen;
+            p>>msg;
+
+            Player * fromPlayer = ObjectAccessor::FindPlayer(guid);
+            if (fromPlayer == NULL) break;
+            const std::string text = msg;
+            HandleCommand(text, *fromPlayer);
+        }
+
+        case SMSG_MONSTER_MOVE:
+        case SMSG_UPDATE_WORLD_STATE:
+        case SMSG_COMPRESSED_UPDATE_OBJECT:
+        case MSG_MOVE_SET_FACING:
+        case MSG_MOVE_STOP:
+        case MSG_MOVE_HEARTBEAT:
+        case MSG_MOVE_STOP_STRAFE:
+        case MSG_MOVE_START_STRAFE_LEFT:
+        case SMSG_UPDATE_OBJECT:
+        case MSG_MOVE_START_FORWARD:
+        //case SMSG_WEATHER:
+        case SMSG_POWER_UPDATE:
+        case SMSG_TIME_SYNC_REQ:
+        case SMSG_STANDSTATE_UPDATE:
+        case SMSG_PERIODICAURALOG:
+        case SMSG_AURA_UPDATE:
+        return;
+
+/*TESTING
+        default:
+        const char *oc = LookupOpcodeName(packet.GetOpcode());
+        TellMaster(oc);
+        //sLog->outError("SMSG opcode: %s", oc);
+  // TESTING*/
+    }
+}
+void PlayerbotAI::HandleTeleportAck()
+{
+    SetIgnoreUpdateTime(3);
+    m_bot->GetMotionMaster()->Clear(true);
+    if(m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; //supposed to be flags? not used currently
+        p << (uint32) time(0); //time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if(m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit &target) const
+{
+    return(static_cast<float>(target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit &target) const
+{
+    if(target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return(100);
+    else
+        return(static_cast<float>(target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit &target) const
+{
+    return(static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+
+typedef std::pair<uint32, uint8> spellEffectPair;
+typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit *player) const
+{
+    for(Unit::AuraMap::const_iterator iter = player->GetOwnedAuras().begin(); iter != player->GetOwnedAuras().end(); ++iter)
+    {
+        if(iter->second->GetId() == spellId) return true;
+    }
+    return false;
+}
+bool PlayerbotAI::HasAura(const char *spellName) const
+{
+    return HasAura(spellName, m_bot);
+}
+bool PlayerbotAI::HasAura(const char *spellName, const Unit *player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return(spellId) ? HasAura(spellId, player) : false;
+}
+
+void PlayerbotAI::UseMount() const
+{
+
+    if(m_master->IsMounted() && ! m_bot->IsMounted())
+    {
+// sLog->outError ("PlayerbotAI::UseMount: %s is mounted but %s is not", m_master->GetName(), m_bot->GetName());
+        //Player Part
+        int32 master_speed1 = 0;
+        int32 master_speed2 = 0;
+        if(!m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).empty())
+        {
+            master_speed1 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellInfo()->Effects[1].BasePoints;
+            master_speed2 = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED).front()->GetSpellInfo()->Effects[2].BasePoints;
+        }
+//sLog->outError ("master_speed1 = %d", master_speed1);
+//sLog->outError ("master_speed2 = %d", master_speed2);
+        //Bot Part
+        uint32 spellMount = 0;
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            uint32 spellId = itr->first;
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+                continue;
+            const SpellInfo *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if(!pSpellInfo)
+                continue;
+            if(pSpellInfo->Effects[0].ApplyAuraName == SPELL_AURA_MOUNTED)
+            {
+                if((pSpellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if((pSpellInfo->Effects[1].BasePoints == master_speed1)
+                        && (pSpellInfo->Effects[2].BasePoints == master_speed2))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if((pSpellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                    && (pSpellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+                {
+                    if((pSpellInfo->Effects[2].BasePoints == master_speed2)
+                        && (pSpellInfo->Effects[1].BasePoints == master_speed1))
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                else if(pSpellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                {
+                    if(pSpellInfo->Effects[1].BasePoints == master_speed1 && master_speed2 <= 0) { spellMount = spellId; break; } //Has no secondary mount aura
+                    else if (spellMount == 0) { spellMount = spellId; } // default to first mount in case it doesnt have correct version
+                }
+            }
+        }
+//sLog->outError ("spellMount = %u", spellMount);
+        if(spellMount > 0) m_bot->GetPlayerbotAI()->CastSpell(spellMount, m_bot);
+
+    }
+    else if(!m_master->IsMounted() && m_bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+} //end UseMount
+
+Item *PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                // if is FOOD
+                if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                    if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is FOOD
+                        if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_FOOD)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+Item *PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+            {
+                if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                    pItemTemplate->Spells[0].SpellCategory == 4)
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+
+                    if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if (pItemTemplate->Class==ITEM_CLASS_CONSUMABLE &&
+                        (pItemTemplate->SubClass==ITEM_SUBCLASS_FOOD ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_POTION ||
+                        pItemTemplate->SubClass==ITEM_SUBCLASS_ELIXIR))
+                    {
+                        // if is WATER
+                        if (pItemTemplate->Spells[0].SpellCategory == SPELL_CATEGORY_DRINK ||
+                            pItemTemplate->Spells[0].SpellCategory == 4)
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+Item *PlayerbotAI::FindPotion() const
+{
+    // list out items in main backpack
+    for (uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if (pItemTemplate->IsPotion())
+            {
+                    return pItem;
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                    if (! pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if (pItemTemplate->IsPotion())
+                    {
+                            return pItem;
+                    }
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+
+
+Item *PlayerbotAI::FindBandage() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+            if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag)
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                    if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_BANDAGE) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+// finds poison starting from the front
+Item *PlayerbotAI::FindPoisonForward() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+            if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                    if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+// finds poison starting from the back
+Item *PlayerbotAI::FindPoisonBackward() const
+{
+    //list out items in main backpack
+    for(uint8 slot=INVENTORY_SLOT_ITEM_END; slot > INVENTORY_SLOT_ITEM_START; slot--)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(pItem)
+        {
+            const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+            if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_GLYPH) continue;
+            if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+        }
+    }
+    //list out items in other removable backpacks
+    for(uint8 bag = INVENTORY_SLOT_BAG_END; bag > INVENTORY_SLOT_BAG_START; --bag)
+    {
+        const Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(pBag && pBag->IsBag())
+        {
+            for(uint8 slot = pBag->GetBagSize(); slot > 0  ; --slot)
+            {
+                Item *const pItem = m_bot->GetItemByPos(bag, slot);
+                if(pItem)
+                {
+                    const ItemTemplate *const pItemTemplate = pItem->GetTemplate();
+                    if(!pItemTemplate || m_bot->CanUseItem(pItemTemplate)!=EQUIP_ERR_OK) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_GLYPH) continue;
+                    if(pItemTemplate->Class == ITEM_CLASS_CONSUMABLE && pItemTemplate->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) return pItem;
+                }
+            }
+        }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket *const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);
+    uint8 counter = 1;
+    *packet << counter;
+    *packet << m_CurrentlyCastingSpellId;
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    //stand up if we are done feasting
+    if(!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_TimeDoneDrinking = time(0) - 1;
+        m_TimeDoneEating = time(0) - 1;
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    //wait 1 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(0);
+    SetIgnoreUpdateTime(1);
+
+    //should we drink another
+    if(m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking && ((static_cast<float>(m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item *pItem = FindDrink();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        } else {
+
+            // find a mage
+            if (m_FeastSpamTimer > 0) --m_FeastSpamTimer;
+            else {
+                Player *mage = GetClassAI()->FindMage(m_bot);
+                if (mage != NULL) {
+                    SendWhisper("I could use a drink.", *mage);
+                }
+                TellMaster("I need water.");
+                m_FeastSpamTimer=100;
+            }
+        }
+    }
+
+    //should we eat another
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking  && ((static_cast<float>(m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item *pItem = FindFood();
+        if(pItem != NULL && !m_bot->HasSpellCooldown(pItem->GetSpell()))
+        {
+            UseItem(*pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        //TellMaster("I need food."); //Disabled, tends to be horribly spammy.
+    }
+
+    //if we are no longer eating or drinking
+    //because we are out of items or we are above 80% in both stats
+    if(currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        //TellMaster("I'm ready, let's go.");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+Unit *PlayerbotAI::getNextTarget(Unit *victim)
+{
+    Unit *target = NULL;
+    AttackerSet m_attackers = victim->getAttackers();
+    if(!m_attackers.empty())
+    {
+        for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+        {
+            if(*iter && m_bot->GetDistance((*iter)) < 30 && (*iter)->isTargetableForAttack())
+            {
+                target = *iter;
+                break;
+            } //end if
+        } //end for
+    }
+    return target;
+} //end getNextTarget
+
+//intelligently sets a reasonable combat order for this bot
+//based on its class / level / etc
+void PlayerbotAI::GetCombatOrders()
+{
+    if(m_bot->isDead() || isLooting) return;
+    Unit *thingToAttack=0;
+
+    // check raid targets icons
+   if (!thingToAttack)
+    {
+        Group *group = m_bot->GetGroup();
+        uint64 targetGUID = group->GetTargetWithIconByGroup (m_bot->GetGUID());
+        if (targetGUID>0)
+        {
+            thingToAttack = ObjectAccessor::GetUnit(*m_master, targetGUID);
+            if (!thingToAttack || thingToAttack->isDead() || !m_bot->IsHostileTo(thingToAttack) || !thingToAttack->isTargetableForAttack())
+            {
+                m_bot->AttackStop();
+                thingToAttack=0;
+            }
+//else sLog->outError ("%s is attacking %s", m_bot->GetName(), thingToAttack->GetName());
+        }
+    }
+
+    //check if someone wants to attack master or me
+    if (!thingToAttack) thingToAttack = getNextTarget(m_master);
+
+    if(!thingToAttack)
+        thingToAttack = getNextTarget(m_bot);
+
+    //check master's target
+    if(!thingToAttack)
+    {
+        Unit *const pTarget = ObjectAccessor::GetUnit(*m_master, m_master->GetSelection());
+        if(pTarget && pTarget->isInCombat() && pTarget->IsHostileTo(m_master) && pTarget->isTargetableForAttack())
+            thingToAttack = pTarget;
+    }
+
+    //last try to find something to attack
+    if(!thingToAttack)
+    {
+        Unit *pUnit = NULL;
+        Trinity::NearestHostileUnitInAttackDistanceCheck u_check((Creature*)m_bot, 30.0);
+        Trinity::UnitLastSearcher<Trinity::NearestHostileUnitInAttackDistanceCheck> searcher(m_bot, pUnit, u_check);
+        m_bot->VisitNearbyObject(30, searcher);
+        if(pUnit != NULL && pUnit->isAlive() && pUnit->IsHostileToPlayers() && pUnit->isTargetableForAttack()) thingToAttack = pUnit;
+    }
+
+
+    //if the thing to attack is a world invisible trigger, ex Glyph in UBRS,
+    //default to master's current victim
+    if(!thingToAttack || thingToAttack->GetUInt32Value(UNIT_FIELD_DISPLAYID) == 11686 || !thingToAttack->isTargetableForAttack())
+    {
+        m_bot->AttackStop();
+        thingToAttack = m_master->getVictim();
+    }
+
+    //if the thing to attack is an invisible trigger ex vazruden in Hellfire Ramparts,
+    //default to master's current victim
+    if(!thingToAttack || !thingToAttack->IsVisible()) thingToAttack = m_master->getVictim();
+    // if the thing to attack is not attackable
+    //if (!thingToAttack || thingToAttack->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE)) thingToAttack = NULL;
+    if (!thingToAttack || !thingToAttack->isTargetableForAttack())
+    {
+        m_bot->AttackStop();
+        thingToAttack = NULL;
+    }
+
+    // override all others if ordered to pull
+    if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling()) {
+        thingToAttack = ObjectAccessor::GetUnit(*m_master,m_master->GetSelection());
+    }
+
+    if(!thingToAttack)
+    {
+        if(GetClassAI() && !m_bot->isInCombat()) (GetClassAI())->DoNonCombatActions();
+        return;
+    }
+
+    //wait till it gets closer
+    //if(m_bot->GetDistance(thingToAttack) > 30) return;
+
+    //if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    //this method never gets called when the bot is in a duel and this code
+    //prevents bot from helping
+    if(thingToAttack->GetTypeId() == TYPEID_PLAYER && ((Player*)(thingToAttack))->duel)
+    {
+       SetIgnoreUpdateTime(6);
+        return;
+    }
+
+    m_bot->SetSelection(thingToAttack->GetGUID());
+    SetIgnoreUpdateTime(0.5);
+    m_combatOrder = ORDERS_KILL;
+
+    if(m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    m_bot->Attack(thingToAttack, true);
+
+    if(thingToAttack->GetTypeId() != TYPEID_PLAYER)
+    {
+        //add thingToAttack to loot list
+        CreatureTemplate const *creatureInfo = ((Creature *)thingToAttack)->GetCreatureInfo();
+        if(creatureInfo && creatureInfo->lootid) m_lootCreature.push_back(thingToAttack->GetGUID());
+    }
+
+    return;
+}
+
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if(isLooting) return;
+
+    Unit *const pTarget = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+
+    //if current order doesn't make sense anymore
+    //clear our orders so we can get orders in next update
+    if((!pTarget || pTarget->isDead() || !pTarget->IsInWorld() ||
+        !m_bot->IsHostileTo(pTarget) || pTarget->IsPolymorphed() || m_bot->isDead()
+        || ( !m_master->isInCombat() && !m_bot->isInCombat() && !pTarget->isInCombat()) // The mob probably is in evade mode, stop combat..
+        || !pTarget->isTargetableForAttack()
+        ) &&
+        !m_bot->GetPlayerbotAI()->GetClassAI()->isPulling() )
+    {
+        m_bot->AttackStop();
+        m_combatOrder = ORDERS_NONE;
+        m_bot->SetSelection(0);
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->InterruptNonMeleeSpells(true);
+//sLog->outError ("current target doesn't make sense so following");
+        Follow(*m_master);
+        return;
+    }
+
+    if(GetClassAI())
+    {
+        if(m_bot->HasUnitState(UNIT_STAT_CASTING))
+        {
+            return;
+        }
+
+        GetClassAI()->DoNextCombatManeuver(pTarget);
+    }
+}
+
+//this is where the AI should go
+//GetRandomContactPoint
+//GetPower, GetMaxPower
+//HasSpellCooldown
+//IsAffectedBySpellmod
+//isMoving
+//HasUnitState(FLAG) FLAG like: UNIT_STAT_ROOT, UNIT_STAT_CONFUSED, UNIT_STAT_STUNNED
+//hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 p_time)
+{
+    time_t currentTime = time(0);
+    uint32 currentClock = getMSTime();
+    m_bot->UpdateZone(m_bot->GetZoneId(), m_bot->GetAreaId());
+
+    uint32 masterfaction = m_master->getFaction();
+    if(m_bot->getFaction() != masterfaction)
+        m_bot->setFaction(masterfaction);
+    if (m_bot->HaveBot())
+    {
+        for (uint8 i = 0; i != m_bot->GetMaxNpcBots(); ++i)
+        {
+            Creature *my_bot = m_bot->GetBotMap()[i].m_creature;
+            if (my_bot)
+            {
+                if (my_bot->getFaction() != masterfaction)
+                    my_bot->setFaction(masterfaction);
+                if(my_bot->m_botHasPet)
+                {
+                    Creature *bots_pet = my_bot->getBotsPet();
+                    if(bots_pet != NULL)
+                        bots_pet->setFaction(masterfaction);
+                }
+            }
+        }
+    }
+
+    if (m_playerBotsFly==0 && m_master->isInFlight())
+    {
+        if (m_IsFollowingMaster)
+        {
+            const WorldLocation fakeloc = WorldLocation(35, -0.873190f, 52.920242f, -27.550674f, 1.655620f);
+            PlayerbotChatHandler ch(m_master);
+            if (! ch.teleport(*m_bot, fakeloc))
+            {
+                ch.sysmessage(".. could not be teleported ..");
+                return;
+            }
+            m_bot->SendUpdateToPlayer(m_master);
+       }
+        Stay();
+        return;
+    }
+
+    if(m_TimeRessurect == 0 && m_bot->isDead())
+    {
+        m_IsFollowingMaster = false;
+        m_TimeRessurect = currentTime + 30;
+        return;
+    }
+    else if(m_TimeRessurect > currentTime && m_bot->isDead())
+    {
+        return;
+    }
+    else if((!m_TimeRessurect == 0) && m_TimeRessurect <= currentTime && m_bot->isDead())
+    {
+        m_IsFollowingMaster = true;
+        m_TimeRessurect = 0;
+    }
+    if(((int64)m_ignoreAIUpdatesUntilTime - (int64)currentClock) > (int64) 30000) { SetIgnoreUpdateTime(2); return; } // Fix Timer overflow and AI freeze (max limit 30 secs)
+    if(currentClock < m_ignoreAIUpdatesUntilTime || m_bot->IsBeingTeleported() || m_bot->GetTrader()) return;
+
+
+    //default updates occur every 1.5 seconds
+    SetIgnoreUpdateTime(0.5);
+
+    // prevent cheating
+    if (!m_bot->GetGroup())
+    {
+        m_master->GetSession()->LogoutPlayerBot(m_bot->GetGUID(), false);
+        return;
+    }
+
+    if(m_bot->isDead()) isLooting = false;
+
+    /*
+     * combat checks
+     */
+    if(m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return; //You're DEAD, stop thinking.
+
+    //if we are casting a spell then interrupt it
+    //make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+    Spell *const pSpell = GetCurrentSpell();
+    if(pSpell && !(pSpell->IsChannelActive() || pSpell->IsAutoRepeat())) InterruptCurrentCastingSpell();
+
+    //direct cast command from master
+    else if(m_spellIdCommand != 0)
+    {
+        Unit *pTarget = ObjectAccessor::GetUnit(*m_bot, m_targetGuidCommand);
+        if(pTarget != NULL) CastSpell(m_spellIdCommand, pTarget);
+        m_spellIdCommand = 0;
+        m_targetGuidCommand = 0;
+    }
+
+    else if(m_combatOrder != ORDERS_NONE) DoNextCombatManeuver(); //handle combat
+
+    else if (m_bot->GetPlayerbotAI()->GetClassAI()->isPulling())
+    {
+        GetCombatOrders();
+        return;
+    }
+
+    //if master is in combat and bot is not, automatically assist master
+    //NOTE: combat orders are also set via incoming packets to bot or outgoing packets from master
+    else if(m_master->isInCombat() && (!m_bot->isInCombat() || m_combatOrder == ORDERS_NONE) || m_master->isDead()) GetCombatOrders();
+
+    //if bot is in combat but master is not, attack
+    else if(m_bot->isInCombat()) GetCombatOrders();
+
+    // if bot is not in combat, but main tank is
+    else if (!m_bot->isInCombat()) {
+       Unit *tank=m_classAI->FindMainTankInRaid(m_bot);
+       if (tank!=NULL && tank->isInCombat()) GetCombatOrders();
+
+    }
+
+    /*
+     * Non combat checks
+     */
+
+    //are we sitting, if so feast if possible
+/* TESTING */ //   if(m_bot->getStandState() == UNIT_STAND_STATE_SIT) {*/
+/* TESTING *///sLog->outError ("%s - sitting so feast", m_bot->GetName());
+//
+/* TESTING */ //   }
+
+    //if commanded to follow master and not already following master then follow master
+    if(!m_bot->isInCombat() && m_IsFollowingMaster && m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE)
+    {
+        Follow(*m_master);
+
+    //do class specific non combat actions
+    } else if(!m_bot->isInCombat() && GetClassAI()) {
+        (GetClassAI())->DoNonCombatActions();
+    } if(!m_master->isInCombat())
+        DoLoot();
+
+
+    if (m_master->getStandState() == UNIT_STAND_STATE_SIT)
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+        m_bot->SendUpdateToPlayer(m_master);
+        if(m_bot->GetHealthPct() < 80.0f)
+            Feast();
+    }
+    else if (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0)) //Do no interrupt if bot is eating/drinking
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+
+    //try to catch if he is falling through the world.  This happens
+    //when zoning in/out of an instance
+    if(m_IsFollowingMaster && m_bot->GetMapId() != m_master->GetMapId() ||
+    //m_bot->GetZoneId() != m_master->GetZoneId() ||
+    (abs(abs(m_bot->GetPositionX()) - abs(m_master->GetPositionX())) > 90) ||
+    (abs(abs(m_bot->GetPositionY()) - abs(m_master->GetPositionY())) > 90) ||
+    (abs(abs(m_bot->GetPositionZ()) - abs(m_master->GetPositionZ())) > 50))
+    {
+//sLog->outError ("%s: %s is too far away so following", m_bot->GetName(), m_master->GetName());
+        Follow(*m_master);
+    }
+}
+
+
+void PlayerbotAI::KilledMonster(uint32 entry, uint64 guid)
+{
+   // isLooting = true;
+
+    if(m_master->isAlive() && m_IsFollowingMaster && !m_master->isInCombat())
+    {
+        if(!DoLoot())
+        {
+            float angle = rand_norm()*M_PI; //Generates random float between 0 and 3.14
+            float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10);
+
+            m_bot->GetMotionMaster()->Clear(true);
+            m_bot->GetMotionMaster()->MoveFollow(m_master, dist, angle);
+        }
+    }
+
+    // reset main tank every time we finish combat, just in case the
+    // original main tank died and got set to next tank.
+    //m_classAI->SetMainTank(NULL);
+}
+
+Spell *PlayerbotAI::GetCurrentSpell() const
+{
+    if(m_CurrentlyCastingSpellId == 0) return NULL;
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+    return pSpell;
+}
+
+void PlayerbotAI::TellMaster(const std::string &text)
+{
+    SendWhisper(text, *m_master);
+}
+
+bool PlayerbotAI::CanBotsFly()
+{
+    if (m_playerBotsFly==0) return false;
+    else return true;
+}
+
+void PlayerbotAI::SendWhisper(const std::string &text, Player &player)
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER_INFORM, text, LANG_UNIVERSAL);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player &player) const
+{
+    return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+void PlayerbotAI::SetInFront(const Unit *obj)
+{
+    if(!m_bot->HasInArc(M_PI, obj))
+    {
+        m_bot->SetInFront(obj);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+}
+
+bool PlayerbotAI::CastSpell(const char *args)
+{
+    uint32 spellId = getSpellId(args);
+    return(spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if (!spellId) return false;
+
+    if (!m_bot->HasSpell(spellId)) {
+        return false;
+    }
+
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);
+}
+
+bool PlayerbotAI::CastSpell(const SpellInfo * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{
+    if(!m_bot->isAlive()) return false;
+    if(!pSpellInfo)
+    {
+        sLog->outError ("%s: Missing spell entry in CastSpell Direct", m_bot->GetName());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+    uint64 oldSel = m_bot->GetSelection();
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (sSpellMgr->GetSpellInfo(spellId)->AttributesCu & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    //Make the Checks
+
+    if (!triggered && checkFirst && !CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck) ) { return false; }
+    if ( m_bot->GetSelection() != target->GetGUID() ) { m_bot->SetSelection(target->GetGUID()); } //if target is different than selection apply it
+
+    m_bot->CastSpell(target, pSpellInfo, triggered); //CAST THE SPELL
+    if ( m_bot->GetSelection() != oldSel ) { m_bot->SetSelection(oldSel); } // Restore if target changed to cast
+
+    // Check if the casting started..
+    Spell *const pSpell = m_bot->FindCurrentSpellBySpellId(spellId);
+    if(!pSpell) return false;
+
+    // Trigger Pseudo Global Cooldown and consider casttime
+    float GCD = 1.5f;
+    if (m_bot->getPowerType() == POWER_ENERGY) GCD = 1;
+    float psCastTime = ((float)pSpell->GetCastTime()) / 1000.0f;
+    if (psCastTime - GCD > -0.3f) GCD = 0.3f; //Global cooldown won't be an issiue for casts (0.3 secs is for safe next cast)
+    else { GCD -= psCastTime; } //Remaining GCD after cast..
+    //float psRecoveryTime = GetSpellRecoveryTime(pSpellInfo) / 1000;
+    //sLog->outDebug(LOG_FILTER_NETWORKIO, "Bot [%u] Start Spell [%u] Cast Time [%f]", m_bot->GetGUIDLow(), pSpellInfo->Id, psCastTime);
+    m_CurrentlyCastingSpellId = spellId;
+    //SetIgnoreUpdateTime(psCastTime + GCD);
+    SetIgnoreUpdateTime(psCastTime > GCD ? psCastTime : GCD);
+    return true;
+}
+
+bool PlayerbotAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+     //if spellId == 0, it means that the bot is not high enough level to
+    //have learned the spell
+    if (!spellId) return false;
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Non-existing Spell in Cast - [%u]", m_bot->getClass(), spellId);
+        std::stringstream ss;
+        ss << "Missing spell entry in CastSpell - ";
+        ss << spellId;
+        TellMaster(ss.str());
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    return CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);
+}
+
+bool PlayerbotAI::CanCast(const SpellInfo * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (!pSpellInfo)
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "CRITICAL: PBot Class %u - Non-existing Spell in CastCheck - Direct SpellInfo", m_bot->getClass());
+        TellMaster("Missing spell entry in CastSpell");
+        SetIgnoreUpdateTime(1);
+        return false;
+    }
+    uint32 spellId = pSpellInfo->Id;
+
+    // Auto Targeting
+    if (!target)
+    {
+        //NEGATIVE SPELL
+        if (sSpellMgr->GetSpellInfo(spellId)->AttributesCu & SPELL_ATTR0_CU_NEGATIVE)
+        {
+            if (m_bot->GetSelection() <= 0) return false;
+            else
+            {
+                target = ObjectAccessor::GetUnit(*m_bot, m_bot->GetSelection());
+                if (!target) return false;
+            }
+        }
+        else { target = m_bot; }
+    }
+
+    if (!m_bot->isAlive()) return false;
+    if (m_bot->HasSpellCooldown(spellId)) return false;
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return false;
+    if (m_bot->IsMounted()) return false;
+
+    //cast existing aura over again?
+    if (!castExistingAura && target->HasAura(spellId, m_bot->GetGUID())) return false;
+
+    //Stances-forms and equipment REQs
+    if (!skipEquipStanceCheck)
+    {
+        uint32 formMask = (GetForm() ? 1 << (GetPlayerBot()->GetShapeshiftForm() - 1) : 0);
+        //sLog->outDebug(LOG_FILTER_NETWORKIO, "DEBUG: Spell [%u] - Form [%X] - Need Form [%X] - Not Form [%X]", pSpellInfo->Id, formMask, pSpellInfo->Stances, pSpellInfo->StancesNot );
+        if (pSpellInfo->Stances & formMask) { return true; }
+        if (pSpellInfo->StancesNot && pSpellInfo->StancesNot & formMask) { return false; }
+        if (!m_bot->HasItemFitToSpellRequirements(pSpellInfo)) return false;
+    }
+
+    //Power Costs
+    const SpellSchoolMask pSpellSchool = pSpellInfo->GetSchoolMask();
+    uint32 pPowerCost = pSpellInfo->CalcPowerCost(m_bot, pSpellSchool);
+
+    if (skipEquipStanceCheck) { if (m_bot->GetPower((Powers)pSpellInfo->PowerType) < pPowerCost) return false; } //Power check for Required PowerType (After changind stance, powertype may change, for druids)
+    else { if (m_bot->GetPower(m_bot->getPowerType()) < pPowerCost) return false; } //Power check for Current m_bot Power Type
+
+    //Distance / movement checks
+    const SpellRangeEntry * pSpellRange = sSpellRangeStore.LookupEntry(pSpellInfo->RangeEntry->ID);
+    float curDistance = m_bot->GetDistance(target);
+    if (pSpellInfo->CastTimeEntry->CastTime > 0 && m_bot->isMoving()) return false; //Cannot cast while moving
+
+    //The target is immune or not?
+    if (target->GetTypeId() != TYPEID_PLAYER) { if ( ((Creature*)target)->IsImmunedToSpell(pSpellInfo)) { return false; } }
+    else { if (target->IsImmunedToSpell(pSpellInfo)) { return false; } }
+
+    //target reaction checks (Has problems with dual effect spells like death coil/holy shock)
+    if (skipFriendlyCheck)
+    {
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } } //Assume hostile spell
+    }
+    else if (sSpellMgr->GetSpellInfo(spellId)->IsPositive())
+    {
+        if(! m_bot->IsFriendlyTo(target)) { return false; }
+        else if (pSpellRange->maxRangeFriend != 0) { if (pSpellRange->maxRangeFriend < curDistance || pSpellRange->minRangeFriend > curDistance) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false;
+    }
+    else
+    {
+        if (m_bot->IsFriendlyTo(target))  return false;
+        if (!m_bot->HasInArc(M_PI,target)) return false; //target is not in front
+        if (pSpellRange->maxRangeHostile != 0) { if ( pSpellRange->maxRangeHostile < curDistance || pSpellRange->minRangeHostile > curDistance ) { return false; } }
+        else if (curDistance > MELEE_RANGE) return false; //Out of range - Melee Range
+    }
+
+    return true;
+}
+
+uint8 PlayerbotAI::GetForm(Unit *pPlayer)
+{
+    if (!pPlayer) pPlayer = m_bot;
+    return (pPlayer->GetUInt32Value(UNIT_FIELD_BYTES_2) & 0xFF000000) >> (4 * 6);
+}
+
+//extracts all item ids in format below
+//I decided to roll my own extractor rather then use the one in ChatHandler
+//because this one works on a const string, and it handles multiple links
+//|color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string &text, std::list<uint32> &itemIds) const
+{
+    uint8 pos = 0;
+    while(true)
+    {
+        int i = text.find("Hitem:", pos);
+        if(i == -1) break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if(endPos == -1) break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if(id) itemIds.push_back(id);
+    }
+}
+
+bool PlayerbotAI::extractGOinfo(const std::string& text, uint32 &guid, uint32 &entry, int &mapid, float &x, float &y, float &z) const
+{
+
+   //    Link format
+   //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':' << x << ':' << y << ':' << z  << ':' << mapid << ':' <<  "|h[" << gInfo->name << "]|h|r";
+
+     //    |cFFFFFF00|Hfound:5093:1731:-9295:-270:81.874:0:|h[Copper Vein]|h|r
+  uint8 pos = 0;
+      // extract GO guid
+       int i = text.find("Hfound:", pos); // base H = 11
+       if (i == -1) // break if error
+            return false;
+
+       pos = i + 7; //start of window in text 11 + 7 = 18
+      int endPos = text.find(':', pos); // end of window in text 22
+      if (endPos == -1) //break if error
+           return false;
+       std::string guidC = text.substr(pos, endPos - pos); // get string within window i.e guid 22 - 18 =  4
+       guid = atol(guidC.c_str()); // convert ascii to long int
+     // extract GO entry
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string entryC = text.substr(pos, endPos - pos); // get string within window i.e entry
+        entry = atol(entryC.c_str()); // convert ascii to float
+     // extract GO x
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+       std::string xC = text.substr(pos, endPos - pos); // get string within window i.e x
+
+        x = atof(xC.c_str()); // convert ascii to float
+      // extract GO y
+       pos = endPos + 1;
+      endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string yC = text.substr(pos, endPos - pos); // get string within window i.e y
+      y = atof(yC.c_str()); // convert ascii to float
+     // extract GO z
+
+        pos = endPos + 1;
+       endPos = text.find(':', pos); // end of window in text
+        if (endPos == -1) //break if error
+           return false;
+
+       std::string zC = text.substr(pos, endPos - pos); // get string within window i.e z
+
+        z = atof(zC.c_str()); // convert ascii to float
+
+      //extract GO mapid
+       pos = endPos + 1;
+       endPos = text.find(':', pos); // end of window in text
+       if (endPos == -1) //break if error
+           return false;
+      std::string mapidC = text.substr(pos, endPos - pos); // get string within window i.e mapid
+       mapid = atoi(mapidC.c_str()); // convert ascii to int
+        pos = endPos; // end
+      return true;
+}
+
+//extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string &text) const
+{
+    //if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for(uint8 i = 0; i < text.length(); i++)
+    {
+        if(text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if(text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if(text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if(text[i] == ' ')
+        {
+            break;
+        }
+        else if(text[i] >= 48 && text[i] <= 57)
+        {
+            acum += text[i];
+        } else {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for( uint8 slot=EQUIPMENT_SLOT_START; itemIdSearchList.size()>0 && slot<EQUIPMENT_SLOT_END; slot++ ) {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if( !pItem )
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+
+//finds items in inventory and adds Item *to foundItemList
+//also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    //look for items in main bag
+    for(uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item *const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem) continue;
+        for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if(pItem->GetTemplate()->ItemId != *it) continue;
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    //for all for items in other bags
+    for(uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag *const pBag = (Bag *)m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if(!pBag) continue;
+        for(uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item *const pItem = m_bot->GetItemByPos(bag, slot);
+            if(!pItem) continue;
+            for(std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if(pItem->GetTemplate()->ItemId != *it) continue;
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotAI::HasPick()
+{
+    QueryResult result;
+
+    // list out equiped items
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+        if (pItem )
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+
+                if (!pItemTemplate )
+                    continue;
+
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemTemplate->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NETWORKIO, "[%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot); // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+            if (!pItemTemplate )
+                continue;
+            result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemTemplate->ItemId);
+            if (result)
+            {
+                Field *fields = result->Fetch();
+                uint32 tc = fields[0].GetUInt32();
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "HasPick %u",tc);
+                if(tc ==  165 || tc == 167) // pick = 165, hammer = 162 or hammer pick = 167
+                    return true;
+            }
+        }
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag); // 255, 20 to 23
+        if (pBag)
+        {
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug(LOG_FILTER_NETWORKIO, "[%s's]bag[%u] slot = %u",m_bot->GetName(),bag,slot); // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+
+                    if (!pItemTemplate )
+                        continue;
+
+                    result = WorldDatabase.PQuery("SELECT TotemCategory FROM item_template WHERE entry = '%i'", pItemTemplate->ItemId);
+                    if (result)
+                    {
+
+                        Field *fields = result->Fetch();
+                        uint32 tc = fields[0].GetUInt32();
+                        // sLog->outDebug(LOG_FILTER_NETWORKIO, "HasPick %u",tc);
+                        if(tc ==  165 || tc == 167)
+                            return true;
+                    }
+                }
+            }
+        }
+    }
+    std::ostringstream out;
+    out << "|cffffffffI do not have a pick!";
+    TellMaster( out.str().c_str() );
+    return false;
+}
+
+
+//submits packet to use an item
+void PlayerbotAI::PoisonWeapon(Item &item, uint32 _spellId, uint32 _target, EquipmentSlots weaponSlot)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = _spellId;
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    uint32 target = _target;
+    uint32 targetItemGUID = 0;
+    uint8 x = 0;
+    Item *weapon=NULL;
+    if (_spellId>0){
+
+        targetItemGUID = 16;
+        x = 135;
+        cast_count = 7;
+        weapon = GetPlayerBot()->GetItemByPos( INVENTORY_SLOT_BAG_0, weaponSlot );
+
+    }
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 4);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    if (weapon) packet->appendPackGUID(weapon->GetGUID());
+
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get around race condition
+
+} // end PoisonWeapon
+
+
+
+//submits packet to use an item
+void PlayerbotAI::UseItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 cast_count = 1;
+    uint32 spellid = 0; //only used in combat
+    uint64 item_guid = item.GetGUID();
+    uint32 glyphIndex = 0; //??
+    uint8 unk_flags = 0; //not 0x02
+
+    //create target data
+    //note other targets are possible but not supported at the moment
+    //see SpellCastTargets::read in Spell.cpp to see other options
+    //for setting target
+
+    uint32 target = TARGET_TYPE_DEFAULT;
+
+    WorldPacket *const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1);
+    *packet << bagIndex << slot << cast_count << spellid << item_guid << glyphIndex << unk_flags << target;
+    m_bot->GetSession()->QueuePacket(packet); //queue the packet to get aroundrace condition
+
+} // end UseItem
+
+
+//submits packet to use an item
+void PlayerbotAI::EquipItem(Item &item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+
+    WorldPacket *const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+    *packet << bagIndex << slot;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI::TradeItem]: slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+        slot,
+        (m_bot->GetTrader()?1:0),
+        (item.IsInTrade()?1:0),
+        (item.CanBeTraded()?1:0)
+        );
+
+    if (!m_bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    int8 tradeSlot = -1;
+
+    if( (slot>=0 && slot<TRADE_SLOT_COUNT) /* && m_bot->GetItem(trade slot)==NULL_SLOT */) {
+        tradeSlot = slot;
+    } else if (!item.CanBeTraded())
+    {
+        tradeSlot = (uint8) TRADE_SLOT_NONTRADED;
+    }
+    else
+    {
+        for( uint8 i=0; i<TRADE_SLOT_TRADED_COUNT; ++i )
+        {
+            if (m_bot->GetTradeData()->GetItem(TradeSlots(i)) == NULL){
+                tradeSlot = (uint8)i;
+                break;
+            }
+        }
+    }
+
+    if( tradeSlot == -1 ) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+
+    return true;
+}
+
+
+//submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if(copper > 0)
+    {
+        WorldPacket *const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::Stay()
+{
+    if (!m_IsFollowingMaster)
+        return;
+
+    m_IsFollowingMaster = false;
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_SALUTE);
+}
+
+
+bool PlayerbotAI::Follow(Player &player)
+{
+    if(m_master <= 0 || ((m_master->isInCombat() || m_bot->isInCombat()) && m_bot->isDead())) return false; //You're DEAD, stop thinking.
+    if(m_master->isDead()) return false;
+    if(m_master->IsBeingTeleported() || m_master->isInFlight()) return false;
+
+    if(m_bot->getStandState() == UNIT_STAND_STATE_SIT && (m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0))) return false; //Do no interrupt if bot is eating/drinking
+
+    m_IsFollowingMaster = true;
+
+    if(!m_bot->IsStandState()) {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        m_bot->SendUpdateToPlayer(m_master);
+    }
+
+    if(!m_bot->isInCombat())
+    {
+        //if bot is dead and master is alive, revive bot
+        if(m_master->isAlive() && !m_bot->isAlive())
+        {
+            SetIgnoreUpdateTime(6);
+            isLooting = false;
+            PlayerbotChatHandler ch(m_master);
+            if(!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return false;
+            }
+        }
+
+        if(!m_bot->isDead() && !m_bot->IsBeingTeleported() && !player.isDead() &&
+            (m_bot->GetMapId() != player.GetMapId()
+            || m_bot->GetZoneId() != player.GetZoneId()
+            || m_bot->GetAreaId() != player.GetAreaId()
+            || m_bot->GetPhaseMask() != player.GetPhaseMask())
+            || m_bot->GetDistance(player) > 255)
+            {
+                SetIgnoreUpdateTime(3);
+                isLooting = false;
+                PlayerbotChatHandler ch(m_master);
+                if(!ch.teleport(*m_bot))
+                {
+                    ch.sysmessage(".. could not be teleported ..");
+                    return false;
+                }
+        }
+    }
+
+    if(m_bot->isAlive() && !isLooting)
+    {
+        float angle = M_PI/2 + rand_norm()*M_PI ; //Generates random float between 90 and 270 degrees
+        float dist = (float)(urand((m_followDistanceMin*10), (m_followDistanceMax*10))/10); // Using urand to get a random float is stupid.
+        m_bot->GetMotionMaster()->Clear(true);
+        m_bot->GetMotionMaster()->MoveFollow(&player, dist, angle);
+
+        return true;
+    }
+    return false;
+}
+
+//handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string &text, Player &fromPlayer)
+{
+    //ignore any messages from Addons
+    if(text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos)
+        return;
+
+    //if message is not from a player in the masters account auto reply and ignore
+    if(!canObeyCommandFrom(fromPlayer))
+    {
+        std::string msg = "I can't talk to you. Please speak to my master ";
+        msg += m_master->GetName();
+        msg += ".";
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+        SendWhisper(msg, fromPlayer);
+    }
+
+
+    else if (text == "I could use a drink." &&
+             m_bot->getClass() == CLASS_MAGE)
+    {
+            Item const*pItem = FindDrink();
+            if (pItem != NULL) {
+                WorldPacket *p = new WorldPacket(CMSG_INITIATE_TRADE, 8);
+                *p << fromPlayer.GetGUID();
+                m_bot->GetSession()-> HandleInitiateTradeOpcode(*p);
+                SendWhisper ("Here is a tasty treat for you", fromPlayer);
+
+            }
+    }
+    // accept food/drink from mage
+    else if (text == "Here is a tasty treat for you")
+    {
+        m_bot->Say ("Thank you for this treat", LANG_UNIVERSAL);
+        SendWhisper ("Thank you for this treat.", fromPlayer);
+    }
+    // trade opened so send items over
+    else if (text == "Thank you for this treat")
+    {
+        if (m_bot->getClass()!=CLASS_MAGE) return;
+
+        Item const*pItem = FindDrink();
+        if (pItem==NULL) return;
+
+        bool trade = TradeItem (*pItem,2);
+        if (trade) {
+            m_bot->Say("Enjoy the refreshing drink.", LANG_UNIVERSAL);
+
+            WorldPacket* const packet = new WorldPacket(CMSG_ACCEPT_TRADE, 3);
+            m_bot->GetSession()->QueuePacket(packet);  // packet is not used
+        } else {
+            m_bot->Say ("I cannot trade with you.", LANG_UNIVERSAL);
+        }
+    }
+
+    // if in the middle of a trade, and player asks for an item/money
+    else if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID() &&
+        fromPlayer.GetPlayerbotAI() == NULL)
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            findItemsInEquip(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+
+    else if(text == "teleport" || text == "tele" || text == "summon" || text == "summ")
+    {
+        PlayerbotChatHandler ch(m_master);
+        if(!ch.teleport(*m_bot, *m_master))
+            ch.sysmessage("bot cannot be teleported");
+    }
+
+    else if(text == "follow" || text == "come")
+        Follow(*m_master);
+
+    else if(text == "stay" || text == "stop")
+        Stay();
+
+    //handle cast command
+    else if(text.size() > 2 && text.substr(0, 2) == "c " ||
+        text.size() > 5 && text.substr(0, 5) == "cast ")
+        {
+            uint32 spellId = 0;
+            std::string spellStr = text.substr(text.find(" ") + 1);
+
+            if(spellStr.find("Hspell:"))
+            {
+                spellStr = spellStr.substr(spellStr.find("|h[") + 3);
+                spellStr = spellStr.substr(0, spellStr.find("]"));
+            } else
+                spellId = (uint32)atol(spellStr.c_str());
+
+            //try and get spell ID by name
+            if(spellId == 0) spellId = getSpellId(spellStr.c_str(), true);
+
+            uint64 castOnGuid = fromPlayer.GetSelection();
+            if(castOnGuid == 0) castOnGuid = m_bot->GetGUID();
+            if(spellId != 0)
+            {
+                m_spellIdCommand = spellId;
+                m_targetGuidCommand = castOnGuid;
+            }
+    }
+
+    //use items
+    else if(text.size() > 2 && text.substr(0, 2) == "u " ||
+    text.size() > 4 && text.substr(0, 4) == "use ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) UseItem(**it);
+    }
+
+    // poison mainhand weapon
+    else if(text.size() > 2 && text.substr(0, 2) == "p " ||
+    text.size() >= 8 && text.substr(0, 8) == "poison m")
+    {
+
+        Item *poison = FindPoisonForward();
+        if(poison == NULL) {
+            std::string msg = "No poison found for mainhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+    }
+
+    // poison offhand weapon
+    else if(text.size() >= 8 && text.substr(0, 8) == "poison o")
+    {
+
+        Item *poison = FindPoisonBackward();
+        if(poison == NULL) {
+            std::string msg = "No poison found for offhand.";
+            SendWhisper(msg, fromPlayer);
+            return;
+        }
+
+        PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+    }
+
+    //equip items
+    else if(text.size() > 2 && text.substr(0, 2) == "e " ||
+    text.size() > 6 && text.substr(0, 6) == "equip ")
+    {
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+         for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it) EquipItem(**it);
+    }
+
+    else if(text == "spells")
+    {
+        int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+        std::string alreadySeenList = ",";
+
+        for(PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+                continue;
+
+            const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if(!pSpellInfo)
+                continue;
+
+            //|| name.find("Teleport") != -1
+
+            std::string comp = ",";
+            comp.append(pSpellInfo->SpellName[loc]);
+            comp.append(",");
+
+            if(!(ignoreList.find(comp) == std::string::npos &&
+                alreadySeenList.find(comp) == std::string::npos))
+                continue;
+
+            alreadySeenList += pSpellInfo->SpellName[loc];
+            alreadySeenList += ",";
+
+            if(sSpellMgr->GetSpellInfo(spellId)->IsPositive())
+                posOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |cffffffff|Hspell:" << spellId << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("Here's my non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("Here's my attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+
+    else if (text.size() > 13 && text.substr(0,13) == "accept quest ")
+    {
+        uint32 questId = 0;
+        std::string questStr = text.substr(text.find(" ") + 1);
+        questStr = questStr.substr(questStr.find(" ") + 1);
+        std::string questStrLink = questStr;
+        if (questStr.find("Hquest:"))
+        {
+            questStr = questStr.substr(questStr.find("|h[") + 3);
+            questStr = questStr.substr(0, questStr.find("]"));
+        }
+        else
+            questId = (uint32)atol(questStr.c_str());
+
+        // try and get quest ID by name
+        if (questId == 0)
+            questId = getQuestId(questStr.c_str(), 0);
+        std::ostringstream out;
+        out << "Quest " << questId << " " << questStr.c_str();
+
+        PlayerbotChatHandler ch(m_master);
+        uint64 oldSel = 0;
+        if (m_master->GetSelection())
+            oldSel = m_master->GetSelection();
+        m_master->SetSelection(m_bot->GetGUID());
+        if (questId != 0 && ch.acceptQuest(questStrLink.c_str()))
+        {
+            out << " accepted.";
+            TellMaster(out.str());
+        }
+        else
+        {
+            out << " not accepted.";
+            TellMaster(out.str());
+        }
+        if (oldSel > 0)
+            m_master->SetSelection(oldSel);
+    }
+
+    else if (text.size() > 14 && text.substr(0,14) == "abandon quest ")
+    {
+        uint32 questId = 0;
+        std::string questStr = text.substr(text.find(" ") + 1);
+        questStr = questStr.substr(questStr.find(" ") + 1);
+        std::string questStrLink = questStr;
+        if (questStr.find("Hquest:"))
+        {
+            questStr = questStr.substr(questStr.find("|h[") + 3);
+            questStr = questStr.substr(0, questStr.find("]"));
+        }
+        else
+            questId = (uint32)atol(questStr.c_str());
+
+        // try and get quest ID by name
+        if (questId == 0)
+            questId = getQuestId(questStr.c_str(), 1);
+        std::ostringstream out;
+        out << "Quest " << questId << " " << questStr.c_str();
+
+        PlayerbotChatHandler ch(m_master);
+        uint64 oldSel = 0;
+        if (m_master->GetSelection())
+            oldSel = m_master->GetSelection();
+        m_master->SetSelection(m_bot->GetGUID());
+        if (questId != 0 && ch.abandonQuest(questStrLink.c_str()))
+        {
+            out << " abandoned.";
+            TellMaster(out.str());
+        }
+               else
+        {
+            out << " not abandoned.";
+            TellMaster(out.str());
+        }
+        if (oldSel > 0)
+            m_master->SetSelection(oldSel);
+    }
+
+    /*else if (text.size() == 1 && text.substr(0,1) == "q" ||
+        text == "quests")
+    {
+        std::ostringstream out;
+        for (QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+        {
+            const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+            if (!qInfo)
+                continue;
+            QuestStatusData qData = iter->second;
+
+            uint32 questId = qInfo->GetQuestId();
+            const std::string name = qInfo->GetTitle();
+            if (name.empty())
+                continue;
+            //out << qData->m_status << " ";
+            if (qData.m_status == QUEST_STATUS_NONE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " no status" << "\n";
+                continue;
+            }
+            else if (qData.m_status == QUEST_STATUS_COMPLETE)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " complete" << "\n";
+            }
+            else if (qData.m_status == QUEST_STATUS_UNAVAILABLE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " unavailable" << "\n";
+                continue;
+            }
+            else if (qData.m_status == QUEST_STATUS_INCOMPLETE)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " incomplete" << "\n";
+            }
+            else if (qData.m_status == QUEST_STATUS_AVAILABLE)
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " available" << "\n";
+                continue;
+            }
+            else if (qData.m_status == QUEST_STATUS_FAILED)
+            {
+                out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                out << " failed" << "\n";
+            }
+            else
+            {
+                //out << "Quest " << " |cffffffff|Hquest:" << questId << "|h[" << name << "]|h|r" << " ";
+                //out << " unknown" << "\n";
+                continue;
+            }
+        }
+        if (!out.str().empty())
+            TellMaster(out.str());
+    }*/
+
+    else if (text == "train")
+    {
+         Unit *unit = m_master->GetSelectedUnit();
+
+         if (!unit)
+         {
+             TellMaster("Please select the trainer which I should learn from!");
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             TellMaster("This is not a trainer!");
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             TellMaster("This trainer can not train me anything at all!");
+             return;
+         }
+
+         CreatureTemplate const *creatureInfo = creature->GetCreatureInfo();
+
+         if (!creatureInfo)
+         {
+             TellMaster("This trainer can not train me anything at all!");
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+             TellMaster("No training spells can be found from this trainer");
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "I had learnt the following spells:\n";
+         uint32 totalCost = 0;
+         uint32 totalSpellLearnt = 0;
+         int loc = m_master->GetSession()->GetSessionDbcLocale();
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 if  (sSpellMgr->GetSpellInfo(tSpell->learnedSpell[i])->IsPrimaryProfessionFirstRank())
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+             {
+                 continue;
+             }
+             //data << uint32(primary_prof_first_rank &&  can_learn_primary_prof ? 1 : 0);
+             uint32 spellId = tSpell->spell;
+             const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+             if (!pSpellInfo)
+             {
+                 continue;
+             }
+             uint32 cost = (uint32) (floor(tSpell->spellCost *  fDiscountMod));
+
+             // check money requirement
+             if(m_bot->GetMoney() < cost )
+                 continue;
+
+             m_bot->ModifyMoney( -int32(cost) );
+
+             // learn explicitly or cast explicitly
+             if(tSpell->IsCastable())
+                 //FIXME: prof. spell entry in trainer list not marked  gray until list re-open.
+                 m_bot->CastSpell(m_bot,tSpell->spell,true);
+             else
+                 m_bot->learnSpell(spellId,false);
+             totalSpellLearnt++;
+             totalCost = totalCost + cost;
+
+             msg << " |cffffffff|Hspell:" << spellId <<  "|h[" << pSpellInfo->SpellName[loc] << "]|h|r" <<  ", ";
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+         }
+
+         uint32 gold = uint32(totalCost / 10000);
+         totalCost -= (gold * 10000);
+         uint32 silver = uint32(totalCost / 100);
+         totalCost -= (silver * 100);
+         msg << "Total of " << totalSpellLearnt << "  spell(s) learnt, ";
+         if (gold > 0)
+         {
+             msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+         }
+         if (silver > 0)
+         {
+             msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+         }
+         msg << totalCost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t spent.";
+
+         TellMaster(msg.str());
+
+         m_bot->GetPlayerbotAI()->GetClassAI()->LoadSpells();
+
+    }
+    else if (text == "train list")
+    {
+         Unit *unit = m_master->GetSelectedUnit();
+
+         if (!unit)
+         {
+             TellMaster("Please select the trainer which I should learn  from!");
+             return;
+         }
+         if (!unit->isTrainer())
+         {
+             TellMaster("This is not a trainer!");
+             return;
+         }
+
+         Creature *creature =  m_bot->GetMap()->GetCreature(m_master->GetSelection());
+         if(!creature->isCanTrainingOf(m_bot, false))
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         CreatureTemplate const *creatureInfo = creature->GetCreatureInfo();
+
+         if (!creatureInfo)
+         {
+             TellMaster("This trainer can not train me anything at  all!");
+             return;
+         }
+
+         TrainerSpellData const* trainer_spells =  creature->GetTrainerSpells();
+         if(!trainer_spells)
+         {
+             TellMaster("No training spells can be found from this  trainer");
+             return;
+         }
+         // reputation discount
+         float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+         bool can_learn_primary_prof =  m_bot->GetFreePrimaryProfessionPoints() > 0;
+
+         std::ostringstream msg;
+         msg << "The spells I can learn and their costs are:\n";
+         uint32 totalCost = 0;
+         int loc = m_master->GetSession()->GetSessionDbcLocale();
+         for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+         {
+             TrainerSpell const* tSpell = &itr->second;
+
+             bool valid = true;
+             bool primary_prof_first_rank = false;
+             for (uint8 i = 0; i < MAX_SPELL_EFFECTS ; ++i)
+             {
+                 if (!tSpell->learnedSpell[i])
+                     continue;
+                  if(!m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[i]))
+                 {
+                     valid = false;
+                     break;
+                 }
+                 if  (sSpellMgr->GetSpellInfo(tSpell->learnedSpell[i])->IsPrimaryProfessionFirstRank())
+                     primary_prof_first_rank = true;
+             }
+             if (!valid)
+                 continue;
+
+             TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+             if (state != TRAINER_SPELL_GREEN)
+             {
+                 continue;
+             }
+             //data << uint32(primary_prof_first_rank &&  can_learn_primary_prof ? 1 : 0);
+             uint32 spellId = tSpell->spell;
+             const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+             if (!pSpellInfo)
+             {
+                 continue;
+             }
+             uint32 cost = (uint32) (floor(tSpell->spellCost *  fDiscountMod));
+             totalCost = totalCost + cost;
+
+             uint32 gold = uint32(cost / 10000);
+             cost -= (gold * 10000);
+             uint32 silver = uint32(cost / 100);
+             cost -= (silver * 100);
+             msg << " |cffffffff|Hspell:" << spellId <<  "|h[" << pSpellInfo->SpellName[loc] << "]|h|r" <<  ", ";
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << cost <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+         }
+         uint32 moneyDiff = m_bot->GetMoney() - totalCost;
+         if (moneyDiff >= 0)
+         {
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t left.";
+             }
+         else
+         {
+             moneyDiff = moneyDiff * (-1);
+             uint32 gold = uint32(moneyDiff / 10000);
+             moneyDiff -= (gold * 10000);
+             uint32 silver = uint32(moneyDiff / 100);
+             moneyDiff -= (silver * 100);
+             msg << "I need ";
+             if (gold > 0)
+             {
+                 msg << gold <<  "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+             }
+             if (silver > 0)
+             {
+                 msg << silver <<  "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+             }
+             msg << moneyDiff <<  "|TInterface\\Icons\\INV_Misc_Coin_05:16|t more to learn all the  spells!";
+         }
+         TellMaster(msg.str());
+
+    }
+ else if(text.size() >= 4 && text.substr(0, 4) == "sell")
+    {
+        Unit *unit = m_master->GetSelectedUnit();
+
+        if (!unit)
+        {
+            TellMaster("Please show me who I should trade with!");
+            return;
+        }
+        if (!unit->isVendor())
+        {
+            TellMaster("This person does not want to trade with me!");
+            return;
+        }
+        if (!m_bot->IsInMap((WorldObject*) unit))
+        {
+            TellMaster("I'm too far away to sell items!");
+            return;
+        }
+        uint32 TotalCost = 0;
+        uint32 TotalSold = 0;
+        std::ostringstream report;
+
+        std::list<uint32> itemIds;
+        std::list<Item *> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInInv(itemIds, itemList);
+        for(std::list<Item *>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        {
+            if ((**it).GetTemplate()->SellPrice > 0)
+            {
+                int32 cost = (**it).GetCount() * (**it).GetTemplate()->SellPrice;
+                m_bot->ModifyMoney(cost);
+                m_bot->MoveItemFromInventory((**it).GetBagSlot(), (**it).GetSlot(), true);
+
+                TotalSold = TotalSold + 1;
+                TotalCost = TotalCost + cost;
+
+                if ((**it).GetCount() > 0) {
+                    report << "Sold " << (**it).GetCount() << "x";
+                    report << " |cffffffff|Hitem:" << (**it).GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << (**it).GetTemplate()->Name1 << "]|h|r";
+                    report << " for ";
+
+                    uint32 gold = uint32(cost / 10000);
+                    cost -= (gold * 10000);
+                    uint32 silver = uint32(cost / 100);
+                    cost -= (silver * 100);
+
+                    if (gold > 0)
+                    {
+                        report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+                    }
+                    if (silver > 0)
+                    {
+                        report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+                    }
+                    report << cost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t\n";
+                }
+            }
+        }
+        if (TotalSold > 0) {
+            report << "Sold total " << TotalSold << " item(s) for ";
+
+            uint32 gold = uint32(TotalCost / 10000);
+            TotalCost -= (gold * 10000);
+            uint32 silver = uint32(TotalCost / 100);
+            TotalCost -= (silver * 100);
+
+            if (gold > 0)
+            {
+                report << gold << "|TInterface\\Icons\\INV_Misc_Coin_01:16|t";
+            }
+            if (silver > 0)
+            {
+                report << silver << "|TInterface\\Icons\\INV_Misc_Coin_03:16|t";
+            }
+            report << TotalCost << "|TInterface\\Icons\\INV_Misc_Coin_05:16|t.";
+            TellMaster(report.str());
+        }
+    }
+
+ else if (text.size() > 2 && text.substr(0, 2) == "g " || text.size() > 4 && text.substr(0, 4) == "get ")
+ {
+     uint32 guid;
+     float x,y,z;
+     uint32 entry;
+     int mapid;
+     if (extractGOinfo(text, guid, entry, mapid, x, y, z))
+     {
+         sLog->outDebug(LOG_FILTER_NETWORKIO, "find: guid : %u entry : %u x : (%f) y : (%f) z : (%f) mapid : %d",guid, entry, x, y, z, mapid);
+         m_lootCurrent = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+         GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+         if (!go)
+         {
+             m_bot->Say("I can't find it.", LANG_UNIVERSAL);
+             m_lootCurrent = 0;
+             return;
+         }
+
+         if ( !go->isSpawned() ) {
+             m_bot->Say("It is not there anymore.", LANG_UNIVERSAL);
+             return;
+         }
+
+         m_bot->UpdateGroundPositionZ(x,y,z);
+         m_bot->GetMotionMaster()->MovePoint( mapid, x, y, z );
+         m_bot->UpdatePosition(x, y, z, m_bot->GetOrientation());
+         m_bot->SendLoot( m_lootCurrent, LOOT_CORPSE );
+         Loot *loot = &go->loot;
+         uint32 lootNum = loot->GetMaxSlotInLootFor( m_bot );
+
+         sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: GetGOType %u - %s looting: '%s' got %d items", go->GetGoType(), m_bot->GetName(), go->GetGOInfo()->name, loot->GetMaxSlotInLootFor( m_bot ));
+         for ( uint32 l=0; l<lootNum; l++ )
+         {
+             QuestItem *qitem=0, *ffaitem=0, *conditem=0;
+             LootItem *item = loot->LootItemInSlot( l, m_bot, &qitem, &ffaitem, &conditem );
+             if ( !item )
+                 continue;
+
+             if ( !qitem && item->is_blocked )
+             {
+                 m_bot->SendLootRelease( m_lootCurrent );
+                 continue;
+             }
+
+             if ( m_needItemList[item->itemid]>0 )
+             {
+                 ItemPosCountVec dest;
+                 if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count ) == EQUIP_ERR_OK )
+                 {
+                     Item * newitem = m_bot->StoreNewItem( dest, item->itemid, true, item->randomPropertyId);
+                     if ( qitem )
+                     {
+                         qitem->is_looted = true;
+                         if ( item->freeforall || loot->GetPlayerQuestItems().size() == 1 )
+                             m_bot->SendNotifyLootItemRemoved( l );
+                         else
+                             loot->NotifyQuestItemRemoved( qitem->index );
+                     }
+                     else
+                     {
+                         if ( ffaitem )
+                         {
+                             ffaitem->is_looted=true;
+                             m_bot->SendNotifyLootItemRemoved( l );
+                         }
+                         else
+                         {
+                             if ( conditem )
+                                 conditem->is_looted=true;
+                             loot->NotifyItemRemoved( l );
+                         }
+                     }
+                     if (!item->freeforall)
+                         item->is_looted = true;
+                     --loot->unlootedCount;
+                     m_bot->SendNewItem( newitem, uint32(item->count), false, false, true );
+
+                     m_bot->GetAchievementMgr().UpdateAchievementCriteria( ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count );
+                 }
+             }
+             uint32 lockId = go->GetGOInfo()->GetLockId();
+             LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+             if(lockInfo)
+             {
+                 uint32 skillId = SkillByLockType(LockType(lockInfo->Index[0]));
+                 switch(skillId)
+                 {
+                 case SKILL_MINING:
+                     if (m_bot->HasSkill(SKILL_MINING) && HasPick()) // Has skill & suitable pick
+                     {
+                         ItemPosCountVec dest;
+                         if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+                         {
+                             Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                             uint32 reqSkillValue = lockInfo->Skill[0];
+                             uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_MINING);
+                             if (SkillValue >= reqSkillValue)
+                             {
+                                 m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                 m_bot->UpdateGatherSkill(SKILL_MINING, SkillValue, reqSkillValue);
+                                 --loot->unlootedCount;
+                             }
+                         }
+                     }
+                     break;
+                 case SKILL_HERBALISM:
+                     if (m_bot->HasSkill(SKILL_HERBALISM)) // Has skill
+                     {
+                         ItemPosCountVec dest;
+                         if ( m_bot->CanStoreNewItem( NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK )
+
+                         {
+                             Item* pItem = m_bot->StoreNewItem (dest,item->itemid,true,item->randomPropertyId);
+                             uint32 reqSkillValue = lockInfo->Skill[0];
+                             uint32 SkillValue = m_bot->GetPureSkillValue(SKILL_HERBALISM);
+                             if (SkillValue >= reqSkillValue)
+                             {
+                                 m_bot->SendNewItem(pItem, uint32(item->count), false, false, true);
+                                 m_bot->UpdateGatherSkill(SKILL_HERBALISM, SkillValue, reqSkillValue);
+                                 --loot->unlootedCount;
+                             }
+                         }
+                     }
+                     break;
+                 }
+             }
+         }
+         // release loot
+         m_bot->GetSession()->DoLootRelease( m_lootCurrent );
+
+         // clear movement target, take next target on next update
+         m_bot->GetMotionMaster()->Clear();
+         m_bot->GetMotionMaster()->MoveIdle();
+         sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent );
+         SetQuestNeedItems();
+     }
+     else
+         SendWhisper("I have no info on that object", fromPlayer);
+ }
+
+ else if (text == "survey")
+ {
+      float distance = 100.0f;
+      uint32 count = 0;
+      std::ostringstream detectout;
+
+      QueryResult result = WorldDatabase.PQuery("SELECT guid, id, position_x, position_y, position_z, map, "
+        "(POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) AS order_ "
+        "FROM gameobject WHERE map='%u' AND (POW(position_x - '%f', 2) + POW(position_y - '%f', 2) + POW(position_z - '%f', 2)) <= '%f' ORDER BY order_",
+         m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(),
+         m_bot->GetMapId(), m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), distance*distance);
+
+      if (result)
+      {
+         do
+         {
+             Field *fields = result->Fetch();
+             uint32 guid = fields[0].GetUInt32();
+             uint32 entry = fields[1].GetUInt32();
+             float x = fields[2].GetFloat();
+             float y = fields[3].GetFloat();
+             float z = fields[4].GetFloat();
+             int mapid = fields[5].GetUInt16();
+
+             GameObjectTemplate const * goinfo = sObjectMgr->GetGameObjectTemplate(entry);
+
+             if(!goinfo)
+                 continue;
+
+             uint64 objGuid = MAKE_NEW_GUID(guid, entry, HIGHGUID_GAMEOBJECT);
+             GameObject *go = m_bot->GetMap()->GetGameObject(objGuid);
+             if ( !go || (go && !go->isSpawned()) ) continue;
+
+             if(count < 12) // count, limits number of links
+                  detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry << ":" << x << ":" << y << ":" << z  << ":" << mapid  << ":" <<  "|h[" << goinfo->name << "]|h|r";
+             ++count;
+         } while (result->NextRow());
+
+      }
+      SendWhisper(detectout.str().c_str(), fromPlayer);
+    }
+
+    else if (text == "pull")
+    {
+        m_bot->GetPlayerbotAI()->GetClassAI()->Pull();
+    }
+    else if(text == "help")
+    {
+        std::string msg;
+        if (m_bot->getClass() == CLASS_ROGUE)
+            msg = "The commands I respond to are \n follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se,\n(q)uests, accept quest <hlink>, abandon quest <hlink>\npoison [main | off].\ntrain list";
+        else
+            msg = "The commands I respond to are \n follow, stay, (c)ast <spellname>, spells, (e)quip, (u)se,\n(q)uests, accept quest <hlink>, abandon quest <hlink>\ntrain list.";
+
+        SendWhisper(msg, fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+      else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            uint64 questRewarderGUID = m_bot->GetSelection();
+            Object* const pNpc = ObjectAccessor::GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.GetMenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.QuestId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    ! m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                {
+                    for (uint8 rewardIdx=0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+}
+
+void PlayerbotAI::SetLooting(bool looting)
+{
+    isLooting = looting;
+}
+
+void PlayerbotAI::AddLootGUID(uint64 guid) {
+    m_lootCreature.push_back(guid);
+}
+
+bool PlayerbotAI::DoLoot()
+{
+    if(!m_lootCurrent && m_lootCreature.empty())
+    {
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s reset loot list / go back to idle", m_bot->GetName());
+//        SetQuestNeedItems();
+        isLooting = false;
+        return false;
+    }
+
+    if(m_bot->isDead())
+    {
+        isLooting = false;
+        return false;
+    }
+
+    if(!m_lootCurrent)
+    {
+        m_lootCurrent = m_lootCreature.front();
+
+        if(!m_lootCurrent)
+        {
+            //sLog->outError("PlayerbotAI::DoLoot() error location #1, please report this error immediately!");
+            return false;
+        }
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && c->isAlive())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s got loot target 0x%08X", m_bot->GetName(), m_lootCurrent);
+        Position pos;
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE)){ //Verify if the bot it close to a loot.
+
+            m_lootCreature.pop_front();
+            object->GetPosition(&pos);
+            //m_bot->GetMotionMaster()->MovePoint(object->GetMapId(), (const Position &)(pos));
+
+        } else { //Rotate the loot to very if one is not near the bot.
+
+            m_lootobjtemp = m_lootCreature.front();
+            m_lootCreature.pop_front();
+            m_lootCreature.push_back(m_lootobjtemp);
+            m_lootCurrent = 0;
+        }
+        return true;
+
+    } else {
+
+        Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+        GameObject *o = m_bot->GetMap()->GetGameObject( m_lootCurrent );
+        if(!c && !o)
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false;
+        }
+        if(c && c->isAlive())
+        {
+            m_lootCurrent = 0;
+            isLooting = false;
+            return false; //not dead yet
+        }
+
+        WorldObject *object;
+        if (c) object = c;
+        else object = o;
+
+        if(m_bot->IsWithinDistInMap(object, INTERACTION_DISTANCE))
+        {
+            //check for needed items
+            m_bot->SendLoot(m_lootCurrent, LOOT_CORPSE);
+
+            Loot *loot;
+            if (c)
+                loot = &c->loot;
+            else
+                loot = &o->loot;
+
+            assert(loot);
+
+            uint32 lootNum = loot->GetMaxSlotInLootFor(m_bot);
+//sLog->outError("[PlayerbotAI]: %s loot target 0x%08X got %d items", m_bot->GetName(), m_lootCurrent, loot->GetMaxSlotInLootFor(m_bot));
+
+            for(uint32 l = 0; l < lootNum; ++l)
+            {
+                QuestItem *qitem = 0, *ffaitem = 0, *conditem = 0;
+                LootItem *item = loot->LootItemInSlot(l, m_bot, &qitem, &ffaitem, &conditem);
+                if(!item) continue;
+                if(!qitem && item->is_blocked)
+                {
+                    m_bot->SendLootRelease(m_bot->GetLootGUID());
+                    continue;
+                }
+
+                if(m_needItemList[item->itemid] > 0)
+                {
+//sLog->outError("[PlayerbotAI]: %s LOOT needed item 0x%04X", m_bot->GetName(), item->itemid);
+                    ItemPosCountVec dest;
+                    if(m_bot->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, item->itemid, item->count) == EQUIP_ERR_OK)
+                    {
+                        Item *newitem = m_bot->StoreNewItem(dest, item->itemid,true, item->randomPropertyId);
+                        if(qitem)
+                        {
+                            qitem->is_looted = true;
+                            if(item->freeforall ||loot->GetPlayerQuestItems().size() == 1)
+                                m_bot->SendNotifyLootItemRemoved(l);
+                            else
+                                loot->NotifyQuestItemRemoved(qitem->index);
+                        }
+                        else if(ffaitem)
+                        {
+                            ffaitem->is_looted = true;
+                            m_bot->SendNotifyLootItemRemoved(l);
+                        } else {
+                            if(conditem) conditem->is_looted = true;
+                            loot->NotifyItemRemoved(l);
+                        }
+                        if(!item->freeforall) item->is_looted = true;
+                        --(loot->unlootedCount);
+                        m_bot->SendNewItem(newitem, uint32(item->count), false,false, true);
+                        m_bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_LOOT_ITEM, item->itemid, item->count);
+
+                        std::ostringstream out;
+                        PlayerbotChatHandler ch(m_master);
+                        out << m_bot->GetName() << " needs " << m_needItemList[item->itemid]-1 << " more.";
+                        ch.sysmessage(out.str().c_str());
+                        m_ignoreAIUpdatesUntilTime = time(0);
+                    }
+                }
+            }
+            //release loot
+            if(uint64 lguid = m_bot->GetLootGUID() && m_bot->GetSession())
+                m_bot->GetSession()->DoLootRelease(lguid);
+            else if(!m_bot->GetSession())
+                sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s has no session. Cannot releaseloot!", m_bot->GetName());
+
+            //clear movement target, take next target on next update
+            //m_bot->GetMotionMaster()->Clear();
+            //m_bot->GetMotionMaster()->MoveIdle();
+            sLog->outDebug(LOG_FILTER_NETWORKIO, "[PlayerbotAI]: %s looted target 0x%08X", m_bot->GetName(), m_lootCurrent);
+            m_lootCurrent = 0;
+            m_ignoreAIUpdatesUntilTime = time(0);
+            isLooting = false;
+        } else { //keep moving till we get there
+            //Position pos;
+
+            if (c) {
+                //c->GetPosition(&pos);
+                //m_bot->GetMotionMaster()->MovePoint(c->GetMapId(), (const Position &)(pos));
+            } else {
+                //o->GetPosition(&pos);
+                //m_bot->GetMotionMaster()->MovePoint(o->GetMapId(), (const Position &)(pos));
+            }
+
+        }
+    }
+    return false;
+} //end DoLoot
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    //reset values first
+    m_needItemList.clear();
+    m_lootCreature.clear();
+    m_lootCurrent = 0;
+
+    //run through accepted quests, get quest infoand data
+    for(QuestStatusMap::iterator iter=m_bot->getQuestStatusMap().begin(); iter!=m_bot->getQuestStatusMap().end(); ++iter)
+    {
+        const Quest *qInfo = sObjectMgr->GetQuestTemplate(iter->first);
+        if(!qInfo) continue;
+        QuestStatusData *qData = &iter->second;
+
+        //only check quest if it is incomplete
+        if(qData->m_status != QUEST_STATUS_INCOMPLETE) continue;
+
+        //check for items we not have enough of
+        for(uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if(!qInfo->RequiredItemCount[i] || (qInfo->RequiredItemCount[i]-qData->m_itemcount[i]) <= 0) continue;
+            m_needItemList[qInfo->RequiredItemId[i]] = (qInfo->RequiredItemCount[i]-qData->m_itemcount[i]);
+        }
+    }
+}//end SetQuestNeedItems
+
+//Localization support
+void PlayerbotAI::ItemLocalization(std::string &itemName, const uint32 itemID) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if(pItemInfo)
+    {
+        if(pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if(Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::QuestLocalization(std::string &questTitle, const uint32 questID) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if(pQuestInfo)
+    {
+        if(pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if(Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+    }
+}
+
+void PlayerbotAI::TurnInQuests( WorldObject *pNpc )
+{
+
+    uint64 npcGUID = pNpc->GetGUID();
+    if (!m_bot->IsInMap((WorldObject*) pNpc))
+        m_bot->GetPlayerbotAI()->TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(npcGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(npcGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.QuestId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (! m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, pNpc, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemTemplate const *pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                        {
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+
+                    // else multiple rewards - let master pick
+                    else {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i=0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE) {
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+            }
+
+//            else if (status == QUEST_STATUS_AVAILABLE){
+  //              out << "|cff00ff00Quest available:|r "
+//                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+//            }
+
+            if (! out.str().empty())
+                m_bot->GetPlayerbotAI()->TellMaster(out.str());
+        }
+    }
+} // TurnInQuests
+
+
+ void PlayerbotAI::SetCombatOrder (CombatOrderType orders)
+ {
+    m_combatOrder = orders;
+ }
diff --git a/src/server/game/AI/Bots/PlayerbotAI.h b/src/server/game/AI/Bots/PlayerbotAI.h
new file mode 100644
index 0000000..ac908f1
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotAI.h
@@ -0,0 +1,284 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Common.h"
+
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+class PlayerbotClassAI;
+
+enum ScenarioType
+{
+    SCENARIO_PVEEASY,
+    SCENARIO_PVEHARD,
+    SCENARIO_DUEL,
+    SCENARIO_PVPEASY,
+    SCENARIO_PVPHARD
+};
+
+//masters orders that should be obeyed by the AI during the updteAI routine
+//the master will auto set the target of the bot
+enum CombatOrderType
+{
+    ORDERS_NONE,
+    ORDERS_KILL,
+    ORDERS_CC,
+    ORDERS_HEAL,
+    ORDERS_TANK,
+    ORDERS_PROTECT,
+    ORDERS_REGEN
+};
+
+typedef std::set<Unit *> AttackerInfoList;
+
+class PlayerbotAI
+{
+public:
+    //******* Stuff the outside world calls ****************************
+    PlayerbotAI(Player *const master, Player *const bot);
+    virtual ~PlayerbotAI();
+
+    //This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    //This is called from ChatHandler.cpp when there is an incoming message to the bot
+    //from a whisper or from the party channel
+    void HandleCommand(const std::string &text, Player &fromPlayer);
+
+    //This is called by WorldSession.pm
+    //It provides a view of packets normally sent to the client.
+    //Since there is no client at the other end, the packets are dropped of course.
+    //For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket &packet);
+
+    //This is called whenever the master sends a packet to the server.
+    //These packets can be viewed, but not edited.
+    //It allows bot creators to craft AI in response to a master's actions.
+    //For a list of opcodes that can be caught see Opcodes.cpp (CMSG_* opcodes only)
+    //Notice: that this is static which means it is called once for all bots of the master.
+    static void HandleMasterIncomingPacket(const WorldPacket &packet, WorldSession &masterSession);
+    static void HandleMasterOutgoingPacket(const WorldPacket &packet, WorldSession &masterSession);
+
+    //Returns what kind of situation we are in so the AI can react accordingly
+    ScenarioType GetScenarioType(){ return m_ScenarioType; }
+
+    PlayerbotClassAI *GetClassAI(){ return m_classAI; }
+
+    //protected:
+
+    //******* Utilities ***************************************************
+
+    //finds spell ID for matching substring args
+    //in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char *args, bool master=false) const;
+    //Main PlayerBot spell finding function Returns ONLY exact matches including Upper/Lower case differentiation.
+    uint32 getSpellIdExact(const char *args, bool includePassive=false, bool master=false);
+
+    // finds quest ID for matching substring args
+    uint32 getQuestId(const char* args, bool remove) const;
+
+    //extracts item ids from links
+    void extractItemIds(const std::string &text, std::list<uint32> &itemIds) const;
+
+    //extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string &text) const;
+
+    // extracts gameobject info from link
+    bool extractGOinfo(const std::string& text, uint32 &guid,  uint32 &entry, int &mapid, float &x, float &y, float &z) const;
+
+    // finds items in equipment and adds Item* to foundItemList
+    // also removes found item IDs from itemIdSearchList when found
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+
+    //currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player &player) const;
+
+    //get current casting spell (will return NULL if no spell!)
+    Spell *GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit *player) const;
+    bool HasAura(const char *spellName, const Unit *player) const;
+    bool HasAura(const char *spellName) const;
+    void HandleTeleportAck();
+
+    bool HasPick();
+
+    uint8 GetHealthPercent(const Unit &target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit &target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit &target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit &target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit &target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit &target) const;
+    uint8 GetRunicPower() const;
+
+    Item *FindFood() const;
+    Item *FindDrink() const;
+    Item *FindPotion() const;
+    Item *FindBandage() const;
+    Item *FindPoisonForward() const;    // finds poison starting from the front
+    Item *FindPoisonBackward() const;   // finds poison starting from the back
+
+    void UseMount() const;
+
+    //******* Actions ****************************************
+    //Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string &text);
+    void SendWhisper(const std::string &text, Player &player);
+    bool CastSpell(const char *args);
+    //Player bots main spell cast function, if checkFirst > performs canCast() first, if castExistingAura > performs the cast even if the aura exists on target,
+    //if skipFriendlyCheck > do not perform spell positive/negative and target friendly/hostile checks (Useful for dual purpose spells like holy shock)
+    virtual bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    virtual bool CastSpell(const SpellInfo * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+    //Simple Checks to determine if the bot can cast the spell or not...
+    //Mana/Stance/EquipmentRequirement/Distance/TargetInFront/OverwriteOrStackExistingAura/FriendlyFire checks
+    virtual bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    virtual bool CanCast(const SpellInfo * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+    //Gets the current form/stance of player
+    uint8 GetForm(Unit *pPlayer=NULL);
+    void UseItem(Item &item);
+    void PoisonWeapon(Item &item, uint32 spellid=0, uint32 target=0, EquipmentSlots weapon=EQUIPMENT_SLOT_MAINHAND);
+    void EquipItem(Item &item);
+    void Stay();
+    bool Follow(Player &player);
+    void SendNotEquipList(Player &player);
+    void Feast();
+    void SetLooting(bool looting);
+    void InterruptCurrentCastingSpell();
+    void GetCombatOrders();
+    void DoNextCombatManeuver();
+    void KilledMonster(uint32 entry, uint64 guid);
+    void ItemLocalization(std::string &itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string &questTitle, const uint32 questID) const;
+
+    uint32 GetAttackerCount(){ return m_attackerInfo.size(); }
+    void SetIgnoreUpdateTime(float t){m_ignoreAIUpdatesUntilTime=getMSTime() + (t * 1000); };
+
+    Player *GetPlayerBot(){ return m_bot; }
+    void SetInFront(const Unit *obj);
+
+    bool CanBotsFly();  // take the flight path?
+    uint32 GetStartMapID() { return m_startMapID; };
+    uint32 GetStartZoneID() { return m_startZoneID; };
+    uint32 GetStartAreaID() { return m_startAreaID; };
+    uint32 GetStartPhase() { return m_startPhase; };
+    uint32 GetStartDifficulty() { return m_startDifficulty; };
+    uint32 GetStartInstanceID() { return m_startInstanceID; };
+    float GetStartX() { return m_startX; };
+    float GetStartY() { return m_startY; };
+    float GetStartZ() { return m_startZ; };
+    float GetStartO() { return m_startO; };
+
+    void SetStartMapID(uint32 mapID) { m_startMapID = mapID; };
+    void SetStartZoneID(uint32 zoneID) { m_startZoneID = zoneID; };
+    void SetStartAreaID(uint32 areaID) { m_startAreaID = areaID; };
+    void SetStartPhase(uint32 phase) { m_startPhase = phase; };
+    void SetStartDifficulty(uint32 difficulty) { m_startDifficulty = difficulty; };
+    void SetStartInstanceID(uint32 instanceID) { m_startInstanceID = instanceID; };
+    void SetStartX(float x) { m_startX = x; };
+    void SetStartY(float y) { m_startY = y; };
+    void SetStartZ(float z) { m_startZ = z; };
+    void SetStartO(float o) { m_startO = o; };
+
+    void AddLootGUID(uint64 guid);
+    void SetCombatOrder (CombatOrderType orders);
+
+private:
+
+    //****** Closed Actions ********************************
+    //These actions may only be called at special times.
+    //Trade methods are only applicable when the trade window is open
+    //and are only called from within HandleCommand.
+    // submits packet to trade an item (trade window must already be open)
+
+    // default slot is -1 which means trade slots 0 to 5. if slot is set
+    // to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+    // 'Will not be traded' slot.
+    bool TradeItem(const Item& item, int8 slot=-1);
+
+    bool TradeCopper(uint32 copper);
+
+    //it is safe to keep these back reference pointers because m_bot
+    //owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player *const m_master;
+    Player *const m_bot;
+    PlayerbotClassAI *m_classAI;
+
+    //ignores AI updates until time specified
+    //no need to waste CPU cycles during casting etc
+    uint32 m_ignoreAIUpdatesUntilTime;
+
+    CombatOrderType m_combatOrder;
+
+    ScenarioType m_ScenarioType;
+    typedef std::set<Unit *> AttackerSet;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    time_t m_TimeRessurect;
+    uint32 m_CurrentlyCastingSpellId;
+    bool m_IsFollowingMaster;
+
+    //if master commands bot to do something, store here until updateAI
+    //can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+
+    //finds who to attack next
+    Unit *getNextTarget(Unit *victim);
+
+    /* -- Loot routines by runsttren */
+    bool DoLoot();
+    void SetQuestNeedItems();
+
+    void TurnInQuests( WorldObject *questgiver );
+
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::list<uint64> BotLootCreature;
+    typedef std::map<uint32, std::string> BotQuestsSeen;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needItemList;
+
+    //list of items needed to fullfill quests
+    BotNeedItem m_needEmblemList;
+
+    //list of quests recently seen that we can accept
+    BotQuestsSeen m_questsSeen;
+
+    //list of creatures we recently attacked and want to loot
+    BotLootCreature m_lootCreature; //list of creatures
+    uint64 m_lootCurrent; //current remains of interest
+    uint64 m_lootobjtemp;
+    bool isLooting;
+    AttackerInfoList m_attackerInfo;
+
+    float m_followDistanceMin, m_followDistanceMax;
+    int m_playerBotsFly;
+
+    uint32 m_startMapID;
+    uint32 m_startZoneID;
+    uint32 m_startAreaID;
+    uint32 m_startPhase;
+    uint32 m_startDifficulty;
+    uint32 m_startInstanceID;
+    float m_startX;
+    float m_startY;
+    float m_startZ;
+    float m_startO;
+
+    uint32 m_FeastSpamTimer;
+};
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotClassAI.cpp b/src/server/game/AI/Bots/PlayerbotClassAI.cpp
new file mode 100644
index 0000000..2cdc3ef
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotClassAI.cpp
@@ -0,0 +1,599 @@
+/*
+Name :    PlayerbotClassAI.cpp
+Notes:    Does not really work with peldor's own classbot AIs
+        Contains many improvements and hacks to overcome some difficulites
+Known
+Problems:    - Contains hardcoded values,  for an example check group heal, individual heal decision
+            - ai->getSpellIdExact func, *although works more accurately* is probably slower and hackish
+            - FindMainTankRaid func, includes a db query making it a resource hog
+            - canCast func, does not check for every possible problem, can cause AI stuck.. Should be inside PlayerbotAI class
+            - castSpell func is redundant and should be placed in PlayerbotAI class, sets private variable m_ai->m_CurrentlyCastingSpellId which is made public as a hack..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotClassAI.h"
+#include "Common.h"
+#include "Spell.h"
+#include "Group.h"
+
+PlayerbotClassAI::PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai): m_master(master), m_bot(bot), m_ai(ai), rezSpamTimer(0)
+{
+    threatThreshold = 75;            // Threat % threshold for dps to lower tps
+    offensiveSpellThreshold = 70;    // Mana % threshold for healers to use offensive spells
+
+    // first aid
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // RACIALS
+    R_ARCANE_TORRENT = ai->getSpellIdExact("Arcane Torrent");
+    R_BERSERKING = ai->getSpellIdExact("Berserking");
+    R_BLOOD_FURY = ai->getSpellIdExact("Blood Fury");
+    R_CANNIBALIZE = ai->getSpellIdExact("Cannibalize");
+    R_ESCAPE_ARTIST = ai->getSpellIdExact("Escape Artist");
+    R_EVERY_MAN_FOR_HIMSELF = ai->getSpellIdExact("Every Man for Himself");
+    R_GIFT_OF_NAARU = ai->getSpellIdExact("Gift of the Naaru");
+    R_SHADOWMELD = ai->getSpellIdExact("Shadowmeld");
+    R_STONEFORM = ai->getSpellIdExact("Stoneform");
+    R_WAR_STOMP = ai->getSpellIdExact("War Stomp");
+    R_WILL_OF_FORSAKEN = ai->getSpellIdExact("Will of the Forsaken");
+
+    mainTank = NULL;
+    m_pulling = false;
+}
+PlayerbotClassAI::~PlayerbotClassAI(){}
+
+void PlayerbotClassAI::DoNextCombatManeuver(Unit *){}
+
+void PlayerbotClassAI::DoNonCombatActions(){}
+
+void PlayerbotClassAI::LoadSpells(){}
+
+void PlayerbotClassAI::Pull(){}
+
+bool PlayerbotClassAI::BuffPlayer(Unit *target){ return false; }
+
+bool PlayerbotClassAI::FindMount(){ return true; }
+
+bool PlayerbotClassAI::Unmount(){ return true; }
+
+bool PlayerbotClassAI::HealTarget (Unit *target, uint8 hp){ return false; }
+
+bool PlayerbotClassAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal){ return false; }
+
+bool PlayerbotClassAI::CureTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::RezTarget (Unit *target){ return false; }
+
+bool PlayerbotClassAI::IsMounted(){ return m_bot->IsMounted(); }
+
+bool PlayerbotClassAI::CastSpell(uint32 spellId, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(spellId, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered); }
+bool PlayerbotClassAI::CastSpell(const SpellInfo * pSpellInfo, Unit *target, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck, bool triggered)
+{return m_ai->CastSpell(pSpellInfo, target, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck, triggered);}
+
+bool PlayerbotClassAI::CanCast(uint32 spellId, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(spellId, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::CanCast(const SpellInfo * pSpellInfo, Unit *target, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{return m_ai->CanCast(pSpellInfo, target, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck);}
+
+bool PlayerbotClassAI::listAuras(Unit *u)
+{
+    int loc = 0;
+    Unit *target = u;
+    typedef std::pair<uint32, uint8> spellEffectPair;
+    typedef std::multimap< spellEffectPair, Aura*> AuraMap;
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellInfo const *spellInfo = (*itr).second->GetSpellInfo();
+        const SpellInfo *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        sLog->outDebug(LOG_FILTER_NETWORKIO, "aura = %u %s", spellInfo->Id, name.c_str());
+    }
+    return true;
+};//end listAuras
+
+bool PlayerbotClassAI::HasAuraName (Unit *unit, uint32 spellId, uint64 casterGuid)
+{
+    const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if(!pSpellInfo) return false;
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if(name.length() == 0) return false;
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool PlayerbotClassAI::HasAuraName (Unit *target, std::string spell, uint64 casterGuid)
+{
+    int loc = m_bot->GetSession()->GetSessionDbcLocale();
+    typedef std::pair<uint32, uint8>spellEffectPair;
+    typedef std::multimap<spellEffectPair, Aura*>AuraMap;
+
+    Unit::AuraMap &vAuras = target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        //SpellInfo const *spellInfo = (*itr).second->GetSpellInfo();
+        const SpellInfo *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if(!spell.compare(name))
+        //if(!strcmp(name.c_str(),spell.c_str()))
+        {
+            if(casterGuid == 0) //don't care who casted it
+                return true;
+            else if(casterGuid == itr->second->GetCasterGUID()) //only if correct caster casted it
+                return true;
+        }
+    }
+    return false;
+};
+
+bool PlayerbotClassAI::castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst, bool castExistingAura, bool skipFriendlyCheck, bool skipEquipStanceCheck)
+{
+    if (dispelSpell == 0 || !dTarget ) return false;
+    //if (!canCast(dispelSpell, dTarget, true)) return false; //Needless cpu cycles wasted, usually a playerbot can cast a dispell
+    const SpellInfo *dSpell = sSpellMgr->GetSpellInfo(dispelSpell);
+    if (!dSpell) return false;
+
+    for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+    {
+        if (dSpell->Effects[i].Effect != (uint32)SPELL_EFFECT_DISPEL) continue;
+        uint32 dispel_type = dSpell->Effects[i].MiscValue;
+        uint32 dispelMask  = SpellInfo::GetDispelMask(DispelType(dispel_type));
+        Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura * aura = itr->second;
+            AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+            if (!aurApp)
+                continue;
+
+            if ((1<<aura->GetSpellInfo()->Dispel) & dispelMask)
+            {
+                if(aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+                {
+                    bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE)) : false;
+
+                    // do not remove positive auras if friendly target
+                    //               negative auras if non-friendly target
+                    if(positive == dTarget->IsFriendlyTo(GetPlayerBot()))
+                        continue;
+                }
+                // If there is a successfull match return, else continue searching.
+                if (CastSpell(dSpell, dTarget, checkFirst, castExistingAura, skipFriendlyCheck, skipEquipStanceCheck)) { return true; }
+            }
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::castSelfCCBreakers (uint32 castList[])
+{
+    uint32 dispelSpell = 0;
+    Player *dTarget = GetPlayerBot();
+
+
+            /* dispelSpell = (uint32) R_ESCAPE_ARTIST; // this is script effect,
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp)
+                    continue;
+
+                if ( ( aura->GetSpellInfo()->Mechanic == MECHANIC_SNARE ) || ( aura->GetSpellInfo()->Mechanic == MECHANIC_ROOT ) )
+                {
+                    if(aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_UNK7)) : false;
+
+                        // do not remove positive auras if friendly target
+                        //               negative auras if non-friendly target
+                        if(positive == dTarget->IsFriendlyTo(caster))
+                            continue;
+                    }
+                    return castSpell(dispelSpell, dTarget);
+                }
+            }
+            return false;  */
+
+        // racial abilities
+    /*  if( GetPlayerBot()->getRace() == RACE_BLOODELF && !pTarget->HasAura( ARCANE_TORRENT,0 ) && castSpell( ARCANE_TORRENT,pTarget ) ) {
+         //GetPlayerBot()->Say("Arcane Torrent!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_HUMAN && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( EVERY_MAN_FOR_HIMSELF, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("EVERY MAN FOR HIMSELF!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_UNDEAD_PLAYER && (GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_FEAR ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_CHARM )) && castSpell( WILL_OF_THE_FORSAKEN, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("WILL OF THE FORSAKEN!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_DWARF && GetPlayerBot()->HasAuraState( AURA_STATE_DEADLY_POISON ) && castSpell( STONEFORM, GetPlayerBot() ) ) {
+        //GetPlayerBot()->Say("STONEFORM!", LANG_UNIVERSAL);
+    } else if( GetPlayerBot()->getRace() == RACE_GNOME && (GetPlayerBot()->HasUnitState( UNIT_STAT_STUNNED ) || GetPlayerBot()->HasAuraType( SPELL_AURA_MOD_DECREASE_SPEED )) && castSpell( ESCAPE_ARTIST, GetPlayerBot() ) ) {
+       // GetPlayerBot()->Say("ESCAPE ARTIST!", LANG_UNIVERSAL);
+    } */
+
+    for (uint8 j = 0; j <  sizeof (castList); j++)
+    {
+        dispelSpell = castList[j];
+        if (dispelSpell == 0 || !dTarget->HasSpell(dispelSpell) || !CanCast(dispelSpell, dTarget, true)) continue;
+        SpellInfo const *dSpell = sSpellMgr->GetSpellInfo(dispelSpell);
+        if (!dSpell) continue;
+
+        for (uint8 i = 0 ; i < MAX_SPELL_EFFECTS ; ++i)
+        {
+            if (dSpell->Effects[i].Effect != (uint32)SPELL_EFFECT_DISPEL && dSpell->Effects[i].Effect != (uint32)SPELL_EFFECT_APPLY_AURA) continue;
+            if (dSpell->Effects[i].Effect == (uint32)SPELL_EFFECT_APPLY_AURA && (
+                (dSpell->Effects[i].ApplyAuraName != (uint32) SPELL_AURA_MECHANIC_IMMUNITY) ||
+                (dSpell->Effects[i].ApplyAuraName != (uint32) SPELL_AURA_DISPEL_IMMUNITY)
+                )) continue;
+
+            Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+            {
+                Aura * aura = itr->second;
+                AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+                if (!aurApp) continue;
+
+                if (aura->GetSpellInfo() && (
+                    (dSpell->Effects[i].Effect == (uint32)SPELL_EFFECT_DISPEL  && ((1<<aura->GetSpellInfo()->Dispel) & aura->GetSpellInfo()->GetDispelMask(DispelType(dSpell->Effects[i].MiscValue))) )
+                    || (dSpell->Effects[i].ApplyAuraName == (uint32) SPELL_AURA_MECHANIC_IMMUNITY && ( aura->GetSpellInfo()->GetAllEffectsMechanicMask() & ( 1 << dSpell->Effects[i].MiscValue) ) )
+                    || (dSpell->Effects[i].ApplyAuraName == (uint32) SPELL_AURA_DISPEL_IMMUNITY && ( (1<<aura->GetSpellInfo()->Dispel) & SpellInfo::GetDispelMask(DispelType(dSpell->Effects[i].MiscValue)) ) )
+                    ) )
+                {
+                    if(aura->GetSpellInfo()->Dispel == DISPEL_MAGIC)
+                    {
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE)) : false;
+                        if(positive)continue;
+                    }
+                    return CastSpell(dispelSpell, dTarget, false);
+                }
+            }
+        }
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::DoSupportRaid(Player *gPlayer, float radius, bool dResurrect, bool dGroupHeal, bool dHeal, bool dCure, bool dBuff)
+{
+    bool needHeal = false;
+    if (dGroupHeal || dHeal)
+    {
+        uint8 cntNeedHeal = 0;
+        uint8 raidHPPercent = GetHealthPercentRaid(gPlayer, cntNeedHeal);
+        if (dGroupHeal && raidHPPercent <=90 && cntNeedHeal > 1)
+        {
+            if (HealGroup(gPlayer, raidHPPercent, cntNeedHeal)) return true;
+        }
+        if (raidHPPercent < 60 ) needHeal = true;
+    }
+    //std::list<Unit*> unitList;
+    //gPlayer->GetRaidMember(unitList,30);
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return false;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Unit* tPlayer = itr->getSource();
+        if(!tPlayer || gPlayer->IsHostileTo(tPlayer)) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        if(!m_bot->IsWithinDistInMap(tPlayer, radius)) { continue; }
+        if(tPlayer->isDead()) // May be we can rez
+        {
+            if(!dResurrect) continue;
+            if(needHeal) continue; //First heal others needing heal
+            if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+            if(tPlayer->IsNonMeleeSpellCasted(true)) continue; //Already rez
+            if(RezTarget(tPlayer)) { return true; }
+            else continue;
+        }
+        if (dHeal)
+        {
+            uint8 tarHPPercent = tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+            if (tarHPPercent < 100 && HealTarget(tPlayer, tarHPPercent)) return true;
+        }
+        if (needHeal && dHeal) continue; //First heal others needing heal
+        if (dCure && CureTarget(tPlayer)) return true;
+        if (dBuff && BuffPlayer(tPlayer)) return true;
+    }
+    return false;
+}
+
+bool PlayerbotClassAI::TakePosition(Unit *followTarget, BotRole bRole, float bDist, float bMinDist, float bMaxDist, float bAngle, Unit *faceTarget)
+{
+    bool doFollow = true;
+    bool omitAngle = false;
+    bool angleIsAutoSet = false;
+    if (!bAngle) angleIsAutoSet = true;
+    if (bAngle < 0) bAngle += 2 * M_PI;
+    //if (bAngle > 2 * M_PI) bAngle -= 2 * M_PI; //Do not send values higher than 2 PI, lower than -2 PI
+    bool rval = false;
+    if (followTarget == NULL) { followTarget = GetMaster(); if (followTarget == NULL) { return false; } }
+    if (faceTarget == NULL) { faceTarget = followTarget; }
+    if (bRole == BOT_ROLE_NONE) { bRole = ( (m_role == BOT_ROLE_NONE) ? BOT_ROLE_DPS_MELEE : m_role);  }
+    //Default values
+    Unit *pVictim = followTarget->getVictim();
+    if (pVictim && pVictim->GetGUID() == m_bot->GetGUID()) //if target is attacking me
+    {
+        if (bRole == BOT_ROLE_TANK || bRole == BOT_ROLE_OFFTANK || bRole == BOT_ROLE_DPS_MELEE)
+        {
+            //Move to target
+            if (!bDist || bDist > 0.7f) bDist = 0.7f;
+            if (bMinDist < 0 || bMinDist > 1) bMinDist = 0;
+            if (bMaxDist <= 0 || bMaxDist > MELEE_RANGE) bMaxDist = MELEE_RANGE;
+            bAngle = 0;
+        }
+        else {doFollow = false;} //Do not move, creature will come
+    }
+    else
+    {
+        // calculating distance to follow
+        switch (bRole)
+        {
+            case BOT_ROLE_TANK:
+            case BOT_ROLE_OFFTANK:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0; bMaxDist = MELEE_RANGE; bAngle = 0;}
+                break;
+            case BOT_ROLE_HEALER:
+            case BOT_ROLE_SUPPORT:
+                if (!bDist) { bDist = urand(12, 14); bMinDist = 10; bMaxDist = 18; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            case BOT_ROLE_DPS_RANGED:
+                if (!bDist) { bDist = urand(18, 24); bMinDist = 10;  bMaxDist = 26; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+            default:
+                if (!bDist) { bDist = 0.7f; bMinDist = 0.1f; bMaxDist = MELEE_RANGE; bAngle = ((urand(0,1) * 90 ) + urand(110,160)) * M_PI / 180; }
+                break;
+        }
+    }
+    //Do not try to go behind if ranged and creature is not boss like
+    if (bDist > MELEE_RANGE && followTarget->GetTypeId() != TYPEID_PLAYER)
+    {
+        const CreatureTemplate *creatureInfo = ((Creature*) followTarget)->GetCreatureInfo();
+        if (!creatureInfo || creatureInfo->rank != 3) { omitAngle = true; }
+    }
+
+    //Move
+    if (doFollow)
+    {
+        float curDist = m_bot->GetDistance(followTarget);
+        if (m_pulling ||
+            (!m_bot->isMoving() &&
+            ((curDist > bMaxDist || curDist < bMinDist)  //Outside range boundries
+            || (!omitAngle && ((!followTarget->HasInArc(M_PI,m_bot)) ^ (bAngle > 0.5f * M_PI && bAngle < 1.5f * M_PI)))) )//is at right position front/behind?
+            )
+        {
+            //m_bot->GetMotionMaster()->Clear();
+            //sLog->outError("Bot[%u] is moving, curDist[%f], bDist[%f], bminDist[%f], bMaxDist[%f], bAngle[%f], InFront[%u]", m_bot->GetGUIDLow(), curDist, bDist,bMinDist, bMaxDist, bAngle, followTarget->HasInArc(M_PI,m_bot));
+            if (angleIsAutoSet && omitAngle) { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist); }
+            else { m_bot->GetMotionMaster()->MoveChase(followTarget, bDist, bAngle); }
+            rval |= true;
+        }
+    }
+    //Face your faceTarget
+    if (!m_bot->HasInArc(M_PI/16, faceTarget) && !m_bot->isMoving() ) { m_bot->SetFacingToObject(faceTarget); rval |= true; }
+    return rval;
+}
+
+uint8 PlayerbotClassAI::GetThreatPercent(Unit *pTarget, Unit *pFrom)
+{
+    uint8 tPercent = 0;
+    Unit *pVictim = pTarget->getVictim();
+    if (!pVictim) return 100; //Not Attacking anyone yet, somehow..
+    if (!pFrom) { pFrom = m_bot; }
+    if (pVictim->GetGUID() == pFrom->GetGUID()) return 100; //I'm already being attacked, too late for alert, kill it..
+    //if (m_tank->GetGUID() == m_bot->GetGUID()) {} //If I am not tank and there is a target
+
+    ThreatManager &pthreatManager = pTarget->getThreatManager();
+    float maxThreat = pthreatManager.getThreat(pTarget->getVictim()) ;
+    if (maxThreat <= 0) { return 100; } //0 threat
+    float curThreat = pthreatManager.getThreat(pFrom);
+    return (curThreat * 100 / maxThreat);
+}
+//Gets if the unit is under attack by # of attackers
+bool PlayerbotClassAI::isUnderAttack(Unit *pAttacked,const uint8 &minNumberOfAttackers)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return false; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() >= minNumberOfAttackers) { return true; }
+    return false;
+}
+
+//Gets the first found attacker of Unit
+Unit *PlayerbotClassAI::GetAttackerOf(Unit *pAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) { return NULL; } }
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+    return (*fAttackerSet.begin());
+}
+//Gets the first found attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+Unit *PlayerbotClassAI::GetNearestAttackerOf(Unit *pAttacked, bool nearestToAttacked)
+{
+    if (!pAttacked) { pAttacked = m_bot; if (!pAttacked) return NULL;}
+
+    Unit::AttackerSet fAttackerSet = pAttacked->getAttackers();
+    if (fAttackerSet.size() <= 0) { return NULL; }
+
+    Unit *nearestTo = m_bot;
+    if (nearestToAttacked) { nearestTo = pAttacked; }
+
+    Unit *curAtt = NULL;
+    float minDist = 30;
+
+
+    for (Unit::AttackerSet::const_iterator itr = fAttackerSet.begin(); itr != fAttackerSet.end(); ++itr)
+    {
+        Unit *tAtt = (*itr);
+        if (!tAtt) break; // Something is wrong.. How can a non existing mob attack?
+        if (tAtt->isDead()) break;
+        if (m_bot->GetDistance(tAtt) >= minDist) continue; //Get the nearest one
+        curAtt = tAtt;
+        minDist = tAtt->GetDistance(nearestTo);
+    }
+    return curAtt;
+
+}
+
+uint8 PlayerbotClassAI::GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing)
+{
+    uint8 validMemberCount=0;
+    uint16 totalHPPercent=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if(!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = ObjectAccessor::FindPlayer((*itr)->GetGUID());
+        if(tPlayer == NULL) continue;
+        if(tPlayer->isDead()) continue;
+        if(GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+        uint8 fndHPPercent =  tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth();
+        totalHPPercent+=fndHPPercent;
+        validMemberCount++;
+        if (fndHPPercent < 100) countNeedHealing++;
+
+        //const std::string myname = GetPlayerBot()->GetName();
+        //const std::string hisname = tPlayer->GetName();
+        //sLog->outDebug(LOG_FILTER_NETWORKIO, "me = %s, checked= %s %u [%u / %u]", myname.c_str(), hisname.c_str(), fndHPPercent, tPlayer->GetHealth(), tPlayer->GetMaxHealth());
+
+      }
+    }
+    if (validMemberCount == 0) return 100;
+    return totalHPPercent / validMemberCount;
+}
+
+Unit *PlayerbotClassAI::DoSelectLowestHpFriendly(float range, uint32 MinHPDiff)
+{
+    Unit *pUnit = NULL;
+    Trinity::MostHPMissingInRange u_check(GetPlayerBot(), range, MinHPDiff);
+    Trinity::UnitLastSearcher<Trinity::MostHPMissingInRange> searcher(GetPlayerBot(), pUnit, u_check);
+
+    GetPlayerBot()->VisitNearbyObject(range, searcher);
+
+    if(pUnit && ((pUnit->GetCharmerOrOwner() && pUnit->GetCharmerOrOwner()->ToPlayer() && 
+        pUnit->GetCharmerOrOwner()->ToPlayer()->GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId()) //npcbot
+        || 
+        (pUnit->ToPlayer() && pUnit->ToPlayer()->GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId()))) //playerbot
+        return pUnit;
+    else 
+        return NULL;
+}
+
+void PlayerbotClassAI::SetMainTank(Unit *tank)
+{
+    mainTank = tank;
+}
+
+// is Resource heavy, do not spam or use heavily in loop
+Unit *PlayerbotClassAI::FindMainTankInRaid(Player *gPlayer)
+{
+    // check if original main tank is still alive. No point regetting main
+    // tank b/c chances are slim that it will not get reset in the middle of a fight.
+    // But if main tank dies, try to find next best canidate
+    if(mainTank!=NULL && mainTank->IsInWorld() && mainTank->isAlive())
+        return mainTank;
+
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, pGroup->GetGUID());
+        if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = ObjectAccessor::FindPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                mainTank = pPlayer;
+                return pPlayer;
+            }
+        }
+    }
+
+
+    // if could not find tank try assuming
+    // Assume the one with highest health is the main tank
+    uint32 maxhpfound=0;
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if (!unitList.empty()){
+      for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr) {
+        //Player *tPlayer = GetPlayerBot()->GetObjPlayer((*itr)->GetGUID());
+        Unit *tPlayer = ObjectAccessor::FindPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL) continue;
+        if (tPlayer->isDead()) continue;
+        if (GetPlayerBot()->GetAreaId() != tPlayer->GetAreaId()) continue;
+        //if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if (GetPlayerBot()->GetDistance(tPlayer) > 50) continue;
+        if (tPlayer->GetMaxHealth() > maxhpfound) { maxhpfound = tPlayer->GetMaxHealth(); pPlayer=tPlayer; }
+        // Also check pets
+        if ( (tPlayer->getClass() == (uint8) CLASS_HUNTER || tPlayer->getClass() == (uint8) CLASS_WARLOCK) && IS_PET_GUID(tPlayer->GetPetGUID()) )
+        {
+            Pet* tpet = ObjectAccessor::GetPet(*tPlayer, tPlayer->GetPetGUID());
+            if (!tpet || !tpet->IsInWorld() || !tpet->isDead()) continue;
+            if (tpet->GetArmor() > tPlayer->GetArmor()) //Probably a tanking capable pet..
+            {
+                if (tpet->GetMaxHealth() > maxhpfound) { maxhpfound = tpet->GetMaxHealth(); pPlayer=tpet; }
+                else if (tPlayer->GetGUID() == pPlayer->GetGUID()) {pPlayer = tpet;} //set pet as tank instead of owner
+            }
+        }
+      }
+    }
+
+    mainTank = pPlayer;
+    return pPlayer;
+}
+
+Unit *PlayerbotClassAI::FindMainAssistInRaid(Player *gPlayer)
+{
+    if (!gPlayer) return NULL;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return NULL;
+    uint64 pLeaderGuid = pGroup->GetLeaderGUID();
+
+
+    Unit *pPlayer = NULL;
+
+    // Check if set in raid
+    if (pGroup->isRaidGroup())
+    {
+        QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINASSIST, pGroup->GetGUID());
+          if(result)
+        {
+            uint64 pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+            pPlayer = ObjectAccessor::FindPlayer(pGuid);
+            if (pPlayer && pGroup->IsMember(pGuid) && pPlayer->isAlive()){
+                return pPlayer;
+            }
+        }
+    }
+
+    // default to main tank
+    return FindMainTankInRaid(gPlayer);
+}
+
+Player * PlayerbotClassAI::FindMage(Player *gPlayer)
+{
+    Group::MemberSlotList const &groupSlot = gPlayer->GetGroup()->GetMemberSlots();
+    for(Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *tPlayer = ObjectAccessor::FindPlayer(itr->guid);
+
+        if(tPlayer == NULL) continue;
+        if(tPlayer->GetGUID() == GetPlayerBot()->GetGUID()) continue;
+        if(GetPlayerBot()->GetAreaId() != gPlayer->GetAreaId()) continue;
+        if(GetPlayerBot()->GetDistance(tPlayer) > 30) continue;
+
+        if (tPlayer->getClass() == CLASS_MAGE) return tPlayer;
+    }
+    return NULL;
+}
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotClassAI.h b/src/server/game/AI/Bots/PlayerbotClassAI.h
new file mode 100644
index 0000000..202adf4
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotClassAI.h
@@ -0,0 +1,162 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+#include "SpellAuras.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+
+
+class Player;
+class PlayerbotAI;
+class Aura;
+
+        enum BotRole
+        {
+            BOT_ROLE_NONE,
+            BOT_ROLE_TANK,
+            BOT_ROLE_OFFTANK,
+            BOT_ROLE_DPS_RANGED,
+            BOT_ROLE_DPS_MELEE,
+            BOT_ROLE_SUPPORT,
+            BOT_ROLE_HEALER
+        };
+
+class PlayerbotClassAI
+{
+    public:
+        PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotClassAI();
+
+        //all combat actions go here
+        virtual void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        virtual void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        virtual bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        virtual bool HealTarget (Unit *target, uint8 hp);
+
+        //Heals the group based off its HP
+        virtual bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cure the target
+        virtual bool CureTarget (Unit *target);
+
+        //Resurrect the target (OBSOLETE - Check individual ClassAIs instead)
+        virtual bool RezTarget(Unit *target);
+
+        //find any specific mount spells, ie druids = cat, shaman = ghost wolf etc (OBSOLETE)
+        virtual bool FindMount();
+
+        virtual bool Unmount();
+
+        virtual bool IsMounted();
+
+        virtual void LoadSpells();
+
+        virtual void Pull();
+
+        //Utilities
+        Player *GetMaster (){ return m_master; }
+        Player *GetPlayerBot(){ return m_bot; }
+        PlayerbotAI *GetAI (){ return m_ai; }
+
+        bool isPulling() { return m_pulling; }
+        bool TakePosition(Unit *followTarget, BotRole bRole=BOT_ROLE_NONE, float bDist=0, float bMinDist=0, float bMaxDist=0, float bAngle=0, Unit *faceTarget=NULL);
+        //Gets the threat done by bot / threat max (percent) to the target.
+        uint8 GetThreatPercent(Unit *pTarget, Unit *pFrom = NULL);
+        //Gets if the unit is under attack by # of attackers
+        bool isUnderAttack(Unit *pAttacked=NULL,const uint8 &minNumberOfAttackers=1);
+        //Gets the first found attacker of Unit
+        Unit *GetAttackerOf(Unit *pAttacked=NULL);
+        //Gets the nearest attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+        Unit *GetNearestAttackerOf(Unit *pAttacked=NULL, bool nearestToAttacked=false);
+        //Calculates Average Raid Health condition as Percentage, ref value is the Count of units need healing..
+        uint8 GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing);
+
+        // Called when the main tank is set from raid ui
+        void SetMainTank (Unit *tank);
+
+        //Finds the possible MainTank in Raid including Hunter/Warlock pets.. Makes the assumption based on - max maxHealth..
+        Unit *FindMainTankInRaid(Player *gPlayer);
+
+        //Finds the possible MainAssist in Raid.  Defaults to Main Tank if it cannot find one.
+        Unit *FindMainAssistInRaid(Player *gPlayer);
+
+        Player *FindMage(Player *gPlayer);
+        //Finds the lowest hp creature around that is friendly with the caster.
+        Unit *DoSelectLowestHpFriendly(float range, uint32 MinHPDiff);
+
+
+        protected:
+        bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CastSpell(const SpellInfo * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        bool CanCast(const SpellInfo * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+
+        //Debug method to list the auras currently active.
+        //Use to find what spells were casted
+        bool listAuras(Unit *unit);
+
+        //More generalized method than HasAura().  It looks for
+        //any rank of the spell and it doesn't care which
+        //spell effect you want.  If it has the spell aura than
+        //it returns true
+        bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+
+        //The following functions return true only a match is found and the bot successfully casted a spell to resolve the problem
+        //If the result is false, either a match is not found, or the ClassAI could not cast or refused to cast a spell for some reason..
+
+        //Combination of all Healer roles, scans the party and decides if group healing > individual healing > Rez > curing > buffing is needed
+        //and directs any matches found to individual ClassAIs
+        //Main Raid scan function for Healer/Support types..
+        bool DoSupportRaid(Player *gPlayer, float radius=30, bool dResurrect=true, bool dGroupHeal=true, bool dHeal=true, bool dCure=true, bool dBuff=true);
+        //Find matching debuffs on target to provided Spell, and call castSpell() with provided parameters
+        bool castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        //Cast matching debuffs on self with probided SpellId list.. Mainly Used for Racial spells.. List is used to prevent extra loops for each spell..
+        bool castSelfCCBreakers (uint32 castList[]);
+
+
+
+        typedef std::set<Unit *> AttackerSet;
+
+        uint8 rezSpamTimer;
+        uint32 foodDrinkSpamTimer;
+        static const uint32 foodDrinkSpamCount = 100;
+
+        BotRole m_role;
+        bool m_pulling;
+        uint32 threatThreshold, offensiveSpellThreshold;
+
+        // RACIAL SPELLS
+        uint32 R_ARCANE_TORRENT, R_BERSERKING, R_BLOOD_FURY, R_CANNIBALIZE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_GIFT_OF_NAARU, R_SHADOWMELD, R_STONEFORM, R_WAR_STOMP, R_WILL_OF_FORSAKEN;
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+        uint32 SHOOT;
+
+    private:
+        Player *m_master;
+        Player *m_bot;
+        PlayerbotAI *m_ai;
+        Unit *mainTank;
+
+
+
+};
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..b0c26d9
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,325 @@
+/*
+Name : PlayerbotDeathknightAI.cpp
+Complete: maybe around 65%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Death grip casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn
+Version : 0.40
+*/
+
+#include "PlayerbotDeathKnightAI.h"
+
+class PlayerbotAI;
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+void PlayerbotDeathKnightAI::LoadSpells(){
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // Unholy
+    PLAGUE_STRIKE = ai->getSpellIdExact("Plague Strike");
+    DEATH_STRIKE = ai->getSpellIdExact("Death Strike");
+    SCOURGE_STRIKE  = ai->getSpellIdExact("Scourge Strike");
+
+    // Frost
+    ICY_TOUCH = ai->getSpellIdExact("Icy Touch");
+    OBLITERATE = ai->getSpellIdExact("Obliterate");
+
+    // Blood
+    BLOOD_STRIKE = ai->getSpellIdExact("Blood Strike");
+    HEART_STRIKE  = ai->getSpellIdExact("Heart Strike");
+    RUNE_TAP = ai->getSpellIdExact("Rune Tap");
+    DARK_COMMAND = ai->getSpellIdExact("Dark Command");
+
+    // AOE
+    HOWLING_BLAST = ai->getSpellIdExact("Howling Blast");
+    BLOOD_BOIL = ai->getSpellIdExact("Blood Boil");
+    PESTILENCE = ai->getSpellIdExact("Pestilence");
+    CORPSE_EXPLOSION = ai->getSpellIdExact("Corpse Explosion");
+    DEATH_AND_DECAY = ai->getSpellIdExact("Death and Decay");
+
+    // Rune attacks
+    FROST_STRIKE = ai->getSpellIdExact("Frost Strike");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+    RUNE_STRIKE = ai->getSpellIdExact("Rune Strike");
+
+    // CC Interrupt
+    DEATH_GRIP = ai->getSpellIdExact("Death Grip");
+    CHAINS_OF_ICE = ai->getSpellIdExact("Chains of Ice");
+    MIND_FREEZE = ai->getSpellIdExact("Mind Freeze");
+    HUNGERING_COLD = ai->getSpellIdExact("Hungering Cold");
+    STRANGULATE = ai->getSpellIdExact("Strangulate");
+
+    // Debuffs
+    FROST_FEVER = 55095; //ai->getSpellIdExact("Frost Fever",true);
+    BLOOD_PLAGUE = 55078; //ai->getSpellIdExact("Blood Plague",true);
+    CRYPT_FEVER = ai->getSpellIdExact("Crypt Fever",true);
+    EBON_PLAGUE = ai->getSpellIdExact("Ebon Plague",true);
+    MARK_OF_BLOOD = ai->getSpellIdExact("Mark of Blood");
+
+    // Buffs
+    HORN_OF_WINTER = ai->getSpellIdExact("Horn of Winter");
+    BONE_SHIELD = ai->getSpellIdExact("Bone Shield");
+    VAMPIRIC_BLOOD = ai->getSpellIdExact("Vampiric Blood");
+    HYSTERIA = ai->getSpellIdExact("Hysteria");
+    UNBREAKABLE_ARMOR = ai->getSpellIdExact("Unbreakable Armor");
+    ANTI_MAGIC_SHELL = ai->getSpellIdExact("Anti Magic Shell");
+    ANTI_MAGIC_ZONE = ai->getSpellIdExact("Anti Magic Zone");
+    ICEBOUND_FORTITUDE = ai->getSpellIdExact("Icebound Fortitude");
+    EMPOWER_WEAPON = ai->getSpellIdExact("Empower Rune Weapon");
+    LICHBORNE = ai->getSpellIdExact("Lichborne");
+
+    // Summons
+    RAISE_DEAD = ai->getSpellIdExact("Raise Dead");
+    ARMY_OF_THE_DEAD = ai->getSpellIdExact("Army of the Dead");
+    SUMMON_GARGOYLE = ai->getSpellIdExact("Summon Gargoyle");
+    GHOUL_FRENZY = ai->getSpellIdExact("Ghoul Frenzy");
+    DEATH_PACT = ai->getSpellIdExact("Death Pact");
+    DANCING_WEAPON = ai->getSpellIdExact("Dancing Rune Weapon");
+
+    // Presences
+    BLOOD_PRESENCE = ai->getSpellIdExact("Blood Presence");
+    FROST_PRESENCE = ai->getSpellIdExact("Frost Presence");
+    UNHOLY_PRESENCE  = ai->getSpellIdExact("Unholy Presence");
+
+    // Talent
+    TALENT_BLOOD = HEART_STRIKE;
+    TALENT_FROST = FROST_STRIKE;
+    TALENT_UNHOLY = SCOURGE_STRIKE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BLOOD) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    if (TALENT_UNHOLY) talentCounter++;
+    if (talentCounter > 1) { TALENT_BLOOD = 0; TALENT_FROST = 0; TALENT_UNHOLY = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    std::ostringstream out;
+
+
+    if (!m_pulling)
+    {
+        m_role = BOT_ROLE_DPS_MELEE;
+        #pragma region Choose Role/Presence
+
+        // Choose Presence
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_TANK; return; }
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (CastSpell(FROST_PRESENCE,m_bot)) { m_role = BOT_ROLE_OFFTANK; return; }
+        }
+        else if (TALENT_UNHOLY)
+        {
+            if (CastSpell(UNHOLY_PRESENCE,m_bot)) return;
+        }
+        else if (CastSpell(BLOOD_PRESENCE,m_bot)) return;
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[6] = { LICHBORNE, ICEBOUND_FORTITUDE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+
+   if (m_pulling) {
+        if (GetAI()->CastSpell(DEATH_GRIP,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+
+            if (m_bot->GetPet()) pet->SetReactState (REACT_DEFENSIVE);
+         }
+          return;
+    }
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() < 80 && ai->GetHealthPercent() > 20 && CastSpell(VAMPIRIC_BLOOD,m_bot)) { }  //NO GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(RUNE_TAP,m_bot)) { } //NO GCD
+    if (CanCast(DEATH_STRIKE,pTarget,true) && ai->GetHealthPercent() < 90 &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) ||pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(DEATH_STRIKE,pTarget,false) ) {return;}
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (pet && ai->GetHealthPercent() < 50 && CastSpell(DEATH_PACT,m_bot)) { return; }
+    if (pet && ai->GetHealthPercent() < 60 && CastSpell(MARK_OF_BLOOD,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 65 && CastSpell(ICEBOUND_FORTITUDE,m_bot)) { } //No GCD
+    if (ai->GetHealthPercent() < 65 && CastSpell(UNBREAKABLE_ARMOR,m_bot)) { return; }
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (CastSpell(MIND_FREEZE,pTarget)) {} // No GCD
+        if (CastSpell(STRANGULATE,pTarget)) { return; }
+        if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        if (CastSpell(ANTI_MAGIC_ZONE,m_bot)) { return; }
+        if (CastSpell(ANTI_MAGIC_SHELL,m_bot)) {} //NO GCD
+    }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(DEATH_GRIP,pTarget)) return;
+        if (CastSpell(CHAINS_OF_ICE,pTarget)) return;
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt && CastSpell(DARK_COMMAND, curAtt))  { }     //No gcd
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DARK_COMMAND, pTarget) )  { } // No gcd
+    }
+
+    // If not in Frost Presence slow down due to threat
+    if (pThreat > threatThreshold && !m_bot->HasAura(FROST_PRESENCE) && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //DK has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+    //Dps up
+    if (CastSpell(EMPOWER_WEAPON,m_bot)) {} //NO GCD
+    if (ai->GetHealthPercent() > 90 && CastSpell(HYSTERIA,m_bot)) {} //NO GCD
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // Use up excess Runic Power
+    if (ai->GetRunicPower() > 60 && CastSpell(FROST_STRIKE,pTarget)) { return; }
+    else if (ai->GetRunicPower() > 60 && CastSpell(DEATH_COIL,pTarget,true,true,true)) { return; }
+    if ((isUnderAttack() || ai->GetRunicPower() > 70) && CastSpell(RUNE_STRIKE,pTarget)) {} //Next attack spell
+
+    // Build Diseases
+    if (!pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && CastSpell(ICY_TOUCH,pTarget)) { return; }
+    if (!pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) && CastSpell(PLAGUE_STRIKE,pTarget)) { return; }
+
+    // Use AOEs summons
+    if (isUnderAttack(m_tank,4) && CastSpell(DEATH_AND_DECAY,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(HOWLING_BLAST,pTarget)) { return; }
+    if (CanCast(PESTILENCE,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) && pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(PESTILENCE,pTarget,false)) { return; }
+    if (CanCast(BLOOD_BOIL,pTarget,true) && isUnderAttack(m_tank,4) &&
+        (pTarget->HasAura(FROST_FEVER,m_bot->GetGUID()) || pTarget->HasAura(BLOOD_PLAGUE,m_bot->GetGUID()) )
+        && CastSpell(BLOOD_BOIL,pTarget,false)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if (isUnderAttack(m_tank,6) && CastSpell(ARMY_OF_THE_DEAD,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(SUMMON_GARGOYLE,pTarget)) { return; } //This should be somewhat different
+
+    // Use standard damage spells
+    if (CastSpell(HEART_STRIKE,pTarget,true,true)) { return; }
+    if (CastSpell(BLOOD_STRIKE,pTarget)) { return; }
+    if (TALENT_FROST && CastSpell(OBLITERATE,pTarget)) { return; }
+    else if (TALENT_UNHOLY && CastSpell(SCOURGE_STRIKE,pTarget)) { return; }
+    else if (CastSpell(DEATH_STRIKE,pTarget)) { return; }
+    #pragma endregion
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff UP
+    if (CastSpell(HORN_OF_WINTER,m_bot)) { return; }
+    if (CastSpell(BONE_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(RUNE_TAP,m_bot)) { return; } //no gcd but lets give the others a time to heal
+    if (ai->GetHealthPercent() < 30) { ai->Feast(); }
+    //Item* fItem = ai->FindBandage();
+    /* if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(*fItem);
+        ai->SetIgnoreUpdateTime(8);
+        return;
+    }  */
+} // end DoNonCombatActions
+
+void PlayerbotDeathKnightAI::Pull()
+{
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if (GetPlayerBot()->GetPet()) GetPlayerBot()->GetPet()->SetReactState (REACT_PASSIVE);
+}
diff --git a/src/server/game/AI/Bots/PlayerbotDeathKnightAI.h b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..a337537
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDeathKnightAI.h
@@ -0,0 +1,61 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDeathKnightAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDeathKnightAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        void Pull();
+
+    private:
+        // Unholy
+        uint32 PLAGUE_STRIKE, DEATH_STRIKE, SCOURGE_STRIKE;
+
+        // Frost
+        uint32 ICY_TOUCH, OBLITERATE;
+
+        // Blood
+        uint32 BLOOD_STRIKE, HEART_STRIKE, RUNE_TAP, DARK_COMMAND;
+
+        // AOE
+        uint32 HOWLING_BLAST, BLOOD_BOIL, PESTILENCE, CORPSE_EXPLOSION, DEATH_AND_DECAY;
+
+        // Rune attacks
+        uint32 FROST_STRIKE, DEATH_COIL, RUNE_STRIKE;
+
+        // CC Interrupt
+        uint32 DEATH_GRIP, CHAINS_OF_ICE, MIND_FREEZE, HUNGERING_COLD, STRANGULATE;
+
+        // Debuffs
+        uint32 FROST_FEVER, BLOOD_PLAGUE, CRYPT_FEVER, EBON_PLAGUE, MARK_OF_BLOOD;
+
+        // Buffs
+        uint32 HORN_OF_WINTER, BONE_SHIELD, VAMPIRIC_BLOOD, HYSTERIA, UNBREAKABLE_ARMOR, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, ICEBOUND_FORTITUDE, EMPOWER_WEAPON, LICHBORNE;
+
+        // Summons
+        uint32 RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, GHOUL_FRENZY, DEATH_PACT, DANCING_WEAPON;
+
+        // Presences
+        uint32 BLOOD_PRESENCE, FROST_PRESENCE, UNHOLY_PRESENCE;
+
+        // Talent
+        uint32 TALENT_BLOOD, TALENT_FROST, TALENT_UNHOLY;
+
+};
+
+#endif
+
diff --git a/src/server/game/AI/Bots/PlayerbotDruidAI.cpp b/src/server/game/AI/Bots/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..4afa17d
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDruidAI.cpp
@@ -0,0 +1,676 @@
+/*
+Name : PlayerbotDruidAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is a combination of Feral/balance type..
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Tree of life form transition is late and may never occur, due to healing bots attacking priority at full mana.
+                - Boomkin's support roles are not fully covered.. For example -> off healing
+                - Situations needing Abolish Disease casting : limited / non-existant..
+
+Authors : SwaLLoweD, rrtn, Natsukawa
+Version : 0.40
+*/
+#include "PlayerbotDruidAI.h"
+
+class PlayerbotAI;
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI(){}
+
+void PlayerbotDruidAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+#pragma region SpellId Fill
+    // Balance Spells
+    MOONFIRE = ai->getSpellIdExact("Moonfire"); //attacks
+    WRATH = ai->getSpellIdExact("Wrath");
+    STARFIRE = ai->getSpellIdExact("Starfire");
+    STARFALL = ai->getSpellIdExact("Starfall");
+    FORCE_OF_NATURE = ai->getSpellIdExact("Force of Nature");
+    TYPHOON = ai->getSpellIdExact("Typhoon");
+    HURRICANE = ai->getSpellIdExact("Hurricane");
+    INSECT_SWARM = ai->getSpellIdExact("Insect Swarm");
+
+    CYCLONE = ai->getSpellIdExact("Cyclone");
+    ROOTS = ai->getSpellIdExact("Entangling Roots");
+    NATURES_GRASP = ai->getSpellIdExact("Nature's Grasp");
+
+    HIBERNATE = ai->getSpellIdExact("Hibernate");
+    FAERIE_FIRE = ai->getSpellIdExact("Faerie Fire");
+
+
+    // Bear Form Spells
+    MAUL = ai->getSpellIdExact("Maul");
+    BASH = ai->getSpellIdExact("Bash");
+    LACERATE = ai->getSpellIdExact("Lacerate");
+    MANGLE_BEAR = ai->getSpellIdExact("Mangle (Bear)");
+    SWIPE_BEAR = ai->getSpellIdExact("Swipe (Bear)");
+
+    DEMORALIZING_ROAR = ai->getSpellIdExact("Demoralizing Roar");
+    GROWL = ai->getSpellIdExact("Growl");
+    CHALLENGING_ROAR = ai->getSpellIdExact("Challenging Roar");
+
+    ENRAGE = ai->getSpellIdExact("Enrage");
+    FERAL_CHARGE_BEAR = ai->getSpellIdExact("Feral Charge - Bear");
+    FRENZIED_REGENERATION = ai->getSpellIdExact("Frenzied Regeneration");
+
+
+    //Cat Attack type's
+    RAKE = ai->getSpellIdExact("Rake"); //40 energy
+    CLAW = ai->getSpellIdExact("Claw"); //45
+    MANGLE_CAT = ai->getSpellIdExact("Mangle (Cat)"); //45
+    SHRED = ai->getSpellIdExact("Shred");
+
+    RIP = ai->getSpellIdExact("Rip"); //30
+    FEROCIOUS_BITE = ai->getSpellIdExact("Ferocious Bite"); //35
+    SAVAGE_ROAR = ai->getSpellIdExact("Savage Roar");
+    MAIM = ai->getSpellIdExact("Maim"); //35
+
+    FERAL_CHARGE_CAT = ai->getSpellIdExact("Feral Charge - Cat");
+    COWER = ai->getSpellIdExact("Cower"); //20
+    TIGERS_FURY = ai->getSpellIdExact("Tiger's Fury");
+
+    // Feral General
+    BERSERK = ai->getSpellIdExact("Berserk");
+    FAERIE_FIRE_FERAL = ai->getSpellIdExact("Faerie Fire (Feral)"); //debuffs
+
+    //buffs
+    MARK_OF_THE_WILD = ai->getSpellIdExact("Mark of the Wild"); //buffs
+    GIFT_OF_THE_WILD = ai->getSpellIdExact("Gift of the Wild");
+    THORNS = ai->getSpellIdExact("Thorns");
+    SURVIVAL_INSTINCTS = ai->getSpellIdExact("Survival Instincts");
+
+    // Restoration Spells
+    LIFEBLOOM = ai->getSpellIdExact("Lifebloom");
+    REJUVENATION = ai->getSpellIdExact("Rejuvenation"); //heals
+    REGROWTH = ai->getSpellIdExact("Regrowth");
+    NOURISH = ai->getSpellIdExact("Nourish");
+    SWIFTMEND = ai->getSpellIdExact("Swiftmend");
+    HEALING_TOUCH = ai->getSpellIdExact("Healing Touch");
+    INNERVATE = ai->getSpellIdExact("Innervate");
+    WILD_GROWTH = ai->getSpellIdExact("Wild Growth");
+    TRANQUILITY = ai->getSpellIdExact("Tranquility");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    CURE_POISON = ai->getSpellIdExact("Abolish Poison");
+    if (!CURE_POISON) CURE_POISON = ai->getSpellIdExact("Cure Poison");
+
+    REBIRTH    = ai->getSpellIdExact("Rebirth");
+    REVIVE = ai->getSpellIdExact("Revive");
+
+    BARKSKIN = ai->getSpellIdExact("Barkskin");
+
+    //Druid Forms
+    BEAR_FORM = ai->getSpellIdExact("Dire Bear Form");
+    if (!BEAR_FORM) BEAR_FORM = ai->getSpellIdExact("Bear Form");
+    CAT_FORM = ai->getSpellIdExact("Cat Form");
+    MOONKIN_FORM = ai->getSpellIdExact("Moonkin Form");
+    TREE_OF_LIFE_FORM = ai->getSpellIdExact("Tree of Life"); //33891;//learning spell has higher id..
+    AQUATIC_FORM = ai->getSpellIdExact("Aquatic Form");
+    TRAVEL_FORM = ai->getSpellIdExact("Travel Form");
+    FLIGHT_FORM = ai->getSpellIdExact("Swift Flight Form");
+    if (!FLIGHT_FORM) FLIGHT_FORM = ai->getSpellIdExact("Flight Form");
+
+
+    TALENT_BALANCE    = MOONKIN_FORM;
+    TALENT_RESTO    = SWIFTMEND;
+    TALENT_FERAL    = MANGLE_CAT;
+
+    uint8 talentCounter = 0;
+    if (TALENT_BALANCE) talentCounter++;
+    if (TALENT_FERAL) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    if (talentCounter > 1) { TALENT_BALANCE = 0; TALENT_RESTO = 0; TALENT_FERAL = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    #pragma region Select behaviour
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_FERAL && BEAR_FORM) { m_role = BOT_ROLE_TANK; } //Just Keep Tanking dont even change forms for healing
+        else
+        {
+            if (TALENT_BALANCE) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <30 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 25 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+            else //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else if (ai->GetManaPercent() < 15 ) { m_role = BOT_ROLE_TANK; }
+                else { m_role = BOT_ROLE_DPS_RANGED; }
+            }
+        }
+    }
+    else if (isUnderAttack() && !( ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_TREE)  ) // if i am under attack
+    {
+        // Keep being in Cat Form if you can reduce threat
+        if (ai->GetForm() == FORM_CAT && CastSpell(COWER,pTarget)) {return; }
+        else if (TALENT_RESTO && ai->GetManaPercent() > 10 ) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_FERAL && CAT_FORM) { // If has any feral forms at all
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 30 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else{ m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_BALANCE) {
+        if ((ai->GetHealthPercent() <= 50 || masterHP <40 ) && (ai->GetManaPercent() >= 10)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else if (TALENT_RESTO)    { m_role = BOT_ROLE_SUPPORT; }
+    else
+    {
+        // Unknown build or low level : Do not change forms rapidly..
+        if ( (ai->GetManaPercent() < 30 && BEAR_FORM) || ( (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) && ai->GetManaPercent() < 70 )  ) m_role = BOT_ROLE_DPS_MELEE;
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+
+    if (!isUnderAttack() && m_tank->GetGUID() != m_bot->GetGUID())
+    {
+        // Select Attacking target
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {} //if my target is attacking me continue
+        else
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+    // Return to normal form from non combat forms
+    if (ai->GetForm() == FORM_NONE || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_TREE || ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR )  { } //Those are valid incombat auras
+    else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //return to caster form
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            //ai->TellMaster("DruidCombat");
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                //We have little mana probably cant change form
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; }
+                else if(m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) {  return;}
+                else if(DoSupportRaid(GetMaster(),false,false,false)) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+            }
+
+            if (CAT_FORM) { if (ChangeForm(CAT_FORM)) { return; } }
+            else if (BEAR_FORM) { if (ChangeForm(BEAR_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) {  } //Normal Form
+
+            TakePosition(pTarget);
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_OFFTANK:
+        case BOT_ROLE_TANK: // It is a tank druid or a defending druid
+
+            // Do what you must before getting attacked...
+            if (ai->GetForm() == FORM_NONE)
+            {
+                // Non tank stuff to avoid
+                if (m_tank->GetGUID() != m_bot->GetGUID())
+                {
+                    if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+                    if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+                    if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+                    //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+                }
+                // Things to do wheter Tank or not
+                if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd
+                if (ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot) ) { return; } //We have little mana probably cant change form
+            }
+            TakePosition(pTarget);
+
+            if (ChangeForm(BEAR_FORM)) { return; }
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_ROAR, curAtt)) { return; }
+                    if (CastSpell(GROWL, curAtt))  { return; }
+                }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(GROWL, pTarget) )  { return; }
+            }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE, m_bot)) { return; }
+
+            // Do caster form stuff
+            if (ai->GetForm() == FORM_NONE)
+            {
+                if(DoSupportRaid(GetMaster())) return;
+                else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            }
+
+            if (MOONKIN_FORM) { if (ChangeForm(MOONKIN_FORM)) { return; } }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { } //Normal Form
+
+            TakePosition(pTarget);
+
+            // BUFF UP
+            if(DoSupportRaid(GetMaster(),false,false,false)) return;
+            else if(m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            if ( ai->GetManaPercent() < 20 && CastSpell (INNERVATE,m_bot)) { return; }
+            //Get to tree form only if you will no longer cast attack spells
+            if( TREE_OF_LIFE_FORM && (ai->GetManaPercent() < offensiveSpellThreshold || isUnderAttack()) )
+            {
+                 if (ChangeForm(TREE_OF_LIFE_FORM)) { return; }
+            }
+            else if (ai->GetForm() != FORM_NONE && ChangeForm(1)) { }  //Normal Form no gcd
+
+            TakePosition(pTarget);
+
+            //RezGroup(REBIRTH, GetMaster());
+            if (DoSupportRaid(GetMaster())) { return; }
+            if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(30, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+
+    #pragma region DruidCommon
+    // Common Dps and protection routine
+    if (ai->GetHealthPercent() <= 70 && CastSpell(BARKSKIN,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(NATURES_GRASP,m_bot)) { return; }
+
+    if (ai->GetForm() == FORM_CAT)
+    {
+        // If at threat limit, use Cower to reduce threat
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+        {
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+            {
+                m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                return;
+            }
+            else
+            {
+                if (CastSpell(COWER,pTarget)) { return; } //Lets see if we can manage
+                else { return; } //use no spells and wait threat to be reduced
+            }
+        }
+        if (CastSpell(FERAL_CHARGE_CAT,pTarget)) { return; }
+        if (m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(MAIM, pTarget)) { return; }
+
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if (isUnderAttack() && CastSpell(NATURES_GRASP, m_bot)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+
+        if (m_bot->GetComboPoints() < 5)
+        {
+            if (CastSpell(RAKE, pTarget)) { return; }
+            if (CastSpell(MANGLE_CAT, pTarget)) { return; }
+            if (!pTarget->HasInArc(M_PI,m_bot) && CastSpell(SHRED, pTarget)) { return; }
+            if (ai->GetEnergyAmount() > 65 && CastSpell(MANGLE_CAT, pTarget)) { return; } //Spam mangle if cannot cast shred
+            if (ai->GetEnergyAmount() > 65 && CastSpell(CLAW, pTarget) ) { return; } //Spam Claw if there is no mangle
+            // if (CanCast(COWER, pTarget) && CastSpell(COWER, pTarget)) { return; } //if still nothing, use COWER to reduce threat
+        }
+        else
+        {
+            if (CastSpell(SAVAGE_ROAR)) { return; }
+            if (CastSpell(RIP, pTarget)) { return; }
+            if (ai->GetEnergyAmount() >= 65 && CastSpell(FEROCIOUS_BITE, pTarget)) { return; } //maxhit for feracious bite
+        }
+        if (CastSpell(TIGERS_FURY, m_bot)) { return; } //if nothing is ready yet, use tigers fury
+    }
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        if (CastSpell(FERAL_CHARGE_BEAR,pTarget)) { return; }
+        if (CastSpell(BASH, pTarget,true,true)) { return; } //Need check for immunity
+        if (CastSpell(BERSERK, m_bot)) { return; }
+        if (CastSpell(DEMORALIZING_ROAR, pTarget)) { return; }
+        if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 50 && CastSpell(ENRAGE, m_bot)) { return; }
+        if (ai->GetHealthPercent() <= 75 && CastSpell(SURVIVAL_INSTINCTS, m_bot)) { return; }
+        if ( ( ai->GetHealthPercent() <= 30 || (ai->GetHealthPercent() < 85 && m_tank->GetGUID() != m_bot->GetGUID())  )
+            && CastSpell(FRENZIED_REGENERATION)) { return; }
+        if (CastSpell(FAERIE_FIRE_FERAL, pTarget)) { return; }
+        if (CastSpell(MANGLE_BEAR, pTarget)) { return; }
+        if ((ai->GetRageAmount() > 70 || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(SWIPE_BEAR, pTarget)) { return; }
+        if (ai->GetRageAmount() > 50 && CastSpell(MAUL, pTarget)) {} // Low Priority, Next Attack effect
+        if (ai->GetRageAmount() > 60 && CastSpell(LACERATE, pTarget)) { return; } //Currently applies only 1
+    }
+    else
+    {
+        //Defensive stuff
+        if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+        {
+            if (ROOTS && !pTarget->HasAura(CYCLONE) && !pTarget->HasAura(HIBERNATE) && CastSpell(ROOTS, pTarget)) { return; }
+            if (CYCLONE && pDist > 5 && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(HIBERNATE) && CastSpell(CYCLONE, pTarget)) { return; }
+            if (HIBERNATE && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && !pTarget->HasAura(ROOTS) && !pTarget->HasAura(CYCLONE) && CastSpell(HIBERNATE, pTarget)) { return; }
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+        }
+
+        if (CastSpell(FAERIE_FIRE, pTarget)) { return; }
+
+        // If at threat limit, stop
+        if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+        {
+            //Change to tank's target
+            if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) { m_bot->SetSelection(m_tank->getVictim()->GetGUID()); }
+            return; //use no spells and wait threat to be reduced
+        }
+        // Continue attacking if theres excess mana (for healers)
+        if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+        if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //only balance no gcd
+
+        if (m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(STARFIRE, pTarget)) { return; }
+        if (CastSpell(INSECT_SWARM, pTarget)) { return; }
+        if (CastSpell(TYPHOON, pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HURRICANE, pTarget)) { ai->SetIgnoreUpdateTime(8); return; }
+        if (isUnderAttack(m_tank,5) && CastSpell(FORCE_OF_NATURE, m_bot)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(STARFALL, pTarget)) { return; }
+        if (CastSpell(MOONFIRE, pTarget)) { return; }
+        if (CastSpell(WRATH, pTarget)) { return; }
+        if (CastSpell(STARFIRE, pTarget)) { return; }
+    }
+
+    // If there is nothing else to do buff UP
+    if (m_role == BOT_ROLE_DPS_MELEE) //Those already healed and buffed or should never buff in combat
+    {
+        if (DoSupportRaid(GetMaster(),false,false,false)) { return; }
+        if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot,false,false,false)) { return; }
+    }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+} //end DoNextCombatManeuver
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(GetMaster())) { return; }
+    if (m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup() && DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (INNERVATE, m_bot)) { return; } //Need mana fast
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() &&
+        (ai->GetForm() != FORM_CAT && ai->GetForm() != FORM_MOONKIN && ai->GetForm() != FORM_DIREBEAR && ai->GetForm() != FORM_BEAR)
+        && CastSpell(REGROWTH,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    if(!target || target->isDead()) { return false; }
+
+    if (CanCast(THORNS,target,0,0,1) && !HasAuraName(target, THORNS)) {
+        // Decide if it is worth to change form
+        if( /*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+            else { return false; }
+        }
+        return CastSpell(THORNS, target, false);
+    }
+    if (CanCast(MARK_OF_THE_WILD,target,0,0,1) && !HasAuraName(target, GIFT_OF_THE_WILD) && !HasAuraName(target, MARK_OF_THE_WILD)) {
+        // Decide if it is worth to change form
+        if(/*m_bot->HasAura(MOONKIN_FORM) ||*/ m_bot->HasAura(CAT_FORM) || m_bot->HasAura(BEAR_FORM))
+        {
+            if(GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+            else return false;
+        }
+        return CastSpell(MARK_OF_THE_WILD, target, false);
+    }
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit *target, uint8 hp)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp < 75 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    // if(m_bot->HasAura(TRAVEL_FORM)) ChangeForm(1);
+
+    if(hp < 60 && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEALING_TOUCH, target)) { return true; }
+    if(hp < 90 && CastSpell(LIFEBLOOM, target)) { return true; }
+    if(hp < 80 && CastSpell(REJUVENATION, target)) { return true; }
+    if(hp < 60 && CastSpell(REGROWTH, target)) { return true; }
+    if(hp < 70 && CanCast(NOURISH,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,LIFEBLOOM,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(NOURISH, target, false); }
+    if(hp < 50 && CanCast(SWIFTMEND,target) &&
+        (HasAuraName(target,REJUVENATION,m_bot->GetGUID()) || HasAuraName(target,REGROWTH,m_bot->GetGUID()))
+        ) { return CastSpell(SWIFTMEND, target, false); }
+    if(hp < 40 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) { } // NO gcd
+    if(hp < 40 && CastSpell(HEALING_TOUCH, target)) { return true; }
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+
+    if (countNeedHeal < 2) { return false; }
+
+    // Decide if it is worth to change form
+    if (ai->GetForm() == FORM_MOONKIN || ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        if (hp > 70) { return false; }
+        if (!CanCast(TRANQUILITY,target,0,0,1) && !WILD_GROWTH) { return false; }
+        if (!WILD_GROWTH && hp > 35) { return false; }
+        if (hp < 65 && GetAI()->GetManaPercent() >= 70 ) { ChangeForm(1); }
+        else if (hp < 40 && GetAI()->GetManaPercent() >= 50) { ChangeForm(1); }
+        else if (hp < 25 && GetAI()->GetManaPercent() >= 30) { ChangeForm(1); }
+        else return false;
+    }
+
+    if (hp < 36 && m_bot->isInCombat() && CanCast(TRANQUILITY,target))
+    {
+            bool sc = CastSpell(TRANQUILITY, target, false);
+            if (sc) GetAI()->SetIgnoreUpdateTime(10);
+            return sc;
+    }
+    if (hp < 75 && CastSpell(WILD_GROWTH,target)) { return true; }
+    return false;
+}
+
+bool PlayerbotDruidAI::CureTarget(Unit *target)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!target || target->isDead()) { return false; }
+    // Decide if it is worth to change form (they cange forms even if theres nothing to cure..)
+    if (ai->GetForm() == FORM_CAT || ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR)
+    {
+        //if(GetAI()->GetManaPercent() >= 80 ) { ChangeForm(1); }
+        //else { return false; }
+        return false;
+    }
+    if (castDispel(CURE_POISON, target)) { return true; }
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotDruidAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+
+    if (m_bot->isInCombat())
+    {
+        if (!CanCast(REBIRTH,target)) return false;
+        Unit *m_tank = FindMainTankInRaid(m_bot);
+        if (!m_tank) m_tank = m_bot;
+        if (target->GetGUID() != m_tank->GetGUID() &&
+            (target->getClass() != (uint8) CLASS_PRIEST || target->getClass() != (uint8) CLASS_DRUID || target->getClass() != (uint8) CLASS_PALADIN) ) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REBIRTH, target);
+    }
+    else
+    {
+        if (!CanCast(REVIVE,target)) return false;
+        std::string msg = "Rezzing ";
+        msg += target->GetName();
+       // msg += " with ";
+       // msg += *REZZSpell->SpellName;
+        GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+        return CastSpell(REVIVE, target);
+    }
+    return false;
+}
+
+/*bool PlayerbotDruidAI::FindMount() {
+    if (TRAVEL_FORM) {
+        if (GetPlayerBot())    CastSpell(TRAVEL_FORM, GetPlayerBot());
+        return true;
+    } else return false;
+}
+
+bool PlayerbotDruidAI::Unmount() {
+    GetPlayerBot()->RemoveAurasDueToSpell(TRAVEL_FORM);
+    return true;
+}
+
+bool PlayerbotDruidAI::IsMounted() {
+    return GetPlayerBot()->IsMounted() || HasAuraName(GetPlayerBot(), TRAVEL_FORM);
+} */
+
+bool PlayerbotDruidAI::ChangeForm(uint32 form)
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+    if (!form) return false;
+
+    if (form == 1 && ai->GetForm() == FORM_NONE) return false;
+
+    if (form != 1)
+    {
+        if (!CanCast(form,m_bot,0,0,1)) return false;
+        if (m_bot->HasAura(form)) { return false; }
+    }
+
+    if (ai->GetForm() == FORM_TREE) m_bot->RemoveAurasDueToSpell(TREE_OF_LIFE_FORM);
+    else if (ai->GetForm() == FORM_CAT) m_bot->RemoveAurasDueToSpell(CAT_FORM);
+    else if (ai->GetForm() == FORM_MOONKIN) m_bot->RemoveAurasDueToSpell(MOONKIN_FORM);
+    else if (ai->GetForm() == FORM_DIREBEAR || ai->GetForm() == FORM_BEAR) m_bot->RemoveAurasDueToSpell(BEAR_FORM);
+    else if (ai->GetForm() == FORM_TRAVEL) m_bot->RemoveAurasDueToSpell(TRAVEL_FORM);
+    else if (ai->GetForm() == FORM_FLIGHT || ai->GetForm() == FORM_FLIGHT_EPIC)    m_bot->RemoveAurasDueToSpell(FLIGHT_FORM);
+    else if (ai->GetForm() == FORM_AQUA) m_bot->RemoveAurasDueToSpell(AQUATIC_FORM);
+
+    if (form == 1) { return true; }
+
+    return CastSpell(form,m_bot,false);
+}
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotDruidAI.h b/src/server/game/AI/Bots/PlayerbotDruidAI.h
new file mode 100644
index 0000000..35f4d54
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotDruidAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotDruidAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotDruidAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotDruidAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup(Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget(Unit *target);
+
+        // find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        /* virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+        //Change Form
+        bool ChangeForm(uint32 form);
+
+    private:
+
+        // BALANCE Attacks
+        uint32 MOONFIRE, WRATH, STARFALL, STARFIRE, TYPHOON, HURRICANE, FORCE_OF_NATURE, INSECT_SWARM, CYCLONE, ROOTS, NATURES_GRASP, HIBERNATE, FAERIE_FIRE;
+
+        // RESTORATION Spells
+        uint32 LIFEBLOOM, REJUVENATION, REGROWTH, NOURISH, SWIFTMEND, HEALING_TOUCH, NATURES_SWIFTNESS, INNERVATE, WILD_GROWTH, TRANQUILITY, REBIRTH, REVIVE, CURE_POISON, BARKSKIN;
+
+        // BEAR SPELLS
+        uint32 MAUL, BASH, LACERATE, MANGLE_BEAR, SWIPE_BEAR, DEMORALIZING_ROAR, GROWL, CHALLENGING_ROAR , ENRAGE, FERAL_CHARGE_BEAR, FRENZIED_REGENERATION;
+
+        // CAT SPELLS
+        uint32 CLAW, RAKE, SHRED, MANGLE_CAT, RIP, FEROCIOUS_BITE, SAVAGE_ROAR, MAIM, FERAL_CHARGE_CAT, COWER, TIGERS_FURY;
+
+        // FERAL General
+        uint32 BERSERK, FAERIE_FIRE_FERAL;
+
+        // BUFFS
+        uint32 MARK_OF_THE_WILD, GIFT_OF_THE_WILD, THORNS, SURVIVAL_INSTINCTS;
+
+        // FORMS
+        uint32 CAT_FORM, BEAR_FORM, MOONKIN_FORM, TREE_OF_LIFE_FORM, TRAVEL_FORM, FLIGHT_FORM, AQUATIC_FORM;
+
+        // Key TALENT SPELLS
+        uint32 TALENT_BALANCE, TALENT_RESTO, TALENT_FERAL;
+
+};
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotHunterAI.cpp b/src/server/game/AI/Bots/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..4b3c3bc
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotHunterAI.cpp
@@ -0,0 +1,561 @@
+/*
+Name : PlayerbotHunterAI.cpp
+Complete: maybe around 70%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - AI always assumes pet is the tank if there are no higher hp people in group than the hunter..
+                - Possible threat build / reduce race between pet and hunter if attacking to same target.. Needs checking
+                - Possible target changing loop between pet and hunter if attacking to same target and getting aggro repeatedly.. Needs checking
+                - Disarm and Nature resist aspect, Disengage, Scorpid sting are not used right now..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotHunterAI.h"
+
+
+class PlayerbotAI;
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai): PlayerbotClassAI(master, bot, ai)
+{
+    m_petSummonFailed = false;
+    LoadSpells();
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+void PlayerbotHunterAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    // PET CONTROL
+    PET_SUMMON = ai->getSpellIdExact("Call Pet");
+    PET_DISMISS = ai->getSpellIdExact("Dismiss Pet");
+    PET_REVIVE = ai->getSpellIdExact("Revive Pet");
+    PET_MEND = ai->getSpellIdExact("Mend Pet");
+    PET_FEED = 1539; //ai->getSpellIdExact("Feed Pet");
+    KILL_COMMAND = ai->getSpellIdExact("Kill Command");
+    INTIMIDATION = ai->getSpellIdExact("Intimidation");
+    BESTIAL_WRATH = ai->getSpellIdExact("Bestial Wrath");
+
+    // PET SPELL (master does not have these spells anymore)
+    GROWL = ai->getSpellIdExact("Growl");
+    COWER = ai->getSpellIdExact("Cower");
+    BAD_ATTITUDE = ai->getSpellIdExact("Bad Attitude");
+    SONIC_BLAST = ai->getSpellIdExact("Sonic Blast");
+    NETHER_SHOCK = ai->getSpellIdExact("Nether Shock");
+    DEMORALIZING_SCREECH = ai->getSpellIdExact("Demoralizing Screech");
+
+    // RANGED ATTACK
+    AUTO_SHOT = ai->getSpellIdExact("Auto Shot");
+    ARCANE_SHOT = ai->getSpellIdExact("Arcane Shot");
+    EXPLOSIVE_SHOT = ai->getSpellIdExact("Explosive Shot");
+    STEADY_SHOT = ai->getSpellIdExact("Steady Shot");
+    AIMED_SHOT = ai->getSpellIdExact("Aimed Shot");
+    SCATTER_SHOT = ai->getSpellIdExact("Scatter Shot");
+    KILL_SHOT = ai->getSpellIdExact("Kill Shot");
+    CHIMERA_SHOT = ai->getSpellIdExact("Chimera Shot");
+    CONCUSSIVE_SHOT = ai->getSpellIdExact("Concussive Shot");
+    DISTRACTING_SHOT = ai->getSpellIdExact("Distracting Shot");
+    SILENCING_SHOT = ai->getSpellIdExact("Silencing Shot");
+
+    // STINGS
+    SERPENT_STING = ai->getSpellIdExact("Serpent Sting");
+    SCORPID_STING = ai->getSpellIdExact("Scorpid Sting");
+    WYVERN_STING = ai->getSpellIdExact("Wyvern Sting");
+    VIPER_STING = ai->getSpellIdExact("Viper Sting");
+
+    // DEBUFF
+    HUNTERS_MARK = ai->getSpellIdExact("Hunter's Mark");
+    SCARE_BEAST = ai->getSpellIdExact("Scare Beast");
+
+    //AOE
+    VOLLEY = ai->getSpellIdExact("Volley");
+    MULTI_SHOT = ai->getSpellIdExact("Multi Shot");
+
+    //MELEE
+    RAPTOR_STRIKE = ai->getSpellIdExact("Raptor Strike");
+    WING_CLIP = ai->getSpellIdExact("Wing Clip");
+    MONGOOSE_BITE = ai->getSpellIdExact("Mongoose Bite");
+    COUNTERATTACK = ai->getSpellIdExact("Counterattack");
+
+    //TRAP
+    FREEZING_TRAP = ai->getSpellIdExact("Freezing Trap");
+    IMMOLATION_TRAP = ai->getSpellIdExact("Immolation Trap");
+    FROST_TRAP = ai->getSpellIdExact("Frost Trap");
+    EXPLOSIVE_TRAP = ai->getSpellIdExact("Explosive Trap");
+    SNAKE_TRAP = ai->getSpellIdExact("Snake Trap");
+    ARCANE_TRAP = ai->getSpellIdExact("Arcane Trap");
+    FREEZING_ARROW = ai->getSpellIdExact("Freezing Arrow");
+    BLACK_ARROW = ai->getSpellIdExact("Black Arrow");
+
+    //BUFF
+    TRUESHOT_AURA = ai->getSpellIdExact("Trueshot Aura");
+    DETERRENCE = ai->getSpellIdExact("Deterrence");
+    FEIGN_DEATH = ai->getSpellIdExact("Feign Death");
+    DISENGAGE = ai->getSpellIdExact("Disengage");
+    RAPID_FIRE = ai->getSpellIdExact("Rapid Fire");
+    READINESS = ai->getSpellIdExact("Readiness");
+    MISDIRECTION = ai->getSpellIdExact("Misdirection");
+
+    //ASPECT
+    ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Dragonhawk");
+    ASPECT_OF_THE_MONKEY = ASPECT_OF_THE_HAWK;
+    if (!ASPECT_OF_THE_HAWK) ASPECT_OF_THE_HAWK = ai->getSpellIdExact("Aspect of the Hawk");
+    if (!ASPECT_OF_THE_MONKEY) ASPECT_OF_THE_MONKEY = ai->getSpellIdExact("Aspect of the Monkey");
+    ASPECT_OF_THE_VIPER = ai->getSpellIdExact("Aspect of the Viper");
+
+    TALENT_MM = TRUESHOT_AURA;
+    TALENT_BM = BESTIAL_WRATH;
+    TALENT_SURVIVAL = WYVERN_STING;
+
+    uint8 talentCounter = 0;
+    if (TALENT_MM) talentCounter++;
+    if (TALENT_BM) talentCounter++;
+    if (TALENT_SURVIVAL) talentCounter++;
+    if (talentCounter > 1) { TALENT_MM = 0; TALENT_BM = 0; TALENT_SURVIVAL = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+bool PlayerbotHunterAI::HasPet(Player* bot)
+{
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM character_pet WHERE owner = '%u' AND (slot = '%u' OR slot = '%u')",bot->GetGUIDLow(),PET_SAVE_AS_CURRENT,PET_SAVE_NOT_IN_SLOT);
+
+    if(result)
+        return true; //hunter has current pet
+    else
+        return false; //hunter either has no pet or stabled
+}// end HasPet
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+ //   switch (ai->GetScenarioType())
+//    {
+//        case PlayerbotAI::SCENARIO_DUEL:
+ //           ai->CastSpell(RAPTOR_STRIKE);
+ //           return;
+//    }
+
+    // ------- Non Duel combat ----------
+
+
+    #pragma region Choose Target
+    // Choose Target
+    if (isUnderAttack()) // I am under attack
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+        else //Have to select nearest target
+        {
+            Unit *curAtt = GetNearestAttackerOf(m_bot);
+            if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(curAtt->GetGUID());
+                //ai->AddLootGUID(curAtt->GetGUID());
+                DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                return;
+            }
+        }
+        //my target is attacking me
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+
+        //Heal pet
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( PET_MEND>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(PET_MEND,m_bot) )) { return; }
+
+        // Set pet to attack hunter's attacker > its own attackers > hunter's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help hunter if she's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and hunter has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= hunter) takes aggro back)
+            //Hunter should help her pet whether main tank or not, unless she's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(sSpellMgr->GetSpellInfo(GROWL),true); //Autocast growl
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(sSpellMgr->GetSpellInfo(BAD_ATTITUDE),true);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(sSpellMgr->GetSpellInfo(COWER),false);
+            if (CastSpell(INTIMIDATION,m_bot)) { return; }
+        }
+        else
+        {
+            if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(sSpellMgr->GetSpellInfo(GROWL),false); //Do not try to get aggro
+            if (BAD_ATTITUDE) pet->GetCharmInfo()->SetSpellAutocast(sSpellMgr->GetSpellInfo(BAD_ATTITUDE),false);
+            if (COWER) pet->GetCharmInfo()->SetSpellAutocast(sSpellMgr->GetSpellInfo(COWER),true); //Autocast cower
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            if (CastSpell(KILL_COMMAND,m_bot)) { }
+            else if (CastSpell(BESTIAL_WRATH,m_bot)) { }
+        }
+        // NETHERSHOCK DEMORALIZINGSCREECH
+    }
+    #pragma endregion
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    #pragma region Evasive manuevers
+    // Do evasive manuevers if under attack
+    if (isUnderAttack())
+    {
+        if (m_tank->GetGUID() == m_bot->GetGUID()) { } // i am tank and my pet is probably dead, so i have to face the attackers
+        else if (CastSpell(FEIGN_DEATH,m_bot)) { return; } //avoid attack
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+        else if (CastSpell(CONCUSSIVE_SHOT,pTarget)) { return; }
+        else if (CastSpell(WYVERN_STING,pTarget)) { return; }
+        else if (CastSpell(SCATTER_SHOT,pTarget)) { return; }
+        else if (CastSpell(FREEZING_ARROW,pTarget)) { return; }
+        else if (CastSpell(MISDIRECTION,m_tank)) { return; }
+        else if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget) ) { return; } //no gcd but is cast
+        else if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST && CastSpell(SCARE_BEAST,pTarget)) { return; }
+        else if (pDist <= 2 && CastSpell(FREEZING_TRAP,pTarget)) { return; }
+    }
+    #pragma endregion
+
+    //Select combat mode
+    m_role = BOT_ROLE_DPS_RANGED;
+    if ((isUnderAttack()  && pDist <= ATTACK_DISTANCE) || !m_bot->GetUInt32Value(PLAYER_AMMO_ID) ) { m_role = BOT_ROLE_DPS_MELEE; }
+
+    TakePosition(pTarget);
+
+    #pragma region Buff / Protect
+    //Buff UP
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot) ) {  } //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot) ) { } //no GCD
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+    if (CastSpell(RAPID_FIRE,m_bot)) { return; }
+    if (CastSpell(HUNTERS_MARK,pTarget)) { return; }
+    if ((ai->GetHealthPercent() < 80 || ai->GetManaPercent() < 60 ) && CastSpell(READINESS,m_bot)) { } //no gcd
+
+
+    //Protect yourself if needed
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot) ) { } //no gcd
+    if (ai->GetHealthPercent() < 20 && CastSpell(DETERRENCE,m_bot)) {} //No GCD
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return;  }
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ( pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 20 ) && CastSpell(R_ARCANE_TORRENT, pTarget) ) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCING_SHOT, pTarget) ) { return; }
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(WING_CLIP,pTarget)) return;
+        if (CastSpell(CONCUSSIVE_SHOT,pTarget)) return;
+        if (CastSpell(SCATTER_SHOT, pTarget) ) { return; }
+    }
+    #pragma endregion
+
+    //Do combat
+    switch (m_role)
+    {
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            if (AUTO_SHOT) { m_bot->InterruptNonMeleeSpells( true, AUTO_SHOT ); } //Stop autoshot
+            if (CastSpell(ASPECT_OF_THE_MONKEY,m_bot)) { return; } //Get Monkey aspect
+
+            if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+            // Threat control
+            if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+            else
+            {
+                if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                {
+                    m_bot->SetSelection(pet->getVictim()->GetGUID());
+                    return;
+                }
+                else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                {
+                    m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                    return;
+                }
+                else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                else { return; } // No more threat reducing spells, just slow down
+            }
+
+            if (CastSpell(RAPTOR_STRIKE,pTarget,true,true)) {} //No gcd
+            if (CastSpell(MONGOOSE_BITE,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            else if (CastSpell(COUNTERATTACK,pTarget,true,true)) { return; } // Cannot be sure if casted or not
+            if (CastSpell(WING_CLIP,pTarget)) { return; }
+            if (isUnderAttack(m_tank,6) && CastSpell(SNAKE_TRAP,m_bot)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(EXPLOSIVE_TRAP,m_bot)) { return; }
+            if (CastSpell(IMMOLATION_TRAP,m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            if (m_pulling) {
+                if (GetAI()->CastSpell(CONCUSSIVE_SHOT,pTarget) ||
+                    GetAI()->CastSpell(AUTO_SHOT,pTarget)) {
+                    m_pulling = false;
+                    GetAI()->SetCombatOrder(ORDERS_NONE);
+                    GetAI()->Follow(*GetMaster());
+                    GetAI()->SetIgnoreUpdateTime(2);
+
+                    if(HasPet(GetPlayerBot()))
+                        m_bot->GetPet()->SetReactState(REACT_DEFENSIVE);
+                }
+                return;
+            }
+            if (AUTO_SHOT && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT)) { ai->CastSpell(AUTO_SHOT,pTarget); } //Start autoshot
+            if (!(ai->GetManaPercent() < 85 && m_bot->HasAura(ASPECT_OF_THE_VIPER)) && CastSpell(ASPECT_OF_THE_HAWK,m_bot)) { return; } //Get Hawk aspect
+            if ((ai->GetManaPercent() < 25) && CastSpell(ASPECT_OF_THE_VIPER,m_bot,true,false,true)) { return; } //Build up mana
+
+            // if i am main tank, protect master by taunt
+            if(m_tank->GetGUID() == m_bot->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt && CastSpell(DISTRACTING_SHOT, curAtt))  { return; }
+                // My target is not attacking me, taunt..
+                if (pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(DISTRACTING_SHOT, pTarget) )  { return; }
+            }
+            // If i am not tank, transfer threat to tank or pet..
+            else
+            {
+                if (CastSpell(MISDIRECTION,m_tank)) { return; }
+                if (pet && pet->isAlive() && CastSpell(MISDIRECTION,pet)) { return; }
+
+                // Threat control
+                if (pThreat < threatThreshold || m_bot->HasAura(MISDIRECTION) ) { } //Continue attack
+                else
+                {
+                    if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+                    {
+                        m_bot->SetSelection(pet->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+                    {
+                        m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+                        return;
+                    }
+                    else if (CastSpell(FEIGN_DEATH,m_bot)) { return; }
+                    else { return; } // No more threat reducing spells, just slow down
+                }
+            }
+
+            // DO dps
+            if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(KILL_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(MULTI_SHOT,pTarget)) { return; }
+            if (isUnderAttack(m_tank,4) && CastSpell(VOLLEY,pTarget)) { GetAI()->SetIgnoreUpdateTime(7); return; }
+            if (CanCast(CHIMERA_SHOT,pTarget) &&
+                (pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) || pTarget->HasAura(SERPENT_STING,m_bot->GetGUID()) )
+                && CastSpell(CHIMERA_SHOT,pTarget,false) ) { return; }
+            if (ai->GetManaPercent() < 60 && ai->GetManaPercent(*pTarget) > 4 && CastSpell(VIPER_STING,pTarget)) { return; }
+            if (!pTarget->HasAura(VIPER_STING,m_bot->GetGUID()) && CastSpell(SERPENT_STING,pTarget)) { return; }
+            if (CastSpell(ARCANE_SHOT,pTarget)) { return; }
+            if (CastSpell(BLACK_ARROW,pTarget)) { return; }
+            if (CastSpell(EXPLOSIVE_SHOT,pTarget)) { return; }
+            if (CastSpell(STEADY_SHOT,pTarget)) { return; }
+            break;
+        #pragma endregion
+    }
+
+    /*// drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }*/
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    // buff group
+    if (CastSpell(TRUESHOT_AURA, m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 20 || ai->GetHealthPercent() < 30) { ai->Feast(); }
+
+    #pragma region Check Pet
+    // check for pet
+    if( PET_SUMMON>0 && !m_petSummonFailed && HasPet(m_bot) )
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if( !pet )
+        {
+            // summon pet
+            if( PET_SUMMON>0 && ai->CastSpell(PET_SUMMON,m_bot) )
+                ai->TellMaster( "summoning pet." );
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster( "summon pet failed!" );
+            }
+        }
+        else if( pet->getDeathState() != ALIVE )
+        {
+            // revive pet
+            if( PET_REVIVE>0 && ai->GetManaPercent()>=80 && ai->CastSpell(PET_REVIVE,m_bot) )
+                ai->TellMaster( "reviving pet." );
+        }
+        else if( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        {
+            // heal pet when health lower 50%
+            if( PET_MEND>0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND,0) && ai->GetManaPercent()>=13 && ai->CastSpell(PET_MEND,m_bot) )
+                ai->TellMaster( "healing pet." );
+        }
+        else if(pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit*)m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                    if (!pItemTemplate )
+                        continue;
+                    if(pet->HaveInDiet(pItemTemplate)) // is pItem in pets diet
+                    {
+                        //sLog.outDebug("Food for pet: %s",pItemTemplate->Name1);
+                        caster->CastSpell(caster,51284,true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemTemplate->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                        ai->TellMaster( "feeding pet." );
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag*) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                {
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemTemplate* const pItemTemplate = pItem->GetTemplate();
+                            if (!pItemTemplate )
+                                continue;
+                            if(pet->HaveInDiet(pItemTemplate)) // is pItem in pets diet
+                            {
+                                //sLog.outDebug("Food for pet: %s",pItemTemplate->Name1);
+                                caster->CastSpell(caster,51284,true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemTemplate->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem,count,true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot,PET_FEED,&benefit,NULL,NULL,true); // feed pet
+                                ai->TellMaster( "feeding pet." );
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+                }
+            }
+            if( pet->HasAura(PET_MEND, 0) && !pet->HasAura(PET_FEED, 0))
+
+                ai->TellMaster( "..no pet food!" );
+                ai->SetIgnoreUpdateTime(7);
+        }
+    #pragma endregion
+    }
+} // end DoNonCombatActions
+
+void PlayerbotHunterAI::Pull()
+{
+    if (!AUTO_SHOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+
+    if(GetPlayerBot()->GetPet())
+        GetPlayerBot()->GetPet()->SetReactState(REACT_PASSIVE);
+}
diff --git a/src/server/game/AI/Bots/PlayerbotHunterAI.h b/src/server/game/AI/Bots/PlayerbotHunterAI.h
new file mode 100644
index 0000000..4892624
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotHunterAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotHunterAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotHunterAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotHunterAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        bool HasPet(Player* bot);
+
+        virtual void Pull();
+
+        //buff a specific player, usually a real PC who is not in group
+        //void BuffPlayer(Player *target);
+
+    private:
+        //Hunter
+        bool m_petSummonFailed;
+        bool m_petFeedPetFailed;
+
+        // PET CONTROL
+        uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, KILL_COMMAND, INTIMIDATION, BESTIAL_WRATH;
+
+        // PET SPELL
+        uint32 GROWL, COWER, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH;
+
+        // RANGED ATTACK
+        uint32 AUTO_SHOT, ARCANE_SHOT, EXPLOSIVE_SHOT, STEADY_SHOT, AIMED_SHOT, SCATTER_SHOT, KILL_SHOT, CHIMERA_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, SILENCING_SHOT;
+
+        // STINGS
+        uint32 SERPENT_STING, SCORPID_STING, WYVERN_STING, VIPER_STING;
+
+        // DEBUFF
+        uint32 HUNTERS_MARK, SCARE_BEAST;
+
+        //AOE
+        uint32 VOLLEY, MULTI_SHOT;
+
+        //MELEE
+        uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, COUNTERATTACK;
+
+        //TRAP
+        uint32 FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, SNAKE_TRAP, ARCANE_TRAP, FREEZING_ARROW, BLACK_ARROW;
+
+        //BUFF
+        uint32 TRUESHOT_AURA, DETERRENCE, FEIGN_DEATH, DISENGAGE, RAPID_FIRE, READINESS, MISDIRECTION;
+
+        //ASPECT
+        uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, ASPECT_OF_THE_VIPER;
+
+        uint32 TALENT_MM, TALENT_BM, TALENT_SURVIVAL;
+
+};
+
+#endif
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotMageAI.cpp b/src/server/game/AI/Bots/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..9906390
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotMageAI.cpp
@@ -0,0 +1,384 @@
+#include "PlayerbotMageAI.h"
+class PlayerbotAI;
+PlayerbotMageAI::PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai){\
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotMageAI::~PlayerbotMageAI(){}
+
+void PlayerbotMageAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //arcane
+    ARCANE_MISSILES = ai->getSpellIdExact("Arcane Missiles");
+    ARCANE_EXPLOSION = ai->getSpellIdExact("Arcane Explosion");
+    ARCANE_BLAST = ai->getSpellIdExact("Arcane Blast");
+    ARCANE_BARRAGE = ai->getSpellIdExact("Arcane Barrage");
+
+
+    //fire
+    FIREBALL = ai->getSpellIdExact("Fireball");
+    FROSTFIRE_BOLT = ai->getSpellIdExact("Frostfire Bolt");
+    FIRE_BLAST = ai->getSpellIdExact("Fire Blast");
+    FLAMESTRIKE = ai->getSpellIdExact("Flamestrike");
+    BLAST_WAVE = ai->getSpellIdExact("Blastwave");
+    SCORCH = ai->getSpellIdExact("Scorch");
+    PYROBLAST = ai->getSpellIdExact("Pyroblast");
+    LIVING_BOMB = ai->getSpellIdExact("Living Bomb");
+
+
+    //cold
+    FROSTBOLT = ai->getSpellIdExact("Frostbolt");
+    FROST_NOVA = ai->getSpellIdExact("Frost Nova");
+    ICE_LANCE = ai->getSpellIdExact("Ice Lance");
+    BLIZZARD = ai->getSpellIdExact("Blizzard");
+    CONE_OF_COLD = ai->getSpellIdExact("Cone of Cold");
+
+    WATER_ELEMENTAL = ai->getSpellIdExact("Summon Water Elemental");
+
+
+    // buffs
+    FROST_ARMOR = ai->getSpellIdExact("Ice Armor");
+    if (!FROST_ARMOR) FROST_ARMOR = ai->getSpellIdExact("Frost Armor");
+    MAGE_ARMOR = ai->getSpellIdExact("Mage Armor");
+    MOLTEN_ARMOR = ai->getSpellIdExact("Molten Armor");
+    FIRE_WARD = ai->getSpellIdExact("Fire Ward");
+    FROST_WARD = ai->getSpellIdExact("Frost Ward");
+    MANA_SHIELD = ai->getSpellIdExact("Mana Shield");
+    ICE_BARRIER = ai->getSpellIdExact("Ice Barrier");
+    POM = ai->getSpellIdExact("Presence of Mind");
+    FOCUS_MAGIC = ai->getSpellIdExact("Focus Magic");
+    ARCANE_POWER = ai->getSpellIdExact("Arance Power");
+    COMBUSTION = ai->getSpellIdExact("Combustion");
+    ICY_VEINS = ai->getSpellIdExact("Icy Veins");
+
+    ARCANE_INTELLECT = ai->getSpellIdExact("Arcane Intellect");
+    ARCANE_BRILLIANCE = ai->getSpellIdExact("Arcane Brilliance");
+    DALARAN_INTELLECT = ai->getSpellIdExact("Dalaran Intellect");
+    DALARAN_BRILLIANCE = ai->getSpellIdExact("Dalaran Brilliance");
+    DAMPEN_MAGIC = ai->getSpellIdExact("Dampen Magic");
+    AMPLIFY_MAGIC = ai->getSpellIdExact("Amplify Magic");
+
+
+    //CC
+    POLYMORPH = ai->getSpellIdExact("Polymorph");
+    DRAGONS_BREATH = ai->getSpellIdExact("Dragon's Breath");
+    DEEP_FREEZE = ai->getSpellIdExact("Deep Freeze");
+
+
+    //other
+    CONJURE_REFRESHMENT = ai->getSpellIdExact("Conjure Refreshment");
+    CONJURE_WATER = ai->getSpellIdExact("Conjure Water");
+    CONJURE_FOOD = ai->getSpellIdExact("Conjure Food");
+    CONJURE_MANA_GEM = ai->getSpellIdExact("Conjure Mana Gem");
+    MIRROR_IMAGE = ai->getSpellIdExact("Mirror Image");
+    BLINK = ai->getSpellIdExact("Blink");
+    ICE_BLOCK = ai->getSpellIdExact("Ice Block");
+    INVISIBILITY = ai->getSpellIdExact("Invisibility");
+    EVOCATION = ai->getSpellIdExact("Evocation");
+    REMOVE_CURSE = ai->getSpellIdExact("Remove Curse");
+    COUNTER_SPELL = ai->getSpellIdExact("Counterspell");
+    SLOW = ai->getSpellIdExact("Slow");
+
+    //Special
+    P_BRAIN_FREEZE = 57761; //Brain Freeze proc
+    P_FIRESTARTER = 54741; //Firestarter proc
+    P_HOT_STREAK = 48108; //Hot Sreak proc
+    P_ARCANE_BLAST = 36032; //Arcane blast proc
+    P_MISSILE_BARRAGE = 54490; //Missle Barrage proc
+    P_FINGERS_OF_FROST = 44545; //Fingers of Frost proc
+    IMP_SCORCH = 12873; //IMP SCORCH
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_ARCANE = ARCANE_BARRAGE;
+    TALENT_FIRE = COMBUSTION;
+    TALENT_FROST = ICE_BARRIER;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARCANE) talentCounter++;
+    if (TALENT_FIRE) talentCounter++;
+    if (TALENT_FROST) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ARCANE = 0; TALENT_FIRE = 0; TALENT_FROST = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents (MAGE is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (isUnderAttack())
+    {
+        // Keep hitting but reduce threat
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        //if (CastSpell(INVISIBILITY, m_bot)) { return; }
+        if (ai->GetHealthPercent(*pTarget) > 50 && CastSpell(POLYMORPH)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist > 5 && CastSpell(FROST_NOVA, pTarget)) { return; }
+    if (DEEP_FREEZE && pTarget->isFrozen() && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(DRAGONS_BREATH, pTarget)) { return; }
+    if ((isUnderAttack() || ai->GetHealthPercent() < 75 && !HasAuraName(m_bot, MANA_SHIELD))  && ai->GetManaPercent() > 40 && CastSpell(MANA_SHIELD,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    if ((ai->GetHealthPercent() < 65 || ai->GetManaPercent() < 5) && CastSpell(ICE_BLOCK,m_bot)) { return; }
+    if (isUnderAttack() && CastSpell(ICE_BARRIER, pTarget)) { return; }
+    if (ai->GetManaPercent() < 30 && CastSpell (EVOCATION, m_bot)) { return; }
+
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pThreat < threatThreshold && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(COUNTER_SPELL, pTarget)) { return; } //High threat
+    if (!m_bot->HasAura(MOLTEN_ARMOR) && CastSpell(MOLTEN_ARMOR,m_bot)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 96) { return; } // dont dps too early
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_NOVA,pTarget)) return;
+        if (CastSpell(FROSTBOLT,pTarget)) return;
+    }
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(INVISIBILITY,m_bot)) { return; } //Lets see if we can manage
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+    // buff up
+    if (CastSpell(ICY_VEINS,m_bot)) {} //nogcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(POM,m_bot)) {} //nogcd
+
+    if (TALENT_ARCANE)
+    {
+        if (CastSpell(ARCANE_POWER,m_bot)) {} //nogcd
+        if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+        //AOE
+        if (isUnderAttack(m_tank,5))
+        {
+            if (CastSpell(BLIZZARD,pTarget)) { return; }
+        }
+        //DPS
+        if (ARCANE_BLAST)
+        {
+            Aura *abaura = m_bot->GetAura(P_ARCANE_BLAST);
+            if (abaura && abaura->GetStackAmount() >= 3)
+            {
+                if (m_bot->HasAura(P_MISSILE_BARRAGE) && CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+                else if (CastSpell(ARCANE_BARRAGE,pTarget)) { return; }
+            }
+        }
+        if (CastSpell(ARCANE_BARRAGE,pTarget) ) { return; }
+
+    }
+    if (TALENT_FIRE)
+    {
+        if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+        if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+
+        //AOE
+        if (isUnderAttack(m_tank,5))
+        {
+            if (CastSpell(FLAMESTRIKE,pTarget)) { return; }
+            if (CastSpell(BLAST_WAVE,pTarget)) { return; }
+            if (CastSpell(LIVING_BOMB,pTarget)) { return; }
+            if (CastSpell(DRAGONS_BREATH,pTarget)) { return; }
+        }
+
+        //DPS
+        if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget)) { return; }
+        if (!pTarget->HasAura(LIVING_BOMB,m_bot->GetGUID()) && CastSpell(LIVING_BOMB,pTarget)) { return; }
+        //if (!pTarget->HasAura(IMP_SCORCH) && CastSpell(SCORCH,pTarget)) { return; }
+        if (CastSpell(FIREBALL,pTarget)) { return; }
+    }
+    if (TALENT_FROST)
+    {
+        if (CastSpell(MIRROR_IMAGE,m_bot)) { return; }
+        if (CastSpell(WATER_ELEMENTAL,m_bot)) { return; }
+
+        uint64 pet_guid = m_bot->GetPetGUID();
+        if (pet_guid>0){
+            Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+            Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+            if (unit!=NULL){
+                if (!unit->isInCombat()) {
+                    m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_ATTACK, ACT_COMMAND, pTarget->GetGUID());
+                }
+            }
+        }
+
+        //if (CastSpell(33395, pTarget)) // pet freeze spell
+        //    sLog.outError ("successfully casted freeze");
+
+        //AOE
+        if (isUnderAttack(m_tank,5))
+        {
+            if (CastSpell(BLIZZARD,pTarget)) { return; }
+        }
+
+        //DPS
+        if (m_bot->HasAura(P_FINGERS_OF_FROST) && CastSpell(DEEP_FREEZE,pTarget)) { return; }
+        if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FROSTFIRE_BOLT,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget,true,true)) { return; }
+
+    }
+
+    // Defaults especialy for lower levels
+    if (m_bot->HasAura(P_BRAIN_FREEZE) && CastSpell(FIREBALL,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_FIRESTARTER) && CastSpell(FLAMESTRIKE,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(P_HOT_STREAK) && CastSpell(PYROBLAST,pTarget,1,1)) { return; }
+        if (m_bot->HasAura(POM) && (CastSpell(PYROBLAST,pTarget,1,1) || CastSpell(FIREBALL,pTarget,1,1) || CastSpell(FROSTBOLT,pTarget,1,1))) { return; }
+        if (pTarget->isFrozen() && CastSpell(ICE_LANCE,pTarget)) { return; }
+        if (m_bot->isMoving() && (CastSpell(FIRE_BLAST,pTarget,1,1) || CastSpell(ARCANE_BARRAGE,pTarget) || CastSpell(ICE_LANCE,pTarget))) { return; }
+        if (CastSpell(FIREBALL,pTarget)) { return; }
+        if (CastSpell(FROSTBOLT,pTarget)) { return; }
+        if (CastSpell(ARCANE_MISSILES,pTarget)) { return; }
+
+    // drink potion
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+    // if we get down here, it means we are out of mana, so use wand
+    CastSpell(SHOOT, pTarget);
+
+} //end DoNextCombatManeuver
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    // make sure pet stays by your side
+    uint64 pet_guid = m_bot->GetPetGUID();
+    if (pet_guid>0){
+        Pet* pet = ObjectAccessor::GetPet(*m_bot, pet_guid);
+        Unit *unit = ObjectAccessor::GetUnit(*m_bot, pet_guid);
+        if (unit!=NULL){
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, COMMAND_FOLLOW, ACT_COMMAND, 0);
+            m_bot->GetSession()->HandlePetActionHelper(unit, pet_guid, REACT_DEFENSIVE, ACT_REACTION, 0);
+        }
+    }
+
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,1,1)) { return; }
+
+    //Own Buffs
+    if (MOLTEN_ARMOR) { if ( CastSpell(MOLTEN_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(MAGE_ARMOR,m_bot)) { return; }
+    if (CastSpell(COMBUSTION,m_bot)) { } //nogcd
+    if (!HasAuraName(m_bot, MANA_SHIELD)) CastSpell (MANA_SHIELD);
+
+    //conjure food & water
+    Item *pItem = ai->FindDrink();
+    if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_WATER, m_bot)) { return; }
+        return;
+    }
+    pItem = ai->FindFood();
+    if(pItem == NULL && ai->GetManaPercent() >= 48)
+    {
+        if (CastSpell(CONJURE_REFRESHMENT, m_bot)) { return; }
+        if (CastSpell(CONJURE_FOOD, m_bot)) { return; }
+        return;
+    }
+    //Conjure mana gem??
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && CastSpell (EVOCATION, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+} //end DoNonCombatActions
+
+
+bool PlayerbotMageAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (target->getClass() == CLASS_WARRIOR || target->getClass() == CLASS_DEATH_KNIGHT || target->getClass() == CLASS_ROGUE) return false;
+
+    if (!HasAuraName(target, ARCANE_INTELLECT) && !HasAuraName(target, ARCANE_BRILLIANCE) && !HasAuraName(target, DALARAN_INTELLECT) && !HasAuraName(target, DALARAN_BRILLIANCE))
+    {
+        if (CastSpell(ARCANE_BRILLIANCE, target)) return true;
+        else if (CastSpell (ARCANE_INTELLECT, target)) return true;
+    }
+    return false;
+}
+bool PlayerbotMageAI::CureTarget(Unit *target)
+{
+    //Cures the target
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_CURSE, target)) return true;
+    return false;
+}
diff --git a/src/server/game/AI/Bots/PlayerbotMageAI.h b/src/server/game/AI/Bots/PlayerbotMageAI.h
new file mode 100644
index 0000000..307e519
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotMageAI.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMAGEAI_H
+#define _PLAYERBOTMAGEAI_H
+
+#include "PlayerbotClassAI.h"
+
+enum
+{
+    SPELL_SCORCH,
+    SPELL_POM,
+    SPELL_ARCANE_POWER,
+    SPELL_FIREBALL,
+    SPELL_MISSILES,
+    SPELL_FROSTBOLT
+};
+
+//class Player;
+
+class PlayerbotMageAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotMageAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotMageAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        typedef std::set<Unit *> AttackerSet;
+    private:
+        //arcane
+        uint32 ARCANE_MISSILES, ARCANE_EXPLOSION, ARCANE_BLAST, ARCANE_BARRAGE;
+
+        //fire
+        uint32 FIREBALL, FROSTFIRE_BOLT, FIRE_BLAST, FLAMESTRIKE, BLAST_WAVE, SCORCH, PYROBLAST, LIVING_BOMB;
+
+        //cold
+        uint32 FROSTBOLT, FROST_NOVA, ICE_LANCE, BLIZZARD, CONE_OF_COLD, WATER_ELEMENTAL;
+
+        // buffs
+        uint32 FROST_ARMOR, ICE_ARMOR, MAGE_ARMOR, MOLTEN_ARMOR, FIRE_WARD, FROST_WARD, MANA_SHIELD, ICE_BARRIER, POM, FOCUS_MAGIC, ARCANE_POWER, COMBUSTION, ICY_VEINS,
+            ARCANE_INTELLECT, ARCANE_BRILLIANCE, DALARAN_INTELLECT, DALARAN_BRILLIANCE, DAMPEN_MAGIC, AMPLIFY_MAGIC;
+
+        //CC
+        uint32 POLYMORPH, DRAGONS_BREATH, DEEP_FREEZE;
+
+        //other
+        uint32 CONJURE_REFRESHMENT, CONJURE_WATER, CONJURE_FOOD, CONJURE_MANA_GEM, MIRROR_IMAGE, BLINK, ICE_BLOCK, INVISIBILITY, EVOCATION, REMOVE_CURSE, COUNTER_SPELL, SLOW, SHOOT;
+
+        //special
+        uint32 P_BRAIN_FREEZE, P_FIRESTARTER, P_HOT_STREAK, P_ARCANE_BLAST, P_MISSILE_BARRAGE, P_FINGERS_OF_FROST, IMP_SCORCH;
+
+
+        uint32 TALENT_ARCANE, TALENT_FIRE, TALENT_FROST;
+
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotPaladinAI.cpp b/src/server/game/AI/Bots/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..abaec14
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPaladinAI.cpp
@@ -0,0 +1,536 @@
+#include "PlayerbotPaladinAI.h"
+
+class PlayerbotAI;
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPaladinAI::~PlayerbotPaladinAI(){}
+
+void PlayerbotPaladinAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    FLASH_OF_LIGHT = ai->getSpellIdExact("Flash of Light");
+    HOLY_LIGHT = ai->getSpellIdExact("Holy Light");
+    HOLY_SHOCK = ai->getSpellIdExact("Holy Shock");
+    CLEANSE = ai->getSpellIdExact("Cleanse");
+    if (!CLEANSE) CLEANSE = ai->getSpellIdExact("Purify");
+    LOH = ai->getSpellIdExact("Lay on Hands");
+    SACRED_SHIELD = ai->getSpellIdExact("Sacred Shield");
+    BEACON_OF_LIGHT = ai->getSpellIdExact("Beacon of Light");
+    DIVINE_FAVOR = ai->getSpellIdExact("Divine Favor");
+    REDEMPTION = ai->getSpellIdExact("Redemption");
+
+    //Damages
+    JOL = ai->getSpellIdExact("Judgement of Light");
+    JOW = ai->getSpellIdExact("Judgement of Wisdom");
+    JOJ = ai->getSpellIdExact("Judgement of Justice");
+    HAMMER_OF_WRATH = ai->getSpellIdExact("Hammer of Wrath");
+    EXORCISM = ai->getSpellIdExact("Exorcism");
+    HOLY_WRATH = ai->getSpellIdExact("Holy Wrath");
+    CONSECRATION = ai->getSpellIdExact("Consecration");
+    AVENGERS_SHIELD = ai->getSpellIdExact("Avenger's Shield");
+    SHIELD_OF_RIGHTEOUSNESS = ai->getSpellIdExact("Shield of Righteousness");
+    HOTR = ai->getSpellIdExact("Hammer of the Righteous");
+    CRUSADER_STRIKE = ai->getSpellIdExact("Crusader Strike");
+    DIVINE_STORM = ai->getSpellIdExact("Divine Storm");
+
+    //CC
+    HAMMER_OF_JUSTICE = ai->getSpellIdExact("Hammer of Justice");
+    REPENTANCE = ai->getSpellIdExact("Repentance");
+
+    //Self buffs
+    SOL = ai->getSpellIdExact("Seal of Light");
+    SOW = ai->getSpellIdExact("Seal of Wisdom");
+    SOR = ai->getSpellIdExact("Seal of Righteousness");
+    SOC = ai->getSpellIdExact("Seal of Command");
+    SOV = ai->getSpellIdExact("Seal of Vengeance");
+    if (!SOV) SOV = ai->getSpellIdExact("Seal of Corruption");
+    DIVINE_PLEA = ai->getSpellIdExact("Divine Plea");
+    HOLY_SHIELD = ai->getSpellIdExact("Holy Shield");
+    RIGHTEOUS_FURY = ai->getSpellIdExact("Righteous Fury");
+    DIVINE_SHIELD = ai->getSpellIdExact("Divine Shield");
+    if (!DIVINE_SHIELD) DIVINE_SHIELD = ai->getSpellIdExact("Divine Protection");
+    AVENGING_WRATH = ai->getSpellIdExact("Avenging Wrath");
+
+    //AURAS
+    DEVOTION_AURA = ai->getSpellIdExact("Devotion Aura");
+    RETRIBUTION_AURA = ai->getSpellIdExact("Retribution Aura");
+    CONCENTRATION_AURA = ai->getSpellIdExact("Concentration Aura");
+    FIRE_AURA = ai->getSpellIdExact("Fire Resistance Aura");
+    FROST_AURA = ai->getSpellIdExact("Frost Resistance Aura");
+    SHADOW_AURA = ai->getSpellIdExact("Shadow Resistance Aura");
+    CRUSADER_AURA = ai->getSpellIdExact("Crusader Aura");
+
+    //Blessings
+    BOW = ai->getSpellIdExact("Blessing of Wisdom");
+    BOM = ai->getSpellIdExact("Blessing of Might");
+    BOS = ai->getSpellIdExact("Blessing of Sanctuary");
+    BOK = ai->getSpellIdExact("Blessing of Kings");
+    GBOW = ai->getSpellIdExact("Greater Blessing of Wisdom");
+    GBOM = ai->getSpellIdExact("Greater Blessing of Might");
+    GBOS = ai->getSpellIdExact("Greater Blessing of Sanctuary");
+    GBOK = ai->getSpellIdExact("Greater Blessing of Kings");
+
+    //Hands
+    HOF = ai->getSpellIdExact("Hand of Freedom");
+    HOR = ai->getSpellIdExact("Hand of Reckoning");
+    HOS = ai->getSpellIdExact("Hand of Salvation");
+    HOP = ai->getSpellIdExact("Hand of Protection");
+    DIVINE_SACRIFICE = ai->getSpellIdExact("Divine Sacrifice");
+
+    //Taunt
+    RIGHTEOUS_DEFENSE = ai->getSpellIdExact("Righteous Defense");
+
+    FORBEARANCE = 25771;
+    AOW = 53488;
+
+    TALENT_RETRI = CRUSADER_STRIKE;
+    TALENT_PROT = HOLY_SHIELD;
+    TALENT_HOLY = HOLY_SHOCK;
+
+    uint8 talentCounter = 0;
+    if (TALENT_RETRI) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_RETRI = 0; TALENT_PROT = 0; TALENT_HOLY = 0; } //Unreliable Talent detection.
+
+    #pragma endregion
+}
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+
+    // Fill mana if needed
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && ai->GetManaPercent() < 20 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (ai->GetManaPercent() < 30 && CastSpell (DIVINE_PLEA, m_bot)) { return; }
+
+    // If hp is too low divine shield
+    if (ai->GetHealthPercent() < 20 && (!m_bot->HasAura(DIVINE_SHIELD) || !m_bot->HasAura(HOP) || !m_bot->HasAura(SACRED_SHIELD)))
+    {
+        if (!m_bot->HasAura(FORBEARANCE))
+        {
+            if (CastSpell(DIVINE_SHIELD,m_bot)) { return; }
+            if (CastSpell(HOP,m_bot)) { return; }
+        }
+        else if (CastSpell(SACRED_SHIELD,m_bot)) { return; }
+    }
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && !TALENT_PROT && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(HOS,m_bot,true,true)) { }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        if (TALENT_PROT) { m_role=BOT_ROLE_TANK; } //Just Keep Tanking
+        else
+        {
+            if (TALENT_RETRI) {
+                if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+                else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else { m_role = BOT_ROLE_TANK; } //have no shield but can tank if you think so
+            }
+            else if (TALENT_HOLY) //I am both healer and tank?? Hmm
+            {
+                if ((ai->GetHealthPercent() <= 70 || masterHP <70 ) && (ai->GetManaPercent() >= 50))m_role = BOT_ROLE_SUPPORT;
+                else if (OwnPartyHP < 20 && ai->GetManaPercent() >= 30) { m_role = BOT_ROLE_SUPPORT; }
+                else m_role = BOT_ROLE_TANK;
+            }
+            else { m_role = BOT_ROLE_TANK; } //Unknown build or low level
+        }
+    }
+    else if (TALENT_RETRI) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 40)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 30) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_MELEE; }
+    }
+    else if (TALENT_PROT) {
+        if ((ai->GetHealthPercent() <= 30 || masterHP <40 ) && (ai->GetManaPercent() >= 20)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) { m_role = BOT_ROLE_SUPPORT; }
+        else { m_role = BOT_ROLE_OFFTANK; }
+    }
+    else if (TALENT_HOLY) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+    //takepos
+    if (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) TakePosition(pTarget,BOT_ROLE_DPS_MELEE,0.5f);
+    else TakePosition(pTarget,m_role);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+
+            ChangeAura(CONCENTRATION_AURA);
+            if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) {    if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if(SOL && ai->GetHealthPercent() < 40) { if(CastSpell(SOL,m_bot)) { return; } }
+            else if(CastSpell(SOR, m_bot)) { return; }
+
+            if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) { } // no gcd
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            if (ai->GetManaPercent() <= 80 && CastSpell(JOW,pTarget,true,true)) { return; }
+
+            // Use Spells only if mana is sufficient..
+            if(ai->GetManaPercent() < offensiveSpellThreshold ) return;
+
+        break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+
+            ChangeAura(DEVOTION_AURA);
+            if (CastSpell(RIGHTEOUS_FURY,m_bot)) { return; }
+            // Choose Seal
+            if (SOW && ai->GetManaPercent() <= 30) { if (CastSpell(SOW,m_bot)) { return; } }
+            else if (m_bot->HasAura(SOW) && ai->GetManaPercent() < 85) { } // Paladin was striving for mana, keep until he got most of his mana back
+            else if (SOL && ai->GetHealthPercent() < 40) { if (CastSpell(SOL,m_bot)) { return; } }
+            else if (CastSpell(SOR,m_bot)) { return; }
+
+            // We are tank/offtank threat is not an issiue;
+            // Use taunts only if helping target is not main tank..
+            // Taunt if needed (Only for master)
+            if(GetMaster()->GetGUID() != m_tank->GetGUID())
+            {
+                // Taunt if needed (Only for master)
+                Unit *curAtt = GetAttackerOf(GetMaster());
+                if (curAtt)
+                {
+                    if (isUnderAttack(GetMaster(),2) && CastSpell(RIGHTEOUS_DEFENSE, GetMaster())) { return; }
+                    if (CastSpell(HOR, curAtt,true,true))  { } //No GCD
+                }
+            }
+            // My target is not attacking me, taunt..
+            if ( m_tank->GetGUID() == m_bot->GetGUID() && pVictim && pVictim->GetGUID() != m_bot->GetGUID() && CastSpell(HOR, pTarget,true,true) )  { } //NO GCD
+
+            // Tank specials
+            if (TALENT_PROT && ai->GetManaPercent() < 90 && CastSpell (DIVINE_PLEA, m_bot)) { return; } //Prot paladin always uses this..
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(HOLY_SHIELD,m_bot)) { return; }
+            if (CastSpell(AVENGERS_SHIELD,pTarget,true,true)) { return; }
+            if (CastSpell(HOTR,pTarget,true,true)) { return; }
+            if (CastSpell(HOLY_WRATH,pTarget,true,true)){ return; }
+            if (CastSpell(CONSECRATION,pTarget)) { return; }
+            if (m_bot->getRace() == (uint8) RACE_DWARF && CastSpell(R_STONEFORM,m_bot)) { return; }
+
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+
+        break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+
+            ChangeAura(RETRIBUTION_AURA);
+            if (!TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID()) m_bot->RemoveAurasDueToSpell(RIGHTEOUS_FURY);
+            if (CastSpell(SOV,m_bot)) { return; }
+
+            if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+            if (!m_bot->HasAura(FORBEARANCE) && CastSpell(AVENGING_WRATH,m_bot)) {} //no gcd
+            if (CastSpell(JOW,pTarget)) { return; }
+            if (CastSpell(DIVINE_STORM, pTarget)) { return; }
+            if (CastSpell(CRUSADER_STRIKE, pTarget)) { return; }
+            if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget)) { return; }
+            if (CastSpell(CONSECRATION,pTarget)) { return; }
+            if (m_bot->HasAura(AOW) && CastSpell(EXORCISM,pTarget)) { return; }
+            if (CastSpell(HOLY_WRATH,pTarget)) { return; }
+
+        break;
+        #pragma endregion
+
+    }
+    #pragma region PaladinCommon
+    // Shared dps spells
+    if (pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID && pTarget->IsNonMeleeSpellCasted(true) && CastSpell (REPENTANCE, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+
+    // If at threat limit, stop
+    if(pThreat > threatThreshold && !TALENT_PROT && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(HOS,m_bot)) { return; } //Lets see if we can manage with HOS
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+    // Continue attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (GetAI()->GetHealthPercent(*pTarget)<20 && CastSpell(HAMMER_OF_WRATH, pTarget,true,true)) { return; } //no gcd but cast
+    if (CastSpell (HAMMER_OF_JUSTICE, pTarget)) { return; }
+    if (CanCast(JOW,pTarget,true) &&
+        ( ( ai->GetManaPercent() <= 70 && ai->GetHealthPercent() > 90)
+        || ( ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 75)
+        || ( ai->GetManaPercent() <= 20 && ai->GetHealthPercent() > 20) )
+        && CastSpell(JOW,pTarget,false)) { return; }
+    else if (CastSpell(JOL,pTarget),true,true) { return; }
+    if (CastSpell(SHIELD_OF_RIGHTEOUSNESS,pTarget,true,true)) { return; }
+    if (CastSpell (DIVINE_STORM, pTarget,true,true)) { return; }
+    if (CastSpell (CRUSADER_STRIKE, pTarget,true,true)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no GCD but cast
+    if (isUnderAttack(m_tank,4) && CastSpell(HOLY_WRATH,pTarget,true,true)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(CONSECRATION,pTarget)) { return; }
+    if (CastSpell(HOLY_SHOCK,pTarget,true,true)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 60 && OwnPartyHP < 65 && DoSupportRaid(m_bot)) { return; } //if there is spare time and mana, do healz and other stuff..
+    else if (m_role != BOT_ROLE_SUPPORT && ai->GetManaPercent() > 30 && DoSupportRaid(m_bot,30,false,false,false,true,false)) { return; }
+    if (CastSpell(EXORCISM,pTarget,true,true)) { return; }
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_OF_LIGHT,m_bot)) { return; }
+    if (ai->GetManaPercent() < 70) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotPaladinAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 10 && m_bot->isInCombat() && CastSpell(LOH, target)) { return true; }
+    //if(hp < 10 && m_bot->isInCombat() && CastSpell(SACRED_SHIELD,target)) { return true; }
+    if(hp < 15 && m_bot->isInCombat() && CastSpell(HOP,target)) { return true; }
+    if(hp < 20 && m_bot->isInCombat() && CastSpell(BEACON_OF_LIGHT,target)) { return true; }
+    if(hp < 30 && CastSpell(HOLY_SHOCK,target,true,true,true)) { return true; }
+    if(hp < 30 && m_bot->isInCombat() && CanCast(DIVINE_FAVOR,m_bot,true) && CanCast(HOLY_LIGHT,target,true) ) { CastSpell(DIVINE_FAVOR, m_bot,false); return CastSpell(HOLY_LIGHT,target,false); } //No gcd
+    if(hp < 30 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD but has cast
+    if(hp < 65 && CastSpell(HOLY_LIGHT,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(FLASH_OF_LIGHT,target,true,true)) { return true; }
+    if(hp < 95 && m_bot->isInCombat() && CastSpell(SACRED_SHIELD,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPaladinAI::CureTarget(Unit *target)
+{
+    if (!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE, target)) { return true; }
+    return false;
+
+} //end CureTarget
+
+bool PlayerbotPaladinAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    // Check if target already has a blessing by me..
+    if (HasAuraName(target,BOW,m_bot->GetGUID()) ||
+    HasAuraName(target,BOK,m_bot->GetGUID()) ||
+    HasAuraName(target,BOM,m_bot->GetGUID()) ||
+    HasAuraName(target,BOS,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOW,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOK,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOM,m_bot->GetGUID()) ||
+    HasAuraName(target,GBOS,m_bot->GetGUID())
+    ) return false;
+
+#pragma region Choose Buff > Class
+    switch(target->getClass())
+    {
+        case CLASS_MAGE:
+        case CLASS_WARLOCK:
+            if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_PRIEST:
+            if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_HUNTER:
+            if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_ROGUE:
+            if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+            else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            break;
+        case CLASS_WARRIOR:
+        case CLASS_DEATH_KNIGHT:
+            if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+            {
+                if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            }
+            else
+            {
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            }
+            break;
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (target->GetMaxPower(target->getPowerType()) > target->GetMaxHealth())
+            {
+                if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+            }
+            else if (target->GetUnitDodgeChance() + target->GetUnitParryChance() > 40)
+            {
+                if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                else if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+            }
+            else
+            {
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+            }
+            break;
+
+        default:
+                if (CanCast(GBOK,target) && !HasAuraName(target,BOK) && !HasAuraName(target,GBOK) ) return CastSpell(GBOK,target,false);
+                else if (CanCast(GBOM,target) && !HasAuraName(target,BOM) && !HasAuraName(target,GBOM) ) return CastSpell(GBOM,target,false);
+                else if (CanCast(GBOW,target) && !HasAuraName(target,BOW) && !HasAuraName(target,GBOW) ) return CastSpell(GBOW,target,false);
+                else if (CanCast(GBOS,target) && !HasAuraName(target,BOS) && !HasAuraName(target,GBOS) ) return CastSpell(GBOS,target,false);
+                break;
+    }
+#pragma endregion
+
+    return false;
+}
+
+bool PlayerbotPaladinAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(REDEMPTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(REDEMPTION, target, false);
+}
+
+bool PlayerbotPaladinAI::ChangeAura(uint32 aura)
+{
+    Player *m_bot = GetPlayerBot();
+    if(!aura) return false;
+
+    if(!CanCast(aura,m_bot)) return false;
+
+    if(m_bot->HasAura(aura))
+    {
+        if (aura == DEVOTION_AURA)
+        {
+            if (ChangeAura(FIRE_AURA)) return true;
+            if (ChangeAura(FROST_AURA)) return true;
+            if (ChangeAura(SHADOW_AURA)) return true;
+            return true;
+        }
+        else return ChangeAura(DEVOTION_AURA);
+    }
+    return CastSpell(aura,m_bot,false);
+}
+
diff --git a/src/server/game/AI/Bots/PlayerbotPaladinAI.h b/src/server/game/AI/Bots/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..999cb42
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPaladinAI.h
@@ -0,0 +1,70 @@
+#ifndef _PLAYERBOTPALADINAI_H
+#define _PLAYERBOTPALADINAI_H
+
+#include "PlayerbotClassAI.h"
+#include "SharedDefines.h"
+
+class PlayerbotPaladinAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotPaladinAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotPaladinAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeAura(uint32 aura);
+
+    private:
+        //heals
+        uint32 FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, REZZ, CLEANSE, LOH, SACRED_SHIELD, BEACON_OF_LIGHT, DIVINE_FAVOR, REDEMPTION;
+
+        //Damages
+        uint32 JOL, JOW, JOJ, HAMMER_OF_WRATH, EXORCISM, HOLY_WRATH, CONSECRATION, AVENGERS_SHIELD, SHIELD_OF_RIGHTEOUSNESS, HOTR, CRUSADER_STRIKE, DIVINE_STORM;
+
+        //CC
+        uint32 HAMMER_OF_JUSTICE, REPENTANCE;
+
+        //Self buffs
+        uint32 SOL, SOW, SOR, SOC, SOV, DIVINE_PLEA, HOLY_SHIELD, RIGHTEOUS_FURY, DIVINE_SHIELD, AVENGING_WRATH;
+
+        //AURAS
+        uint32 DEVOTION_AURA, RETRIBUTION_AURA, CONCENTRATION_AURA, FIRE_AURA, FROST_AURA, SHADOW_AURA, CRUSADER_AURA ;
+
+        //Blessings
+        uint32 BOW, BOM, BOS, BOK, GBOW, GBOM, GBOS, GBOK;
+
+        //Hands
+        uint32 HOF, HOR, HOS, HOP, DIVINE_SACRIFICE;
+
+        //Taunt
+        uint32 RIGHTEOUS_DEFENSE;
+
+        uint32 FORBEARANCE;
+
+        uint32 TALENT_HOLY, TALENT_PROT, TALENT_RETRI;
+
+        //procs
+        uint32 AOW;
+
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotPriestAI.cpp b/src/server/game/AI/Bots/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..729316f
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPriestAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotPriest.cpp
+Complete: maybe around 55%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Holy And Disc builds do not cast any offensive spells requiring cast time..(To compensate for the fact that Healing decision is not that intelligent)
+                - Priest breaks her own CCs.. Need a check for bots to not attack CC ed mobs..
+                - Wand usage is not very smooth..
+
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotPriestAI.h"
+
+class PlayerbotAI;
+PlayerbotPriestAI::PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotPriestAI::~PlayerbotPriestAI(){}
+
+void PlayerbotPriestAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //heals
+    RENEW = ai->getSpellIdExact("Renew");
+    FLASH_HEAL = ai->getSpellIdExact("Flash Heal");
+    if (!FLASH_HEAL) FLASH_HEAL = ai->getSpellIdExact("Lesser Heal");
+    HEAL = ai->getSpellIdExact("Greater Heal");
+    if (!HEAL) HEAL = ai->getSpellIdExact("Heal");
+    if (!HEAL) HEAL = FLASH_HEAL;
+    BINDING_HEAL = ai->getSpellIdExact("Binding Heal");
+    PO_MENDING = ai->getSpellIdExact("Prayer of Mending");
+    DESPERATE_PRAYER = ai->getSpellIdExact("Desperate Prayer");
+    PO_HEALING = ai->getSpellIdExact("Prayer of Healing");
+    CIRCLE_OF_HEALING = ai->getSpellIdExact("Circle of Healing");
+    DIVINE_HYMN = ai->getSpellIdExact("Divine Hymn");
+    RESURRECTION = ai->getSpellIdExact("Resurrection");
+    HYMN_OF_HOPE = ai->getSpellIdExact("Hymn of Hope");
+    CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    if (!CURE_DISEASE) CURE_DISEASE = ai->getSpellIdExact("Abolish Disease");
+    DISPEL_MAGIC = ai->getSpellIdExact("Dispel Magic");
+    MASS_DISPEL = ai->getSpellIdExact("Mass Dispel");
+
+    //Holy Offensive
+    SMITE = ai->getSpellIdExact("Smite");
+    HOLY_FIRE = ai->getSpellIdExact("Holy Fire");
+    PENANCE = ai->getSpellIdExact("Penance");
+    HOLY_NOVA = ai->getSpellIdExact("Holy Nova");
+
+    //Shadow Offensive
+    MIND_BLAST = ai->getSpellIdExact("Mind Blast");
+    SW_PAIN = ai->getSpellIdExact("Shadow Word: Pain");
+    DEVOURING_PLAGUE = ai->getSpellIdExact("Devouring Plague");
+    MIND_FLAY = ai->getSpellIdExact("Mind Flay");
+    VAMPIRIC_EMBRACE = ai->getSpellIdExact("Vampiric Embrace");
+    VAMPIRIC_TOUCH = ai->getSpellIdExact("Vampiric Touch");
+    SW_DEATH = ai->getSpellIdExact("Shadow Word: Death");
+    MIND_SEAR = ai->getSpellIdExact("Mind Sear");
+    MANA_BURN = ai->getSpellIdExact("Mana Burn");
+    SHADOWFIEND = ai->getSpellIdExact("Shadowfiend");
+
+    //CC - Breaker
+    PSYCHIC_SCREAM = ai->getSpellIdExact("Psychic Scream");
+    PSYCHIC_HORROR = ai->getSpellIdExact("Psychic Horror");
+    MIND_SOOTHE = ai->getSpellIdExact("Mind Soothe");
+    SHACKLE_UNDEAD = ai->getSpellIdExact("Shackle Undead");
+    SILENCE = ai->getSpellIdExact("Silence");
+    MIND_CONTROL = ai->getSpellIdExact("Mind Control");
+
+    //buffs
+    PW_SHIELD = ai->getSpellIdExact("Power Word: Shield");
+    INNER_FIRE = ai->getSpellIdExact("Inner Fire");
+    GUARDIAN_SPIRIT = ai->getSpellIdExact("Guardian Spirit");
+    FADE = ai->getSpellIdExact("Fade");
+    INNER_FOCUS = ai->getSpellIdExact("Inner Focus");
+    POWER_INFUSION = ai->getSpellIdExact("Power Infusion");
+    PAIN_SUPPRESSION = ai->getSpellIdExact("Pain Suppression");
+    SHADOWFORM = ai->getSpellIdExact("Shadowform");
+    DISPERSION = ai->getSpellIdExact("Dispersion");
+    LIGHTWELL = ai->getSpellIdExact("Lightwell");
+
+    PW_FORTITUDE = ai->getSpellIdExact("Power Word: Fortitude");
+    DIVINE_SPIRIT = ai->getSpellIdExact("Divine Spirit");
+    SHADOW_PROTECTION = ai->getSpellIdExact("Shadow Protection");
+    PO_FORTITUDE = ai->getSpellIdExact("Prayer of Fortitude");
+    PO_SPIRIT = ai->getSpellIdExact("Prayer of Spirit");
+    PO_SHADOW_PROTECTION = ai->getSpellIdExact("Prayer of Shadow Protection");
+    FEAR_WARD = ai->getSpellIdExact("Fear Ward");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DISC = PAIN_SUPPRESSION;
+    TALENT_HOLY = CIRCLE_OF_HEALING;
+    TALENT_SHADOW = SHADOWFORM;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DISC) talentCounter++;
+    if (TALENT_HOLY) talentCounter++;
+    if (TALENT_SHADOW) talentCounter++;
+    if (talentCounter > 1) { TALENT_DISC = 0; TALENT_HOLY = 0; TALENT_SHADOW = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    /*
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, pTarget) && ai->GetHealthPercent() < 60 && CastSpell(HEAL)) ||
+            CastSpell(PAIN) ||
+            (ai->GetHealthPercent() < 80 && CastSpell(RENEW)) ||
+            (m_bot->GetDistance(pTarget) <= 5 && CastSpell(SCREAM)) ||
+            CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && CastSpell(FLASH_HEAL)) ||
+            CastSpell(SMITE);
+            return;
+    }*/
+
+
+    //------- Non Duel combat ----------
+
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[6] = { DISPEL_MAGIC, CURE_DISEASE, DISPERSION, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+    {
+        m_role = BOT_ROLE_DPS_RANGED;
+    }
+    else if (TALENT_SHADOW) {
+        if ((ai->GetHealthPercent() <= 40 || masterHP <40 ) && (ai->GetManaPercent() >= 30)) { m_role = BOT_ROLE_SUPPORT; }
+        else if (OwnPartyHP < 40 && ai->GetManaPercent() >= 40) {m_role = BOT_ROLE_SUPPORT;}
+        else { m_role = BOT_ROLE_DPS_RANGED; }
+    }
+    else { m_role = BOT_ROLE_SUPPORT; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(FADE,m_bot)) { return; }
+        else if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+
+    if (m_role == BOT_ROLE_DPS_RANGED && CastSpell(SHADOWFORM,m_bot)) { return; }
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetForm() == FORM_SHADOW) { m_bot->RemoveAurasDueToSpell(SHADOWFORM); }
+
+    //Buff
+    if (CastSpell(INNER_FIRE,m_bot)) { } //nogcd
+    if (CastSpell(POWER_INFUSION,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+
+    if (ai->GetForm() != FORM_SHADOW)
+    {
+        if (PO_MENDING && ai->GetHealthPercent(*m_tank) < 90 && !HasAuraName(m_tank, "Prayer of Mending") && CastSpell(PO_MENDING,m_tank)) { return; } //MEND tank first
+        if (DoSupportRaid(m_bot)) { return; }
+        //heal pets and bots
+        Unit *target = DoSelectLowestHpFriendly(30, 1000);
+        if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+    }
+    if (ai->GetForm() == FORM_SPIRITOFREDEMPTION) { return; } //You're dead..
+
+
+    //PROTECT
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (PSYCHIC_HORROR && CastSpell(PSYCHIC_HORROR, pTarget)) { return; }
+        if (PSYCHIC_SCREAM && CastSpell(PSYCHIC_SCREAM, pTarget)) { return; }
+        if (SHACKLE_UNDEAD && pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_UNDEAD && CastSpell(SHACKLE_UNDEAD, pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (ai->GetHealthPercent() < 20 && CastSpell(DESPERATE_PRAYER)) { return; }
+    if (ai->GetHealthPercent() < 30 && CastSpell(PW_SHIELD)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (ai->GetHealthPercent() < 60 && CastSpell(PAIN_SUPPRESSION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() < 10 && CastSpell(DISPERSION,m_bot)) { return; }
+    if (ai->GetManaPercent() < 10 && CastSpell (HYMN_OF_HOPE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+
+
+    //Break Spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(SILENCE, pTarget)) { return; }
+
+
+    // If at threat limit, try to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(PAIN_SUPPRESSION,m_bot)) { return; } //Lets see if we can manage
+            else if (CastSpell(FADE,m_bot)) { return; }
+            else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+    //WAND
+    if (ai->GetManaPercent() < 5 ||
+        (m_role != BOT_ROLE_DPS_RANGED && SHOOT && !m_bot->FindCurrentSpellBySpellId(SHOOT) && ai->CastSpell(SHOOT,pTarget) )
+        ) { return; } //Start autoshot
+
+    // Continue spell attacking if theres excess mana (for healers)
+    if (m_role == BOT_ROLE_SUPPORT && ai->GetManaPercent() < offensiveSpellThreshold) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (CastSpell(VAMPIRIC_EMBRACE,pTarget)) { return; }
+    if (CastSpell(VAMPIRIC_TOUCH,pTarget)) { return; }
+    if (CastSpell(DEVOURING_PLAGUE,pTarget)) { return; }
+    if (CastSpell(SW_PAIN,pTarget)) { return; }
+
+    if (ai->GetForm() == FORM_SHADOW)
+    {
+        if (castDispel(DISPEL_MAGIC, pTarget)) { return; } //Dispel buffs if any
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(MIND_FLAY,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+    }
+
+    if (ai->GetForm() == FORM_NONE && m_role == BOT_ROLE_DPS_RANGED)
+    {
+        if (CastSpell(PENANCE,pTarget)) { return; }
+        if (CastSpell(MIND_BLAST,pTarget)) { return; }
+        if (CastSpell(HOLY_FIRE,pTarget)) { return; }
+        if (CastSpell(SMITE,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(MIND_SEAR,pTarget)) { return; }
+        if (isUnderAttack(m_tank,4) && CastSpell(HOLY_NOVA,pTarget)) { return; }
+    }
+
+     // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+} //end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Own Buffs
+    if (CastSpell(INNER_FIRE,m_bot)) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(30, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(FLASH_HEAL,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+
+
+bool PlayerbotPriestAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && m_bot->isInCombat() && CastSpell(GUARDIAN_SPIRIT,target)) { } //nogcd
+    if (hp < 30 && CastSpell(PENANCE,target,true,false,true)) { return true; } //Channeling Dual purpose
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(PW_SHIELD,target)) { return true; } //Check weakened soul
+    if (hp < 80 && hp > 50 && GetAI()->GetHealthPercent() < 80 && CastSpell (BINDING_HEAL,target)) { return true; }
+    if (hp < 85 && CastSpell(RENEW,target)) { return true; }
+    if (hp < 40 && GetPlayerBot()->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) { return true; } // no GCD, but has cast
+    if (hp < 55 && hp > 35 && CastSpell(HEAL,target)) { return true; }
+    if (hp < 75 && CastSpell(FLASH_HEAL,target)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotPriestAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    // if (hp < 75 && CastSpell(PO_MENDING, rTarget)) { return true; } //save this for tank
+    if (hp < 35 && m_bot->isInCombat() && CastSpell(DIVINE_HYMN,rTarget)) { /*GetAI()->SetIgnoreUpdateTime(9);*/ return true; }
+    if (hp < 70 && CastSpell(CIRCLE_OF_HEALING,rTarget)) { return true; }
+    if (hp < 75 && hp > 30 && countNeedHeal > 4 && CastSpell(PO_HEALING)) { return true; }
+    if (hp < 65 && CastSpell(HOLY_NOVA,rTarget,true,false,true)) { return true; }
+
+    return false;
+}
+
+//Cures the target
+bool PlayerbotPriestAI::CureTarget(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(DISPEL_MAGIC, target,true,false,true)) return true;
+    if (castDispel(CURE_DISEASE, target)) return true;
+    // if(HasAuraName(target, "Venom Spit") || HasAuraName(target, "Poison")) return CastSpell(CURE_POISON, target);
+    return false;
+}
+
+bool PlayerbotPriestAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(RESURRECTION,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+   // msg += " with ";
+   // msg += *REZZSpell->SpellName;
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(RESURRECTION, target,false);
+}
+
+bool PlayerbotPriestAI::BuffPlayer(Unit *target)
+{
+    if(!target || target->isDead()) return false;
+
+    return (
+        (!HasAuraName(target, PW_FORTITUDE) && !HasAuraName(target, PO_FORTITUDE) && CastSpell (PW_FORTITUDE, target)) ||
+        (!HasAuraName(target, SHADOW_PROTECTION) && !HasAuraName(target, PO_SHADOW_PROTECTION) && CastSpell(SHADOW_PROTECTION, target)) ||
+        (!HasAuraName(target, DIVINE_SPIRIT) && !HasAuraName(target, PO_SPIRIT) && CastSpell (DIVINE_SPIRIT, target)) ||
+        (!HasAuraName(target, FEAR_WARD) && CastSpell (FEAR_WARD, target))
+         );
+}
diff --git a/src/server/game/AI/Bots/PlayerbotPriestAI.h b/src/server/game/AI/Bots/PlayerbotPriestAI.h
new file mode 100644
index 0000000..9670986
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotPriestAI.h
@@ -0,0 +1,59 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+    virtual ~PlayerbotPriestAI();
+
+    virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    //Heals the target based off its HP
+    bool HealTarget(Unit *target, uint8 hp);
+
+    bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+    //Cures the target
+    bool CureTarget(Unit *target);
+
+    bool RezTarget (Unit *target);
+
+private:
+    //heals
+    uint32 RENEW, FLASH_HEAL, HEAL, BINDING_HEAL, PO_MENDING, DESPERATE_PRAYER, PO_HEALING, CIRCLE_OF_HEALING, DIVINE_HYMN, RESURRECTION, HYMN_OF_HOPE, CURE_DISEASE, DISPEL_MAGIC, MASS_DISPEL;
+
+    //Holy Offensive
+    uint32 SMITE, HOLY_FIRE, PENANCE, HOLY_NOVA;
+
+    //Shadow Offensive
+    uint32 MIND_BLAST, SW_PAIN, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_EMBRACE, VAMPIRIC_TOUCH, SW_DEATH, MIND_SEAR, MANA_BURN, SHADOWFIEND;
+
+    //CC - Breaker
+    uint32 PSYCHIC_SCREAM, PSYCHIC_HORROR, MIND_SOOTHE, SHACKLE_UNDEAD, SILENCE, MIND_CONTROL;
+
+    //buffs
+    uint32 PW_SHIELD, INNER_FIRE, GUARDIAN_SPIRIT, FADE, INNER_FOCUS, POWER_INFUSION, PAIN_SUPPRESSION, SHADOWFORM, DISPERSION, LIGHTWELL,
+        PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION, PO_FORTITUDE, PO_SPIRIT, PO_SHADOW_PROTECTION, FEAR_WARD;
+
+    uint32 SHOOT;
+
+    uint32 TALENT_DISC, TALENT_HOLY, TALENT_SHADOW;
+};
+
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotRogueAI.cpp b/src/server/game/AI/Bots/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..85f4dae
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotRogueAI.cpp
@@ -0,0 +1,266 @@
+#include "PlayerbotRogueAI.h"
+#include "Spell.h"
+class PlayerbotAI;
+PlayerbotRogueAI::PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotRogueAI::~PlayerbotRogueAI(){}
+
+void PlayerbotRogueAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //Damage spells
+    BACKSTAB = ai->getSpellIdExact("Backstab");
+    SINISTER_STRIKE = ai->getSpellIdExact("Sinister Strike");
+    MUTILATE = ai->getSpellIdExact("Mutilate");
+    HEMORRHAGE = ai->getSpellIdExact("Hemorrhage");
+    GHOSTLY_STRIKE = ai->getSpellIdExact("Ghostly Strike");
+    RIPOSTE = ai->getSpellIdExact("Riposte");
+    SHIV = ai->getSpellIdExact("Shiv");
+    FAN_OF_KNIVES = ai->getSpellIdExact("Fan of Knives");
+
+    //Finishing Moves
+    EVISCERATE = ai->getSpellIdExact("Eviscerate");
+    RUPTURE = ai->getSpellIdExact("Rupture");
+    KIDNEY_SHOT = ai->getSpellIdExact("Kidney Shot");
+    ENVENOM = ai->getSpellIdExact("Envenom");
+    SLICE_AND_DICE = ai->getSpellIdExact("Slice and Dice");
+    EXPOSE_ARMOR = ai->getSpellIdExact("Expose Armor");
+    DEADLY_THROW = ai->getSpellIdExact("Deadly Throw");
+
+    //Buffs
+    STEALTH = ai->getSpellIdExact("Stealth");
+    VANISH = ai->getSpellIdExact("Vanish");
+    EVASION = ai->getSpellIdExact("Evasion");
+    CLOAK_OF_SHADOWS = ai->getSpellIdExact("Cloak of Shadows");
+    SPRINT = ai->getSpellIdExact("Sprint");
+    COLD_BLOOD = ai->getSpellIdExact("Cold Blood");
+    HUNGER_FOR_BLOOD = ai->getSpellIdExact("Hunger for Blood");
+    BLADE_FLURRY = ai->getSpellIdExact("Blade Flurry");
+    ADRENALINE_RUSH = ai->getSpellIdExact("Adrenaline Rush");
+    KILLING_SPREE = ai->getSpellIdExact("Killing Spree");
+    SHADOW_DANCE = ai->getSpellIdExact("Shadow Dance");
+
+    //Openers
+    CHEAP_SHOT = ai->getSpellIdExact("Cheap Shot");
+    GARROTE = ai->getSpellIdExact("Garrote");
+    AMBUSH = ai->getSpellIdExact("Ambush");
+
+    //Others
+    GOUGE = ai->getSpellIdExact("Gouge");
+    BLIND = ai->getSpellIdExact("Blind");
+    DISMANTLE = ai->getSpellIdExact("Dismantle");
+    SAP = ai->getSpellIdExact("Sap");
+    KICK = ai->getSpellIdExact("Kick");
+    PREPARATION = ai->getSpellIdExact("Preparation");
+    PREMEDITATION = ai->getSpellIdExact("Premeditation");
+    SHADOWSTEP = ai->getSpellIdExact("Shadowstep");
+    FEINT = ai->getSpellIdExact("Feint");
+    TRICKS_OF_THE_TRADE = ai->getSpellIdExact("Tricks of the Trade");
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+    THROW = ai->getSpellIdExact("Throw");
+
+    TALENT_ASSASSINATION = MUTILATE;
+    TALENT_COMBAT = ADRENALINE_RUSH;
+    TALENT_SUBTELTY = PREMEDITATION;
+
+    //uint8 talentCounter = 0;
+    //if (TALENT_ASSASSINATION) talentCounter++;
+    //if (TALENT_COMBAT) talentCounter++;
+    //if (TALENT_SUBTELTY) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ASSASSINATION = 0; TALENT_COMBAT = 0; TALENT_SUBTELTY = 0; } //Unreliable Talent detection.
+#pragma endregion
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (ROGUE is always MELEE DPS)
+    m_role = BOT_ROLE_DPS_MELEE;
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        else if (CastSpell(VANISH,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+    #pragma endregion
+
+    // wait until we actually reach our target b4 we actually do anything
+    if (m_bot->GetDistance(pTarget)>10.0 &&
+        !m_bot->HasAura(STEALTH) &&
+        !m_bot->isInCombat() && CastSpell(STEALTH))
+    { return; }
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    // wait until we actually reach our target b4 we actually do anything
+    /*if (GetPlayerBot()->GetDistance(pTarget)>10.0 &&
+        !HasAuraName(GetPlayerBot(),STEALTH) &&
+        !GetPlayerBot()->isInCombat() && CastSpell(STEALTH))
+    { return; }*/
+
+    //Buff
+    if (CastSpell(PREMEDITATION,m_bot)) { return; }
+    if (CastSpell(COLD_BLOOD,m_bot)) { } //no gcd
+
+    //PROTECT UP
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+        if (CastSpell(FEINT,m_bot)) { return; }
+        if (CastSpell(VANISH,m_bot)) { return; }
+    }
+    if (isUnderAttack() && pDist <= MELEE_RANGE && ai->GetHealthPercent() <= 85 && CastSpell(EVASION, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 55 && CastSpell(CLOAK_OF_SHADOWS, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 65 && CastSpell(GOUGE, m_bot)) { return; }
+    if (isUnderAttack() && ai->GetHealthPercent() <= 45 && CastSpell(BLIND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(KICK, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(GOUGE, pTarget)) { return; }
+    else if (pTarget->IsNonMeleeSpellCasted(true) && m_bot->GetComboPoints() >= 1 && CastSpell(KIDNEY_SHOT, pTarget)) { return; }
+
+    //Transfer threat
+    if (m_tank->GetGUID() != m_bot->GetGUID() && CastSpell(TRICKS_OF_THE_TRADE,m_tank)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    // sometimes we lose attack
+    if (!m_bot->isInCombat()) {
+        m_bot->Attack(pTarget, true);
+    }
+
+    if(TALENT_ASSASSINATION)
+    {
+        if (!m_bot->HasAura(HUNGER_FOR_BLOOD) && CastSpell(HUNGER_FOR_BLOOD,m_bot)) { return; }
+        if (m_bot->GetComboPoints() < 5)
+        {
+            if (CastSpell(MUTILATE, pTarget)) { return; }
+        }
+        else
+        {
+            if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+
+        }
+    }
+
+    if(TALENT_COMBAT)
+    {
+        if (CastSpell(BLADE_FLURRY,m_bot)) { return; }
+        if (ai->GetEnergyAmount() < 20 && CastSpell(ADRENALINE_RUSH,m_bot)) { return; }
+        if (!CastSpell(ADRENALINE_RUSH) && CastSpell(KILLING_SPREE,m_bot,1,0,1)) { return; }
+        if (m_bot->GetComboPoints() > 5)
+        {
+            if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+        }
+    }
+
+    if(TALENT_SUBTELTY)
+    {
+        if (CastSpell(PREMEDITATION,m_bot)) {}
+        if (CastSpell(SHADOW_DANCE,m_bot)) {}
+        if (!CastSpell(SHADOW_DANCE,m_bot) && CastSpell(PREPARATION,m_bot)) { return; }
+        if (m_bot->GetComboPoints() < 5)
+        {
+            if (m_bot->HasAura(SHADOW_DANCE) && !pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(AMBUSH, pTarget)) { return; } }
+            if (CastSpell(GHOSTLY_STRIKE, pTarget)) { return; }
+        }
+        else
+        {
+            if (!pTarget->HasAura(RUPTURE) && CastSpell(RUPTURE)) { return; }
+            if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) { return; }
+            if (CastSpell(SHADOWSTEP,pTarget)) { }
+        }
+    }
+
+    // defaults if not high enough do specialized attacks
+    if (m_bot->GetComboPoints() < 5) {
+        if (!pTarget->HasInArc(M_PI,m_bot)) { if (CastSpell(BACKSTAB, pTarget)) { return; } }
+        if (!MUTILATE &&CastSpell(SINISTER_STRIKE,pTarget)) { return; } // Dont cast if we have mutilate, save energy for it
+    } else {
+        if (!m_bot->HasAura(SLICE_AND_DICE) && CastSpell(SLICE_AND_DICE)) {  return; }
+        if (CastSpell(ENVENOM,pTarget)) { return; }
+        if (CastSpell(EVISCERATE,pTarget)) { return; }
+    }
+} //end DoNextCombatManeuver
+
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (ChangeWeaponEnchants()) { return; }
+} //end DoNonCombatActions
+
+bool PlayerbotRogueAI::ChangeWeaponEnchants()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return false; }
+
+    Item *weap;
+    Item *poison;
+
+    weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonForward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_MAINHAND);
+        return true;
+    }
+    weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+    if (weap && !weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+    {
+        poison = GetAI()->FindPoisonBackward();
+        if(poison == NULL) return false;
+        GetAI()->PoisonWeapon(*poison, poison->GetTemplate()->Spells[0].SpellId, TARGET_FLAG_ITEM, EQUIPMENT_SLOT_OFFHAND);
+        return true;
+    }
+    return false;
+}
diff --git a/src/server/game/AI/Bots/PlayerbotRogueAI.h b/src/server/game/AI/Bots/PlayerbotRogueAI.h
new file mode 100644
index 0000000..9c400f1
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotRogueAI.h
@@ -0,0 +1,41 @@
+#ifndef _PLAYERBOTROGUEAI_H
+#define _PLAYERBOTROGUEAI_H
+
+#include "PlayerbotClassAI.h"
+#include "TargetedMovementGenerator.h"
+
+class PlayerbotRogueAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotRogueAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotRogueAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool ChangeWeaponEnchants();
+
+    private:
+        //Damage spells
+        uint32 BACKSTAB, SINISTER_STRIKE, MUTILATE, HEMORRHAGE, GHOSTLY_STRIKE, RIPOSTE, SHIV, FAN_OF_KNIVES;
+        //Finishing Moves
+        uint32 EVISCERATE, RUPTURE, KIDNEY_SHOT, ENVENOM, SLICE_AND_DICE, EXPOSE_ARMOR, DEADLY_THROW;
+        //Buffs
+        uint32 STEALTH, VANISH, EVASION, CLOAK_OF_SHADOWS, SPRINT, COLD_BLOOD, HUNGER_FOR_BLOOD, BLADE_FLURRY, ADRENALINE_RUSH, KILLING_SPREE, SHADOW_DANCE;
+        //Openers
+        uint32 CHEAP_SHOT, GARROTE, AMBUSH;
+        //Others
+        uint32 GOUGE, BLIND, DISMANTLE, SAP, KICK, PREPARATION, PREMEDITATION, SHADOWSTEP, FEINT, TRICKS_OF_THE_TRADE;
+
+        uint32 TALENT_ASSASSINATION, TALENT_COMBAT, TALENT_SUBTELTY;
+
+        uint32 THROW;
+
+};
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotShamanAI.cpp b/src/server/game/AI/Bots/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..e58d868
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotShamanAI.cpp
@@ -0,0 +1,555 @@
+#include "PlayerbotShamanAI.h"
+class PlayerbotAI;
+PlayerbotShamanAI::PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotShamanAI::~PlayerbotShamanAI(){}
+
+void PlayerbotShamanAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //totems
+    HEALING_STREAM_TOTEM = ai->getSpellIdExact("Healing Stream Totem");
+    MANA_SPRING_TOTEM = ai->getSpellIdExact("Mana Spring Totem");
+    MANA_TIDE_TOTEM = ai->getSpellIdExact("Mana Tide Totem");
+    CLEANSING_TOTEM = ai->getSpellIdExact("Cleansing Totem");
+    FIRE_RESISTANCE_TOTEM = ai->getSpellIdExact("Fire Resistance Totem");
+
+    WINDFURY_TOTEM = ai->getSpellIdExact("Windfury Totem");
+    WRATH_OF_AIR_TOTEM = ai->getSpellIdExact("Wrath of Air Totem");
+    GROUNDING_TOTEM = ai->getSpellIdExact("Grounding Totem");
+    NATURE_RESISTANCE_TOTEM = ai->getSpellIdExact("Nature Resistance Totem");
+
+    STRENGTH_OF_EARTH_TOTEM = ai->getSpellIdExact("Strength of Earth Totem");
+    EARTHBIND_TOTEM = ai->getSpellIdExact("Earthbind Totem");
+    STONESKIN_TOTEM = ai->getSpellIdExact("Stoneskin Totem");
+    STONECLAW_TOTEM = ai->getSpellIdExact("Stoneclaw Totem");
+    TREMOR_TOTEM = ai->getSpellIdExact("Tremor Totem");
+    EARTH_ELEMENTAL_TOTEM = ai->getSpellIdExact("Earth Elemental Totem");
+
+    FLAMETONGUE_TOTEM = ai->getSpellIdExact("Flametongue Totem");
+    TOTEM_OF_WRATH = ai->getSpellIdExact("Totem of Wrath");
+    SEARING_TOTEM = ai->getSpellIdExact("Searing Totem");
+    MAGMA_TOTEM = ai->getSpellIdExact("Magma Totem");
+    FIRE_ELEMENTAL_TOTEM = ai->getSpellIdExact("Fire Elemental Totem");
+    FROST_RESISTANCE_TOTEM = ai->getSpellIdExact("Frost Resistance Totem");
+
+    TOTEMIC_RECALL = ai->getSpellIdExact("Totemic Recall");
+    CALL_OF_THE_ELEMENTS = ai->getSpellIdExact("Call of the Elements");
+    CALL_OF_THE_ANCESTORS = ai->getSpellIdExact("Call of the Ancestors");
+    CALL_OF_THE_SPIRITS = ai->getSpellIdExact("Call of the Spirits");
+
+    //restoration
+    HEAL = ai->getSpellIdExact("Healing Wave");
+    LESSER_HEAL = ai->getSpellIdExact("Lesser Healing Wave");
+    CHAIN_HEAL = ai->getSpellIdExact("Chain Heal");
+    RIPTIDE = ai->getSpellIdExact("Riptide");
+    ANCESTRAL_SPIRIT = ai->getSpellIdExact("Ancestral Spirit");
+    CLEANSE_SPIRIT = ai->getSpellIdExact("Cleanse Spirit");
+    if (CLEANSE_SPIRIT) CLEANSE_SPIRIT = ai->getSpellIdExact("Cure Toxins");
+
+    //offensive spells
+    LIGHTNING_BOLT = ai->getSpellIdExact("Lightning Bolt");
+    CHAIN_LIGHTNING = ai->getSpellIdExact("Chain Lightning");
+    FIRE_NOVA = ai->getSpellIdExact("Fire Nova");
+    THUNDERSTORM = ai->getSpellIdExact("Thunderstorm");
+    LAVA_BURST = ai->getSpellIdExact("Lava Burst");
+    EARTH_SHOCK = ai->getSpellIdExact("Earth Shock");
+    WIND_SHEAR = ai->getSpellIdExact("Wind Shear");
+    FLAME_SHOCK = ai->getSpellIdExact("Flame Shock");
+    FROST_SHOCK = ai->getSpellIdExact("Frost Shock");
+    PURGE = ai->getSpellIdExact("Purge");
+    HEX  = ai->getSpellIdExact("Hex");
+
+    //buffs
+    LIGHTNING_SHIELD = ai->getSpellIdExact("Lightning Shield");
+    WATER_SHIELD = ai->getSpellIdExact("Water Shield");
+    EARTH_SHIELD = ai->getSpellIdExact("Earth Shield");
+    HEROISM = ai->getSpellIdExact("Heroism");
+    if (HEROISM) HEROISM = ai->getSpellIdExact("Bloodlust");
+    ELEMENTAL_MASTERY = ai->getSpellIdExact("Elemental Mastery");
+    NATURES_SWIFTNESS = ai->getSpellIdExact("Nature's Swiftness");
+
+    WINDFURY_WEAPON = ai->getSpellIdExact("Windfury Weapon");
+    FLAMETONGUE_WEAPON = ai->getSpellIdExact("Flametongue Weapon");
+    FROSTBRAND_WEAPON = ai->getSpellIdExact("Frostbrand Weapon");
+    ROCKBITER_WEAPON = ai->getSpellIdExact("Rockbiter Weapon");
+    EARTHLIVING_WEAPON = ai->getSpellIdExact("Earthliving Weapon");
+
+    WATER_BREATHING = ai->getSpellIdExact("Water Breathing");
+    WATER_WALKING = ai->getSpellIdExact("Water Walking");
+
+    //melee
+    LAVA_LASH = ai->getSpellIdExact("Lava Lash");
+    STORMSTRIKE = ai->getSpellIdExact("Stormstrike");
+    SHAMANISTIC_RAGE = ai->getSpellIdExact("Shamanistic Rage");
+    FERAL_SPIRIT = ai->getSpellIdExact("Feral Spirit");
+
+    GHOST_WOLF = ai->getSpellIdExact("Ghost Wolf");
+
+    EXHAUSTION = 57723; // heroism debuff
+    SATED = 57724; // bloodlust debuff
+    //MAELSTROM_WEAPON = 0; // We want the triggered aura, not the talent spell
+    uint32 mwtrigger = ai->getSpellIdExact("Maelstrom Weapon",true);
+    if (mwtrigger)
+    {
+        SpellInfo const *mwtSpell = sSpellMgr->GetSpellInfo(mwtrigger);
+        if (mwtSpell && mwtSpell->Effects[0].TriggerSpell > 0) MAELSTROM_WEAPON = mwtSpell->Effects[0].TriggerSpell;
+    }
+
+    TALENT_ELEMENTAL = ELEMENTAL_MASTERY;
+    TALENT_ENHANCEMENT = STORMSTRIKE;
+    TALENT_RESTO = EARTH_SHIELD;
+
+    uint8 talentCounter = 0;
+    if (TALENT_ELEMENTAL) talentCounter++;
+    if (TALENT_ENHANCEMENT) talentCounter++;
+    if (TALENT_RESTO) talentCounter++;
+    //if (talentCounter > 1) { TALENT_ELEMENTAL = 0; TALENT_ENHANCEMENT = 0; TALENT_RESTO = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    uint8 reqHeal = 0;
+    uint8 OwnPartyHP = GetHealthPercentRaid(m_bot, reqHeal);
+
+    switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            ((ai->GetHealthPercent() < 80 && CastSpell(LESSER_HEAL)) ||
+            CastSpell(LIGHTNING_BOLT, pTarget));
+            return;
+    }
+
+    // Cast CC breakers if any match found (include any dispels first)  does not work yet
+    //uint32 ccSpells[4] = { R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    //if (ai->GetManaPercent() < 35) { ccSpells[0] = 0; ccSpells[1] = 0; } //We dont have any mana to waste...
+    //if (castSelfCCBreakers(ccSpells)) {  } // Most of them don't trigger gcd
+
+
+    #pragma region Choose Actions
+    // Choose actions accoring to talents
+    if (m_tank->GetGUID() == m_bot->GetGUID()) { m_role=BOT_ROLE_TANK; } // Hey! I am Main Tank
+    else if (TALENT_ENHANCEMENT) { m_role = BOT_ROLE_DPS_MELEE; }
+    else if (TALENT_ELEMENTAL) { m_role = BOT_ROLE_DPS_RANGED; }
+    else if (TALENT_RESTO) { m_role = BOT_ROLE_SUPPORT; }
+    else { m_role = BOT_ROLE_DPS_MELEE; } //Unknown build or low level.. Mainly attack
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack()  )
+    {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+    }
+    #pragma endregion
+
+    // Choose Weapon Enchant
+    if (ChangeWeaponEnchants()) return;
+
+    if (TALENT_ELEMENTAL){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+    if (TALENT_ENHANCEMENT){ if (!m_bot->HasAura(LIGHTNING_SHIELD) && CastSpell(LIGHTNING_SHIELD,m_bot)) { return; }}
+    if (TALENT_RESTO){ if (!m_bot->HasAura(WATER_SHIELD) && CastSpell(WATER_SHIELD,m_bot)) { return; }}
+    // Choose shield
+    /*
+    if (EARTH_SHIELD && ai->GetHealthPercent() < 80 && isUnderAttack()) { if (CastSpell(EARTH_SHIELD,m_bot)) { return; } }
+    else if (WATER_SHIELD && ai->GetManaPercent() < 40) { if (CastSpell(WATER_SHIELD,m_bot)) { return; } }
+    else if (LIGHTNING_SHIELD &&
+        ( isUnderAttack() || m_tank->GetGUID() == m_bot->GetGUID() )  && !(m_bot->HasAura(WATER_SHIELD) && ai->GetManaPercent() < 80)
+        ) { if (CastSpell(LIGHTNING_SHIELD,m_bot)) { return; } }
+    else if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+    */
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) return;
+
+    switch(m_role)
+    {
+        #pragma region BOT_ROLE_TANK / BOT_ROLE_OFFTANK
+        case BOT_ROLE_TANK:
+        case BOT_ROLE_OFFTANK:
+             if (!TALENT_ELEMENTAL && !TALENT_RESTO) { TakePosition(pTarget); }
+            else { TakePosition(pTarget,BOT_ROLE_DPS_RANGED); } // mob will come to you sooner or later no need to hurry
+
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 70 && DoSupportRaid(m_bot)) { return; }
+
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_MELEE
+        case BOT_ROLE_DPS_MELEE:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_DPS_RANGED
+        case BOT_ROLE_DPS_RANGED:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (ai->GetManaPercent() > 40 && DoSupportRaid(m_bot)) { return; }
+            break;
+        #pragma endregion
+
+        #pragma region BOT_ROLE_SUPPORT
+        case BOT_ROLE_SUPPORT:
+            TakePosition(pTarget);
+            // Do support stuff
+            if (!m_bot->isMoving() && ChangeTotems(m_role)) { return; }
+            if (DoSupportRaid(m_bot)) { return; }
+            //heal pets and bots
+            Unit *target = DoSelectLowestHpFriendly(40, 1000);
+            if(target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth()) ) { return; }
+
+            break;
+        #pragma endregion
+    }
+    #pragma region ShamanCommon
+
+
+    //Defensive Stuff
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (pDist > 5 && CastSpell(FROST_SHOCK, pTarget)) { return; }
+        if ((pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_BEAST || pTarget->GetCreatureType() == (uint32) CREATURE_TYPE_HUMANOID) && CastSpell(HEX, pTarget)) { return; } // no gcd
+        if (CastSpell(WIND_SHEAR, pTarget)) { } // no gcd
+    }
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && pTarget->IsNonMeleeSpellCasted(true) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(WIND_SHEAR, pTarget)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(FROST_SHOCK,pTarget)) return;
+    }
+
+
+    //Buff and restores
+    if ( ( (ai->GetHealthPercent() < 60 && isUnderAttack()) ||
+        (ai->GetManaPercent() < 30) ) && CastSpell(SHAMANISTIC_RAGE, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} // no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} // no GCD
+    if (!m_bot->HasAura(HEROISM) && !m_bot->HasAura(EXHAUSTION) && !m_bot->HasAura(SATED) && CastSpell(HEROISM,m_bot)) { return; }
+    if (m_role != BOT_ROLE_SUPPORT && CastSpell(NATURES_SWIFTNESS, m_bot)) { } //healers keep it for healing no gcd
+    else if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+
+    // If at threat limit, use WIND_SHEAR to reduce threat
+    if (pThreat > threatThreshold && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack())
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else
+        {
+            if (CastSpell(WIND_SHEAR,pTarget)) { return; } //Lets see if we can manage
+            else { return; } //use no spells and wait threat to be reduced
+        }
+    }
+
+
+    if (TALENT_ELEMENTAL)
+    {
+        if (CastSpell(ELEMENTAL_MASTERY, m_bot)) { } //no gcd
+        if (!pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+        if (CastSpell(LAVA_BURST,pTarget)) { return; }
+        if (CastSpell(CHAIN_LIGHTNING,pTarget)) { return; }
+        if (CastSpell(LIGHTNING_BOLT,pTarget)) { return; }
+    }
+
+    //dps
+    if (MAELSTROM_WEAPON)
+    {
+        Aura *maelaura = m_bot->GetAura(MAELSTROM_WEAPON);
+        if (maelaura && maelaura->GetStackAmount() == 5)
+        {
+            if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CHAIN_LIGHTNING,pTarget,true,true)) { return; }
+            if (CastSpell(LIGHTNING_BOLT,pTarget,true,true)) { return; }
+        }
+    }
+    if (CastSpell(FLAME_SHOCK,pTarget)) { return; }
+    if (CastSpell(STORMSTRIKE,pTarget,true,true)) { return; }
+
+    //if (!TALENT_ENHANCEMENT && CanCast(LAVA_BURST,pTarget,true) && pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) && CastSpell(LAVA_BURST,pTarget,false)) { return; }
+    if (CastSpell(FERAL_SPIRIT,m_bot)) { return; }
+    if (CanCast(EARTH_SHOCK,pTarget,true) && (pTarget->HasAura(STORMSTRIKE,m_bot->GetGUID()) || pTarget->HasAura(FLAME_SHOCK,m_bot->GetGUID()) ) && CastSpell(EARTH_SHOCK,pTarget)) { return; }
+    //if (CanCast(FLAME_SHOCK,pTarget) && CastSpell(FLAME_SHOCK,pTarget)) { return; }
+    if (CastSpell(LAVA_LASH,pTarget,true,true)) { return; }
+    if (CastSpell(FIRE_NOVA,pTarget)) { return; }
+    //if ((isUnderAttack(m_tank,4) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(FIRE_NOVA,pTarget)) { return; }
+    if (ai->GetManaPercent() > 60 && castDispel(PURGE,pTarget)) { return; } //PURGE but dont overpurge
+
+    #pragma endregion
+
+
+    // drink potion if support / healer (Other builds simply overuse mana and waste mana pots)
+    if(ai->GetManaPercent() < 5 && (m_role == BOT_ROLE_SUPPORT || m_role == BOT_ROLE_HEALER) )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+
+} //end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot)) { return; }
+
+    //heal pets and bots
+    Unit *target = DoSelectLowestHpFriendly(40, 1000);
+    if (target && target->isAlive() && HealTarget(target, target->GetHealth()*100 / target->GetMaxHealth())) { return; }
+
+    //Buffs
+    if (ChangeWeaponEnchants()) { return; }
+    if (CastSpell(WATER_SHIELD,m_bot)) { return; }
+    if (CastSpell(EARTH_SHIELD,m_bot)) { return; }
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (m_bot->GetHealth() < m_bot->GetMaxHealth() && CastSpell(LESSER_HEAL,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50) { ai->Feast(); }
+
+} //end DoNonCombatActions
+bool PlayerbotShamanAI::HealTarget(Unit *target, uint8 hp)
+{
+    if(!target || target->isDead()) return false;
+    Player *m_bot = GetPlayerBot();
+
+    if(hp < 30 && m_bot->isInCombat() && CastSpell(NATURES_SWIFTNESS, m_bot)) {} // NO gcd
+    if(hp < 60 && CanCast(HEAL,target,true) && m_bot->HasAura(NATURES_SWIFTNESS) && CastSpell(HEAL, target, false)) { return true; }
+    if(hp < 30 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+    if(hp < 40 && m_bot->getRace() == (uint8) RACE_DRAENEI && CastSpell(R_GIFT_OF_NAARU,target)) {} // no GCD
+    if(hp < 65 && CanCast(EARTH_SHIELD,target) && !m_bot->HasAura(EARTH_SHIELD,m_bot->GetGUID()) && CastSpell(EARTH_SHIELD,target,false)) { return true; }
+    if(hp < 65 && CastSpell(HEAL,target,true,true)) { return true; }
+    if(hp < 85 && CastSpell(LESSER_HEAL,target,true,true)) { return true; }
+
+    return false;
+} //end HealTarget
+
+bool PlayerbotShamanAI::HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal)
+{
+    Player *m_bot = GetPlayerBot();
+    if (countNeedHeal < 2) { return false; }
+    Unit *rTarget = DoSelectLowestHpFriendly(30,500);
+    if (!rTarget || rTarget->isDead() || rTarget->GetHealth() * 100 / rTarget->GetMaxHealth() > 80 ) { return false; }
+
+    if (hp < 65 && RIPTIDE && rTarget->HasAura(RIPTIDE,m_bot->GetGUID()) && CastSpell(CHAIN_HEAL, rTarget)) { return true; }
+    if (hp < 85 && CastSpell(RIPTIDE, rTarget)) { return true; }
+    if (hp < 75 && CastSpell(CHAIN_HEAL, rTarget,true,true)) { return true; }
+
+    return false;
+}
+
+bool PlayerbotShamanAI::CureTarget(Unit *target)
+//Cures the target
+{
+    Player *m_bot = GetPlayerBot();
+
+    if(!target || target->isDead()) { return false; }
+    if (castDispel(CLEANSE_SPIRIT, target)) return true;
+
+    return false;
+}
+
+bool PlayerbotShamanAI::RezTarget (Unit *target)
+{
+    if(!target || target->isAlive()) return false;
+    Player *m_bot = GetPlayerBot();
+    if (target->IsNonMeleeSpellCasted(true)) { return false; } //Already resurrected
+    if (m_bot->isInCombat()) { return false; }
+
+    if (!CanCast(ANCESTRAL_SPIRIT,target)) return false;
+    std::string msg = "Rezzing ";
+    msg += target->GetName();
+
+    GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    return CastSpell(ANCESTRAL_SPIRIT, target,false);
+}
+
+bool PlayerbotShamanAI::BuffPlayer(Unit *target)
+{
+    //std::string msg = "Mana totem, coming right up.";
+    //GetPlayerBot()->Say(msg, LANG_UNIVERSAL);
+    //if(!HasAuraName(GetPlayerBot(), "Mana Spring")) { CastSpell(MANA_SPRING_TOTEM, GetPlayerBot()); } return true;
+    return false;
+}
+#pragma region Change Totems
+bool PlayerbotShamanAI::ChangeTotems(uint32 mode)
+{
+    uint32 earth=0, fire=0, water=0, air=0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+    Unit *pTarget = m_bot->GetSelectedUnit();
+    Unit *pVictim = NULL;
+    if (m_bot->GetSelectedUnit()->IsFriendlyTo(m_bot)) pTarget = NULL;
+    if (pTarget) pVictim = pTarget->getVictim();
+
+    //Defaults
+    if (!HasAuraName(m_bot,"Horn of Winter") )earth = STRENGTH_OF_EARTH_TOTEM;
+    if (!earth) earth = STONESKIN_TOTEM;
+    if (!earth) earth = EARTHBIND_TOTEM;
+    fire = TOTEM_OF_WRATH;
+    if (!fire) fire = FLAMETONGUE_TOTEM;
+    if (!fire) fire = SEARING_TOTEM;
+    water = MANA_SPRING_TOTEM;
+    if (!water) water = HEALING_STREAM_TOTEM;
+    if (TALENT_ELEMENTAL || TALENT_RESTO) air = WRATH_OF_AIR_TOTEM;
+    else air = WINDFURY_TOTEM;
+
+    //Target reactive stuff
+    if (pTarget)
+    {
+        if (GROUNDING_TOTEM && pTarget->IsNonMeleeSpellCasted(true)) air = GROUNDING_TOTEM;
+    }
+
+    if (STONESKIN_TOTEM && isUnderAttack()) earth = STONESKIN_TOTEM;
+
+    uint32 totz[4] = {earth, fire, water, air};
+
+    for (int i = 0; i < 4; i++)
+    {
+        if (!totz[i]) continue;
+        SpellInfo const *tSpell = sSpellMgr->GetSpellInfo(totz[i]);
+        if (!tSpell) continue;
+        uint32 tEntry = (uint32) tSpell->Effects[0].MiscValue;
+        if (!tEntry) continue;
+        CreatureTemplate const *totemEntry = sObjectMgr->GetCreatureTemplate(tEntry);
+        if (!tEntry) continue;
+
+        if (CanCast(totz[i], m_bot) && !m_bot->FindNearestCreature(tEntry,30)) { return CastSpell(totz[i],m_bot,false); }
+    }
+    return false;
+}
+#pragma endregion
+#pragma region ChangeWeaponEnchants
+bool PlayerbotShamanAI::ChangeWeaponEnchants()
+{
+    uint32 mhEnch = 0, ohEnch = 0;
+
+    PlayerbotAI *ai = GetAI();
+    if(!ai) return false;
+    Player *m_bot = GetPlayerBot();
+    if(!m_bot || m_bot->isDead()) return false;
+
+
+    // Choose Weapon Enchant
+    if (TALENT_RESTO) { mhEnch = EARTHLIVING_WEAPON; }
+    else if (TALENT_ELEMENTAL){ mhEnch = FLAMETONGUE_WEAPON; }
+    else
+    {
+        if (WINDFURY_WEAPON)
+        {
+            mhEnch = WINDFURY_WEAPON;
+            if (m_bot->haveOffhandWeapon())
+            {
+                if (LAVA_LASH) ohEnch = FLAMETONGUE_WEAPON;
+                else ohEnch = WINDFURY_WEAPON;
+            }
+        }
+    else if (FLAMETONGUE_WEAPON)
+    {
+        mhEnch = FLAMETONGUE_WEAPON;
+        if (m_bot->haveOffhandWeapon()) ohEnch = FLAMETONGUE_WEAPON;
+    }
+
+    }
+
+    Item* weap;
+    uint32 enchant_id = 0;
+    SpellInfo const *tSpell;
+    bool castedsomething = false;
+
+    if (mhEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(BASE_ATTACK);
+        if (weap)
+        {
+            tSpell = sSpellMgr->GetSpellInfo(mhEnch);
+            if (tSpell && tSpell->Effects[0].MiscValue > 0)
+            {
+                enchant_id = (uint32) tSpell->Effects[0].MiscValue;
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+
+    if (ohEnch)
+    {
+        weap = m_bot->GetWeaponForAttack(OFF_ATTACK);
+        if (weap)
+        {
+            tSpell = sSpellMgr->GetSpellInfo(ohEnch);
+            if (tSpell && tSpell->Effects[0].MiscValue > 0)
+            {
+                enchant_id = (uint32) tSpell->Effects[0].MiscValue;
+                if (enchant_id && weap->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) != enchant_id && sSpellItemEnchantmentStore.LookupEntry(enchant_id))
+                {
+                    m_bot->ApplyEnchantment(weap,TEMP_ENCHANTMENT_SLOT, false); //Remove old enchantment effect
+                    weap->SetEnchantment(TEMP_ENCHANTMENT_SLOT, enchant_id, 1800 * 1000, 0); //Add for 30 mins
+                    m_bot->ApplyEnchantment(weap, TEMP_ENCHANTMENT_SLOT, true); //Add new effect
+                    castedsomething = true;
+                }
+            }
+        }
+    }
+    return castedsomething;
+
+}
+#pragma endregion
diff --git a/src/server/game/AI/Bots/PlayerbotShamanAI.h b/src/server/game/AI/Bots/PlayerbotShamanAI.h
new file mode 100644
index 0000000..e5fef23
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotShamanAI.h
@@ -0,0 +1,75 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotShamanAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotShamanAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotShamanAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, REBIRTHes
+        void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        bool HealTarget(Unit *target, uint8 hp);
+
+        bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cures the target
+        bool CureTarget(Unit *target);
+
+        bool RezTarget (Unit *target);
+
+        bool ChangeTotems(uint32 mode);
+
+        bool ChangeWeaponEnchants();
+
+        /*//find any specific mount spells, ie druids=cat, shaman=ghost wolf etc
+        virtual bool FindMount();
+        virtual bool Unmount();
+        virtual bool IsMounted(); */
+
+    private:
+
+        //totems
+        uint32 HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, MANA_TIDE_TOTEM, CLEANSING_TOTEM, FIRE_RESISTANCE_TOTEM; //water
+        uint32 WINDFURY_TOTEM, WRATH_OF_AIR_TOTEM, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM;  //air
+        uint32 STRENGTH_OF_EARTH_TOTEM, EARTHBIND_TOTEM, STONESKIN_TOTEM, STONECLAW_TOTEM, TREMOR_TOTEM, EARTH_ELEMENTAL_TOTEM ; //earth
+        uint32 FLAMETONGUE_TOTEM, TOTEM_OF_WRATH, SEARING_TOTEM, MAGMA_TOTEM, FIRE_ELEMENTAL_TOTEM, FROST_RESISTANCE_TOTEM; //fire
+        uint32 TOTEMIC_RECALL, CALL_OF_THE_ELEMENTS, CALL_OF_THE_ANCESTORS, CALL_OF_THE_SPIRITS;
+
+        //restoration
+        uint32 HEAL, LESSER_HEAL, CHAIN_HEAL, RIPTIDE, ANCESTRAL_SPIRIT, CLEANSE_SPIRIT;
+
+        //offensive spells
+        uint32 LIGHTNING_BOLT, CHAIN_LIGHTNING, FIRE_NOVA, THUNDERSTORM, LAVA_BURST, EARTH_SHOCK, WIND_SHEAR, FLAME_SHOCK, FROST_SHOCK, PURGE, HEX ;
+
+        //buffs
+        uint32 LIGHTNING_SHIELD, WATER_SHIELD, EARTH_SHIELD, HEROISM, ELEMENTAL_MASTERY, NATURES_SWIFTNESS,
+            WINDFURY_WEAPON, FLAMETONGUE_WEAPON, FROSTBRAND_WEAPON, ROCKBITER_WEAPON, EARTHLIVING_WEAPON,
+            WATER_BREATHING, WATER_WALKING ;
+
+        //mellee
+        uint32 LAVA_LASH, STORMSTRIKE, SHAMANISTIC_RAGE, FERAL_SPIRIT;
+
+        uint32 GHOST_WOLF;
+
+        //special
+        uint32 EXHAUSTION, SATED, MAELSTROM_WEAPON;
+
+        uint32 TALENT_ELEMENTAL, TALENT_ENHANCEMENT, TALENT_RESTO;
+
+};
+
+
+#endif
diff --git a/src/server/game/AI/Bots/PlayerbotWarlockAI.cpp b/src/server/game/AI/Bots/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..96d3ad1
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarlockAI.cpp
@@ -0,0 +1,410 @@
+/*
+Name : PlayerbotWarlockAI.cpp
+Complete: maybe around 60%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Behaviour does not change though..
+                - Curse checks are slow, later all curses should be looked up in one loop
+                - Need a function to lookup pet known spells for better pet handling
+                - Warlock do not summon other pets than Fel hunter/Imp
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+#include "PlayerbotWarlockAI.h"
+
+class PlayerbotAI;
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarlockAI::~PlayerbotWarlockAI(){}
+
+void PlayerbotWarlockAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    #pragma region SpellId Fill
+    //CURSES
+    CURSE_OF_ELEMENTS = ai->getSpellIdExact("Curse of Elements");
+    CURSE_OF_WEAKNESS = ai->getSpellIdExact("Curse of Weakness");
+    CURSE_OF_AGONY = ai->getSpellIdExact("Curse of Agony");
+    CURSE_OF_RECKLESSNESS = ai->getSpellIdExact("Curse of Recklessness");
+    CURSE_OF_TONGUES = ai->getSpellIdExact("Curse of Tongues");
+    CURSE_OF_DOOM = ai->getSpellIdExact("Curse of Doom");
+    CURSE_OF_EXHAUSTION = ai->getSpellIdExact("Curse of Exhaustion");
+
+
+    //AFFLICTION
+    CORRUPTION = ai->getSpellIdExact("Corruption");
+    DRAIN_SOUL = ai->getSpellIdExact("Drain Soul");
+    DRAIN_LIFE = ai->getSpellIdExact("Drain Life");
+    DRAIN_MANA = ai->getSpellIdExact("Drain Mana");
+    SIPHON_LIFE = ai->getSpellIdExact("Siphon Life");
+    UNSTABLE_AFFLICTION = ai->getSpellIdExact("Unstable Affliction");
+    HAUNT = ai->getSpellIdExact("Haunt");
+    SEED_OF_CORRUPTION = ai->getSpellIdExact("Seed of Corruption");
+    DEATH_COIL = ai->getSpellIdExact("Death Coil");
+
+
+    //DESTRUCTION
+    SHADOW_BOLT = ai->getSpellIdExact("Shadow Bolt");
+    IMMOLATE = ai->getSpellIdExact("Immolate");
+    INCINERATE = ai->getSpellIdExact("Incinerate");
+    SEARING_PAIN = ai->getSpellIdExact("Searing Pain");
+    CONFLAGRATE = ai->getSpellIdExact("Conflagrate");
+    SOUL_FIRE = ai->getSpellIdExact("Soul Fire");
+    SHADOWBURN = ai->getSpellIdExact("Shadowburn");
+    SHADOWFURY = ai->getSpellIdExact("Shadowfury");
+    CHAOS_BOLT = ai->getSpellIdExact("Chaos Bolt");
+    SHADOWFLAME = ai->getSpellIdExact("Shadowflame");
+    RAIN_OF_FIRE = ai->getSpellIdExact("Rain of Fire");
+    HELLFIRE = ai->getSpellIdExact("Hellfire");
+
+
+    //DEMONOLOGY
+    DEMON_ARMOR = ai->getSpellIdExact("Demon Armor");
+    if (!DEMON_ARMOR) DEMON_ARMOR = ai->getSpellIdExact("Demon Skin");
+    FEL_ARMOR = ai->getSpellIdExact("Fel Armor");
+    SOULSHATTER = ai->getSpellIdExact("Soulshatter");
+    HEALTH_FUNNEL = ai->getSpellIdExact("Health Funnel");
+    DARK_PACT = ai->getSpellIdExact("Dark Pact");
+    SOUL_LINK = ai->getSpellIdExact("Soul Link");
+    DEMONIC_EMPOWERMENT = ai->getSpellIdExact("Demonic Empowerment");
+    METAMORPHOSIS = ai->getSpellIdExact("Metamorphosis"); //Original is learn spell
+    SUMMON_IMP = ai->getSpellIdExact("Summon Imp");
+    SUMMON_VOIDWALKER = ai->getSpellIdExact("Summon Voidwalker");
+    SUMMON_SUCCUBUS = ai->getSpellIdExact("Summon Succubus");
+    SUMMON_FELHUNTER = ai->getSpellIdExact("Summon Felhunter");
+    SUMMON_FELGUARD = ai->getSpellIdExact("Summon Felguard");
+
+
+    //CC
+    FEAR = ai->getSpellIdExact("Fear");
+    HOWL_OF_TERROR = ai->getSpellIdExact("Howl of Terror");
+    BANISH = ai->getSpellIdExact("Banish");
+    ENSLAVE_DEMON = ai->getSpellIdExact("Enslave Demon");
+
+
+    //Buff
+    UNENDING_BREATH = ai->getSpellIdExact("Unending Breath");
+    DETECT_INVISIBILITY = ai->getSpellIdExact("Detect Invisibility");
+    SHADOW_WARD = ai->getSpellIdExact("Shadow Ward");
+
+
+    //Other
+    LIFE_TAP = ai->getSpellIdExact("Life Tap");
+    CREATE_SOULSTONE = ai->getSpellIdExact("Create Soulstone");
+
+
+    SOUL_SHARD = 6265; //Soul Shard Item id
+    P_BACKLASH = 34936; //Backlash proc
+    P_NIGHTFALL= 17941; //Nightfall proc
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    TALENT_DEMONOLOGY = SUMMON_FELGUARD;
+    TALENT_AFFLICTION = UNSTABLE_AFFLICTION;
+    TALENT_DESTRUCTION = CONFLAGRATE;
+
+    uint8 talentCounter = 0;
+    if (TALENT_DEMONOLOGY) talentCounter++;
+    if (TALENT_AFFLICTION) talentCounter++;
+    if (TALENT_DESTRUCTION) talentCounter++;
+    if (talentCounter > 1) { TALENT_DEMONOLOGY = 0; TALENT_AFFLICTION = 0; TALENT_DESTRUCTION = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    Pet *pet = m_bot->GetPet();
+    if (m_tank->GetGUID() == m_bot->GetGUID() && pet && pet->isAlive() && pet->isInCombat()) { m_tank = pet; }
+    uint8 petThreat = 0;
+    if (pet) { GetThreatPercent(pTarget,pet); }
+
+    /*switch(ai->GetScenarioType())
+    {
+        case SCENARIO_DUEL:
+            if(SHADOW_BOLT > 0) CastSpell(SHADOW_BOLT);
+            return;
+    }*/
+
+    //------- Non Duel combat ----------
+
+    //ai->Follow(*GetMaster()); //don't want to melee mob
+
+    #pragma region Choose Target
+    // Choose actions accoring to talents (WARLOCK is always ranged dps)
+    m_role = BOT_ROLE_DPS_RANGED;
+
+    // if i am under attack and if i am not tank or offtank: change target if needed
+    if (m_tank->GetGUID() != m_bot->GetGUID() && isUnderAttack() )
+    {
+        // Keep hitting but reduce threat
+        if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        //else if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CastSpell(R_SHADOWMELD,m_bot)) { return; }
+        else //I cannot reduce threat so
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+        }
+    }
+
+    #pragma endregion
+
+    #pragma region Pet Actions
+    // Pet's own Actions
+    if( pet && pet->isAlive() )
+    {
+        // Setup pet
+        if (pet->GetCharmInfo()->IsAtStay()) {pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW); }
+        //if (pet->HasSpell(BLOOD_PACT) && ); //Cast Blood Pact
+
+        if ( ( ((float)pet->GetHealth()/(float)pet->GetMaxHealth()) < 0.5f )
+        && ( HEALTH_FUNNEL>0 && !pet->getDeathState() != ALIVE && pVictim != m_bot
+        && CastSpell(HEALTH_FUNNEL,m_bot) )) { return; } //Heal pet
+
+        // Set pet to attack warlock's attacker > its own attackers > warlock's target
+        if (!pet->getVictim()) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(m_bot)) { pet->AI()->AttackStart(pTarget); }  //Always help warlock if he's under attack
+        else if (pet->getVictim()->GetGUID() != pTarget->GetGUID() && !isUnderAttack(pet)) { pet->AI()->AttackStart(pTarget); }
+        else if (isUnderAttack(pet)) // Pet is under attack and warlock has no attackers
+        {
+            if ( pet->getVictim()->getVictim() && pet->getVictim()->getVictim()->GetGUID() == pet->GetGUID() && pDist <= 2) {  } // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(pet,true);
+                if (curAtt && (!pet->getVictim() || curAtt->GetGUID() != pet->getVictim()->GetGUID()))
+                {
+                    pet->AI()->AttackStart(curAtt); //Attack nearest attacker
+                }
+            }
+            //Actions to do under attack (Always tank it, and try to kill it, until someone (!= warlock) takes aggro back)
+            //Warlock should help her pet whether main tank or not, unless he's being attacked (BEWARE Targeting Loop possibility)
+            if (pet->getVictim() && !isUnderAttack(m_bot) && pet->getVictim()->GetGUID() != pTarget->GetGUID())
+            {
+                m_bot->SetSelection(pet->getVictim()->GetGUID());
+                DoNextCombatManeuver(pet->getVictim()); //Restart new update to get variables fixed..
+                return;
+            }
+
+        }
+        // Pet tanking behaviour
+        if (pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot) || isUnderAttack(pet))
+        {
+            //need pet tanking spells
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,true); //Autocast growl
+        }
+        else
+        {
+            //if (GROWL) pet->GetCharmInfo()->SetSpellAutocast(GROWL,false); //Do not try to get aggro
+        }
+        // NORMAL PET dps attacks
+        if (petThreat < threatThreshold || pet->GetGUID() == m_tank->GetGUID() || isUnderAttack(m_bot))
+        {
+            //if (CastSpell(KILL_COMMAND,m_bot)) { }
+        }
+    }
+    #pragma endregion
+
+    TakePosition(pTarget);
+    // If there's a cast stop
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    //Buff
+    if (isUnderAttack()) { if (CastSpell (DEMON_ARMOR, m_bot)) { return; } }
+    else if (FEL_ARMOR) { if (CastSpell(FEL_ARMOR,m_bot)) { return; } }
+    else if (CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (CastSpell(METAMORPHOSIS,m_bot)) { return; }
+    if (CastSpell(DEMONIC_EMPOWERMENT,m_bot)) { return; }
+
+    //Protect
+    if (m_tank->GetGUID() != m_bot->GetGUID() && pVictim && pVictim->GetGUID() == m_bot->GetGUID() )
+    {
+        if (CastSpell(SOULSHATTER, m_bot)) { return; }
+        if (pTarget->GetCreatureType() == CREATURE_TYPE_DEMON && CastSpell(BANISH,pTarget)) { return; }
+        //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && isUnderAttack() && CastSpell(R_SHADOWMELD, m_bot)) { return; }
+    }
+    if (isUnderAttack() && CastSpell(FEAR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(HOWL_OF_TERROR, pTarget)) { return; }
+    if (isUnderAttack() && CastSpell(SHADOWFURY, pTarget)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+    if (m_bot->getRace() == (uint8) RACE_TAUREN && pDist < 8 && CastSpell(R_WAR_STOMP, pTarget)) { return; } //no gcd but is cast
+    //Void Walker shield?
+    if (ai->GetHealthPercent() < 70 && CastSpell(DEATH_COIL,pTarget)) { return; }
+    if (ai->GetHealthPercent() < 70 && CastSpell(DRAIN_LIFE,pTarget)) { return; }
+    if (ai->GetManaPercent() < 70 && ai->GetManaPercent(*pTarget) > 10 && CastSpell(DRAIN_MANA,pTarget)) { return; }
+    if (ai->GetManaPercent() < 50 && pet && ai->GetManaPercent(*pet) > 50 && CastSpell(DARK_PACT,pet,1,0,1)) { return; }
+    if (ai->GetManaPercent() < 30 && ai->GetHealthPercent() > 60 && CastSpell(LIFE_TAP,m_bot,1,0,1)) { return; }
+    //Use Health stone
+
+    //Break spells
+    if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && (pTarget->IsNonMeleeSpellCasted(true) || ai->GetManaPercent() < 40) && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+    else if (pTarget->IsNonMeleeSpellCasted(true) && CastSpell(CURSE_OF_TONGUES, pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(CURSE_OF_EXHAUSTION,pTarget)) return;
+    }
+
+    // Threat control
+    if (pThreat < threatThreshold || m_tank->GetGUID() == m_bot->GetGUID() ) { } //Continue attack
+    else
+    {
+        if (pet && isUnderAttack(pet) && pet->getVictim() && pet->getVictim()->GetGUID() != pTarget->GetGUID()) //Should be helping pet
+        {
+            m_bot->SetSelection(pet->getVictim()->GetGUID());
+            return;
+        }
+        else if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else if (CastSpell(SOULSHATTER,m_bot)) { return; }
+        else if (m_bot->FindCurrentSpellBySpellId(SHOOT)) { m_bot->InterruptNonMeleeSpells( true, SHOOT ); return; } //Disable wand
+        else { return; } // No more threat reducing spells, just slow down
+    }
+
+
+
+    //Urgent DPS
+    if ((m_bot->HasAura(P_NIGHTFALL) || m_bot->HasAura(P_BACKLASH)) && CastSpell(SHADOW_BOLT,pTarget)) { return; }
+    if (INCINERATE && pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) && CastSpell(INCINERATE,pTarget)) { return; }
+    if (CONFLAGRATE && (pTarget->HasAura(IMMOLATE,m_bot->GetGUID()) || pTarget->HasAura(SHADOWFLAME,m_bot->GetGUID())) && CastSpell(CONFLAGRATE,pTarget)) { return; }
+
+    if (ai->GetHealthPercent(*pTarget) < 2 && CastSpell(SHADOWBURN,pTarget)) { return; }
+    if (ai->GetHealthPercent(*pTarget) < 5 && m_bot->GetItemCount(SOUL_SHARD) < 20 && CastSpell(DRAIN_SOUL,pTarget)) { return; }
+
+    //Dps up
+    if (ai->GetHealthPercent(*pTarget) > 95) { return; } // dont dps too early
+
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+    if (CastSpell(HAUNT,pTarget)) { return; }
+
+    //AOE
+    if (isUnderAttack(m_tank,4) && CastSpell(SHADOWFLAME,pTarget)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(RAIN_OF_FIRE,pTarget)) { return; }
+
+    //Dps Main
+    if(CURSE_OF_ELEMENTS) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_ELEMENTS, pTarget)) { return; } } //curse of elements trumps any other curses
+    else if (CURSE_OF_AGONY) { if (!CheckCurse(pTarget) && CastSpell(CURSE_OF_AGONY, pTarget)) { return; } }
+
+    if (SEED_OF_CORRUPTION && isUnderAttack(m_tank,4)) { if (CastSpell(SEED_OF_CORRUPTION,pTarget)) { return;} }
+    else if (CastSpell(CORRUPTION,pTarget)) { return; }
+
+    if (CastSpell(CHAOS_BOLT,pTarget)) { return; }
+
+    if (UNSTABLE_AFFLICTION) { if (CastSpell(UNSTABLE_AFFLICTION,pTarget)) { return; } }
+    else if (CastSpell(IMMOLATE,pTarget)) { return; }
+
+    if (CastSpell(SHADOW_BOLT,pTarget)) { return; }
+
+
+
+
+    //Use healthstone??
+    // drink poition
+    if(ai->GetManaPercent() < 5 )
+    {
+        Item *pItem = ai->FindPotion();
+        if(pItem != NULL)
+        {
+            if (pItem->GetSpell() && m_bot->HasSpellCooldown(pItem->GetSpell()) ) { return; } //pot is in cooldown
+            ai->UseItem(*pItem);
+        }
+    }
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //buff and heal raid
+    if (DoSupportRaid(m_bot,30,0,0,0,0,1)) { return; }
+
+    //Own Buffs
+    if (CastSpell (FEL_ARMOR, m_bot)) { return; }
+    if (!FEL_ARMOR && CastSpell(DEMON_ARMOR, m_bot)) { return; }
+    if (SOUL_LINK && m_bot->GetPet() && !m_bot->HasAuraType(SPELL_AURA_SPLIT_DAMAGE_PCT) && CastSpell(SOUL_LINK,m_bot)) { return; }
+
+    if(m_bot->GetPet() == NULL) {
+        if (SUMMON_FELGUARD)
+            CastSpell(SUMMON_FELGUARD, m_bot);
+        else
+            CastSpell(SUMMON_IMP, m_bot);
+    } else {
+    m_bot->GetPet()->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+    m_bot->GetPet()->GetCharmInfo()->SetIsCommandAttack(false);
+    }
+
+    //Create Healthstone?
+
+    //mana/hp check
+    //Don't bother with eating, if low on hp, just let it heal themself
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 && ai->GetHealthPercent() > 60 && CastSpell (LIFE_TAP, m_bot)) { return; }
+    if (ai->GetManaPercent() < 50 || ai->GetHealthPercent() < 50) { ai->Feast(); }
+
+
+} //end DoNonCombatActions
+
+bool PlayerbotWarlockAI::BuffPlayer(Unit *target)
+{
+    if (!target || target->isDead()) return false;
+
+    if (!HasAuraName(target, DETECT_INVISIBILITY) && CastSpell(DETECT_INVISIBILITY, target)) { return true; }
+    if (!HasAuraName(target, UNENDING_BREATH) && CastSpell(UNENDING_BREATH, target)) { return true; }
+    return false;
+}
+
+uint32 PlayerbotWarlockAI::CheckCurse(Unit *target)
+{
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead() || !target || target->isDead() ) { return 0; }
+    uint64 mGuid = m_bot->GetGUID();
+
+    if (CURSE_OF_ELEMENTS && target->HasAura(CURSE_OF_ELEMENTS,mGuid)) { return CURSE_OF_ELEMENTS; }
+    if (CURSE_OF_AGONY && target->HasAura(CURSE_OF_AGONY,mGuid)) { return CURSE_OF_AGONY; }
+    if (CURSE_OF_TONGUES && target->HasAura(CURSE_OF_TONGUES,mGuid)) { return CURSE_OF_TONGUES; }
+    if (CURSE_OF_WEAKNESS && target->HasAura(CURSE_OF_WEAKNESS,mGuid)) { return CURSE_OF_WEAKNESS; }
+    if (CURSE_OF_DOOM && target->HasAura(CURSE_OF_DOOM,mGuid)) { return CURSE_OF_DOOM; }
+    if (CURSE_OF_RECKLESSNESS && target->HasAura(CURSE_OF_RECKLESSNESS,mGuid)) { return CURSE_OF_RECKLESSNESS; }
+    if (CURSE_OF_EXHAUSTION && target->HasAura(CURSE_OF_EXHAUSTION,mGuid)) { return CURSE_OF_EXHAUSTION; }
+    return 0;
+}
+
+//void PlayerbotWarlockAI::BuffPlayer(Player *target){}
+
diff --git a/src/server/game/AI/Bots/PlayerbotWarlockAI.h b/src/server/game/AI/Bots/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..6904261
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarlockAI.h
@@ -0,0 +1,57 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotClassAI.h"
+
+//class Player;
+
+class PlayerbotWarlockAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarlockAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarlockAI();
+
+        virtual void LoadSpells();
+
+    //all combat actions go here
+    void DoNextCombatManeuver(Unit *);
+
+    //all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    //buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Unit *target);
+
+    uint32 CheckCurse(Unit *target);
+
+  private:
+    //CURSES
+    uint32 CURSE_OF_ELEMENTS, CURSE_OF_WEAKNESS, CURSE_OF_AGONY, CURSE_OF_RECKLESSNESS, CURSE_OF_TONGUES, CURSE_OF_DOOM, CURSE_OF_EXHAUSTION;
+
+    //AFFLICTION
+    uint32 CORRUPTION, DRAIN_SOUL, DRAIN_LIFE, DRAIN_MANA, SIPHON_LIFE, UNSTABLE_AFFLICTION, HAUNT, SEED_OF_CORRUPTION, DEATH_COIL;
+
+    //DESTRUCTION
+    uint32 SHADOW_BOLT, IMMOLATE, INCINERATE, SEARING_PAIN, CONFLAGRATE, SOUL_FIRE, SHADOWBURN, SHADOWFURY, CHAOS_BOLT, SHADOWFLAME, RAIN_OF_FIRE, HELLFIRE;
+
+    //DEMONOLOGY
+    uint32 DEMON_ARMOR, FEL_ARMOR, SOULSHATTER, HEALTH_FUNNEL, DARK_PACT, SOUL_LINK, DEMONIC_EMPOWERMENT, METAMORPHOSIS, SUMMON_IMP, SUMMON_VOIDWALKER, SUMMON_SUCCUBUS, SUMMON_FELHUNTER, SUMMON_FELGUARD;
+
+    //CC
+    uint32 FEAR, HOWL_OF_TERROR, BANISH, ENSLAVE_DEMON;
+
+    //Buff
+    uint32 UNENDING_BREATH, DETECT_INVISIBILITY, SHADOW_WARD;
+
+    //Other
+    uint32 LIFE_TAP, CREATE_SOULSTONE;
+
+    //Special
+    uint32 SOUL_SHARD, P_BACKLASH, P_NIGHTFALL, SHOOT;
+
+    uint32 TALENT_DEMONOLOGY, TALENT_AFFLICTION, TALENT_DESTRUCTION;
+};
+
+#endif
+
+
diff --git a/src/server/game/AI/Bots/PlayerbotWarriorAI.cpp b/src/server/game/AI/Bots/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..29ad3ad
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarriorAI.cpp
@@ -0,0 +1,400 @@
+/*
+Name : PlayerbotWarrior.cpp
+Complete: maybe around 75%
+
+Limitations:    - Talent build decision is made by key talent spells, which makes them viable only after level 50-ish.. Until then default behaviour is Blood dps/offtank type
+                - Tanking bots should taunt if any group member is under attack, currently only saves master
+                - Situations needing Intervene casting : limited / non-existant..
+                - Intervene / Piercing Howl / Hamstring are not used..
+
+Authors : SwaLLoweD
+Version : 0.40
+*/
+
+#include "PlayerbotWarriorAI.h"
+
+class PlayerbotAI;
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai): PlayerbotClassAI(master, bot, ai)
+{
+    foodDrinkSpamTimer = 0;
+    LoadSpells();
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI(){}
+
+void PlayerbotWarriorAI::LoadSpells() {
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+   #pragma region SpellId Fill
+    //Defensive Stance
+    SHIELD_WALL = ai->getSpellIdExact("Shield Wall");
+    REVENGE = ai->getSpellIdExact("Revenge");
+    SHIELD_BLOCK = ai->getSpellIdExact("Shield Block");
+    DISARM = ai->getSpellIdExact("Disarm");
+    INTERVENE = ai->getSpellIdExact("Intervene");
+
+    //Berserker Stance
+    RECKLESSNESS = ai->getSpellIdExact("Recklessness");
+    WHIRLWIND = ai->getSpellIdExact("Whirlwind");
+    PUMMEL = ai->getSpellIdExact("Pummel");
+    INTERCEPT = ai->getSpellIdExact("Intercept");
+
+    //Battle Stance
+    RETALIATION = ai->getSpellIdExact("Retaliation");
+    CHARGE = ai->getSpellIdExact("Charge");
+    OVERPOWER = ai->getSpellIdExact("Overpower");
+    SHATTERING_THROW = ai->getSpellIdExact("Shattering Throw");
+
+    //Mixed Attacks
+    REND = ai->getSpellIdExact("Rend");                                // 1 2
+    THUNDER_CLAP = ai->getSpellIdExact("Thunder Clap");
+    SPELL_REFLECTION = ai->getSpellIdExact("Spell Reflection");
+    SHIELD_BASH = ai->getSpellIdExact("Shield Bash");
+    EXECUTE = ai->getSpellIdExact("Execute");                        // 1 3
+    HAMSTRING = ai->getSpellIdExact("Hamstring");
+    SWEEPING_STRIKES = ai->getSpellIdExact("Sweeping Strikes");
+    VICTORY_RUSH = ai->getSpellIdExact("Victory Rush");
+
+
+    //General attacks
+    HEROIC_STRIKE = ai->getSpellIdExact("Heroic Strike");
+    MORTAL_STRIKE = ai->getSpellIdExact("Mortal Strike");
+    BLOODTHIRST = ai->getSpellIdExact("Bloodthirst");
+    SHIELD_SLAM = ai->getSpellIdExact("Shield Slam");
+    SHOCKWAVE = ai->getSpellIdExact("Shockwave");
+    SLAM = ai->getSpellIdExact("Slam");
+    CLEAVE = ai->getSpellIdExact("Cleave");
+    BLADESTORM = ai->getSpellIdExact("Bladestorm");
+    HEROIC_THROW = ai->getSpellIdExact("Heroic Throw");
+    CONCUSSION_BLOW = ai->getSpellIdExact("Concussion Blow");
+    SUNDER_ARMOR = ai->getSpellIdExact("Sunder Armor");
+    DEMORALIZING_SHOUT = ai->getSpellIdExact("Demoralizing Shout");
+    INTIMIDATING_SHOUT = ai->getSpellIdExact("Intimidating Shout");
+    PIERCING_HOWL = ai->getSpellIdExact("Piercing Howl");
+    DEVASTATE = ai->getSpellIdExact("Devastate");
+
+
+    //buffs
+    COMMANDING_SHOUT = ai->getSpellIdExact("Commanding Shout");
+    BATTLE_SHOUT = ai->getSpellIdExact("Battle Shout");
+    VIGILANCE = ai->getSpellIdExact("Vigilance");
+    BERSERKER_RAGE = ai->getSpellIdExact("Berserker Rage");
+    ENRAGED_REGENERATION = ai->getSpellIdExact("Enraged Regeneration");
+    BLOODRAGE = ai->getSpellIdExact("Bloodrage");
+    LAST_STAND = ai->getSpellIdExact("Last Stand");
+    HEROIC_FURY = ai->getSpellIdExact("Heroic Fury");
+    DEATH_WISH = ai->getSpellIdExact("Death Wish");
+
+
+    //Stances
+    DEFENSIVE_STANCE = ai->getSpellIdExact("Defensive Stance");
+    BATTLE_STANCE = ai->getSpellIdExact("Battle Stance");
+    BERSERKER_STANCE = ai->getSpellIdExact("Berserker Stance");
+
+
+    //Taunts
+    TAUNT = ai->getSpellIdExact("Taunt");
+    CHALLENGING_SHOUT = ai->getSpellIdExact("Challenging Shout");
+    MOCKING_BLOW = ai->getSpellIdExact("Mocking Blow");
+
+    //Special
+    SLAMM = 46916; //Instant Slam (Blood Surge)
+
+    TALENT_ARMS = MORTAL_STRIKE;
+    TALENT_FURY = BLOODTHIRST;
+    TALENT_PROT = DEVASTATE;
+
+    SHOOT = ai->getSpellIdExact("Shoot");
+
+    uint8 talentCounter = 0;
+    if (TALENT_ARMS) talentCounter++;
+    if (TALENT_FURY) talentCounter++;
+    if (TALENT_PROT) talentCounter++;
+    if (talentCounter > 1) { TALENT_ARMS = 0; TALENT_FURY = 0; TALENT_PROT = 0; } //Unreliable Talent detection.
+    #pragma endregion
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget || pTarget->isDead()) return;
+    PlayerbotAI *ai = GetAI();
+    if (!ai) return;
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || m_bot->isDead()) return;
+    Unit *pVictim = pTarget->getVictim();
+    Unit *m_tank = FindMainTankInRaid(GetMaster());
+    if (!m_tank && m_bot->GetGroup() && GetMaster()->GetGroup() != m_bot->GetGroup()) { FindMainTankInRaid(m_bot); }
+    if (!m_tank) { m_tank = m_bot; }
+    uint32 masterHP = GetMaster()->GetHealth()*100 / GetMaster()->GetMaxHealth();
+    float pDist = m_bot->GetDistance(pTarget);
+    uint8 pThreat = GetThreatPercent(pTarget);
+
+    if (!m_pulling){
+        #pragma region Choose Role / Stance
+
+        m_role = BOT_ROLE_DPS_MELEE;
+
+        // Choose Stance
+        if (m_tank->GetGUID() == m_bot->GetGUID()) // Hey! I am Main Tank
+        {
+            if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_TANK; return; }  //m_bot->GetShield(true)
+        }
+        else if (isUnderAttack()) // I am under attack
+        {
+            if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && pDist <= 2)  {} // My target is almost up to me, no need to search
+            else //Have to select nearest target
+            {
+                Unit *curAtt = GetNearestAttackerOf(m_bot);
+                if (curAtt && curAtt->GetGUID() != pTarget->GetGUID())
+                {
+                    m_bot->SetSelection(curAtt->GetGUID());
+                    //ai->AddLootGUID(curAtt->GetGUID());
+                    DoNextCombatManeuver(curAtt); //Restart new update to get variables fixed..
+                    return;
+                }
+            }
+            //my target is attacking me
+            //if (m_bot->getRace() == (uint8) RACE_NIGHTELF && CanCast(R_SHADOWMELD,m_bot) && CastSpell(R_SHADOWMELD,m_bot) ) { return; }
+            if (m_bot->GetShield(true)) { if (ChangeStance(DEFENSIVE_STANCE)) { m_role = BOT_ROLE_OFFTANK; return; } }
+            else if (ChangeStance(BATTLE_STANCE)) { return; }
+        }
+        else if (ai->GetHealthPercent() > 90)
+        {
+            if (ChangeStance(BERSERKER_STANCE)) { return; }
+        }
+        else if (ai->GetForm() != FORM_BERSERKERSTANCE || ai->GetHealthPercent() < 70 ) { if (ChangeStance(BATTLE_STANCE)) { return; } }
+        #pragma endregion
+    }
+
+    // Cast CC breakers if any match found  (does not work yet)
+    // uint32 ccSpells[7] = { HEROIC_FURY, BERSERKER_RAGE, BLADESTORM, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_WILL_OF_FORSAKEN, R_STONEFORM };
+    // if (castSelfCCBreakers(ccSpells)) { } //most of them dont have gcd
+
+    TakePosition(pTarget);
+
+    // If there's a cast stop
+    if(m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+
+    if (m_pulling) {
+        if (GetAI()->CastSpell(SHOOT,pTarget)) {
+            m_pulling = false;
+            GetAI()->SetCombatOrder(ORDERS_NONE);
+            GetAI()->Follow(*GetMaster());
+            GetAI()->SetIgnoreUpdateTime(2);
+         }
+          return;
+    }
+
+    #pragma region Buff Heal Interrupt
+    //Buff UP
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+
+    //HEAL UP && PROTECT UP
+    if (ai->GetHealthPercent() <= 85 && CastSpell(SHIELD_BLOCK, m_bot)) { } //no GCD
+    if (ai->GetHealthPercent() <= 45 && CastSpell(SHIELD_WALL, m_bot)) { return; }
+    if (ai->GetHealthPercent() < 55 &&
+        (m_bot->HasAura(BERSERKER_RAGE) || m_bot->HasAura(BLOODRAGE) || m_bot->HasAura(DEATH_WISH)) //There are other spells that count as enrage
+        && CastSpell(ENRAGED_REGENERATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 25 && CastSpell(INTIMIDATING_SHOUT, m_bot)) { return; }
+    if (ai->GetHealthPercent() <= 75 && CastSpell(LAST_STAND, m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_DWARF && ai->GetHealthPercent() < 75 && CastSpell(R_STONEFORM,m_bot)) { } //no gcd
+    if (m_bot->getRace() == (uint8) RACE_DRAENEI && ai->GetHealthPercent() < 55 && CastSpell(R_GIFT_OF_NAARU,m_bot)) { return; } //no Gcd, but has cast
+
+    //Break spells being cast
+    if (pTarget->IsNonMeleeSpellCasted(true))
+    {
+        if (pVictim && pVictim->GetGUID() == m_bot->GetGUID() && CastSpell(SPELL_REFLECTION,pTarget)) { return; }
+        if (m_bot->HasAura(SPELL_REFLECTION))
+        {
+            if (CastSpell(SHIELD_BASH,pTarget)) {} // No GCD
+            else if (CastSpell(PUMMEL,pTarget)) { return; }
+            else if (m_bot->getRace() == (uint8) RACE_BLOODELF && pDist < 8 && CastSpell(R_ARCANE_TORRENT, pTarget)) { } //no gcd
+        }
+    }
+    #pragma endregion
+
+    #pragma region Taunt / Threat
+    // if i am main tank, protect master by taunt
+    if(m_tank->GetGUID() == m_bot->GetGUID())
+    {
+        // Taunt if needed (Only for master)
+        Unit *curAtt = GetAttackerOf(GetMaster());
+        if (curAtt)
+        {
+            if (isUnderAttack(GetMaster(),2) && CastSpell(CHALLENGING_SHOUT, curAtt)) { return; }
+            if (CastSpell(TAUNT, curAtt,true,true))  { return; }
+            if (CastSpell(VIGILANCE, GetMaster())) { return; }
+            if (CastSpell(TAUNT, curAtt))  { return; }
+            if (CastSpell(MOCKING_BLOW, curAtt)) { return; }
+        }
+        // My target is not attacking me, taunt..
+        if (pVictim && pVictim->GetGUID() != m_bot->GetGUID())
+        {
+            if (CastSpell(VIGILANCE, pVictim)) { return; }
+            if (CastSpell(TAUNT, pTarget))  { return; }
+            if (CastSpell(MOCKING_BLOW, pTarget)) { return; }
+        }
+    }
+
+    // If not in Defensive Stance slow down due to threat
+    if (pThreat > threatThreshold && ai->GetForm() != FORM_DEFENSIVESTANCE && m_tank->GetGUID() != m_bot->GetGUID() && !isUnderAttack() )
+    {
+        if (m_tank->getVictim() && m_tank->getVictim()->GetGUID() != pTarget->GetGUID()) // I am attacking wrong target!!
+        {
+            m_bot->SetSelection(m_tank->getVictim()->GetGUID());
+            return;
+        }
+        else { return; } //Warrior has no threat reducing spells, just slow down
+    }
+    #pragma endregion
+
+    #pragma region Dps
+
+    //Ranged Stuff (Openers)
+    if (CastSpell(CHARGE,pTarget)) { } //no GCD
+    else if (CastSpell(INTERCEPT,pTarget)) { } //no GCD
+    if (pDist > MELEE_RANGE && ai->GetForm() == FORM_DEFENSIVESTANCE && CastSpell(HEROIC_THROW,pTarget)) { return; } //High threat
+    if (pDist > MELEE_RANGE && CastSpell(SHATTERING_THROW,pTarget)) { return; }
+
+    //Catch
+    if (pTarget->HasUnitMovementFlag(UNIT_FLAG_FLEEING))
+    {
+        if (CastSpell(HAMSTRING,pTarget)) return;
+        if (CastSpell(PIERCING_HOWL,pTarget)) return;
+    }
+
+
+    //Dps up
+    if (ai->GetHealthPercent() > 90 && ai->GetRageAmount() < 20 && CastSpell(BLOODRAGE,m_bot))  { return; }
+    if (isUnderAttack() && CastSpell(RETALIATION,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 90 && CastSpell(DEATH_WISH,m_bot)) { return; }
+    if (ai->GetHealthPercent() > 80 && CastSpell(RECKLESSNESS,m_bot)) { return; }
+    if (m_bot->getRace() == (uint8) RACE_TROLL && CastSpell(R_BERSERKING,m_bot)) {} //no GCD
+    if (m_bot->getRace() == (uint8) RACE_ORC && CastSpell(R_BLOOD_FURY,m_bot)) {} //no GCD
+
+    //Tank only stuff
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 85) && CastSpell(THUNDER_CLAP)) { return; } //High threat
+    if ((ai->GetForm() == FORM_DEFENSIVESTANCE || ai->GetRageAmount() > 75) && CastSpell(HEROIC_STRIKE)) {} //nogcd high threat
+
+    //Finishing Move / Timed moves
+    if (ai->GetHealthPercent(*pTarget) < 20 && CastSpell(EXECUTE,pTarget)) { return; }
+    if (CastSpell(VICTORY_RUSH,pTarget)) { return; }
+
+    //AOE
+    if (CastSpell(SHOCKWAVE,pTarget)) { return; }
+    if ((isUnderAttack(m_tank,3) || m_tank->GetGUID() == m_bot->GetGUID()) && CastSpell(CLEAVE,pTarget)) {} //no GCD
+    if (isUnderAttack(m_tank,3) && CastSpell(SWEEPING_STRIKES,m_bot)) {} //no GCD
+    if (isUnderAttack(m_tank,4) && CastSpell(BLADESTORM,m_bot)) { return; }
+    if (isUnderAttack(m_tank,4) && CastSpell(WHIRLWIND,pTarget)) { return; }
+
+    //Main dps
+    if (m_bot->HasAura(SLAMM) && CastSpell(SLAM,pTarget)) { return; }  //instant slam only
+    if (CastSpell(REVENGE,pTarget)) { return; } //Def stance only
+    if (CastSpell(OVERPOWER,pTarget)) { return; }
+    if (CastSpell(SHIELD_SLAM,pTarget)) { return; }
+    if (CastSpell(BLOODTHIRST,pTarget)) { return; }
+    if (CastSpell(MORTAL_STRIKE,pTarget)) { return; }
+
+
+    //Support/Debuff
+    if (CastSpell(DEMORALIZING_SHOUT,pTarget)) { return; }
+    if (DEVASTATE) { if (CastSpell(DEVASTATE,pTarget,1,1)) { return; } }  //High threat
+    else if (CastSpell(SUNDER_ARMOR)) { return; } //Only 1 - High threat
+    if (CastSpell(CONCUSSION_BLOW,pTarget)) { return; }
+    if (CastSpell(REND,pTarget)) { return; }
+    if (CastSpell(DISARM,pTarget)) { return; }
+    #pragma endregion
+
+} //end DoNextCombatManeuver
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot || !ai || m_bot->isDead()) { return; }
+
+    //If Casting or Eating/Drinking return
+    if (m_bot->HasUnitState(UNIT_STAT_CASTING)) { return; }
+    if (m_bot->getStandState() == UNIT_STAND_STATE_SIT) { return; }
+
+    //Buff Up
+    if (!m_bot->HasAura(BATTLE_SHOUT) && CastSpell(BATTLE_SHOUT,m_bot)) { return; }
+    if (!m_bot->HasAura(BATTLE_SHOUT,m_bot->GetGUID()) && !m_bot->HasAura(COMMANDING_SHOUT) && CastSpell(COMMANDING_SHOUT,m_bot)) { return; }
+
+    if (GetMaster()->isAlive() && CastSpell(VIGILANCE, GetMaster())) { return; }
+
+    //want to start off in battle stance so we can CHARGE
+    //if(ai->GetRageAmount() < 20 && ai->GetForm() != FORM_BATTLESTANCE && ChangeStance(BATTLE_STANCE)) { return; }
+
+    //mana/hp check
+    if (m_bot->getRace() == (uint8) RACE_UNDEAD_PLAYER && ai->GetHealthPercent() < 75 && CastSpell(R_CANNIBALIZE,m_bot)) { return; }
+    if (ai->GetHealthPercent() < 75) { ai->Feast(); }
+} //end DoNonCombatActions
+
+bool PlayerbotWarriorAI::ChangeStance(uint32 stance)
+{
+    if (stance == 0) return false;
+    if (CastSpell(stance, GetPlayerBot())) { return true; }
+    return false;
+}
+
+void PlayerbotWarriorAI::Pull()
+{
+    if (!SHOOT) return;
+
+    // check ammo
+    uint32 ammo_id = GetPlayerBot()->GetUInt32Value(PLAYER_AMMO_ID);
+    if (!ammo_id) {
+        GetPlayerBot()->Say("I'm out of ammo.", LANG_UNIVERSAL);
+        return;
+    }
+
+    Unit* pTarget = ObjectAccessor::GetUnit(*GetMaster(), GetMaster()->GetSelection());
+    if (pTarget==NULL || pTarget->IsFriendlyTo(GetMaster()))
+    {
+        GetPlayerBot()->Say("Invalid target", LANG_UNIVERSAL);
+        m_pulling = false;
+        GetAI()->Follow(*GetMaster());
+        return;
+    }
+
+    m_role = BOT_ROLE_DPS_RANGED;
+    m_pulling = true;
+    GetAI()->SetIgnoreUpdateTime(0);
+}
+
+/*
+void PlayerbotWarriorAI::BreakCC(const uint32 diff)
+{
+    if(pvpTrinket_cd < diff && GCD < diff)
+    {
+        if(m_creature->HasAuraType(SPELL_AURA_MOD_ROOT) ||
+        m_creature->HasAuraType(SPELL_AURA_MOD_CONFUSE) || //dragons breath/blind/poly
+        m_creature->HasAura(8983)                       || //Druid bash rank 3
+        m_creature->HasAura(27006)                      || //Druid pounce rank 4
+        m_creature->HasAura(33786)                      || //Druid cyclone
+        m_creature->HasAura(22570, 1)                   || //Druid maim
+        m_creature->HasAura(10308)                      || //Paladin hammer of justice rank 4
+        m_creature->HasAura(30414, 1)                   || //Warlock shadowfury rank 3
+        m_creature->HasAura(6215)                       || //Warlock fear rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(17928)                      || //Warlock howlofterror rank 3 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(10890)                      || //Priest psychic scream rank 4 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(14902)                      || //Rogue Cheap shot
+        m_creature->HasAura(8643)                       || //Rogue Kidney shot Rank 2
+        m_creature->HasAura(38764, 2)                   || //Rogue Gouge Rank 6 **REMOVE THIS & IMPLEMENT IN BERSERKER RAGE**
+        m_creature->HasAura(12809))                        //Warrior concussion blow
+        {
+            doCast(m_creature, PVPTRINKET); //I think it would be better to instead of applying individual spells that apply the
+            pvpTrinket_cd = PVPTRINKET_CD;  //effect SPELL_AURA_MOD_STUN, just add that type and start removing bad choices e.g. impact.
+        }
+
+        if(m_creature->HasAura(11297) && m_creature->GetDistance(m_creature->getVictim()) < 10)
+        {      //if warrior sapped and creature is less then 10 yards from war, cast pvp trinket and attempt to demo shout him out of stealth
+            doCast(m_creature, PVPTRINKET);
+            pvpTrinket_cd = PVPTRINKET_CD;
+            castDemoralizingShout = true;
+        }
+    }
+} //BreakCC
+*/
diff --git a/src/server/game/AI/Bots/PlayerbotWarriorAI.h b/src/server/game/AI/Bots/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..87ab4a8
--- /dev/null
+++ b/src/server/game/AI/Bots/PlayerbotWarriorAI.h
@@ -0,0 +1,57 @@
+#ifndef _PLAYERBOTWARRIORAI_H
+#define _PLAYERBOTWARRIORAI_H
+
+#include "PlayerbotClassAI.h"
+
+class PlayerbotWarriorAI : PlayerbotClassAI
+{
+    public:
+        PlayerbotWarriorAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotWarriorAI();
+
+        virtual void LoadSpells();
+
+        //all combat actions go here
+        void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        void DoNonCombatActions();
+
+        virtual void Pull();
+
+    private:
+        //Defensive Stance
+        uint32 SHIELD_WALL, REVENGE, SHIELD_BLOCK, DISARM, INTERVENE;
+
+        //Berserker Stance
+        uint32 RECKLESSNESS, WHIRLWIND, PUMMEL, INTERCEPT;
+
+        //Battle Stance
+        uint32 RETALIATION, CHARGE, OVERPOWER, SHATTERING_THROW;
+
+        //Mixed Attacks                                              //1 3
+        uint32 REND, THUNDER_CLAP, SPELL_REFLECTION, SHIELD_BASH, EXECUTE, HAMSTRING, SWEEPING_STRIKES, VICTORY_RUSH;
+
+        //General attacks
+        uint32 HEROIC_STRIKE, MORTAL_STRIKE, BLOODTHIRST, SHIELD_SLAM, SHOCKWAVE, SLAM, CLEAVE, BLADESTORM, HEROIC_THROW, CONCUSSION_BLOW, SUNDER_ARMOR, DEMORALIZING_SHOUT, INTIMIDATING_SHOUT, PIERCING_HOWL, DEVASTATE;
+
+        //buffs
+        uint32 COMMANDING_SHOUT, BATTLE_SHOUT, VIGILANCE, BERSERKER_RAGE, ENRAGED_REGENERATION, BLOODRAGE, LAST_STAND, HEROIC_FURY, DEATH_WISH;
+
+        //Stances
+        uint32 DEFENSIVE_STANCE, BATTLE_STANCE, BERSERKER_STANCE;
+
+        //Taunts
+        uint32 TAUNT, CHALLENGING_SHOUT, MOCKING_BLOW;
+
+        //Special
+        uint32 SLAMM;
+
+        uint32 TALENT_ARMS, TALENT_FURY, TALENT_PROT;
+
+        bool ChangeStance(uint32 stance);
+
+
+};
+
+#endif
diff --git a/src/server/game/AI/CoreAI/PetAI.cpp b/src/server/game/AI/CoreAI/PetAI.cpp
index e009bf9..ab24f48 100755
--- a/src/server/game/AI/CoreAI/PetAI.cpp
+++ b/src/server/game/AI/CoreAI/PetAI.cpp
@@ -287,6 +287,8 @@ void PetAI::KilledUnit(Unit* victim)
 
 void PetAI::AttackStart(Unit* target)
 {
+    if (me->GetCharmInfo() == NULL) return;
+
     // Overrides Unit::AttackStart to correctly evaluate Pet states
 
     // Check all pet states to decide if we can attack this target
diff --git a/src/server/game/AI/ScriptedAI/PlayerbotClassAI.h b/src/server/game/AI/ScriptedAI/PlayerbotClassAI.h
new file mode 100644
index 0000000..202adf4
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/PlayerbotClassAI.h
@@ -0,0 +1,162 @@
+#ifndef _PLAYERBOTCLASSAI_H
+#define _PLAYERBOTCLASSAI_H
+
+#include "Common.h"
+#include "World.h"
+#include "SpellMgr.h"
+#include "Player.h"
+#include "ObjectMgr.h"
+#include "WorldPacket.h"
+#include "Unit.h"
+#include "SharedDefines.h"
+#include "PlayerbotAI.h"
+#include "SpellAuras.h"
+#include "Cell.h"
+#include "CellImpl.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+
+
+class Player;
+class PlayerbotAI;
+class Aura;
+
+        enum BotRole
+        {
+            BOT_ROLE_NONE,
+            BOT_ROLE_TANK,
+            BOT_ROLE_OFFTANK,
+            BOT_ROLE_DPS_RANGED,
+            BOT_ROLE_DPS_MELEE,
+            BOT_ROLE_SUPPORT,
+            BOT_ROLE_HEALER
+        };
+
+class PlayerbotClassAI
+{
+    public:
+        PlayerbotClassAI(Player *const master, Player *const bot, PlayerbotAI *const ai);
+        virtual ~PlayerbotClassAI();
+
+        //all combat actions go here
+        virtual void DoNextCombatManeuver(Unit *);
+
+        //all non combat actions go here, ex buffs, heals, rezzes
+        virtual void DoNonCombatActions();
+
+        //buff a specific player, usually a real PC who is not in group
+        virtual bool BuffPlayer(Unit *target);
+
+        //Heals the target based off its HP
+        virtual bool HealTarget (Unit *target, uint8 hp);
+
+        //Heals the group based off its HP
+        virtual bool HealGroup (Unit *target, uint8 hp, uint8 &countNeedHeal);
+
+        //Cure the target
+        virtual bool CureTarget (Unit *target);
+
+        //Resurrect the target (OBSOLETE - Check individual ClassAIs instead)
+        virtual bool RezTarget(Unit *target);
+
+        //find any specific mount spells, ie druids = cat, shaman = ghost wolf etc (OBSOLETE)
+        virtual bool FindMount();
+
+        virtual bool Unmount();
+
+        virtual bool IsMounted();
+
+        virtual void LoadSpells();
+
+        virtual void Pull();
+
+        //Utilities
+        Player *GetMaster (){ return m_master; }
+        Player *GetPlayerBot(){ return m_bot; }
+        PlayerbotAI *GetAI (){ return m_ai; }
+
+        bool isPulling() { return m_pulling; }
+        bool TakePosition(Unit *followTarget, BotRole bRole=BOT_ROLE_NONE, float bDist=0, float bMinDist=0, float bMaxDist=0, float bAngle=0, Unit *faceTarget=NULL);
+        //Gets the threat done by bot / threat max (percent) to the target.
+        uint8 GetThreatPercent(Unit *pTarget, Unit *pFrom = NULL);
+        //Gets if the unit is under attack by # of attackers
+        bool isUnderAttack(Unit *pAttacked=NULL,const uint8 &minNumberOfAttackers=1);
+        //Gets the first found attacker of Unit
+        Unit *GetAttackerOf(Unit *pAttacked=NULL);
+        //Gets the nearest attacker of Unit if not nearestToAttacked > finds the one nearest to bot
+        Unit *GetNearestAttackerOf(Unit *pAttacked=NULL, bool nearestToAttacked=false);
+        //Calculates Average Raid Health condition as Percentage, ref value is the Count of units need healing..
+        uint8 GetHealthPercentRaid(Player *gPlayer, uint8 &countNeedHealing);
+
+        // Called when the main tank is set from raid ui
+        void SetMainTank (Unit *tank);
+
+        //Finds the possible MainTank in Raid including Hunter/Warlock pets.. Makes the assumption based on - max maxHealth..
+        Unit *FindMainTankInRaid(Player *gPlayer);
+
+        //Finds the possible MainAssist in Raid.  Defaults to Main Tank if it cannot find one.
+        Unit *FindMainAssistInRaid(Player *gPlayer);
+
+        Player *FindMage(Player *gPlayer);
+        //Finds the lowest hp creature around that is friendly with the caster.
+        Unit *DoSelectLowestHpFriendly(float range, uint32 MinHPDiff);
+
+
+        protected:
+        bool CastSpell(uint32 spellId, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CastSpell(const SpellInfo * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=false);
+        bool CanCast(uint32 spellId, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        bool CanCast(const SpellInfo * pSpellInfo, Unit *target=NULL,bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+
+        //Debug method to list the auras currently active.
+        //Use to find what spells were casted
+        bool listAuras(Unit *unit);
+
+        //More generalized method than HasAura().  It looks for
+        //any rank of the spell and it doesn't care which
+        //spell effect you want.  If it has the spell aura than
+        //it returns true
+        bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+
+        //The following functions return true only a match is found and the bot successfully casted a spell to resolve the problem
+        //If the result is false, either a match is not found, or the ClassAI could not cast or refused to cast a spell for some reason..
+
+        //Combination of all Healer roles, scans the party and decides if group healing > individual healing > Rez > curing > buffing is needed
+        //and directs any matches found to individual ClassAIs
+        //Main Raid scan function for Healer/Support types..
+        bool DoSupportRaid(Player *gPlayer, float radius=30, bool dResurrect=true, bool dGroupHeal=true, bool dHeal=true, bool dCure=true, bool dBuff=true);
+        //Find matching debuffs on target to provided Spell, and call castSpell() with provided parameters
+        bool castDispel (uint32 dispelSpell, Unit *dTarget, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false);
+        //Cast matching debuffs on self with probided SpellId list.. Mainly Used for Racial spells.. List is used to prevent extra loops for each spell..
+        bool castSelfCCBreakers (uint32 castList[]);
+
+
+
+        typedef std::set<Unit *> AttackerSet;
+
+        uint8 rezSpamTimer;
+        uint32 foodDrinkSpamTimer;
+        static const uint32 foodDrinkSpamCount = 100;
+
+        BotRole m_role;
+        bool m_pulling;
+        uint32 threatThreshold, offensiveSpellThreshold;
+
+        // RACIAL SPELLS
+        uint32 R_ARCANE_TORRENT, R_BERSERKING, R_BLOOD_FURY, R_CANNIBALIZE, R_ESCAPE_ARTIST, R_EVERY_MAN_FOR_HIMSELF, R_GIFT_OF_NAARU, R_SHADOWMELD, R_STONEFORM, R_WAR_STOMP, R_WILL_OF_FORSAKEN;
+        // first aid
+        uint32 RECENTLY_BANDAGED;
+        uint32 SHOOT;
+
+    private:
+        Player *m_master;
+        Player *m_bot;
+        PlayerbotAI *m_ai;
+        Unit *mainTank;
+
+
+
+};
+
+#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 65ba160..7c32c84 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -107,6 +107,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/dep/zlib
   ${CMAKE_SOURCE_DIR}/src/server/collision
   ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/Bots
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
   ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
@@ -127,6 +128,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/Bots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index 185ac48..3be4da4 100755
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -217,6 +217,14 @@ ChatCommand* ChatHandler::getCommandTable()
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
+    static ChatCommand questCommandTable[] =
+    {
+        { "add",            SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestAdd>,                   "", NULL },
+        { "complete",       SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestComplete>,              "", NULL },
+        { "remove",         SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleQuestRemove>,                "", NULL },
+        { NULL,             0,                  false, NULL,                                           "", NULL }
+    };
+
     static ChatCommand resetCommandTable[] =
     {
         { "achievements",   SEC_ADMINISTRATOR,  true,  OldHandler<&ChatHandler::HandleResetAchievementsCommand>,   "", NULL },
@@ -414,6 +422,11 @@ ChatCommand* ChatHandler::getCommandTable()
         { "bindsight",      SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleBindSightCommand>,           "", NULL },
         { "unbindsight",    SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandleUnbindSightCommand>,         "", NULL },
         { "playall",        SEC_GAMEMASTER,  false, OldHandler<&ChatHandler::HandlePlayAllCommand>,             "", NULL },
+        // Playerbot mod
+        { "bot",            SEC_ADMINISTRATOR,  false, OldHandler<&ChatHandler::HandlePlayerbotCommand>,             "", NULL },
+        { "maintank",       SEC_PLAYER,  false, OldHandler<&ChatHandler::HandlePlayerbotMainTankCommand>,             "", NULL },
+        // npcbot
+        { "npcbot",         SEC_PLAYER,  false, OldHandler<&ChatHandler::HandleNpcBotCommand>,             "", NULL },
         { NULL,             0,                  false, NULL,                                           "", NULL }
     };
 
diff --git a/src/server/game/Chat/Chat.h b/src/server/game/Chat/Chat.h
index 24652fc..2d6ac5d 100755
--- a/src/server/game/Chat/Chat.h
+++ b/src/server/game/Chat/Chat.h
@@ -211,6 +211,13 @@ class ChatHandler
         bool HandlePDumpLoadCommand(const char *args);
         bool HandlePDumpWriteCommand(const char *args);
 
+        bool HandlePlayerbotCommand(const char *args);
+        bool HandlePlayerbotMainTankCommand(const char *args);
+        bool HandleQuestAdd(const char * args);
+        bool HandleQuestRemove(const char * args);
+        bool HandleQuestComplete(const char * args);
+        bool HandleNpcBotCommand(const char * args);
+
         bool HandleResetAchievementsCommand(const char * args);
         bool HandleResetAllCommand(const char * args);
         bool HandleResetHonorCommand(const char * args);
diff --git a/src/server/game/Chat/Commands/Level0.cpp b/src/server/game/Chat/Commands/Level0.cpp
index 97173f7..3496792 100755
--- a/src/server/game/Chat/Commands/Level0.cpp
+++ b/src/server/game/Chat/Commands/Level0.cpp
@@ -28,6 +28,7 @@
 #include "SystemConfig.h"
 #include "revision.h"
 #include "Util.h"
+#include "Group.h"
 
 bool ChatHandler::HandleHelpCommand(const char* args)
 {
@@ -150,6 +151,180 @@ bool ChatHandler::HandleSaveCommand(const char* /*args*/)
     return true;
 }
 
+//Playerbot mod
+bool ChatHandler::HandlePlayerbotCommand(const char *args)
+{
+    if(!m_session)
+    {
+        PSendSysMessage("You may only add bots from an active session");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    if(!*args)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if(!cmd || !charname)
+    {
+        PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+    uint64 guid;
+
+   if (charnameStr.compare("all") != 0)
+   {
+       if (!normalizePlayerName(charnameStr))
+           return false;
+
+       guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+       if (guid == 0 || (guid == m_session->GetPlayer()->GetGUID()))
+       {
+           SendSysMessage(LANG_PLAYER_NOT_FOUND);
+           SetSentErrorMessage(true);
+           return false;
+       }
+
+       uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+       if (accountId != m_session->GetAccountId())
+       {
+           PSendSysMessage("You may only add bots from the same account.");
+           SetSentErrorMessage(true);
+           return false;
+       }
+   }
+
+    if (cmdStr.compare("add") == 0 || cmdStr.compare("login") == 0)
+    {
+        if (charnameStr.compare("all") == 0)
+        {
+            std::list<std::string> *names;
+            names=m_session->GetPlayer()->GetCharacterList();
+            std::list<std::string>::iterator iter,next;
+            for (iter = names->begin(); iter != names->end(); iter++)
+            {
+                std::stringstream arg;
+                arg << "add " << (*iter).c_str();
+                HandlePlayerbotCommand(arg.str().c_str());
+            }
+            PSendSysMessage("Bots added successfully.");
+            return true;
+        }
+        else
+        {
+            if(m_session->GetPlayerBot(guid) != NULL)
+            {
+                PSendSysMessage("Bot already exists in world.");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            m_session->AddPlayerBot(guid);
+        }
+
+    }
+    else if (cmdStr.compare("remove") == 0 || cmdStr.compare("logout") == 0)
+    {
+        if (charnameStr.compare("all") == 0)
+        {
+            std::list<std::string> *names = new std::list<std::string>;
+            for (PlayerBotMap::const_iterator iter = m_session->GetPlayerBotsBegin(); iter != m_session->GetPlayerBotsEnd(); ++iter)
+            {
+                names->push_back(iter->second->GetName());
+            }
+            std::list<std::string>::iterator iter,next;
+            for (iter = names->begin(); iter != names->end(); iter++)
+            {
+                std::stringstream arg;
+                arg << "remove " << (*iter).c_str();
+                HandlePlayerbotCommand(arg.str().c_str());
+            }
+            return true;
+        }
+        else
+        {
+            if (m_session->GetPlayerBot(guid) == NULL)
+            {
+                PSendSysMessage("Bot can not be removed because bot does not exist in world.");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            m_session->LogoutPlayerBot(guid, true);
+            PSendSysMessage("Bot removed successfully.");
+            return true;
+        }
+    }
+    return true;
+}
+
+bool ChatHandler::HandlePlayerbotMainTankCommand(const char *args)
+{
+    uint64 guid = 0;
+    uint64 pGuid = 0;
+    char *charname ;
+    Group *group = m_session->GetPlayer()->GetGroup();
+
+    if (group == NULL) {
+        PSendSysMessage("Must be in a group to set a main tank.");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, group->GetGUID());
+    if(result)
+    {
+        pGuid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_PLAYER);
+    }
+
+    // if no arguments are passed in, just say who the current main tank is
+    if(!*args) {
+
+        if (pGuid>0) {
+            Player *pPlayer = ObjectAccessor::FindPlayer(pGuid);
+
+            if (pPlayer  && pPlayer->isAlive()){
+                PSendSysMessage("Main tank is %s.", pPlayer->GetName());
+                return true;
+            }
+        }
+
+        PSendSysMessage("Currently there is no main tank. ");
+        return true;
+    } else {
+        charname = strtok ((char*)args, " ");
+        std::string charnameStr = charname;
+        guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+
+        // clear if same player
+        if (pGuid==guid) {
+            group->SetGroupMemberFlag(guid, false, MEMBER_FLAG_MAINTANK);
+            PSendSysMessage("Main tank has been cleared. ");
+            return true;
+        }
+
+        if (m_session->GetPlayer()->GetGroup()->IsMember(guid)) {
+            group->SetGroupMemberFlag(pGuid,false, MEMBER_FLAG_MAINTANK); // clear old one
+            group->SetGroupMemberFlag(guid, true, MEMBER_FLAG_MAINTANK);  // set new one
+            Player *pPlayer = ObjectAccessor::FindPlayer(guid);
+            if (pPlayer->IsInWorld())
+                PSendSysMessage("Main tank is %s.", pPlayer->GetName());
+            else
+                PSendSysMessage("Player is not online.");
+        } else {
+            PSendSysMessage("Player is not in your group.");
+        }
+    }
+    return true;
+}
+
 /// Display the 'Message of the day' for the realm
 bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
 {
@@ -157,3 +332,401 @@ bool ChatHandler::HandleServerMotdCommand(const char* /*args*/)
     return true;
 }
 
+bool ChatHandler::HandleNpcBotCommand(const char* args)
+{
+    if(!*args) 
+    {
+        PSendSysMessage("usage:");
+        PSendSysMessage("add <botclass>");
+        PSendSysMessage("create (cre) <botclass>");
+        PSendSysMessage("revive (rev)");
+        PSendSysMessage("reset (res)");
+        PSendSysMessage("remove (rem)");
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    Player* owner = m_session->GetPlayer();
+    char* bclass = strtok((char*)args, " ");
+    uint8 botclass = 0;
+
+    if(args[0] == 'r' && args[1] == 'e' && args[2] == 'm')
+    {
+        uint64 guid = owner->GetSelection();
+        Player *master = NULL;
+        if(!guid)
+        {
+            PSendSysMessage(".npcbot remove");
+            PSendSysMessage("Remove npcbots for selected Playerbot, you can also remove npcbots manually");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        master = sObjectAccessor->FindPlayer(guid);
+        if (master)
+        {
+            if(master->GetSession()->GetAccountId() != owner->GetSession()->GetAccountId())
+            {
+                PSendSysMessage("You can only remove bots from self and your own playerbots");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            if(master->HaveBot())
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    uint64 guid = master->GetBotMap()[i].m_guid;
+                    if (guid != 0) master->RemoveBot(guid, true);
+                }
+                if (!master->HaveBot())
+                {
+                    PSendSysMessage("Npcbot successfully removed");
+                    SetSentErrorMessage(true);
+                    return true;
+                }
+                PSendSysMessage("Error!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            else
+            {
+                PSendSysMessage("Npcbots are not found!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+        }
+        Creature *cre = sObjectAccessor->GetCreature(*owner, guid);
+        if (cre)
+        {
+            uint8 pos = 0;
+            uint64 masterguid = cre->GetBotOwnerGUID();
+            if (masterguid != 0)
+                master = sObjectAccessor->FindPlayer(masterguid);
+            if (!master)
+            {
+                PSendSysMessage("npcbot's master is not found");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            if(master->GetSession()->GetAccountId() != owner->GetSession()->GetAccountId())
+            {
+                PSendSysMessage("You can only remove bots from self and your own playerbots");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            pos = master->GetNpcBotSlot(guid);
+            master->RemoveBot(cre->GetGUID(), true);
+            if (master->GetBotMap()[pos].m_creature == NULL)
+            {
+                PSendSysMessage("Npcbots successfully removed");
+                SetSentErrorMessage(true);
+                return true;
+            }
+            return false;
+        }
+        PSendSysMessage(".npcbot remove");
+        PSendSysMessage("Remove npcbots for selected Playerbot, you can also remove npcbots manually");
+        SetSentErrorMessage(true);
+        return false;
+    }
+    if(args[0] == 'r' && args[1] == 'e' && args[2] == 's')
+    {
+        bool all = false;
+        Player* master = NULL;
+        uint64 guid = owner->GetSelection();
+        if(!guid)
+        {
+            PSendSysMessage(".npcbot reset");
+            PSendSysMessage("Reset selected npcbot or npcbots for selected Playerbot, you can also reset your npcbots");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        if(IS_PLAYER_GUID(guid))
+        {
+            all = true;
+            master = sObjectAccessor->FindPlayer(guid);
+        }
+        if(IS_CREATURE_GUID(guid))
+        {
+            Creature *cre = sObjectAccessor->GetCreature(*owner, guid);
+            if (cre)
+            {
+                uint64 masterguid = cre->GetOwnerGUID();
+                master = sObjectAccessor->FindPlayer(masterguid);
+            }
+        }
+        if(master && master->GetSession()->GetAccountId() == owner->GetSession()->GetAccountId())
+        {
+            if(!master->HaveBot())
+            {
+                PSendSysMessage("Npcbots are not found!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                if (all)
+                    master->RemoveBot(master->GetBotMap()[i].m_guid);
+                else if (master->GetBotMap()[i].m_guid == guid)
+                {
+                    master->RemoveBot(guid);
+                    break;
+                }
+            }
+            PSendSysMessage("NpcBot has been procced to reset");
+            SetSentErrorMessage(true);
+            return true;
+        }
+        PSendSysMessage(".npcbot reset");
+        PSendSysMessage("Reset selected npcbot or npcbot for selected Playerbot, you can also reset your npcbot");
+        SetSentErrorMessage(true);
+        return false;
+    }
+    if(args[0] == 'r' && args[1] == 'e' && args[2] == 'v')
+    {
+        if (owner->HaveBot())
+        {
+            uint8 deadbots = 0;
+            bool dead = false;
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = owner->GetBotMap()[i].m_creature;
+                if (!bot) continue;
+                if (bot->isDead() || bot->GetBotDied())
+                    ++deadbots;
+                if (deadbots > 0)
+                    break;
+            }
+            if (deadbots == 0)
+            {
+                PSendSysMessage(".npcbot revive");
+                PSendSysMessage("Revive your npcbot if you are hopelessly dead");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = owner->GetBotMap()[i].m_creature;
+                if (!bot || bot->isAlive()) continue;
+                botclass = bot->GetBotClass();
+                uint8 botRace = bot->GetBotRace();
+                uint32 botEntry = bot->GetEntry();
+                owner->SetBot(bot);
+                owner->CreateBot(botEntry, botRace, botclass, true);
+            }
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = owner->GetBotMap()[i].m_creature;
+                if (!bot) continue;
+                if (bot->isDead()) { dead = true; break; }
+            }
+            if (!dead)
+            {
+                PSendSysMessage("NpcBots revived");
+                SetSentErrorMessage(true);
+                return true;
+            }
+            else
+            {
+                PSendSysMessage("NpcBot is not revived or you still have dead bots!");
+                SetSentErrorMessage(true);
+                return true;
+            }
+        }
+        else
+        {
+            PSendSysMessage("Cannot find your npcbots");
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+    if(args[0] == 'c' && args[1] == 'r' && args[2] == 'e')
+    {
+        Player* master = owner->GetSelectedPlayer();
+        if(!master)
+        {
+            PSendSysMessage(".npcbot create");
+            PSendSysMessage("Allows to create npcbot of given class for targeted Playerbot, can be also used on self");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        if(master->GetTypeId() != TYPEID_PLAYER || master->GetSession()->GetAccountId() != owner->GetSession()->GetAccountId())
+        {
+            PSendSysMessage("You should select yourself or one of your playerbots");
+            SetSentErrorMessage(true);
+            return false;
+        }
+
+        if(bclass == "cre druid" || args[4] == 'd')
+        {
+            botclass = CLASS_DRUID;
+        }
+        else if(bclass == "cre hunter" || args[4] == 'h')
+        {
+            botclass = CLASS_HUNTER;
+        }
+        else if(bclass == "cre mage" || args[4] == 'm')
+        {
+            botclass = CLASS_MAGE;
+        }
+        else if(bclass == "cre paladin" || (args[4] == 'p' && args[5] == 'a'))
+        {
+            botclass = CLASS_PALADIN;
+        }
+        else if(bclass == "cre priest" || (args[4] == 'p' && args[5] == 'r'))
+        {
+            botclass = CLASS_PRIEST;
+        }
+        else if(bclass == "cre rogue" || args[4] == 'r')
+        {
+            botclass = CLASS_ROGUE;
+        }
+        else if(bclass == "cre shaman" || args[4] == 's')
+        {
+            botclass = CLASS_SHAMAN;
+        }
+        else if(bclass == "cre warlock" || (args[4] == 'w' && args[5] == 'a' && args[6] == 'r' && args[7] == 'l'))
+        {
+            botclass = CLASS_WARLOCK;
+        }
+        else if(bclass == "cre warrior" || (args[4] == 'w' && args[5] == 'a' && args[6] == 'r' && args[7] == 'r'))
+        {
+            botclass = CLASS_WARRIOR;
+        }
+        else if(args[0] == 'c' && args[1] == 'r' && args[2] == 'e' && args[4] != NULL)
+        {
+            PSendSysMessage("Wrong bot class");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        if(botclass > 0)
+        {
+            if(master->isDead())
+            {
+                if (master == owner)
+                    owner->GetSession()->SendNotification("You're dead!");
+                else
+                    owner->GetSession()->SendNotification("He's dead!");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            else if (master->GetNpcBotsCount() < master->GetMaxNpcBots())
+            {
+                uint8 bots = master->GetNpcBotsCount();
+                master->CreateNPCBot(botclass);
+                master->RefreshBot(0);
+                if (master->GetNpcBotsCount() > bots)
+                {
+                    PSendSysMessage("NpcBot successfully created");
+                    SetSentErrorMessage(true);
+                    return true;
+                }
+            }
+            else
+            {
+                if (master->GetNpcBotsCount() >= master->GetMaxNpcBots())
+                {
+                    PSendSysMessage("Npcbots limit exceed");
+                    SetSentErrorMessage(true);
+                    return true;
+                }
+            }
+            PSendSysMessage("NpcBot is NOT created for some reason!");
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+    if(args[0] == 'a' && args[1] == 'd' && args[2] == 'd')
+    {
+        if((args[3] == NULL && args[4] == NULL) || bclass == "add" || bclass == "add ")
+        {
+            PSendSysMessage(".npcbot add");
+            PSendSysMessage("Create npcbot of given class for current character");
+            SetSentErrorMessage(true);
+            return false;
+        }
+        if(bclass == "add druid" || args[4] == 'd')
+        {
+            botclass = CLASS_DRUID;
+        }
+        else if(bclass == "add hunter" || args[4] == 'h')
+        {
+            botclass = CLASS_HUNTER;
+        }
+        else if(bclass == "add mage" || args[4] == 'm')
+        {
+            botclass = CLASS_MAGE;
+        }
+        else if(bclass == "add paladin" || (args[4] == 'p' && args[5] == 'a'))
+        {
+            botclass = CLASS_PALADIN;
+        }
+        else if(bclass == "add priest" || (args[4] == 'p' && args[5] == 'r'))
+        {
+            botclass = CLASS_PRIEST;
+        }
+        else if(bclass == "add rogue" || args[4] == 'r')
+        {
+            botclass = CLASS_ROGUE;
+        }
+        else if(bclass == "add shaman" || args[4] == 's')
+        {
+            botclass = CLASS_SHAMAN;
+        }
+        else if(bclass == "add warlock" || (args[4] == 'w' && args[5] == 'a' && args[6] == 'r' && args[7] == 'l'))
+        {
+            botclass = CLASS_WARLOCK;
+        }
+        else if(bclass == "add warrior" || (args[4] == 'w' && args[5] == 'a' && args[6] == 'r' && args[7] == 'r'))
+        {
+            botclass = CLASS_WARRIOR;
+        }
+        else if(args[0] == 'a' && args[1] == 'd' && args[2] == 'd' && args[4] != NULL)
+        {
+            PSendSysMessage("Wrong bot class");
+            SetSentErrorMessage(true);
+            return false;
+        }
+
+        if(botclass > 0)
+        {
+            if(owner->isDead())
+            {
+                owner->GetSession()->SendNotification("You are dead");
+                SetSentErrorMessage(true);
+                return false;
+            }
+            else
+            {
+                uint8 bots = owner->GetNpcBotsCount();
+                if (bots >= owner->GetMaxNpcBots())
+                {
+                    PSendSysMessage("Youre exceed max npcbots");
+                    SetSentErrorMessage(true);
+                    return false;
+                }
+                else
+                {
+                    owner->CreateNPCBot(botclass);
+                    owner->RefreshBot(0);
+                    if (owner->GetNpcBotsCount() > bots)
+                    {
+                        PSendSysMessage("NpcBot successfully created");
+                        SetSentErrorMessage(true);
+                        return true;
+                    }
+                }
+            }
+            PSendSysMessage("NpcBot is NOT created!");
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+    PSendSysMessage("usage:");
+    PSendSysMessage("add (botclass)");
+    PSendSysMessage("revive");
+    PSendSysMessage("reset");
+    PSendSysMessage("remove");
+    PSendSysMessage("cre (botclass)");
+    SetSentErrorMessage(true);
+    return false;
+}
diff --git a/src/server/game/Chat/Commands/Level1.cpp b/src/server/game/Chat/Commands/Level1.cpp
index f06f8a7..c441e52 100755
--- a/src/server/game/Chat/Commands/Level1.cpp
+++ b/src/server/game/Chat/Commands/Level1.cpp
@@ -183,9 +183,10 @@ bool ChatHandler::HandleSummonCommand(const char* args)
                 target->UnbindInstance(map->GetInstanceId(), target->GetDungeonDifficulty(), true);
 
             // we are in instance, and can summon only player in our group with us as lead
-            if (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
+            if(!target->IsPlayerbot() &&
+                (!m_session->GetPlayer()->GetGroup() || !target->GetGroup() ||
                 (target->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()) ||
-                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID()))
+                (m_session->GetPlayer()->GetGroup()->GetLeaderGUID() != m_session->GetPlayer()->GetGUID())))
                 // the last check is a bit excessive, but let it be, just in case
             {
                 PSendSysMessage(LANG_CANNOT_SUMMON_TO_INST, nameLink.c_str());
diff --git a/src/server/game/Chat/Commands/Level3.cpp b/src/server/game/Chat/Commands/Level3.cpp
index f4f5892..f4d699d 100755
--- a/src/server/game/Chat/Commands/Level3.cpp
+++ b/src/server/game/Chat/Commands/Level3.cpp
@@ -2831,6 +2831,207 @@ bool ChatHandler::HandleServerIdleShutDownCommand(const char *args)
     return true;
 }
 
+bool ChatHandler::HandleQuestAdd(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .addquest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND,entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+ // check item starting quest (it can work incorrectly if added without item in inventory)
+    ItemTemplateContainer const* its = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator itr = its->begin(); itr != its->end(); ++itr)
+    {
+        if (itr->second.StartQuest == entry)
+        {
+            PSendSysMessage(LANG_COMMAND_QUEST_STARTFROMITEM, entry, itr->second.ItemId);
+            SetSentErrorMessage(true);
+            return false;
+        }
+    }
+
+    // ok, normal (creature/GO starting) quest
+    if (player->CanAddQuest(pQuest, true))
+    {
+        player->AddQuest(pQuest, NULL);
+
+        if (player->CanCompleteQuest(entry))
+            player->CompleteQuest(entry);
+    }
+
+    return true;
+}
+
+bool ChatHandler::HandleQuestRemove(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .removequest #entry'
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    if (!pQuest)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 quest = player->GetQuestSlotQuestId(slot);
+        if (quest == entry)
+        {
+            player->SetQuestSlot(slot,0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            player->TakeQuestSourceItem(quest, false);
+        }
+    }
+
+    // set quest status to not started (will updated in DB at next save)
+    player->SetQuestStatus(entry, QUEST_STATUS_NONE);
+
+    // reset rewarded for restart repeatable quest
+   // player->getQuestStatusMap()[entry].m_rewarded = false;
+
+    SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+    return true;
+}
+
+bool ChatHandler::HandleQuestComplete(const char *args)
+{
+    Player* player = getSelectedPlayer();
+    if (!player)
+    {
+        SendSysMessage(LANG_NO_CHAR_SELECTED);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // .quest complete #entry
+    // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+    char* cId = extractKeyFromLink((char*)args,"Hquest");
+    if (!cId)
+        return false;
+
+    uint32 entry = atol(cId);
+
+    Quest const* pQuest = sObjectMgr->GetQuestTemplate(entry);
+
+    // If player doesn't have the quest
+    if (!pQuest || player->GetQuestStatus(entry) == QUEST_STATUS_NONE)
+    {
+        PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        SetSentErrorMessage(true);
+        return false;
+    }
+
+    // Add quest items for quests that require items
+    for (uint8 x = 0; x < QUEST_ITEM_OBJECTIVES_COUNT; ++x)
+    {
+        uint32 id = pQuest->RequiredItemId[x];
+        uint32 count = pQuest->RequiredItemCount[x];
+        if (!id || !count)
+            continue;
+
+        uint32 curItemCount = player->GetItemCount(id,true);
+
+        ItemPosCountVec dest;
+        uint8 msg = player->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, id, count-curItemCount);
+        if (msg == EQUIP_ERR_OK)
+        {
+            Item* item = player->StoreNewItem(dest, id, true);
+            player->SendNewItem(item,count-curItemCount,true,false);
+        }
+    }
+
+    // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+    for (uint8 i = 0; i < QUEST_OBJECTIVES_COUNT; ++i)
+    {
+        uint32 creature = pQuest->RequiredNpcOrGo[i];
+        uint32 creaturecount = pQuest->RequiredNpcOrGoCount[i];
+
+        if (uint32 spell_id = pQuest->RequiredSpellCast[i])
+        {
+            for (uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature,0,spell_id);
+        }
+        else if (creature > 0)
+        {
+            if (CreatureTemplate const* creatureInfo = sObjectMgr->GetCreatureTemplate(creature))
+                for (uint16 z = 0; z < creaturecount; ++z)
+                    player->KilledMonster(creatureInfo,0);
+        }
+        else if (creature < 0)
+        {
+            for (uint16 z = 0; z < creaturecount; ++z)
+                player->CastedCreatureOrGO(creature,0,0);
+        }
+    }
+
+    // If the quest requires reputation to complete
+    if (uint32 repFaction = pQuest->GetRepObjectiveFaction())
+    {
+        uint32 repValue = pQuest->GetRepObjectiveValue();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue);
+    }
+
+    // If the quest requires a SECOND reputation to complete
+    if (uint32 repFaction = pQuest->GetRepObjectiveFaction2())
+    {
+        uint32 repValue2 = pQuest->GetRepObjectiveValue2();
+        uint32 curRep = player->GetReputationMgr().GetReputation(repFaction);
+        if (curRep < repValue2)
+            if (FactionEntry const *factionEntry = sFactionStore.LookupEntry(repFaction))
+                player->GetReputationMgr().SetReputation(factionEntry,repValue2);
+    }
+
+    // If the quest requires money
+    int32 ReqOrRewMoney = pQuest->GetRewOrReqMoney();
+    if (ReqOrRewMoney < 0)
+        player->ModifyMoney(-ReqOrRewMoney);
+
+    player->CompleteQuest(entry);
+    return true;
+}
+
 bool ChatHandler::HandleBanAccountCommand(const char *args)
 {
     return HandleBanHelper(BAN_ACCOUNT, args);
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 3238d98..42d0e70 100755
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -160,6 +160,24 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_formation(NULL)
 
     ResetLootMode(); // restore default loot mode
     TriggerJustRespawned = false;
+
+    //bot
+    is_a_bot = false;
+    bot_AI = NULL;
+    m_Tank = NULL;
+    m_bot_base_mana = 0;
+    m_bot_form = 0;
+    m_bot_race = 0;
+    m_bot_class = 0;
+    m_botCommandState = COMMAND_FOLLOW;
+    m_bot_must_wait_for_spell_1 = 0;
+    m_bot_must_wait_for_spell_2 = 0;
+    m_bot_must_wait_for_spell_3 = 0;
+    m_bot_must_be_created = false;
+    m_bot_must_die = false;
+    m_bot_died = false;
+    m_bot_owner_guid = 0;
+    m_bot_owner = NULL;
 }
 
 Creature::~Creature()
@@ -2404,3 +2422,78 @@ bool Creature::IsDungeonBoss() const
     CreatureTemplate const* cinfo = sObjectMgr->GetCreatureTemplate(GetEntry());
     return cinfo && (cinfo->flags_extra & CREATURE_FLAG_EXTRA_DUNGEON_BOSS);
 }
+
+Creature *Creature::GetBotsPet(uint32 entry)
+{
+    //TODO: add few new pets and //implement stat system
+    Creature *pet = m_bot_owner->SummonCreature(entry, GetPositionX() + 5, GetPositionY() + 5, GetPositionZ(), 0, TEMPSUMMON_DEAD_DESPAWN, 0);
+
+    QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi FROM pet_levelstats WHERE creature_entry = 1860 AND level=%u", m_bot_owner->getLevel());
+
+    if(result)
+    {
+        Field *fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt32();
+        uint32 mana = fields[1].GetUInt32();
+        uint32 armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt32();
+        uint32 agi = fields[4].GetUInt32();
+
+        pet->SetMaxHealth(hp);
+        pet->SetMaxPower(POWER_MANA, mana);
+        pet->SetArmor(armor);
+        pet->SetStat(STAT_STRENGTH, str);
+        pet->SetStat(STAT_AGILITY, agi);
+
+        //delete result;
+    }
+    pet->SetLevel(getLevel());
+    pet->SetFullHealth();
+    if(pet->getPowerType() == POWER_MANA)
+        pet->SetPower(POWER_MANA, pet->GetMaxPower(POWER_MANA));
+
+    m_botHasPet = true;
+    m_botsPet = pet;
+
+    return pet;
+} //end GetBotsPet
+
+void Creature::SetBotsPetDied()
+{
+    if(m_botHasPet && m_botsPet != NULL && m_botsPet->IsInWorld())
+    {
+        m_botsPet->SetCharmerGUID(0);
+        m_botsPet->CombatStop();
+        m_bot_owner->SetMinion((Minion*)m_botsPet, false);
+        m_botsPet->CleanupsBeforeDelete();
+        m_botsPet->AddObjectToRemoveList();
+    }
+    m_botsPet = NULL;
+    m_botHasPet = false;
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    is_a_bot = bot;
+    if (bot == true && m_bot_owner) m_bot_owner_guid = m_bot_owner->GetGUID();
+    if (bot = false)
+    {
+        m_bot_owner = NULL;
+        m_bot_owner_guid = 0;
+        m_Tank = NULL;
+        m_botsPet = NULL;
+        m_botHasPet = false;
+        m_bot_class = 0;
+        m_bot_race = 0;
+        m_bot_form = 0;
+        m_bot_must_wait_for_spell_1 = 0;
+        m_bot_must_wait_for_spell_2 = 0;
+        m_bot_must_wait_for_spell_3 = 0;
+        m_bot_must_be_created = false;
+        m_bot_must_die = false;
+        m_bot_died = false;
+        if (bot_AI)
+            bot_AI = NULL;
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, 0);
+    }
+}
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 6ae9fa9..5802000 100755
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -520,6 +520,8 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         void AI_SendMoveToPacket(float x, float y, float z, uint32 time, uint32 MovementFlags, uint8 type);
         CreatureAI* AI() const { return (CreatureAI*)i_AI; }
 
+        //bool doCast(const SpellInfo * pSpellInfo, Unit *target=NULL, bool checkFirst=true, bool castExistingAura=false, bool skipFriendlyCheck=false, bool skipEquipStanceCheck=false, bool triggered=true);
+
         uint32 GetShieldBlockValue() const                  //dunno mob block value
         {
             return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
@@ -707,6 +709,54 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         uint32 GetGUIDTransport() { return guid_transport; }
 
         void FarTeleportTo(Map* map, float X, float Y, float Z, float O);
+
+        //Bot commands
+        void SetOwner(Player *newowner){ m_bot_owner = newowner; }
+        Player *GetBotOwner() { return m_bot_owner; }
+        uint64 GetBotOwnerGUID() { return m_bot_owner_guid; }
+        void ResetBot()
+        {
+            SetByteValue(UNIT_FIELD_BYTES_0, 0, GetBotRace());
+            SetBotMustWaitForSpell1(0);
+            SetBotMustWaitForSpell2(0);
+            SetBotMustWaitForSpell3(0); //eating and drinking
+            m_botsPet = NULL;
+            m_botHasPet = false;
+            
+        }
+        CreatureAI *GetBotAI(){ return bot_AI; }
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot(){ return is_a_bot; }
+        CommandStates GetBotCommandState() { return m_botCommandState; }
+        void SetBotCommandState(CommandStates st) { m_botCommandState = st; }
+        void SetBotReactState(ReactStates st){ SetReactState(st); }
+        Creature *GetBotsPet (uint32 entry);
+        Creature *getBotsPet() { return m_botsPet; }
+        void SetBotsPetDied();
+        bool m_botHasPet;
+        uint8 GetBotClass(){ return m_bot_class; }
+        uint8 GetBotRace(){ return m_bot_race; }
+        void SetBotMustDie(bool die = true){ m_bot_must_die = die; }
+        bool GetBotMustDie(){ return m_bot_must_die; }
+        void SetBotDied(bool died = true){ m_bot_died = died; }
+        bool GetBotDied(){ return m_bot_died; }
+        uint32 GetBotForm(){ return m_bot_form; }
+        Unit* GetBotTank(){ return m_Tank; }
+        void SetBotTank(Unit* newtank){ m_Tank = newtank; }
+
+        void SetBotClass(uint8 botclass){ m_bot_class = botclass; }
+        void SetBotRace(uint8 botrace){ m_bot_race = botrace; }
+        void SetBotForm(uint32 form){ m_bot_form = form; }
+        void SetBotMustWaitForSpell1(uint32 wait){ m_bot_must_wait_for_spell_1 = wait; }
+        uint32 GetBotMustWaitForSpell1(){ return m_bot_must_wait_for_spell_1; }
+        void SetBotMustWaitForSpell2(uint32 wait){ m_bot_must_wait_for_spell_2 = wait; }
+        uint32 GetBotMustWaitForSpell2(){ return m_bot_must_wait_for_spell_2; }
+        void SetBotMustWaitForSpell3(uint32 wait){ m_bot_must_wait_for_spell_3 = wait; }
+        uint32 GetBotMustWaitForSpell3(){ return m_bot_must_wait_for_spell_3; }
+        void SetBotBaseMana(uint32 val) { m_bot_base_mana = val;}
+        uint32 GetBotBaseMana() { return m_bot_base_mana; }
+        //Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, uint32 team, const CreatureData* data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
@@ -756,6 +806,29 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         bool IsInvisibleDueToDespawn() const;
         bool CanAlwaysSee(WorldObject const* obj) const;
     private:
+        //bot system
+        //TODO: Add hp modifier
+        bool is_a_bot;
+        CreatureAI *bot_AI;
+        Player *m_bot_owner;
+        uint64 m_bot_owner_guid;
+        Creature *m_botsPet;
+        uint8 m_bot_class;
+        uint8 m_bot_race;
+        CommandStates m_botCommandState;
+        Unit* m_Tank;
+
+        bool m_bot_must_be_created;
+        bool m_bot_must_die;
+
+        uint32 m_bot_base_mana;
+        uint32 m_bot_form; //Only for Druid
+        uint32 m_bot_must_wait_for_spell_1; //in ms
+        uint32 m_bot_must_wait_for_spell_2; //in ms
+        uint32 m_bot_must_wait_for_spell_3; //in ms
+        bool m_bot_died;
+        //bot system
+
         //WaypointMovementGenerator vars
         uint32 m_waypointID;
         uint32 m_path_id;
diff --git a/src/server/game/Entities/Creature/GossipDef.h b/src/server/game/Entities/Creature/GossipDef.h
index 5173955..5bdd919 100755
--- a/src/server/game/Entities/Creature/GossipDef.h
+++ b/src/server/game/Entities/Creature/GossipDef.h
@@ -50,6 +50,7 @@ enum Gossip_Option
     GOSSIP_OPTION_UNLEARNPETTALENTS = 17,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_LEARNDUALSPEC     = 18,                   //UNIT_NPC_FLAG_TRAINER             (16) (bonus option for GOSSIP_OPTION_TRAINER)
     GOSSIP_OPTION_OUTDOORPVP        = 19,                   //added by code (option for outdoor pvp creatures)
+    GOSSIP_OPTION_BOT               = 20,                   //PLAYERBOT ADDITION
     GOSSIP_OPTION_MAX
 };
 
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index b17606b..4ae6da4 100755
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -246,6 +246,18 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+//bot
+    Player *playerowner = GetBotOwner();
+    if (isDead() && playerowner && playerowner->HaveBot())
+    {
+        for (uint8 i = 0; i != playerowner->GetMaxNpcBots(); ++i)
+        {
+            Creature *cre = playerowner->GetBotMap()[i].m_creature;
+            if (cre == this) return;// dont unsummon corpse if a bot
+        }
+    }
+//end bot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index d4723cb..9ec3874 100755
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -2158,8 +2158,20 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
-            summon = new Totem(properties, summoner);
-            break;
+         {
+             if(summoner->GetCharmerGUID() && summoner->GetOwnerGUID() && summoner->GetOwnerGUID() == summoner->GetCharmerGUID())
+             {
+                 //If the caster is charmed, assume it is a Bot.  This might not always be
+                 //the case, but oh well.  This will allow the affects of the totem
+                 //(ex healing, stoneskin, etc, to affect the bot owner insteadof the
+                 //bot. Thats ok, the bot is expendable  :-)
+                 summon = new Totem (properties, summoner->GetCharmer());  break;
+             }
+             else
+             {
+                 summon = new Totem (properties, summoner);  break;
+             }
+         }
         case UNIT_MASK_MINION:
             summon = new Minion(properties, summoner);
             break;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 5a9a3d2..d51fcb2 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -75,6 +75,14 @@
 #include <cmath>
 #include "AccountMgr.h"
 
+// Playerbot mod
+//#include "CreatureAIFactory.h"
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
+#define DRINK 66041
+#define EAT 66478
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -511,6 +519,21 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPctN(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1 Apply NpcBotReductionRate
+        if(player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            uint32 XPRate = ConfigMgr::GetIntDefault("Bot.XpReductionPercent", 0);
+            if (XPRate > 100) XPRate = 100;
+            if (XPRate)
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * XPRate;
+                if (ratePct < 10) ratePct = 10;//minimum
+                if (ratePct > 100) ratePct = 100;//maximum
+                if (ratePct <= 100)
+                    xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -631,6 +654,9 @@ UpdateMask Player::updateVisualBits;
 #endif
 Player::Player (WorldSession* session): Unit(), m_achievementMgr(this), m_reputationMgr(this)
 {
+// Playerbot mod
+m_playerbotAI = NULL;
+
 #ifdef _MSC_VER
 #pragma warning(default:4355)
 #endif
@@ -845,6 +871,15 @@ Player::Player (WorldSession* session): Unit(), m_achievementMgr(this), m_reputa
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    //playerbot
+    m_MaxPlayerbots = ConfigMgr::GetIntDefault("Bot.MaxPlayerbots", 9) < 9 ? ConfigMgr::GetIntDefault("Bot.MaxPlayerbots", 9) : 9;
+    //npcbot
+    m_botTimer = 0;
+    m_bot = NULL;
+    m_MaxNpcBots = ConfigMgr::GetIntDefault("Bot.MaxNpcBots", 1) < 10 ? ConfigMgr::GetIntDefault("Bot.MaxNpcBots", 1) : 9;
+    m_MaxClassNpcBots = ConfigMgr::GetIntDefault("Bot.MaxNpcBotsPerClass", 1) < m_MaxNpcBots ? ConfigMgr::GetIntDefault("Bot.MaxNpcBotsPerClass", 1) : m_MaxNpcBots;
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -888,6 +923,12 @@ Player::~Player ()
 
     delete m_declinedname;
     delete m_runes;
+    //Playerbot mod: remove AI if exists
+    if(m_playerbotAI != NULL)
+    {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
 
     sWorld->DecreasePlayerCount();
 }
@@ -1712,6 +1753,18 @@ void Player::Update(uint32 p_time)
         RegenerateAll();
     }
 
+    //want to refresh bot even if we're dead so it can rez me
+    if(HaveBot() || GetBotMustBeCreated() || (m_bot && m_bot->GetBotDied()))
+        RefreshBot(p_time);
+
+    if(m_botTimer > 0)
+    {
+        if(p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+
     if (m_deathState == JUST_DIED)
         KillPlayer();
 
@@ -1799,6 +1852,10 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //Playerbot mod: this was added as part of the Playerbot mod,
+    if(m_playerbotAI != NULL) m_playerbotAI->UpdateAI(p_time);
+
 }
 
 void Player::setDeathState(DeathState s)
@@ -2039,7 +2096,8 @@ void Player::SendTeleportPacket(Position &oldPos)
     WorldPacket data2(MSG_MOVE_TELEPORT, 38);
     data2.append(GetPackGUID());
     BuildMovementPacket(&data2);
-    Relocate(&oldPos);
+    // Relocate(&oldPos);
+    if (!this->IsPlayerbot()) Relocate(&oldPos);
     SendMessageToSet(&data2, false);
 }
 
@@ -2068,6 +2126,14 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         return false;
     }
 
+    //Playerbot mod: if this user has bots, tell them to stop following master
+    //so they don't try to follow the master after the master teleports
+    for(PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+    {
+        Player *botPlayer = itr->second;
+        botPlayer->GetMotionMaster()->Clear();
+    }
+
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
@@ -2421,6 +2487,1033 @@ void Player::RemoveFromWorld()
     }
 }
 
+Player *Player::GetObjPlayer(uint64 guid)
+{
+    return ObjectAccessor::FindPlayer(guid);
+}
+
+void Player::RefreshBot(uint32 diff)
+{
+    if(m_botTimer != 0) return;
+    uint32 refreshDelay = 0;
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = m_botmap[i].m_guid;
+        m_bot = m_botmap[i].m_creature ? m_botmap[i].m_creature : sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL); //itr->second;
+        if (!m_bot || !m_bot->IsInWorld()) continue;
+
+        uint32 Bentry = m_bot->GetEntry();
+        uint8 Brace = m_bot->GetBotRace();
+        uint8 Bclass = m_bot->GetBotClass();
+
+        if((m_bot->GetBotDied() || !m_bot->isAlive()) && isAlive()/* && !isInCombat()*/)
+        {
+            //recreate bot because it died
+            CreateBot(Bentry, Brace, Bclass, true);
+            continue;
+        }
+        //BOT MUST DIE SUPPORT
+        if (m_bot->GetBotMustDie()/* && m_bot->isAlive()*/)//unsummon even if corpse
+        {
+            RemoveBot(m_bot->GetGUID(), true);
+            continue;
+        }
+        if (isInFlight())
+        {
+            RemoveBot(m_bot->GetGUID());
+            continue;
+        }
+
+        if(m_bot->isAlive())
+        {
+            //BOT DEFIBRILLATE SUPPORT FOR DEBUG ONLY (problems with druid's revive)
+            if(isDead() && !m_bot->HasUnitState(UNIT_STAT_CASTING) && !this->isRessurectRequested() && 
+               (m_bot->GetBotClass() != CLASS_PRIEST && 
+                m_bot->GetBotClass() != CLASS_PALADIN/* && 
+                m_bot->GetBotClass() != CLASS_SHAMAN && //temporary removed shaman
+                m_bot->GetBotClass() != CLASS_DRUID*/))  //temporary removed druid
+            {
+                m_bot->Relocate(GetPositionX()+urand(1,2), GetPositionY()+urand(1,2), GetPositionZ());
+                m_bot->AI()->DoCast(this, 54732);//defibrillate
+            }
+
+            //TELEPORT AND CHANGE ZONE/AREA SUPPORT
+            if(!isInFlight())
+            {
+                bool tp = false;
+
+                float maxdist = sWorld->GetMaxVisibleDistanceOnContinents();
+                if(GetMap()->IsDungeon()) maxdist = sWorld->GetMaxVisibleDistanceInInstances();
+                else if(GetMap()->IsBattlegroundOrArena()) maxdist = sWorld->GetMaxVisibleDistanceInBGArenas();
+                maxdist -= 25.0f;
+                if(abs(m_bot->GetPositionX() - GetPositionX()) > maxdist || 
+                abs(m_bot->GetPositionY() - GetPositionY()) > maxdist || 
+                abs(m_bot->GetPositionZ() - GetPositionZ()) > maxdist || 
+                m_bot->GetMapId() != GetMapId())
+                    tp = true;
+
+                //If bot is too far away
+                if(tp)
+                {
+                    RemoveBot(m_bot->GetGUID());
+                    continue;
+                }
+            }
+
+            //FLYING MOUNT SUPPORT
+            if((IsMounted() && HasAuraType(SPELL_AURA_FLY)) || canFly() || IsFlying() || isInFlight())
+            {
+                if(m_bot->GetMountID() != 17759
+                && m_bot->GetMountID() != 17703
+                && m_bot->GetMountID() != 17718
+                && m_bot->GetMountID() != 17720
+                && m_bot->GetMountID() != 17721
+                && m_bot->GetMountID() != 17719)
+                {
+                    int m_mount = 0;
+                    int m_rand = rand()%100;
+                    if (m_rand < 33)      m_mount = 1;
+                    else if (m_rand > 64) m_mount = 2;
+                    else                 m_mount = 3;
+
+                    //support for druid's bird removed
+                    //if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() >= 70)) m_mount = 0;
+                    //if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() >= 70)) m_mount = 0;
+
+                    if(Brace == RACE_HUMAN || Brace == RACE_DWARF || Brace == RACE_NIGHTELF || Brace == RACE_GNOME || Brace == RACE_DRAENEI)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(17759); break;
+                            case 2: m_bot->Mount(17703); break;
+                            case 3: m_bot->Mount(17718); break;
+                            default: break;
+                        }
+                    }
+                    else if(Brace == RACE_ORC || Brace == RACE_UNDEAD_PLAYER || Brace == RACE_TAUREN || Brace == RACE_TROLL || Brace == RACE_BLOODELF)
+                    {
+                        switch(m_mount)
+                        {
+                            case 1: m_bot->Mount(17720); break;
+                            case 2: m_bot->Mount(17721); break;
+                            case 3: m_bot->Mount(17719); break;
+                            default: break;
+                        }
+                    }
+                    //m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_WALK) - 0.1f, true);
+                }
+                if(isInFlight())
+                {
+                    m_bot->SetUnitMovementFlags(MOVEMENTFLAG_FLYING);
+                    m_bot->SetSpeed(MOVE_FLIGHT, GetSpeed(MOVE_FLIGHT) + 0.1f, true);
+                }
+                else
+                {
+                    m_bot->SetUnitMovementFlags(MOVEMENTFLAG_NONE);
+                    m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_RUN) + 0.1f, true);
+                }
+            }
+            //MOUNT SUPPORT
+            else if(IsMounted() && !m_bot->IsMounted())
+            {
+                int m_mount = 0;
+                int m_rand = rand()%100;
+                if (m_rand < 33)      m_mount = 1;
+                else if(m_rand > 64) m_mount = 2;
+                else                 m_mount = 3;
+
+                //if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() < 60)) m_mount = 0;
+                //if((GetBotClass() == CLASS_DRUID) && (m_bot->getLevel() < 60)) m_mount = 0;
+
+                switch(Brace)
+                {
+                    case RACE_HUMAN:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(2409); break;
+                                case 2: m_bot->Mount(2404); break;
+                                case 3: m_bot->Mount(2405); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14338); break;
+                                case 2: m_bot->Mount(14583); break;
+                                case 3: m_bot->Mount(14582); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_ORC:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(247); break;
+                                case 2: m_bot->Mount(2327); break;
+                                case 3: m_bot->Mount(2328); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14575); break;
+                                case 2: m_bot->Mount(14574); break;
+                                case 3: m_bot->Mount(14573); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_DWARF:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(2785); break;
+                                case 2: m_bot->Mount(2786); break;
+                                case 3: m_bot->Mount(2736); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14347); break;
+                                case 2: m_bot->Mount(14576); break;
+                                case 3: m_bot->Mount(14346); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_NIGHTELF:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(6080); break;
+                                case 2: m_bot->Mount(6448); break;
+                                case 3: m_bot->Mount(6444); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14632); break;
+                                case 2: m_bot->Mount(14332); break;
+                                case 3: m_bot->Mount(14331); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_UNDEAD_PLAYER:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(10670); break;
+                                case 2: m_bot->Mount(10671); break;
+                                case 3: m_bot->Mount(10672); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(10721); break;
+                                case 2: m_bot->Mount(10720); break;
+                                case 3: m_bot->Mount(10719); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_TAUREN:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(12246); break;
+                                case 2: m_bot->Mount(11641); break;
+                                case 3: m_bot->Mount(12245); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14579); break;
+                                case 2: m_bot->Mount(14349); break;
+                                case 3: m_bot->Mount(14578); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_GNOME:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(9473); break;
+                                case 2: m_bot->Mount(10661); break;
+                                case 3: m_bot->Mount(6569); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14376); break;
+                                case 2: m_bot->Mount(14374); break;
+                                case 3: m_bot->Mount(14377); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_TROLL:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(6472); break;
+                                case 2: m_bot->Mount(4806); break;
+                                case 3: m_bot->Mount(6473); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(14344); break;
+                                case 2: m_bot->Mount(14339); break;
+                                case 3: m_bot->Mount(14342); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_BLOODELF:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(18696); break;
+                                case 2: m_bot->Mount(19480); break;
+                                case 3: m_bot->Mount(19478); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(19484); break;
+                                case 2: m_bot->Mount(18697); break;
+                                case 3: m_bot->Mount(19482); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                    case RACE_DRAENEI:
+                    {
+                        if(getLevel() < 60)
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(17063); break;
+                                case 2: m_bot->Mount(19870); break;
+                                case 3: m_bot->Mount(19869); break;
+                                default: break;
+                            }
+                        }
+                        else
+                        {
+                            switch(m_mount)
+                            {
+                                case 1: m_bot->Mount(19871); break;
+                                case 2: m_bot->Mount(19872); break;
+                                case 3: m_bot->Mount(19873); break;
+                                default: break;
+                            }
+                        }
+                        break;
+                    }
+                }
+                m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_WALK) - 0.1f, true);
+            }
+            else if(!IsMounted() && m_bot->IsMounted())
+            {
+                m_bot->Unmount();
+                CreatureTemplate const *cinfo = sObjectMgr->GetCreatureTemplate(m_bot->GetEntry());
+                m_bot->SetSpeed(MOVE_RUN, cinfo->speed_run, true);
+                m_bot->SetUnitMovementFlags(MOVEMENTFLAG_NONE);
+            }
+
+            //NON-COMBAT RATIONS SUPPORT
+            //TODO: replace into bot_ai::CheckAuras()...SetStats()
+            //if low on mana, take a drink
+            if((Bclass == CLASS_SHAMAN || Bclass == CLASS_DRUID ||
+                Bclass == CLASS_PRIEST || Bclass == CLASS_MAGE || Bclass == CLASS_HUNTER ||
+                Bclass == CLASS_WARLOCK || Bclass == CLASS_PALADIN) && !m_bot->IsNonMeleeSpellCasted(true))
+            {
+                if(m_bot->GetPower(POWER_MANA)*100/m_bot->GetMaxPower(POWER_MANA) < 80 &&
+                  !m_bot->HasAura(DRINK) &&
+                  m_bot->GetBotMustWaitForSpell3() <= 0 &&
+                  !m_bot->isInCombat())
+                {
+                    m_bot->CastSpell(m_bot, DRINK, true);
+                    m_bot->SetBotMustWaitForSpell3(2000);
+                    m_bot->SetStandState(1);
+                    m_botTimer = 1000; //set longer delay so it wont stand up right away
+                    continue;
+                }
+                //if drinking, have to add additional regen
+                if(m_bot->HasAura(DRINK))
+                {
+                    uint32 addvalue = 0;
+                    //uint32 maxValue = m_bot->GetMaxPower(POWER_MANA);
+                    uint32 maxValue = m_bot->GetBotBaseMana() ? m_bot->GetBotBaseMana() : m_bot->GetMaxPower(POWER_MANA);;
+                    uint32 curValue = m_bot->GetPower(POWER_MANA);
+
+                    if(curValue < m_bot->GetMaxPower(POWER_MANA))
+                    {
+                        addvalue = maxValue/urand(30,60);
+                        m_bot->ModifyPower(POWER_MANA, addvalue);
+                        //continue;
+                    }
+                    else
+                        m_bot->RemoveAurasDueToSpell(DRINK);
+                }
+            }
+
+            if(m_bot->HasAura(DRINK) && m_bot->GetPower(POWER_MANA) >= m_bot->GetMaxPower(POWER_MANA))
+                m_bot->RemoveAurasDueToSpell(DRINK);
+
+            //eat
+            if(m_bot->GetHealth()*100 / m_bot->GetMaxHealth() < 80 &&
+               !m_bot->HasAura(EAT) &&
+               m_bot->GetBotMustWaitForSpell3() <= 0 &&
+               !m_bot->isInCombat())
+            {
+                m_bot->SetBotMustWaitForSpell3(2000);
+                m_bot->CastSpell(m_bot, EAT, true);
+                m_bot->SetStandState(1);
+                m_botTimer = 1000; //set longer delay so it wont stand up right away
+                continue;
+            }
+
+            //if eating, have to regen additional amount
+            if(m_bot->HasAura(EAT))
+            {
+                uint32 addvalue = 0;
+                uint32 maxValue = m_bot->GetMaxHealth();
+                uint32 curValue = m_bot->GetHealth();
+
+                if(curValue < maxValue)
+                {
+                    addvalue = maxValue/urand(70,100);
+                    m_bot->SetHealth(curValue + addvalue);
+                    //continue;
+                }
+                else
+                    m_bot->RemoveAurasDueToSpell(EAT);
+            }
+
+            if(m_bot->GetHealth() >= m_bot->GetMaxHealth() && m_bot->HasAura(EAT))
+                m_bot->RemoveAurasDueToSpell(EAT);
+
+            //if bot stands up for some reason, ie goes into combat,
+            //remove the food and drink affect
+            if(m_bot->isInCombat()/* || m_bot->IsStopped()/* || m_bot->IsStandState()*/)
+            {
+                if(m_bot->HasAura(EAT)) m_bot->RemoveAurasDueToSpell(EAT);
+                if(m_bot->HasAura(DRINK)) m_bot->RemoveAurasDueToSpell(DRINK);
+            }
+
+            //if done drinking and eating, stand up
+            if(getStandState() == UNIT_STAND_STATE_STAND && 
+                m_bot->getStandState() == UNIT_STAND_STATE_SIT && 
+                !m_bot->HasAura(DRINK) && !m_bot->HasAura(EAT))
+                m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+            if (getStandState() == UNIT_STAND_STATE_SIT || (m_bot->HasAura(EAT) || m_bot->HasAura(DRINK)))
+                m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+            else 
+                m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+
+            //SPELL AI CUSTOM SUPPORT
+            //CURRENTLY DISABLED
+            /*switch(GetBotClass())
+            {
+                case CLASS_DRUID: //DRUID FORM SUPPORT
+                {
+                    if(!m_bot->isAlive()) break;
+
+                    CreatureTemplate const *cinfo = sObjectMgr->GetCreatureTemplate(m_bot->GetEntry());
+
+                    uint32 m_old_bot_form = m_bot->GetDisplayId();
+                    if((IsMounted() && HasAuraType(SPELL_AURA_FLY)) || canFly() || IsFlying() || isInFlight())
+                    {
+                        //flight form
+                        if((((IsMounted()) && (m_bot->getLevel() >= 70)) || (GetShapeshiftForm() == FORM_FLIGHT) || (GetShapeshiftForm() == FORM_FLIGHT_EPIC)))
+                        {
+                            if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 21243))
+                                m_bot->SetDisplayId(21243);
+                            if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 21244))
+                                m_bot->SetDisplayId(21244);
+                            m_bot->Unmount();
+                            SetBotForm(m_bot->GetDisplayId());
+                            SetBotMustWaitForSpell1(3000);
+                        }
+                    }
+                    else if((GetBotMustWaitForSpell1() == 0) && (m_bot->IsInWater()) && (!isInFlight()))
+                    {
+                        //Removed this because it turns into a seal in Booty Bay
+                        //seal form
+    /*
+                        if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 2428))
+                            m_bot->SetDisplayId(2428);
+                        if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 2428))
+                            m_bot->SetDisplayId(2428);
+                        SetBotForm(m_bot->GetDisplayId());
+                        SetBotMustWaitForSpell1(3000);
+    *//*
+                    }
+                    else if((GetBotMustWaitForSpell1() == 0) && (m_bot->isInCombat()) && (!m_bot->isInFlight()))
+                    {
+                        //combat form is now handled in AI
+                    }
+                    else if((GetBotMustWaitForSpell1() == 0) && (((IsMounted()) && (m_bot->getLevel() < 60)) || (GetShapeshiftForm() == FORM_TRAVEL)) && (!m_bot->isInFlight()))
+                    {
+                        //travel form
+                        if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 632))
+                            m_bot->SetDisplayId(632);
+                        if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 632))
+                            m_bot->SetDisplayId(632);
+                        SetBotForm(m_bot->GetDisplayId());
+                        SetBotMustWaitForSpell1(3000);
+                    }
+                    else if((GetBotMustWaitForSpell1() == 0) && (GetShapeshiftForm() == FORM_CAT) && (!m_bot->isInFlight()))
+                    {
+                        //cat form
+                        if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 892))
+                            m_bot->SetDisplayId(892);
+                        if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 8571))
+                            m_bot->SetDisplayId(8571);
+                        SetBotForm(m_bot->GetDisplayId());
+                        //SetBotMustWaitForSpell1(3000);
+                    }
+                    else if((GetBotMustWaitForSpell1() == 0) && (GetShapeshiftForm() == FORM_BEAR) && (!m_bot->isInFlight()))
+                    {
+                        //bear form
+                        if((GetBotRace() == RACE_NIGHTELF) && (m_bot->GetDisplayId() != 2281)) m_bot->SetDisplayId(2281);
+                        if((GetBotRace() == RACE_TAUREN) && (m_bot->GetDisplayId() != 2289)) m_bot->SetDisplayId(2289);
+                        SetBotForm(m_bot->GetDisplayId());
+                        //SetBotMustWaitForSpell1(3000);
+                    }
+
+                    if(m_old_bot_form != GetBotForm())
+                    {
+                        //change stats based on forms
+                        m_bot->SetSpeed(MOVE_SWIM, cinfo->speed_run, true); m_bot->SetSpeed(MOVE_RUN, cinfo->speed_run, true);
+                        if(GetBotForm() == 2428)
+                            m_bot->SetSpeed(MOVE_SWIM, cinfo->speed_run * 1.50f, true);
+                        else if(GetBotForm() == 632) //travel form
+                        {
+                            //m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_WALK) , true);
+                            m_bot->SetSpeed(MOVE_RUN, GetSpeed(MOVE_RUN) - 0.1f, true);
+                        }
+
+                    }
+
+                    //RESET FORMS
+                    if((!m_bot->isInFlight()) && (!m_bot->IsInWater())  &&  (!m_bot->isInCombat())  && (!IsMounted()) && (GetShapeshiftForm() != FORM_TRAVEL) && (GetShapeshiftForm() != FORM_CAT))
+                    {
+                        //don't reset if bear or cat because it costs too much mana
+                        if(m_bot->HasAura(9634) ||
+                            m_bot->HasAura(768) ||
+                            m_bot->HasAura(16591))
+                            return;
+
+                        if((GetBotRace() == 4) && (m_bot->GetDisplayId() != cinfo->Modelid1))
+                            m_bot->SetDisplayId(cinfo->Modelid1);
+                        if((GetBotRace() == 6) && (m_bot->GetDisplayId() != cinfo->Modelid3))
+                            m_bot->SetDisplayId(cinfo->Modelid3);
+                        m_bot->SetSpeed(MOVE_SWIM, cinfo->speed_run, true);
+                        m_bot->SetSpeed(MOVE_RUN, cinfo->speed_run, true);
+                        SetBotForm(m_bot->GetDisplayId());
+                    }
+
+                    //SPECIAL SPELL FOR DRUID
+                    SetBotForm(m_bot->GetDisplayId());
+                    break;
+                }
+
+            }//END SWITCH*/
+
+            /*if (!m_bot->getVictim() && !m_bot->SelectVictim() && 
+                GetBotCommandState() != COMMAND_STAY &&
+                GetDistance(m_bot) > 50 &&
+                !IsBeingTeleported())
+            {
+                m_bot->Relocate(this);
+                SetBotCommandState(COMMAND_FOLLOW);
+            }*/
+        }//end if m_bot->isAlive()
+
+        //randomize next update time for bots (make average 10-11)
+        if (m_bot->GetBotMustWaitForSpell1() > 0) m_bot->SetBotMustWaitForSpell1(m_bot->GetBotMustWaitForSpell1() - refreshDelay > 0 ? refreshDelay : 10);
+        if (m_bot->GetBotMustWaitForSpell2() > 0) m_bot->SetBotMustWaitForSpell2(m_bot->GetBotMustWaitForSpell2() - refreshDelay > 0 ? refreshDelay : 10);
+        if (m_bot->GetBotMustWaitForSpell3() > 0) m_bot->SetBotMustWaitForSpell3(m_bot->GetBotMustWaitForSpell3() - refreshDelay > 0 ? refreshDelay : 10);
+        m_bot = NULL;
+    }//end for botmap
+    m_botTimer = refreshDelay;
+
+    if(!isInFlight() && GetBotMustBeCreated() && isAlive())
+    {
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        {
+            uint32 Bentry = 0;
+            uint8 Brace = 0;
+            uint8 Bclass = 0;
+            if (m_botmap[pos].m_entry != 0 && m_botmap[pos].m_guid == 0)
+            {
+                Bentry = m_botmap[pos].m_entry;
+                Brace = m_botmap[pos].m_race;
+                Bclass = m_botmap[pos].m_class;
+                CreateBot(Bentry, Brace, Bclass);
+            }
+        }
+    }
+} //end Player::RefreshBot
+
+void Player::SetBotMustDie(uint64 guid)
+{
+    m_bot = NULL;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i].m_guid == guid)
+            m_bot = m_botmap[i].m_creature;
+        if (!m_bot)
+            m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+        if (m_bot && m_bot->GetBotOwnerGUID() == GetGUID())
+            m_bot->SetBotMustDie();
+        break;
+    }
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos].m_entry == 0)
+        {
+            m_botmap[pos].m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos].m_entry = m_entry;
+            m_botmap[pos].m_race = m_race;
+            m_botmap[pos].m_class = m_class;
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos].m_guid == 0 && 
+            (m_botmap[pos].m_entry != 0 || 
+            m_botmap[pos].m_race != 0 || 
+            m_botmap[pos].m_class != 0))
+            return true;
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(uint64 value, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos].m_guid == value) || 
+            (guid == false && pos == value) || 
+            fully)
+        {
+            m_botmap[pos].m_guid = 0;
+            m_botmap[pos].m_entry = 0;
+            m_botmap[pos].m_race = 0;
+            m_botmap[pos].m_class = 0;
+            m_botmap[pos].m_creature = NULL;
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
+{
+    if (!guid) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_guid == guid)
+            m_bot = m_botmap[i].m_creature;
+    if (!m_bot)
+        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+    if (m_bot)
+    {
+        if(m_bot->m_botHasPet)
+            m_bot->SetBotsPetDied();
+
+        uint32 guidlow = m_bot->GetGUIDLow();
+        Group *gr = GetGroup();
+        if (gr && gr->IsMember(guid) && (gr->GetMembersCount() > 2 || !GetMap()->Instanceable() || final))//will remove from group anyway unless in instance and not forced (trying to avoid ("unknowns"))
+            gr->RemoveMember(guid);
+        m_bot->SetCharmerGUID(0);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->RemoveFromWorld();
+
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->SetIAmABot(false); //this HAS to come after CleanupsBeforeDelete
+        m_bot->AddObjectToRemoveList();
+
+        if (final)
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)
+                CharacterDatabase.PExecute("DELETE FROM character_npcbot WHERE owner = '%u' AND guid = '%u'", GetGUIDLow(), guidlow);
+        }
+        else
+        {
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos].m_guid == guid)
+                {
+                    m_botmap[pos].m_guid = 0;//reset guid so it can be set during recreation
+                    m_botmap[pos].m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+} //end RemoveBot
+
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive)
+{
+    if(IsBeingTeleported() || isInFlight()) return; //don't create bot yet
+    if(isDead() && !revive) return; //not to revive by command so abort
+
+    //if (this->isInCombat() || this->isDead()) return; //removed for now
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(m_bot->GetMaxHealth()*5/100);//5% at revive
+        if(m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetMaxPower(POWER_MANA)*20/100);
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotDied(false);
+        m_bot->AI()->Reset();
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        sLog->outError("ERROR! Player::CreateBot() trying to create bot with entry = %u, race = %u, class = %u, ignored", botentry, botrace, botclass);
+        return;
+    }
+
+    if (GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(this);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos].m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    //check if we have free slot
+    bool place = false;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos].m_entry == botentry && m_botmap[pos].m_guid == 0)
+        {
+            place = true;
+            break;
+        }
+    if (!place)
+    {
+        sLog->outError("character %u is trying to create bot off limits! Removing all bots", GetGUID());
+        ClearBotMustBeCreated(0, false, true);
+    }
+
+    m_bot = SummonCreature(botentry, GetPositionX()-2, GetPositionY()-2, GetPositionZ(), GetOrientation(), TEMPSUMMON_MANUAL_DESPAWN, 0);
+
+    m_bot->SetBotClass(botclass);
+    m_bot->SetBotRace(botrace);
+    m_bot->SetCharmerGUID(GetGUID());
+    m_bot->SetOwner(this);
+    m_bot->SetIAmABot(true);
+    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AIM_Initialize();
+
+    m_bot->SetBotReactState(REACT_PASSIVE); //may be removed as not changes anything (customly scripted)
+//insert
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos].m_entry == botentry && m_botmap[pos].m_guid == 0)
+        {
+            m_botmap[pos].m_guid = m_bot->GetGUID();
+            m_botmap[pos].m_creature = m_bot;//this will save some time but we need guid as well
+            break;
+        }
+    }
+//insert
+    //If we have a group, just add bot
+    if(GetGroup())
+    {
+        Group *m_group = GetGroup();
+        if (m_group && !m_group->IsFull())
+            m_group->AddMember(reinterpret_cast<Player*>(m_bot));
+        else
+        {
+            m_bot->SetBotMustDie();
+            return;
+        }
+    }
+    else
+    {
+        Group *m_group = new Group;
+        if (!m_group->Create(this))
+        {
+            delete m_group;
+            return;
+        }
+        sGroupMgr->AddGroup(m_group);
+
+        if(!m_group->IsFull()) m_group->AddMember(reinterpret_cast<Player*>(m_bot));
+    }
+    m_bot->SetBotMustDie(false);
+
+    Group::MemberSlotList const &a = GetGroup()->GetMemberSlots();
+    if(!GetGroup() || a.empty())
+    {
+        m_bot->SetBotMustDie();
+        return;
+    }
+
+    m_bot->ResetBot();//reset cd's and pets, also set race
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    if (m_bot->GetBotAI())//its set automaticly due AIM_Initialize();
+        m_bot->GetBotAI()->JustRespawned();
+    m_bot->AI()->Reset();
+    //entry is unique for each master's bot so clean it up just in case 
+    CharacterDatabase.PExecute("DELETE FROM character_npcbot WHERE owner = '%u' AND entry = '%u'", GetGUIDLow(), botentry);
+    //add the new entry
+    CharacterDatabase.PExecute("INSERT INTO character_npcbot (guid,owner,entry,race,class) VALUES ('%u','%u','%u','%u','%u')", m_bot->GetGUIDLow(), GetGUIDLow(), m_bot->GetEntry(), m_bot->GetBotRace(), m_bot->GetBotClass());
+} //end Player::CreateBot
+
+uint8 Player::GetMaxNpcBots()
+{
+    return m_MaxNpcBots ? m_MaxNpcBots : ConfigMgr::GetIntDefault("Bot.MaxNpcBots", 1);
+}
+bool Player::HaveBot()
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_entry != 0)
+            return true;
+    return false;
+}
+Creature *Player::GetBot(uint64 guid)
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_guid == guid)
+            return m_botmap[i].m_creature;
+    return NULL;
+}
+//finds bot's slot into master's botmap
+uint8 Player::GetNpcBotSlot(uint64 guid)
+{
+    if (!guid) return 0;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_guid == guid)
+            return i;
+    return 0;
+}
+//Problematic function, returns max for some reason (maybe)
+uint8 Player::GetNpcBotsCount()
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos].m_guid != 0)
+            ++bots;
+    return bots;
+}
+NpcBotMap *Player::GetBotMap()
+{
+    return m_botmap;
+}
+//This is called from script_bot_giver.cpp
+void Player::CreatePlayerBot(std::string name)
+{
+    uint64 guid = sObjectMgr->GetPlayerGUIDByName(name.c_str());
+    if(m_session->GetPlayerBot(guid) != NULL) return;
+    m_session->AddPlayerBot(guid);
+}
+//This is called from script_bot_giver.cpp
+std::list<std::string> *Player::GetCharacterList()
+{
+    std::string plName;
+    QueryResult results;
+
+    results = CharacterDatabase.PQuery("SELECT name FROM characters WHERE account='%u' AND online=0", m_session->GetAccountId());
+
+    if(!results) return NULL;
+
+    plName = (*results)[0].GetString();
+
+    std::list<std::string> *names = new std::list<std::string>;
+    do
+    {
+        Field *fields = results->Fetch();
+        plName = fields[0].GetString();
+        if(plName.compare(GetName()) == 0) continue;
+        names->insert(names->end(), fields[0].GetString());
+    } while(results->NextRow());
+    return names;
+}
+void Player::SetPlayerbotAI(PlayerbotAI *ai)
+{
+    if(ai == NULL)
+    {
+        sLog->outError("Tried to assign playerbot AI to NULL; this is not supported!");
+        return;
+    }
+    if(GetPlayerbotAI() != NULL)
+    {
+        sLog->outError("Tried to reassign playerbot AI; this is not yet supported!");
+        return;
+    }
+    //assigning bot AI to normal players is not currently supported
+    if(!IsPlayerbot())
+    {
+        sLog->outError("Tried to set playerbot AI for a player that was not a bot.");
+        return;
+    }
+    m_playerbotAI = ai;
+
+    m_SaveOrgLocation = ConfigMgr::GetIntDefault("Bot.SaveOrgLocation", 0);
+}
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    if(HaveBot() && !isGameMaster())//do not allow multiple playerbots unless is gamemaster (for development support)
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i].m_class == bot_class)
+                ++count;
+        if(count >= m_MaxClassNpcBots)
+        {
+            ChatHandler ch(this);
+            ch.PSendSysMessage("You cannot have more bots of that class! Max: %u", m_MaxClassNpcBots);
+            return;
+        }
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    QueryResult result;
+
+    //may be we should remove team check? ;
+    if(this->GetTeam() == ALLIANCE)
+    {
+        if(bot_class == CLASS_ROGUE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='rogue_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_PRIEST) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='priest_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_DRUID) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='druid_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_SHAMAN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='shaman_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_MAGE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='mage_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_WARLOCK) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warlock_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_WARRIOR) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warrior_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_PALADIN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='paladin_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if(bot_class == CLASS_HUNTER) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='hunter_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='script_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+    }
+    else if(this->GetTeam() == HORDE)
+    {
+        if(bot_class == CLASS_ROGUE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='rogue_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_PRIEST) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='priest_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_SHAMAN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='shaman_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_MAGE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='mage_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_WARLOCK) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warlock_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_WARRIOR) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warrior_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_DRUID) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='druid_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_PALADIN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='paladin_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if(bot_class == CLASS_HUNTER) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='hunter_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='script_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+    }
+
+    //randomly select one of NPCs
+    if(result)
+    {
+        uint64 m_rand = urand(1, result->GetRowCount());
+        uint64 tmp_rand = 0;
+        do
+        {
+            Field *fields = result->Fetch();
+            entry = fields[0].GetUInt32();
+            bot_race = fields[1].GetUInt32();
+            ++tmp_rand;
+            if(tmp_rand == m_rand)
+                break;
+        } while(result->NextRow());
+       // delete result;
+    }
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i].m_entry == entry)//do not allow duplicates on every single char
+        {
+            ChatHandler ch(this);
+            ch.PSendSysMessage("OOPs! You've rolled duplicate bot! maybe you should try again?");
+            return;
+        }
+    }
+    SetBotMustBeCreated(entry, bot_race, bot_class);
+} //end CreateNPCBot
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2707,7 +3800,7 @@ Creature* Player::GetNPCIfCanInteractWith(uint64 guid, uint32 npcflagmask)
                     return NULL;
 
     // not too far
-    if (!creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+    if (!creature->IsWithinDistInMap(this,INTERACTION_DISTANCE) && !IsPlayerbot())
         return NULL;
 
     return creature;
@@ -2896,6 +3989,47 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+         Player *_player = ObjectAccessor::FindPlayer(guid);
+ 
+         if(_player!=NULL) {
+             WorldSession *session= _player->GetSession();
+             // Playerbot mod: if you remove yourself from a group, log out all playerbots
+ 
+             //save the map of playerbots first because if the map gets altered when
+             //a playerbot logs out which will corrupt the for loop
+             PlayerBotMap m_playerBots;
+             for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+             {
+                 Player *bot = itr->second;
+                 (m_playerBots)[itr->first] = bot;
+             }
+             for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+             {
+                 Player *botPlayer = itr2->second;
+                 if (!botPlayer) continue;
+ 
+                 session->LogoutPlayerBot(botPlayer->GetGUID(),true);
+             }
+
+             //remove npcbots
+             if(_player->HaveBot())
+             {
+                 uint8 players = 0;
+                 for(Group::MemberSlotList::const_iterator itr = group->GetMemberSlots().begin(); itr != group->GetMemberSlots().end(); ++itr)
+                     if (IS_PLAYER_GUID(itr->guid))
+                            ++players;
+                 bool remove = (players <= 1);
+                 for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+                 {
+                     uint64 guid = _player->m_botmap[i].m_guid;
+                     if (guid != 0)
+                         _player->RemoveBot(guid, remove);
+                 }
+             }
+             if (!ObjectAccessor::FindPlayer(guid)->GetGroup() || group->GetMembersCount()==0) return;
+         }
+ 
+
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -7107,6 +8241,10 @@ bool Player::RewardHonor(Unit* uVictim, uint32 groupsize, int32 honor, bool pvpt
         {
             Player* pVictim = uVictim->ToPlayer();
 
+            if(pVictim->IsPlayerbot() && (!ConfigMgr::GetBoolDefault("Bot.HonorFromPlayerbots", false) ||
+                pVictim->GetPlayerbotAI()->GetClassAI()->GetMaster() == this)) //Killing your own playerbots is not honorable!
+                return false;
+
             if (GetTeam() == pVictim->GetTeam() && !sWorld->IsFFAPvPRealm())
                 return false;
 
@@ -15786,6 +16924,9 @@ void Player::KilledMonsterCredit(uint32 entry, uint64 guid)
             }
         }
     }
+
+    //Playerbot mod
+    if(m_playerbotAI != NULL) m_playerbotAI->KilledMonster(entry, guid);
 }
 
 void Player::KilledPlayerCredit()
@@ -15951,6 +17092,7 @@ void Player::TalkedToCreature(uint32 entry, uint64 guid)
                             m_QuestStatusSave[questid] = true;
 
                             SendQuestUpdateAddCreatureOrGo(qInfo, guid, j, curTalkCount, addTalkCount);
+                            if (IsPlayerbot()) this->GetPlayerbotAI()->TellMaster("Talked to quest guy.");
                         }
                         if (CanCompleteQuest(questid))
                             CompleteQuest(questid);
@@ -18377,6 +19519,18 @@ void Player::SaveToDB(bool create /*=false*/)
 
         if (!IsBeingTeleported())
         {
+            if (IsPlayerbot() && m_SaveOrgLocation == 1)
+            {
+                stmt->setUInt16(index++, (uint16)m_playerbotAI->GetStartMapID());
+                stmt->setUInt32(index++, (uint32)m_playerbotAI->GetStartInstanceID());
+                stmt->setUInt8(index++, (uint8)m_playerbotAI->GetStartDifficulty());
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartX()));
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartY()));
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartZ()));
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartO()));
+            }
+            else
+            {
             stmt->setUInt16(index++, (uint16)GetMapId());
             stmt->setUInt32(index++, (uint32)GetInstanceId());
             stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
@@ -18384,9 +19538,22 @@ void Player::SaveToDB(bool create /*=false*/)
             stmt->setFloat(index++, finiteAlways(GetPositionY()));
             stmt->setFloat(index++, finiteAlways(GetPositionZ()));
             stmt->setFloat(index++, finiteAlways(GetOrientation()));
+            }
         }
         else
         {
+            if (IsPlayerbot() && m_SaveOrgLocation == 1)
+            {
+                stmt->setUInt16(index++, (uint16)m_playerbotAI->GetStartMapID());
+                stmt->setUInt32(index++, (uint32)m_playerbotAI->GetStartInstanceID());
+                stmt->setUInt8(index++, (uint8)m_playerbotAI->GetStartDifficulty());
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartX()));
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartY()));
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartZ()));
+                stmt->setFloat(index++, finiteAlways(m_playerbotAI->GetStartO()));
+            }
+            else
+            {
             stmt->setUInt16(index++, (uint16)GetTeleportDest().GetMapId());
             stmt->setUInt32(index++, (uint32)0);
             stmt->setUInt8(index++, (uint8(GetDungeonDifficulty()) | uint8(GetRaidDifficulty()) << 4));
@@ -18394,6 +19561,7 @@ void Player::SaveToDB(bool create /*=false*/)
             stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionY()));
             stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetPositionZ()));
             stmt->setFloat(index++, finiteAlways(GetTeleportDest().GetOrientation()));
+            }
         }
 
         std::ostringstream ss;
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 2b84a11..78122cf 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -55,6 +55,9 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+//Playerbot mod
+class PlayerbotAI;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2527,6 +2530,37 @@ class Player : public Unit, public GridObject<Player>
             //! TODO: Need a proper calculation for collision height when mounted
         }
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        //PlayerBot
+        void SetPlayerbotAI(PlayerbotAI *ai);
+        PlayerbotAI *GetPlayerbotAI(){ return m_playerbotAI; }
+        bool IsPlayerbot(){ return(GetSession()->GetRemoteAddress() == "bot"); }
+        void CreatePlayerBot(std::string name);
+        uint8 GetMaxPlayerBot(){ return m_MaxPlayerbots; }
+        std::list<std::string> *GetCharacterList();
+        //npcbot
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        uint8 GetNpcBotSlot(uint64 guid);
+        bool HaveBot();
+        Player *GetObjPlayer(uint64 guid);
+        Creature *GetBot(uint64 guid);
+        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature *cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount();
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class);
+        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        void SetBotMustDie(uint64 guid);
+        NpcBotMap *GetBotMap();
+        uint8 GetMaxNpcBots();
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2785,6 +2819,24 @@ class Player : public Unit, public GridObject<Player>
         uint8 m_grantableLevels;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+
+        //Playerbot mod
+        PlayerbotAI *m_playerbotAI;
+        uint8 m_MaxPlayerbots;
+        uint8 m_SaveOrgLocation;
+        //npcbot
+        Creature *m_bot;
+        uint8 m_MaxNpcBots;
+        uint8 m_MaxClassNpcBots;
+        uint32 m_botTimer;
+        NpcBotMap m_botmap[9];
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 3b5b210..6e54b53 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -10861,7 +10861,9 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
 {
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
-    if (IS_CREATURE_GUID(GetGUID()) && !(isTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+    if (IS_CREATURE_GUID(GetGUID()) && !(isTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438
+        && !(GetCharmerGUID() && GetOwnerGUID() && GetOwnerGUID() == GetCharmerGUID()))
+        //Owned and charmed by same player means bot (need proof) : allow bots to crit
         return false;
 
     // not critting spell
@@ -12189,11 +12191,16 @@ bool Unit::_IsValidAttackTarget(Unit const* target, SpellInfo const* bySpell) co
             return false;
     }
     // check flags
-    if (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_TAXI_FLIGHT | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_UNK_16)
+    if ((target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE | UNIT_FLAG_TAXI_FLIGHT | UNIT_FLAG_NOT_ATTACKABLE_1 | UNIT_FLAG_UNK_16)
         || (!HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE))
         || (!target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PASSIVE))
         || (HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE))
         || (target->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE) && HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_OOC_NOT_ATTACKABLE)))
+        //exception for bots (they are passive as charmed units)
+        && //allow bots attack
+        !((GetCharmerGUID() && GetOwnerGUID() && GetOwnerGUID() == GetCharmerGUID()) 
+        || //allow attack bots
+        (target->GetCharmerGUID() && target->GetOwnerGUID() && target->GetOwnerGUID() == target->GetCharmerGUID())))
         return false;
 
     // CvC case - can attack each other only when one of them is hostile
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 4e15920..963421c 100755
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -254,7 +254,7 @@ bool SpellClickInfo::IsFitToRequirements(Unit const* clicker, Unit const* clicke
 ObjectMgr::ObjectMgr(): m_auctionid(1), m_equipmentSetGuid(1),
     m_ItemTextId(1), m_mailid(1), m_hiPetNumber(1), m_hiCharGuid(1),
     m_hiCreatureGuid(1), m_hiPetGuid(1), m_hiVehicleGuid(1), m_hiItemGuid(1),
-    m_hiGoGuid(1), m_hiDoGuid(1), m_hiCorpseGuid(1), m_hiMoTransGuid(1)
+    m_hiGoGuid(1), m_hiDoGuid(1), m_hiCorpseGuid(1), m_hiMoTransGuid(1), m_hiGroupGuid(1)
 {}
 
 ObjectMgr::~ObjectMgr()
@@ -6200,6 +6200,8 @@ void ObjectMgr::SetHighestGuids()
     result = CharacterDatabase.Query("SELECT MAX(guid) FROM groups");
     if (result)
         sGroupMgr->SetGroupDbStoreSize((*result)[0].GetUInt32()+1);
+    if (result)
+        m_hiGroupGuid = (*result)[0].GetUInt32()+1;
 }
 
 uint32 ObjectMgr::GenerateAuctionID()
@@ -6292,6 +6294,13 @@ uint32 ObjectMgr::GenerateLowGuid(HighGuid guidhigh)
                 World::StopNow(ERROR_EXIT_CODE);
             }
             return m_hiDoGuid++;
+        case HIGHGUID_GROUP:
+            if (m_hiGroupGuid >= 0xFFFFFFFE)
+            {
+                sLog->outError("Group guid overflow!! Can't continue, shutting down server. ");
+                World::StopNow(ERROR_EXIT_CODE);
+            }
+            return m_hiGroupGuid++;
         case HIGHGUID_MO_TRANSPORT:
             if (m_hiMoTransGuid >= 0xFFFFFFFE)
             {
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 88c593a..93fddd2 100755
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -1209,6 +1209,7 @@ class ObjectMgr
         uint32 m_hiDoGuid;
         uint32 m_hiCorpseGuid;
         uint32 m_hiMoTransGuid;
+        uint32 m_hiGroupGuid;
 
         QuestMap            mQuestTemplates;
 
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 11175b1..6816d71 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -34,6 +34,10 @@
 #include "MapInstanced.h"
 #include "Util.h"
 #include "LFGMgr.h"
+//Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
@@ -107,6 +111,12 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //if leader has playerbots check config
+    if (!leader->GetSession()->m_playerBots.empty())
+        m_lootMethod = (LootMethod)ConfigMgr::GetIntDefault("Bot.LootMethod", 0);
+    else if (leader->HaveBot())//no playerbots but npcbots so set to free-for-all
+        m_lootMethod = FREE_FOR_ALL;
+    else //default
     m_lootMethod = GROUP_LOOT;
     m_lootThreshold = ITEM_QUALITY_UNCOMMON;
     m_looterGuid = leaderGuid;
@@ -309,6 +319,12 @@ bool Group::AddMember(Player* player)
             return false;
     }
 
+     if (IsFull())
+        return false;
+
+    if (!player->GetGUID())
+        return false;
+
     MemberSlot member;
     member.guid      = player->GetGUID();
     member.name      = player->GetName();
@@ -319,7 +335,7 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
-    if (player)
+    if (player && IS_PLAYER_GUID(player->GetGUID()))
     {
         player->SetGroupInvite(NULL);
         if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
@@ -349,7 +365,7 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
-    if (player)
+    if (player && IS_PLAYER_GUID(player->GetGUID()))
     {
         if (!IsLeader(player->GetGUID()) && !isBGGroup())
         {
@@ -390,6 +406,49 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOV
 {
     BroadcastGroupUpdate();
 
+      {
+         Player *player = ObjectAccessor::FindPlayer(guid);
+ 
+         if(player)
+         {
+             //Log out any Playerbots by the player
+             WorldSession *session = player->GetSession();
+ 
+             //save the map of playerbots first because if the map gets altered when
+             //a playerbot logs out which will corrupt the for loop
+             PlayerBotMap m_playerBots;
+             for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+             {
+                 Player *bot = itr->second;
+                 (m_playerBots)[itr->first] = bot;
+             }
+ 
+             //now log out any playerbots it may have
+             for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+             {
+                 Player *bot = itr2->second;
+                 session->LogoutPlayerBot(bot->GetGUID(),true);
+             }
+
+             //Remove any npcbots (allow recreate if not alone if the group)
+             if(player->HaveBot())
+             { 
+                 //if only one non-playerbot then remove npcbots
+                 uint8 players = 0;
+                 for(MemberSlotList::const_iterator itr = GetMemberSlots().begin(); itr != GetMemberSlots().end(); ++itr)
+                     if (IS_PLAYER_GUID(itr->guid))
+                            ++players;
+                 bool remove = (players <= 1);
+                 for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                 {
+                     uint64 guid = player->GetBotMap()[i].m_guid;
+                     if (guid != 0)
+                         player->RemoveBot(guid, remove);
+                 }
+             }
+         }
+     }
+
     sScriptMgr->OnGroupRemoveMember(this, guid, method, kicker, reason);
 
     // LFG group vote kick handled in scripts
@@ -433,12 +492,23 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOV
 
             _homebindIfInstance(player);
         }
+        else if(!player && method == 99)//not a valid player and method == 99 mean I'm a bot
+        {
+            RemoveMember(guid);
+            SendUpdate();
+        }
+        else if(!IS_PLAYER_GUID(guid))
+        {
+            CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", guid);
+            SendUpdate();
+        }
 
         // Remove player from group in DB
         CharacterDatabase.PExecute("DELETE FROM group_member WHERE memberGuid=%u", GUID_LOPART(guid));
 
         // Reevaluate group enchanter if the leaving player had enchanting skill or the player is offline
         if ((player && player->GetSkillValue(SKILL_ENCHANTING)) || !player)
+        if (ObjectAccessor::FindPlayer(guid)) SendUpdate();
             ResetMaxEnchantingLevel();
 
         // Remove player from loot rolls
@@ -1140,6 +1210,34 @@ void Group::CountTheRoll(Rolls::iterator rollI, uint32 NumberOfPlayers)
     delete roll;
 }
 
+//
+// Bot changes
+//
+uint64 Group::GetTargetWithIconByGroup(uint64 guid)
+{
+  //  if (icon >= TARGETICONCOUNT) return 0;
+
+    uint64 targetGUID = 0;
+
+    switch(GetMemberGroup(guid))
+    {
+    case 0: targetGUID = m_targetIcons[STAR]; break;
+    case 1: targetGUID = m_targetIcons[CIRCLE]; break;
+    case 2: targetGUID = m_targetIcons[DIAMOND]; break;
+    case 3: targetGUID = m_targetIcons[TRIANGLE]; break;
+    case 4: targetGUID = m_targetIcons[MOON]; break;
+    case 5: targetGUID = m_targetIcons[SQUARE]; break;
+    case 6: targetGUID = m_targetIcons[CROSS]; break;
+    default: break;
+    }
+
+    // if no target icon, default to star
+    if (targetGUID==0) m_targetIcons[STAR];
+
+   return targetGUID;
+} // end getTargetWithIcon
+
+
 void Group::SetTargetIcon(uint8 id, uint64 whoGuid, uint64 targetGuid)
 {
     if (id >= TARGETICONCOUNT)
@@ -1966,6 +2064,22 @@ void Group::SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag)
     // Preserve the new setting in the db
     CharacterDatabase.PExecute("UPDATE group_member SET memberFlags='%u' WHERE memberGuid='%u'", slot->flags, GUID_LOPART(guid));
 
+    Player *pPlayer = ObjectAccessor::FindPlayer(guid);
+    if (pPlayer && pPlayer->GetPlayerbotAI() != NULL)
+    {
+        if (apply) pPlayer->HandleEmoteCommand(EMOTE_ONESHOT_ROAR); // if pBot is maintank, acknowledge it
+    }
+    // tell all the bots who is the main tank now
+    if (apply)
+        for (GroupReference *itr = GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->getSource();
+            if(!tPlayer) continue;
+            PlayerbotAI *ai = tPlayer->GetPlayerbotAI();
+            if(!ai) continue;
+            if (tPlayer->IsPlayerbot())
+                ai->GetClassAI()->SetMainTank(ObjectAccessor::FindPlayer(guid));
+        }
     // Broadcast the changes to the group
     SendUpdate();
 }
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index c51aa6d..aa21549 100755
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -44,6 +44,21 @@ struct MapEntry;
 #define MAX_RAID_SUBGROUPS MAXRAIDSIZE/MAXGROUPSIZE
 #define TARGETICONCOUNT 8
 
+class PlayerbotAI;
+class PlayerbotClassAI;
+
+enum TARGETICON
+{
+    STAR            = 0,
+    CIRCLE          = 1,
+    DIAMOND         = 2,
+    TRIANGLE        = 3,
+    MOON            = 4,
+    SQUARE          = 5,
+    CROSS           = 6,
+    SKULL           = 7
+};
+
 enum RollVote
 {
     PASS              = 0,
@@ -247,6 +262,10 @@ class Group
         void SetGroupMemberFlag(uint64 guid, bool apply, GroupMemberFlags flag);
         void RemoveUniqueGroupMemberFlag(GroupMemberFlags flag);
 
+         // Bot change
+         uint64 GetTargetWithIconByGroup(uint64 guid);
+         void SetTargetIcon(uint8 id, uint64 guid);
+
         Difficulty GetDifficulty(bool isRaid) const;
         Difficulty GetDungeonDifficulty() const;
         Difficulty GetRaidDifficulty() const;
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 04a5b10..7d7b57c 100755
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -2162,7 +2162,9 @@ void InstanceMap::InitVisibilityDistance()
 */
 bool InstanceMap::CanEnter(Player* player)
 {
-    if (player->GetMapRef().getTarget() == this)
+    //playerbots calls this twice, first by TeleportTo and again by WorldSession
+    //Don't want to error since we know we are already here.
+    if(player->GetMapRef().getTarget() == this && !player->IsPlayerbot())
     {
         sLog->outError("InstanceMap::CanEnter - player %s(%u) already in map %d, %d, %d!", player->GetName(), player->GetGUIDLow(), GetId(), GetInstanceId(), GetSpawnMode());
         ASSERT(false);
@@ -2170,7 +2172,7 @@ bool InstanceMap::CanEnter(Player* player)
     }
 
     // allow GM's to enter
-    if (player->isGameMaster())
+    if (player->isGameMaster() || player->IsPlayerbot())
         return Map::CanEnter(player);
 
     // cannot enter if the instance is full (player cap), GMs don't count
@@ -2222,6 +2224,16 @@ bool InstanceMap::CanEnter(Player* player)
 /*
     Do map specific checks and add the player to the map if successful.
 */
+std::string getTimeString(uint64 time)
+{
+    uint64 days = time / DAY, hours = (time % DAY) / HOUR, minute = (time % HOUR) / MINUTE;
+    std::ostringstream ss;
+    if (days) ss << days << "d ";
+    if (hours) ss << hours << "h ";
+    ss << minute << 'm';
+    return ss.str();
+}
+
 bool InstanceMap::AddPlayerToMap(Player* player)
 {
     // TODO: Not sure about checking player level: already done in HandleAreaTriggerOpcode
@@ -2258,8 +2270,14 @@ bool InstanceMap::AddPlayerToMap(Player* player)
                 // cannot enter other instances if bound permanently
                 if (playerBind->save != mapSave)
                 {
+                    //Hacky unbind if Playerbot
+                    if(player->IsPlayerbot())
+                        player->UnbindInstance(GetId(), Difficulty(GetSpawnMode()));
+                    else
+                    {
                     sLog->outError("InstanceMap::Add: player %s(%d) is permanently bound to instance %d, %d, %d, %d, %d, %d but he is being put into instance %d, %d, %d, %d, %d, %d", player->GetName(), player->GetGUIDLow(), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset());
                     return false;
+                    }
                 }
             }
             else
@@ -2269,12 +2287,17 @@ bool InstanceMap::AddPlayerToMap(Player* player)
                     // solo saves should be reset when entering a group
                     InstanceGroupBind* groupBind = group->GetBoundInstance(this);
                     if (playerBind)
-                    {
-                        sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d, %d, %d, %d, %d, %d but he is in group %d and is bound to instance %d, %d, %d, %d, %d, %d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(group->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
+                   {
+                        if(player->IsPlayerbot())
+                            player->UnbindInstance(GetId(), Difficulty(GetSpawnMode()));
+                        else
+                        {
+                        sLog->outError("InstanceMap::Add: player %s(%d) is being put into instance %d,%d,%d,%d,%d,%d but he is in group %d and is bound to instance %d,%d,%d,%d,%d,%d!", player->GetName(), player->GetGUIDLow(), mapSave->GetMapId(), mapSave->GetInstanceId(), mapSave->GetDifficulty(), mapSave->GetPlayerCount(), mapSave->GetGroupCount(), mapSave->CanReset(), GUID_LOPART(group->GetLeaderGUID()), playerBind->save->GetMapId(), playerBind->save->GetInstanceId(), playerBind->save->GetDifficulty(), playerBind->save->GetPlayerCount(), playerBind->save->GetGroupCount(), playerBind->save->CanReset());
                         if (groupBind)
-                            sLog->outError("InstanceMap::Add: the group is bound to the instance %d, %d, %d, %d, %d, %d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
+                            sLog->outError("InstanceMap::Add: the group is bound to the instance %d,%d,%d,%d,%d,%d", groupBind->save->GetMapId(), groupBind->save->GetInstanceId(), groupBind->save->GetDifficulty(), groupBind->save->GetPlayerCount(), groupBind->save->GetGroupCount(), groupBind->save->CanReset());
                         //ASSERT(false);
                         return false;
+                        }
                     }
                     // bind to the group or keep using the group save
                     if (!groupBind)
diff --git a/src/server/game/Quests/QuestDef.h b/src/server/game/Quests/QuestDef.h
index 989c63d..fff9f64 100755
--- a/src/server/game/Quests/QuestDef.h
+++ b/src/server/game/Quests/QuestDef.h
@@ -97,9 +97,9 @@ enum QuestStatus
 {
     QUEST_STATUS_NONE           = 0,
     QUEST_STATUS_COMPLETE       = 1,
-    //QUEST_STATUS_UNAVAILABLE    = 2,
+    QUEST_STATUS_UNAVAILABLE    = 2,
     QUEST_STATUS_INCOMPLETE     = 3,
-    //QUEST_STATUS_AVAILABLE      = 4,
+    QUEST_STATUS_AVAILABLE      = 4,
     QUEST_STATUS_FAILED         = 5,
     QUEST_STATUS_REWARDED       = 6,        // Not used in DB
     MAX_QUEST_STATUS
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 26d7034..03d7279 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -76,6 +76,18 @@ void AddSC_npcs_special();
 void AddSC_npc_taxi();
 void AddSC_achievement_scripts();
 
+//Bots
+void AddSC_druid_bot();
+void AddSC_priest_bot();
+void AddSC_shaman_bot();
+void AddSC_warrior_bot();
+void AddSC_rogue_bot();
+void AddSC_mage_bot();
+void AddSC_warlock_bot();
+void AddSC_paladin_bot();
+void AddSC_hunter_bot();
+void AddSC_script_bot_giver();
+
 //eastern kingdoms
 void AddSC_alterac_valley();                 //Alterac Valley
 void AddSC_boss_balinda();
@@ -679,6 +691,19 @@ void AddWorldScripts()
     AddSC_npcs_special();
     AddSC_npc_taxi();
     AddSC_achievement_scripts();
+
+    //Bots
+    AddSC_druid_bot();
+    AddSC_priest_bot();
+    AddSC_shaman_bot();
+    AddSC_warrior_bot();
+    AddSC_rogue_bot();
+    AddSC_mage_bot();
+    AddSC_warlock_bot();
+    AddSC_paladin_bot();
+    AddSC_hunter_bot();
+    AddSC_script_bot_giver();
+
     AddSC_chat_log();
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index 925b352..13547d6 100755
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -769,13 +769,29 @@ bool ScriptMgr::OnGossipHello(Player* player, Creature* creature)
     return tmpscript->OnGossipHello(player, creature);
 }
 
+bool ScriptMgr::OnGossipHelloScriptId(Player * player, Creature* creature, uint32 scriptId)
+{
+    ASSERT(player);
+    ASSERT(creature);
+
+    GET_SCRIPT_RET(CreatureScript, scriptId, tmpscript, false);
+    return tmpscript->OnGossipHello(player, creature);
+}
+
 bool ScriptMgr::OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
 {
     ASSERT(player);
     ASSERT(creature);
 
-    GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
-    return tmpscript->OnGossipSelect(player, creature, sender, action);
+    // Bots change
+    if (sender > 6000)
+    {
+        GET_SCRIPT_RET(CreatureScript, sObjectMgr->GetScriptId("script_bot_giver"), tmpscript, false);
+        return tmpscript->OnGossipSelect(player, creature, sender, action);
+    } else {
+        GET_SCRIPT_RET(CreatureScript, creature->GetScriptId(), tmpscript, false);
+        return tmpscript->OnGossipSelect(player, creature, sender, action);
+    }
 }
 
 bool ScriptMgr::OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code)
diff --git a/src/server/game/Scripting/ScriptMgr.h b/src/server/game/Scripting/ScriptMgr.h
index b3ba7f0..f60d930 100755
--- a/src/server/game/Scripting/ScriptMgr.h
+++ b/src/server/game/Scripting/ScriptMgr.h
@@ -409,6 +409,8 @@ class CreatureScript : public ScriptObject, public UpdatableScript<Creature>
         // Called when a player opens a gossip dialog with the creature.
         virtual bool OnGossipHello(Player* /*player*/, Creature* /*creature*/) { return false; }
 
+        virtual bool OnGossipHelloScriptId(Player* /*player*/, Creature* /*creature*/, uint32 ScriptId) { return false; }
+
         // Called when a player selects a gossip item in the creature's gossip menu.
         virtual bool OnGossipSelect(Player* /*player*/, Creature* /*creature*/, uint32 /*sender*/, uint32 /*action*/) { return false; }
 
@@ -885,6 +887,9 @@ class ScriptMgr
 
         bool OnDummyEffect(Unit* caster, uint32 spellId, SpellEffIndex effIndex, Creature* target);
         bool OnGossipHello(Player* player, Creature* creature);
+
+        bool OnGossipHelloScriptId(Player* player, Creature* creature, uint32 ScriptId);
+
         bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
         bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code);
         bool OnQuestAccept(Player* player, Creature* creature, Quest const* quest);
diff --git a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
index 3d33e50..c382c06 100755
--- a/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/CharacterHandler.cpp
@@ -44,6 +44,10 @@
 #include "Battleground.h"
 #include "AccountMgr.h"
 
+// Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -196,6 +200,34 @@ bool LoginQueryHolder::Initialize()
     return res;
 }
 
+// don't call WorldSession directly
+// it may get deleted before the query callbacks get executed
+// instead pass an account id to this handler
+class CharacterHandler
+{
+
+    public:
+        void HandleCharEnumCallback(QueryResult result, uint32 account)
+        {
+            WorldSession * session = sWorld->FindSession(account);
+            if (!session)
+                return;
+            session->HandleCharEnum(result);
+        }
+        void HandlePlayerLoginCallback(QueryResult /*dummy*/, SQLQueryHolder * holder)
+        {
+            if (!holder) return;
+            WorldSession *session = sWorld->FindSession(((LoginQueryHolder*)holder)->GetAccountId());
+            if (!session)
+            {
+                delete holder;
+                return;
+            }
+            session->HandlePlayerLogin((LoginQueryHolder*)holder);
+        }
+
+} chrHandler;
+
 void WorldSession::HandleCharEnum(QueryResult result)
 {
     WorldPacket data(SMSG_CHAR_ENUM, 100);                  // we guess size
@@ -1015,9 +1047,123 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder * holder)
 
     m_playerLoading = false;
 
+    //the only place where we check if it has an NPCBot
+    QueryResult results;
+    results = CharacterDatabase.PQuery("SELECT entry,race,class FROM character_npcbot WHERE owner='%u'", pCurrChar->GetGUIDLow());
+    if(results)
+    {
+        do
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            Field *fields = results->Fetch();
+            m_bot_entry = fields[0].GetUInt32();
+            m_bot_race = fields[1].GetUInt8();
+            m_bot_class = fields[2].GetInt8();
+            if(m_bot_entry && m_bot_race && m_bot_class) pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class);
+        } while(results->NextRow());
+    }
+
     sScriptMgr->OnPlayerLogin(pCurrChar);
     delete holder;
 }
+//Playerbot mod: is different from the normal
+//HandlePlayerLoginCallback in that it sets up the bot's
+//world session and also stores the pointer to the bot player
+//in the master's world session m_playerBots map
+void WorldSession::HandlePlayerBotLogin(SQLQueryHolder *holder)
+{
+    if(!holder) return;
+
+    LoginQueryHolder *lqh = (LoginQueryHolder *)holder;
+
+    if(!lqh || !lqh->GetAccountId()) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #1 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        return;
+    }
+
+    WorldSession *masterSession = sWorld->FindSession(lqh->GetAccountId());
+
+    if(!masterSession) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #2 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        return;
+    }
+
+    //This WorldSession is owned by the bot player object
+    //it will deleted in the Player class constructor for Playerbots
+    //only
+    WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, masterSession->GetSecurity(), 2, 0, LOCALE_enUS, 0, false);
+
+    if(!botSession) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #3 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    botSession->m_Address = "bot";
+    botSession->m_expansion = masterSession->Expansion();
+
+    uint64 guid = lqh->GetGuid();
+     if(!guid) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #4 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    Group * group = masterSession->GetPlayer()->GetGroup() ;
+    if(group && group->IsFull() && !group->IsMember(guid))
+    {
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        ChatHandler chH = ChatHandler(masterSession->GetPlayer());
+        chH.PSendSysMessage("Bot removed because group is full.");
+        return;
+    }
+
+    botSession->HandlePlayerLogin(lqh);
+    Player *botPlayer = botSession->GetPlayer();
+
+    if(!botPlayer) // Probably excessively verbose..
+    {
+        sLog->outError("Excessively verbose Playerbot error checkpoint #5 hit. Please report this error immediately.");
+        if(holder) delete holder;
+        if(botSession) delete botSession;
+        return;
+    }
+
+    //give the bot some AI, object is owned by the player class
+    PlayerbotAI *ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+    botPlayer->SetPlayerbotAI(ai);
+
+    ai->SetStartDifficulty(botPlayer->GetDungeonDifficulty());
+    ai->SetStartInstanceID(botPlayer->GetInstanceId());
+    ai->SetStartMapID(botPlayer->GetMapId());
+    ai->SetStartZoneID(botPlayer->GetZoneId());
+    ai->SetStartAreaID(botPlayer->GetAreaId());
+    ai->SetStartO(botPlayer->GetOrientation());
+    ai->SetStartX(botPlayer->GetPositionX());
+    ai->SetStartY(botPlayer->GetPositionY());
+    ai->SetStartZ(botPlayer->GetPositionZ());
+
+    //tell the world session that they now manage this new bot
+    (masterSession->m_playerBots)[guid] = botPlayer;
+
+    //if bot is in a group and master is not in group then
+    //have bot leave their group
+    if(botPlayer->GetGroup() &&
+        (masterSession->GetPlayer()->GetGroup() == NULL ||
+        masterSession->GetPlayer()->GetGroup()->IsMember(guid) == false))
+        botPlayer->RemoveFromGroup();
+}
 
 void WorldSession::HandleSetFactionAtWar(WorldPacket & recv_data)
 {
@@ -1176,6 +1322,40 @@ void WorldSession::HandleChangePlayerNameOpcodeCallBack(QueryResult result, std:
     sWorld->UpdateCharacterNameData(guidLow, newname);
 }
 
+//Playerbot mod - add new player bot for this master. This definition must
+//appear in this file because it utilizes the CharacterHandler class
+//which isn't accessible outside this file
+void WorldSession::AddPlayerBot(uint64 playerGuid)
+{
+    //has bot already been added?
+    if(GetPlayerBot(playerGuid) != 0) return;
+
+    ChatHandler chH = ChatHandler(GetPlayer());
+
+    //check if max playerbots are exceeded
+    uint8 count = 0;
+    uint8 m_MaxPlayerbots = ConfigMgr::GetFloatDefault("Bot.MaxPlayerbots", 9);
+    for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr) ++count;
+
+    if(count >= m_MaxPlayerbots)
+    {
+        chH.PSendSysMessage("You have reached the maximum number (%d) of Player Bots allowed.", m_MaxPlayerbots);
+        return;
+    }
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+
+    if(!holder->Initialize())
+    {
+        delete holder; //delete all unprocessed queries
+        return;
+    }
+    //CharacterDatabase.DelayQueryHolder(&chrHandler, &CharacterHandler::HandlePlayerBotLoginCallback, holder);
+    _charBotLoginCallback = CharacterDatabase.DelayQueryHolder(holder);
+
+    chH.PSendSysMessage("Bot added successfully.");
+}
+
 void WorldSession::HandleSetPlayerDeclinedNames(WorldPacket& recv_data)
 {
     uint64 guid;
diff --git a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
index 852549b..cc18600 100755
--- a/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/ChatHandler.cpp
@@ -41,6 +41,9 @@
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
 
+//Playerbot mod
+#include "PlayerbotAI.h"
+
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
     if (lang != LANG_ADDON)
@@ -295,7 +298,17 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
             if (!senderIsPlayer && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID()))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
-            GetPlayer()->Whisper(msg, lang, receiver->GetGUID());
+            //Playerbot mod: handle whispered command to bot
+            if(sender->GetPlayerbotAI())
+            {
+                sender->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else {
+            //end Playerbot mod
+                GetPlayer()->Whisper(msg, lang, sender->GetGUID());
+            }
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -314,6 +327,21 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
+
+            //Playerbot mod: broadcast message to bot members
+            Player *player;
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                player = itr->getSource();
+                if(player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+//end Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, uint8(type), lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
index 6586528..6288beb 100755
--- a/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/GroupHandler.cpp
@@ -302,8 +302,23 @@ void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket & recv_data)
 
     if (grp->IsMember(guid))
     {
+        if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature* cr = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL))
+                if (Player *player = cr->GetBotOwner())
+                        player->RemoveBot(cr->GetGUID(), true);
+                        
+            return;
+        }
+        Player *player = ObjectAccessor::FindPlayer(guid);
+        //logout playerbot (do not touch npcbots, they will be removed and DB-stored is WorldSession:LogoutPlayer())
+        if(player && player->IsPlayerbot())
+        {
+            GetPlayer()->GetSession()->LogoutPlayerBot(guid, true);
+            return;
+        }
+
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID(), reason.c_str());
-        return;
     }
 
     if (Player* player = grp->GetInvited(guid))
@@ -322,9 +337,26 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
     std::string membername;
     recv_data >> membername;
 
+    Player *player = GetPlayer();
+
     // player not found
     if (!normalizePlayerName(membername))
+    {
+        if(player->HaveBot())//player not found cuz it is bot name
+        {
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            {
+                Creature *cre = player->GetBotMap()[i].m_creature;
+                if (cre && !membername.compare(cre->GetName()))
+                {
+                    player->RemoveBot(cre->GetGUID(), true);
+                    return;
+                }
+            }
+        }
         return;
+    }
+
 
     // can't uninvite yourself
     if (GetPlayer()->GetName() == membername)
@@ -346,6 +378,14 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
 
     if (uint64 guid = grp->GetMemberGUID(membername))
     {
+        if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature* cr = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL))
+                if (Player *player = cr->GetBotOwner())
+                        player->RemoveBot(cr->GetGUID(), true);
+                        
+            return;
+        }
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID());
         return;
     }
diff --git a/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp b/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
index a675214..6a1c44e 100755
--- a/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
+++ b/src/server/game/Server/Protocol/Handlers/NPCHandler.cpp
@@ -340,6 +340,7 @@ void WorldSession::HandleGossipHelloOpcode(WorldPacket & recv_data)
         _player->PrepareGossipMenu(unit, unit->GetCreatureInfo()->GossipMenuId, true);
         _player->SendPreparedGossip(unit);
     }
+
     unit->AI()->sGossipHello(_player);
 }
 
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 14c8628..94d93f6 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -42,6 +42,10 @@
 #include "zlib.h"
 #include "ScriptMgr.h"
 #include "Transport.h"
+//Playerbot mod
+#include "PlayerbotAI.h"
+#include "PlayerbotClassAI.h"
+
 
 bool MapSessionFilter::Process(WorldPacket* packet)
 {
@@ -110,6 +114,10 @@ isRecruiter(isARecruiter)
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
+    //Playerbot mod: log out any PlayerBots owned in this WorldSession
+    while(!m_playerBots.empty())
+    LogoutPlayerBot(m_playerBots.begin()->first, true);
+
     ///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
@@ -145,6 +153,13 @@ char const* WorldSession::GetPlayerName() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    //Playerbot mod: send packet to bot AI
+    if(GetPlayer() && GetPlayer()->GetPlayerbotAI()) {
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+    } else if(!m_playerBots.empty()) {
+            PlayerbotAI::HandleMasterOutgoingPacket(*packet, *this);
+    }
+
     if (!m_Socket)
         return;
 
@@ -216,8 +231,8 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 
     ///- Before we process anything:
     /// If necessary, kick the player from the character select screen
-    if (IsConnectionIdle())
-        m_Socket->CloseSocket();
+    /*if (IsConnectionIdle())
+        m_Socket->CloseSocket();*/
 
     ///- Retrieve packets from the receive queue and call the appropriate handlers
     /// not process packets if socket already closed
@@ -249,6 +264,12 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             (this->*opHandle.handler)(*packet);
                             if (sLog->IsOutDebug() && packet->rpos() < packet->wpos())
                                 LogUnprocessedTail(packet);
+
+                            // Playerbot mod: if this player has bots let the
+                            // botAI see the masters packet
+                            if(!m_playerBots.empty())
+                                PlayerbotAI::HandleMasterIncomingPacket(*packet, *this);
+
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
@@ -334,6 +355,29 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         if (ShouldLogOut(currTime) && !m_playerLoading)
             LogoutPlayer(true);
 
+    //Playerbot mod - Process player bot packets
+    //The PlayerbotAI class adds to the packet queue to simulate a real player
+    //since Playerbots are known to the World obj only its master's
+    //WorldSession object we need to process all master's bot's packets.
+        for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+        {
+            Player *const botPlayer = itr->second;
+            WorldSession *const pBotWorldSession = botPlayer->GetSession();
+            if(botPlayer->IsBeingTeleportedFar())
+            {
+              pBotWorldSession->HandleMoveWorldportAckOpcode();
+          } else if(botPlayer->IsInWorld())
+          {
+              WorldPacket *packet;
+              while(pBotWorldSession->_recvQueue.next(packet))
+              {
+                  OpcodeHandler &opHandle = opcodeTable[packet->GetOpcode()];
+                  (pBotWorldSession->*opHandle.handler)(*packet);
+                  delete packet;
+              }
+          }
+        }
+
         ///- Cleanup socket pointer if need
         if (m_Socket && m_Socket->IsClosed())
         {
@@ -350,6 +394,23 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    if (!_player)
+    {
+        return;
+    }
+
+    if (_player->IsMounted()) _player->Unmount();
+
+    for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = _player->GetBotMap()[i].m_guid;
+        if (guid != 0)
+            _player->RemoveBot(guid, true, false);
+    }
+    //Playerbot mod: log out all player bots owned by this toon
+    while(!m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first, Save);
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -470,7 +531,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
-        if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+        if ((_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket) || (_player->IsPlayerbot() && _player->GetGroup()))
             _player->RemoveFromGroup();
 
         ///- Send update to group and reset stored max enchanting level
@@ -494,6 +555,7 @@ void WorldSession::LogoutPlayer(bool Save)
         _player->CleanupsBeforeDelete();
         sLog->outChar("Account: %d (IP: %s) Logout Character:[%s] (GUID: %u)", GetAccountId(), GetRemoteAddress().c_str(), _player->GetName(), _player->GetGUIDLow());
         Map* _map = _player->GetMap();
+        uint32 guid = _player->GetGUIDLow();
         _map->RemovePlayerFromMap(_player, true);
         SetPlayer(NULL);                                    // deleted in Remove call
 
@@ -503,7 +565,7 @@ void WorldSession::LogoutPlayer(bool Save)
 
         ///- Since each account can only have one online character at any given time, ensure all characters for active account are marked as offline
         //No SQL injection as AccountId is uint32
-        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE account = '%u'", GetAccountId());
+        CharacterDatabase.PExecute("UPDATE characters SET online = 0 WHERE guid = '%u'", guid);
         sLog->outDebug(LOG_FILTER_NETWORKIO, "SESSION: Sent SMSG_LOGOUT_COMPLETE Message");
     }
 
@@ -605,6 +667,38 @@ void WorldSession::LoadGlobalAccountData()
     LoadAccountData(CharacterDatabase.Query(stmt), GLOBAL_CACHE_MASK);
 }
 
+//Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(uint64 guid, bool Save)
+{
+    Player *pPlayerBot = GetPlayerBot(guid);
+
+    if(pPlayerBot) //log out any playbots I have
+    {
+        //if (pPlayerBot->IsMounted()) pPlayerBot->GetPlayerbotAI()->GetClassAI()->Unmount();
+
+        pPlayerBot->CombatStop();
+
+        // remove from group
+        Group* m_group = pPlayerBot->GetGroup();
+        if (m_group)
+        {
+            if (m_group->RemoveMember(pPlayerBot->GetGUID())) { }
+        }
+
+        WorldSession *pPlayerBotWorldSession = pPlayerBot->m_session;
+        m_playerBots.erase(guid); //deletes bot player ptr inside this WorldSession PlayerBotMap
+        pPlayerBotWorldSession->LogoutPlayer(Save); //this will delete the bot Player object and PlayerbotAI object
+        delete pPlayerBotWorldSession; //finally delete the bot's WorldSession
+    }
+}
+
+//Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player *WorldSession::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return(it == m_playerBots.end()) ? 0 : it->second;
+}
+
 void WorldSession::LoadAccountData(PreparedQueryResult result, uint32 mask)
 {
     for (uint32 i = 0; i < NUM_ACCOUNT_DATA_TYPES; ++i)
@@ -1009,6 +1103,15 @@ void WorldSession::ProcessQueryCallbacks()
         _charLoginCallback.cancel();
     }
 
+    //! HandlePlayerBotLogin
+    if (_charBotLoginCallback.ready())
+    {
+        SQLQueryHolder* param;
+        _charBotLoginCallback.get(param);
+        HandlePlayerBotLogin((SQLQueryHolder*)param);
+        _charBotLoginCallback.cancel();
+    }
+
     //! HandleAddFriendOpcode
     if (_addFriendCallback.IsReady())
     {
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 4a83c2d..1711bb8 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -210,6 +210,20 @@ class CharacterCreateInfo
         virtual ~CharacterCreateInfo(){};
 };
 
+//Playerbot mod
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+//npcbot
+struct NpcBotMap
+{
+        NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL) {}
+        NpcBotMap(uint64 _guid, uint32 _entry, uint8 _race, uint8 _class, Creature *_creature) : m_guid(m_guid), m_entry(_entry), m_race(_race), m_class(_class), m_creature(_creature) {}
+
+        uint64 m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature *m_creature;
+};
 /// Player session in the World
 class WorldSession
 {
@@ -217,6 +231,14 @@ class WorldSession
         WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
         ~WorldSession();
 
+        //Playerbot mod
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid, bool Save);
+        Player *GetPlayerBot (uint64 guid) const;
+        PlayerBotMap m_playerBots;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -402,6 +424,7 @@ class WorldSession
         void HandlePlayerLoginOpcode(WorldPacket& recvPacket);
         void HandleCharEnum(QueryResult result);
         void HandlePlayerLogin(LoginQueryHolder * holder);
+        void HandlePlayerBotLogin(SQLQueryHolder * holder);
         void HandleCharFactionOrRaceChange(WorldPacket& recv_data);
 
         // played time
@@ -908,6 +931,7 @@ class WorldSession
         QueryCallback<PreparedQueryResult, CharacterCreateInfo*> _charCreateCallback;
         QueryResultHolderFuture _charLoginCallback;
 
+        QueryResultHolderFuture _charBotLoginCallback;
     private:
         // private trade methods
         void moveItems(Item* myItems[], Item* hisItems[]);
diff --git a/src/server/scripts/Bots/CMakeLists.txt b/src/server/scripts/Bots/CMakeLists.txt
new file mode 100644
index 0000000..f943a5e
--- /dev/null
+++ b/src/server/scripts/Bots/CMakeLists.txt
@@ -0,0 +1,26 @@
+set(scripts_STAT_SRCS
+  ${scripts_STAT_SRCS}
+  Bots/bot_ai.cpp
+  Bots/bot_druid_ai.cpp
+  Bots/bot_hunter_ai.cpp
+  Bots/bot_mage_ai.cpp
+  Bots/bot_paladin_ai.cpp
+  Bots/bot_priest_ai.cpp
+  Bots/bot_rogue_ai.cpp
+  Bots/bot_shaman_ai.cpp
+  Bots/bot_warlock_ai.cpp
+  Bots/bot_warrior_ai.cpp
+  Bots/script_bot_giver.cpp
+  Bots/bot_ai.h
+  Bots/bot_druid_ai.h
+  Bots/bot_hunter_ai.h
+  Bots/bot_mage_ai.h
+  Bots/bot_paladin_ai.h
+  Bots/bot_priest_ai.h
+  Bots/bot_rogue_ai.h
+  Bots/bot_shaman_ai.h
+  Bots/bot_warlock_ai.h
+  Bots/bot_warrior_ai.h
+)
+
+message("  -> Prepared: Bots")
diff --git a/src/server/scripts/Bots/bot_ai.cpp b/src/server/scripts/Bots/bot_ai.cpp
new file mode 100644
index 0000000..3927ddc
--- /dev/null
+++ b/src/server/scripts/Bots/bot_ai.cpp
@@ -0,0 +1,1693 @@
+#include "bot_ai.h"
+
+bot_ai::bot_ai(Creature *creature): ScriptedAI(creature)
+{
+    m_creature = creature;
+    pct = 0;
+    m_basemana = 0;
+    m_totalmana = 0;
+    m_basehp = 0;
+    m_totalhp = 0;
+    speed_walk = 0.0;
+    speed_run = 0.0;
+    speed_swim = 0.0;
+    tank = NULL;
+    oldtank = NULL;
+    clear_cd = 0;
+    pet = NULL;
+    prevCommandState = COMMAND_FOLLOW; // default
+    master = m_creature->GetBotOwner();
+    info = NULL;
+    cost = 0;
+
+}
+
+bot_ai::~bot_ai(){}
+
+void bot_ai::SetBotCommandState(CommandStates st)
+{
+    m_creature->SetBotCommandState(st);
+    float mydist = 0.0f;
+    float angle = 0.0f;
+    switch (m_creature->GetBotClass())
+    {
+    case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case CLASS_PALADIN:
+        mydist = RAND(1.0f,1.5f,2.0f,2.5f,3.0f,3.5f,4.0f,4.5f,5.0f);
+        angle = (M_PI/2)/8.0f*RAND(7.0f,7.5f,8.0f,8.5f,-7.0f,-7.5f,-8.0f,-8.5f);
+        break;
+    case CLASS_WARLOCK: case CLASS_PRIEST: case CLASS_MAGE:
+        mydist = RAND(0.5f,1.0f,1.5f,2.0f);
+        angle = (M_PI/2)/6.0f*RAND(10.5f,11.0f,11.5f,12.0f,12.5f,13.0f,13.5f);
+        break;
+    default:
+        mydist = RAND(2.5f,3.0f,3.5f,4.0f);
+        angle = (M_PI/2)/6.0f*RAND(9.0f,10.0f,11.0f,12.0f,13.0f,14.0f,15.0f);
+        break;
+    }
+    
+    //     mmmm       mmmm 
+    //   mmmmmmmmm mmmmmmmmm
+    // mmmmmmmmm MMM mmmmmmmmm
+    //  mmmmmm rrrrrrr mmmmmm
+    //    ddd rrrrrrrrr ddd
+    //     ddddddddddddddd
+    //       ddddddddddd
+    //         
+    //MMM - player
+    //m - melee (warrior, paladin, deathknight)
+    //d - default (druid, shaman, rogue, hunter)
+    //r - ranged/support (priest, warlock, mage)
+    switch(st)
+    {
+        case COMMAND_STAY: m_creature->StopMoving(); m_creature->GetMotionMaster()->Clear(); m_creature->GetMotionMaster()->MoveIdle(); break;
+        case COMMAND_FOLLOW: m_creature->GetMotionMaster()->MoveFollow(master, mydist, angle); break;
+    }
+}
+
+void bot_ai::FindTank(Player *gPlayer)
+{
+    // check if original main tank is still alive. No point regetting main
+    // tank b/c chances are slim that it will not get reset in the middle of a fight.
+    // But if main tank dies, try to find next best canidate
+    if (tank != NULL && tank->IsInWorld() && tank->isAlive())
+        return;
+    else
+        tank = NULL;
+
+    if (!gPlayer) gPlayer = master;
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return;
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid FROM group_member WHERE memberFlags='%u' AND guid = '%u'",MEMBER_FLAG_MAINTANK, pGroup->GetGUID());
+    if (result)
+    {
+        Unit *t = NULL;
+        uint64 guid = MAKE_NEW_GUID(result->Fetch()->GetInt32(),0,HIGHGUID_UNIT);
+        t = ObjectAccessor::FindUnit(guid);
+        if (t && pGroup->IsMember(guid) && t->isAlive())
+            tank = t;
+    }
+    if (!tank)
+    {
+        std::list<Unit*> unitList;
+        gPlayer->GetRaidMember(unitList,50);
+        if (!unitList.empty())
+        {  
+            uint32 maxhpfound = 0;
+            for (std::list<Unit*>::iterator itr = unitList.begin() ; itr != unitList.end();++itr)
+            {
+                Player *tPlayer = master->GetObjPlayer((*itr)->GetGUID());
+                if (tPlayer == NULL) continue;
+                if (tPlayer->isDead() && !tPlayer->HaveBot()) continue;
+                if (m_creature->GetDistance(tPlayer) > 50) continue;
+                if (tPlayer->GetMaxHealth() > maxhpfound)
+                {
+                    maxhpfound = tPlayer->GetMaxHealth();
+                    tank = tPlayer;
+                }
+
+                if (!tPlayer->HaveBot())  continue;
+                for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                {
+                    Creature *bot = tPlayer->GetBotMap()[i].m_creature;
+                    if (!bot || !bot->IsInWorld() || bot->isDead() || m_creature->GetDistance(bot) > 50) continue;
+                    if (bot->GetMaxHealth() > maxhpfound)
+                    {
+                        maxhpfound = bot->GetMaxHealth();
+                        tank = bot;
+                    }
+                }
+            }
+        }
+    }
+    if (tank)
+    {
+        if (tank != m_creature->GetBotTank() && tank != oldtank)
+        {
+            if (tank == m_creature)
+            {
+                switch (rand()%5)
+                {
+                case 1: DoSay("I am tank here!"); break;
+                case 2: DoSay("I will tank now."); break;
+                case 3: DoSay("Seems it is for me to tank"); break;
+                case 4: DoSay("I think I will be best tank here..."); break;
+                case 5: DoSay("I AM the tank!"); break;
+                }
+                m_creature->HandleEmoteCommand(EMOTE_ONESHOT_CHEER);
+            }
+            if (tank->GetGUID() == master->GetGUID())
+            {
+                switch (rand()%5)
+                {
+                case 1:
+                case 2:
+                case 3:
+                case 4: break;
+                case 5: m_creature->MonsterWhisper("You're the tank now...", master->GetGUID()); break;
+                }
+            }
+        }
+        pGroup->RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);
+        pGroup->SetGroupMemberFlag(tank->GetGUID(), true, MEMBER_FLAG_MAINTANK);
+    }
+}
+
+void bot_ai::BuffAndHealGroup(Player *gPlayer)
+{
+    if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return; // if I'm already casting
+
+    std::list<Unit*> unitList;
+    gPlayer->GetRaidMember(unitList,30);
+    if (!unitList.empty())
+    {
+        uint8 Bots = 0;
+        for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr)
+        {
+            Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+            if (tPlayer == NULL) continue;
+            if (tPlayer->isDead() && !tPlayer->HaveBot()) continue;
+            if (m_creature->GetDistance(tPlayer) > 30) continue;
+            if (tPlayer->HaveBot())
+                Bots++;
+            HealTarget(tPlayer, tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth());
+            BuffTarget(tPlayer);
+        }
+        if (Bots == 0) return;
+        for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr)
+        {
+            Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = tPlayer->GetBotMap()[i].m_creature;
+                if (!bot || bot->isDead()) continue;
+                if (m_creature->GetDistance(bot) > 30) continue;
+                HealTarget(bot, bot->GetHealth()*100 / bot->GetMaxHealth());
+                BuffTarget(bot);
+            }
+        }
+    }
+}
+
+void bot_ai::RezGroup(uint32 REZZ, Player *gPlayer)
+{
+    if (!REZZ || !gPlayer) return;
+    if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return; // if I'm already casting
+
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup) return;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *tPlayer = itr->getSource();//((Player *)master)->GetObjPlayer((*itr)->GetGUID());//Ref:Group Members
+        if (tPlayer == NULL) continue;
+        if (tPlayer->isAlive()) continue;
+        if (tPlayer->isRessurectRequested()) continue; //ressurected
+        //if (m_creature->GetAreaId() != gPlayer->GetAreaId()) continue;
+        if (m_creature->GetDistance(tPlayer) > 40) continue;
+        /*if (tPlayer->HasUnitState(UNIT_STAT_CASTING) && 
+            tPlayer->GetSelectedPlayer() && 
+            (tPlayer->GetSelectedPlayer()->IsInRaidWith(tPlayer) || 
+            tPlayer->GetSelectedPlayer()->IsInPartyWith(tPlayer))) continue; *///someone rezzing it already
+        if (!tPlayer->IsWithinLOSInMap(m_creature))
+            m_creature->Relocate(tPlayer);
+
+        if (doCast(tPlayer, REZZ))//rezzing it
+        {
+            char *str = (char *)malloc(32);
+            sprintf(str, "Rezzing %s", tPlayer->GetName());
+            m_creature->MonsterSay(str, LANG_UNIVERSAL, NULL);
+            free(str);
+        }
+        return;
+    }
+}
+
+void bot_ai::BotAttackStart(Unit *victim)
+{
+    AttackStart(victim);
+    m_creature->AttackerStateUpdate(victim);
+    //m_creature->resetAttackTimer();
+    if (m_creature->GetBotCommandState() != COMMAND_ATTACK)
+        prevCommandState = m_creature->GetBotCommandState();
+    SetBotCommandState(COMMAND_ATTACK);
+}
+
+bool bot_ai::gettingAttacked(AttackerSet m_attackers)
+{
+    if (!m_attackers.empty())
+    {
+        for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+        {
+            if (*iter && m_creature->GetDistance((*iter)) < 45 &&
+               !IsInBotParty(*iter) && 
+               //if the thing to attack is a world invisible trigger, ex Glyph in UBRS,
+               (*iter)->GetUInt32Value(UNIT_FIELD_DISPLAYID) != 11686 && 
+               (*iter)->isTargetableForAttack())
+            {
+                BotAttackStart(*iter);
+                opponent = (*iter);
+                return true;
+            } //end if
+        } //end for
+    } // end if
+    return false;
+} //end gettingAttacked
+
+void bot_ai::ResetOrGetNextTarget()
+{
+    if (m_creature->GetBotMustDie()) return;
+    if (m_creature->getVictim()) return;
+
+    Unit *u = master->GetSelectedUnit();
+    if (u && 
+        u->IsHostileTo(master) && 
+        u->isInCombat() && 
+        u->getVictim() && 
+        IsInBotParty(u->getVictim()) && 
+        u->isTargetableForAttack())
+    {
+        if (m_creature->IsWithinDist(u, 30))
+        {
+            BotAttackStart(u);
+            opponent = u;
+            return;
+        }
+    }
+
+    //check if anyone is attacking master
+    AttackerSet m_attackers = master->getAttackers();
+    if (gettingAttacked(m_attackers)) return;
+
+    //check if anyone is attacking me
+    m_attackers = m_creature->getAttackers();
+    if (gettingAttacked(m_attackers)) return;
+
+    //check pet
+    if (pet != NULL)
+    {
+        m_attackers = pet->getAttackers();
+        if (gettingAttacked(m_attackers)) return;
+    }
+
+    //lastly check a random victim, including bots, pets, etc
+    u = DoSelectLowestHpFriendly(30);
+    if (u != NULL && u->isAlive() && IsInBotParty(u))
+    {
+        m_attackers = u->getAttackers();
+        if (gettingAttacked(m_attackers)) return;
+    }
+
+    //if there is no one to attack, make sure we are following master
+    if (!m_creature->getVictim() &&
+        m_creature->GetBotCommandState() != COMMAND_STAY &&
+        master->GetDistance(m_creature) > 14 &&
+        !master->IsBeingTeleported())
+    {
+        if (!master->isAlive())
+            SetBotCommandState(COMMAND_STAY);
+        else if (m_creature->GetBotCommandState()==COMMAND_ATTACK)
+            SetBotCommandState(prevCommandState);
+        else if (m_creature->GetBotCommandState()==COMMAND_STAY)
+            SetBotCommandState(COMMAND_FOLLOW);
+        return;
+    }
+}
+
+/*std::string bot_ai::GetSpellName(uint32 spellId)
+{
+    if (spellId==0) return "";
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+    const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (pSpellInfo != NULL) {
+        const std::string  name = pSpellInfo->SpellName[loc];
+        return name;
+    }
+    return "";
+} // end GetSpellName
+*/
+/*bool bot_ai::HasAuraIcon (Unit *unit, uint32 SpellIconID, uint64 casterGuid)
+{
+    int loc = master->GetSession()->GetSessionDbcLocale();;
+    if (unit == NULL) return false;
+    Unit *target = unit;
+    if (target->isDead()) return false;
+
+    Unit::AuraMap &vAuras = (Unit::AuraMap&)target->GetOwnedAuras();
+
+    //save the map of auras b/c it can crash if an aura goes away while looping
+    UNORDERED_MAP<uint64, Aura*> auraMap;
+    for(Unit::AuraMap::const_iterator iter = vAuras.begin(); iter!= vAuras.end(); ++iter)
+    {
+         Aura *aura = iter->second;
+        (auraMap)[iter->first] = aura;
+    }
+
+    // now search our new map
+    for(UNORDERED_MAP<uint64, Aura*>::iterator itr = auraMap.begin(); itr!= auraMap.end(); ++itr)
+    {
+        const SpellInfo *spellInfo = itr->second->GetSpellInfo();
+        uint32 spelliconId = spellInfo->SpellIconID;
+//sLog->outError ("bot_ai.HasAuraICON: %s has icon %u",spellInfo->SpellName[master->GetSession()->GetSessionDbcLocale()],  spellInfo->SpellIconID);
+
+        if (spelliconId==SpellIconID)
+        {
+//sLog->outError ("bot_ai.HasAuraICON: %s has icon %u",spellInfo->SpellName[master->GetSession()->GetSessionDbcLocale()],  spellInfo->SpellIconID);
+            if (casterGuid == 0){ //don't care who casted it
+                return true;
+            } else if (casterGuid == itr->second->GetCasterGUID()){ //only if correct caster casted it
+                return true;
+            }
+        }
+    }
+    return false;
+}
+*/
+bool bot_ai::HasAuraName (Unit *unit, uint32 spellId, uint64 casterGuid)
+{
+    const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+    if (!pSpellInfo) return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if (name.length() == 0) return false;
+
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool bot_ai::HasAuraName (Unit *unit, std::string spell, uint64 casterGuid)
+{
+    if (spell.length()==0) return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();;
+    if (!unit || unit->isDead()) return false;
+
+    Unit::AuraMap &vAuras = (Unit::AuraMap&)unit->GetOwnedAuras();
+
+    //save the map of auras b/c it can crash if an aura goes away while looping
+    UNORDERED_MAP<uint64, Aura*> auraMap;
+    for(Unit::AuraMap::const_iterator iter = vAuras.begin(); iter!= vAuras.end(); ++iter)
+    {
+         Aura *aura = iter->second;
+        (auraMap)[iter->first] = aura;
+    }
+
+    // now search our new map
+    for(UNORDERED_MAP<uint64, Aura*>::iterator itr = auraMap.begin(); itr!= auraMap.end(); ++itr)
+    {
+        const SpellInfo *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if (!spell.compare(name))
+        {
+            if (casterGuid == 0){ //don't care who casted it
+                return true;
+            } else if (casterGuid == itr->second->GetCasterGUID()){ //only if correct caster casted it
+                return true;
+            }
+        }
+    }
+
+    return false;
+}
+
+bool bot_ai::listAuras (Unit *unit)
+{
+    Unit *target = unit;
+    sLog->outError ("ListAuras for %s", unit->GetName());
+    Unit::AuraMap &vAuras = (Unit::AuraMap&)target->GetOwnedAuras();
+    for(Unit::AuraMap::const_iterator itr = vAuras.begin(); itr!=vAuras.end(); ++itr)
+    {
+        SpellInfo const *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[0];
+        const std::string rank = spellInfo->Rank[0];
+        char *passive = NULL;
+        if (spellInfo->IsPassive()) 
+            passive = "(Passive)";
+        if (passive != NULL)
+            sLog->outError("aura = %u %s %s %s", spellInfo->Id, name.c_str(), rank.c_str(), passive);
+        else
+            sLog->outError("aura = %u %s %s", spellInfo->Id, name.c_str(), rank.c_str());
+    }
+    sLog->outBasic("base hp: %u", m_basehp);
+    sLog->outBasic("total hp: %u", m_totalhp);
+    if (m_creature->getPowerType() == POWER_MANA)
+    {
+        sLog->outBasic("base mana: %u", m_creature->GetBotBaseMana());
+        sLog->outBasic("total mana: %u", m_totalmana);
+    }
+    if (tank != NULL && tank->IsInWorld())
+    {
+        sLog->outError("Maintank is %s", tank->GetName());
+    }
+    return false;
+}
+//   DOCAST
+bool bot_ai::doCast(Unit *victim, uint32 spellId, bool triggered)
+{
+    if (spellId == 0) return false;
+    if (!isTimerReady(GC_Timer)) return false;
+    if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false; //already casting
+    if (Feasting() && !master->isInCombat() && 
+        !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+        return false;//NEW! if nothing threats us both do nothing (bot can feast only out of combat)
+
+    m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+    if (master->getLevel() >= 78)
+        GC_Timer = 8;
+    else if (master->getLevel() >= 70)
+        GC_Timer = 10;
+    else if (master->getLevel() >= 50)
+        GC_Timer = 12;
+    else if (master->getLevel() >= 35)
+        GC_Timer = 14;
+    else if (master->getLevel() >= 25)
+        GC_Timer = 16;
+    else if (master->getLevel() >= 15)
+        GC_Timer = 18;
+    else
+        GC_Timer = 20;
+
+    //GC_Timer = 10;//1.0 sec (little haste)
+    DoCast(victim, spellId, triggered);
+    return true;
+} 
+//   end DOCAST
+
+void bot_ai::CureGroup(Unit *pTarget)
+{
+    if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return;
+    std::list<Unit*> unitList;
+    pTarget->GetRaidMember(unitList,30);
+    if (unitList.empty()) return;
+    uint8 Bots = 0;
+    for(std::list<Unit*>::iterator itr = unitList.begin(); itr!=unitList.end(); ++itr)
+    {
+        Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL) continue;
+        if (tPlayer->isDead() && !tPlayer->HaveBot()) continue;
+        if (m_creature->GetDistance(tPlayer) > 30) continue;
+        if (tPlayer->HaveBot())
+                Bots++;
+        CureTarget(tPlayer);
+    }
+    if (Bots == 0) return;
+    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr)
+    {
+        Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature *cre = tPlayer->GetBotMap()[i].m_creature;
+            if (!cre || !cre->IsInWorld() || m_creature->GetDistance(cre) > 30) continue;
+            CureTarget(cre);
+        }
+    }
+}
+
+bool bot_ai::CureTarget(Unit *dTarget)
+{
+    if (m_creature->getLevel() < 20) return false;
+    if (!dTarget || dTarget->isDead()) return false;
+    if (!isTimerReady(GC_Timer)) return false;
+    if (m_creature->GetDistance(dTarget) > 30) return false;
+    if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+    Unit::AuraMap const& auras = dTarget->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+    {
+        Aura *aura = itr->second;
+        if (aura->GetId() == 64844 || //Divine Hymn
+            aura->GetId() == 6346) // Fear Ward
+            continue;
+        DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+        if (dispel != DISPEL_MAGIC && 
+            dispel != DISPEL_POISON && 
+            dispel != DISPEL_DISEASE && 
+            dispel != DISPEL_CURSE)
+            continue;
+        AuraApplication * aurApp = aura->GetApplicationOfTarget(dTarget->GetGUID());
+        if (!aurApp)
+            continue;
+        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE)) : false;
+        if (!positive && (dTarget->IsFriendlyTo(master) || IsInBotParty(dTarget)))//IF NEGATIVE
+            if (isTimerReady(GC_Timer) && HandleCure(dispel, dTarget))
+                return true;
+    }
+    return false;
+}
+
+void bot_ai::setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force)
+{
+    if (myrace==0) return;
+
+    if (force || m_creature->getLevel() != master->getLevel())
+        m_creature->SetLevel(mylevel);
+
+    //DATABASE STATS
+    PlayerClassLevelInfo classinfo;
+    sObjectMgr->GetPlayerClassLevelInfo(myclass, mylevel, &classinfo);
+
+    if (m_creature->getFaction() != master->getFaction())
+        m_creature->setFaction(master->getFaction());
+
+    for (int i = STAT_STAMINA; i < MAX_STATS; i++)
+        m_creature->SetCreateStat(Stats(i), master->GetTotalStatValue(Stats(i))/10.0f*8.0f);//80% stats goes to bot
+    
+    float class_mod = 0.0f;
+    float val2 = 0.0f;
+    float level = float(mylevel);
+    float mLevelMult = level/16.0f >= 1.0f ? level/16.0f : 1.0f;
+
+    switch(myclass)
+    {
+    case CLASS_WARRIOR:       val2 = level * mLevelMult*1.5f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*2.0f; class_mod = 1.3f; break;
+    case CLASS_DEATH_KNIGHT:  val2 = level * mLevelMult*1.5f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*1.7f; class_mod = 1.0f; break;
+    case CLASS_PALADIN:       val2 = level * mLevelMult*1.5f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*1.5f; class_mod = 0.9f; break;
+    case CLASS_ROGUE:         val2 = level * mLevelMult*1.1f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*0.5f + (m_creature->GetStat(STAT_AGILITY) - 20.0f)*0.8f; class_mod = 0.4f; break;
+    case CLASS_HUNTER:        val2 = level * mLevelMult*1.3f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*1.0f + (m_creature->GetStat(STAT_AGILITY) - 20.0f)*1.0f; class_mod = 0.7f; break;
+    case CLASS_SHAMAN:        val2 = level * mLevelMult*1.2f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*0.7f + (m_creature->GetStat(STAT_AGILITY) - 20.0f)*1.2f; class_mod = 0.6f; break;
+    case CLASS_DRUID:
+    case CLASS_MAGE:
+    case CLASS_PRIEST:
+    case CLASS_WARLOCK:       val2 = level * mLevelMult*0.5f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*0.5f; class_mod = 0.2f; break;
+    case 15:/*BEAR*/          val2 = level * mLevelMult*1.4f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*2.0f; class_mod = 0.9f; break;
+    case 25:/*CAT*/           val2 = level * mLevelMult*1.0f + (m_creature->GetStat(STAT_AGILITY)  - 20.0f)     ; class_mod = 0.5f; break;
+    default:                  val2 = level * mLevelMult*1.0f + (m_creature->GetStat(STAT_STRENGTH) - 20.0f)*1.0f; class_mod = 1.0f;
+    }
+
+    uint32 stat = 0;
+    uint32 oldstat = 0;
+    for (uint8 i = 0; i < MAX_STATS; i++)
+    {
+        uint32 newstat = uint32(master->GetTotalStatValue(Stats(i)));
+        if (newstat > stat)
+        { oldstat = stat; stat = newstat; }//Get Hightest stat
+        if (stat > 4000)//cheaty case ,I mean case of raid stats
+        { stat = oldstat > 3000 ? oldstat : oldstat > 2000 ? oldstat + 1000 : oldstat > 1000 ? oldstat + 2000 : oldstat; break; }
+    }
+
+    //bot must benefit from master's damage
+    float min = master->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+    float max = master->GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+    float mid = (min+max)/2.0f/8.0f;//1/7 of master's average damage goes to bot (it is also multiplied by dmg_mult in DB, 1x-1.4x)
+    if (mid < 10.0f) mid = 10.0f;//too small damage
+
+    UnitMods mod = UNIT_MOD_ATTACK_POWER;
+    float attPowerMult = master->GetModifierValue(mod, BASE_PCT);
+    float attPowerMultTotal = master->GetModifierValue(mod, TOTAL_PCT);
+    attPowerMult = attPowerMult ? attPowerMult : 1.0f;
+    attPowerMultTotal = attPowerMultTotal ? attPowerMultTotal : 1.0f;
+
+    float bonus = float(stat)/8.0f * attPowerMult * attPowerMultTotal * class_mod;//bonus from total stats multiplied by master (dependance)
+
+    //!!!!!!!!!!!!!!!!!!!!!!
+    float DAMAGE = val2 + (mid + bonus)*class_mod;//!!!
+    DAMAGE *= 1.2f;//additional total damage mod
+    //!!!!!!!!!!!!!!!!!!!!!!
+
+    m_creature->SetBaseWeaponDamage (BASE_ATTACK, MINDAMAGE, DAMAGE - DAMAGE/7.0f);
+    m_creature->SetBaseWeaponDamage (BASE_ATTACK, MAXDAMAGE, DAMAGE);
+    m_creature->SetStatFloatValue(UNIT_FIELD_MINDAMAGE, DAMAGE - DAMAGE/7.0f);
+    m_creature->SetStatFloatValue(UNIT_FIELD_MAXDAMAGE, DAMAGE);
+    if (m_creature->CanDualWield())
+    {
+        m_creature->SetBaseWeaponDamage (OFF_ATTACK, MINDAMAGE, (DAMAGE - DAMAGE/7.0f)/2.0f);
+        m_creature->SetBaseWeaponDamage (OFF_ATTACK, MAXDAMAGE, DAMAGE/2.0f);
+        m_creature->SetStatFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE, (DAMAGE - DAMAGE/7.0f)/2.0f);
+        m_creature->SetStatFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE, DAMAGE/2.0f);
+    }
+    if (myclass == CLASS_HUNTER)
+    {
+        m_creature->SetBaseWeaponDamage (RANGED_ATTACK, MINDAMAGE, (DAMAGE - DAMAGE/7.0f)*1.3f);
+        m_creature->SetBaseWeaponDamage (RANGED_ATTACK, MAXDAMAGE, DAMAGE*1.3f);
+        m_creature->SetStatFloatValue(UNIT_FIELD_MINRANGEDDAMAGE, (DAMAGE - DAMAGE/7.0f)*1.3f);
+        m_creature->SetStatFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE, DAMAGE*1.3f);
+    }
+
+    /*sLog->outBasic ("udpating BASE ATTACK FOR Bot : %s", m_creature->GetName());
+    sLog->outBasic ("mLevelMult = %f", mLevelMult);
+    sLog->outBasic ("class_mod = %f", class_mod);
+    sLog->outBasic ("chosen stat value = %f", float(stat));
+    sLog->outBasic ("val2 = %f", val2);
+    sLog->outBasic ("bonus damage = %f", bonus);
+    sLog->outBasic ("attPowerMult(total) = %f", attPowerMult*attPowerMultTotal);
+    sLog->outBasic ("master's min damage = %f", min);
+    sLog->outBasic ("master's max damage = %f", max);
+    sLog->outBasic ("master's mid damage(divided by 7) = %f", mid);
+    sLog->outBasic ("val2 + mid + bonus = %f", val2 + mid + bonus);
+    sLog->outBasic ("\tmin damage = %f", DAMAGE - DAMAGE/7.0f);
+    sLog->outBasic ("\tmax/base damage = %f", DAMAGE);
+*/
+    mod = UNIT_MOD_ARMOR;
+    float value = master->GetTotalStatValue(STAT_AGILITY)*5.0f;    // armor bonus from stats
+    value += master->GetModifierValue(mod, BASE_VALUE);             // base armor (from items)
+    value *= master->GetModifierValue(mod, BASE_PCT);               // armor percent from items
+    value += master->GetModifierValue(mod, TOTAL_VALUE);
+    value *= master->GetModifierValue(mod, TOTAL_PCT);
+
+    //Custom armor system
+    value = value*class_mod + master->GetArmor();
+    m_creature->SetArmor(int32(value));
+
+    //Set hp/mana depending on master's and my stats
+    pct = GetHealthPCT(m_creature, true) + 2;//(save pct)
+    if (pct > 100) pct = 100;
+
+    m_basehp = classinfo.basehealth;
+
+    //here we set rate from stamina (pretty sensitive)
+    float stammod = 10.0f;
+    switch(myclass)
+    {
+    case CLASS_DEATH_KNIGHT: case CLASS_PALADIN:
+        switch(master->getClass())
+        {
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            stammod = 13.0f; break;
+        case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            stammod = 11.0f; break;
+        default:
+            stammod = 9.5f; break;
+        }
+        break;
+    case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+        switch(master->getClass())
+        {
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            stammod = 9.5f; break;
+        case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            stammod = 8.0f; break;
+        default:
+            stammod = 7.0f; break;
+        }
+        break;
+    case CLASS_DRUID: case 15: case 25: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+        switch(master->getClass())
+        {
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            stammod = 11.0f;; break;
+        case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            stammod = 9.5f; break;
+        default:
+            stammod = 7.5f; break;
+        }
+        break;
+    case CLASS_WARRIOR:
+        switch(master->getClass())
+        {
+        case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+            stammod = 14.0f;; break;
+        case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+            stammod = 12.0f;; break;
+        default:
+            stammod = 8.5f;; break;
+        }
+        break;
+    default:
+        stammod = 10.0f; break;
+    }
+    if (master->Has310Flyer(false)) stammod += 2.0f;
+    stammod -= float(master->GetNpcBotsCount() - 1 > 0 ? master->GetNpcBotsCount() - 1 : 0);//more 2x bots -- less hp
+
+    //insert some randomness(making hp unique for each bot of each player)
+    //modifying this can change bot's hp down to the crash
+    uint32 hp_add = 0;
+    if (mylevel >= 10)
+    {
+        hp_add += uint32(m_creature->GetTotalStatValue(STAT_STAMINA))*uint32(stammod);
+        hp_add -= m_creature->getGender()*2*mylevel;//less hp for females
+        if (mylevel >= 20)
+            hp_add -= master->GetNpcBotSlot(m_creature->GetGUID())*mylevel;//more bots -- less hp
+    }
+    m_totalhp = (m_basehp + hp_add) * (master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) * m_creature->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    m_creature->SetMaxHealth(m_totalhp);
+
+    if (force) m_creature->SetHealth(m_creature->GetMaxHealth());//set max on init
+    else m_creature->SetHealth(m_creature->GetMaxHealth() * pct / 100);//restore pct
+
+    if (myclass == CLASS_WARRIOR || myclass == CLASS_ROGUE || myclass == CLASS_DEATH_KNIGHT || myclass == 15 || myclass == 25)
+        return;
+
+    pct = GetManaPCT(m_creature, true) + urand(2,3);//1-2% of base mana every tick (uint calc always -=1)
+    if (pct > 100) pct = 100;
+
+    m_basemana = classinfo.basemana;
+    m_creature->SetCreateMana(m_basemana);//solve mana usage problem
+    m_creature->SetBotBaseMana(m_basemana);
+    uint8 manamod = 15;//here we set mana multiplier from intellect as we gain mana from MASTER's intellect mostly
+    switch (myclass)
+    {
+    case CLASS_PALADIN: case CLASS_HUNTER: manamod = 9;   break;
+    case CLASS_SHAMAN:                     manamod = 12;  break;
+    case CLASS_DRUID:                      manamod = 14;  break;
+    case CLASS_PRIEST:                     manamod = 15;  break;
+    case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 13;  break;
+    default:                               manamod = 0;   break;
+    }
+    if (mylevel < 20)
+        manamod /= (20 - mylevel);
+    //sLog->outBasic("Manamod: %u", manamod);
+    //sLog->outBasic("Got base mana level for my class: %u", m_basemana);
+    if (m_creature->GetTotalStatValue(STAT_INTELLECT) + m_creature->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT) > stat/3*2)
+        m_basemana += uint32(m_creature->GetTotalStatValue(STAT_INTELLECT))/5*3*manamod;
+    else
+        m_basemana += stat*manamod/5*3;
+    //sLog->outBasic("base mana + mana from intellect: %u", m_basemana);
+    m_basemana += uint32(m_creature->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT))*3*manamod;
+    //sLog->outBasic("base mana + mana from intellect + buffs: %u", m_basemana);
+    //mana += uint32(master->GetTotalStatValue(STAT_INTELLECT))/10*manamod;//another 0.1 of master's intellect gain
+    m_basemana += m_creature->getGender()*2*mylevel;
+    m_basemana -= master->GetNpcBotSlot(m_creature->GetGUID())*mylevel;
+    m_basemana += m_creature->GetMaxHealth()/50;//2% of hp goes to mana 
+    m_totalmana = m_basemana;
+
+    m_creature->SetMaxPower(POWER_MANA, m_totalmana);
+    if (force) m_creature->SetPower(POWER_MANA, m_creature->GetMaxPower(POWER_MANA));//set to max on init
+    else m_creature->SetPower(POWER_MANA, m_creature->GetMaxPower(POWER_MANA) * pct / 100);//restore pct
+
+    //sLog->outBasic("Got base mana level for my class: %u", m_basemana);
+    //sLog->outBasic("Calculated total mana for level %u: %f", mylevel, leveledmana/divider);
+    //sLog->outBasic("Stat: %u", stat);
+    //sLog->outBasic("Manamod: %u", manamod);
+    //sLog->outBasic("Base Mana: %u", m_basemana);
+    //sLog->outBasic("Max Mana to set (+= master's int/10): %u", m_totalmana);
+}
+
+void bot_ai::ReceiveEmote(Player *player, uint32 emote)
+{
+    // debug to see what auras are on bot
+    if (emote == TEXT_EMOTE_BONK)
+        listAuras(m_creature);
+
+    // debug to see what auras are on me
+    if (emote == TEXT_EMOTE_SALUTE)
+        listAuras(player);
+
+    if (emote == TEXT_EMOTE_STAND)
+    {
+        if (m_creature->GetCharmerGUID() != player->GetGUID())
+        {
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+            return;
+        }
+        SetBotCommandState (COMMAND_STAY);
+        DoSay("Standing Still.",LANG_UNIVERSAL,player->GetGUID());
+    }
+
+    if (emote == TEXT_EMOTE_WAVE)
+    {
+        if (m_creature->GetCharmerGUID() != player->GetGUID())
+        {
+            m_creature->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+            return;
+        }
+        SetBotCommandState (COMMAND_FOLLOW);
+        DoSay("Following!",LANG_UNIVERSAL,player->GetGUID());
+    }
+
+    // buff the requester
+    if (emote == TEXT_EMOTE_BOW)
+    {
+        ReceiveBowEmote(player);
+    }
+} // end ReceiveEmote
+
+void bot_ai::ReceiveBowEmote(Player *player)
+{
+    if (!CCed(me) && player != master)
+    {
+       me->HandleEmoteCommand(EMOTE_ONESHOT_SHOUT);
+       me->MonsterYell("I have no buffs for you!",LANG_UNIVERSAL,player->GetGUID());
+    }
+}
+
+void bot_ai::DoSay(const char* text, const uint32 language,uint64 receiver)
+{
+    if (CCed(me)) return;
+
+    me->MonsterSay(text, language, receiver);
+}
+
+bool bot_ai::BossFight(bool checkcombat, bool checkalive)
+{
+    if (!master->GetMap()->Instanceable())
+    {
+        //sLog->outBasic("BossFight: requested for non-dungeon map %s",master->GetMap()->GetMapName());
+        return false;//do not waste time for search in non-instances
+    }
+
+    Creature *unit = NULL;
+    float dist = sWorld->GetMaxVisibleDistanceInInstances();
+    if (master->GetMap()->IsRaid())
+        dist += 80.0f;
+
+    //if (master->GetMapId() == 550)//Tempest Keep
+    //    checkcombat = false;
+    if (master->GetMapId() == 574)//Utgarde Keep
+        checkalive = false;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyHostileBossCheck check(master, dist, checkcombat, checkalive);
+    Trinity::CreatureLastSearcher <NearbyHostileBossCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::CreatureLastSearcher <NearbyHostileBossCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::CreatureLastSearcher <NearbyHostileBossCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    if (unit)
+    {
+        //sLog->outBasic("BossFight: Boss found by %s", master->GetName());
+        return true;
+    }
+    return false;
+}
+//Returns true if 'Mob in combat' or(if checked) 'Mobs corpse' found within dist
+bool bot_ai::Battle(float dist, bool checkcorpses)
+{
+    if (!master->getAttackers().empty() || !m_creature->getAttackers().empty())
+        return true;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    float olddist = 0.0f;
+
+    if (master->GetMap()->Instanceable())
+    {
+        olddist = dist;
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+    }
+
+    Creature *unit = NULL;
+
+    UnitsInCombatCheck check(master, dist);
+    Trinity::CreatureLastSearcher <UnitsInCombatCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::CreatureLastSearcher <UnitsInCombatCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::CreatureLastSearcher <UnitsInCombatCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    if (unit)
+    {
+        //sLog->outBasic("Battle: Mob in combat found by %s in 40 yards", master->GetName());
+        return true;
+    }
+
+    if (!checkcorpses)
+        return false;
+
+    if (olddist > 0)
+        dist = olddist;
+
+    NearbyCorpseCheck ccheck(master, dist);
+    Trinity::CreatureLastSearcher <NearbyCorpseCheck> csearcher(master, unit, ccheck);
+
+    TypeContainerVisitor<Trinity::CreatureLastSearcher <NearbyCorpseCheck>, WorldTypeMapContainer > cworld_unit_searcher(csearcher);
+    TypeContainerVisitor<Trinity::CreatureLastSearcher <NearbyCorpseCheck>, GridTypeMapContainer >  cgrid_unit_searcher(csearcher);
+
+    cell.Visit(p, cworld_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, cgrid_unit_searcher, *master->GetMap(), *master, dist);
+
+    if (unit)
+    {
+        //sLog->outBasic("Battle: Corpse found by %s in 40 yards", master->GetName());
+        return true;
+    }
+
+    return false;
+}
+//This is used to find target for priest's dispels and mage's spellsteal
+//Will return any dispellable/stealable 'Hostile Creature In Combat'
+//or 'Hostile Player'
+Unit *bot_ai::FindHostileDispelTarget(float dist, bool stealable)
+{
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    HostileDispelTargetCheck check(m_creature, dist, stealable);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    //if (unit)
+    //{
+        //sLog->outBasic("Battle: Mob in combat found by %s in %u yards", master->GetName(), master->GetDistance(unit));
+        //return true;
+    //}
+    //return false;
+    return unit;
+}
+
+//Finds single target affected by given spell (and given caster if is)
+//Can check 
+//    hostile targets  (hostile = 0) <by default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit *bot_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile)
+{
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    AffectedTargetCheck check(sObjectAccessor->FindUnit(caster), dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    if (unit)
+    {
+        /*const char *ch;
+        if (caster)
+            ch = caster->GetName();
+        else
+            ch = "someone";
+        sLog->outBasic("FindAffectedTarget: Found unit affected by %s's spell(%u)", ch, spellId);
+    */}
+    return unit;
+}
+//Finds target for mage's polymorph
+Unit *bot_ai::FindPolyTarget(float dist)
+{
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    PolyUnitCheck check(m_creature, dist);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    return unit;
+}
+//Finds target for warlock's fear
+Unit *bot_ai::FindFearTarget(float dist)
+{
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    FearUnitCheck check(m_creature, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit *bot_ai::FindRepentanceTarget(float dist)
+{
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    StunUnitCheck check(m_creature, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit *bot_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/)
+{
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    UndeadCCUnitCheck check(m_creature, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    return unit;
+}
+//Finds casting target (friend of enemy)
+Unit *bot_ai::FindCastingTarget(float dist, bool isFriend, uint32 spellId)
+{
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    CastingUnitCheck check(m_creature, dist, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    return unit;
+}
+//Returns target for AOE spell (blizzard, hurricane etc.) based on attackers can also check npcbots
+Unit *bot_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend)
+{
+    Unit *unit = NULL;
+
+    std::list<Unit*> unitList;
+    master->GetRaidMember(unitList,30);
+    if (unitList.empty()) return NULL;
+    uint8 Bots = 0;
+    for(std::list<Unit*>::iterator itr = unitList.begin(); itr!=unitList.end(); ++itr)
+    {
+        Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+        if (!tPlayer || tPlayer->isDead()) continue;
+        if (tPlayer->isDead() && checkbots && !tPlayer->HaveBot()) continue;
+        if (m_creature->GetDistance(tPlayer) > 30) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots++;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->IsPolymorphed()) continue;
+                if (m_creature->GetDistance(*iter) < 30)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit *u = tPlayer->getVictim();
+                if (u && tPlayer->GetDistance(u) > 5)
+                    unit = u;
+                else if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        float mydist = 30.0f;
+                        if (!(*iter) || (*iter)->isDead()) continue;
+                        if (tPlayer->GetDistance(*iter) < mydist)
+                        {
+                            mydist = tPlayer->GetDistance(*iter);
+                            unit = (*iter);
+                        }
+                    }
+                }
+                //return unit;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (unit) return unit;
+    if (Bots == 0) return NULL;
+    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr)
+    {
+        Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature *bot = tPlayer->GetBotMap()[i].m_creature;
+            if (!bot || bot->isDead() || !bot->IsInWorld() || m_creature->GetDistance(bot) > 30) continue;
+        //Creature *bot = tPlayer->GetBot();
+        //if (!bot || bot->isDead()) continue;
+        //if (m_creature->GetDistance(bot) > 30) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->IsPolymorphed()) continue;
+                    if (m_creature->GetDistance(*iter) < 30)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit *u = bot->getVictim();
+                    if (u && bot->GetDistance(u) > 5)
+                        unit = u;
+                    else if (targetfriend == true)
+                        unit = bot;
+                    else
+                    {
+                        for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                        {
+                            float mydist = 30.0f;
+                            if (!(*iter) || (*iter)->isDead()) continue;
+                            if (bot->GetDistance(*iter) < mydist)
+                            {
+                                mydist = tPlayer->GetDistance(*iter);
+                                unit = (*iter);
+                            }
+                        }
+                    }
+                    //return unit;
+                }//end for
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+
+Unit *bot_ai::FindSplashTarget(float dist)
+{
+    Unit *unit2 = m_creature->SelectNearbyTarget(dist);
+    if (!unit2)
+        return NULL;
+    Unit *u = m_creature->getVictim();
+    if (u && m_creature->GetDistance(u) > dist)
+        return NULL;
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    SecondEnemyCheck check(m_creature, dist);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(m_creature, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    if (unit && unit != unit2 && unit->GetDistance(unit2) <= dist)//additional check(maybe unneccessary)
+        return unit;//now we have 2 separate targets close to each other
+    else
+        return NULL;
+}
+
+bool bot_ai::IsInBotParty(Unit *unit)
+{
+    if (!unit) return false;
+    Creature *cre = unit->ToCreature();
+    if (cre && cre->isWorldBoss()) return false;
+    Unit *owner = unit->GetCharmerOrOwner();
+    if (owner && owner->ToPlayer() && 
+        owner->ToPlayer()->GetSession()->GetAccountId() == master->GetSession()->GetAccountId())//npcbot or me or npcbot's pet
+        return true;
+    Player *plr = unit->ToPlayer();
+    if (plr && plr->GetSession()->GetAccountId() == master->GetSession()->GetAccountId())//playerbot or master
+        return true;
+    return false;
+}
+
+//PASSIVES
+bool bot_ai::RefreshAura(uint32 spell, uint8 count, Unit *target)
+{
+    if (!target) target = m_creature;
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (target->HasAura(spell))
+        target->RemoveAurasDueToSpell(spell);
+    for(uint8 i = 0; i < count; ++i)
+        target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+    return true;
+}
+//PASSIVES
+void bot_ai::CheckAuras()
+{
+    if (checkAurasTimer > 0) return;
+
+    //update speeds
+    float speed = 0.0f;
+    float speedbonus = 0.0f;
+    if      (m_creature->GetDistance(master) > 50.0f) speedbonus = 0.5f;
+    else if (m_creature->GetDistance(master) > 30.0f) speedbonus = 0.2f;
+    else if (m_creature->GetDistance(master) > 10.0f) speedbonus = 0.1f;
+    speed = master->GetSpeedRate(MOVE_WALK) + 0.1f;
+    if (speed > 1.2f) speed = 1.2f;
+    if (speed_walk != speed + speedbonus) m_creature->SetSpeed(MOVE_WALK, speed + speedbonus);
+    speed = master->GetSpeedRate(MOVE_RUN) + 0.1f;
+    if (speed > 2.5f) speed = 2.5f;
+    if (speed_run != speed + speedbonus) m_creature->SetSpeed(MOVE_RUN, speed + speedbonus);
+    speed = master->GetSpeedRate(MOVE_SWIM) + 0.1f;
+    if (speed > 1.5f) speed = 1.5f;
+    if (speed_swim != speed + speedbonus) m_creature->SetSpeed(MOVE_SWIM, speed + speedbonus);
+    speed_walk = m_creature->GetSpeedRate(MOVE_WALK);
+    speed_run  = m_creature->GetSpeedRate(MOVE_RUN);
+    speed_swim = m_creature->GetSpeedRate(MOVE_SWIM);
+    if (pet != NULL && pet->IsInWorld())
+    {
+        pet->SetSpeed(MOVE_WALK, speed_walk + 0.3f);
+        pet->SetSpeed(MOVE_RUN, speed_run + 0.3f);
+        pet->SetSpeed(MOVE_SWIM, speed_swim + 0.3f);
+    }
+
+    setStats(m_creature->GetBotClass(), m_creature->GetBotRace(), master->getLevel());
+
+    if (m_creature->GetDistance(master) > 6 && m_creature->GetBotCommandState() != COMMAND_STAY && m_creature->GetBotCommandState() != COMMAND_ATTACK)
+        SetBotCommandState(COMMAND_FOLLOW);
+    if (!m_creature->InSamePhase(master))
+        m_creature->SetPhaseMask(master->GetPhaseMask(), true);
+
+    //aggro mods and regen for pets
+    //57339 - Tank Class Passive Threat +43%
+    if (pet != NULL && pet->isAlive())
+    {
+        switch(m_creature->GetBotClass())
+        {
+        case CLASS_WARLOCK:
+            switch(pet->GetEntry())//hack - for now
+            {
+            case 60237: RefreshAura(57339, 2, pet); break;// voidwalker pet
+            default: break;
+            }
+            break;
+        case CLASS_HUNTER:
+            switch(pet->GetEntry())
+            {
+            case 60238: RefreshAura(57339, 1, pet); break;//bird pet
+            default: break;
+            }
+            break;
+        default:
+            break;
+        }
+        //pet will regenerate only OOC
+        if (!pet->isInCombat() && pet->GetHealth() != pet->GetMaxHealth())
+        {
+            uint8 pct = GetHealthPCT(pet);
+            if (pct < 99) pct += 2;
+            else if (pct < 100) pct = 100;
+            pet->SetHealth(pet->GetMaxHealth() * pct /100);
+        }
+    }
+
+    --clear_cd;
+    if (clear_cd <= 0)
+    {
+        if (oldtank != tank)
+            oldtank = tank;
+        tank = NULL;
+        FindTank();
+        clear_cd = 5;//every 15 seconds
+    }
+}
+
+Unit *bot_ai::getTarget()
+{
+    opponent = NULL;
+
+    //this needed to get pet's attackers as topaggro if no target found
+    if (pet != NULL)
+    {
+        AttackerSet p_attackers = pet->getAttackers();
+        if (!p_attackers.empty())
+        {
+            for(AttackerSet::iterator itr = p_attackers.begin(); itr != p_attackers.end(); ++itr)
+            {
+                if ((*itr) && (*itr)->isAlive() && m_creature->getThreatManager().getThreat(*itr) <= 0.01f)
+                {
+                    m_creature->AddThreat((*itr), 0.01f);
+                    (*itr)->AddThreat(m_creature, 0.01f);
+                }
+            }
+        }
+    }
+
+    Unit *u = m_creature->getVictim();
+    if (u && !u->isTargetableForAttack())
+    {
+        m_creature->AttackStop();
+        Follow();
+        //m_creature->SendUpdateToPlayer(master);
+    }
+    u = master->getVictim();
+    if (u && u->isTargetableForAttack() && master->isInCombat())
+        opponent = u;
+
+    if (!opponent)
+    {
+        Unit *aTarget = SelectTarget(SELECT_TARGET_TOPAGGRO);
+        u = NULL;
+        if (aTarget)
+            u = aTarget->getVictim();
+        if (aTarget && aTarget->isTargetableForAttack() && u && IsInBotParty(u))
+            opponent = aTarget;
+    }
+    //ResetOrGetNextTarget();
+    if (!opponent)
+    {
+        Unit *bTarget = NULL;
+        float dist = 35;
+
+        CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+        Cell cell(p);
+        cell.SetNoCreate();
+
+        NearestHostileUnitCheck check(m_creature, dist);
+        Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(m_creature, bTarget, check);
+
+        TypeContainerVisitor<Trinity::UnitLastSearcher <NearestHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+        TypeContainerVisitor<Trinity::UnitLastSearcher <NearestHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+        cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+        cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+        if (bTarget)
+            u = bTarget->getVictim();
+        if (bTarget && bTarget->isTargetableForAttack() && u && IsInBotParty(u))
+            opponent = bTarget;
+    }
+    return opponent;
+}
+
+void bot_ai::assistMaster(Unit *me)
+{
+    if (!me)
+        me = m_creature;
+    Unit *u = master->getVictim();
+    Unit *u2 = me->getVictim();
+    if (u && (u2 != u || opponent != u))
+    {
+        if (!u2)
+            u2 = opponent;
+        float threat = 10.0f;
+        if (u2)
+        {
+            threat = me->getThreatManager().getThreat(u2);
+            if (threat > 15.0f)
+                me->getThreatManager().modifyThreatPercent(u2, -98);
+            //me->AttackStop();
+        }
+        me->getThreatManager().addThreat(u, threat);
+        if (me == m_creature)
+            opponent = u;
+        //m_creature->getThreatManager().tauntApply(master->getVictim());
+    }
+    else/* if (me == m_creature)*/
+    {
+        u = me->getVictim();
+        if (u && u->isTargetableForAttack())
+            opponent = u;
+    }
+}
+
+bool bot_ai::CheckTarget(Unit *target)
+{
+    if (target && !target->IsInWorld()) return false;
+    if (target && !target->InSamePhase(master)) return false;
+    if ((!target || !target->isTargetableForAttack()) && !IsEvent())
+    {
+        if (target && target->getAttackers().size() <= 1)
+            target->CombatStop();
+        m_creature->AttackStop();
+        m_creature->CombatStop();
+        opponent = NULL;
+        if (master->isInCombat())
+            master->CombatStop();
+        Follow();
+        DoNonCombatActions();
+        ResetOrGetNextTarget();                    
+        return false;
+    }
+    return true;
+}
+
+void bot_ai::ChangeTarget(Unit* target, float dist)
+{
+    if (!target) return;
+    Unit *bTarget = NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(m_creature->GetPositionX(), m_creature->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearestHostileUnitCheck check(m_creature, dist, target);//we pointing our current target
+    Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(m_creature, bTarget, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <NearestHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <NearestHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+    cell.Visit(p, grid_unit_searcher, *m_creature->GetMap(), *m_creature, dist);
+
+    if (bTarget)
+    {
+        Unit *u = bTarget->getVictim();
+        if (bTarget && bTarget->isTargetableForAttack() && u && IsInBotParty(u))
+            opponent = bTarget;
+    }
+    else
+        opponent = target;
+
+
+    if (opponent != target)
+    {
+        float threat = 10.0f;
+        if (target)
+        {
+            threat = me->getThreatManager().getThreat(target);
+            if (threat > 15.0f)
+                me->getThreatManager().modifyThreatPercent(target, -98);
+        }
+        m_creature->getThreatManager().addThreat(opponent, threat);
+    }
+}
+
+void bot_ai::healOthers()
+{
+    Unit *target = DoSelectLowestHpFriendly(40, 5500);
+    if (!target)
+        target = DoSelectLowestHpFriendly(40, 2500);
+    if (!target)
+        target = DoSelectLowestHpFriendly(40, 1500);
+    if (!target)
+        target = DoSelectLowestHpFriendly(40, 500);
+    if (target && target != m_creature && !target->IsHostileToPlayers() && (target->GetInstanceScript() || IsInBotParty(target)))
+        HealTarget(target, GetHealthPCT(target));
+}
+
+void bot_ai::ApplyPassives(Classes m_class)
+{
+    m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+    uint8 level = master->getLevel();
+
+    //apply +healing TAKEN (+40% Blood of Rhino rank 2)
+    if (level >= 40)
+        RefreshAura(53482);
+
+    //apply aggro mod
+    switch(m_class)
+    {
+    case CLASS_PALADIN:
+        break;
+    case CLASS_PRIEST:
+        RefreshAura(21184,3);//-87%
+        break;
+    default:
+        RefreshAura(21184,2);//-54%
+        break;
+    }
+
+    //***Common Passives***\\
+    //mana regen
+    if (m_class != CLASS_ROGUE && m_class != CLASS_DEATH_KNIGHT && m_class != CLASS_WARRIOR)
+    {
+        if      (level >= 80) RefreshAura(MANAREGEN2,8);
+        else if (level >= 79) RefreshAura(MANAREGEN2,7);
+        else if (level >= 78) RefreshAura(MANAREGEN2,6);
+        else if (level >= 77) RefreshAura(MANAREGEN2,5);
+        else if (level >= 76) RefreshAura(MANAREGEN2,4);
+        else if (level >= 75) RefreshAura(MANAREGEN2,3);
+        else if (level >= 74) RefreshAura(MANAREGEN2,2);
+        else if (level >= 73) RefreshAura(MANAREGEN2,1);
+    }
+
+    //spd
+    //the biggest problem here was moment when bot ACCIDENTLY gains hundreds of spellpower
+    switch(m_class)
+    {
+    case CLASS_DRUID:
+        if      (level >= 78) RefreshAura(SPELL_BONUS_700, 5); //3500
+        else if (level >= 75) RefreshAura(SPELL_BONUS_700, 4); //2800
+        else if (level >= 68) RefreshAura(SPELL_BONUS_700, 3); //2100
+        else if (level >= 58) RefreshAura(SPELL_BONUS_700, 2); //1400
+        else if (level >= 45) RefreshAura(SPELL_BONUS_700, 1); //700
+        else if (level >= 40) RefreshAura(SPELL_BONUS_150, 2); //300
+        else if (level >= 35) RefreshAura(SPELL_BONUS_150, 1); //150
+        else if (level >= 30) RefreshAura(SPELL_BONUS_50 , 1); //50
+        break;
+    case CLASS_MAGE:
+        RefreshAura(FIREDAM_86, level/15); //x5 (86,172,258,344,430)
+        if      (level >= 78) RefreshAura(SPELL_BONUS_400, 2); //922
+        else if (level >= 75){RefreshAura(SPELL_BONUS_400, 1); RefreshAura(SPELL_BONUS_250, 1);} //461 + 250 = 711
+        else if (level >= 68) RefreshAura(SPELL_BONUS_400, 1); //461
+        else if (level >= 58) RefreshAura(SPELL_BONUS_250, 1); //250
+        else if (level >= 45) RefreshAura(SPELL_BONUS_150, 1); //150
+        else if (level >= 35) RefreshAura(SPELL_BONUS_50,  1); //50
+        break;
+    case CLASS_PRIEST:
+        if      (level >= 78) RefreshAura(SPELL_BONUS_950, 4); //3800
+        else if (level >= 77){RefreshAura(SPELL_BONUS_950, 3); RefreshAura(SPELL_BONUS_250, 3);} //2850 + 750 = 3600
+        else if (level >= 76){RefreshAura(SPELL_BONUS_950, 3); RefreshAura(SPELL_BONUS_250, 1); RefreshAura(SPELL_BONUS_150, 1);} //2850 + 400 = 3250
+        else if (level >= 75) RefreshAura(SPELL_BONUS_950, 3); //2850
+        else if (level >= 72){RefreshAura(SPELL_BONUS_950, 2); RefreshAura(SPELL_BONUS_250, 2);} //1900 + 500 = 2400
+        else if (level >= 68) RefreshAura(SPELL_BONUS_950, 2); //1900
+        else if (level >= 65) RefreshAura(SPELL_BONUS_700, 2); //1400
+        else if (level >= 58) RefreshAura(SPELL_BONUS_700, 1); //700
+        else if (level >= 55) RefreshAura(SPELL_BONUS_250, 2); //500
+        else if (level >= 45) RefreshAura(SPELL_BONUS_250, 1); //250
+        else if (level >= 35) RefreshAura(SPELL_BONUS_150, 1); //150
+        else if (level >= 30) RefreshAura(SPELL_BONUS_50,  1); //50
+        break;
+    case CLASS_PALADIN:
+        if      (level >= 80) RefreshAura(SPELL_BONUS_950, 3); //2850
+        else if (level >= 78){RefreshAura(SPELL_BONUS_950, 2); RefreshAura(SPELL_BONUS_250, 2);} //500 + 1900 = 2400
+        else if (level >= 75) RefreshAura(SPELL_BONUS_950, 2); //1900
+        else if (level >= 70){RefreshAura(SPELL_BONUS_950, 1); RefreshAura(SPELL_BONUS_250, 2);} //950 + 500 = 1450
+        else if (level >= 68) RefreshAura(SPELL_BONUS_950, 1); //950
+        else if (level >= 65) RefreshAura(SPELL_BONUS_700, 1); //700
+        else if (level >= 58) RefreshAura(SPELL_BONUS_250, 2); //500
+        else if (level >= 55){RefreshAura(SPELL_BONUS_250, 1); RefreshAura(SPELL_BONUS_150, 1);} //400
+        else if (level >= 45) RefreshAura(SPELL_BONUS_250, 1); //250
+        else if (level >= 40) RefreshAura(SPELL_BONUS_150, 1); //150
+        else if (level >= 35) RefreshAura(SPELL_BONUS_50,  1); //50
+        break;
+    default:
+        break;
+    }
+
+    // +crits, +haste, -damage taken
+    switch(m_class)
+    {
+    case CLASS_DRUID:
+        if      (level >= 78) RefreshAura(CRITS,5); //+25%
+        else if (level >= 75) RefreshAura(CRITS,4); //+20%
+        else if (level >= 58) RefreshAura(CRITS,3); //+15%
+        else if (level >= 35) RefreshAura(CRITS,2); //+10%
+        else if (level >= 15) RefreshAura(CRITS);   //+5%
+
+        if      (level >= 68) RefreshAura(SPELL_WARDING,3); //-30%
+        else if (level >= 45) RefreshAura(SPELL_WARDING,2); //-20%
+        else if (level >= 25) RefreshAura(SPELL_WARDING);   //-10%
+
+        if      (level >= 78) RefreshAura(HASTE,4); //+40%
+        else if (level >= 68) RefreshAura(HASTE,3); //+30%
+        else if (level >= 45) RefreshAura(HASTE,2); //+20%
+        else if (level >= 15) RefreshAura(HASTE);   //+10%
+        break;
+    case CLASS_MAGE:
+        if      (level >= 78) RefreshAura(HASTE,5); //+50%
+        else if (level >= 75) RefreshAura(HASTE,4); //+40%
+        else if (level >= 58) RefreshAura(HASTE,3); //+30%
+        else if (level >= 35) RefreshAura(HASTE,2); //+20%
+        else if (level >= 15) RefreshAura(HASTE);   //+10%
+
+        if      (level >= 78) RefreshAura(CRITS,5); //+25%
+        else if (level >= 68) RefreshAura(CRITS,4); //+20%
+        else if (level >= 45) RefreshAura(CRITS,3); //+15%
+        else if (level >= 25) RefreshAura(CRITS,2); //+10%
+        else if (level >= 15) RefreshAura(CRITS);   //+5%
+        break;
+
+    case CLASS_PRIEST:
+        if      (level >= 58) RefreshAura(SPELL_WARDING,3); //-30%
+        else if (level >= 35) RefreshAura(SPELL_WARDING,2); //-20%
+        else if (level >= 15) RefreshAura(SPELL_WARDING);   //-10%
+
+        if      (level >= 80) RefreshAura(HASTE,5); //+50%
+        else if (level >= 78) RefreshAura(HASTE,4); //+40%
+        else if (level >= 68) RefreshAura(HASTE,3); //+30%
+        else if (level >= 45) RefreshAura(HASTE,2); //+20%
+        else if (level >= 25) RefreshAura(HASTE);   //+10%
+
+        if      (level >= 78) RefreshAura(CRITS,4); //+20%
+        else if (level >= 68) RefreshAura(CRITS,3); //+15%
+        else if (level >= 45) RefreshAura(CRITS,2); //+10%
+        else if (level >= 25) RefreshAura(CRITS);   //+5%
+
+        if      (level >= 78) RefreshAura(HOLYCRIT,5); //+25%
+        else if (level >= 68) RefreshAura(HOLYCRIT,4); //+20%
+        else if (level >= 58) RefreshAura(HOLYCRIT,3); //+15%
+        else if (level >= 35) RefreshAura(HOLYCRIT,2); //+10%
+        else if (level >= 15) RefreshAura(HOLYCRIT);   //+5%
+        break;
+
+    case CLASS_PALADIN:
+        if      (level >= 75) RefreshAura(HASTE,4); //+40%
+        else if (level >= 58) RefreshAura(HASTE,3); //+30%
+        else if (level >= 35) RefreshAura(HASTE,2); //+20%
+        else if (level >= 25) RefreshAura(HASTE);   //+10%
+        break;
+
+    default:
+        break;
+    }
+}
+
+bool bot_ai::CheckImmunities(uint32 spell, Unit *target)
+{
+    if (target->IsHostileTo(master) && target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)))
+        return false;
+    //I Want to randomize chance of casting spell
+    //This needed to prevent double casts(mostly)
+    //it will be some burden on cpu as chance to not cast is high
+    //since here is so many bots possible
+    //this is the most rough (simple) variant
+    if (rand()%100 > 50) return false;
+    //if (spell != 10326 && target->IsImmunedToSpell(sSpellMgr->GetSpellInfo(spell)))
+    //    return false;
+    return true;
+}
+
+/*void DamageDealt(Unit* u, uint32 &damage, DamageEffectType)
+{
+    Creature* Victim = u->ToCreature();
+    if (Victim && !Victim->IsDamageEnoughForLootingAndReward())
+        Victim->LowerPlayerDamageReq(damage*3);
+    damage = 0;
+}*/
\ No newline at end of file
diff --git a/src/server/scripts/Bots/bot_ai.h b/src/server/scripts/Bots/bot_ai.h
new file mode 100644
index 0000000..1bd7128
--- /dev/null
+++ b/src/server/scripts/Bots/bot_ai.h
@@ -0,0 +1,627 @@
+#include "Group.h"
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#define SPELL_LEVEL ((int)m_creature->getLevel()/10)//!!!DO NOT CHANGE!!!
+
+#define MANAPOTION 58952 //32453
+#define MANA_CD 500
+#define HEALINGPOTION 15504
+
+#define MASS_DISPEL     32375
+#define CURE_DISEASE    552
+#define CURE_POISON     14253
+#define REMOVE_CURSE    2782//15729//475
+#define CLEANSE         4987
+//#define DEFIBRILLATE 54732
+//#define REVIVE 51918
+//#define BANDAGE 45544
+//#define POTIONCD 15000
+//#define FIRSTAID 61000
+//#define DRINK 66041
+//#define EAT 66478
+
+//COMMON PASSIVES
+#define SPELL_BONUS_50                  45011//50dd
+#define SPELL_BONUS_150                 28141//150dd
+#define SPELL_BONUS_250                 69709//250dd
+#define SPELL_BONUS_700                 35842//700dd
+#define SPELL_BONUS_400                 52810//461
+#define FIREDAM_86                      33816//86
+#define SPELL_BONUS_950                 35855//954
+#define MANAREGEN2                      35903//74 mp5
+#define SPELL_WARDING                   27904//rank 5 10% reduction
+#define HASTE/*Gift of the EarthMother*/51183//rank 5 10% haste
+#define CRITS/*Thundering Strikes-sham*/16305//rank 5 5% crit
+#define HOLYCRIT/*Holy Spec - Priest*/  15011//rank 5 5% holy crit
+
+//#define master ((Player*)m_creature->GetCharmer())
+
+typedef std::set<Unit *> AttackerSet;
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        bot_ai(Creature *c);
+        Creature *m_creature;
+        Creature *pet;
+        Player *master;
+        Unit *opponent;
+
+        virtual ~bot_ai();
+
+        //Heal the target
+        virtual bool HealTarget (Unit *target, uint8 hp) { return true; }
+        // Buff target
+        virtual bool BuffTarget(Unit *target) { return true; }
+        virtual void ReceiveBowEmote(Player *player);
+
+        // Cycles through the group to heal/buff/rezz
+        void BuffAndHealGroup(Player *gPlayer);
+        void RezGroup(uint32 REZZ, Player *gPlayer);
+
+        //Debug method to list the auras currently active.
+        //Use to find what spells were casted
+        bool listAuras(Unit *unit);
+
+        //More generalized method than HasAura().  It looks for
+        //any rank of the spell and it doesn't care which
+        //spell effect you want.  If it has the spell aura than
+        //it returns true
+        bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid=0);
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid=0);
+        //bool HasAuraIcon (Unit *unit, uint32 SpellIconID, uint64 casterGuid=0);
+
+        //std::string GetSpellName(uint32 spell_id);
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false);
+        bool isTimerReady(uint16 timer) {return (timer <= 0 && GC_Timer <= 0);}
+
+        void ResetOrGetNextTarget();
+
+        void DoSay(const char* text, const uint32 language = LANG_UNIVERSAL, uint64 receiver = 0);
+
+        bool IAmDead() { return (!master || ((master->isInCombat() || master->isDead()) && m_creature->isDead())); }
+
+        //ADDINGS
+        //Cure
+        void CureGroup(Unit *pTarget);
+        bool CureTarget(Unit *target);
+        virtual bool HandleCure(DispelType dispel, Unit *target) { return true; }
+        //end Cure
+
+        bool IsEvent(){ return (Battle() || BossFight()); }
+        bool BossFight(bool checkcombat = true, bool checkalive = true);
+        bool Battle(float dist = 45, bool checkcorpses = false);
+        Unit *FindHostileDispelTarget(float dist = 30, bool stealable = false);
+        Unit *FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0);
+        Unit *FindPolyTarget(float dist = 30);
+        Unit *FindFearTarget(float dist = 30);
+        Unit *FindRepentanceTarget(float dist = 20);
+        Unit *FindUndeadCCTarget(float dist = 30, uint32 spellId = 0);
+        Unit *FindCastingTarget(float dist = 10, bool isFriend = false, uint32 spellId = 0);
+        Unit *FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true);
+        Unit *FindSplashTarget(float dist = 7);
+        bool IsInBotParty(Unit *unit);
+        bool CCed(Unit *target = NULL, bool snare = false, bool checkdisarm = true)
+        {
+            if (!target)
+                target = m_creature;
+            if (snare) return
+                (target->HasAuraWithMechanic((1<<MECHANIC_FREEZE)|(1<<MECHANIC_SNARE)|(1<<MECHANIC_SHACKLE)|(1<<MECHANIC_CHARM)|(1<<MECHANIC_DISORIENTED)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_ROOT)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_STUN)|(1<<MECHANIC_POLYMORPH)|(1<<MECHANIC_TURN)|(1<<MECHANIC_HORROR)|(1<<MECHANIC_SAPPED)));
+            else if (checkdisarm) return
+                ((target->HasAuraType(SPELL_AURA_MOD_ROOT) || 
+                target->HasAuraType(SPELL_AURA_MOD_CONFUSE) || 
+                target->HasAuraType(SPELL_AURA_MOD_STUN) || 
+                target->HasAuraType(SPELL_AURA_MOD_FEAR) || 
+                target->HasAuraType(SPELL_AURA_MOD_CHARM)) && 
+                !target->HasAuraType(SPELL_AURA_MOD_DISARM));
+            else return
+                ((target->HasAuraType(SPELL_AURA_MOD_ROOT) || 
+                target->HasAuraType(SPELL_AURA_MOD_CONFUSE) || 
+                target->HasAuraType(SPELL_AURA_MOD_STUN) || 
+                target->HasAuraType(SPELL_AURA_MOD_FEAR) || 
+                target->HasAuraType(SPELL_AURA_MOD_CHARM)));
+                //return (target->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_CHARM)|(1<<MECHANIC_DISORIENTED)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_ROOT)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_STUN)|(1<<MECHANIC_POLYMORPH)|(1<<MECHANIC_TURN)|(1<<MECHANIC_HORROR)|(1<<MECHANIC_SAPPED)));
+                //return (target->HasAuraType(SPELL_AURA_MOD_ROOT) || target->HasAuraType(SPELL_AURA_MOD_CONFUSE) || target->HasAuraType(SPELL_AURA_MOD_STUN) || target->HasAuraType(SPELL_AURA_MOD_FEAR)  || target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)));
+        }
+        bool Feasting() { return (m_creature->HasAura(66478)/*EAT*/ || m_creature->HasAura(66041)/*DRINK*/); }
+        uint32 GetLostHP(Unit *unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        uint8 GetHealthPCT(Unit *hTarget, bool base = false)
+        {
+            if (!hTarget || hTarget->isDead()) return 100;
+            //if (base && m_basehp > 0) return (hTarget->GetHealth()*100/(hTarget->GetMaxHealth()*2 - m_basehp));
+            //else 
+                return (hTarget->GetHealth()*100/hTarget->GetMaxHealth());
+        }
+        uint8 GetManaPCT(Unit *hTarget, bool base = false)
+        {
+            if (!hTarget || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100;
+            //if (base && m_basemana > 0) return (hTarget->GetPower(POWER_MANA)*100/m_basemana);
+            //else 
+                return (hTarget->GetPower(POWER_MANA)*100/hTarget->GetMaxPower(POWER_MANA));
+        }
+        bool RefreshAura(uint32 spell, uint8 count = 1, Unit *target=NULL);
+        void CheckAuras();
+        bool IsChanneling() { return m_creature->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        void Follow() { if (m_creature->GetBotCommandState() != COMMAND_FOLLOW && m_creature->GetBotCommandState() != COMMAND_STAY) m_creature->SetBotCommandState(COMMAND_FOLLOW); }
+        Unit *getTarget();
+        void assistMaster(Unit *me=NULL);
+        bool CheckTarget(Unit *target);
+        void ChangeTarget(Unit *target, float dist = 30);
+        void healOthers();
+        void ApplyPassives(Classes m_class);
+        bool CheckImmunities(uint32 spell, Unit *target = NULL);
+        bool isMeleeClass(uint8 m_class) { if (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT) return true; return false;}
+        virtual void DoNonCombatActions() { }
+        //end ADDINGS
+
+        //void Feast();
+
+        void BotAttackStart(Unit *victim);
+
+        uint16 Potion_cd;
+        uint8 GC_Timer; //global cooldown
+        uint8 temptimer;
+        uint8 checkAurasTimer;
+        uint8 wait;
+        Unit *tank;
+        SpellInfo const *info;
+        int32 cost;
+        void SetBotCommandState(CommandStates st);
+
+    private:
+        void FindTank(Player *gPlayer = NULL);
+        uint8 GetAttackerCount(){ return m_attackersInfo.size(); }
+        AttackerSet m_attackersInfo;
+        bool gettingAttacked(AttackerSet m_attackers);
+        void ReceiveEmote(Player *player, uint32 emote);
+        CommandStates prevCommandState;
+        int8 clear_cd;
+        Unit *oldtank;
+        uint8 pct;
+        uint32 m_basemana;
+        uint32 m_totalmana;
+        uint32 m_basehp;
+        uint32 m_totalhp;
+        float speed_walk;
+        float speed_run;
+        float speed_swim;
+
+    protected:
+        void setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force = false);
+    class NearbyHostileBossCheck
+    {
+        public:
+            explicit NearbyHostileBossCheck(Unit const* unit, float dist = 120, bool checkCombatState = true, bool checkDeathState = true) : me(unit), m_range(dist), checkCombat(checkCombatState), mustBeAlive(checkDeathState) {}
+            bool operator()(Creature* u)
+            {
+                if (mustBeAlive && !u->isAlive())
+                    return false;
+                if (u->GetEntry() == 19622)//Kael'thas Sunstrider Event
+                    return true;
+                if (checkCombat && !u->isInCombat())
+                    return false;
+
+                if ((u->IsDungeonBoss() || u->isWorldBoss()) && me->IsWithinDistInMap(u, m_range) && u->IsHostileToPlayers())
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            bool checkCombat;
+            bool mustBeAlive;
+            NearbyHostileBossCheck(NearbyHostileBossCheck const&);
+    };
+
+    class UnitsInCombatCheck
+    {
+        public:
+            explicit UnitsInCombatCheck(Unit const* unit, float dist = 40) : me(unit), m_range(dist) {}
+            bool operator()(Creature* u)
+            {
+                if (!u->isAlive())
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+
+                if (me->IsWithinDistInMap(u, m_range) && u->IsHostileTo(me))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            UnitsInCombatCheck(UnitsInCombatCheck const&);
+    };
+
+    class NearbyCorpseCheck
+    {
+        public:
+            explicit NearbyCorpseCheck(Unit const* unit, float dist = 15) : me(unit), m_range(dist) {}
+            bool operator()(Creature* u)
+            {
+                if (me->IsWithinDistInMap(u, m_range) && 
+                    me->IsWithinLOSInMap(u) && 
+                    u->IsHostileToPlayers() && 
+                    u->isDead() && 
+                    u->InSamePhase(me))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            NearbyCorpseCheck(NearbyCorpseCheck const&);
+    };
+
+    class HostileDispelTargetCheck
+    {
+        public:
+            explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false) : me(unit), m_range(dist), checksteal(stealable) {}
+            bool operator()(Unit* u)
+            {
+                if (u->isAlive() && 
+                    u->isTargetableForAttack() && 
+                    u->IsHostileTo(me) && 
+                    ((u->isInCombat() && IS_CREATURE_GUID(u->GetGUID())) || IS_PLAYER_GUID(u->GetGUID())) && 
+                    me->IsWithinDistInMap(u, m_range) && 
+                    u->InSamePhase(me))
+                {
+                    if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                    if (!checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to dispel
+                    Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                    for(Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                    {
+                        Aura * aura = itr->second;
+                        if (aura->GetSpellInfo()->Dispel != DISPEL_MAGIC) continue;
+                        if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_PASSIVE) continue;
+                        if (checksteal && (aura->GetSpellInfo()->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                        AuraApplication * aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                        if (!aurApp)
+                            continue;
+                        bool positive = aurApp->IsPositive() ? (!(aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE)) : false;
+                        if (positive)
+                        {
+                            return true;
+                        }//end if !positive
+                    }
+                }
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            bool checksteal;
+            HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+    };
+
+    class AffectedTargetCheck
+    {
+        public:
+            explicit AffectedTargetCheck(Unit const* unit, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) : 
+            me(unit), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+            {}
+            bool operator()(Unit* u)
+            {
+                if (!checker)
+                    return false;
+                if (u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                    return false;
+                if (needhostile == 0 && !u->IsHostileTo(me)) return false;
+                if (needhostile == 1 && !(checker->GetGroup() && checker->GetGroup()->IsMember(u->GetGUID()) && IS_PLAYER_GUID(u->GetGUID()))) return false;
+                if (needhostile == 2 && !(checker->GetGroup() && checker->GetGroup()->IsMember(u->GetGUID()))) return false;
+                if (needhostile == 3 && !u->IsFriendlyTo(me)) return false;
+                
+                if (u->isAlive() && me->IsWithinDistInMap(u, m_range))
+                {
+                    Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                    for(Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                    {
+                        Aura * aura = itr->second;
+                        if (aura->GetId() == spell && aura->GetCaster() == me)
+                            return true;
+                    }
+                }
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            uint32 spell;
+            uint8 needhostile;
+            Player const *checker;
+            AffectedTargetCheck(AffectedTargetCheck const&);
+    };
+
+    class PolyUnitCheck
+    {
+        public:
+            explicit PolyUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (!(u->isAlive() && u->isInCombat() && u->IsHostileTo(me)))
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10))
+                    /*u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)*//*shackleundead*/)
+                    return false;
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(12824)))//Polymorph rank 2
+                    return false;
+                if ((u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                    u->GetCreatureType() == CREATURE_TYPE_BEAST) && 
+                    uint32(u->GetHealthPct()) > 70)
+                        return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            PolyUnitCheck(PolyUnitCheck const&);
+    };
+
+    class FearUnitCheck
+    {
+        public:
+            explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (!u->IsHostileTo(me))
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (u->getAttackers().size() > 1)
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    u->HasUnitState(UNIT_STAT_FLEEING) || 
+                    u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                    return false;
+                if (u->isFeared())
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            FearUnitCheck(FearUnitCheck const&);
+    };
+
+    class StunUnitCheck
+    {
+        public:
+            explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (!u->IsHostileTo(me))
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (!(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (me->GetDistance(u) < 9)//do not allow close cast to prevent break due to consecration
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            StunUnitCheck(StunUnitCheck const&);
+    };
+
+    class UndeadCCUnitCheck
+    {
+        public:
+            explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (!u->IsHostileTo(me))
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if(me->getVictim() == u && u->getVictim() == me)
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                    (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                    return false;
+                //most horrible hacks
+                if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                    u->GetCreatureType() != CREATURE_TYPE_DEMON && 
+                    (m_spellId == 2812 || m_spellId == 10318 || //holy
+                    m_spellId == 27139 || m_spellId == 48816 || //wra
+                    m_spellId == 48817 ||                       //th or
+                    m_spellId == 10326))                        //turn evil
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/ || 
+                    u->isInRoots() || 
+                    u->isFeared())
+                    return false;
+                if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && 
+                    (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            uint32 m_spellId;
+            UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+    };
+
+    class CastingUnitCheck
+    {
+        public:
+            explicit CastingUnitCheck(Unit const* unit, float dist = 30, bool friendly = false, uint32 spell = 0) : me(unit), m_range(dist), m_friend(friendly), m_spell(spell) { if (!m_spell) return; }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->IsNonMeleeSpellCasted(false))
+                    return false;
+                if (!m_friend && !u->IsHostileTo(me))
+                    return false;
+                if (m_friend && u->IsHostileTo(me))
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!m_friend && !u->isTargetableForAttack())
+                    return false;
+                if (m_spell == 10326 && //turn evil
+                    u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                    u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                    return false;
+                if (m_spell == 20066 && //repentance
+                    !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            bool m_friend;
+            uint32 m_spell;
+            CastingUnitCheck(CastingUnitCheck const&);
+    };
+
+    class SecondEnemyCheck
+    {
+        public:
+            explicit SecondEnemyCheck(Unit const* unit, float dist = 7) : me(unit), m_range(dist) {}
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (u == me->SelectNearbyTarget(m_range))
+                    return false;//We need to find SECONDARY target
+                if (u->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+                    return false;
+
+                if (u->isAlive() && u->isInCombat() && u->IsHostileTo(me))
+                    return true;
+                
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            SecondEnemyCheck(SecondEnemyCheck const&);
+    };
+
+    class NearestHostileUnitCheck
+    {
+        public:
+            explicit NearestHostileUnitCheck(Creature const* creature, float dist = 0, Unit const *lasttarget = NULL) : me(creature), m_range(dist), m_mytar(lasttarget) { }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->IsHostileTo(me->GetCharmerOrOwnerOrSelf()))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (u->HasAuraType(SPELL_AURA_MOD_FEAR) || 
+                    u->HasAuraType(SPELL_AURA_MOD_CHARM) || 
+                    (u->HasAuraWithMechanic((1<<MECHANIC_SAPPED)|(1<<MECHANIC_SHACKLE)|(1<<MECHANIC_TURN))))
+                    return false;//do not allow CCed units
+                if (m_mytar == u)
+                    return false;
+
+                m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+                return true;
+            }
+
+    private:
+            Creature const* me;
+            float m_range;
+            Unit const *m_mytar;
+            NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+    };
+};
+#endif
+
diff --git a/src/server/scripts/Bots/bot_druid_ai.cpp b/src/server/scripts/Bots/bot_druid_ai.cpp
new file mode 100644
index 0000000..def1c8e
--- /dev/null
+++ b/src/server/scripts/Bots/bot_druid_ai.cpp
@@ -0,0 +1,997 @@
+#include "bot_druid_ai.h"
+//#include "Group.h" 
+/*
+Druid NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Maybe 30%
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new bot_druid_ai(pCreature);
+    }
+
+    struct bot_druid_ai : public bot_ai
+    {
+        bot_druid_ai(Creature *c) : bot_ai(c)
+        {
+            Reset();
+        }
+        uint8 Heal_Timer;
+        uint8 Regrowth_Timer;
+        uint8 Swiftmend_Timer;
+        uint8 Wild_Growth_Timer;
+        uint16 Tranquility_Timer;
+        uint16 Nature_Swiftness_Timer;
+        uint16 Warstomp_Timer;
+
+        //Bear Timers
+        //int32 Bash_Timer;
+        //int32 Swipe_Timer;
+        //int32 MangleB_Timer;
+
+        //Cat Timers
+        uint8 Claw_Timer;
+        uint8 Rake_Timer;
+        uint8 Shred_Timer;
+        uint8 Rip_Timer;
+        uint8 Mangle_Cat_Timer;
+
+        //Balance Timers
+        uint8 Moonfire_Timer;
+        uint8 Starfire_Timer;
+        uint8 Wrath_Timer;
+        uint8 Hurricane_Timer;
+        uint8 formtimer;
+
+        bool clearcast;
+        Powers power;
+
+        uint16 rage;
+        float rageIncomeMult;
+        float rageLossMult;
+        uint8 ragetimer;
+        uint8 ragetimer2;
+
+        void Reset()
+        {
+            GC_Timer = 0;
+            Potion_cd = 0;
+            Heal_Timer = 0;
+            Regrowth_Timer = 0;
+            Swiftmend_Timer = 0;
+            Wild_Growth_Timer = 0;
+            Tranquility_Timer = 0;
+            Nature_Swiftness_Timer = 0;
+
+            Warstomp_Timer = 0;
+            //Bash_Timer = 0;
+            //Swipe_Timer = 20;
+            //MangleB_Timer = 0;
+
+            Claw_Timer = 0;
+            Rake_Timer = 0;
+            Shred_Timer = 0;
+            Rip_Timer = 0;
+            Mangle_Cat_Timer = 0;
+
+            Moonfire_Timer = 0;
+            Starfire_Timer = 0;
+            Wrath_Timer = 0;
+            Hurricane_Timer = 0;
+
+            temptimer = 0;
+            checkAurasTimer = 0;
+            formtimer = 0;
+            wait = 15;
+            opponent = NULL;
+            clearcast = false;
+            power = POWER_MANA;
+
+            rage = 0;
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            ragetimer = 0;
+            ragetimer2 = 0;
+        
+            if (master) 
+            {
+                setStats(CLASS_DRUID, m_creature->getRace(), master->getLevel(), true);
+
+                if (master->getLevel() >= 50)
+                    RefreshAura(SPELLDMG2); //+6%
+                if (master->getLevel() >= 45)
+                    RefreshAura(NATURAL_PERFECTION3); //4%
+                else if (master->getLevel() >= 43)
+                    RefreshAura(NATURAL_PERFECTION2); //3%
+                else if (master->getLevel() >= 41)
+                    RefreshAura(NATURAL_PERFECTION1); //2%
+                if (master->getLevel() >= 50)
+                    RefreshAura(LIVING_SEED3); //100%
+                else if (master->getLevel() >= 48)
+                    RefreshAura(LIVING_SEED2); //66%
+                else if (master->getLevel() >= 46)
+                    RefreshAura(LIVING_SEED1); //33%
+                if (master->getLevel() >= 55)
+                    RefreshAura(REVITALIZE3, 5); //75% (15%)x5
+                else if (master->getLevel() >= 53)
+                    RefreshAura(REVITALIZE2, 3); //30% (10%)x3
+                else if (master->getLevel() >= 51)
+                    RefreshAura(REVITALIZE1, 3); //15%  (5%)x3
+                if (master->getLevel() >= 70)
+                    RefreshAura(OMEN_OF_CLARITY, 3); //x3
+                else if (master->getLevel() >= 40)
+                    RefreshAura(OMEN_OF_CLARITY, 2); //x2
+                else if (master->getLevel() >= 20)
+                    RefreshAura(OMEN_OF_CLARITY); //x1
+                if (master->getLevel() >= 45)
+                    RefreshAura(GLYPH_SWIFTMEND); //no comsumption
+
+                if (master->getLevel() >= 78)
+                {
+                    RefreshAura(T9_RESTO_P4_BONUS);
+                    RefreshAura(T8_RESTO_P4_BONUS);
+                    RefreshAura(T9_BALANCE_P2_BONUS);
+                    RefreshAura(T10_BALANCE_P2_BONUS);
+                    RefreshAura(T10_BALANCE_P4_BONUS);
+                }
+
+                ApplyPassives(CLASS_DRUID);
+                SetBotCommandState(COMMAND_FOLLOW);
+           }
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (Feasting() && !master->isInCombat() && 
+                !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (m_creature->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != MANAPOTION && spellId != HEALINGPOTION) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                DoCast(victim, spellId, triggered);
+                m_creature->EnergizeBySpell(m_creature, spellId, urand(m_creature->GetMaxPower(POWER_MANA)/3,m_creature->GetMaxPower(POWER_MANA)), POWER_MANA);
+                return true;
+            }
+            m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+            if (master->getLevel() >= 78)
+                GC_Timer = 8;
+            else if (master->getLevel() >= 70)
+                GC_Timer = 10;
+            else if (master->getLevel() >= 50)
+                GC_Timer = 12;
+            else if (master->getLevel() >= 35)
+                GC_Timer = 14;
+            else if (master->getLevel() >= 25)
+                GC_Timer = 16;
+            else if (master->getLevel() >= 15)
+                GC_Timer = 18;
+            else
+                GC_Timer = 20;
+            
+            if (!victim->IsWithinLOSInMap(m_creature) && IsInBotParty(victim))
+                m_creature->Relocate(victim);
+
+            if (m_creature->getPowerType() == POWER_MANA && 
+                m_creature->HasAura(SPELL_NATURES_SWIFTNESS) && 
+                spellId != TEMP_SHADOWSTEP && spellId != SPELL_WARSTOMP && 
+                spellId != SPELL_BEAR_FORM && spellId != SPELL_CAT_FORM)
+            {
+                DoCast(victim, spellId, true);
+                m_creature->RemoveAurasDueToSpell(SPELL_NATURES_SWIFTNESS,m_creature->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                return true;
+            }
+
+            DoCast(victim, spellId, triggered);
+
+            if (spellId != TEMP_SHADOWSTEP && spellId != SPELL_WARSTOMP && 
+                spellId != SPELL_BEAR_FORM && spellId != SPELL_CAT_FORM && 
+                m_creature->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                info = sSpellMgr->GetSpellInfo(spellId);
+                cost = info->CalcPowerCost(m_creature, info->GetSchoolMask());
+                clearcast = true;
+                power = m_creature->getPowerType();
+            }
+            if (spellId == SPELL_BEAR_FORM || 
+                spellId == SPELL_CAT_FORM)
+            {
+                int32 val = m_creature->GetCreateMana();
+                val -= (val/20);
+                m_creature->ModifyPowerPct(POWER_MANA, irand(-(val*5),-(val*3)));//15-25% of base mana
+            }
+            return true;
+        } //end doCast
+
+        void Aggro(Unit *who){}
+
+        void EnterEvadeMode()
+        {if (!master) return;
+            if (!me->isAlive())
+                return;
+            if (m_creature->IsInEvadeMode())
+                return;
+            if (!IsEvent())
+            {
+                if (!m_creature->getThreatManager().isThreatListEmpty())
+                    m_creature->DeleteThreatList();
+                if (m_creature->isInCombat())
+                {
+                    if (IsChanneling())
+                        m_creature->CombatStop(false);
+                    else
+                        m_creature->CombatStop(true);
+                }
+                Follow();
+            }
+        }
+
+        void KilledUnit(Unit*)
+        {if (!master) return;
+            Unit *u = master->GetSelectedUnit();
+            if (!u || !u->isInCombat() || !u->IsHostileTo(master))
+            {
+                if (!IsEvent())
+                {
+                    if (!master->getVictim() && master->getAttackers().empty() && master->isInCombat())
+                        master->CombatStop();
+                    if (!master->isInCombat())
+                        m_creature->CombatStop();
+                }
+            }
+            //master->SetBotCommandState(COMMAND_FOLLOW);
+            //if (DamagePossible()) ResetOrGetNextTarget();
+        }
+
+        void JustDied(Unit *Killer)
+        {if (!master) return;
+            removeFeralForm(true);
+            SetBotCommandState(COMMAND_FOLLOW);
+        }
+
+        //try to do a warstomp every time I get out of animal form
+        void warstomp(const uint32 diff)
+        {
+            if (!m_creature->SelectNearestTarget()) return;
+            if (m_creature->GetBotRace() != RACE_TAUREN) return;
+            if (!isTimerReady(Warstomp_Timer)) return;
+            if (m_creature->HasAura(SPELL_CAT_FORM) || m_creature->HasAura(SPELL_CAT_FORM))
+                return;
+
+            AttackerSet b_attackers = m_creature->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit *u = m_creature->SelectNearestTarget(5);
+                if (u && u->isInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(m_creature, SPELL_WARSTOMP))
+                    {
+                        Warstomp_Timer = 300; //30sec
+                        return;
+                    }
+                }
+                return;
+            }
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (m_creature->GetDistance((*iter)) > 5) continue;
+                if (m_creature->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(m_creature, SPELL_WARSTOMP))
+                    {
+                        Warstomp_Timer = 300; //30sec
+                    }
+                }
+            }
+        } //end warstomp
+
+        bool DamagePossible()
+        {
+            if (GetHealthPCT(master) < 75 || GetHealthPCT(m_creature) < 75) return false;
+
+            //if (master->IsPlayerbot() && master->getAttackers().size() > 2)
+            //    return false;
+
+            std::list<Unit*> unitList;
+            master->GetRaidMember(unitList,30);
+            if (!unitList.empty())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end(); ++itr)
+                {
+                    Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+                    if (!tPlayer) continue;
+                    if (m_creature->GetDistance(tPlayer) > 30) continue;
+                    if (tPlayer->isDead()) return false;
+                    
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                    {
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                        {
+                            ++DIScount;
+                        }
+                    }
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit *u = master->getVictim();
+            if (master->getAttackers().size() > 4 || 
+              (!master->getAttackers().empty() && 
+                u != NULL && u->GetHealth() > m_creature->GetMaxHealth()*17))
+                return false;
+
+            return true;
+        }
+
+        void removeFeralForm(bool force = false)
+        {
+            if (!force && formtimer > 0) return;
+
+            if (m_creature->HasAura(SPELL_BEAR_FORM))
+            {
+                m_creature->RemoveAurasDueToSpell(SPELL_BEAR_FORM);
+                m_creature->RemoveAurasDueToSpell(SPELL_BEAR_FORM_MOD);
+                m_creature->RemoveAurasDueToSpell(BEAR_ARMOR);
+                formtimer = 10;
+                m_creature->DeMorph();
+                SetStats(CLASS_DRUID);
+            }
+
+            if (m_creature->HasAura(SPELL_CAT_FORM))
+            {
+                m_creature->RemoveAurasDueToSpell(SPELL_CAT_FORM);
+                m_creature->RemoveAurasDueToSpell(SPELL_CAT_FORM_MOD);
+                m_creature->RemoveAurasDueToSpell(CAT_HASTE);
+                m_creature->RemoveAurasDueToSpell(CAT_HASTE2);
+                formtimer = 10;
+                m_creature->DeMorph();
+                SetStats(CLASS_DRUID);
+            }
+            //if (m_creature->getPowerType() != POWER_MANA)
+            //    m_creature->setPowerType(POWER_MANA);
+            //setStats(CLASS_DRUID, m_creature->getRace(), master->getLevel());
+        } //end removeFeralForm
+
+        void AttackStart(Unit *u)
+        {if (!master) return;
+            if (!u || !u->isTargetableForAttack()) return;
+            Aggro(u);
+            m_creature->AddThreat(u, 0.001f);
+            opponent = u;
+            if (m_creature->HasAura(SPELL_BEAR_FORM) || m_creature->HasAura(SPELL_CAT_FORM))
+            {
+                UnitAI::AttackStart(u);
+                m_creature->SetBotCommandState(COMMAND_ATTACK);
+            }
+        }
+
+        void doBearActions(const uint32 diff)
+        {
+            if (m_creature->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(m_creature) < 75)
+                HealTarget(m_creature, GetHealthPCT(m_creature));
+            assistMaster();
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack()) return;
+
+            if (m_creature->getVictim() != opponent)
+                AttackStart(opponent);
+            rage = m_creature->GetPower(POWER_RAGE);
+            if (ragetimer2 <= 0)
+            {
+                if (m_creature->isInCombat() && m_creature->getLevel() >= 30)
+                {
+                    if (rage < 990 && rage >= 0)
+                        m_creature->SetPower(POWER_RAGE, rage + uint32(10.0f*rageIncomeMult));//1 rage per 2 sec
+                    else
+                        m_creature->SetPower(POWER_RAGE, 1000);//max
+                }
+                ragetimer2 = 20;
+            }
+            if (ragetimer <= 0)
+            {
+                if (!m_creature->isInCombat())
+                {
+                    if (rage > 10.0f*rageLossMult)
+                        m_creature->SetPower(POWER_RAGE, rage - uint32(10.0f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        m_creature->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 15;
+                if (rage > 1000) m_creature->SetPower(POWER_RAGE, 1000);
+                if (rage < 10) m_creature->SetPower(POWER_RAGE, 0);
+            }
+
+            //range check (melee) to prevent fake casts
+            if (m_creature->GetDistance(opponent) > 6) return;
+
+            if (isTimerReady(GC_Timer) && (rage >= 200 || m_creature->HasAura(OMEN_OF_CLARITY_BUFF)))
+            {
+                if (doCast(opponent, SPELL_SWIPE, true))
+                {
+                    if (rage < 200)
+                        m_creature->SetPower(POWER_RAGE, rage);
+                    else
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage -200);
+                        rage -= 200;
+                    }
+                }
+            }
+        }//end doBearActions
+
+        void doCatActions(/*Player *master, Creature *m_creature,*/ const uint32 diff)
+        {
+            if (GetHealthPCT(m_creature) < 75)
+                HealTarget(m_creature, GetHealthPCT(m_creature));
+            assistMaster();
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack()) return;
+
+            if (m_creature->getVictim() != opponent)
+                AttackStart(opponent);
+            uint16 energy = m_creature->GetPower(POWER_ENERGY);
+
+            //range check (melee) to prevent fake casts
+            if (m_creature->GetDistance(opponent) > 6) return;
+
+            if (isTimerReady(Claw_Timer))
+            {
+                if (doCast(opponent, SPELL_CLAW, true))
+                    Claw_Timer = 70;
+            }
+            if (isTimerReady(Mangle_Cat_Timer))
+            {
+                if (doCast(opponent, SPELL_MANGLE_CAT, true))
+                    Mangle_Cat_Timer = 70;
+            }
+            if (isTimerReady(Rake_Timer))
+            {
+                if (doCast(opponent, SPELL_RAKE, true))
+                    Rake_Timer = 100;
+            }
+            if (isTimerReady(Shred_Timer))
+            {
+                if (opponent->HasInArc(M_PI, m_creature))
+                    doCast(opponent, TEMP_SHADOWSTEP, true);
+                if (doCast(opponent, SPELL_SHRED, true))
+                    Shred_Timer = 120;
+            }
+            if (isTimerReady(Rip_Timer))
+            {
+                if (doCast(opponent, SPELL_RIP, true))
+                    Rip_Timer = 150;
+            }
+        } //end doCatActions
+
+        void doBalanceActions(const uint32 diff)
+        {
+            assistMaster();
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack()) return;
+
+            if (master->GetDistance(opponent) < 20)
+                ScriptedAI::AttackStartCaster(opponent, 14);
+            else if (!m_creature->HasUnitState(UNIT_STAT_CASTING) && m_creature->GetDistance(master) > 10)
+            {
+                m_creature->Relocate(master);
+                SetBotCommandState(COMMAND_FOLLOW);
+                return;
+            }
+                
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = m_creature->getAttackers();
+
+            //range check (melee) to prevent fake casts
+            if (m_creature->GetDistance(opponent) > 30) return;
+
+            if (SPELL_HURRICANE != 0 && isTimerReady(Hurricane_Timer) && !m_creature->HasUnitState(UNIT_STAT_CASTING))
+            {
+                Unit *target = FindAOETarget(30, true);
+                if (target && doCast(target, SPELL_HURRICANE))
+                    Hurricane_Timer = 50;
+            }
+            if (!opponent->HasAura(SPELL_FAIRIE_FIRE) && GC_Timer <= 0)
+            {
+                if (doCast(opponent, SPELL_FAIRIE_FIRE)) {}
+            }
+            if (isTimerReady(Moonfire_Timer) && 
+                !opponent->HasAura(SPELL_MOONFIRE))
+            {
+                if (doCast(opponent, SPELL_MOONFIRE))
+                    Moonfire_Timer = 50;
+            }
+            if (isTimerReady(Starfire_Timer))
+            {
+                if (m_creature->HasAura(NATURESGRACE) && m_creature->HasAura(NATURESGRACEBUFF))
+                {
+                    if (doCast(opponent, SPELL_STARFIRE)) Starfire_Timer = 110;
+                }
+                else if (m_creature->getLevel() < 40 && doCast(opponent, SPELL_STARFIRE)) Starfire_Timer = 110;
+            }
+            if (isTimerReady(Wrath_Timer))
+            {
+                if (doCast(opponent, SPELL_WRATH))
+                {
+                    if (m_creature->HasAura(NATURESGRACEBUFF))
+                        Wrath_Timer = 5;
+                    else
+                        Wrath_Timer = sSpellMgr->GetSpellInfo(SPELL_WRATH)->CalcCastTime()/100 * m_creature->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1;
+                }
+            }
+        }
+
+        bool HandleCure(DispelType dispel, Unit *target)
+        {
+            if (dispel == DISPEL_POISON)
+            {
+                removeFeralForm();
+                if (doCast(target, CURE_POISON))
+                    return true;
+            }
+            return false;
+        }
+
+        bool MassGroupHeal(Player *gPlayer)
+        {
+            if (!gPlayer) return false;
+            if (!isTimerReady(Tranquility_Timer) && !isTimerReady(Wild_Growth_Timer)) return false;
+            if (!SPELL_TRANQUILITY && !SPELL_WILD_GROWTH) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false; // if I'm already casting
+            Group *pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            if (SPELL_TRANQUILITY && isTimerReady(Tranquility_Timer))
+            {
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (m_creature->GetDistance(tPlayer) > 30) continue;
+                    if (GetHealthPCT(tPlayer) < 70)
+                        ++LHPcount;
+                }
+                if (LHPcount > 1)
+                {
+                    removeFeralForm();
+                    if (doCast(m_creature, SPELL_TRANQUILITY))
+                    { Tranquility_Timer = 450; return true; }
+                }
+            }
+            if (SPELL_WILD_GROWTH && isTimerReady(Wild_Growth_Timer))
+            {
+                Unit *tPlayer = m_creature;
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    tPlayer = itr->getSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (m_creature->GetDistance(tPlayer) > 30) continue;
+                    if (tPlayer->HasAura(SPELL_WILD_GROWTH, m_creature->GetGUID())) continue;
+                    if (GetHealthPCT(tPlayer) < 90)
+                        ++LHPcount;
+                }
+                if (LHPcount > 0)
+                {
+                    removeFeralForm();
+                    if (doCast(tPlayer, SPELL_WILD_GROWTH))
+                    { Wild_Growth_Timer = 50; return true; }
+                }
+            }
+            return false;
+        }//end MassGroupHeal
+
+        void UpdateAI(const uint32 diff)
+        {if (!master) return;
+            decrementTimers();
+            if (IAmDead()) return;
+            if (!m_creature->HasAura(SPELL_TEMP_NOGG))
+                m_creature->AddAura(SPELL_TEMP_NOGG, m_creature);
+            if (!m_creature->HasAura(SPELL_CAT_FORM) && !m_creature->HasAura(SPELL_BEAR_FORM) && 
+                m_creature->GetDisplayId() != m_creature->GetNativeDisplayId())
+                m_creature->DeMorph();
+            if (m_creature->HasAura(OMEN_OF_CLARITY_BUFF) && clearcast && !m_creature->IsNonMeleeSpellCasted(true))
+            {
+                m_creature->EnergizeBySpell(m_creature, OMEN_OF_CLARITY_BUFF, cost, power);
+                m_creature->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,m_creature->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = urand(1,3);
+            else
+                return;
+            if (checkAurasTimer <= 0)
+            {
+                if (m_creature->HasAura(SPELL_BEAR_FORM))
+                    SetStats(BEAR);
+                else if (m_creature->HasAura(SPELL_CAT_FORM))//bear\cat
+                    SetStats(CAT);
+                else
+                    SetStats(CLASS_DRUID);
+                CheckAuras();
+                checkAurasTimer = 30;
+            }
+            if (CCed()) return;
+            warstomp(diff);
+            if (GetManaPCT(m_creature) > 80)
+                RezGroup(SPELL_REBIRTH, master);
+
+            if (m_creature->getPowerType() == POWER_MANA && 
+                GetManaPCT(m_creature) < 20 && 
+                Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, MANAPOTION)) Potion_cd = MANA_CD;
+                GC_Timer = temptimer;
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+            {
+                HealTarget(master, GetHealthPCT(master));
+            }
+            MassGroupHeal(master);
+            BuffAndHealGroup(master);
+            CureTarget(master);
+            CureGroup(master);
+            CureTarget(m_creature);
+            healOthers();
+
+            if (!m_creature->HasAura(SPELL_BEAR_FORM) && !m_creature->HasAura(SPELL_CAT_FORM))
+            {
+                opponent = getTarget();
+            }
+            else 
+            {
+                Unit *u = m_creature->getVictim();
+                if (!u || !u->isTargetableForAttack())
+                    opponent = getTarget();
+                else
+                    opponent = u;
+            }
+
+            if (!CheckTarget(opponent) || !opponent)
+            {
+                removeFeralForm();
+                return;
+            }
+
+            if (CCed(opponent))
+                ChangeTarget(opponent, 20);
+
+            if (GetHealthPCT(m_creature) < 75)
+            {
+                HealTarget(m_creature, GetHealthPCT(m_creature));
+                return;
+            }
+
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return;//Casting heal or so
+            //if the target is attacking us, we want to go bear
+            if (DamagePossible() && opponent->isTargetableForAttack())
+            {
+                Unit *u = opponent->getVictim();
+                if (m_creature->getLevel() >= 20 && (u == m_creature || m_creature->getAttackers().size() > 1))
+                {
+                    //if we don't have bear yet
+                    if (!m_creature->HasAura(SPELL_BEAR_FORM) && isTimerReady(formtimer))
+                    {
+                        removeFeralForm();
+                        if (doCast(m_creature, SPELL_BEAR_FORM))
+                        {
+                            SetStats(BEAR);
+                            formtimer = 15;
+                        }
+                    }
+                    if (m_creature->HasAura(SPELL_BEAR_FORM))
+                        doBearActions(diff);
+                }
+                else if (m_creature->getLevel() >= 20 && u == master && master->getVictim() != opponent/*IsInBotParty(opponent->getVictim())*/)
+                {
+                    //if we don't have cat yet
+                    if (!m_creature->HasAura(SPELL_CAT_FORM) && isTimerReady(formtimer))
+                    {
+                        removeFeralForm();
+                        if (doCast(m_creature, SPELL_CAT_FORM))
+                        {
+                            SetStats(CAT);
+                            formtimer = 15;
+                        }
+                    }
+                    if (m_creature->HasAura(SPELL_CAT_FORM))
+                        doCatActions(diff);
+                }
+                else/* if (m_creature->getLevel() >= 20)*/
+                {
+                    if (m_creature->HasAura(SPELL_BEAR_FORM) || m_creature->HasAura(SPELL_CAT_FORM))
+                        removeFeralForm();
+                    doBalanceActions(diff);
+                }
+            }
+            else if (opponent->isTargetableForAttack())
+            {
+                SetStats(CLASS_DRUID);
+                if (!m_creature->HasAura(SPELL_BEAR_FORM) && !m_creature->HasAura(SPELL_CAT_FORM))
+                    doBalanceActions(diff);
+            }
+            //else if (DamagePossible()) ResetOrGetNextTarget();
+
+            ScriptedAI::UpdateAI(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp)
+        {
+            //if (hp > 50 && m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (!target || target->isDead()) return false;
+            if (target == m_creature && hp > 80) return false;//do not waste heal if in feral or so
+            if (m_creature->GetDistance(target) > 30) return false;
+            if (m_creature->GetDistance(target) < 15 && !target->IsWithinLOSInMap(m_creature))
+            {
+                m_creature->Relocate(target);
+            }
+
+            if ((hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) && 
+                Nature_Swiftness_Timer <= 0 && (target->isInCombat() || !target->getAttackers().empty()))
+            {
+                removeFeralForm();
+                if (m_creature->IsNonMeleeSpellCasted(false))
+                    m_creature->InterruptNonMeleeSpells(false);
+                if (m_creature->getLevel() >= 30 && doCast(m_creature, SPELL_NATURES_SWIFTNESS) && RefreshAura(23434))//need to be critical
+                {
+                    if (GC_Timer > 2)
+                        GC_Timer = 2;
+                    if (doCast(target, SPELL_HEALING_TOUCH, true))
+                    {
+                        m_creature->RemoveAurasDueToSpell(SPELL_NATURES_SWIFTNESS,0,0, AURA_REMOVE_BY_EXPIRE);
+                        m_creature->RemoveAurasDueToSpell(23434);
+                        Nature_Swiftness_Timer = 1200;//2 min
+                        Heal_Timer = 30;
+                        return true;
+                    }
+                }
+            }
+            if (m_creature->getLevel() >= 40 && (hp < 25 || GetLostHP(target) > 5000) && Swiftmend_Timer <= 30 && 
+                (HasAuraName(target, SPELL_REGROWTH) || HasAuraName(target, SPELL_REJUVENATION)))
+            {
+                removeFeralForm();
+                if (doCast(target, SPELL_SWIFTMEND))
+                {
+                    Swiftmend_Timer = 100;
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (GC_Timer > 3)
+                            GC_Timer = 3;
+                        if (doCast(target, SPELL_REGROWTH))
+                            return true;
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && isTimerReady(Heal_Timer) && m_creature->getLevel() >= 70)
+            {
+                removeFeralForm();
+                switch(urand(1,3))
+                {
+                case 1:
+                case 2:
+                    {
+                        if (doCast(target, SPELL_NOURISH))
+                        { Heal_Timer = 30; return true; }
+                    }
+                case 3:
+                    {
+                        if (doCast(target, SPELL_HEALING_TOUCH))
+                        { Heal_Timer = 30; return true; }
+                    }
+                }
+            }
+            if (((hp < 80 || GetLostHP(target) > 3500) && isTimerReady(Regrowth_Timer) && !target->HasAura(SPELL_REGROWTH, m_creature->GetGUID())) || 
+                (target->HasAura(SPELL_REGROWTH, m_creature->GetGUID()) && target->HasAura(SPELL_REJUVENATION, m_creature->GetGUID()) && (hp < 70 || GetLostHP(target) > 3000)  && isTimerReady(Regrowth_Timer)))
+            {
+                removeFeralForm();
+                if (doCast(target, SPELL_REGROWTH))
+                { Regrowth_Timer = 20; return true; }
+            }
+            if (hp > 25 && (hp < 90 || GetLostHP(target) > 2000) && GC_Timer <= 0 && 
+                !HasAuraName(target, SPELL_REJUVENATION, m_creature->GetGUID()))
+            {
+                removeFeralForm();
+                if (doCast(target, SPELL_REJUVENATION))
+                {
+                    if (GC_Timer > 5)
+                        GC_Timer = 5;
+                    if (GetHealthPCT(target) > 75 || GetLostHP(target) > 4000)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (m_creature->getLevel() >= 40 && isTimerReady(Swiftmend_Timer) && doCast(target, SPELL_SWIFTMEND))
+                        { Swiftmend_Timer = 100; return true; }
+                    }
+                }
+            }
+            if (((hp < 85 && hp > 40) || 
+                (hp < 70 && hp > 25 && HasAuraName(target, SPELL_REGROWTH) && HasAuraName(target, SPELL_REJUVENATION)) || 
+                (GetLostHP(target) > 1500 && hp > 35)) && 
+                GC_Timer <= 0 && 
+                SPELL_LIFEBLOOM != 0)
+            {
+                Aura *bloom = target->GetAura(SPELL_LIFEBLOOM, m_creature->GetGUID());
+
+                if (!bloom || bloom->GetStackAmount() < 3)
+                {
+                    removeFeralForm();
+                    if (doCast(target, SPELL_LIFEBLOOM)) return true;
+                }
+            }
+            if (hp > 20 && (hp < 70 || GetLostHP(target) > 3000) && isTimerReady(Heal_Timer))
+            {
+                removeFeralForm();
+                if (doCast(target, SPELL_HEALING_TOUCH))
+                { Heal_Timer = 30; return true; }
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit *target)
+        {
+            if (target && target->isAlive() && m_creature->GetDistance(target) < 30)
+            {
+                if (!HasAuraName(target, SPELL_MARK_OF_THE_WILD) && GC_Timer <= 0) 
+                {
+                    if (doCast(target, SPELL_MARK_OF_THE_WILD))
+                    {
+                        if (IS_CREATURE_GUID(target->GetGUID()))
+                            m_creature->AddAura(SPELL_MARK_OF_THE_WILD, target);
+                    }
+                }
+                if (!HasAuraName(target, SPELL_THORNS) && GC_Timer <= 0) 
+                {
+                    if (doCast(target, SPELL_THORNS))
+                    {
+                        if (IS_CREATURE_GUID(target->GetGUID()))
+                            m_creature->AddAura(SPELL_THORNS, target);
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void DoNonCombatActions()
+        {if (!master) return;
+            //if eating or drinking don't do anything
+            if (Feasting()) return;
+            if (master->GetGroup())
+            {
+                RezGroup(SPELL_REBIRTH, master);
+                //BuffAndHealGroup(master);
+            }
+            BuffTarget(m_creature);
+        }
+
+        void SetStats(uint8 Form)
+        {
+            switch(Form)
+            {
+            case BEAR:
+                m_creature->SetBotClass(15);
+                if (m_creature->getPowerType() != POWER_RAGE)
+                {
+                    m_creature->setPowerType(POWER_RAGE);
+                    m_creature->SetMaxPower(POWER_RAGE, 1000);
+                }
+                if (m_creature->getLevel() >= 15)
+                    m_creature->SetPower(POWER_RAGE, 200);
+                else
+                    m_creature->SetPower(POWER_RAGE, 0);
+                if (m_creature->getLevel() >= 40 && !m_creature->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                RefreshAura(BEAR_ARMOR, 5);//30% reduced damage taken
+                RefreshAura(SPELL_BEAR_FORM_MOD, master->getLevel()/20 + 2);
+                setStats(BEAR, m_creature->getRace(), master->getLevel());
+                break;
+            case CAT:
+                m_creature->SetBotClass(25);
+                if (m_creature->getPowerType() != POWER_ENERGY)
+                {
+                    m_creature->setPowerType(POWER_ENERGY);
+                    m_creature->SetMaxPower(POWER_ENERGY, 100);
+                    m_creature->SetPower(POWER_ENERGY, 0);
+                }
+                if (m_creature->getLevel() >= 15)
+                    m_creature->SetPower(POWER_ENERGY, 40);
+                else
+                    m_creature->SetPower(POWER_ENERGY, 0);
+                if (m_creature->getLevel() >= 40 && !m_creature->HasAura(LEADER_OF_THE_PACK))
+                        RefreshAura(LEADER_OF_THE_PACK);
+                RefreshAura(CAT_HASTE, 5);//30% dodge, 5x 10% haste
+                RefreshAura(CAT_HASTE2);//30% haste
+                RefreshAura(SPELL_CAT_FORM_MOD, master->getLevel()/20 + 1);
+                setStats(CAT, m_creature->getRace(), master->getLevel());
+                break;
+            case CLASS_DRUID:
+                m_creature->SetBotClass(CLASS_DRUID);
+                if (m_creature->getPowerType() != POWER_MANA)
+                    m_creature->setPowerType(POWER_MANA);
+                if (m_creature->getLevel() >= 20)
+                    RefreshAura(NATURESGRACE);
+                setStats(CLASS_DRUID, m_creature->getRace(), master->getLevel());
+                break;
+            }
+        }
+
+        void decrementTimers()
+        {
+            if (GC_Timer > 0)                --GC_Timer;
+            //if (Demoralizing_Roar_Timer > 0) --Demoralizing_Roar_Timer;
+            //if (Swipe_Timer > 0)             --Swipe_Timer;
+            if (Claw_Timer > 0)              --Claw_Timer;
+            if (Rake_Timer > 0)              --Rake_Timer;
+            if (Shred_Timer > 0)             --Shred_Timer;
+            if (Mangle_Cat_Timer > 0)        --Mangle_Cat_Timer;
+            if (Moonfire_Timer > 0)          --Moonfire_Timer;
+            if (Starfire_Timer > 0)          --Starfire_Timer;
+            if (Wrath_Timer > 0)             --Wrath_Timer;
+            if (Hurricane_Timer > 0)         --Hurricane_Timer;
+            if (Rip_Timer > 0)               --Rip_Timer;
+            if (Potion_cd > 0)               --Potion_cd;
+            if (Regrowth_Timer > 0)          --Regrowth_Timer;
+            if (Heal_Timer > 0)              --Heal_Timer;
+            if (Swiftmend_Timer > 0)         --Swiftmend_Timer;
+            if (Wild_Growth_Timer > 0)       --Wild_Growth_Timer;
+            if (Nature_Swiftness_Timer > 0)  --Nature_Swiftness_Timer;
+            if (Tranquility_Timer > 0)       --Tranquility_Timer;
+            if (Warstomp_Timer > 0)          --Warstomp_Timer;
+            if (temptimer > 0)               --temptimer;
+            if (checkAurasTimer > 0)         --checkAurasTimer;
+            if (wait > 0)                    --wait;
+            if (formtimer > 0)               --formtimer;
+            if (ragetimer > 0)               --ragetimer;;
+            if (ragetimer2 > 0)              --ragetimer2;;
+        }
+
+        void ReceiveBowEmote(Player *player)
+        {
+            if (m_creature->GetDistance(player) < 30)
+            {
+                ((bot_druid_ai*)m_creature->AI())->removeFeralForm();
+                if (((bot_druid_ai*)m_creature->AI())->doCast(player, SPELL_MARK_OF_THE_WILD))
+                    m_creature->AddAura(SPELL_MARK_OF_THE_WILD, player);
+            }
+            else
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                DoSay("Come closer, you fool", LANG_UNIVERSAL, player->GetGUID());
+            }
+        }
+    }; //end druid_bot
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/scripts/Bots/bot_druid_ai.h b/src/server/scripts/Bots/bot_druid_ai.h
new file mode 100644
index 0000000..d52e50c
--- /dev/null
+++ b/src/server/scripts/Bots/bot_druid_ai.h
@@ -0,0 +1,106 @@
+#include "bot_ai.h"
+
+#define SPELL_TEMP_NOGG             16591
+#define SPELL_WARSTOMP              20549    //racial ability
+#define TEMP_SHADOWSTEP             45273
+
+#define SPELL_MARK_OF_THE_WILD      SPELL_MARK_OF_THE_WILD_A[SPELL_LEVEL]
+#define SPELL_THORNS                SPELL_THORNS_A[SPELL_LEVEL]
+
+uint32 SPELL_MARK_OF_THE_WILD_A[] = { 1126, 5232, 6756, 5234, 8907, 9884, 9885, 26990, 48469, 48469 };
+uint32 SPELL_THORNS_A[] = { 467, 782, 1075, 8914, 9756, 9910, 26992, 26992, 53307, 8148 };
+
+#define SPELL_HEALING_TOUCH         SPELL_HEALING_TOUCH_A[SPELL_LEVEL]
+#define SPELL_REGROWTH              SPELL_REGROWTH_A[SPELL_LEVEL]
+#define SPELL_REJUVENATION          SPELL_REJUVENATION_A[SPELL_LEVEL]
+#define SPELL_REBIRTH               SPELL_REBIRTH_A[SPELL_LEVEL]
+#define SPELL_LIFEBLOOM             SPELL_LIFEBLOOM_A[SPELL_LEVEL]
+#define SPELL_WILD_GROWTH           SPELL_WILD_GROWTH_A[SPELL_LEVEL]
+#define SPELL_TRANQUILITY           SPELL_TRANQUILITY_A[SPELL_LEVEL]
+#define SPELL_NOURISH               50464
+#define SPELL_SWIFTMEND             18562
+#define SPELL_NATURES_SWIFTNESS     17116
+
+uint32 SPELL_HEALING_TOUCH_A[] = { 5185, 5187, 5189, 6778, 9758, 9889, 26978, 26979, 48378, 69899 };
+uint32 SPELL_REGROWTH_A[] = { 8936, 8939, 8941, 9750, 9857, 9858, 26980, 48442, 48443, 69882 };
+uint32 SPELL_REJUVENATION_A[] = { 1058, 2090, 2091, 3627, 9840, 26981, 26982, 48440, 48441, 69898 };
+uint32 SPELL_REBIRTH_A[] = { 0, 0, 50769, 50768, 50767, 50766, 50765, 50764, 50763, 51918 };
+uint32 SPELL_LIFEBLOOM_A[] = { 0, 0, 0, 0, 0, 0, 33763, 48450, 48451, 48451 };
+uint32 SPELL_WILD_GROWTH_A[] = { 0, 0, 0, 0, 0, 0, 48438, 53248, 53251, 53251 };
+uint32 SPELL_TRANQUILITY_A[] = { 0, 0, 0, 740, 8918, 9862, 9863, 48446, 48447, 48447 };
+
+//FERAL SPELLS
+#define LEADER_OF_THE_PACK          24932
+
+#define BEAR 15
+#define CAT 25
+
+#define SPELL_BEAR_FORM             18309//9634
+#define SPELL_BEAR_FORM_MOD         1178
+#define BEAR_ARMOR/*MoltenSkinWarl*/63351
+
+#define SPELL_BASH                  8983
+#define SPELL_SWIPE                 SPELL_SWIPE_A[SPELL_LEVEL]
+#define SPELL_MANGLE_BEAR           SPELL_MANGLE_BEAR_A[SPELL_LEVEL]
+
+uint32 SPELL_MANGLE_BEAR_A[] = { 0, 0, 0, 0, 0, 0, 0, 31041, 31041, 31041 };
+uint32 SPELL_SWIPE_A[] = { 0, 779, 780, 769, 9754, 9908, 26997, 26997, 53498, 53498 };
+
+#define SPELL_CAT_FORM              32356//768
+#define SPELL_CAT_FORM_MOD          3025
+#define CAT_HASTE/*rogue-Lightn.Re*/13789
+#define CAT_HASTE2/*Cobra Reflexes*/61683
+
+#define SPELL_CLAW                  SPELL_CLAW_A[SPELL_LEVEL]
+#define SPELL_RAKE                  SPELL_RAKE_A[SPELL_LEVEL]
+#define SPELL_SHRED                 SPELL_SHRED_A[SPELL_LEVEL]
+#define SPELL_RIP                   SPELL_RIP_A[SPELL_LEVEL]
+#define SPELL_MANGLE_CAT            SPELL_MANGLE_CAT_A[SPELL_LEVEL]
+
+uint32 SPELL_CLAW_A[] = { 0, 0, 1082, 3029, 5201, 9849, 9850, 27000, 48569, 67793 };
+uint32 SPELL_RAKE_A[] = { 0, 0, 1822, 1823, 1824, 9904, 27003, 27003, 48574, 53499 };
+uint32 SPELL_SHRED_A[] = { 0, 0, 5221, 6800, 8992, 9829, 9830, 27001, 27002, 48572 };
+uint32 SPELL_RIP_A[] = { 0, 0, 1079, 9492, 9493, 9752, 9894, 9896, 27008, 49800 };
+uint32 SPELL_MANGLE_CAT_A[] = { 0, 0, 0, 0, 0, 33982, 33983, 48565, 48566, 48566 };
+
+//BALANCE SPELLS
+#define SPELL_MOONFIRE              SPELL_MOONFIRE_A[SPELL_LEVEL]
+#define SPELL_STARFIRE              SPELL_STARFIRE_A[SPELL_LEVEL]
+#define SPELL_WRATH                 SPELL_WRATH_A[SPELL_LEVEL]
+#define SPELL_FAIRIE_FIRE           SPELL_FAIRIE_FIRE_A[SPELL_LEVEL]
+#define SPELL_HURRICANE             SPELL_HURRICANE_A[SPELL_LEVEL]
+
+uint32 SPELL_MOONFIRE_A[] = { 8921, 8924, 8925, 8928, 8929, 9834, 26987, 26988, 48463, 43545 };
+uint32 SPELL_STARFIRE_A[] = { 0, 0, 2912, 8950, 8951, 9875, 25298, 26986, 48465, 38935 };
+uint32 SPELL_WRATH_A[] = { 5176, 5177, 5178, 5179, 8905, 9912, 26984, 26985, 48461, 48461 };
+uint32 SPELL_FAIRIE_FIRE_A[] = { 0, 770, 770, 770, 770, 770, 65863, 65863, 65863, 65863 };
+uint32 SPELL_HURRICANE_A[] = { 0, 0, 0, 16914, 17401, 17401, 17402, 27012, 48467, 40090 };
+
+//PASSIVE
+//dam/crit
+#define SPELLDMG/*Arcane Instability-mage*/ 15060//rank3 3% dam/crit
+//dam
+#define SPELLDMG2/*Earth and Moon - druid*/ 48511//rank3 6% dam
+//Talents
+#define OMEN_OF_CLARITY                     16864
+#define NATURESGRACE                        61346
+#define NATURAL_PERFECTION1                 33881
+#define NATURAL_PERFECTION2                 33882
+#define NATURAL_PERFECTION3                 33883
+#define LIVING_SEED1                        48496//rank 1
+#define LIVING_SEED2                        48499//rank 2
+#define LIVING_SEED3                        48500//rank 3
+#define REVITALIZE1                         48539//rank 1
+#define REVITALIZE2                         48544//rank 2
+#define REVITALIZE3                         48545//rank 3
+//Glyphs
+#define GLYPH_SWIFTMEND                     54824//no consumption
+//other
+#define T9_RESTO_P4_BONUS                   67128//rejuve crits
+#define T8_RESTO_P4_BONUS                   64760//rejuve init heal 
+#define T9_BALANCE_P2_BONUS                 67125//moonfire crits
+#define T10_BALANCE_P2_BONUS                70718//omen of doom (15%)
+#define T10_BALANCE_P4_BONUS                70723//Languish(DOT)
+
+#define NATURESGRACEBUFF                    16886
+#define OMEN_OF_CLARITY_BUFF                16870
diff --git a/src/server/scripts/Bots/bot_hunter_ai.cpp b/src/server/scripts/Bots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..261401c
--- /dev/null
+++ b/src/server/scripts/Bots/bot_hunter_ai.cpp
@@ -0,0 +1,325 @@
+#include "ScriptPCH.h"
+#include "bot_hunter_ai.h"
+#include "Group.h"
+
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new hunter_botAI(pCreature);
+    }
+
+    struct hunter_botAI : public bot_ai
+    {
+        hunter_botAI(Creature *c) :bot_ai(c)
+        {
+            Reset();
+            pet = NULL;
+        }
+
+        bool oom_spam;
+
+        Unit *opponent;
+        Creature *pet;
+
+        int32 Potion_cd;
+
+        int32 ArcaneShot_cd;
+        int32 ChimeraShot_Timer;
+        int32 SilencingShot_Timer;
+        int32 AimedShot_Timer;
+        int32 Feign_Death_Timer;
+
+        void Reset()
+        {
+            oom_spam = false;
+
+            opponent = NULL;
+
+            Potion_cd = 0;
+            GC_Timer = 0;
+            ArcaneShot_cd = 0;
+            ChimeraShot_Timer = 0;
+            SilencingShot_Timer = 0;
+            AimedShot_Timer = 0;
+            Feign_Death_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_HUNTER, m_creature->getRace(), master->getLevel());
+                SetBotCommandState(COMMAND_FOLLOW);
+             }
+        }
+
+        void CreatePet()
+        {
+
+            pet = m_creature->GetBotsPet(60238);
+
+            if(pet == NULL)
+                return;
+
+            pet->UpdateCharmAI();
+            pet->setFaction(m_creature->getFaction());
+            pet->SetReactState(REACT_DEFENSIVE);
+            pet->GetMotionMaster()->MoveFollow(m_creature, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+            CharmInfo *charmInfonewbot = pet->InitCharmInfo();
+            pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+            pet->UpdateStats(STAT_STRENGTH);
+            pet->UpdateStats(STAT_AGILITY);
+            pet->SetLevel(master->getLevel());
+
+            /*float val2 = master->getLevel()*4.0f + pet->GetStat(STAT_STRENGTH)*5.0f;
+
+            val2=100.0;
+            uint32 attPowerMultiplier=1;
+            pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+            pet->UpdateAttackPowerAndDamage();
+            pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+            pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*3+master->getLevel());
+            pet->UpdateDamagePhysical(BASE_ATTACK);*/
+
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (!master) return;
+            ReduceCD(diff);
+
+            if(IAmDead()) return;
+
+            if(!m_creature->isInCombat())
+            {
+                DoNonCombatActions();
+            }
+
+            if(pet && pet != NULL && pet->isDead())
+            {
+                m_creature->SetBotsPetDied();
+                pet = NULL;
+            }
+
+            //if we think we have a pet, but master doesn't, it means we teleported
+            if(pet && m_creature->m_botHasPet == false)
+            {
+                m_creature->SetBotsPetDied();
+                pet = NULL;
+            }
+
+            DoNormalAttack(diff);
+            ScriptedAI::UpdateAI(diff);
+
+            //if low on health, drink a potion
+            if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.6 && isTimerReady(Potion_cd))
+            {
+                doCast(m_creature, HEALINGPOTION);
+                Potion_cd = 250;
+            }
+
+            //if low on mana, drink a potion
+             if(m_creature->GetPower(POWER_MANA) < m_creature->GetMaxPower(POWER_MANA)*0.1)
+            {
+                if(isTimerReady(Potion_cd))
+                {
+                    doCast(m_creature, MANAPOTION);
+                    //MonsterSay("MANA POTION", LANG_UNIVERSAL, NULL);
+                    Potion_cd = 450;
+                }
+             }
+
+            opponent = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+            if(!opponent && !m_creature->getVictim())
+            {
+                m_creature->CombatStop();
+                //ResetOrGetNextTarget();
+
+                //to reduce the number of crashes, remove pet whenever we are not in combat
+                if(pet != NULL && pet->isAlive())
+                {
+                    m_creature->SetBotsPetDied();
+                    pet = NULL;
+                }
+                return;
+            }
+
+
+            if(pet == NULL)
+                CreatePet();
+
+            if (pet && pet->isAlive() &&
+                !pet->isInCombat() &&
+                m_creature->getVictim()) {
+                pet->Attack (m_creature->getVictim(), true);
+                pet->GetMotionMaster()->MoveChase(m_creature->getVictim(), 1, 0);
+
+            }
+        }
+
+        void Aggro(Unit *who){}
+
+        void JustDied(Unit *Killer)
+        {if (!master) return;
+            SetBotCommandState(COMMAND_FOLLOW);
+        }
+
+        void KilledUnit(Unit *)
+        {
+            SetBotCommandState(COMMAND_FOLLOW);
+        }
+
+
+        void AttackStart(Unit *u)
+        {if (!master) return;
+            Aggro(u);
+            ScriptedAI::AttackStartCaster(u, 29);
+            m_creature->AddThreat(u, 0.001f);
+            u->AddThreat(m_creature, 0.001f);
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            if(opponent == NULL) return;
+            if(opponent->isDead()) return;
+
+
+            // try to get rid of enrage effect
+            if (TRANQ_SHOT && (HasAuraName(opponent, "Enrage") || (HasAuraName(opponent, "Frenzy")))) 
+            {
+                m_creature->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                m_creature->MonsterSay("Tranquil shot!", LANG_UNIVERSAL, NULL);
+                doCast(opponent, TRANQ_SHOT, true);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // silence it
+            if(SILENCING_SHOT && opponent->HasUnitState(UNIT_STAT_CASTING) && isTimerReady(SilencingShot_Timer))
+            {
+                doCast(opponent, SILENCING_SHOT);
+                SilencingShot_Timer = 250;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // mark it
+            if (!HasAuraName(opponent, "Hunter's Mark")) {
+                doCast(opponent, HUNTERS_MARK);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // sting it
+            if (SCORPID_STING && !opponent->HasAura(SCORPID_STING, m_creature->GetGUID())) 
+            {
+                m_creature->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, SCORPID_STING);
+               // m_creature->MonsterSay("Scorpid Sting!", LANG_UNIVERSAL, NULL);
+               // doCast(opponent, AUTO_SHOT);
+               // return;
+            }
+
+             if (CHIMERA_SHOT && isTimerReady(ChimeraShot_Timer)) {
+                m_creature->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, CHIMERA_SHOT);
+                ChimeraShot_Timer = 100;
+               // m_creature->MonsterSay("Chimera Sting!", LANG_UNIVERSAL, NULL);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if(ARCANE_SHOT && isTimerReady(ArcaneShot_cd))
+            {
+                m_creature->InterruptNonMeleeSpells( true, AUTO_SHOT );
+                doCast(opponent, ARCANE_SHOT);
+               // m_creature->MonsterSay("Arcane shot!", LANG_UNIVERSAL, NULL);
+                ArcaneShot_cd = 60;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if(AIMED_SHOT && isTimerReady(AimedShot_Timer))
+            {
+                m_creature->InterruptNonMeleeSpells( true, AUTO_SHOT );
+                doCast(opponent, AIMED_SHOT);
+               // m_creature->MonsterSay("Aimed shot!", LANG_UNIVERSAL, NULL);
+                AimedShot_Timer = 120;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+            //Temp Feign death For Debug
+            AttackerSet b_attackers = m_creature->getAttackers();
+            if (!b_attackers.empty())
+            {
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                if(*iter && (*iter)->getVictim()->GetGUID() == m_creature->GetGUID() && 
+                    m_creature->GetDistance(*iter) < 13    && 
+                    isTimerReady(Feign_Death_Timer))
+                {
+                    doCast(m_creature, FEIGN_DEATH, true);
+                    opponent->AddThreat(m_creature, -100000);
+                    m_creature->CombatStop();
+                    Feign_Death_Timer = 300;
+                    m_creature->SetBotMustWaitForSpell1(2000);//2 sec
+                    m_creature->CombatStart(opponent);
+                }
+            }
+
+            doCast(opponent, AUTO_SHOT);
+        }
+
+        void DoNonCombatActions()
+        {if (!master) return;
+            if(ASPECT_OF_THE_DRAGONHAWK && 
+                !HasAuraName(m_creature, "Aspect of the Dragonhawk") && 
+                doCast(master, ASPECT_OF_THE_DRAGONHAWK))
+                m_creature->AddAura(ASPECT_OF_THE_DRAGONHAWK, m_creature);
+        }
+
+        void ReduceCD(const uint32 diff)
+        {if (!master) return;
+            if(GC_Timer > 0)                --GC_Timer;
+            if(ArcaneShot_cd > 0)           --ArcaneShot_cd;
+            if(ChimeraShot_Timer > 0)       --ChimeraShot_Timer;
+            if(SilencingShot_Timer > 0)     --SilencingShot_Timer;
+            if(AimedShot_Timer > 0)         --AimedShot_Timer;
+            if(Feign_Death_Timer > 0)        --Feign_Death_Timer;
+        }
+
+        void ReceiveEmote(Player *player, uint32 emote)
+        {if (!master) return;
+            //debug to see what auras are on bot
+            //if(emote == TEXT_EMOTE_BONK) ((hunter_botAI*)m_creature->AI())->listAuras(m_creature);
+
+            //debug to see what auras are on me
+            //if(emote == TEXT_EMOTE_SALUTE) ((hunter_botAI*)m_creature->AI())->listAuras(player);
+
+
+            if(emote == TEXT_EMOTE_STAND)
+            {
+                if(m_creature->GetCharmerGUID() != player->GetGUID())
+                {
+                    m_creature->HandleEmoteCommand(TEXT_EMOTE_RUDE);
+                    return;
+                }
+
+                SetBotCommandState (COMMAND_STAY);
+            }
+            if(emote == TEXT_EMOTE_WAVE)
+            {
+                SetBotCommandState (COMMAND_FOLLOW);
+            }
+
+
+        }
+
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/scripts/Bots/bot_hunter_ai.h b/src/server/scripts/Bots/bot_hunter_ai.h
new file mode 100644
index 0000000..2979957
--- /dev/null
+++ b/src/server/scripts/Bots/bot_hunter_ai.h
@@ -0,0 +1,26 @@
+#include "bot_ai.h"
+
+#define AUTO_SHOT            75
+#define TRANQ_SHOT           TRANQ_SHOT_A[SPELL_LEVEL]
+#define SCORPID_STING        SCORPID_STING_A[SPELL_LEVEL]
+#define HUNTERS_MARK         HUNTERS_MARK_A[SPELL_LEVEL]
+
+#define ARCANE_SHOT          ARCANE_SHOT_A[SPELL_LEVEL]
+#define CHIMERA_SHOT         CHIMERA_SHOT_A[SPELL_LEVEL]
+#define AIMED_SHOT           AIMED_SHOT_A[SPELL_LEVEL]
+#define SILENCING_SHOT       SILENCING_SHOT_A[SPELL_LEVEL]
+#define ASPECT_OF_THE_DRAGONHAWK   ASPECT_OF_THE_DRAGONHAWK_A[SPELL_LEVEL]
+
+#define FEIGN_DEATH          5384
+
+uint32 TRANQ_SHOT_A[] = { 0, 0, 19801, 19801, 19801, 19801, 19801, 19801, 19801, 19801 };
+uint32 HUNTERS_MARK_A[] = { 14325, 14325, 14325, 14325, 14325, 14325, 14325, 14325, 53338, 53338 };
+uint32 SCORPID_STING_A[] = { 0, 0, 0, 0, 0, 0, 3043, 3043, 3043, 3043 };
+
+uint32 ARCANE_SHOT_A[] = { 3044, 14281, 14282, 14284, 14285, 14286, 27019, 49044, 49045, 36609 };
+uint32 CHIMERA_SHOT_A[] = { 0, 0, 0, 0, 0, 0, 53209, 53209, 53209, 53209 };
+uint32 AIMED_SHOT_A[] = { 0, 0, 19434, 20900, 20902, 20903, 20904, 49049, 49050, 67979 };
+uint32 SILENCING_SHOT_A[] = { 0, 0, 0, 34490, 34490, 34490, 34490, 34490, 34490, 42671 };
+
+uint32 ASPECT_OF_THE_DRAGONHAWK_A[] = {0, 0, 0, 0, 61846, 61846, 61846, 61847, 61847, 61847 };
+
diff --git a/src/server/scripts/Bots/bot_mage_ai.cpp b/src/server/scripts/Bots/bot_mage_ai.cpp
new file mode 100644
index 0000000..334a700
--- /dev/null
+++ b/src/server/scripts/Bots/bot_mage_ai.cpp
@@ -0,0 +1,727 @@
+#include "bot_mage_ai.h"
+//#include "Group.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 65%
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new mage_botAI(pCreature);
+    }
+
+    struct mage_botAI : public bot_ai
+    {
+        mage_botAI(Creature *c) :bot_ai(c)
+        {
+            Reset();
+        }
+        uint8 Pyroblast_cd;
+        uint16 Haste_cd;
+        uint16 Iceblock_cd;
+        uint8 Bolt_cd;
+        uint8 FireBlast_cd;
+        uint8 CounterSpell_cd;
+        uint8 Nova_cd;
+        uint8 Blizzard_cd;
+        uint8 DragonBreath_cd;
+        uint16 Combustion_cd;
+        uint16 Evocation_cd;
+        uint8 Living_Bomb_cd;
+        uint8 ConeofCold_cd;
+        uint8 Ice_Barrier_cd;
+
+        uint8 polyCheckTimer;
+
+        bool Polymorph;
+        bool clearcast;
+
+        uint32 BOLT;
+        uint32 NOVA;
+
+        void Reset()
+        {
+            Pyroblast_cd = 0;
+            Ice_Barrier_cd = 0;
+            Iceblock_cd = 0;
+            Haste_cd = 300;
+            ConeofCold_cd = 0;
+
+            Blizzard_cd = 100;
+            FireBlast_cd = 0;
+            Bolt_cd =0;
+            CounterSpell_cd = 0;
+            Nova_cd = 0;
+            DragonBreath_cd = 0;
+            Potion_cd = 0;
+            Combustion_cd = 300;//30 sec for reset
+            Evocation_cd = 0;
+            GC_Timer = 0;
+            Polymorph = false;
+            clearcast = false;
+
+            BOLT = FROSTBOLT;//default frost
+            NOVA = BLASTWAVE != 0 ? BLASTWAVE : FROSTNOVA;
+
+            temptimer = 0;
+            checkAurasTimer = 0;
+            wait = 15;
+            polyCheckTimer = 0;
+
+            opponent = NULL;
+
+            if (master) 
+            {
+                setStats(CLASS_MAGE, m_creature->getRace(), master->getLevel(), true);
+
+                //Aura
+                if (master->getLevel() >= 78)
+                    RefreshAura(BRILLIANCE_AURA); //+100% spirit
+                //Talents
+                //Dam+(-Hit)
+                if (master->getLevel() >= 60)
+                    RefreshAura(ARCTIC_WINDS,4); //+20%/-20%
+                else if (master->getLevel() >= 50)
+                    RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
+                else if (master->getLevel() >= 25)
+                    RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
+                else if (master->getLevel() >= 10)
+                    RefreshAura(ARCTIC_WINDS); //+5%/-5%
+                //CHILL
+                if (master->getLevel() >= 30)
+                    RefreshAura(WINTERS_CHILL3); //100%
+                else if (master->getLevel() >= 25)
+                    RefreshAura(WINTERS_CHILL2); //66%
+                else if (master->getLevel() >= 20)
+                    RefreshAura(WINTERS_CHILL1); //33%
+                //Frostbite
+                if (master->getLevel() >= 60)
+                    RefreshAura(FROSTBITE,3);//3x
+                else if (master->getLevel() >= 30)
+                    RefreshAura(FROSTBITE,2);//2x
+                else if (master->getLevel() >= 10)
+                    RefreshAura(FROSTBITE);//1x
+                //
+                if (master->getLevel() >= 45)
+                    RefreshAura(SHATTERED_BARRIER);
+                //Bonus
+                if (master->getLevel() >= 75)
+                    RefreshAura(ARCANE_INSTABILITY,5); //+15%dmg crit
+                else if (master->getLevel() >= 65)
+                    RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
+                else if (master->getLevel() >= 55)
+                    RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
+                else if (master->getLevel() >= 45)
+                    RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
+                else if (master->getLevel() >= 35)
+                    RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
+                //Absorb
+                if (master->getLevel() >= 50)
+                    RefreshAura(INCANTERS_ABSORPTION3);
+                else if (master->getLevel() >= 45)
+                    RefreshAura(INCANTERS_ABSORPTION2);
+                else if (master->getLevel() >= 40)
+                    RefreshAura(INCANTERS_ABSORPTION1);
+                //Shatter
+                if (master->getLevel() >= 35)
+                    RefreshAura(SHATTER3);
+                else if (master->getLevel() >= 30)
+                    RefreshAura(SHATTER2);
+                else if (master->getLevel() >= 25)
+                    RefreshAura(SHATTER1);
+                //ClearCasting
+                if (master->getLevel() >= 75)
+                    RefreshAura(CLEARCAST,3);//30%
+                else if (master->getLevel() >= 40)
+                    RefreshAura(CLEARCAST,2);//20%
+                else if (master->getLevel() >= 15)
+                    RefreshAura(CLEARCAST);//10%
+                //Fingers
+                if (master->getLevel() >= 45)
+                    RefreshAura(FINGERS_OF_FROST);//15%
+                //Potency
+                if (master->getLevel() >= 40)
+                    RefreshAura(ARCANE_POTENCY2);//30% bonus
+                else if (master->getLevel() >= 35)
+                    RefreshAura(ARCANE_POTENCY1);//15% bonus
+                //Ignite
+                if (master->getLevel() >= 15)
+                    RefreshAura(IGNITE);
+                //Imp. Counterspell
+                if (master->getLevel() >= 35)
+                    RefreshAura(IMPROVED_COUNTERSPELL2);//4 sec
+                else if (master->getLevel() >= 25)
+                    RefreshAura(IMPROVED_COUNTERSPELL1);//2 sec
+                //Firestarter
+                if (master->getLevel() >= 55)
+                    RefreshAura(FIRESTARTER2);//100% chance
+                else if (master->getLevel() >= 45)
+                    RefreshAura(FIRESTARTER1);//50% chance
+
+                if (LIVINGBOMB != 0)
+                    RefreshAura(GLYPH_LIVING_BOMB);
+                if (POLYMORPH != 0)
+                    RefreshAura(GLYPH_POLYMORPH);
+
+                ApplyPassives(CLASS_MAGE);
+                SetBotCommandState(COMMAND_FOLLOW);
+           }
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (Feasting() && !master->isInCombat() && 
+                !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (m_creature->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != MANAPOTION && spellId != HEALINGPOTION) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                DoCast(victim, spellId, triggered);
+                m_creature->EnergizeBySpell(m_creature, spellId, urand(m_creature->GetMaxPower(POWER_MANA)/3,m_creature->GetMaxPower(POWER_MANA)), POWER_MANA);
+                return true;
+            }
+            m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+            if (master->getLevel() >= 78)
+                GC_Timer = 8;
+            else if (master->getLevel() >= 70)
+                GC_Timer = 10;
+            else if (master->getLevel() >= 50)
+                GC_Timer = 12;
+            else if (master->getLevel() >= 35)
+                GC_Timer = 14;
+            else if (master->getLevel() >= 25)
+                GC_Timer = 16;
+            else if (master->getLevel() >= 15)
+                GC_Timer = 18;
+            else
+                GC_Timer = 20;
+
+            if (!victim->IsWithinLOSInMap(m_creature) && IsInBotParty(victim))
+                m_creature->Relocate(victim);
+
+            DoCast(victim, spellId, triggered);
+            if (m_creature->HasAura(CLEARCASTBUFF))
+            {
+                info = sSpellMgr->GetSpellInfo(spellId);
+                cost = info->CalcPowerCost(m_creature, info->GetSchoolMask());
+                clearcast = true;
+            }
+            return true;
+        }
+
+        void Aggro(Unit *who){}
+
+        void EnterEvadeMode()
+        {if (!master) return;
+            if (!me->isAlive())
+                return;
+            if (m_creature->IsInEvadeMode())
+                return;
+            if (!IsEvent())
+            {
+                if (!m_creature->getThreatManager().isThreatListEmpty())
+                    m_creature->DeleteThreatList();
+                if (m_creature->isInCombat())
+                {
+                    if (IsChanneling())
+                        m_creature->CombatStop(false);
+                    else
+                        m_creature->CombatStop(true);
+                }
+                Follow();
+            }
+        }
+
+        void JustDied(Unit *Killer)
+        {if (!master) return;
+            Follow();
+        }
+
+        void AttackStart(Unit *u)
+        {if (!master) return;
+            if (u && !IsInBotParty(u) && u->isTargetableForAttack())
+            { Aggro(u); m_creature->AddThreat(u, 0.001f); opponent = u; m_creature->SetBotCommandState(COMMAND_ATTACK); }
+        }
+
+        void KilledUnit(Unit *)
+        {if (!master) return;
+            Unit *u = master->GetSelectedUnit();
+            if (!u || !u->isInCombat() || !u->IsHostileTo(master))            {
+                if (!IsEvent())
+                {
+                    if (!master->getVictim() && master->getAttackers().empty() && master->isInCombat())
+                        master->CombatStop();
+                    if (!master->isInCombat())
+                        m_creature->CombatStop();
+                }
+            }
+            SetBotCommandState(COMMAND_FOLLOW);
+            //ResetOrGetNextTarget();
+        }
+
+        void Counter(const uint32 diff)
+        {
+            if (opponent && opponent->isAlive() && 
+                opponent->isTargetableForAttack() && 
+                m_creature->GetDistance(opponent) < 30 && 
+                opponent->HasUnitState(UNIT_STAT_CASTING) && 
+                CounterSpell_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (m_creature->IsNonMeleeSpellCasted(false))
+                    m_creature->InterruptNonMeleeSpells(false);
+                if (doCast(opponent, COUNTERSPELL))
+                    CounterSpell_cd = COUNTERSPELL_CD;
+                GC_Timer = temptimer;
+            }
+            else if (CounterSpell_cd <= 50)//means "every 10 seconds"
+            {
+                Unit *target = FindCastingTarget(30);
+                if (target)
+                {
+                    temptimer = GC_Timer;
+                    if (m_creature->IsNonMeleeSpellCasted(false))
+                        m_creature->InterruptNonMeleeSpells(false);
+                    if (doCast(target, COUNTERSPELL))
+                        CounterSpell_cd = COUNTERSPELL_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        bool HandleCure(DispelType dispel, Unit *target)//BROKEN
+        {
+            if (dispel == DISPEL_CURSE && doCast(target, REMOVE_CURSE))
+                return true;
+            return false;
+        }
+
+        bool CheckSpellSteal(const uint32 diff)
+        {
+            if (!SPELLSTEAL || !isTimerReady(GC_Timer)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            Unit *target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, SPELLSTEAL))
+                return true;
+            return false;
+        }
+
+        void DoNonCombatActions()
+        {
+            //buff myself
+            if (!m_creature->HasAura(SELF_ARCANEINTELLECT) && isTimerReady(GC_Timer) && 
+                doCast(m_creature, SELF_ARCANEINTELLECT))
+            { }
+
+            //check group members
+            std::list<Unit*> unitList;
+            master->GetRaidMember(unitList,30);
+            if (!unitList.empty())
+            {
+                uint8 Bots = 0;
+                for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr)
+                {
+                    Player *tPlayer = ObjectAccessor::FindPlayer((*itr)->GetGUID());
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (tPlayer->HaveBot())
+                        ++Bots;
+                    if (tPlayer->getPowerType() != POWER_MANA) continue;
+                    //buff group
+                    if (isTimerReady(GC_Timer) && 
+                        !HasAuraName(tPlayer, ARCANEINTELLECT) && 
+                        doCast(tPlayer, ARCANEINTELLECT))
+                        GC_Timer = 8;
+                }
+                if (Bots > 0)
+                {
+                    for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end();++itr)
+                    {
+                        Player *tPlayer = ObjectAccessor::FindPlayer((*itr)->GetGUID());
+                        if (!tPlayer || tPlayer->isDead()) continue;
+                        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                        {
+                            Creature *cre = master->GetBotMap()[i].m_creature;
+                            if (!cre || !cre->IsInWorld() || m_creature->GetDistance(cre) > 30) continue;
+                            //buff
+                            if (isTimerReady(GC_Timer) && cre->getPowerType() == POWER_MANA && 
+                                !HasAuraName(cre, ARCANEINTELLECT) && 
+                                doCast(cre, ARCANEINTELLECT))
+                            {
+                                m_creature->AddAura(ARCANEINTELLECT, cre);
+                                GC_Timer = 8;
+                            }
+                        }
+                    }
+                }
+            }
+            //other buffs
+            if (!HasAuraName(m_creature, DAMPENMAGIC) && isTimerReady(GC_Timer) && 
+                doCast(m_creature, DAMPENMAGIC))
+                GC_Timer = 8;
+
+            if (!HasAuraName(m_creature, ICEARMOR) && isTimerReady(GC_Timer) && 
+                doCast(m_creature, ICEARMOR))
+                GC_Timer = 8;
+
+            //buff master because master might be in different group
+            if (master->getPowerType() == POWER_MANA && 
+                !master->HasAura(ARCANEINTELLECT) && 
+                master->isAlive() && 
+                isTimerReady(GC_Timer) && 
+                doCast(master, ARCANEINTELLECT)) { }
+        }
+
+        void UpdateAI(const uint32 diff)
+        {if (!master) return;
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (m_creature->HasAura(CLEARCASTBUFF) && clearcast && !m_creature->IsNonMeleeSpellCasted(true))
+            {
+                m_creature->EnergizeBySpell(m_creature, CLEARCASTBUFF, cost, POWER_MANA);
+                m_creature->RemoveAurasDueToSpell(CLEARCASTBUFF,m_creature->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (m_creature->HasAura(57529))
+                    m_creature->RemoveAurasDueToSpell(57529,m_creature->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (m_creature->HasAura(57531))
+                    m_creature->RemoveAurasDueToSpell(57531,m_creature->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = urand(1,3);
+            else
+                return;
+            if (checkAurasTimer <= 0)
+            {
+                CheckAuras();
+                checkAurasTimer = 30;
+            }
+            if (CCed()) return;
+            if (polyCheckTimer <= 0 && !m_creature->HasUnitState(UNIT_STAT_CASTING))
+            {
+                if (FindAffectedTarget(POLYMORPH, m_creature->GetGUID()))
+                    Polymorph = true;
+                else
+                    Polymorph = false;
+                polyCheckTimer = 20;
+            }
+            else
+                Polymorph = true;
+
+            if (master->GetGroup())
+                CureGroup(master);
+            CureTarget(m_creature);
+
+            if (GetHealthPCT(m_creature) < 70 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, HEALINGPOTION)) Potion_cd = 200; //20 secs
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(m_creature) < 25 && isTimerReady(Evocation_cd) && doCast(m_creature, EVOCATION))
+                Evocation_cd = EVOCATION_CD;
+            if (GetManaPCT(m_creature) < 45 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, MANAPOTION)) Potion_cd = MANA_CD;
+                GC_Timer = temptimer;
+            }
+            //PolyCheck
+            if (master->isInCombat() || m_creature->isInCombat())
+            {
+                if (Polymorph == false && isTimerReady(GC_Timer) && !m_creature->HasUnitState(UNIT_STAT_CASTING))
+                {
+                    Unit *target = FindPolyTarget();
+                    if (target && doCast(target, POLYMORPH))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer = 20;
+                    }
+                }
+            }
+            //endPolyCheck
+            opponent = getTarget();
+            if (!opponent)
+                opponent = m_creature->getVictim();
+
+            if (!CheckTarget(opponent) || !opponent)
+                return;
+
+            if (CCed(opponent))
+                ChangeTarget(opponent, 20);
+
+            Counter(diff);
+            CheckSpellSteal(diff);
+            if (master->GetDistance(opponent) < 20)
+                ScriptedAI::AttackStartCaster(opponent, 16);
+            else if (!m_creature->HasUnitState(UNIT_STAT_CASTING) && m_creature->GetDistance(master) > 10)
+            {
+                m_creature->Relocate(master);
+                SetBotCommandState(COMMAND_FOLLOW);
+                return;
+            }
+            DoNormalAttack(diff);
+            ScriptedAI::UpdateAI(diff);
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack())
+            {
+                if (opponent->isDead() && m_creature->IsNonMeleeSpellCasted(true))
+                    m_creature->InterruptNonMeleeSpells(true);
+                return;
+            }
+            bool defensive = false;
+
+            NOVA = (BLASTWAVE && (m_creature->HasAura(COMBUSTION) || CCed(opponent))) ? BLASTWAVE : FROSTNOVA;
+            BOLT = (CCed(opponent) || (CCed(opponent, true) && m_creature->HasAura(COMBUSTION))) ? FIREBALL : FROSTBOLT;
+            
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = m_creature->getAttackers();
+
+            //opponent is attacking me, go defensive, ie point blank spells
+            //if (opponent->getVictim() && opponent->getVictim()->GetGUID() == m_creature->GetGUID())
+            Unit *u = m_creature->SelectNearestTarget(20);
+            if (u && !b_attackers.empty() && 
+                u->GetDistance(m_creature) < 8)
+                defensive = true;
+
+            if (defensive == false)
+            {
+                //ScriptedAI::AttackStartCaster(opponent, 18);
+                //Position
+                if (master->GetDistance(opponent) < 15)
+                    ScriptedAI::AttackStartCaster(opponent, 13);
+                else if (!m_creature->HasUnitState(UNIT_STAT_CASTING) && m_creature->GetDistance(master) > 10)
+                {
+                    m_creature->Relocate(master);
+                    SetBotCommandState(COMMAND_FOLLOW);
+                    return;
+                }
+            }
+
+            //ICE_BARRIER
+            if (ICE_BARRIER && 
+                u && u->getVictim() == m_creature && 
+                u->GetDistance(m_creature) < 8 && 
+                !m_creature->HasAura(ICE_BARRIER) && 
+                isTimerReady(Ice_Barrier_cd))
+            {
+                if (m_creature->IsNonMeleeSpellCasted(true))
+                    m_creature->InterruptNonMeleeSpells(true);
+                if (doCast(m_creature, ICE_BARRIER))
+                { Ice_Barrier_cd = 250; GC_Timer = 8; }
+            }
+            if (COMBUSTION && 
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*10 
+                || m_attackers.size() > 1 
+                || b_attackers.size() > 2))
+            {
+                if (!HasAuraName(m_creature, "Combustion") && Combustion_cd <= 0)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(m_creature, COMBUSTION))
+                    {
+                        Combustion_cd = COMBUSTION_CD;
+                        //Reset timers for fun
+                        Nova_cd = 0; FireBlast_cd = 0; DragonBreath_cd = 0;
+                    }
+                    GC_Timer = temptimer;
+                }
+            }
+            //ARCANE HASTE
+            u = m_creature->SelectNearestTarget(50);
+            if (m_creature->getLevel() >= 75 && 
+               b_attackers.empty() && u && 
+               u->GetMaxHealth() > master->GetMaxHealth()*10 && //instance creature alone
+               master->getLevel() >= 75 && !m_creature->HasAura(ARCANE_HASTE) && 
+              (m_creature->isInCombat() || master->isInCombat()) && 
+               Haste_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, ARCANE_HASTE)) Haste_cd = 1500;//2.5 min
+                GC_Timer = temptimer;
+            }
+
+            //ICEBLOCK
+            if (m_creature->getLevel() >= 20 && 
+                !b_attackers.empty() && 
+                (GetManaPCT(m_creature) < 25 || GetHealthPCT(m_creature) < 45) && 
+                !m_creature->HasAura(ICEBLOCK) && 
+                Iceblock_cd <= 0)
+            {
+                if (m_creature->IsNonMeleeSpellCasted(true))
+                    m_creature->InterruptNonMeleeSpells(true);
+                if (doCast(m_creature, ICEBLOCK))
+                    Iceblock_cd = ICEBLOCK_CD;
+            }
+            if (m_creature->HasAura(ICEBLOCK) && 
+                GetManaPCT(m_creature) > 50 && GetHealthPCT(m_creature) > 80)
+                m_creature->RemoveAurasDueToSpell(ICEBLOCK);
+
+            //target check
+            if (HasAuraName(opponent, POLYMORPH))
+            {
+                Unit *opponent2 = m_creature->SelectNearestTarget(25);
+                if (opponent2)
+                {
+                    u = opponent2->getVictim();
+                    if (u && opponent2 != opponent && IsInBotParty(u))
+                        opponent = opponent2;
+                }
+            }
+
+            //DAMAGE
+
+            /*if (POLYMORPH && Polymorph == false && 
+                (opponent->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                opponent->GetCreatureType() == CREATURE_TYPE_BEAST) && 
+                opponent->getAttackers().size() <= 1 && 
+                !opponent->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && 
+                !HasAuraName(opponent, POLYMORPH) && 
+                b_attackers.size() < 2 && 
+                GetHealthPCT(opponent) > 70 && 
+                m_creature->GetDistance(opponent) < 30 && 
+                isTimerReady(GC_Timer) && doCast(opponent, POLYMORPH))
+            { }*/
+            //pyroblast
+            if (PYROBLAST && isTimerReady(Pyroblast_cd) && 
+                defensive == false && b_attackers.size() < 2 && 
+                m_creature->GetDistance(opponent) < 30 && 
+                HasAuraName(opponent, POLYMORPH) && 
+                doCast(opponent, PYROBLAST))
+            { }
+            //nova
+            u = m_creature->SelectNearestTarget(7);
+            if (u && isTimerReady(Nova_cd) && !HasAuraName(u, DRAGONBREATH))
+            {
+                Unit *tar = u->getVictim();
+                if (tar && IsInBotParty(tar) && doCast(m_creature, NOVA))
+                {
+                    Nova_cd = NOVA_CD;
+                    return;
+                }
+            }
+            //living bomb
+            if (LIVINGBOMB != 0 && isTimerReady(Living_Bomb_cd) && 
+                m_creature->GetDistance(opponent) < 30 && 
+                !opponent->HasAura(LIVINGBOMB, m_creature->GetGUID()) && 
+                doCast(opponent, LIVINGBOMB))
+            {
+                Living_Bomb_cd = LIVING_BOMB_CD;
+                GC_Timer = 5;
+            }
+            //cone of cold
+            if (CONEOFCOLD != 0 && isTimerReady(ConeofCold_cd) && 
+                m_creature->GetDistance(opponent) < 8 && doCast(opponent, CONEOFCOLD))
+            {
+                ConeofCold_cd = CONEOFCOLD_CD;
+                GC_Timer = 5;
+            }
+            //dragon's breath
+            u = m_creature->SelectNearestTarget(7);
+            if (DRAGONBREATH != 0 && u && isTimerReady(DragonBreath_cd) && 
+                !HasAuraName(u, FROSTNOVA) && doCast(opponent, DRAGONBREATH))
+            {
+                DragonBreath_cd = DRAGONBREATH_CD;
+                GC_Timer = 8;
+            }
+            /*//blast wave
+            u = m_creature->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) && 
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) && 
+                doCast(m_creature, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 8;
+            }*/
+            //fire blast
+            if (isTimerReady(FireBlast_cd) && 
+                m_creature->GetDistance(opponent) < 30 && 
+                doCast(opponent, FIREBLAST))
+            {
+                FireBlast_cd = FIREBLAST_CD;
+                GC_Timer = 5;
+            }
+            //flamestrike
+            if (m_creature->HasAura(FIRESTARTERBUFF) && !m_creature->HasUnitState(UNIT_STAT_CASTING))
+            {
+                Unit *FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, FLAMESTRIKE, true))
+                    m_creature->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+            }
+            //blizzard
+            if (BLIZZARD && isTimerReady(Blizzard_cd) && !m_creature->HasUnitState(UNIT_STAT_CASTING))
+            {
+                Unit *blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, BLIZZARD))
+                    Blizzard_cd = BLIZZARD_CD;
+            }
+            //Frost of Fire Bolt
+            if (isTimerReady(Bolt_cd) && 
+                !HasAuraName(opponent, POLYMORPH) && 
+                m_creature->GetDistance(opponent) < 30 && 
+                doCast(opponent, BOLT))
+                Bolt_cd = sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100 * m_creature->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1;
+            else
+            {
+                u = m_creature->SelectNearestTarget(25);
+                if (u)
+                {
+                    opponent = u;
+                    return;
+                }
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {if (!master) return;
+            if (Pyroblast_cd > 0)    --Pyroblast_cd;
+            if (Ice_Barrier_cd > 0)  --Ice_Barrier_cd;
+            if (Iceblock_cd > 0)     --Iceblock_cd;
+            if (Haste_cd > 0)        --Haste_cd;
+            if (ConeofCold_cd > 0)   --ConeofCold_cd;
+            if (Living_Bomb_cd > 0)  --Living_Bomb_cd;
+            if (FireBlast_cd > 0)    --FireBlast_cd;
+            if (Bolt_cd > 0)         --Bolt_cd;
+            if (Blizzard_cd > 0)     --Blizzard_cd;
+            if (CounterSpell_cd > 0) --CounterSpell_cd;
+            if (Nova_cd > 0)         --Nova_cd;
+            //if (PoM_cd > 0)          --PoM_cd;
+            //if (Ward_cd > 0)         --Ward_cd;
+            if (DragonBreath_cd > 0) --DragonBreath_cd;
+            //if (Blink_cd > 0)        --Blink_cd;
+            if (Combustion_cd > 0)   --Combustion_cd;
+            if (Potion_cd > 0)       --Potion_cd;
+            if (Evocation_cd > 0)    --Evocation_cd;
+            //if (FirstAid_cd >0)      --FirstAid_cd;
+            if (GC_Timer > 0)        --GC_Timer;
+            if (temptimer > 0)       --temptimer;
+            if (checkAurasTimer > 0) --checkAurasTimer;
+            if (wait > 0)            --wait;
+            if (polyCheckTimer > 0)  --polyCheckTimer;
+        }
+
+        void ReceiveBowEmote(Player *player)
+        {
+            if (m_creature->GetDistance(player) < 30)
+                ((mage_botAI*)m_creature->AI())->doCast(player, ARCANEINTELLECT);
+            else
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                DoSay("Come closer, you fool", LANG_UNIVERSAL, player->GetGUID());
+            }
+        }
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/scripts/Bots/bot_mage_ai.h b/src/server/scripts/Bots/bot_mage_ai.h
new file mode 100644
index 0000000..5f3a886
--- /dev/null
+++ b/src/server/scripts/Bots/bot_mage_ai.h
@@ -0,0 +1,123 @@
+#include "bot_ai.h"
+
+//arcane spells cooldown
+#define EVOCATION_CD 600
+#define COUNTERSPELL_CD 150
+//#define POM_CD 200//nUY
+//#define BLINK_CD 150
+
+//fire spells cooldown
+#define DRAGONBREATH_CD 250
+#define FIREBLAST_CD 60//80 if not fire mage
+#define COMBUSTION_CD 600//1min
+#define LIVING_BOMB_CD 40
+#define PYROBLAST_CD 30
+
+//frost spells cooldown
+#define CONEOFCOLD_CD 140
+#define ICEBLOCK_CD 600
+#define BLIZZARD_CD 50
+
+//Universal
+#define NOVA_CD 150
+
+//arcane spells
+#define DAMPENMAGIC     SPELL_DAMPENMAGIC_A[SPELL_LEVEL]
+#define SPELLSTEAL      SPELL_SPELLSTEAL_A[SPELL_LEVEL]
+#define ARCANEINTELLECT SPELL_ARCANEINTELLECT_A[SPELL_LEVEL]
+//#define ARCANEEXPLOSION SPELL_ARCANEEXPLOSION_A[SPELL_LEVEL]
+#define POLYMORPH       SPELL_POLYMORPH_A[SPELL_LEVEL]
+#define COUNTERSPELL    2139
+#define EVOCATION       12051
+//#define BLINK         1953
+//#define ARCANETORRENT 28730
+
+//fire spells
+#define FIREBALL        SPELL_FIREBALL_A[SPELL_LEVEL]
+#define BLASTWAVE       SPELL_BLASTWAVE_A[SPELL_LEVEL]
+#define DRAGONBREATH    SPELL_DRAGONBREATH_A[SPELL_LEVEL]
+#define FIREBLAST       SPELL_FIREBLAST_A[SPELL_LEVEL]
+//#define FIREWARD        SPELL_FIREWARD_A[SPELL_LEVEL]
+#define PYROBLAST       SPELL_PYROBLAST_A[SPELL_LEVEL]
+#define LIVINGBOMB      SPELL_LIVING_BOMB_A[SPELL_LEVEL]
+#define FLAMESTRIKE     SPELL_FLAMESTRIKE_A[SPELL_LEVEL]
+#define COMBUSTION      SPELL_COMBUSTION_A[SPELL_LEVEL]
+
+uint32 SPELL_COMBUSTION_A[] = { 0, 0, 0, 0, 11129, 11129, 11129, 11129, 11129, 11129 };
+
+//frost spells
+#define FROSTNOVA       SPELL_FROSTNOVA_A[SPELL_LEVEL]
+#define FROSTWARD       SPELL_FROSTWARD_A[SPELL_LEVEL]
+#define CONEOFCOLD      SPELL_CONEOFCOLD_A[SPELL_LEVEL]
+#define ICEARMOR        SPELL_ICEARMOR_A[SPELL_LEVEL]
+#define ICEBLOCK        45438
+#define BLIZZARD        SPELL_BLIZZARD_A[SPELL_LEVEL]
+
+//arcane spells
+uint32 SPELL_DAMPENMAGIC_A[] = { 0, 8450, 8451, 10173, 10173, 10174, 33944, 43015, 41478, 41478 };
+//uint32 SPELL_MANASHIELD_A[] = { 0, 0, 1463, 8495, 10191, 10192, 27131, 43019, 38151, 38151 };
+//uint32 SPELL_MAGEARMOR_A[] = { 0, 0, 0, 6117, 22782, 22783, 27125, 43023, 43024 };
+uint32 SPELL_SPELLSTEAL_A[] = { 0, 0, 0, 0, 0, 30449, 30449, 30449, 30449, 30449 };
+//uint32 SPELL_ARCANEMISSILES_A[] = { 5143, 5144, 5145, 8416, 8417, 10212, 27075, 42843, 42846 };//NUY
+uint32 SPELL_ARCANEINTELLECT_A[] = { 1459, 1460, 1461, 1461, 10156, 10157, 10157, 27126, 42995, 42995 };
+//uint32 SPELL_ARCANEEXPLOSION_A[] = { 0, 1449, 8437, 8439, 10201, 10202, 27080, 42990, 59245, 59245 };
+uint32 SPELL_POLYMORPH_A[] = { 0, 0, 118, 12824, 12825, 12825, 12826, 12826, 12826, 12826 };
+//fire spells
+uint32 SPELL_FIREBALL_A[] = { 133, 145, 3140, 8401, 8402, 10149, 10151, 38692, 42833, 42833 };
+uint32 SPELL_BLASTWAVE_A[] = { 0, 0, 0, 11113, 13019, 13020, 13021, 27133, 42945, 33933 };
+uint32 SPELL_DRAGONBREATH_A[] = { 0, 0, 0, 0, 0, 31661, 33042, 33043, 42950, 42950 };
+uint32 SPELL_FIREBLAST_A[] = { 0, 2136, 2138, 8412, 10197, 27078, 42872, 36339, 36339 };
+//uint32 SPELL_FIREWARD_A[] = { 0, 0, 543, 8457, 8458, 10223, 10225, 27128, 43010 };//NUY
+uint32 SPELL_PYROBLAST_A[] = { 0, 0, 11366, 12522, 12525, 12526, 27132, 42890, 38535, 38535 };
+//uint32 SPELL_SCORCH_A[] = { 0, 0, 2948, 8445, 10205, 10207, 27073, 27074, 36807, 36807 };//DPRC
+uint32 SPELL_LIVING_BOMB_A[] = { 0, 0, 0, 0, 0, 44457, 44457, 55359, 55360, 55360 };
+uint32 SPELL_FLAMESTRIKE_A[] = { 0, 2120, 2121, 8422, 8423, 10215, 10216, 42925, 42926, 42926 };
+//frost spells
+uint32 SPELL_FROSTNOVA_A[] = { 0, 122, 865, 6131, 10230, 27088, 27088, 42917, 42917, 42917 };
+//uint32 SPELL_FROSTWARD_A[] = { 0, 0, 6143, 8461, 8462, 10177, 28609, 32796, 43012 };//NUY
+uint32 SPELL_CONEOFCOLD_A[] = { 0, 0, 120, 8492, 10159, 10161, 27087, 42930, 42931, 42931 };
+uint32 SPELL_ICEARMOR_A[] = { 0, 0, 0, 7302, 7320, 10219, 10220, 27124, 43008, 43008 };
+uint32 SPELL_BLIZZARD_A[] = { 0, 0, 10, 6141, 10185, 10185, 10186, 27085, 42940, 21367 };
+
+#define SELF_ARCANEINTELLECT                SELF_ARCANEINTELLECT_A[SPELL_LEVEL]
+uint32 SELF_ARCANEINTELLECT_A[] = { 1459, 1460, 1461, 1461, 10156, 10157, 10157, 27126, 36880, 36880 };
+#define ICE_BARRIER                         ICE_BARRIER_A[SPELL_LEVEL]
+uint32 ICE_BARRIER_A[] = { 0, 0, 13031, 13032, 13033, 27134, 33405, 43038, 43039, 43039 };
+#define FROSTBOLT                           FROSTBOLT_A[SPELL_LEVEL]
+uint32 FROSTBOLT_A[] = { 116, 837, 8406, 8407, 10179, 10181, 27071, 38697, 42842, 42842 };
+
+//AURA
+#define BRILLIANCE_AURA                     31260
+#define ARCANE_HASTE                        50182
+//PASSIVE
+//Talents
+#define FROSTBITE                           FROSTBITE_A[SPELL_LEVEL]
+uint32 FROSTBITE_A[] = { 0, 11071, 11071, 11071, 11071, 12496, 12496, 12496, 12497, 12497 };
+#define IGNITE                              IGNITE_A[SPELL_LEVEL]
+uint32 IGNITE_A[] = { 0, 11120, 12846, 12847, 12848, 12848, 12848, 12848, 12848, 12848 };
+#define SHATTERED_BARRIER                   54787//rank 2
+#define ARCTIC_WINDS                        31678//rank 5
+#define WINTERS_CHILL1                      11180
+#define WINTERS_CHILL2                      28592
+#define WINTERS_CHILL3                      28593
+#define CLEARCAST /*Arcane Concentration*/  12577//rank 5
+#define ARCANE_POTENCY1                     31571
+#define ARCANE_POTENCY2                     31572
+#define SHATTER1                            11170
+#define SHATTER2                            12982
+#define SHATTER3                            12983
+#define INCANTERS_ABSORPTION1               44394
+#define INCANTERS_ABSORPTION2               44395
+#define INCANTERS_ABSORPTION3               44396
+#define FINGERS_OF_FROST                    44545//rank 2
+#define ARCANE_INSTABILITY                  15060//rank 3
+#define IMPROVED_COUNTERSPELL1              11255
+#define IMPROVED_COUNTERSPELL2              12598
+#define FIRESTARTER1                        44442
+#define FIRESTARTER2                        44443
+//Glyphs
+#define GLYPH_LIVING_BOMB                   63091
+#define GLYPH_POLYMORPH                     56375
+//other
+#define CLEARCASTBUFF                       12536
+#define FIRESTARTERBUFF                     54741
\ No newline at end of file
diff --git a/src/server/scripts/Bots/bot_paladin_ai.cpp b/src/server/scripts/Bots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..1f5f4a4
--- /dev/null
+++ b/src/server/scripts/Bots/bot_paladin_ai.cpp
@@ -0,0 +1,989 @@
+#include "bot_paladin_ai.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 40-45%
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new paladin_botAI(pCreature);
+    }
+
+    struct paladin_botAI : public bot_ai
+    {
+        paladin_botAI(Creature *c) :bot_ai(c)
+        {
+            Reset();
+        }
+        uint8 Crusader_cd;
+        uint8 Consecration_cd;
+        uint8 JOL_Timer;
+        uint16 LOH_Timer;
+        uint16 HOJ_Timer;
+        uint8 HOF_Timer;
+        uint8 HS_Timer;
+        uint16 BOP_Timer;
+        uint8 HOW_Timer;
+        uint8 DS_Timer;//divine storm
+        uint16 AW_Timer;//avenging wrath
+        uint8 HOS_Timer;//hand of salvation
+        uint8 SSH_Timer;//sacred shield
+        uint8 Hand_Of_Reckoning_Timer;
+        uint16 Divine_Plea_Timer;
+        uint16 Repentance_Timer;
+        uint8 Exorcism_Timer;
+        uint8 Holy_Wrath_Timer;
+        uint8 Turn_Evil_Timer;
+
+        void Reset()
+        {
+            //oom_spam = false;
+            opponent = NULL;
+
+            Crusader_cd = 0;
+            Consecration_cd = 0;
+            Potion_cd = 0;
+            GC_Timer = 0;
+            LOH_Timer = 0;
+            HOJ_Timer = 75;
+            HOF_Timer = 0;
+            JOL_Timer = 0;
+            HS_Timer = 0;
+            BOP_Timer = 0;
+            HOW_Timer = 0;
+            DS_Timer = 0;
+            AW_Timer = 100;
+            HOS_Timer = 0;
+            SSH_Timer = 0;
+            Hand_Of_Reckoning_Timer = 0;
+            Divine_Plea_Timer = 0;
+            Repentance_Timer = 0;
+            Exorcism_Timer = 0;
+            Holy_Wrath_Timer = 0;
+            Turn_Evil_Timer = 15;
+
+            temptimer = 0;
+            checkAurasTimer = 0;
+            wait = 15;
+
+            if (master) 
+            {
+                setStats(CLASS_PALADIN, m_creature->getRace(), master->getLevel(), true);
+
+                //aura
+                if (master->getLevel() >= 78)
+                    RefreshAura(AURA_OF_CELERITY); //+20% actions speedup
+                //Crit
+                if (master->getLevel() >= 75)
+                    RefreshAura(CRIT,3); //+30% crit (80lvl)
+                else if (master->getLevel() >= 55)
+                    RefreshAura(CRIT,2); //2*2% crit
+                else if (master->getLevel() >= 15)
+                    RefreshAura(CRIT); //2% crit
+                //SPD
+                    //1 - SPD 3% crit 3%
+                if (master->getLevel() >= 78)
+                    RefreshAura(SPELLDMG,5); //+15%
+                else if (master->getLevel() >= 75)
+                    RefreshAura(SPELLDMG,4); //+12%
+                else if (master->getLevel() >= 55)
+                    RefreshAura(SPELLDMG,3); //+9%
+                else if (master->getLevel() >= 35)
+                    RefreshAura(SPELLDMG,2); //+6%
+                else if (master->getLevel() >= 15)
+                    RefreshAura(SPELLDMG); //+3%
+                    //2 - SPD 6%
+                if (master->getLevel() >= 78)
+                    RefreshAura(SPELLDMG2,5); //+30%
+                else if (master->getLevel() >= 75)
+                    RefreshAura(SPELLDMG2,4); //+24%
+                else if (master->getLevel() >= 55)
+                    RefreshAura(SPELLDMG2,3); //+18%
+                else if (master->getLevel() >= 35)
+                    RefreshAura(SPELLDMG2,2); //+12%
+                else if (master->getLevel() >= 15)
+                    RefreshAura(SPELLDMG2); //+6%
+                //end SPD
+
+                //Talents
+                if (master->getLevel() >= 55)
+                    RefreshAura(PURE);
+
+                if (master->getLevel() >= 35)
+                    RefreshAura(WISE);
+
+                if (master->getLevel() >= 50)
+                    RefreshAura(RECKONING5); //10%
+                else if (master->getLevel() >= 45)
+                    RefreshAura(RECKONING4); //8%
+                else if (master->getLevel() >= 40)
+                    RefreshAura(RECKONING3); //6%
+                else if (master->getLevel() >= 35)
+                    RefreshAura(RECKONING2); //4%
+                else if (master->getLevel() >= 30)
+                    RefreshAura(RECKONING1); //2%
+
+                if (master->getLevel() >= 50)
+                    RefreshAura(RIGHTEOUS_VENGEANCE3);
+                else if (master->getLevel() >= 47)
+                    RefreshAura(RIGHTEOUS_VENGEANCE2);
+                else if (master->getLevel() >= 45)
+                    RefreshAura(RIGHTEOUS_VENGEANCE1);
+
+                if (master->getLevel() >= 30)
+                    RefreshAura(VENGEANCE3);
+                else if (master->getLevel() >= 27)
+                    RefreshAura(VENGEANCE2);
+                else if (master->getLevel() >= 25)    
+                    RefreshAura(VENGEANCE1);
+
+                if (master->getLevel() >= 60)
+                    RefreshAura(SHOFL3);
+                else if (master->getLevel() >= 55)
+                    RefreshAura(SHOFL2);
+                else if (master->getLevel() >= 50)
+                    RefreshAura(SHOFL1);
+
+                if (master->getLevel() >= 35)
+                    RefreshAura(DIVINE_PURPOSE);
+
+                if (master->getLevel() >= 25)
+                    RefreshAura(VINDICATION2);
+                else if (master->getLevel() >= 20)
+                    RefreshAura(VINDICATION1);
+
+                if (master->getLevel() >= 30)
+                    RefreshAura(LAYHANDS);
+
+                if (master->getLevel() >= 20)
+                    RefreshAura(FANATICISM,2); //-60% aggro
+
+                if (master->getLevel() >= 15)
+                    RefreshAura(GLPYH_HOLY_LIGHT); //10% heal
+
+                if (master->getLevel() >= 70)
+                    RefreshAura(PALADIN_T9_2P_BONUS); //Righteous Vengeance Crits
+                //misc
+                ApplyPassives(CLASS_PALADIN);
+                SetBotCommandState(COMMAND_FOLLOW);
+            }
+        }
+
+        void EnterEvadeMode()
+        {if (!master) return;
+            if (!me->isAlive())
+                return;
+            if (!IsEvent())
+            {
+                if (!m_creature->getThreatManager().isThreatListEmpty())
+                    m_creature->DeleteThreatList();
+                if (m_creature->isInCombat())
+                    m_creature->CombatStop();
+                Follow();
+            }
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId < 1) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false; //already casting
+            if (Feasting() && !master->isInCombat() && 
+                !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (m_creature->HasAuraWithMechanic(MECHANIC_SILENCE) && 
+                spellId != MANAPOTION && 
+                spellId != HEALINGPOTION
+                && spellId != CRUSADER_STRIKE) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                DoCast(victim, spellId, triggered);
+                m_creature->EnergizeBySpell(m_creature, spellId, urand(m_creature->GetMaxPower(POWER_MANA)/3,m_creature->GetMaxPower(POWER_MANA)), POWER_MANA);
+                return true;
+            }
+            m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+            if (master->getLevel() >= 78)
+                GC_Timer = 8;
+            else if (master->getLevel() >= 70)
+                GC_Timer = 10;
+            else if (master->getLevel() >= 50)
+                GC_Timer = 12;
+            else if (master->getLevel() >= 35)
+                GC_Timer = 14;
+            else if (master->getLevel() >= 25)
+                GC_Timer = 16;
+            else if (master->getLevel() >= 15)
+                GC_Timer = 18;
+            else
+                GC_Timer = 20;
+
+            if (!victim->IsWithinLOSInMap(m_creature) && IsInBotParty(victim))
+                m_creature->Relocate(victim);
+
+            DoCast(victim, spellId, triggered);
+            if (spellId == LAY_ON_HANDS)
+                m_creature->SetPower(POWER_MANA, 0);
+            
+            return true;
+        }
+
+        bool HandleCure(DispelType dispel, Unit *target)
+        {
+            if (dispel == DISPEL_MAGIC || dispel == DISPEL_DISEASE || dispel == DISPEL_POISON)
+                if (doCast(target, CLEANSE))
+                    return true;
+            return false;
+        }
+
+        void HOFGroup(Unit *pTarget)
+        {
+            if (!isTimerReady(HOF_Timer)) return;
+            if (m_creature->getLevel() < 18) return;            //Level restriction applies anyway
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return;//I'm busy casting
+
+            std::list<Unit*> unitList;
+            pTarget->GetRaidMember(unitList,30);
+            if (unitList.empty()) return;
+            for(std::list<Unit*>::iterator itr = unitList.begin(); itr!=unitList.end(); ++itr)
+            {
+                Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+                if (tPlayer == NULL) continue;
+                if (tPlayer->isDead()) continue;
+                if (m_creature->GetDistance(tPlayer) > 30) continue;
+                if (HasAuraName(tPlayer, HOF)) continue;
+                HOFTarget(tPlayer);
+            }
+        }
+
+        bool HOFTarget(Unit *target, bool force = false)
+        {
+            if (!isTimerReady(HOF_Timer)) return false;
+            if (m_creature->getLevel() < 18) return false;                    //Level restriction applies anyway
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;//I'm busy casting
+            if (HasAuraName(target, HOF)) return false;                    //Alredy has HOF
+            if (m_creature->GetDistance(target) > 30) return false;        //too far away
+
+            if (DIVINE_PURPOSE && target->HasAuraType(SPELL_AURA_MOD_STUN))
+            {
+                bool foundStun = false;
+                Unit::AuraEffectList const& stunAuras = target->GetAuraEffectsByType(SPELL_AURA_MOD_STUN);
+                for (Unit::AuraEffectList::const_iterator i = stunAuras.begin(); i != stunAuras.end(); ++i)
+                {
+                    SpellInfo const* spellInfo = (*i)->GetSpellInfo();
+                    if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN))
+                    {
+                        int32 auraDur = (*i)->GetBase()->GetDuration();
+                        if (auraDur > 2000)
+                        {
+                            foundStun = true;
+                            break;
+                        }
+                    }
+                }
+                if (foundStun == true && doCast(target, HOF))
+                {
+                    if (target->GetGUID() == m_creature->GetGUID())
+                        HOF_Timer = 50;//5 sec for selfcast
+                    else
+                        HOF_Timer = 150;//improved
+                    return true;
+                }
+            }
+            else
+            {
+                if (m_creature->HasAuraType(SPELL_AURA_MOD_STUN) && !force) return false;
+                if (target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+                {
+                    if (doCast(target, HOF))
+                    {
+                        if (target->GetGUID() == m_creature->GetGUID())
+                            HOF_Timer = 50;//5 sec for selfcast
+                        else
+                            HOF_Timer = 150;//improved
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Unit *hTarget)
+        {
+            if (!isTimerReady(HOS_Timer)) return;
+            if (m_creature->getLevel() >= 30 && !m_creature->HasUnitState(UNIT_STAT_CASTING))
+            {
+                std::list<Unit*> unitList;
+                hTarget->GetRaidMember(unitList,30);
+                if (unitList.empty()) return;
+                for(std::list<Unit*>::iterator itr = unitList.begin(); itr!=unitList.end(); ++itr)
+                {
+                    Player *HOSPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+                    if (HOSPlayer == NULL) continue;
+                    if (HOSPlayer->isDead()) continue;
+                    if (m_creature->GetDistance(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS)) continue;
+                    //if (HasAuraName(HOSPlayer, 586)) continue;//Glitches with Fade getting enormous threat amounts
+                    if (HOSPlayer->getClass() == CLASS_WARRIOR || 
+                        HOSPlayer->getClass() == CLASS_DEATH_KNIGHT || 
+                        HOSPlayer->getClass() == CLASS_PALADIN) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for(AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if ((*iter)->getThreatManager().getThreat(HOSPlayer) < 25.0f) continue;//too small threat
+                        if (HOSPlayer->GetDistance((*iter)) > 15) continue;
+                        if (HOSPlayer->GetDistance((*iter)) <= 15)
+                        {
+                            HOSTarget(HOSPlayer);
+                        }
+                    }
+                }//end for
+            }//end if
+        }
+
+        void HOSTarget(Unit *target)
+        {
+            if (!target || target->isDead()) return;
+            if (!isTimerReady(HOS_Timer)) return;
+            if (master->getLevel() < 30) return;            //Level restriction applies anyway
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return;    //I'm busy casting
+            if (HasAuraName(target, HOS)) return;                    //Alredy has HOS
+            if (m_creature->GetDistance(target) > 30) return;        //too far away
+            //if (HasAuraName(target, 586)) return;
+            if (target->getClass() == CLASS_WARRIOR || 
+                target->getClass() == CLASS_DEATH_KNIGHT || 
+                target->getClass() == CLASS_PALADIN)//possible tanks do not need it
+                return;
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return; //no aggro
+            uint8 Tattackers = 0;
+            for(AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                if ((*iter)->getThreatManager().getThreat(target) < 25.0f) continue;//too small threat
+                if (target->GetDistance((*iter)) > 15) continue;
+                if (target->GetDistance((*iter)) <= 15)
+                {
+                    Tattackers++;
+                }
+            }
+            if (Tattackers > 0)
+            {
+                doCast(target, HOS);
+                HOS_Timer = 250;
+                if (target->HasAura(586))
+                {
+                    target->RemoveAurasDueToSpell(586);
+                    for(AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if ((*iter)->getThreatManager().getThreat(target) > 0.0f)
+                        {
+                            (*iter)->getThreatManager().modifyThreatPercent(target, -80);
+                        }
+                    }
+                }
+                else
+                {
+                    for(AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if ((*iter)->getThreatManager().getThreat(target) > 0.0f)
+                        {
+                            (*iter)->getThreatManager().modifyThreatPercent(target, -30);
+                        }
+                    }
+                }
+            }
+            //if (target->getClass() == CLASS_PRIEST && target->HasAura(HOS))//due to fade
+            //    target->RemoveAurasDueToSpell(HOS);
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit *target)
+        {
+            if (!HOLY_SHOCK) return false;
+            if (!isTimerReady(HS_Timer)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (!target || target->isDead()) return false;
+            if (m_creature->GetDistance(target) > 30) return false;
+
+            if (IsInBotParty(target))
+            {
+                if (doCast(target, HOLY_SHOCK))
+                {
+                    HS_Timer = 50;
+                    return true;
+                }
+            }
+            else if (GetLostHP(target) > m_creature->GetMaxHealth()*2)
+            {
+                if (doCast(target, HOLY_SHOCK))
+                {
+                    HS_Timer = 35;
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        bool HealTarget(Unit *target, uint8 hp)
+        {
+            if (!isTimerReady(GC_Timer)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (!target || target->isDead() || !target->IsWithinLOSInMap(m_creature)) return false;
+            if (HAND_OF_PROTECTION != 0 && IS_PLAYER_GUID(target->GetGUID()) && 
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) 
+                && isTimerReady(BOP_Timer) && 
+                !target->HasAura(HAND_OF_PROTECTION) && 
+                !HasAuraName(target, "Forbearance"))
+            { // 15% to BOP
+                
+                if (doCast(target, HAND_OF_PROTECTION))
+                {
+                    std::string bop = "BOP on ";
+                    bop += target->GetName();
+                    bop += "!";
+                    m_creature->MonsterSay(bop.c_str(), LANG_UNIVERSAL, NULL);
+                    BOP_Timer = 600; //1 min
+                    bop.clear();
+                }
+                if (!HasAuraName(target, "Forbearance") && target->HasAura(HAND_OF_PROTECTION))
+                    m_creature->AddAura(25771, target);//Forbearance
+                if (HasAuraName(target, "Forbearance") && !target->HasAura(HAND_OF_PROTECTION))
+                    m_creature->AddAura(HAND_OF_PROTECTION, target);
+                return true;
+            }
+            else if (hp < 20 && !target->HasAura(HAND_OF_PROTECTION))
+            {
+                // 20% to cast loh, else just do a Shock
+                uint64 m_rand = urand(1, 3);
+                switch(m_rand)
+                {
+                    case 1: 
+                        if (LAY_ON_HANDS != 0 && isTimerReady(LOH_Timer) && 
+                            hp < 20 && 
+                            !HasAuraName(target, "Forbearance") && 
+                            IS_PLAYER_GUID(target->GetGUID()) && 
+                            (target->isInCombat() || !target->getAttackers().empty()))
+                        {
+                            if (doCast(target, LAY_ON_HANDS))
+                            {
+                                std::string loh = "Lay of Hands on ";
+                                loh += target->GetName();
+                                loh += "!";
+                                m_creature->MonsterSay(loh.c_str(), LANG_UNIVERSAL, NULL);
+                                loh.clear();
+                                LOH_Timer = 600; //1 min
+                                return true;
+                            }
+                        }
+                    case 2: 
+                        if (FLASH_OF_LIGHT != 0 && doCast(target, FLASH_OF_LIGHT)) {}
+                        //break;
+                    case 3: 
+                        if (HOLY_SHOCK != 0 && isTimerReady(HS_Timer) && HS(target))
+                            return true;
+                }
+            }
+            Unit *u = target->getVictim();
+            if (SACRED_SHIELD != 0 && isTimerReady(SSH_Timer) && ((hp < 65 || target->getAttackers().size() > 1 || 
+                (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->isInCombat())) && 
+                !target->HasAura(SACRED_SHIELD) && IS_PLAYER_GUID(target->GetGUID()) && IsInBotParty(target)))
+            {
+                Unit *aff = FindAffectedTarget(SACRED_SHIELD, m_creature->GetGUID(), 50, 1);//use players since we cast only on players
+                if ((!aff || aff->getAttackers().empty()) && 
+                    doCast(target, SACRED_SHIELD))
+                    SSH_Timer = 30;
+            }
+            if (HOLY_SHOCK != 0 && (hp < 90 || GetLostHP(target) > 6000) && isTimerReady(HS_Timer))
+            {
+                if (HS(target)) return true;
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) 
+            {
+                if (doCast(target, HOLY_LIGHT)) return true;
+            }
+            if (FLASH_OF_LIGHT != 0 && (hp < 90 || GetLostHP(target) > 2500))
+            {
+                if (doCast(target, FLASH_OF_LIGHT)) return true;
+            }
+            return false;
+        } //end HealTarget
+
+        void JustDied(Unit *Killer)
+        {if (!master) return;Follow();}
+
+        void AttackStart(Unit *u)
+        { if (!master) return;if (!u->isTargetableForAttack()) return; Aggro(u); m_creature->AddThreat(u, 0.001f); opponent = u; UnitAI::AttackStart(u); m_creature->SetBotCommandState(COMMAND_ATTACK); }
+
+        void KilledUnit(Unit *Victim) //DEBUG changed
+        {if (!master) return;
+            if (!m_creature->getVictim())
+            {
+                if (!IsEvent())
+                {
+                    if (!master->getVictim() && master->getAttackers().empty() && master->isInCombat())
+                        master->CombatStop();
+                    if (!master->isInCombat())
+                        m_creature->CombatStop();
+                }
+            }
+            //master->SetBotCommandState(COMMAND_FOLLOW);
+            //ResetOrGetNextTarget();
+        }
+
+        void UpdateAI(const uint32 diff)
+        {if (!master) return;
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (wait == 0)
+                wait = urand(1,3);
+            else
+                return;
+            if (checkAurasTimer <= 0)
+            {
+                CheckAuras();
+                checkAurasTimer = 30;
+            }
+            HOFTarget(me, true);//self stun cure goes FIRST
+            if (CCed(m_creature)) return;
+
+            if (GetManaPCT(m_creature) < 30 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, MANAPOTION)) Potion_cd = MANA_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(m_creature) < 40 && m_creature->getLevel() >= 70 && isTimerReady(Divine_Plea_Timer))
+            {
+                if (doCast(m_creature, DIVINE_PLEA)) Divine_Plea_Timer = MANA_CD;
+            }
+
+            CureTarget(me);//maybe unnecessary but this goes FIRST
+            HOFTarget(master);//maybe unnecessary
+            CureTarget(master);//maybe unnecessary
+            HOSTarget(master);
+            //buff and heal master's group
+            BuffAndHealGroup(master);
+            CureGroup(master);
+            HOFGroup(master);
+            HOSGroup(master);
+
+            Repentance(diff, NULL);
+
+            //opponent = master->getVictim() ? master->getVictim() : SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+            Unit *u = m_creature->getVictim();
+            if (!u || !u->isTargetableForAttack())
+                opponent = getTarget();
+            else
+                opponent = u;
+            
+            if (!CheckTarget(opponent))
+                return;
+
+
+            if (GetHealthPCT(m_creature) < 50 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, HEALINGPOTION)) Potion_cd = 200;
+                GC_Timer = temptimer;
+            }
+            //buff
+            if (master->getLevel() >= 10 && !m_creature->HasAura(SEAL_OF_COMMAND) && isTimerReady(GC_Timer))
+                doCast(m_creature, SEAL_OF_COMMAND);
+
+            // Heal myself
+            if (GetHealthPCT(m_creature) < 80)
+                HealTarget(m_creature, GetHealthPCT(m_creature));
+            healOthers();
+
+            Counter(diff);
+            DoNormalAttack(diff);
+
+            ScriptedAI::UpdateAI(diff);
+        }
+
+        void Aggro(Unit *who){ }
+
+        void Armour(const uint32 diff){ } //end Armour
+
+        void DoNonCombatActions()
+        {if (!master) return;
+            uint8 Aura;
+            if (m_creature->HasAura(DEVOTION_AURA)) Aura = DEVOTIONAURA;
+            else if (m_creature->HasAura(FIRE_RESISTANCE_AURA)) Aura = FIRERESISTANCEAURA;
+            else if (m_creature->HasAura(CONCENTRATION_AURA)) Aura = CONCENTRATIONAURA;
+            else Aura = NOAURA;
+
+            //buff myself with aura
+            if (master->isAlive())
+            {
+                if ((master->getClass() == CLASS_MAGE || 
+                    master->getClass() == CLASS_PRIEST ||
+                    master->getClass() == CLASS_WARLOCK ||
+                    master->getClass() == CLASS_DRUID ||
+                    master->getClass() == CLASS_SHAMAN) && 
+                    !master->HasAura(CONCENTRATION_AURA) && 
+                    GC_Timer <= 0)
+                    doCast(m_creature, CONCENTRATION_AURA);
+                else
+                if (master->HasAura(CONCENTRATION_AURA) && 
+                    !master->HasAura(CONCENTRATION_AURA, m_creature->GetGUID()) && 
+                    Aura == NOAURA && 
+                    GC_Timer <= 0)
+                    doCast(m_creature, DEVOTION_AURA);
+                else
+                if (!master->HasAura(DEVOTION_AURA) && 
+                    GC_Timer <= 0           && 
+                    Aura == NOAURA) 
+                {
+                    doCast(m_creature, DEVOTION_AURA);
+                }
+                else
+                // I already have devotion aura and its not mine, cast different aura
+                if (master->HasAura(DEVOTION_AURA) && 
+                    !master->HasAura(DEVOTION_AURA, m_creature->GetGUID()) && 
+                    Aura == NOAURA && 
+                    GC_Timer <= 0)
+                    doCast(m_creature, FIRE_RESISTANCE_AURA);
+            }//end if IsAlive
+            //buff
+            if (master->getLevel() >= 10 && !m_creature->HasAura(SEAL_OF_COMMAND) && GC_Timer <= 0)
+                doCast(m_creature, SEAL_OF_COMMAND);
+
+            //buff and heal master's group
+            if (master->GetGroup())
+            {
+                RezGroup(REDEMPTION, master);
+                BuffAndHealGroup(master);
+                CureGroup(master);
+            }
+        }
+
+        bool BuffTarget(Unit *target)
+        {
+            if (!isTimerReady(GC_Timer)) return false;
+            if (!target || target->isDead()) return false;
+            if (m_creature->GetDistance(target) > 30) return false;
+            if (HasAuraName(target, BLESSING_OF_WISDOM, m_creature->GetGUID()) || 
+                HasAuraName(target, BLESSING_OF_SANCTUARY, m_creature->GetGUID()) || 
+                HasAuraName(target, BLESSING_OF_KINGS, m_creature->GetGUID()) || 
+                HasAuraName(target, BLESSING_OF_MIGHT, m_creature->GetGUID()))
+                return false;
+
+            if (IS_PLAYER_GUID(target->GetGUID()))
+            {
+                switch(target->getClass())
+                {
+                case CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !target->HasAura(BLESSING_OF_WISDOM))
+                        doCast(target, BLESSING_OF_WISDOM);
+                    else if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                        doCast(target, BLESSING_OF_KINGS);
+                    break;
+                //case CLASS_PALADIN:
+                //case CLASS_WARRIOR:
+                case CLASS_DEATH_KNIGHT:
+                    if (BLESSING_OF_SANCTUARY && !target->HasAura(BLESSING_OF_SANCTUARY))
+                        doCast(target, BLESSING_OF_SANCTUARY);
+                    else if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                        doCast(target, BLESSING_OF_KINGS);
+                    else if (!target->HasAura(BLESSING_OF_MIGHT))
+                        doCast(target, BLESSING_OF_MIGHT);
+                    break;
+                case CLASS_WARRIOR:
+                case CLASS_PALADIN:
+                case CLASS_ROGUE:
+                case CLASS_HUNTER:
+                    if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                        doCast(target, BLESSING_OF_KINGS);
+                    else if (!target->HasAura(BLESSING_OF_MIGHT) && !HasAuraName(target, "Battle Shout"))
+                        doCast(target, BLESSING_OF_MIGHT);
+                    else if (BLESSING_OF_SANCTUARY && !target->HasAura(BLESSING_OF_SANCTUARY))
+                        doCast(target, BLESSING_OF_SANCTUARY);
+                    else if (BLESSING_OF_WISDOM && target->getPowerType() == POWER_MANA && !target->HasAura(BLESSING_OF_WISDOM))
+                        doCast(target, BLESSING_OF_WISDOM);
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                        doCast(target, BLESSING_OF_KINGS);
+                    else if (BLESSING_OF_WISDOM && target->getPowerType() == POWER_MANA && !target->HasAura(BLESSING_OF_WISDOM))
+                        doCast(target, BLESSING_OF_WISDOM);
+                    else if (BLESSING_OF_SANCTUARY && !target->HasAura(BLESSING_OF_SANCTUARY))
+                        doCast(target, BLESSING_OF_SANCTUARY);
+                    else if (!target->HasAura(BLESSING_OF_MIGHT) && !HasAuraName(target, "Battle Shout"))
+                        doCast(target, BLESSING_OF_MIGHT);
+                    break;
+                }
+            }
+            else// if (Player *owner = (Player*)target->GetCharmerOrOwner())
+            {
+                //if (!owner || !IsInBotParty(owner)) return false;
+                if (!target->ToCreature()) return false;
+                switch(target->ToCreature()->GetBotClass())
+                {
+                case CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !target->HasAura(BLESSING_OF_WISDOM))
+                    {
+                        if (doCast(target, BLESSING_OF_WISDOM))
+                            m_creature->AddAura(BLESSING_OF_WISDOM, target);
+                    }
+                    else if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                    {
+                        if (doCast(target, BLESSING_OF_KINGS))
+                            m_creature->AddAura(BLESSING_OF_KINGS, target);
+                    }
+                    break;
+                //case CLASS_PALADIN:
+                //case CLASS_WARRIOR:
+                case CLASS_DEATH_KNIGHT:
+                    if (BLESSING_OF_SANCTUARY && !target->HasAura(BLESSING_OF_SANCTUARY))
+                    {
+                        if (doCast(target, BLESSING_OF_SANCTUARY))
+                            m_creature->AddAura(BLESSING_OF_SANCTUARY, target);
+                    }
+                    else if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                    {
+                        if (doCast(target, BLESSING_OF_KINGS))
+                            m_creature->AddAura(BLESSING_OF_KINGS, target);
+                    }
+                    else if (!target->HasAura(BLESSING_OF_MIGHT))
+                    {
+                        if (doCast(target, BLESSING_OF_MIGHT))
+                            m_creature->AddAura(BLESSING_OF_MIGHT, target);
+                    }
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !target->HasAura(BLESSING_OF_KINGS))
+                    {
+                        if (doCast(target, BLESSING_OF_KINGS))
+                            m_creature->AddAura(BLESSING_OF_KINGS, target);
+                    }
+                    else if (BLESSING_OF_WISDOM && target->getPowerType() == POWER_MANA && !target->HasAura(BLESSING_OF_WISDOM))
+                    {
+                        if (doCast(target, BLESSING_OF_WISDOM))
+                            m_creature->AddAura(BLESSING_OF_WISDOM, target);
+                    }
+                    else if (!target->HasAura(BLESSING_OF_MIGHT))
+                    {
+                        if (doCast(target, BLESSING_OF_MIGHT))
+                            m_creature->AddAura(BLESSING_OF_MIGHT, target);
+                    }
+                    else if (BLESSING_OF_SANCTUARY && !target->HasAura(BLESSING_OF_SANCTUARY))
+                    {
+                        if (doCast(target, BLESSING_OF_SANCTUARY))
+                            m_creature->AddAura(BLESSING_OF_SANCTUARY, target);
+                    }
+                    break;
+                }
+            }
+            return false;
+        }
+
+        void Repentance(const uint32 diff, Unit *target)
+        {
+            if (target && Repentance_Timer < 250 && doCast(target, REPENTANCE))
+            {
+                temptimer = GC_Timer;
+                Repentance_Timer = 450;
+                GC_Timer = temptimer;
+                return;
+            }
+            if (m_creature->getLevel() >= 35 && isTimerReady(Repentance_Timer))
+            {
+                Unit *u = FindRepentanceTarget();
+                if (u && u->getVictim() != m_creature && doCast(u, REPENTANCE))
+                    Repentance_Timer = 450;
+            }
+        }
+
+        void Counter(const uint32 diff)
+        {
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING))
+                return;
+
+            Unit *target = FindCastingTarget(20, false, REPENTANCE);
+            if (target)
+                Repentance(diff, target);//first check repentance
+            else if (m_creature->getLevel() >= 24 && Turn_Evil_Timer < 15)
+            {
+                target = FindCastingTarget(20, false, TURN_EVIL);
+                temptimer = GC_Timer;
+                if (target && doCast(target, TURN_EVIL, true))
+                    Turn_Evil_Timer = 30;
+                GC_Timer = temptimer;
+            }
+            else if (HOLY_WRATH && Holy_Wrath_Timer < 80)
+            {
+                target = FindCastingTarget(8, false, TURN_EVIL);//here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(m_creature, HOLY_WRATH))
+                    Holy_Wrath_Timer = 230 - m_creature->getLevel(); //23 - 0...8 sec (15 sec on 80 as with glyph)
+                GC_Timer = temptimer;
+            }
+            else if (HOJ_Timer <= 70 && isTimerReady(GC_Timer))
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 650 - master->getLevel()*5; //25 sec on 80
+            }
+        }
+
+        void TurnEvil(const uint32 diff)
+        {
+            if (m_creature->getLevel() < 24 || !isTimerReady(Turn_Evil_Timer) || FindAffectedTarget(TURN_EVIL, m_creature->GetGUID(), 50))
+                return;
+            Unit *target = FindUndeadCCTarget(20, TURN_EVIL);
+            if (target && 
+                (target != m_creature->getVictim() || GetHealthPCT(m_creature) < 70 || target->getVictim() == master) && 
+                doCast(target, TURN_EVIL, true))
+            {
+                Turn_Evil_Timer = 30;
+                return;
+            }
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                !CCed(opponent) && 
+                opponent->getVictim() && tank && opponent->getVictim() != tank && opponent->getVictim() != m_creature && 
+                GetHealthPCT(m_creature) < 90 && 
+                doCast(opponent, TURN_EVIL, true))
+                Turn_Evil_Timer = 30;
+        }
+
+        void Wrath(const uint32 diff)
+        {
+            if (!isTimerReady(Holy_Wrath_Timer))
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                m_creature->GetDistance(opponent) < 9 && doCast(m_creature, HOLY_WRATH))
+                Holy_Wrath_Timer = 230 - m_creature->getLevel(); //23 - 0...8 sec (15 sec on 80 as with glyph)
+            else 
+            {
+                Unit *target = FindUndeadCCTarget(8, HOLY_WRATH);
+                if (target && doCast(m_creature, HOLY_WRATH))
+                    Holy_Wrath_Timer = 230 - m_creature->getLevel(); //23 - 0...8 sec (15 sec on 80 as with glyph)
+            }
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            assistMaster();
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack()) return;
+
+            if (m_creature->getVictim() != opponent)
+                AttackStart(opponent);
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (CCed(opponent))
+                ChangeTarget(opponent, 20);
+
+            if (GetHealthPCT(opponent) < 20 && 
+                m_creature->GetDistance(opponent) < 30 && 
+                isTimerReady(HOW_Timer))
+                if (doCast(opponent, HOW))
+                    HOW_Timer = 60; //6 sec
+
+            Unit *u = opponent->getVictim();
+            if (m_creature->getLevel() >= 16 && Hand_Of_Reckoning_Timer <= 0 && m_creature->GetDistance(opponent) <= 30 && 
+                u && u != m_creature && (IsInBotParty(u) || tank == m_creature))//No GCD
+            {
+                Creature *cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !isMeleeClass(u->getClass())) || 
+                    GetHealthPCT(u) < GetHealthPCT(m_creature) - 5 || 
+                    tank == m_creature) && 
+                    doCast(opponent, HANDOFRECKONING))
+                    Hand_Of_Reckoning_Timer = 80 - (m_creature == tank)*20;
+                    //seems to work (-2 sec on 80 level) since righteous defense broken for bots
+                GC_Timer = temptimer;
+            }
+
+            if (isTimerReady(HOJ_Timer) && !CCed(opponent) && m_creature->GetDistance(opponent) < 10)
+                if (doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 650 - master->getLevel()*5; //25 sec on 80
+
+            if (m_creature->HasAura(SEAL_OF_COMMAND) && 
+                JUDGEMENT_OF_LIGHT != 0 && 
+                isTimerReady(JOL_Timer) && 
+                m_creature->GetDistance(opponent) < 10)
+                if (doCast(opponent, JUDGEMENT_OF_LIGHT))
+                    JOL_Timer = 80;
+
+            if (isTimerReady(Consecration_cd) && m_creature->GetDistance(opponent) < 7 && 
+                !opponent->isMoving() && doCast(m_creature, CONSECRATION))
+                    Consecration_cd = 90;
+
+            if (AVENGING_WRATH != 0 && AW_Timer <= 0 && 
+                (GetHealthPCT(opponent) > 25 || opponent->GetMaxHealth() > master->GetMaxHealth()*10))
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, AVENGING_WRATH))
+                    AW_Timer = 600; //1 min
+                GC_Timer = temptimer;
+            }
+
+            if (m_creature->getLevel() >= 20 && isTimerReady(Crusader_cd) && m_creature->GetDistance(opponent) < 7)
+                if (doCast(opponent, CRUSADER_STRIKE))
+                    Crusader_cd = 120 - m_creature->getLevel();//4 sec on 80
+
+            if (EXORCISM && isTimerReady(Exorcism_Timer) && m_creature->GetDistance(opponent) < 30)
+                if (doCast(opponent, EXORCISM/*, true)*/))//possible instacast here
+                    Exorcism_Timer = 150;
+
+            Wrath(diff);
+
+            if (DIVINE_STORM != 0 && isTimerReady(DS_Timer) && m_creature->GetDistance(opponent) < 7)
+                if (doCast(opponent, DIVINE_STORM))
+                    DS_Timer = 100 - m_creature->getLevel()/4; //10 - 2 sec
+        }
+
+        void ReduceCD(const uint32 diff)
+        {if (!master) return;
+            if (HOW_Timer > 0)               --HOW_Timer;
+            if (DS_Timer > 0)                --DS_Timer;
+            if (AW_Timer > 0)                --AW_Timer;
+            if (HOS_Timer > 0)               --HOS_Timer;
+            if (HS_Timer > 0)                --HS_Timer;
+            if (BOP_Timer > 0)               --BOP_Timer;
+            if (Consecration_cd > 0)         --Consecration_cd;
+            if (Crusader_cd > 0)             --Crusader_cd;
+            if (Potion_cd > 0)               --Potion_cd;
+            if (LOH_Timer > 0)               --LOH_Timer;
+            if (HOJ_Timer > 0)               --HOJ_Timer;
+            if (HOF_Timer > 0)               --HOF_Timer;
+            if (JOL_Timer > 0)               --JOL_Timer;
+            if (SSH_Timer > 0)               --SSH_Timer;
+            if (Hand_Of_Reckoning_Timer > 0) --Hand_Of_Reckoning_Timer;
+            if (Divine_Plea_Timer > 0)       --Divine_Plea_Timer;
+            if (Repentance_Timer > 0)        --Repentance_Timer;
+            if (Exorcism_Timer > 0)          --Exorcism_Timer;
+            if (Holy_Wrath_Timer > 0)        --Holy_Wrath_Timer;
+            if (Turn_Evil_Timer > 0)         --Turn_Evil_Timer;
+            if (GC_Timer > 0)                --GC_Timer;
+            if (temptimer > 0)               --temptimer;
+            if (checkAurasTimer > 0)         --checkAurasTimer;
+            if (wait > 0)                    --wait;
+        }
+
+        void ReceiveBowEmote(Player *player)
+        {
+            BuffTarget(player);
+        }
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/scripts/Bots/bot_paladin_ai.h b/src/server/scripts/Bots/bot_paladin_ai.h
new file mode 100644
index 0000000..9e27c76
--- /dev/null
+++ b/src/server/scripts/Bots/bot_paladin_ai.h
@@ -0,0 +1,118 @@
+#include "bot_ai.h"
+
+#define DEVOTIONAURA        1
+#define FIRERESISTANCEAURA  2
+#define CONCENTRATIONAURA   3
+#define NOAURA              4
+
+// Heals
+#define FLASH_OF_LIGHT                FLASH_OF_LIGHT_A[SPELL_LEVEL]
+#define HOLY_LIGHT                    HOLY_LIGHT_A[SPELL_LEVEL]
+#define LAY_ON_HANDS                  LAY_ON_HANDS_A[SPELL_LEVEL]
+#define REDEMPTION                    REDEMPTION_A[SPELL_LEVEL]
+
+#define HOF                           HOF_A[SPELL_LEVEL]
+#define SACRED_SHIELD                 SACRED_SHIELD_A[SPELL_LEVEL]
+#define HOLY_SHOCK                    HOLY_SHOCK_A[SPELL_LEVEL]
+#define HAND_OF_PROTECTION            HAND_OF_PROTECTION_A[SPELL_LEVEL]
+#define HOS                           1038
+
+uint32 FLASH_OF_LIGHT_A[] = { 0, 0, 19940, 19941, 19942, 19943, 27137, 48784, 48785 };
+uint32 HOLY_LIGHT_A[] = { 635, 647, 1026, 10328, 10329, 25292, 27136, 48781, 48782 };
+uint32 LAY_ON_HANDS_A[] = { 0, 633, 633, 2800, 2800, 10310, 10310, 27154, 48788 };
+uint32 REDEMPTION_A[] = { 0, 7328, 10322, 10324, 20772, 20772, 20773, 48949, 48950 };
+
+uint32 HOF_A[] = { 0, 0, 1044, 1044, 1044, 1044, 1044, 1044, 1044 };
+uint32 SACRED_SHIELD_A[] = { 0, 0, 0, 0, 0, 0, 0, 53601, 53601 };
+uint32 HOLY_SHOCK_A[] = { 0, 0, 0, 0, 20473, 20930, 33072, 48824, 48825 };
+uint32 HAND_OF_PROTECTION_A[] = { 0, 0, 0, 0, 66009, 66009, 66009, 66009, 66009 };
+
+// Seal
+#define SEAL_OF_COMMAND         20375
+//Taunt
+#define HANDOFRECKONING         62124
+//Plea
+#define DIVINE_PLEA             54428
+//Attacks
+#define CRUSADER_STRIKE         35395//71549
+#define JUDGEMENT_OF_LIGHT      JUDGEMENT_OF_LIGHT_A[SPELL_LEVEL]
+#define CONSECRATION            CONSECRATION_A[SPELL_LEVEL]
+#define HAMMER_OF_JUSTICE       HAMMER_OF_JUSTICE_A[SPELL_LEVEL]
+#define DIVINE_STORM            DIVINE_STORM_A[SPELL_LEVEL]
+#define HOW /*Hammer_of_wrath*/ HOW_A[SPELL_LEVEL]
+//Uber
+#define AVENGING_WRATH          AVENGING_WRATH_A[SPELL_LEVEL]
+//Stun
+#define REPENTANCE              20066
+//VERSUS UNDEAD
+//Fear
+#define TURN_EVIL               10326
+#define EXORCISM                EXORCISM_A[SPELL_LEVEL]
+#define HOLY_WRATH              HOLY_WRATH_A[SPELL_LEVEL]
+uint32 EXORCISM_A[] = { 0, 5614, 5615, 10312, 10313, 10314, 27138, 48800, 48801, 48801 };
+uint32 HOLY_WRATH_A[] = { 0, 0, 0, 2812, 10318, 27139, 48816, 48816, 48817, 48817 };
+
+uint32 AVENGING_WRATH_A[] = { 0, 0, 0, 0, 0, 0, 0, 66011, 66011 };
+uint32 DIVINE_STORM_A[] = { 0, 0, 0, 0, 0, 0, 53385, 53385, 53385 };
+uint32 HOW_A[] = { 0, 0, 0, 24275, 24274, 24239, 27180, 48805, 48806 };
+uint32 HAMMER_OF_JUSTICE_A[] = { 0, 853, 5588, 5588, 5589, 10308, 10308, 37369, 39077 };
+uint32 JUDGEMENT_OF_LIGHT_A[] = { 0, 20271, 20271, 20271, 20271, 20271, 20271, 20271, 20271 };
+uint32 CONSECRATION_A[] = { 0, 0, 26573, 20922, 20923, 20924, 27173, 48818, 48819 };
+
+// Blessings
+#define BLESSING_OF_WISDOM      BLESSING_OF_WISDOM_A[SPELL_LEVEL]
+#define BLESSING_OF_KINGS       BLESSING_OF_KINGS_A[SPELL_LEVEL]
+#define BLESSING_OF_SANCTUARY   BLESSING_OF_SANCTUARY_A[SPELL_LEVEL]
+#define BLESSING_OF_MIGHT       BLESSING_OF_MIGHT_A[SPELL_LEVEL]
+
+uint32 BLESSING_OF_WISDOM_A[] = { 0, 19742, 19850, 19852, 19853, 19854, 25290, 48935, 48938 };
+uint32 BLESSING_OF_KINGS_A[] = { 0, 0, 56525, 56525, 56525, 56525, 56525, 56525, 25898 };
+uint32 BLESSING_OF_SANCTUARY_A[] = { 0, 0, 0, 20911, 20911, 20911, 20911, 20911, 25899 };
+uint32 BLESSING_OF_MIGHT_A[] = { 19740, 19834, 19835, 19836, 19838, 25291, 27141, 48933, 48934 };
+
+// Auras
+#define FIRE_RESISTANCE_AURA      FIRE_RESISTANCE_AURA_A[SPELL_LEVEL]
+#define DEVOTION_AURA             DEVOITION_AURA_A[SPELL_LEVEL]
+#define CONCENTRATION_AURA        19746
+uint32 FIRE_RESISTANCE_AURA_A[] = { 0, 0, 0, 0, 0, 0, 0, 19726, 19726 };
+uint32 DEVOITION_AURA_A[] = { 465, 10290, 643, 10291, 1032, 10292, 10293, 58944, 58944 };
+
+//AURA
+#define AURA_OF_CELERITY                      62320
+//PASSIVE
+#define CRIT                                  CRIT_A[SPELL_LEVEL]
+uint32 CRIT_A[] = { 30242, 30242, 30245, 30245, 30246, 30246, 30247, 30247, 30248 };
+//Demonic Tactics {    rank 1    |   rank 2   |    rank 3    |   rank 4   | rank 5 };
+//dam/crit
+#define SPELLDMG/*Arcane Instability-mage*/   15060//rank3 3% dam/crit
+//dam
+#define SPELLDMG2/*Earth and Moon - druid*/   48511//rank3 6% dam
+//Talents
+#define PURE/*Judgements of the Pure*/        54155
+#define WISE/*Judgements of the Wise*/        31878
+//#define SACRED_CLEANSING                    53553//rank 3 //broken
+#define RECKONING1                            20177
+#define RECKONING2                            20179
+#define RECKONING3                            20181
+#define RECKONING4                            20180
+#define RECKONING5                            20182
+#define VINDICATION1                          9452 //rank 1
+#define VINDICATION2                          26016//rank 2
+#define LAYHANDS  /*Improved LOH rank 2*/     20235
+#define FANATICISM                            31881//rank 3
+#define RIGHTEOUS_VENGEANCE1                  53380//rank 1
+#define RIGHTEOUS_VENGEANCE2                  53381//rank 2
+#define RIGHTEOUS_VENGEANCE3                  53382//rank 3
+#define VENGEANCE1                            20049//rank 1
+#define VENGEANCE2                            20056//rank 2
+#define VENGEANCE3                            20057//rank 3
+#define SHOFL1      /*Sheath of Light*/       53501//rank 1
+#define SHOFL2                                53502//rank 2
+#define SHOFL3                                53503//rank 3
+#define DIVINE_PURPOSE                        DIVINE_PURPOSE_A[SPELL_LEVEL]//rank 2 !new
+uint32 DIVINE_PURPOSE_A[] = { 0, 0, 0, 31872, 31872, 31872, 31872, 31872, 31872, 31872 };
+//Glyphs
+#define GLPYH_HOLY_LIGHT                      54937
+#define GLYPH_SOC    /*Seal_of_Command*/      54925
+//other
+#define PALADIN_T9_2P_BONUS                   67188//Righteous Vengeance Crits
\ No newline at end of file
diff --git a/src/server/scripts/Bots/bot_priest_ai.cpp b/src/server/scripts/Bots/bot_priest_ai.cpp
new file mode 100644
index 0000000..20047e1
--- /dev/null
+++ b/src/server/scripts/Bots/bot_priest_ai.cpp
@@ -0,0 +1,737 @@
+#include "bot_priest_ai.h"
+//#include "Group.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 50%
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new priest_botAI(pCreature);
+    }
+
+    struct priest_botAI : public bot_ai
+    {
+        priest_botAI(Creature *c) :bot_ai(c)
+        {
+            Reset();
+        }
+        uint8 Heal_Timer;
+        uint16 Divine_Hymn_Timer;
+        uint16 Prayer_of_Healing_Timer;
+        //uint32 Mass_Dispel_Timer;
+        uint16 Pain_Suppression_Timer;
+        uint8 PWS_Timer;
+        //uint32 Oom_timer;
+        uint8 Fade_Timer;
+        uint16 Potion_Timer;
+        uint8 Fear_Timer;
+        uint8 Mind_Blast_Timer;
+        uint8 SW_Death_Timer;
+        uint16 Fear_Ward_Timer;
+        uint16 Psychic_Horror_Timer;
+        uint16 Silence_Timer;
+        uint8 Mind_Flay_Timer;
+        uint32 PENANCE;
+        uint8 Penance_Timer;
+        uint8 CheckDispelTimer;
+        uint8 DevcheckTimer;
+        bool Devcheck;
+
+        void Reset()
+        {
+            GC_Timer = 0;
+            Heal_Timer = 0;
+            Divine_Hymn_Timer = 0;
+            Prayer_of_Healing_Timer = 0;
+            //Mass_Dispel_Timer = 0;
+            Pain_Suppression_Timer = 0;
+            PWS_Timer = 0;
+            //Oom_timer = 0;
+            Fade_Timer = 0;
+            Potion_cd = 0;
+            Fear_Timer = 0;
+            Mind_Blast_Timer = 0;
+            SW_Death_Timer = 0;
+            Fear_Ward_Timer = 0;
+            Psychic_Horror_Timer = 0;
+            Silence_Timer = 0;
+            Mind_Flay_Timer = 0;
+            Penance_Timer = 0;
+            temptimer = 0;
+            checkAurasTimer = 0;
+            CheckDispelTimer = 0;
+            DevcheckTimer = 20;
+            Devcheck = false;
+            wait = 15;
+
+            opponent = NULL;
+
+            if (master) 
+            {
+                setStats(CLASS_PRIEST, m_creature->getRace(), master->getLevel(), true);
+
+                //aura
+                if (master->getLevel() >= 78)
+                    RefreshAura(RADIANCE_AURA);//3% hp every 3 sec
+                if (master->getLevel() >= 65)
+                    RefreshAura(BORROWED_TIME); //25%haste/40%bonus
+                if (master->getLevel() >= 55)
+                    RefreshAura(DIVINE_AEGIS); //30%
+                if (master->getLevel() >= 50)
+                    RefreshAura(PAINANDSUFFERING3); //100%
+                else if (master->getLevel() >= 48)
+                    RefreshAura(PAINANDSUFFERING2); //66%
+                else if (master->getLevel() >= 45)
+                    RefreshAura(PAINANDSUFFERING1); //33%
+                if (master->getLevel() >= 50)
+                    RefreshAura(MISERY3); //3%
+                else if (master->getLevel() >= 48)
+                    RefreshAura(MISERY2); //2%
+                else if (master->getLevel() >= 45)
+                    RefreshAura(MISERY1); //1%
+                if (master->getLevel() >= 45)
+                {
+                    RefreshAura(GRACE); //100%
+                    RefreshAura(EMPOWERED_RENEW); //5%
+                }
+                if (master->getLevel() >= 35)
+                    RefreshAura(IMP_DEV_PLAG); //30%
+
+                if (master->getLevel() >= 25)
+                    RefreshAura(INSPIRATION3); //10%
+                else if (master->getLevel() >= 23)
+                    RefreshAura(INSPIRATION2); //6%
+                else if (master->getLevel() >= 20)
+                    RefreshAura(INSPIRATION1); //3%
+
+                if (master->getLevel() >= 15)
+                {
+                    RefreshAura(GLYPH_SW_PAIN, master->getLevel()/16); //5% of BASE mana(which pretty small)
+                    RefreshAura(GLYPH_PW_SHIELD); //20% heal
+                }
+
+                if (master->getLevel() >= 40)
+                    RefreshAura(SHADOWFORM); //allows dots to crit
+                if (master->getLevel() >= 70)
+                    RefreshAura(PRIEST_T10_2P_BONUS);
+                //misc
+                ApplyPassives(CLASS_PRIEST);
+                SetBotCommandState(COMMAND_FOLLOW);
+
+                if (master->getLevel() >= 78)
+                    PENANCE = PENANCE4;
+                else if (master->getLevel() >= 70)
+                    PENANCE = PENANCE3;
+                else if (master->getLevel() >= 65)
+                    PENANCE = PENANCE2;
+                else if (master->getLevel() >= 60)
+                    PENANCE = PENANCE1;
+                else
+                    PENANCE = NULL;
+            }
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (spellId == FEAR_WARD && m_creature->getLevel() <= 20) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (Feasting() && !master->isInCombat() && 
+                !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (m_creature->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != MANAPOTION && spellId != HEALINGPOTION) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                DoCast(victim, spellId, triggered);
+                m_creature->EnergizeBySpell(m_creature, spellId, urand(m_creature->GetMaxPower(POWER_MANA)/3,m_creature->GetMaxPower(POWER_MANA)), POWER_MANA);
+                return true;
+            }
+            m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+            if (master->getLevel() >= 78)
+                GC_Timer = 8;
+            else if (master->getLevel() >= 70)
+                GC_Timer = 10;
+            else if (master->getLevel() >= 50)
+                GC_Timer = 12;
+            else if (master->getLevel() >= 35)
+                GC_Timer = 14;
+            else if (master->getLevel() >= 25)
+                GC_Timer = 16;
+            else if (master->getLevel() >= 15)
+                GC_Timer = 18;
+            else
+                GC_Timer = 20;
+
+            if (!victim->IsWithinLOSInMap(m_creature) && IsInBotParty(victim))
+                m_creature->Relocate(victim);
+
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        bool MassGroupHeal(Player *gPlayer)
+        {
+            if (!isTimerReady(Prayer_of_Healing_Timer) && !isTimerReady(Divine_Hymn_Timer)) return false;
+            if (master->getLevel() < 80) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false; // if I'm already casting
+            std::list<Unit*> unitList;
+            gPlayer->GetRaidMember(unitList,20);
+            if (!unitList.empty())
+            {
+                uint8 LHPcount = 0;
+                for (std::list<Unit*>::iterator itr = unitList.begin() ; itr!=unitList.end(); ++itr)
+                {
+                    Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (m_creature->GetDistance(tPlayer) > 39) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 70)
+                        ++LHPcount;
+                }
+                if ((LHPcount > 3) && isTimerReady(Prayer_of_Healing_Timer))
+                {
+                    if (doCast(m_creature, PRAYER_OF_HEALING))
+                    {
+                        Prayer_of_Healing_Timer = 600;
+                        return true;
+
+                        char *str = (char *)malloc(32);
+                        sprintf(str, "Light, give me strength!");
+                        m_creature->MonsterSay(str, LANG_UNIVERSAL, NULL);
+                        free(str);
+                    }
+                }
+                else
+                if (LHPcount > 1 && isTimerReady(Divine_Hymn_Timer))
+                {
+                    GC_Timer = 0;
+                    doCast(m_creature, DIVINE_HYMN);//Too much mana
+                    Divine_Hymn_Timer = 350;
+                    return true;
+                }
+            }//endif unitlist
+            return false;
+        }//end MassGroupHeal
+
+        void ShieldGroup(Unit *pTarget)
+        {
+            if (!isTimerReady(PWS_Timer)) return;
+
+            std::list<Unit*> unitList;
+            pTarget->GetRaidMember(unitList,30);
+            if (unitList.empty()) return;
+            for(std::list<Unit*>::iterator itr = unitList.begin(); itr!=unitList.end(); ++itr)
+            {
+                Player *tPlayer = ((Player *)master)->GetObjPlayer((*itr)->GetGUID());
+                if (tPlayer == NULL) continue;
+                if (tPlayer->isDead()) continue;
+                if (tPlayer->HasAura(WEAKENED_SOUL)) continue;
+                if (HasAuraName(tPlayer, SPELL_PW_SHIELD)) continue;
+                if (m_creature->GetDistance(tPlayer) > 30) continue;
+                ShieldTarget(tPlayer);
+            }
+        }
+
+        bool ShieldTarget(Unit *target)
+        {
+            if (!isTimerReady(PWS_Timer)) return false;
+            if (target->HasAura(WEAKENED_SOUL)) return false;
+            if (HasAuraName(target, SPELL_PW_SHIELD)) return false;
+            if (m_creature->GetDistance(target) > 40) return false;
+
+            if (!target->getAttackers().empty() || GetHealthPCT(target) < 33 || target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                if (doCast(target, SPELL_PW_SHIELD))
+                {
+                    if (target == m_creature || m_creature->getLevel() > 40)
+                        PWS_Timer = 0;
+                    else
+                        PWS_Timer = 40;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        bool HandleCure(DispelType dispel, Unit *target)
+        {
+            if (dispel == DISPEL_DISEASE && doCast(target, CURE_DISEASE))
+                return true;
+            else if (dispel == DISPEL_MAGIC && doCast(target, MASS_DISPEL))
+                return true;
+            return false;
+        }
+
+        void EnterEvadeMode()
+        {
+            if (!me->isAlive())
+                return;
+            if (m_creature->IsInEvadeMode())
+                return;
+            if (!IsEvent())
+            {
+                if (!m_creature->getThreatManager().isThreatListEmpty())
+                    m_creature->DeleteThreatList();
+                if (m_creature->isInCombat())
+                {
+                    if (IsChanneling())
+                        m_creature->CombatStop(false);
+                    else
+                        m_creature->CombatStop(true);
+                }
+                Follow();
+            }
+        }
+
+        void Aggro(Unit *who){}
+
+        void AttackStart(Unit *u)
+        {if (!master) return; if (!u->isTargetableForAttack()) return; Aggro(u); m_creature->AddThreat(u, 0.001f); opponent = u; m_creature->SetBotCommandState(COMMAND_ATTACK); }
+
+        void KilledUnit(Unit *)
+        {if (!master) return;
+            Unit *u = master->GetSelectedUnit();
+            if (!u || !u->isInCombat() || !u->IsHostileTo(master))
+            {
+                if (!IsEvent())
+                {
+                    if (!master->getVictim() && master->getAttackers().empty() && master->isInCombat())
+                        master->CombatStop();
+                    if (!master->isInCombat())
+                        m_creature->CombatStop();
+                }
+            }
+            SetBotCommandState(COMMAND_FOLLOW);
+            //ResetOrGetNextTarget();
+        }
+
+       /* void MoveInLineOfSight(Unit *target)
+        {
+            if (master==NULL || master==0) return;
+
+            if (target->GetGUID() == master->GetGUID()) return;
+
+            if (!target->IsFriendlyTo(master)) return;
+
+            if (target->isAlive() && GetHealthPCT(target) < 75)
+            {
+                m_creature->CastSpell(target, SPELL_HEAL, false);
+            }
+        }*/
+
+        void JustDied(Unit *Killer)
+        {if (!master) return;Follow();}
+
+        void UpdateAI(const uint32 diff)
+        {if (!master) return;
+            decrementTimers();
+            if (IAmDead()) return;
+            if (wait == 0)
+                wait = urand(1,3);
+            else
+                return;
+            if (checkAurasTimer <= 0)
+            {
+                CheckAuras();
+                checkAurasTimer = 30;
+            }
+            if (CCed()) return;
+            if (isTimerReady(DevcheckTimer))
+            {
+                if (FindAffectedTarget(DEVOURING_PLAGUE, m_creature->GetGUID()))
+                    Devcheck = true;
+                else
+                    Devcheck = false;
+            }
+            else
+                Devcheck = true;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = m_creature->getAttackers();
+            /*if (!master->getVictim() && !m_creature->getVictim() && 
+                m_attackers.empty() && b_attackers.empty() && 
+                !HasAuraName(master, "Feign Death") && !IsEvent())
+            {
+                m_creature->DeleteThreatList();
+                m_creature->CombatStop();
+                if (master->isInCombat())
+                    master->CombatStop();
+            }*/
+
+            //potion
+            if (GetManaPCT(m_creature) < 25 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, MANAPOTION)) Potion_cd = MANA_CD;//60 s
+                GC_Timer = temptimer;
+            }
+            //check possible fear
+            doDefend();
+            //buff and heal master's group
+            MassGroupHeal(master);
+            BuffAndHealGroup(master);
+            CureGroup(master);//MASS_DISPEL/CURE_DISEADE
+            ShieldGroup(master);
+            if ((master->isInCombat() || m_creature->isInCombat()) && 
+                isTimerReady(CheckDispelTimer))
+            {
+                CheckSilence();
+                CheckShackles();
+                CheckDispel();
+            }
+
+            healOthers();
+            if (!m_creature->isInCombat())
+            {
+                DoNonCombatActions();
+            }
+
+            //Now if we are doing nothing and nothing threats let's do some damage
+            //I suppose it will do better in boss encounters
+            opponent = getTarget();
+            if (!opponent)
+                opponent = m_creature->getVictim();
+
+            if (!CheckTarget(opponent) || !opponent)
+                return;
+
+            if (CCed(opponent))
+                ChangeTarget(opponent, 30);
+
+            if (GetHealthPCT(master) > 90 && 
+                GetManaPCT(m_creature) > 35 && 
+                GetHealthPCT(m_creature) > 90 && 
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3))
+                //general rule
+            {
+                if (m_creature->GetDistance(opponent) < 30)
+                {
+                    //Position
+                    if (master->GetDistance(opponent) < 15)
+                        ScriptedAI::AttackStartCaster(opponent, 13);
+                    else if (!m_creature->HasUnitState(UNIT_STAT_CASTING) && m_creature->GetDistance(master) > 10)
+                    {
+                        m_creature->Relocate(master);
+                        SetBotCommandState(COMMAND_FOLLOW);
+                        return;
+                    }
+                    if (SW_DEATH != 0 && GetHealthPCT(opponent) < 15 && isTimerReady(SW_Death_Timer) && 
+                        doCast(opponent, SW_DEATH)) 
+                        SW_Death_Timer = 100;
+                    if (!HasAuraName(opponent, SW_PAIN, m_creature->GetGUID()) && GC_Timer <= 0)
+                        doCast(opponent, SW_PAIN);
+                        //m_creature->AddAura(SW_PAIN, opponent);
+                    if (DEVOURING_PLAGUE != 0 && Devcheck == false && !HasAuraName(opponent, DEVOURING_PLAGUE, m_creature->GetGUID()) && GC_Timer <= 0 && 
+                        !opponent->IsImmunedToSpell(sSpellMgr->GetSpellInfo(DEVOURING_PLAGUE)))
+                        doCast(opponent, DEVOURING_PLAGUE);
+                    if (isTimerReady(Mind_Blast_Timer) && doCast(opponent, MIND_BLAST))
+                        Mind_Blast_Timer = 80 - m_creature->getLevel()/4;//6 sec on 80
+                    if (MIND_FLAY && isTimerReady(Mind_Flay_Timer) && m_creature->GetDistance(opponent) < 30 && 
+                        !opponent->HasAura(MIND_FLAY, m_creature->GetGUID()) && 
+                        (opponent->isMoving() || 
+                        (HasAuraName(opponent, SW_PAIN, m_creature->GetGUID()) && 
+                        HasAuraName(opponent, DEVOURING_PLAGUE, m_creature->GetGUID()))) && 
+                        doCast(opponent, MIND_FLAY))
+                        Mind_Flay_Timer = 30;
+                } //endif opponent
+            } //endif damage
+            //check horror after dots/damage
+            if (master->getLevel() >= 45 && opponent && 
+                isTimerReady(Psychic_Horror_Timer) && 
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                !CCed(opponent))
+            {
+                Unit *u = opponent->getVictim();
+                if (u && IsInBotParty(u) && doCast(opponent, SPELL_PSYCHIC_HORROR))
+                    Psychic_Horror_Timer = 600;
+            }
+        } //end UpdateAI
+
+        bool HealTarget(Unit *target, uint8 hp)
+        {
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (!target || target->isDead()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && IS_PLAYER_GUID(target->GetGUID()) && 
+                (target->isInCombat() || !target->getAttackers().empty()) && 
+                Pain_Suppression_Timer <= 0 && 
+                !target->HasAura(PAIN_SUPPRESSION) && 
+                m_creature->getLevel() >= 40 && 
+                m_creature->GetDistance(target) < 40)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, PAIN_SUPPRESSION)) Pain_Suppression_Timer = 450;//45 sec
+                GC_Timer = temptimer;
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) && 
+                isTimerReady(PWS_Timer) && 
+                !HasAuraName(target, SPELL_PW_SHIELD) && 
+                !target->HasAura(WEAKENED_SOUL) && 
+                m_creature->GetDistance(target) < 40)
+            {
+                ShieldTarget(target);
+            }
+
+            if ((hp < 75 || GetLostHP(target) > 4000) && 
+                m_creature->GetDistance(target) < 40)
+            {
+                if (PENANCE != 0 && isTimerReady(Penance_Timer) && doCast(target, PENANCE))
+                { Penance_Timer = 80; return true; }
+                else if (isTimerReady(Heal_Timer) && doCast(target, SPELL_HEAL))
+                { Heal_Timer = 25; return true; }
+            }
+
+            if (((hp > 75 && hp < 90) || hp < 55 || GetLostHP(target) > 1500) && 
+                isTimerReady(GC_Timer) && SPELL_FLASH != 0 && 
+                m_creature->GetDistance(target) < 40)
+            {
+                if (doCast(target, SPELL_FLASH))
+                {
+                    if (GetHealthPCT(target) > 80)
+                        return true;
+                }
+            }
+
+            if (((hp < 98 && 
+                hp > 70) || GetLostHP(target) > 500) && 
+                !HasAuraName(target, SPELL_RENEW, m_creature->GetGUID()) && 
+                m_creature->GetDistance(target) < 40 && GC_Timer <= 0)
+            {
+                if (doCast(target, SPELL_RENEW)) {GC_Timer = 8;}
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit *target)
+        {
+            if (!target || m_creature->GetDistance(target) > 30) return false;
+            if (target->isAlive())
+            {
+                if (!HasAuraName(target, SPELL_FORTITUDE) && GC_Timer <= 0 && doCast(target, SPELL_FORTITUDE)) 
+                    return true;
+                if (!HasAuraName(target, SPELL_PRAYER_OF_SHADOW) && GC_Timer <= 0 && doCast(target, SPELL_PRAYER_OF_SHADOW)) 
+                    return true;
+                if (!HasAuraName(target, SPELL_DIVINE_SPIRIT) && GC_Timer <= 0 && doCast(target, SPELL_DIVINE_SPIRIT))
+                    return true;
+                if (target == master && !target->HasAura(FEAR_WARD) && isTimerReady(Fear_Ward_Timer) && doCast(master, FEAR_WARD))
+                {
+                    Fear_Ward_Timer = 300;//30sec
+                    return true;
+                }
+                if (!HasAuraName(target, FEAR_WARD) && isTimerReady(Fear_Ward_Timer) && master->HasAura(FEAR_WARD) && doCast(target, FEAR_WARD))
+                {
+                    Fear_Ward_Timer = 300;//30sec
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void DoNonCombatActions()
+        {if (!master) return;
+            //if eating or drinking don't do anything
+            if (Feasting()) return;
+
+            //buff master
+            if (master->isAlive() && m_creature->GetDistance(master) < 30)
+            {
+                if (!HasAuraName(master, SPELL_FORTITUDE) && GC_Timer <= 0)
+                    doCast(master, SPELL_FORTITUDE);
+                if (!HasAuraName(master, SPELL_DIVINE_SPIRIT) && GC_Timer <= 0)
+                    doCast(master, SPELL_DIVINE_SPIRIT);
+                if (!HasAuraName(master, SPELL_PRAYER_OF_SHADOW) && GC_Timer <= 0)
+                    doCast(master, SPELL_PRAYER_OF_SHADOW);
+                if (!HasAuraName(master, FEAR_WARD) && isTimerReady(Fear_Ward_Timer))
+                    if (doCast(master, FEAR_WARD))
+                        Fear_Ward_Timer = 300;
+            }
+
+            //buff myself
+            if (master->isAlive())
+            {
+                if (!m_creature->HasAura(SPELL_INNER_FIRE) && GC_Timer <= 0 && 
+                    doCast(m_creature, SPELL_INNER_FIRE)){}
+                if (!m_creature->HasAura(SPELL_FORTITUDE) && GC_Timer <= 0 && 
+                    doCast(m_creature, SPELL_FORTITUDE)){}
+                if (!m_creature->HasAura(SPELL_DIVINE_SPIRIT) && GC_Timer <= 0 && 
+                    doCast(m_creature, SPELL_DIVINE_SPIRIT)){}
+                if (m_creature->getLevel() >= 30 && !m_creature->HasAura(VAMPIRIC_EMBRACE) && GC_Timer <= 0 && 
+                    doCast(m_creature, VAMPIRIC_EMBRACE)){}
+            }
+
+            //buff and heal master's group
+            if (master->GetGroup())
+            {
+                RezGroup(SPELL_RESURRECTION, master);
+                //BuffAndHealGroup(master);
+                CureGroup(master);
+            }
+        }
+
+        void CheckDispel()
+        {
+            if (!isTimerReady(GC_Timer) || !MASS_DISPEL || CheckDispelTimer > 0 || 
+                m_creature->HasUnitState(UNIT_STAT_CASTING))
+                return;
+            Unit *target = FindHostileDispelTarget();
+            if (target && doCast(target, MASS_DISPEL))
+                CheckDispelTimer = 10;
+        }
+
+        void CheckShackles()
+        {
+            if (!isTimerReady(GC_Timer) || !SPELL_SHACKLE_UNDEAD || CheckDispelTimer > 0 || 
+                m_creature->HasUnitState(UNIT_STAT_CASTING) || 
+                FindAffectedTarget(SPELL_SHACKLE_UNDEAD, m_creature->GetGUID()))
+                return;
+            Unit *target = FindUndeadCCTarget(30, SPELL_SHACKLE_UNDEAD);
+            if (target && doCast(target, SPELL_SHACKLE_UNDEAD))
+                GC_Timer = 8;
+        }
+
+        void CheckSilence()
+        {
+            if (m_creature->getLevel() < 25 || CheckDispelTimer > 0 || 
+                m_creature->HasUnitState(UNIT_STAT_CASTING))
+                return;
+            Unit *target = FindCastingTarget(30);
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (Silence_Timer <= 0 && doCast(target, SPELL_SILENCE))
+                    Silence_Timer = 300;
+                else if (Psychic_Horror_Timer <= 300 && doCast(target, SPELL_PSYCHIC_HORROR))
+                    Psychic_Horror_Timer = 600;
+                GC_Timer = temptimer;
+            }
+        }
+
+        void doDefend()
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = m_creature->getAttackers();
+            //fear master's attackers
+            if (!m_attackers.empty() && m_creature->getLevel() >= 20 && 
+                ((master->getClass() != CLASS_WARRIOR && 
+                master->getClass() != CLASS_PALADIN &&  
+                master->getClass() != CLASS_DEATH_KNIGHT) || 
+                GetHealthPCT(master) < 50))
+            {
+                uint8 tCount = 0;
+                for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (m_creature->GetDistance((*iter)) > 8) continue;
+                    if (CCed(*iter) && m_creature->GetDistance((*iter)) > 5) continue;
+                    if (m_creature->GetDistance((*iter)) <= 8 && m_creature->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 1 && isTimerReady(Fear_Timer) && doCast(m_creature, PSYCHIC_SCREAM))
+                    Fear_Timer = 240;//with improved 24 sec
+            }
+            
+            // Defend myself (psychic horror)
+            if (!b_attackers.empty() && m_creature->getLevel() >= 20)
+            {
+                uint8 tCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (m_creature->GetDistance((*iter)) > 8) continue;
+                    if (CCed(*iter) && m_creature->GetDistance((*iter)) > 5) continue;
+                    if (m_creature->GetDistance((*iter)) <= 8 && m_creature->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 0 && isTimerReady(Fear_Timer) && doCast(m_creature, PSYCHIC_SCREAM))
+                    Fear_Timer = 240;//with improved 24 sec
+            }
+            // Heal myself
+            if (GetHealthPCT(m_creature) < 100 && !b_attackers.empty())
+            {
+                ShieldTarget(m_creature);
+
+                if (m_creature->getLevel() >= 10 && Fade_Timer <= 0 && m_creature->isInCombat())
+                {
+                    if (b_attackers.empty()) return; //no aggro
+                    uint8 Tattackers = 0;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if ((*iter)->getThreatManager().getThreat(m_creature) < 15.0f) continue;//too small threat
+                        if (m_creature->GetDistance((*iter)) > 15) continue;
+                        if (m_creature->GetDistance((*iter)) <= 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(m_creature, SPELL_FADE)) Fade_Timer = 60;
+                        GC_Timer = temptimer;
+                        for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                        {
+                            if ((*iter)->getThreatManager().getThreat(m_creature) > 0.0f)
+                                (*iter)->getThreatManager().modifyThreatPercent(m_creature, -50);
+                        }
+                    }
+                }
+
+                if (GetHealthPCT(m_creature) < 90)
+                    HealTarget(m_creature, GetHealthPCT(m_creature));
+            }
+        }
+
+        void decrementTimers()
+        {if (!master) return;
+            if (Heal_Timer > 0)              --Heal_Timer;
+            if (Fade_Timer > 0)              --Fade_Timer;
+            if (Divine_Hymn_Timer > 0)       --Divine_Hymn_Timer;
+            if (Prayer_of_Healing_Timer > 0) --Prayer_of_Healing_Timer;
+            if (Pain_Suppression_Timer > 0)  --Pain_Suppression_Timer;
+            if (PWS_Timer > 0)               --PWS_Timer;
+            if (Potion_cd > 0)               --Potion_cd;
+            if (Fear_Timer > 0)              --Fear_Timer;
+            if (Mind_Blast_Timer > 0)        --Mind_Blast_Timer;
+            if (SW_Death_Timer > 0)          --SW_Death_Timer;
+            if (Fear_Ward_Timer > 0)         --Fear_Ward_Timer;
+            if (Psychic_Horror_Timer > 0)    --Psychic_Horror_Timer;
+            if (Silence_Timer > 0)           --Silence_Timer;
+            if (Mind_Flay_Timer > 0)         --Mind_Flay_Timer;
+            if (Penance_Timer > 0)           --Penance_Timer;
+            if (CheckDispelTimer > 0)        --CheckDispelTimer;
+            if (GC_Timer > 0)                --GC_Timer;
+            if (temptimer > 0)               --temptimer;
+            if (checkAurasTimer > 0)         --checkAurasTimer;
+            if (wait > 0)                    --wait;
+            if (DevcheckTimer > 0)           --DevcheckTimer;
+        } //end decrementTImers
+
+        void ReceiveBowEmote(Player *player)
+        {
+            if (m_creature->GetDistance(player) < 30)
+                ((priest_botAI*)m_creature->AI())->doCast(player, SPELL_FORTITUDE);
+            else
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                DoSay("Come closer, you fool", LANG_UNIVERSAL, player->GetGUID());
+            }
+        }
+    }; //end priest_bot
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/scripts/Bots/bot_priest_ai.h b/src/server/scripts/Bots/bot_priest_ai.h
new file mode 100644
index 0000000..cdb7d18
--- /dev/null
+++ b/src/server/scripts/Bots/bot_priest_ai.h
@@ -0,0 +1,84 @@
+#include "bot_ai.h"
+
+#define FEAR_WARD                 6346
+#define WEAKENED_SOUL             6788
+#define PAIN_SUPPRESSION          33206
+#define PSYCHIC_SCREAM            10890
+#define SPELL_FADE                586
+#define SPELL_PSYCHIC_HORROR      64044
+#define SPELL_SILENCE             15487
+#define SPELL_SHACKLE_UNDEAD      SPELL_SHACKLE_UNDEAD_A[SPELL_LEVEL]
+uint32 SPELL_SHACKLE_UNDEAD_A[] = { 0, 0, 9484, 9484, 9485, 9485, 10955, 10955, 10955, 10955 };
+
+//HEAL
+#define SPELL_HEAL                SPELL_HEAL_A[SPELL_LEVEL]
+#define SPELL_RENEW               SPELL_RENEW_A[SPELL_LEVEL]
+#define SPELL_RESURRECTION        SPELL_RESURRECTION_A[SPELL_LEVEL]
+#define SPELL_FLASH               SPELL_FLASH_A[SPELL_LEVEL]
+#define PRAYER_OF_HEALING         PRAYER_OF_HEALING_A[SPELL_LEVEL]
+#define DIVINE_HYMN               DIVINE_HYMN_A[SPELL_LEVEL]
+#define PENANCE1                  47540
+#define PENANCE2                  53005
+#define PENANCE3                  53006
+#define PENANCE4                  53007
+uint32 PRAYER_OF_HEALING_A[] = { 0, 0, 0, 0, 0, 0, 0, 0, 33152, 33152 };
+uint32 DIVINE_HYMN_A[] = { 0, 0, 0, 0, 0, 0, 0, 0, 64843, 64843 };
+
+//BUFFS
+#define SPELL_PW_SHIELD           SPELL_PW_SHIELD_A[SPELL_LEVEL]
+#define SPELL_INNER_FIRE          SPELL_INNER_FIRE_A[SPELL_LEVEL]
+#define SPELL_FORTITUDE           SPELL_FORTITUDE_A[SPELL_LEVEL]
+#define SPELL_PRAYER_OF_SHADOW    SPELL_PRAYER_OF_SHADOW_A[SPELL_LEVEL]
+#define SPELL_DIVINE_SPIRIT       SPELL_DIVINE_SPIRIT_A[SPELL_LEVEL]
+
+uint32 SPELL_PW_SHIELD_A[] = { 17, 592, 3747, 6066, 10899, 10900, 10901, 25218, 48066, 48066 };
+uint32 SPELL_INNER_FIRE_A[] = { 588, 7128, 602, 1006, 10951, 10952, 25431, 25431, 48168, 48168 };
+uint32 SPELL_FORTITUDE_A[] = { 1243, 1244, 1245, 2791, 10937, 10938, 25389, 48161, 48161, 48161 };
+uint32 SPELL_PRAYER_OF_SHADOW_A[] = { 0, 0, 0, 976, 10957, 10958, 10958, 25433, 48169, 48170 };
+uint32 SPELL_DIVINE_SPIRIT_A[] = {0, 0, 0, 14752, 14818, 14819, 27841, 25312, 48073, 48073};
+uint32 SPELL_RENEW_A[] = { 6074, 6075, 6077, 6078, 10927, 10928, 25315, 25222, 48068, 48068 };
+uint32 SPELL_HEAL_A[] = { 29170, 2053, 2055, 6064, 10963, 10964, 25314, 25213, 48063, 48063 };
+uint32 SPELL_RESURRECTION_A[] = { 2006, 2006, 2010, 10880, 10881, 20770, 25435, 48171, 48171, 51918 };
+uint32 SPELL_FLASH_A[] = { 0, 2061, 9472, 9473, 10915, 10916, 10917, 25235, 48071, 48071 };
+
+//damage
+#define VAMPIRIC_EMBRACE            15286
+#define SW_PAIN                     SW_PAIN_A[SPELL_LEVEL]
+#define MIND_BLAST                  MIND_BLAST_A[SPELL_LEVEL]
+#define SW_DEATH                    SW_DEATH_A[SPELL_LEVEL]
+#define DEVOURING_PLAGUE            DEVOURING_PLAGUE_A[SPELL_LEVEL]
+#define MIND_FLAY                   MIND_FLAY_A[SPELL_LEVEL]
+uint32 SW_PAIN_A[] = { 589, 970, 2767, 10892, 10893, 10894, 25367, 25368, 48125, 57778 };
+uint32 MIND_BLAST_A[] = { 8092, 8102, 8103, 8105, 10945, 10947, 25375, 48126, 48127, 13860 };
+uint32 SW_DEATH_A[] = { 0, 0, 0, 0, 32379, 32996, 32996, 48157, 48158, 48158 };
+uint32 DEVOURING_PLAGUE_A[] = { 0, 0, 2944, 19276, 19277, 19278, 19279, 25467, 48300, 48300 };
+uint32 MIND_FLAY_A[] = { 0, 0, 15407, 17311, 17313, 17314, 18807, 48155, 48156, 48156 };
+
+//AURA
+#define RADIANCE_AURA                   71953
+//PASSIVE
+#define SHADOWFORM  /*For DOT crits*/   49868
+//Talents
+//shadow
+#define IMP_DEV_PLAG                    63627//rank 3
+#define MISERY1                         33191
+#define MISERY2                         33192
+#define MISERY3                         33193
+#define PAINANDSUFFERING1               47580
+#define PAINANDSUFFERING2               47581
+#define PAINANDSUFFERING3               47582
+//disc
+#define DIVINE_AEGIS                    47515//rank 3
+#define BORROWED_TIME                   52800//rank 5
+#define GRACE                           47517//rank 2
+//holy
+//#define BLESSED_RECOVERY                27816//rank 3
+#define EMPOWERED_RENEW                 63534//rank 1
+#define INSPIRATION1                    14892
+#define INSPIRATION2                    15362
+#define INSPIRATION3                    15363
+//Glyphs
+#define GLYPH_SW_PAIN                   55681
+#define GLYPH_PW_SHIELD                 55672
+//other
+#define PRIEST_T10_2P_BONUS             70770//33% renew
\ No newline at end of file
diff --git a/src/server/scripts/Bots/bot_rogue_ai.cpp b/src/server/scripts/Bots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..d70cf91
--- /dev/null
+++ b/src/server/scripts/Bots/bot_rogue_ai.cpp
@@ -0,0 +1,325 @@
+#include "ScriptPCH.h"
+#include "bot_rogue_ai.h"
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new rogue_botAI(pCreature);
+    }
+
+struct rogue_botAI : public bot_ai
+{
+    rogue_botAI(Creature *c) : bot_ai(c)
+    {
+        Reset();
+    }
+
+    int32 GC_Timer;                // global cooldown
+    int32 BS_Timer;
+    int32 SinisterStrike_Timer;
+    int32 Eviscerate_Timer;
+    int32 SliceDice_Timer;
+    int32 Rupture_Timer;
+    int32 Kick_Timer;
+    int32 Poison_Timer;
+    int32 Potion_Timer;
+    int32 Shadowstep_Timer;
+    int32 Mutilate_Timer;
+
+    uint8 energy;
+    uint8 comboPoints;
+
+    Unit *opponent;
+
+    void Reset()
+    {
+        GC_Timer = 0;
+        BS_Timer = 0;
+        Mutilate_Timer = 0;
+        SinisterStrike_Timer = 0;
+        Eviscerate_Timer = 0;
+        SliceDice_Timer = 0;
+        Rupture_Timer = 0;
+        Kick_Timer = 0;
+        Poison_Timer = 0;
+        Potion_Timer=0;
+        Shadowstep_Timer = 0;
+        comboPoints = 0;
+        energy = 100;
+
+        opponent = NULL;
+
+        m_creature->setPowerType(POWER_ENERGY);
+        m_creature->SetMaxPower(POWER_ENERGY, 100);
+        m_creature->SetPower(POWER_ENERGY, 100);
+
+        if (master)
+        {
+            //        if (!m_creature->HasAura(61331)) m_creature->AddAura(61331,m_creature);  // Aggression
+            //         if (!m_creature->HasAura(14137)) m_creature->AddAura(14137,m_creature);  // Lethality
+            //          if (!m_creature->HasAura(14166)) m_creature->AddAura(14166,m_creature);  // Improved Slice and Dice
+            //           if (!m_creature->HasAura(14164)) m_creature->AddAura(14164,m_creature);  // Improved Eviserate
+
+            setStats(CLASS_ROGUE, m_creature->getRace(), master->getLevel());
+            SetBotCommandState(COMMAND_FOLLOW);
+            if (m_creature->getLevel()>60 && !m_creature->HasAura(37169)) m_creature->AddAura(37169,m_creature);  // Death Mantle item set
+        }
+
+    }
+
+    void EnterEvadeMode(){}
+
+    void Aggro(Unit *who){}
+
+    void MoveInLineOfSight(Unit *target){}
+
+    bool isTimerReady(int32 timer)
+    {
+        if(timer <= 0 && GC_Timer <= 0) return true;
+        else                            return false;
+    } //end isTimerReady
+
+    void doCast(Unit *victim, uint32 spellId, bool triggered = false)
+    {if (!master) return;
+        if(spellId == 0) return;
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        GC_Timer = 9;
+        DoCast(victim, spellId, triggered);
+    } //end doCast
+
+    void decrementTimers()
+    {if (!master) return;
+        if(GC_Timer > 0)             --GC_Timer;
+        if(BS_Timer > 0)             --BS_Timer;
+        if(Kick_Timer > 0)           --Kick_Timer;
+        if(SliceDice_Timer > 0)      --SliceDice_Timer;
+        if(SinisterStrike_Timer > 0) --SinisterStrike_Timer;
+        if(Eviscerate_Timer > 0)     --Eviscerate_Timer;
+        if(Rupture_Timer > 0)        --Rupture_Timer;
+        if(Poison_Timer > 0)         --Poison_Timer;
+        if(Potion_Timer > 0)         --Potion_Timer;
+        if(Shadowstep_Timer > 0)     --Shadowstep_Timer;
+        if (Mutilate_Timer > 0)            Mutilate_Timer--;
+    } //end decrementTImers
+
+    void KilledUnit(Unit *)
+    {if (!master) return;
+        SetBotCommandState(COMMAND_FOLLOW);
+    }
+
+    void AttackStart(Unit *u)
+    {if (!master) return;
+        Aggro(u);
+        ScriptedAI::AttackStart(u);
+    }
+
+    void UpdateAI(const uint32 diff)
+    {if (!master) return;
+        decrementTimers();
+
+        if(IAmDead()) return;
+
+        opponent = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+        if(!opponent && !m_creature->getVictim())
+        {
+            m_creature->CombatStop(true);
+            comboPoints = 1;
+            energy = 100;
+            //ResetOrGetNextTarget();
+            return;
+        }
+
+        m_creature->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+        m_creature->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+        energy += 8;
+        if(comboPoints > 5) comboPoints = 5;
+
+        //interrupt any spells
+        if(opponent->HasUnitState(UNIT_STAT_CASTING) && energy >= 25)
+        {
+            if(isTimerReady(Kick_Timer))
+            {
+                doCast(opponent, KICK);
+                Kick_Timer = 80;
+                energy -= 25;
+            }
+            else if(comboPoints > 0)
+            {
+                switch(comboPoints)
+                {
+                    case 1: doCast(opponent, KIDNEY_SHOT_1); --comboPoints; break;
+                    case 2: doCast(opponent, KIDNEY_SHOT_2); comboPoints-=2; break;
+                    default: doCast(opponent, KIDNEY_SHOT_3); comboPoints=0; break;
+                }
+                energy -= 25;
+            }
+        }
+
+        if(!opponent->isInFrontInMap(m_creature, 5) && isTimerReady(BS_Timer) && energy >= 40)
+        {
+            doCast(opponent, BACKSTAB);
+            BS_Timer = 50;
+            energy -= 40;
+        }
+        else if(isTimerReady(Shadowstep_Timer) && energy > 10 && m_creature->GetDistance(opponent) < 25)
+        {
+            //doCast(opponent, SHADOWSTEP);
+            Shadowstep_Timer = 200;
+            energy -= 10;
+
+            //NPCs can't really shadowstep so fake it
+            float x = opponent->GetPositionX();
+            float y = opponent->GetPositionY();
+            float z = opponent->GetPositionZ();
+            float o = opponent->GetOrientation();
+
+            m_creature->Relocate(x-4, y-4, z, o);
+            m_creature->SendMonsterMoveWithSpeed(x-4, y-4, 0, 0);
+            doCast(opponent, BACKSTAB, true);
+            return;
+        }
+
+        if(isTimerReady(SliceDice_Timer) && comboPoints > 0 && !m_creature->HasAura(SLICE_DICE))
+        {
+            doCast(opponent, SLICE_DICE);
+
+            // since npcs don't use combo points, they can only case
+            // first level of spell.  So only remove 1 combo point
+            --comboPoints;
+
+            SliceDice_Timer = 150;
+            energy -= 25;
+        }
+
+        if (isTimerReady(Mutilate_Timer) && energy>60) 
+        {
+            // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            // for now use same formula as evicerate
+            uint32 base_attPower = m_creature->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //float minDmg = m_creature->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float minDmg = m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+m_creature->getLevel();
+
+            // compensate for lack of attack power
+            damage = damage*(rand()%4+1);
+
+            m_creature->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //doCast (m_creature, MUTILATE);
+            Mutilate_Timer = 10;
+            comboPoints+=3;
+            energy -= 60;
+        }
+
+        if (isTimerReady(Eviscerate_Timer) && comboPoints>0 && energy>30) {
+            uint32 base_attPower = m_creature->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //float minDmg = m_creature->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float minDmg = m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            int damage = irand(int32(base_attPower*5*0.03f),int32(base_attPower*5*0.07f))+minDmg+m_creature->getLevel();
+//sLog->outError ("EVISCERTE: base_attPower = %u", base_attPower);
+//sLog->outError("\tminDmg = %f", minDmg);
+//sLog->outError("\tmaxDmg = %f", m_creature->GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE));
+//sLog->outError ("\tMINDAMAGE after setting it = %f", m_creature->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE));
+
+// compensate for lack of attack power
+//sLog->outError ("\tdamage before = %u", damage);
+            damage = damage*(rand()%4+1);
+//sLog->outError ("\tdamage after = %u", damage);
+            // Eviscerate and Envenom Bonus Damage (Deathmantle item set effect)
+            if(m_creature->HasAura(37169))
+                damage += comboPoints*100;
+
+            m_creature->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false, NULL, NULL);
+            //doCast(opponent, EVISCERATE);
+            comboPoints = 1;
+
+            energy -= 30;
+            Eviscerate_Timer = 150;
+         //   return;
+        }
+
+        if(isTimerReady(SinisterStrike_Timer) && comboPoints < 5 && energy>40)
+        {
+            doCast(opponent, SINISTER_STRIKE);
+            //m_creature->Say("sinister strike", LANG_UNIVERSAL, NULL);
+            ++comboPoints;
+            SinisterStrike_Timer = 60;
+            energy -= 40;
+        }
+
+        if(isTimerReady(Rupture_Timer) && energy>25)
+        {
+            doCast(opponent, RUPTURE);
+            comboPoints = 0;
+            Rupture_Timer = 120;
+            energy -= 25;
+        }
+
+        /*if(!opponent->HasAuraType(SPELL_AURA_MOD_DISARM))
+            doCast(opponent, DISMANTLE);*/
+
+        /*
+            since npc can't really use poison, we'll pretend that we were able to poison his blades.
+        */
+        if(isTimerReady(Poison_Timer))
+        {
+            //Deadly Poison has 40% chance of proccing
+            switch(rand()%5)
+            {
+                case 0:
+                case 1:
+                case 2:
+                    break;
+                case 4:
+                case 5:
+                    if(DEADLY_POISON) DoCast(opponent, DEADLY_POISON, true); 
+                    break;
+            }
+
+            //Wound Poison has 50% chance of procing
+            switch(rand()%2)
+            {
+                case 0:
+                     break;
+                case 1:
+                     if(WOUND_POISON) DoCast(opponent, WOUND_POISON, true); 
+                     break;
+            }
+            //Mind Numbing Poison = 50% - in help to other bots' 'counters'
+            switch(rand()%2)
+            {
+                case 0:
+                    break;
+                case 1:
+                    if(MIND_NUMBING_POISON) DoCast(opponent, MIND_NUMBING_POISON, true);
+                    break;
+            }
+
+            Poison_Timer = 12;
+        }
+
+        //if low on health, drink a potion
+        if(m_creature->GetHealth() < m_creature->GetMaxHealth()*0.7 && isTimerReady(Potion_Timer))
+        {
+            doCast(m_creature, HEALINGPOTION);
+            Potion_Timer = 180;
+        }
+
+        m_creature->SetPower(POWER_ENERGY, energy);
+
+        ScriptedAI::UpdateAI(diff);
+    } //end UpdateAI
+
+
+}; //end rogue_bot
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/scripts/Bots/bot_rogue_ai.h b/src/server/scripts/Bots/bot_rogue_ai.h
new file mode 100644
index 0000000..5be7fd5
--- /dev/null
+++ b/src/server/scripts/Bots/bot_rogue_ai.h
@@ -0,0 +1,32 @@
+#include "bot_ai.h"
+
+#define BACKSTAB        BACKSTAB_A[SPELL_LEVEL]
+#define SINISTER_STRIKE SINISTER_STRIKE_A[SPELL_LEVEL]
+#define SLICE_DICE      SLICE_DICE_A[SPELL_LEVEL]
+#define EVISCERATE      EVISCERATE_A[SPELL_LEVEL]
+#define KICK            KICK_A[SPELL_LEVEL]
+#define RUPTURE         RUPTURE_A[SPELL_LEVEL]
+#define WOUND_POISON    WOUND_POISON_A[SPELL_LEVEL]
+#define DEADLY_POISON   DEADLY_POISON_A[SPELL_LEVEL]
+#define MIND_NUMBING_POISON MN_POISON_A[SPELL_LEVEL]
+#define DISMANTLE       DISMANTLE_A[SPELL_LEVEL]
+#define KIDNEY_SHOT_1   8643
+#define KIDNEY_SHOT_2   30832
+#define KIDNEY_SHOT_3   41389
+#define SHADOWSTEP      SHADOWSTEP_A[SPELL_LEVEL]
+#define MUTILATE        MUTILATE_A[SPELL_LEVEL]
+
+
+uint32 MUTILATE_A[] = {0, 0, 0, 0, 48666, 48666, 48666,48666, 48666, 48666 };
+uint32 BACKSTAB_A[] = { 53, 2589, 2591, 8721, 11279, 11280, 11281, 25300, 48657, 48657 };
+uint32 SINISTER_STRIKE_A[] = { 1757, 1758, 1759, 8621, 11293, 11294, 26862, 48638, 48638, 48638 };
+uint32 SLICE_DICE_A[] = { 0, 5171, 5171, 5171, 6774, 6774, 6774, 6774, 6774, 6774 };
+uint32 EVISCERATE_A[]= { 11300, 11300, 11300, 11300, 11300, 11300, 11300, 11300, 60008, 60008 };
+uint32 KICK_A[] = { 0, 1766, 1767, 1767, 1768, 1769, 38768, 38768, 38768, 38768 };
+uint32 RUPTURE_A[] = { 0, 0, 1943, 8640, 11273, 11274, 11275, 26867, 15583, 15583 };
+uint32 WOUND_POISON_A[] = { 0, 0, 0, 13218, 13222, 13223, 13224, 27189, 57974, 57974 };
+uint32 DEADLY_POISON_A[] = { 0, 0, 0, 2818, 2819, 11354, 26968, 57969, 57970, 57970 };
+uint32 DISMANTLE_A[] = { 0, 0, 51722, 51722, 51722, 51722, 51722, 51722, 51722 };//NUY
+uint32 SHADOWSTEP_A[] = { 0, 0, 0, 0, 0, 36554, 36554, 36554, 36554, 36554 };
+uint32 MN_POISON_A[] = { 0, 0, 0, 0, 0, 0, 5760, 5760, 5760, 5760 };
+
diff --git a/src/server/scripts/Bots/bot_shaman_ai.cpp b/src/server/scripts/Bots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..e06d562
--- /dev/null
+++ b/src/server/scripts/Bots/bot_shaman_ai.cpp
@@ -0,0 +1,395 @@
+#include "ScriptPCH.h"
+#include "bot_shaman_ai.h"
+#include "Group.h"
+
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new shaman_botAI(pCreature);
+    }
+
+struct shaman_botAI : public bot_ai
+{
+    shaman_botAI(Creature *c) : bot_ai(c)
+    {
+        Reset();
+    }
+
+    int32 GC_Timer; //global cooldown
+    int32 Heal_Timer;
+    int32 Lesser_Healing_Timer;
+    int32 Self_Lesser_Healing_Timer;
+    int32 Flame_Shock_Timer;
+    int32 Earth_Shock_Timer;
+    int32 Lightning_Bolt_Timer;
+    int32 Others_Heal_Timer;
+    int32 Oom_timer;
+    int32 Potion_Timer;
+    int32 Rez_Timer;
+    int32 Earth_Totem_Timer;
+    int32 Water_Totem_Timer;
+    int32 Fire_Totem_Timer;
+    int32 Wind_Totem_Timer;
+
+    Unit *mobsTarget;
+    Unit *opponent;
+
+    void Reset()
+    {
+        GC_Timer = 0;
+        Heal_Timer = 0;
+        Lesser_Healing_Timer = 0;
+        Self_Lesser_Healing_Timer = 0;
+        Flame_Shock_Timer = 0;
+        Lightning_Bolt_Timer = 0;
+        Earth_Shock_Timer = 0;
+        Others_Heal_Timer = 0;
+        Oom_timer = 0;
+
+        Earth_Totem_Timer = 0;
+        Fire_Totem_Timer = 0;
+        Water_Totem_Timer = 0;
+        Wind_Totem_Timer = 0;
+
+        Potion_Timer = 0;
+        Rez_Timer = 0;
+
+        opponent = NULL;
+
+        if (master)
+        {
+            setStats(CLASS_SHAMAN, m_creature->getRace(), master->getLevel());
+            SetBotCommandState(COMMAND_FOLLOW);
+        }
+    }
+
+    bool isTimerReady(int32 timer)
+    {
+        if(timer <= 0 && GC_Timer <= 0) return true;
+        else                            return false;
+    } //end isTimerReady
+/*
+    void doCast(Unit *victim, uint32 spellId, bool triggered = false)
+    {
+        if(spellId == 0) return;
+        m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+        GC_Timer = 20;
+        DoCast(victim, spellId, triggered);
+    } //end doCast
+*/
+    void decrementTimers()
+    {if (!master) return;
+        if(GC_Timer > 0)             --GC_Timer;
+        if(Heal_Timer > 0)           --Heal_Timer;
+        if(Others_Heal_Timer > 0)    --Others_Heal_Timer;
+        if(Flame_Shock_Timer > 0)    --Flame_Shock_Timer;
+        if(Earth_Shock_Timer > 0)    --Earth_Shock_Timer;
+        if(Lightning_Bolt_Timer > 0) --Lightning_Bolt_Timer;
+        if(Rez_Timer > 0)            --Rez_Timer;
+        if(Potion_Timer > 0)         --Potion_Timer;
+        if(Earth_Totem_Timer > 0)    --Earth_Totem_Timer;
+        if(Fire_Totem_Timer > 0)     --Fire_Totem_Timer;
+        if(Water_Totem_Timer > 0)    --Water_Totem_Timer;
+        if(Wind_Totem_Timer > 0)     --Wind_Totem_Timer;
+        if(Lesser_Healing_Timer > 0) --Lesser_Healing_Timer;
+    } //end decrementTImers
+
+    void KilledUnit(Unit *)
+    {if (!master) return;
+        SetBotCommandState(COMMAND_FOLLOW);
+
+        if(!master->getVictim())
+            {
+                m_creature->CombatStop();
+                master->CombatStop();
+            }
+    }
+
+    void Aggro(Unit *who){}
+
+    void EnterEvadeMode(){ Oom_timer = 0; }
+
+    void UpdateAI(const uint32 diff)
+    {if (!master) return;
+        decrementTimers();
+
+        if(IAmDead()) return;
+        if(CCed(m_creature)) return;
+
+        if(GetManaPCT(m_creature) < 50 &&
+            isTimerReady(Potion_Timer))
+        {
+            doCast(m_creature, MANAPOTION);
+            Potion_Timer = 150;
+        }
+        if(GetManaPCT(m_creature) < 5)
+        {
+            if(Oom_timer == 0)
+            {
+                //MonsterSay("OOM", LANG_UNIVERSAL, NULL);
+                Oom_timer = 150;
+            }
+        }
+
+        BuffAndHealGroup(master);
+
+        // Heal myself
+        HealTarget(m_creature, GetHealthPCT(m_creature));
+
+        //the rest are combat so return if not fighting
+        opponent = SelectTarget(SELECT_TARGET_TOPAGGRO);
+        if(!opponent && !m_creature->getVictim())
+        {
+            m_creature->CombatStop(true);
+            DoNonCombatActions();
+            //ResetOrGetNextTarget();
+            return;
+        }
+
+        //Cast totems.
+        if(m_creature->isInCombat() &&
+        isTimerReady(Earth_Totem_Timer) &&
+        !master->HasAura(SPELL_STONESKIN_AURA, 0))
+        {
+            doCast(m_creature, SPELL_STONESKIN_TOTEM);
+            Earth_Totem_Timer = 300;
+            return;
+        }
+
+        if(m_creature->isInCombat() &&
+        isTimerReady(Fire_Totem_Timer))
+        {
+            doCast(m_creature, SPELL_SEARING_TOTEM);
+            Fire_Totem_Timer = 600;
+            return;
+        }
+
+        if(m_creature->isInCombat() &&
+        isTimerReady(Wind_Totem_Timer) &&
+        !master->HasAura(SPELL_WINDFURY_TOTEM, 0))
+        {
+            doCast(m_creature, SPELL_WINDFURY_TOTEM);
+            Wind_Totem_Timer = 300;
+            return;
+        }
+
+        if(m_creature->isInCombat())
+        {
+            switch(master->getClass())
+            {
+                case CLASS_WARRIOR:
+                case CLASS_DEATH_KNIGHT:
+                case CLASS_ROGUE:
+                {
+                    if(isTimerReady(Water_Totem_Timer) &&
+                    !master->HasAura(SPELL_HEALINGSTREAM_AURA))
+                    {
+                        doCast(m_creature, SPELL_HEALINGSTREAM_TOTEM);
+                        Water_Totem_Timer = 250;
+                        return;
+                    }
+                    break;
+                }
+                default: //everyone else gets a mana totem
+                {
+                    if(isTimerReady (Water_Totem_Timer) &&
+                    !master->HasAura(SPELL_MANASPRING_AURA, 0))
+                    {
+                        doCast(m_creature, SPELL_MANASPRING_TOTEM);
+                        Water_Totem_Timer = 250;
+                        return;
+                    }
+                }
+            } //end switch
+
+        }
+
+
+        if(isTimerReady(Flame_Shock_Timer) &&
+            !opponent->HasAura(SPELL_FLAME_SHOCK))
+        {
+            doCast(opponent, SPELL_FLAME_SHOCK);
+            Flame_Shock_Timer = 150;
+            return;
+        }
+
+        if(isTimerReady(Lightning_Bolt_Timer))
+        {
+            doCast(opponent, SPELL_LIGHTNING_BOLT);
+            Lightning_Bolt_Timer = 90;
+            return;
+        }
+
+        if(isTimerReady(Earth_Shock_Timer) &&
+            !opponent->HasAura(SPELL_FLAME_SHOCK))
+        {
+            doCast(opponent, SPELL_EARTH_SHOCK);
+            Earth_Shock_Timer = 210;
+            return;
+        }
+
+        //now try to heal bots and pets.  DoSelectLowestHpFriendly will get
+        //everyone in group including bots and pets.  Unfortunately it can
+        //not be triggered for % of lost HP, so we just set it to -1000.
+        //This means low level players wont be healed because they wont have
+        //enough HP.
+        Unit *target = DoSelectLowestHpFriendly(40, 1000);
+        if(target)
+        {
+            if(target)
+            {
+                doCast(target, SPELL_CHAIN_HEAL, false);
+                Others_Heal_Timer = 20;
+            }
+        } else {
+            target = DoSelectLowestHpFriendly(40, 500); //now try someone with less HP lost
+            if(target)
+            {
+                if(target)
+                {
+                    doCast(target, SPELL_CHAIN_HEAL, false);
+                    Others_Heal_Timer = 40;
+                }
+            }
+        }
+
+        ScriptedAI::UpdateAI(diff);
+
+    } //end UpdateAI
+
+    void DoNonCombatActions()
+    {if (!master) return;
+        //Feast();
+
+        if(isTimerReady(GC_Timer) && !m_creature->HasAura(SPELL_LIGHTNING_SHIELD, 0))
+            doCast(m_creature, SPELL_LIGHTNING_SHIELD);
+
+        //Casts buffs
+       // if(!m_creature->isInCombat())
+       // {
+            //if(!m_creature->HasAura(SPELL_WINDFURY_WEAPON, 0)) doCast(m_creature, SPELL_WINDFURY_WEAPON);
+ //           if(isTimerReady(GC_Timer) && !m_creature->HasAura(SPELL_LIGHTNING_SHIELD, 0))
+   //             doCast(m_creature, SPELL_LIGHTNING_SHIELD);
+       // }
+
+
+        //Heal/rez others
+        //
+        //check group members, this doesn't check bots/pets.  They will be done later.  Preference
+        //goes to real players first.
+        //
+        //buff and heal group
+        if(master->GetGroup())
+        {
+            RezGroup(SPELL_SHAMAN_REZZ, master);
+            BuffAndHealGroup(master);
+           // CureGroup(master);
+        }
+
+
+        /* TESTING */
+        Group::MemberSlotList const &a =((Player*)master)->GetGroup()->GetMemberSlots();
+        for(Group::member_citerator itr = a.begin(); itr != a.end(); itr++)
+        {
+            Player *tPlayer = ((Player *)master)->GetObjPlayer(itr->guid);
+            if(tPlayer == NULL) continue;
+            //healing others
+            if(tPlayer->isAlive() &&
+            isTimerReady(Others_Heal_Timer) &&
+            tPlayer->GetGUID() != master->GetGUID() &&
+            tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+            {
+                doCast(tPlayer, SPELL_CHAIN_HEAL, false);
+                Others_Heal_Timer = 70;
+            }
+
+            //rezzes
+            if(tPlayer->isDead() &&
+            !m_creature->isInCombat() &&
+            //CanCast(tPlayer, sSpellMgr->GetSpellInfo (SPELL_SHAMAN_REZZ)) &&
+            m_creature->GetDistance(tPlayer) < 40 &&
+            isTimerReady(Rez_Timer))
+            {
+                char *str = (char *)malloc(32);
+                sprintf(str, "Rezzing %s", tPlayer->GetName());
+                m_creature->MonsterSay(str, LANG_UNIVERSAL, NULL);
+                free(str);
+                doCast(tPlayer, SPELL_SHAMAN_REZZ, false);
+                Rez_Timer = 220;
+            }
+        }
+        /* TESTING */
+
+
+
+/* TESTING */
+        if((master->GetHealth()*100 / master->GetMaxHealth() < 90) && Lesser_Healing_Timer <= 0)
+        {
+            doCast(master, SPELL_LESSER_HEALING);
+            Lesser_Healing_Timer = 50;
+            Heal_Timer = Heal_Timer + 1; //wait 2 seconds before casting a real heal
+            //if(master->isInCombat()) && master->getVictim() == NULL) return;
+            return;
+        } else if(Lesser_Healing_Timer >= 0) --Lesser_Healing_Timer;
+
+        if((master->GetHealth()*100 / master->GetMaxHealth() < 75) && isTimerReady(Heal_Timer))
+        {
+            doCast(master, SPELL_CHAIN_HEAL);
+            Heal_Timer = 7; // 7 secs (Heal_Timer) EXACT
+        }
+
+        if(m_creature->GetHealth()*100 / m_creature->GetMaxHealth() < 90)
+        {
+            if(Self_Lesser_Healing_Timer <= 0)
+            {
+                doCast(m_creature, SPELL_LESSER_HEALING);
+                Self_Lesser_Healing_Timer = 70;
+                return;
+            } else if(Self_Lesser_Healing_Timer >= 0)
+                --Self_Lesser_Healing_Timer;
+        }
+/* TESTING */
+        }
+
+    bool HealTarget(Unit *target, uint8 hp)
+    {
+        if (!isTimerReady(GC_Timer)) return false;
+        if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+        if(!target || target->isDead()) return false;
+
+        if(hp < 100 && Lesser_Healing_Timer <= 0)
+        {
+            doCast(target, SPELL_LESSER_HEALING);
+            Lesser_Healing_Timer = 40;
+            Heal_Timer = Heal_Timer + 1; //wait 1 seconds before casting a real heal
+            //if(master->isInCombat()) && master->getVictim() == NULL) return;
+            return true;
+        } 
+        else
+
+        if(hp < 75 && isTimerReady(Heal_Timer))
+        {
+            doCast(target, SPELL_CHAIN_HEAL);
+            Heal_Timer = 3;
+        }
+        return true;
+    } //end HealTarget
+
+    void ReceiveBowEmote(Player *player)
+    {
+        doCast(m_creature, SPELL_MANASPRING_TOTEM);
+    }
+
+
+}; //end shaman_bot
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/scripts/Bots/bot_shaman_ai.h b/src/server/scripts/Bots/bot_shaman_ai.h
new file mode 100644
index 0000000..f4e85eb
--- /dev/null
+++ b/src/server/scripts/Bots/bot_shaman_ai.h
@@ -0,0 +1,48 @@
+#include "bot_ai.h"
+
+#define SPELL_CHAIN_HEAL          SPELL_CHAIN_HEAL_A[SPELL_LEVEL]
+#define SPELL_LESSER_HEALING      SPELL_LESSER_HEALING_A[SPELL_LEVEL]
+
+#define SPELL_SHAMAN_REZZ         SPELL_SHAMAN_REZZ_A[SPELL_LEVEL]
+
+//Nukes
+#define SPELL_FLAME_SHOCK         SPELL_FLAME_SHOCK_A[SPELL_LEVEL]
+#define SPELL_LIGHTNING_BOLT      SPELL_LIGHTNING_BOLT_A[SPELL_LEVEL]
+#define SPELL_EARTH_SHOCK         SPELL_EARTH_SHOCK_A[SPELL_LEVEL]
+
+//BUFFS
+//#define SPELL_WINDFURY_WEAPON   10486 //rank 3
+#define SPELL_LIGHTNING_SHIELD    SPELL_LIGHTNING_SHIELD_A[SPELL_LEVEL]
+#define SPELL_STONESKIN_AURA      SPELL_STONESKIN_AURA_A[SPELL_LEVEL]
+#define SPELL_HEALINGSTREAM_AURA  SPELL_HEALINGSTREAM_AURA_A[SPELL_LEVEL]
+#define SPELL_MANASPRING_AURA     SPELL_MANASPRING_AURA_A[SPELL_LEVEL]
+
+//Totems
+#define SPELL_STONESKIN_TOTEM     SPELL_STONESKIN_TOTEM_A[SPELL_LEVEL]
+#define SPELL_HEALINGSTREAM_TOTEM SPELL_HEALINGSTREAM_TOTEM_A[SPELL_LEVEL]
+#define SPELL_MANASPRING_TOTEM    SPELL_MANASPRING_TOTEM_A[SPELL_LEVEL]
+#define SPELL_SEARING_TOTEM       SPELL_SEARING_TOTEM_A[SPELL_LEVEL]
+#define SPELL_WINDFURY_TOTEM      SPELL_WINDFURY_TOTEM_A[SPELL_LEVEL]
+
+uint32 SPELL_CHAIN_HEAL_A[] = { 0, 0, 0, 0, 1064, 10623, 25422, 25423, 55459, 42027 };
+uint32 SPELL_LESSER_HEALING_A[] = { 0, 0, 8004, 8010, 10466, 10467, 10468, 25420, 49275, 49309, 49309 };
+
+uint32 SPELL_LIGHTNING_BOLT_A[] = { 403, 548, 915, 6041, 10392, 15207, 25448, 45296, 71934, 71934 };
+uint32 SPELL_FLAME_SHOCK_A[] = { 0, 8050, 8052, 8053, 10447, 10448, 29228, 25457, 49232, 55613 };
+uint32 SPELL_EARTH_SHOCK_A[] = { 8042, 8045, 8046, 10412, 10413, 10414, 10414, 25454, 49230, 49230 };
+
+uint32 SPELL_LIGHTNING_SHIELD_A[] = {324, 325, 905, 945, 8134, 10431, 25469, 25472, 49280, 49280 };
+uint32 SPELL_SHAMAN_REZZ_A[] = {0, 2008, 20609, 20610, 20776, 20776, 20777, 25590, 49277, 49277 };
+
+uint32 SPELL_STONESKIN_AURA_A[] = { 8072, 8156, 8156, 10403, 10404, 10405, 25506, 58752, 58752, 58752 };
+uint32 SPELL_STONESKIN_TOTEM_A[] = { 8071, 8154, 8155, 10406, 10407, 10408, 25508, 25509, 25509, 25509 };
+
+uint32 SPELL_HEALINGSTREAM_AURA_A[] = { 0, 0, 5672, 6371, 6372, 10460, 10461, 25566, 58765, 58765 };
+uint32 SPELL_HEALINGSTREAM_TOTEM_A[] = { 0, 0, 5394, 6375, 6377, 10462, 10463, 25567, 58757, 58757 };
+
+uint32 SPELL_MANASPRING_AURA_A[] = { 0, 0, 5677, 10491, 10493, 10494, 25569, 25569, 58775, 58775 };
+uint32 SPELL_MANASPRING_TOTEM_A[] = { 0, 0, 5675, 10495, 10496, 10497, 25570, 25570, 58771, 58771 };
+
+uint32 SPELL_SEARING_TOTEM_A[] = { 0, 3599, 6363, 6364, 6365, 10437, 10438, 25533, 58699, 58699 };
+
+uint32 SPELL_WINDFURY_TOTEM_A[] = { 0, 0, 0, 0, 8512, 8512, 8512, 8512, 8512, 8512 };
diff --git a/src/server/scripts/Bots/bot_warlock_ai.cpp b/src/server/scripts/Bots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..31130a7
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warlock_ai.cpp
@@ -0,0 +1,403 @@
+#include "bot_warlock_ai.h"
+
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new warlock_botAI(pCreature);
+    }
+
+    struct warlock_botAI : public bot_ai
+    {
+        warlock_botAI(Creature *c) :bot_ai(c)
+        {
+            Reset();
+        }
+        uint8 Rain_of_fire_cd;
+        uint8 Haunt_cd;
+        uint8 conflagarate_cd;
+        uint8 chaos_bolt_cd;
+        uint8 fear_cd;
+        bool canPet;
+
+        void Reset()
+        {
+            GC_Timer = 0;
+            Potion_cd = 0;
+            Rain_of_fire_cd = 0;
+            Haunt_cd = 0;
+            conflagarate_cd = 0;
+            chaos_bolt_cd = 0;
+            fear_cd = 0;
+
+            temptimer = 0;
+            checkAurasTimer = 0;
+            wait = 15;
+            opponent = NULL;
+            pet = NULL;
+            canPet = false;
+
+            if (master)
+            {
+                setStats(CLASS_WARLOCK, m_creature->getRace(), master->getLevel(), true);
+                //TODO: passives
+                ApplyPassives(CLASS_WARLOCK);
+                SetBotCommandState(COMMAND_FOLLOW);
+            }
+        }
+
+        void CreatePet()
+        {
+            if (!canPet || pet != NULL) return;
+            pet = m_creature->GetBotsPet(60237);
+
+            if (pet == NULL)
+                return;
+
+            //pet->UpdateCharmAI();
+            pet->SetCharmerGUID(master->GetGUID());
+            //Minion* mypet = static_cast<Minion*>(pet);
+            master->SetMinion((Minion*)pet, true);
+            pet->AIM_Initialize();
+            pet->SetReactState(REACT_DEFENSIVE);
+            pet->GetMotionMaster()->MoveFollow(m_creature, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+            CharmInfo *petcharm = pet->InitCharmInfo();
+            pet->setFaction(master->getFaction());
+            pet->SetLevel(master->getLevel());
+
+
+            /*float val2 = master->getLevel()*4.0f + pet->GetStat(STAT_STRENGTH)*2.5f;
+
+            val2 += 100.0f;
+            uint8 attPowerMultiplier = 1;
+            pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+            
+            pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+            pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*2+master->getLevel());
+            pet->UpdateAttackPowerAndDamage();*/
+            //pet->UpdateDamagePhysical(BASE_ATTACK);
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false;
+            if (Feasting() && !master->isInCombat() && 
+                !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (m_creature->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != MANAPOTION && spellId != HEALINGPOTION) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                DoCast(victim, spellId, triggered);
+                m_creature->EnergizeBySpell(m_creature, spellId, urand(m_creature->GetMaxPower(POWER_MANA)/3,m_creature->GetMaxPower(POWER_MANA)), POWER_MANA);
+                return true;
+            }
+            m_creature->SetStandState(UNIT_STAND_STATE_STAND);
+            if (master->getLevel() >= 78)
+                GC_Timer = 8;
+            else if (master->getLevel() >= 70)
+                GC_Timer = 10;
+            else if (master->getLevel() >= 50)
+                GC_Timer = 12;
+            else if (master->getLevel() >= 35)
+                GC_Timer = 14;
+            else if (master->getLevel() >= 25)
+                GC_Timer = 16;
+            else if (master->getLevel() >= 15)
+                GC_Timer = 18;
+            else
+                GC_Timer = 20;
+
+            if (!victim->IsWithinLOSInMap(m_creature) && IsInBotParty(victim))
+                m_creature->Relocate(victim);
+
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void Aggro(Unit *who){}
+
+        void EnterEvadeMode()
+        {if (!master) return;
+            if (!me->isAlive()) return;
+            if (m_creature->IsInEvadeMode()) return;
+            if (!IsEvent())
+            {
+                if (!m_creature->getThreatManager().isThreatListEmpty())
+                    m_creature->DeleteThreatList();
+                if (m_creature->isInCombat())
+                {
+                    if (IsChanneling())
+                        m_creature->CombatStop(false);
+                    else
+                        m_creature->CombatStop(true);
+                }
+                Follow();
+            }
+            if (pet != NULL && pet->isAlive())
+            {
+                /*if (pet->GetCharmInfo()->GetCommandState() != COMMAND_STAY)
+                    pet->GetCharmInfo()->SetCommandState(COMMAND_STAY);
+                else */if (m_creature->GetDistance(pet) > 25 || m_creature->GetDistance(pet) < 0.2)
+                {
+                    pet->Relocate(m_creature->GetPositionX() + 5, m_creature->GetPositionY() + 5);
+                    pet->GetMotionMaster()->MoveFollow(m_creature, PET_FOLLOW_DIST * 2.5, PET_FOLLOW_ANGLE);
+                }
+            }
+        }
+
+        void JustDied(Unit *Killer)
+        { if (!master) return;if (pet != NULL) RemovePet(); Follow(); }
+
+        void AttackStart(Unit *u)
+        {if (!master) return;
+            if (u && !IsInBotParty(u) && u->isTargetableForAttack())
+            {
+                Aggro(u);
+                m_creature->AddThreat(u, 0.001f);
+                u->AddThreat(m_creature, 0.001f);
+                if (pet != NULL && pet->isAlive())
+                {
+                    pet->AddThreat(u, 0.001f);
+                    u->AddThreat(pet, 0.001f);
+                    //pet->GetCharmInfo()->SetCommandState(COMMAND_ATTACK);
+                }
+                opponent = u;
+            }
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+
+        void KilledUnit(Unit *)
+        {if (!master) return;
+            Unit *u = master->GetSelectedUnit();
+            if (!u || !u->isInCombat() || !u->IsHostileTo(master))
+            {
+                if (!IsEvent())
+                {
+                    if (!master->getVictim() && master->getAttackers().empty() && master->isInCombat())
+                        master->CombatStop();
+                    if (!master->isInCombat())
+                        m_creature->CombatStop();
+                }
+            }
+            SetBotCommandState(COMMAND_FOLLOW);
+            //ResetOrGetNextTarget();
+        }
+
+        void UpdateAI(const uint32 diff)
+        {if (!master) return;
+            ReduceCD();
+            if (IAmDead()) return;
+            //if pet is dead or no permission
+            if (pet != NULL && 
+                (pet->isDead() || 
+                m_creature->m_botHasPet == false || 
+                m_creature->GetDistance(pet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.0f || 
+                !m_creature->canSeeOrDetect(pet, true, true)))
+                RemovePet();
+            if (wait == 0)
+                wait = urand(1,3);
+            else
+                return;
+            if (checkAurasTimer <= 0)
+            {
+                CheckAuras();
+                if (!canPet && master->getLevel() >= 20)
+                    canPet = true;
+                else
+                    canPet = false;
+
+                if (pet == NULL && canPet) CreatePet();
+                checkAurasTimer = 30;
+            }
+            if (CCed()) return;
+
+            //TODO: implement healthstone
+            if (GetHealthPCT(m_creature) < 50 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, HEALINGPOTION))
+                    Potion_cd = 150;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(m_creature) < 50 && Potion_cd <= 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(m_creature, MANAPOTION))
+                    Potion_cd = MANA_CD;
+                GC_Timer = temptimer;
+           }
+
+            opponent = getTarget();
+            if (!opponent)
+                opponent = m_creature->getVictim();
+
+            if (!CheckTarget(opponent) || !opponent)
+            {
+                //to reduce the number of crashes, remove pet whenever we are not in combat
+                //if (pet != NULL && pet->isAlive()) RemovePet();
+                return;
+            }
+
+            if (CCed(opponent))
+                ChangeTarget(opponent, 20);
+
+            if (master->GetDistance(opponent) < 20)
+                ScriptedAI::AttackStartCaster(opponent, 16);
+            else if (!m_creature->HasUnitState(UNIT_STAT_CASTING) && m_creature->GetDistance(master) > 10)
+            {
+                m_creature->Relocate(master);
+                SetBotCommandState(COMMAND_FOLLOW);
+                return;
+            }
+
+            //if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return;
+            DoNormalAttack(diff);
+            ScriptedAI::UpdateAI(diff);
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {if (!master) return;
+            //double check that pet didn't just die
+            if (pet != NULL)
+            {
+                if (pet->isDead()) RemovePet();
+                else assistMaster(pet);
+            }
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack()) return;
+
+            //send in the pet
+            if (pet != NULL && pet->isAlive() && pet->getVictim() != opponent)
+            {
+                pet->Attack(opponent, true);
+                pet->GetMotionMaster()->MoveChase(opponent);
+            }
+
+            //TODO: add more damage spells, add pet relations n' handling
+
+            if (isTimerReady(fear_cd))
+            { CheckFear(); fear_cd = 20; }
+
+            if (RAIN_OF_FIRE && isTimerReady(Rain_of_fire_cd))
+            {
+                Unit *blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, RAIN_OF_FIRE))
+                    Rain_of_fire_cd = 50;
+            }
+
+            if (CURSE_OF_THE_ELEMENTS && GC_Timer <= 0 && !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS) && 
+                doCast(opponent, CURSE_OF_THE_ELEMENTS))
+                GC_Timer = 8;
+
+            if (GC_Timer <= 0 && !opponent->HasAura(CORRUPTION, m_creature->GetGUID()) && 
+                doCast(opponent, CORRUPTION)){}
+
+            if (HAUNT && isTimerReady(Haunt_cd) && !opponent->HasAura(HAUNT, m_creature->GetGUID()) && 
+                doCast(opponent, HAUNT))
+                Haunt_cd = 80;
+
+            if (GC_Timer <= 0 && !Afflicted(opponent))
+            {
+                if (conflagarate_cd <= 50)
+                    doCast(opponent, IMMOLATE);
+                else if (UNSTABLE_AFFLICTION)
+                    doCast(opponent, UNSTABLE_AFFLICTION);
+            }
+
+            if (CONFLAGRATE && isTimerReady(conflagarate_cd) && 
+                HasAuraName(opponent, IMMOLATE, m_creature->GetGUID()) && 
+                doCast(opponent, CONFLAGRATE))
+                conflagarate_cd = 100;
+
+            if (CHAOS_BOLT && isTimerReady(chaos_bolt_cd) && doCast(opponent, CHAOS_BOLT))
+            {
+                if (m_creature->getLevel() >= 78)
+                    chaos_bolt_cd = 80;
+                else if (m_creature->getLevel() >= 65)
+                    chaos_bolt_cd = 100;
+                else
+                    chaos_bolt_cd = 120;
+            }
+            else if (GC_Timer <= 0 && doCast(opponent, SHADOW_BOLT))
+            {}
+
+        } //DoNormalAttack
+
+        void DoNonCombatActions(){}
+
+        uint8 Afflicted(Unit *target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION, m_creature->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE, m_creature->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {if (!master) return;
+            if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return;
+            if (Unit *u = FindAffectedTarget(FEAR, m_creature->GetGUID()))
+                if (Aura *aura = u->GetAura(FEAR, m_creature->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = m_creature->getAttackers();
+            //first: check master's attackers
+            if (!m_attackers.empty())
+            {
+                for(AttackerSet::const_iterator itr = m_attackers.begin(); itr != m_attackers.end(); ++itr)
+                {
+                    if (!(*itr) || (*itr)->isDead() || !(*itr)->isTargetableForAttack()) continue;
+                    if (doCast((*itr), FEAR))
+                        return;
+                }
+            }
+            //second: check bot's attackers
+            if (!b_attackers.empty())
+            {
+                for(AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+                {
+                    if (!(*itr) || (*itr)->isDead() || !(*itr)->isTargetableForAttack()) continue;
+                    if (doCast((*itr), FEAR))
+                        return;
+                }
+            }
+            //last case: use checker to find fearable target
+            Unit *feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR)) {}
+        }
+
+        void RemovePet()
+        {if (!master) return;
+            if (pet != NULL && pet->IsInWorld())
+                m_creature->SetBotsPetDied();
+            pet = NULL;
+        }
+
+        void ReduceCD()
+        {if (!master) return;
+            if (Rain_of_fire_cd > 0)     --Rain_of_fire_cd;
+            if (Haunt_cd > 0)            --Haunt_cd;
+            if (conflagarate_cd > 0)     --conflagarate_cd;
+            if (chaos_bolt_cd > 0)       --chaos_bolt_cd;
+            if (fear_cd > 0)             --fear_cd;
+            if (Potion_cd > 0)           --Potion_cd;
+            if (GC_Timer > 0)            --GC_Timer;
+            if (temptimer > 0)           --temptimer;
+            if (checkAurasTimer > 0)     --checkAurasTimer;
+            if (wait > 0)                --wait;
+
+        }
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+}
diff --git a/src/server/scripts/Bots/bot_warlock_ai.h b/src/server/scripts/Bots/bot_warlock_ai.h
new file mode 100644
index 0000000..8d4e5d1
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warlock_ai.h
@@ -0,0 +1,36 @@
+#include "bot_ai.h"
+
+#define PET_VOIDWALKER 697
+
+//Curses
+#define CURSE_OF_THE_ELEMENTS SPELL_CURSE_OF_THE_ELEMENTS_A[SPELL_LEVEL]
+
+//DESTRUCTION
+#define SHADOW_BOLT         SPELL_SHADOW_BOLT_A[SPELL_LEVEL]
+#define IMMOLATE            SPELL_IMMOLATE_A[SPELL_LEVEL]
+#define CONFLAGRATE         SPELL_CONFLAGRATE_A[SPELL_LEVEL]
+#define CHAOS_BOLT          SPELL_CHAOS_BOLT_A[SPELL_LEVEL]
+#define RAIN_OF_FIRE        SPELL_RAIN_OF_FIRE_A[SPELL_LEVEL]
+
+//AFFLICTION
+#define HAUNT               SPELL_HAUNT_A[SPELL_LEVEL]
+#define CORRUPTION          SPELL_CORRUPTION_A[SPELL_LEVEL]
+#define UNSTABLE_AFFLICTION SPELL_UNSTABLE_AFFLICTION_A[SPELL_LEVEL]
+
+#define FEAR                6215
+
+//curses
+uint32 SPELL_CURSE_OF_THE_ELEMENTS_A[] = { 0, 0, 0, 1490, 11721, 11721, 11722, 11722/*27728*/, 47865, 47865 };
+
+//destruction spells
+uint32 SPELL_SHADOW_BOLT_A[] = { 686, 705, 1088, 7641, 11659, 11660, 25307, 47808, 47809, 57374 };
+uint32 SPELL_IMMOLATE_A[] = { 348, 707, 1094, 2941, 11665, 11667, 25309, 47810, 47811, 37668 };
+uint32 SPELL_CONFLAGRATE_A[] = { 0, 0, 0, 0, 17962, 17962, 17962, 17962, 17962, 17962 };
+uint32 SPELL_CHAOS_BOLT_A[] = { 0, 0, 0, 0, 0, 50796, 50796, 59171, 59172, 69576 };
+uint32 SPELL_RAIN_OF_FIRE_A[] = { 0, 0, 5740, 6219, 11677, 11678, 11678, 27212, 27212, 43440 };
+
+//affliction spells
+uint32 SPELL_HAUNT_A[] = { 0, 0, 0, 0, 0, 0, 59164, 59164, 59164, 59164 };
+uint32 SPELL_CORRUPTION_A[] = { 172, 6222, 7648, 11671, 11672, 25311, 47812, 47835, 47836, 47836 };
+uint32 SPELL_UNSTABLE_AFFLICTION_A[] = { 0, 0, 0, 0, 0, 30404, 30405, 47843, 47843, 65812 };
+
diff --git a/src/server/scripts/Bots/bot_warrior_ai.cpp b/src/server/scripts/Bots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..e500bf5
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warrior_ai.cpp
@@ -0,0 +1,1131 @@
+#include "bot_warrior_ai.h"
+bool battleStance; bool defensiveStance; bool berserkerStance;
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 50-55%
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new warrior_botAI(pCreature);
+    }
+
+    struct warrior_botAI : public bot_ai
+    {
+        warrior_botAI(Creature *c) : bot_ai(c)
+        {
+            Reset();
+        }
+        uint32 slam_cd;
+        uint32 regen_cd;
+        uint32 sweeping_strikes_cd;
+        uint32 charge_cd;
+        uint32 deathwish_cd;
+        uint32 mortalStrike_cd;
+        uint32 overpower_cd;
+        uint32 uber_cd;
+        uint32 berserkerRage_cd;
+        //uint32 challengingShout_cd;
+        uint32 battleShout_cd;
+        uint32 intercept_cd;
+        uint32 intimidatingShout_cd;
+        uint32 pummel_cd;
+        uint32 whirlwind_cd;
+        uint32 cleave_cd;
+        uint32 bloodrage_cd;
+        //uint32 disarm_cd;
+        //uint32 intervene_cd;
+        //uint32 shieldBash_cd;
+        //uint32 spellReflection_cd;
+        uint32 potion_cd;
+        //uint32 firstAid_cd;
+        uint32 pvpTrinket_cd;
+        uint32 taunt_cd;
+        uint32 sunder_cd;
+        uint32 rage;
+        float rageIncomeMult;
+        float rageLossMult;
+        uint32 GCD;
+        uint32 temptimer;
+        uint32 stancetimer;
+        uint32 ragetimer;
+        uint32 ragetimer2;
+
+        bool SChange;
+
+        void Reset()
+        {
+            //vCount = 0;
+            slam_cd = 0;
+            regen_cd = 20000;
+            sweeping_strikes_cd = 0;
+            charge_cd = 0;
+            deathwish_cd = 0;
+            mortalStrike_cd = 0;
+            overpower_cd = 0;
+            uber_cd = 0;
+            berserkerRage_cd = 0;
+            //challengingShout_cd = 0;
+            battleShout_cd = 0;
+            intercept_cd = 0;
+            intimidatingShout_cd = 0;
+            pummel_cd = 0;
+            whirlwind_cd = 10000;
+            cleave_cd = 0;
+            bloodrage_cd = 0;
+            //disarm_cd = 0;
+            //intervene_cd = 0;
+            //shieldBash_cd = 0;
+            //spellReflection_cd = 0;
+            potion_cd = 0;
+            //firstAid_cd = 0;
+            pvpTrinket_cd = 0;
+            taunt_cd = 0;
+            sunder_cd = 0;
+            //yellRage = 0;
+            GCD = 0;
+            temptimer = 0;
+            checkAurasTimer = 0;
+            stancetimer = 0;
+            wait = 15;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            SChange = true;
+
+            opponent = NULL;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            m_creature->setPowerType(POWER_RAGE);
+            m_creature->SetPower(POWER_RAGE, 0);
+            rage = 0;
+            
+            if (master) 
+            {
+                setStats(CLASS_WARRIOR, m_creature->getRace(), master->getLevel(), true);
+
+                if (master->getLevel() >= 75)
+                    RefreshAura(PRECISION);//+20% hit
+                //aura
+                if (master->getLevel() >= 78)
+                    RefreshAura(FRENZY_AURA); //+20% speed + 20% dam
+                //Parry
+                if (master->getLevel() >= 70)
+                    RefreshAura(DEFLECTION,5); //+25%
+                else if (master->getLevel() >= 55)
+                    RefreshAura(DEFLECTION,4); //+20%
+                else if (master->getLevel() >= 40)
+                    RefreshAura(DEFLECTION,3); //+15%
+                else if (master->getLevel() >= 25)
+                    RefreshAura(DEFLECTION,2); //+10%
+                else if (master->getLevel() >= 10)
+                    RefreshAura(DEFLECTION); //+5%
+                //Crit
+                if (master->getLevel() >= 60)
+                    RefreshAura(RAMPAGE);
+
+                if (master->getLevel() >= 70)
+                    RefreshAura(DEMONIC_CRIT,3); //+30% crit
+                else if (master->getLevel() >= 40)
+                    RefreshAura(DEMONIC_CRIT,2); //+20% crit
+                else if (master->getLevel() >= 10)
+                    RefreshAura(DEMONIC_CRIT); //+10% crit
+                //Enrage
+                if (master->getLevel() >= 70)
+                    RefreshAura(WC5); //10%
+                else if (master->getLevel() >= 68)
+                    RefreshAura(WC4); //8%
+                else if (master->getLevel() >= 66)
+                    RefreshAura(WC3); //6%
+                else if (master->getLevel() >= 64)
+                    RefreshAura(WC2); //4%
+                else if (master->getLevel() >= 62)
+                    RefreshAura(WC1); //2%
+                
+                if (master->getLevel() >= 70)
+                    RefreshAura(SWORD_SPEC,2);//twice
+                else if (master->getLevel() >= 30)
+                    RefreshAura(SWORD_SPEC);//once
+
+                if (master->getLevel() >= 55)
+                    RefreshAura(TRAUMA2);//30%
+                else if (master->getLevel() >= 35)
+                    RefreshAura(TRAUMA1);//15%
+
+                if (master->getLevel() >= 50)
+                    RefreshAura(UNRELENTING_ASSAULT);
+
+                if (master->getLevel() >= 45)
+                    RefreshAura(BLOOD_FRENZY);
+
+                if (master->getLevel() >= 40)
+                    RefreshAura(SECOND_WIND);
+
+                if (master->getLevel() >= 40)
+                    RefreshAura(TOUGHNESS,2);//-60%
+                else if (master->getLevel() >= 15)
+                    RefreshAura(TOUGHNESS);//-30%
+
+                if (master->getLevel() >= 25)
+                    RefreshAura(FLURRY);
+
+                if (master->getLevel() >= 20)
+                    RefreshAura(BLOOD_CRAZE);
+                //misc
+                ApplyPassives(CLASS_WARRIOR);
+                SetBotCommandState(COMMAND_FOLLOW);
+                //mob generates abnormal amounts rage so increase/reduce rate with level(from 188% down to 30% at level 80)//not seems to work
+                for(int i = 0; i < 3; ++i)
+                    m_creature->ApplyEffectModifiers(sSpellMgr->GetSpellInfo(29623), i, 90 - master->getLevel()*2);
+            }
+        }
+
+        void EnterEvadeMode()
+        {
+            if (!master) return;
+            if (!me->isAlive())
+                return;
+            if (m_creature->IsInEvadeMode())
+                return;
+            if (!IsEvent())
+            {
+                if (!m_creature->getThreatManager().isThreatListEmpty())
+                    m_creature->DeleteThreatList();
+                if (m_creature->isInCombat())
+                    m_creature->CombatStop();
+                Follow();
+            }
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId < 1) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            //if (m_creature->HasUnitState(UNIT_STAT_CASTING)) return false; //slam cast
+            if (m_creature->HasAura(67541)) return false;//SlapStorm
+            //if (m_creature->HasAuraType(SPELL_AURA_ALLOW_ONLY_ABILITY)) return false; //SlapStorm
+
+            if (master->getLevel() >= 78)
+                GCD = 1300;
+            else if (master->getLevel() >= 70)
+                GCD = 1400;
+            else if (master->getLevel() >= 50)
+                GCD = 1500;
+            else if (master->getLevel() >= 35)
+                GCD = 1600;
+            else if (master->getLevel() >= 25)
+                GCD = 1700;
+            else if (master->getLevel() >= 15)
+                GCD = 1800;
+            else
+                GCD = 2000;
+            //GCD = 1100;
+
+            if (!victim->IsWithinLOSInMap(m_creature) && IsInBotParty(victim))
+                m_creature->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            return true;
+        } //end doCast
+
+        bool isTimerReady(uint16 timer, uint32 diff)
+        {return (timer <= 0 && GCD < diff);}
+
+        void UpdateAI(const uint32 diff)
+        {
+            if (!master) return;
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (checkAurasTimer <= 0)
+            {
+                CheckAuras();
+                checkAurasTimer = 30;
+
+                if (m_creature->HasAura(12328))//SS
+                    SChange = false;
+                else 
+                    SChange = true;
+            }
+
+            rage = m_creature->GetPower(POWER_RAGE);
+            if (ragetimer2 < diff)
+            {
+                if (m_creature->isInCombat() && m_creature->getLevel() >= 20)
+                {
+                    if (rage < 990 && rage >= 0)
+                        m_creature->SetPower(POWER_RAGE, rage + uint32(20.0f*rageIncomeMult));//1 rage per 2 sec
+                    else
+                        m_creature->SetPower(POWER_RAGE, 1000);//max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer < diff)
+            {
+                if (!m_creature->isInCombat() && !m_creature->HasAura(BLOODRAGE))
+                {
+                    if (rage > 10.0f*rageLossMult)
+                        m_creature->SetPower(POWER_RAGE, rage - uint32(10.0f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        m_creature->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 1500;
+
+                if (rage > 1000) m_creature->SetPower(POWER_RAGE, 1000);
+                if (rage < 10) m_creature->SetPower(POWER_RAGE, 0);
+            }
+
+            if (wait == 0)
+                wait = urand(1,3);
+            else
+                return;
+            BreakCC(diff);
+            if (CCed()) return;
+
+            Unit *u = m_creature->getVictim();
+            if (!u || !u->isTargetableForAttack())
+                opponent = getTarget();
+            else
+                opponent = u;
+
+            if (!CheckTarget(opponent))
+                return;
+
+            if (CCed(opponent))
+                ChangeTarget(opponent, 20);
+
+            if (GetHealthPCT(m_creature) < 67 && potion_cd < diff)
+            {
+                temptimer = GCD;
+                if (doCast(m_creature, HEALINGPOTION))
+                    potion_cd = 20000;
+                GCD = temptimer;
+            }
+
+            if (!HasAuraName(master, BATTLESHOUT, m_creature->GetGUID()) && 
+                rage > 100 && GCD < diff         && 
+                battleShout_cd < diff            && 
+                (m_creature->isInCombat() || master->isInCombat()))
+            {
+                if (doCast(m_creature, BATTLESHOUT, true))
+                {
+                    //m_creature->AddAura(BATTLESHOUT, m_creature);
+                    m_creature->SetPower(POWER_RAGE, rage -100);
+                    battleShout_cd = BATTLESHOUT_CD;
+                }
+            }
+
+            if (bloodrage_cd < diff       && 
+                m_creature->isInCombat() && 
+                opponent                 && 
+                rage < 500                && 
+                !m_creature->HasAura(ENRAGED_REGENERATION))
+            {
+                temptimer = GCD;
+                if (doCast(m_creature, BLOODRAGE))
+                {
+                    bloodrage_cd = BLOODRAGE_CD;
+                    m_creature->SetPower(POWER_RAGE, rage +100);
+                }
+                GCD = temptimer;
+            }
+/*
+            if (!m_creature->SelectVictim() || !m_creature->getVictim())
+            {
+                if (m_creature->getAttackers().empty())
+                    m_creature->CombatStop(true);
+                ResetOrGetNextTarget();
+                return;
+            }
+*/
+            //BreakCC(diff);
+
+            if (battleStance != true && master->getAttackers().empty() && SChange == true)
+                stanceChange(diff, 1);
+            Attack(diff);
+            ScriptedAI::UpdateAI(diff);
+        }
+
+        void AttackStart(Unit *u)
+        {if (!master) return; if (!u->isTargetableForAttack()) return; Aggro(u); m_creature->AddThreat(u, 0.001f); opponent = u; UnitAI::AttackStart(u); m_creature->SetBotCommandState(COMMAND_ATTACK); }
+
+        void Aggro(Unit *who)
+        {
+            if (!master) return;
+            //Unit *opponent = SelectUnit(SELECT_TARGET_TOPAGGRO, 0);
+            opponent = who;
+
+            if (!opponent) return;
+
+            if ((m_creature->getLevel() >= 45 || !m_creature->isInCombat()) && 
+                m_creature->GetDistance(opponent) > 8 && 
+                m_creature->GetDistance(opponent) < 25 && 
+                battleStance == true && 
+                !CCed(opponent) && 
+                 charge_cd <= 0)
+            {
+                temptimer = GCD;
+                if (doCast(opponent, CHARGE, true))
+                {
+                    charge_cd = CHARGE_CD;
+                    //m_creature->SetPower(POWER_RAGE, rage +100);
+                }
+                GCD = temptimer;
+            }
+        } //end Aggro
+
+        void KilledUnit(Unit *Victim)
+        {
+            if (!master) return;
+            if (!m_creature->getVictim())
+            {
+                if (!IsEvent())
+                {
+                    if (!master->getVictim() && master->getAttackers().empty() && master->isInCombat())
+                        master->CombatStop();
+                    if (!master->isInCombat())
+                        m_creature->CombatStop();
+                }
+            }
+            //master->SetBotCommandState(COMMAND_FOLLOW);
+            //ResetOrGetNextTarget();
+        }
+
+        void JustDied(Unit *Killer)
+        {if (!master) return;Follow();}
+
+        void BreakCC(const uint32 diff)
+        {if (!master) return;
+            if (m_creature->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (m_creature->getLevel() >= 20 && !m_creature->HasAura(ENRAGED_REGENERATION) && 
+                    berserkerRage_cd < diff && GCD < diff && doCast(m_creature, BERSERKERRAGE))
+                {
+                    berserkerRage_cd = BERSERKERRAGE_CD;
+                    if (m_creature->getLevel() >= 40)
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage + 200);
+                        rage += 200;
+                    }
+                }
+                else if (pvpTrinket_cd < diff)
+                {
+                    temptimer = GCD;
+                    if (doCast(m_creature, PVPTRINKET))
+                        pvpTrinket_cd = PVPTRINKET_CD;
+                    GCD = temptimer;
+                }
+            }
+            if (pvpTrinket_cd < diff && (CCed(m_creature) || HasAuraName(m_creature, "Sleep")))
+            {
+                temptimer = GCD;
+                if (doCast(m_creature, PVPTRINKET))
+                    pvpTrinket_cd = PVPTRINKET_CD;
+                GCD = temptimer;
+            }
+        } //BreakCC
+
+        void Attack(const uint32 diff)
+        {if (!master) return;
+            assistMaster();
+            if (!opponent || opponent->isDead() || !opponent->isTargetableForAttack()) return;
+
+            if (m_creature->getVictim() != opponent)
+                AttackStart(opponent);
+
+            //SelfHeal
+            if (master->getLevel() >= 70)
+            {
+                if (GetHealthPCT(m_creature) < 40 && 
+                    (HasAuraName(m_creature, "Enrage") || 
+                    HasAuraName(m_creature, BLOODRAGE) || 
+                    HasAuraName(m_creature, DEATHWISH) || 
+                    HasAuraName(m_creature, BERSERKERRAGE) || 
+                    m_creature->HasAuraWithMechanic(MECHANIC_ENRAGED)) && 
+                    rage > 150 && 
+                    regen_cd < diff)//no GCD
+                {
+                    temptimer = 0;
+                    if (doCast(m_creature, ENRAGED_REGENERATION, true))
+                    {
+                        regen_cd = ENRAGED_REGENERATION_CD;
+                        m_creature->SetPower(POWER_RAGE, rage -150);
+                    }
+                    GCD = temptimer;
+                }
+                //maybe not needed part
+                if (m_creature->HasAura(ENRAGED_REGENERATION))
+                {
+                    if (HasAuraName(m_creature, "Enrage"))
+                        m_creature->RemoveAurasWithMechanic(MECHANIC_ENRAGED);
+                    if (HasAuraName(m_creature, BLOODRAGE))
+                        m_creature->RemoveAurasDueToSpell(BLOODRAGE);
+                    if (HasAuraName(m_creature, DEATHWISH))
+                        m_creature->RemoveAurasDueToSpell(DEATHWISH);
+                    if (HasAuraName(m_creature, BERSERKERRAGE))
+                        m_creature->RemoveAurasDueToSpell(BERSERKERRAGE);
+                }
+            }
+            //end SelfHeal
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = m_creature->getAttackers();
+
+            if (m_creature->GetDistance(opponent) > 13 && 
+                m_creature->GetDistance(opponent) < 25 && 
+                !CCed(opponent)                        &&
+                intercept_cd < diff                    && 
+                rage > 100)
+            {
+                if (m_creature->getLevel() >= 30 && berserkerStance == true)
+                {
+                    int damage = 0;
+                    if (m_creature->getLevel() >= 78)
+                        damage = m_creature->getLevel()*8;
+                    else if (m_creature->getLevel() >= 70)
+                        damage = m_creature->getLevel()*6;
+                    else if (m_creature->getLevel() >= 60)
+                        damage = m_creature->getLevel()*5;
+                    else if (m_creature->getLevel() >= 40)
+                        damage = m_creature->getLevel()*4;
+                    else
+                        damage = m_creature->getLevel()*3;
+                    m_creature->CastCustomSpell(opponent, INTERCEPT, &damage, NULL, NULL, true, NULL, NULL);
+                    //doCast(opponent, INTERCEPT, true);
+                    intercept_cd = INTERCEPT_CD;
+                    m_creature->SetPower(POWER_RAGE, rage -100);
+                    rage -= 100;
+                }
+                else if (charge_cd <= CHARGE_CD/2 && (!m_creature->isInCombat() || m_creature->getLevel() >= 45))
+                {
+                    temptimer = GCD;
+                    if (doCast(opponent, CHARGE, true))
+                    {
+                        charge_cd = CHARGE_CD;
+                        //m_creature->SetPower(POWER_RAGE, rage +150);
+                    }
+                    GCD = temptimer;
+                }
+                else if (SChange == true && stancetimer < diff)
+                {
+                    stanceChange(diff, 3);
+                    return;
+                }
+            }
+
+            //FEAR
+            if (master->getLevel() >= 20 && rage > 150 && intimidatingShout_cd < diff && GCD < diff)
+            {
+                uint8 tCount = 0;
+                Unit *fearTarget = NULL;
+                bool triggered = false;
+                //fear master's attackers
+                if (!m_attackers.empty() && 
+                    ((master->getClass() != CLASS_DEATH_KNIGHT && 
+                    master->getClass() != CLASS_WARRIOR && 
+                    master->getClass() != CLASS_PALADIN) || 
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (m_creature->GetDistance((*iter)) > 8) continue;
+                        if (CCed(*iter) && m_creature->GetDistance((*iter)) > 5) continue;
+                        if (m_creature->GetDistance((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                        fearTarget = opponent;
+                    if (fearTarget == opponent)
+                        triggered = true;
+                    if (tCount > 1 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        m_creature->SetPower(POWER_RAGE, rage -150);
+                        rage -= 150;
+                        return;
+                    }
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (m_creature->GetDistance((*iter)) > 8) continue;
+                        if (CCed(*iter) && m_creature->GetDistance((*iter)) > 5) continue;
+                        if (m_creature->GetDistance((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                        fearTarget = opponent;
+                    if (fearTarget == opponent)
+                        triggered = true;
+                    if (tCount > 0 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        m_creature->SetPower(POWER_RAGE, rage -150);
+                        rage -= 150;
+                        return;
+                    }
+                }
+            }//end FEAR
+
+            if (//UNRELENTING_ASSAULT && 
+                opponent->HasUnitState(UNIT_STAT_CASTING) && 
+                overpower_cd < diff    && 
+                rage > 50            && 
+                GCD < diff)
+            {
+                if (battleStance == true)
+                {
+                    if (doCast(opponent, OVERPOWER, true))
+                    {
+                        if (UNRELENTING_ASSAULT == 46860)//rank 2
+                            overpower_cd = 1000;
+                        else if (UNRELENTING_ASSAULT == 46859)//rank 1
+                            overpower_cd = 3000;
+                        else
+                            overpower_cd = 5000;
+                        m_creature->SetPower(POWER_RAGE, rage -50);
+                        rage -= 50;
+                    }
+                    //GCD = 800;
+                } 
+                else if (SChange == true && stancetimer < diff) 
+                {
+                    stanceChange(diff, 1);
+                    return;
+                }
+            }
+            Unit *u = opponent->getVictim();
+            if (!HasAuraName(opponent, HAMSTRING) && 
+                (u != m_creature || opponent->HasUnitState(UNIT_STAT_FLEEING)) && 
+                !CCed(opponent, true) && 
+                rage > 100        && 
+                GCD < diff && m_creature->GetDistance(opponent) < 8)
+            {
+                if (battleStance == true || berserkerStance == true)
+                {
+                    if (doCast(opponent, HAMSTRING, true))
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage -100);
+                        rage -= 100;
+                        //imp hamstring 33%
+                        if (opponent->HasAura(HAMSTRING, m_creature->GetGUID()) && m_creature->getLevel() >= 40)
+                        {
+                            switch(urand(1,3))
+                            {
+                            case 1: break;
+                            case 2: break;
+                            case 3:
+                                doCast(opponent, 23694, true);
+                            }
+                        }
+                    }
+                } 
+                else if (SChange == true && stancetimer < diff)
+                {
+                    stanceChange(diff, 5);
+                    return;
+                }
+            }
+            //UBERS
+            //Dont use RETA unless capable circumstances
+            if (master->getLevel() >= 35)//mod here
+            {
+                if (b_attackers.size() > 4 &&
+                    uber_cd < diff &&
+                    GCD < diff)
+                {
+                    if (doCast(m_creature, RETALIATION))
+                        uber_cd = UBER_CD;
+                }
+                //Dont use RECKL unless capable circumstances
+                if ((m_attackers.size() > 3 || opponent->GetHealth() > m_creature->GetHealth()*10) && 
+                    uber_cd < diff && 
+                    GCD < diff)
+                {
+                    if (doCast(m_creature, RECKLESSNESS))
+                        uber_cd = UBER_CD;
+                }
+            }//end UBERS(level 35+)
+            //DEATHWISH
+            if (master->getLevel() >= 25)//mod here
+            {
+                if ((GetHealthPCT(opponent) > 15 || b_attackers.size() > 1 || m_attackers.size() > 1) && 
+                    !m_creature->HasAura(ENRAGED_REGENERATION) && 
+                    deathwish_cd < diff && 
+                    GCD < diff && 
+                    rage > 100)
+                {
+                    if (m_creature->getLevel() < 75)
+                    {
+                        if (opponent->GetHealth() > m_creature->GetHealth()/3 || 
+                            b_attackers.size() + m_attackers.size() > 2)
+                        {
+                            if (doCast(m_creature, DEATHWISH))
+                            {
+                                m_creature->SetPower(POWER_RAGE, rage -100);
+                                deathwish_cd = DEATHWISH_CD;
+                            }
+                        }
+                    }
+                    else
+                    {
+                        if (doCast(m_creature, DEATHWISH))
+                        {
+                            m_creature->SetPower(POWER_RAGE, rage -100);
+                            rage -= 100;
+                            deathwish_cd = DEATHWISH_CD;
+                        }
+                    }
+                }
+            }
+
+            //opponent is not attacking me so try to taunt it
+            u = opponent->getVictim();
+            if (m_creature->getLevel() >= 10 && u && 
+                u != m_creature && 
+                ((u->getClass() != CLASS_WARRIOR && 
+                u->getClass() != CLASS_PALADIN && 
+                u->getClass() != CLASS_DEATH_KNIGHT && 
+                IsInBotParty(u)) || tank == m_creature) && 
+                !CCed(opponent) && 
+                taunt_cd < diff)//No GCD
+            {
+                temptimer = GCD;
+                if (defensiveStance != true && SChange == true)
+                {
+                    if (doCast(m_creature, DEFENSIVESTANCE, true))
+                    {
+                        defensiveStance = true;
+                        if (doCast(opponent, TAUNT, true))
+                            taunt_cd = TAUNT_CD;
+                    }
+                }
+                //if (doCast(opponent, TAUNT, true))
+                //    taunt_cd = TAUNT_CD;
+                GCD = temptimer;
+            }
+
+            if (SUNDER && opponent->GetMaxHealth() > m_creature->GetMaxHealth()/2*3 && 
+                (sunder_cd < diff || rage > 700) && 
+                GCD < diff && rage > 150)
+            {
+                if (SUNDER == 7386 && doCast(opponent, SUNDER))
+                {
+                    m_creature->SetPower(POWER_RAGE, rage -150);
+                    rage -= 150;
+                    sunder_cd = SUNDER_CD;
+                }
+                else
+                {
+                    if (opponent->HasAura(SUNDER))
+                    {
+                        Aura *sunder = opponent->GetAura(SUNDER);
+                        uint8 stacks = sunder->GetStackAmount();
+                        if ((sunder->GetDuration() < 12000 || (stacks < 5 && rage > 700)) && doCast(opponent, 44079))//Cosmetic - Combat Special Attack 1H
+                        {
+                            if (stacks < 5)
+                            {
+                                sunder->SetStackAmount(stacks + 1);
+                                sunder->SetDuration(sunder->GetMaxDuration());
+                            }
+                            else
+                                sunder->SetDuration(sunder->GetMaxDuration());
+                            m_creature->SetPower(POWER_RAGE, rage -150);
+                            rage -= 150;
+                            sunder_cd = SUNDER_CD;
+                        }
+                    }
+                    else if (doCast(opponent, SUNDER))
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage -150);
+                        rage -= 150;
+                        sunder_cd = SUNDER_CD;
+                    }
+                }
+            }
+
+            //SS
+            if ((m_attackers.size() > 1 || b_attackers.size() > 1 || FindSplashTarget(10)) && 
+                sweeping_strikes_cd < diff)//noGCD for SS
+            {
+                temptimer = GCD;
+                if (doCast(m_creature, SWEEPING_STRIKES, true))
+                    sweeping_strikes_cd = SWEEPING_STRIKES_CD;
+                GCD = temptimer;
+            }
+            //WhirlWIND
+            if (WHIRLWIND && whirlwind_cd < diff && 
+               rage > 250 && 
+               GCD < diff && 
+               (FindSplashTarget(8) || rage > 750))
+            {
+                if (WHIRLWIND == 1680)//Warrior WhirlWind
+                {
+                    if (berserkerStance == true && m_creature->GetDistance(opponent) < 9)
+                    {
+                        if (doCast(opponent, WHIRLWIND, true))
+                        {
+                            m_creature->SetPower(POWER_RAGE, rage -250);
+                            rage -= 250;
+                            whirlwind_cd = WHIRLWIND_CD;
+                        }
+                    } 
+                    else if (SChange == true && stancetimer < diff)
+                    {
+                        stanceChange(diff, 3);
+                        return;
+                    }
+                }
+                else //BladeStorm
+                if (u = m_creature->SelectNearestTarget(8))
+                {
+                    if (u && m_creature->GetDistance(u) < 13 && doCast(opponent, WHIRLWIND, true))
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage -250);
+                        rage -= 250;
+                        whirlwind_cd = 45000;
+                    }
+                }
+            }
+            //end WhirlWIND
+
+            if (MORTALSTRIKE != 0 && 
+                mortalStrike_cd < diff && 
+                rage > 300              && 
+                GCD < diff)
+            {
+                if (doCast(opponent, MORTALSTRIKE, true))
+                {
+                    mortalStrike_cd = MORTALSTRIKE_CD;
+                    m_creature->SetPower(POWER_RAGE, rage -300);
+                    rage -= 300;
+                    slam_cd = 0;//reset here
+                }
+            }
+            //slam
+            if (SLAM != 0 && 
+                slam_cd < diff && 
+                rage > 150)
+            {
+                if (doCast(opponent, SLAM, true))
+                {
+                    slam_cd = 4500;//4.5sec (must be > MORTALSTRIKE_CD/2)
+                    m_creature->SetPower(POWER_RAGE, rage -150);
+                    rage -= 150;
+                }
+            }
+
+            if (opponent->HasUnitState(UNIT_STAT_CASTING) && 
+                pummel_cd < diff && 
+                rage > 100)
+            {
+                if (berserkerStance == true)
+                {
+                    temptimer = GCD;
+                    if (doCast(opponent, PUMMEL, true))
+                    {
+                        pummel_cd = PUMMEL_CD;
+                        m_creature->SetPower(POWER_RAGE, rage -100);
+                        rage -= 100;
+                    }
+                    GCD = temptimer;
+                } 
+                else
+                {
+                    stanceChange(diff, 3);
+                    return;
+                }
+            }
+            
+            if (!opponent->HasAura(REND, m_creature->GetGUID()) && 
+                GetHealthPCT(opponent) > 20 && 
+                rage > 100                  && 
+                GCD < diff)
+            {
+                if (battleStance == true || defensiveStance == true)
+                {
+                    if (doCast(opponent, REND, true))
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage -100);
+                        rage -= 100;
+                    }
+                } 
+                else if (SChange == true && stancetimer < diff)
+                {
+                    stanceChange(diff, 1);
+                    return;
+                }
+            }
+
+            
+            /*if (master->getLevel() >= 20)
+            {
+                //fear ones who attacks master
+                if ((m_attackers.size() > 1 || GetHealthPCT(master) < 70))
+                {
+                    u = master->getVictim();
+                    if (intimidatingShout_cd < diff && GCD < diff && u && 
+                        m_creature->GetDistance(u) < 8)
+                    {
+                        if (doCast(u, INTIMIDATING_SHOUT))
+                        {
+                            intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                            m_creature->SetPower(POWER_RAGE, rage -150);
+                        }
+                    }
+                }
+                else
+                {
+                    if (u = m_creature->getVictim())
+                    {
+                        if (u && intimidatingShout_cd < diff && GCD < diff && u && 
+                            m_creature->GetDistance(u) < 8)
+                        {
+                            if (doCast(u, INTIMIDATING_SHOUT))
+                            {
+                                intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                                m_creature->SetPower(POWER_RAGE, rage -150);
+                            }
+                        }
+                        else if (charge_cd <= CHARGE_CD/3 && u && 
+                            m_creature->GetDistance(u) < 25 && 
+                            !CCed(u))
+                        {
+                            temptimer = GCD;
+                            if (doCast(u, CHARGE, true))
+                            {
+                                charge_cd = CHARGE_CD;
+                                //m_creature->SetPower(POWER_RAGE, rage +100);
+                            }
+                            GCD = temptimer;
+                            Unit *u2 = master->getVictim();
+                            if (u2)
+                                opponent = u2;
+                            return;
+                        }
+                    }
+                }
+            }//end FEAR*/
+
+            //Cleave
+            if (cleave_cd < diff && m_creature->getLevel() >= 20 && rage > 200 && FindSplashTarget(6))//noGCD
+            {
+                temptimer = GCD;
+                if (doCast(opponent, CLEAVE))
+                {
+                    m_creature->SetPower(POWER_RAGE, rage -200);
+                    rage -= 200;
+                    cleave_cd = m_creature->getAttackTimer(BASE_ATTACK);
+                }
+                GCD = temptimer;
+            }
+            //Execute
+            if (EXECUTE && 
+                GCD < diff && 
+                rage > 150 && 
+                GetHealthPCT(opponent) < 20 && 
+                m_creature->GetDistance(opponent) < 7)
+            {
+                if (battleStance == true || berserkerStance == true)
+                {
+                    if (EXECUTE == 38959)
+                    {
+                        uint32 dam = rage;
+                        if (dam > 300)
+                            dam = 300;
+                        int damage = int(dam);
+                        m_creature->CastCustomSpell(opponent, EXECUTE, &damage, NULL, NULL, true, NULL, NULL);
+                        GCD = 1500;
+                    }
+                    else if (doCast(opponent, EXECUTE, true)) {}
+                    if (m_creature->getLevel() >= 50 && rage <= 400)
+                    {
+                        m_creature->SetPower(POWER_RAGE, 100);
+                        rage = 100;
+                    }
+                    else if (rage > 300)
+                    {
+                        m_creature->SetPower(POWER_RAGE, rage - 300);
+                        rage -= 300;
+                    }
+                    else
+                    {
+                        m_creature->SetPower(POWER_RAGE, 0);
+                        rage = 0;
+                    }
+                }
+                else if (SChange == true && stancetimer < diff)
+                {
+                    stanceChange(diff, 5);
+                    return;
+                }
+            }//end Execute
+            //DISARM DEPRECATED
+            /*if (disarm_cd < diff    && m_creature->GetDistance(opponent) < 8 &&
+                (opponent->getVictim()->GetGUID() == master->GetGUID()        || 
+                opponent->getVictim()->GetGUID() == m_creature->GetGUID())  &&
+                rage > 15                                                    &&
+                !HasAuraName(opponent, GetSpellName(DISARM))                &&
+                GCD < diff)
+            {
+                if (opponent->getClass() == CLASS_ROGUE  ||
+                    opponent->getClass() == CLASS_WARRIOR   ||
+                    opponent->getClass() == CLASS_SHAMAN    ||
+                    opponent->getClass() == CLASS_PALADIN)
+                {
+                    if (defensiveStance == true)
+                    {
+                        doCast(opponent, DISARM, true);
+                        rage -= 10;
+                        disarm_cd = DISARM_CD;
+                    } else stanceChange(diff, 2);
+                }
+            }*/
+        }//end Attack
+
+        void stanceChange(const uint32 diff, uint8 stance)
+        {if (!master) return;
+            if (!(stancetimer < diff) || stance == 0) return;
+
+            if (stance == 5)
+            {
+                switch(rand()%2)
+                {
+                case 0: stance = 1; break;
+                case 1: stance = 3; break;
+                }
+            }
+            if (stance == 2 && m_creature->getLevel() < 10) return;
+            if (stance == 3 && m_creature->getLevel() < 30) return;
+
+            temptimer = GCD;
+            uint32 temprage = rage > 100 ? 100 : rage;
+            switch(stance)
+            {
+            case 1:
+                if (doCast(m_creature, BATTLESTANCE))
+                {
+                    battleStance = true;
+                    defensiveStance = false;
+                    berserkerStance = false;
+                    //m_creature->RemoveAurasDueToSpell(DEFENSIVESTANCE);
+                    //m_creature->RemoveAurasDueToSpell(BERSERKERSTANCE);
+                    if (m_creature->getLevel() < 10) m_creature->SetPower(POWER_RAGE, 0);
+                    if (temprage > 100) m_creature->SetPower(POWER_RAGE, 100);
+
+                    stancetimer = 2100 - m_creature->getLevel()*20;//2100-1600 on 80
+                }
+                break;
+            case 2:
+                if (doCast(m_creature, DEFENSIVESTANCE))
+                {
+                    defensiveStance = true;
+                    battleStance = false;
+                    berserkerStance = false;
+                    //m_creature->RemoveAurasDueToSpell(BATTLESTANCE);
+                    //m_creature->RemoveAurasDueToSpell(BERSERKERSTANCE);
+                    if (m_creature->getLevel() < 10) m_creature->SetPower(POWER_RAGE, 0);
+                    if (temprage > 100) m_creature->SetPower(POWER_RAGE, 100);
+                    stancetimer = 2100 - m_creature->getLevel()*20;//2100-1600 on 80
+                }
+                break;
+            case 3:
+                if (doCast(m_creature, BERSERKERSTANCE))
+                {
+                    berserkerStance = true;
+                    battleStance = false;
+                    defensiveStance = false;
+                    //m_creature->RemoveAurasDueToSpell(BATTLESTANCE);
+                    //m_creature->RemoveAurasDueToSpell(DEFENSIVESTANCE);
+                    if (m_creature->getLevel() < 10) m_creature->SetPower(POWER_RAGE, 0);
+                    if (temprage > 100) m_creature->SetPower(POWER_RAGE, 100);
+                    stancetimer = 2100 - m_creature->getLevel()*20;//2100-1600 on 80
+                }
+                break;
+            default:
+                break;
+            }
+            /*if (spellId == BATTLESTANCE || spellId == DEFENSIVESTANCE || spellId == BERSERKERSTANCE)
+            {
+                if (master->getLevel() >= 78)
+                    stancetimer = 500;
+                else if (master->getLevel() >= 70)
+                    stancetimer = 700;
+                else if (master->getLevel() >= 60)
+                    stancetimer = 900;
+                else if (master->getLevel() >= 50)
+                    stancetimer = 1100;
+                else if (master->getLevel() >= 30)
+                    stancetimer = 1300;
+                else
+                    stancetimer = 1500;
+            }*/
+            GCD = temptimer;
+        }
+
+        void ReduceCD(const uint32 diff)
+        {if (!master) return;
+            if (!(pvpTrinket_cd < diff))                 pvpTrinket_cd -= diff;
+            if (!(regen_cd < diff))                      regen_cd -= diff;
+            if (!(slam_cd < diff))                       slam_cd -= diff;
+            if (!(battleShout_cd < diff))                battleShout_cd -= diff;
+            if (!(sweeping_strikes_cd < diff))           sweeping_strikes_cd -= diff;
+            if (!(deathwish_cd < diff))                  deathwish_cd -= diff;
+            if (!(mortalStrike_cd < diff))               mortalStrike_cd -= diff;
+            if (!(overpower_cd < diff))                  overpower_cd -= diff;
+            if (!(uber_cd < diff))                       uber_cd -= diff;
+            if (!(berserkerRage_cd < diff))              berserkerRage_cd -= diff;
+            if (!(intercept_cd < diff))                  intercept_cd -= diff;
+            if (!(intimidatingShout_cd < diff))          intimidatingShout_cd -= diff;
+            if (!(pummel_cd < diff))                     pummel_cd -= diff;
+            if (!(whirlwind_cd < diff))                  whirlwind_cd -= diff;
+            if (!(cleave_cd < diff))                     cleave_cd -= diff;
+            if (!(bloodrage_cd < diff))                  bloodrage_cd -= diff;
+            //if (!(disarm_cd < diff))                     disarm_cd -= diff;
+            //if (!(intervene_cd < diff))                  intervene_cd -= diff;
+            //if (!(shieldBash_cd < diff))                 shieldBash_cd -= diff;
+            //if (!(spellReflection_cd < diff))            spellReflection_cd -= diff;
+            if (!(potion_cd < diff))                     potion_cd -= diff;
+            if (!(taunt_cd < diff))                      taunt_cd -= diff;
+            if (!(sunder_cd < diff))                     sunder_cd -= diff;
+            
+            if (!(GCD < diff))                           GCD -= diff;
+            else                                         GCD = 0;
+            if (!(temptimer < diff))                     temptimer -= diff;
+            else                                         temptimer = 0;
+            if (!(stancetimer < diff))                   stancetimer -= diff;
+            if (!(ragetimer < diff))                     ragetimer -= diff;
+            if (!(ragetimer2 < diff))                    ragetimer2 -= diff;
+
+            if (charge_cd > 0)                           --charge_cd; //this is treated different
+            if (checkAurasTimer > 0)                     --checkAurasTimer;
+            if (wait > 0)                                --wait;
+        }
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/scripts/Bots/bot_warrior_ai.h b/src/server/scripts/Bots/bot_warrior_ai.h
new file mode 100644
index 0000000..54fdaf1
--- /dev/null
+++ b/src/server/scripts/Bots/bot_warrior_ai.h
@@ -0,0 +1,103 @@
+#include "bot_ai.h"
+
+//Cooldown/Timers
+#define ENRAGED_REGENERATION_CD    90000//1.5 min
+#define SWEEPING_STRIKES_CD 30000
+#define CHARGE_CD 150
+#define DEATHWISH_CD 90000 //1.5 min
+#define MORTALSTRIKE_CD 7000
+#define UBER_CD 150000 //RETALIATION_RECKLESSNESS_SHIELDWALL 2.5 min
+#define BERSERKERRAGE_CD 25000
+#define INTERCEPT_CD 15000
+#define INTIMIDATINGSHOUT_CD 45000
+#define PUMMEL_CD 10000
+#define WHIRLWIND_CD 8000
+//#define CLEAVE_CD 2500
+#define BLOODRAGE_CD 40000
+//#define DISARM_CD 40000
+//#define INTERVENE_CD 25000
+#define BATTLESHOUT_CD 25000
+//#define SPELLREFLECTION_CD 8000
+#define PVPTRINKET_CD 45000
+#define TAUNT_CD 8000
+#define SUNDER_CD 7000
+//#define POTIONCD 20000
+
+//spells
+#define PVPTRINKET 42292
+//#define CHALLENGING_SHOUT    1161
+#define INTIMIDATING_SHOUT   5246
+#define ENRAGED_REGENERATION 55694
+#define CHARGE               11578 //11578 original warrior one
+#define OVERPOWER            7384
+#define TAUNT                355
+#define DISARM               676 //DISARM_A[SPELL_LEVEL]
+#define BLOODRAGE            29131 //2687 original warrior spell
+#define BERSERKERRAGE        18499
+#define INTERCEPT            20252 //20252 original warrior one
+#define CLEAVE               59992
+#define HAMSTRING            1715
+
+//Battle Stance
+#define BATTLESTANCE         2457//7165 //2457 original warrior one
+//Defensive Stance
+#define DEFENSIVESTANCE      71
+//Berserker Stance
+#define BERSERKERSTANCE      2458//7366 //2458 original warrior spell
+
+//UBERs
+#define RECKLESSNESS         13847
+#define RETALIATION          22857
+#define DEATHWISH            12292
+
+//#define COMMANDINGSHOUT      469
+#define BATTLESHOUT          BATTLESHOUT_A[SPELL_LEVEL]
+#define REND                 REND_A[SPELL_LEVEL]
+#define EXECUTE              EXECUTE_A[SPELL_LEVEL]
+#define WHIRLWIND            WHIRLWIND_A[SPELL_LEVEL]
+#define PUMMEL               PUMMEL_A[SPELL_LEVEL]
+#define MORTALSTRIKE         MORTALSTRIKE_A[SPELL_LEVEL]
+#define SLAM                 SLAM_A[SPELL_LEVEL]
+#define SUNDER               SUNDER_A[SPELL_LEVEL]
+#define SWEEPING_STRIKES     SWEEPING_STRIKES_A[SPELL_LEVEL]
+
+uint32 BATTLESHOUT_A[] = { 6673, 5242, 6192, 11550, 11551, 25289, 2048, 47436, 59614 };
+uint32 REND_A[] = { 772, 772, 6546, 6547, 6548, 11572, 11573, 11574, 11574 };//rank 7
+uint32 EXECUTE_A[] = { 0, 0, 5308, 20660, 20662, 25234, 25236, 47471, 38959 };
+uint32 WHIRLWIND_A[] = { 0, 0, 0, 1680, 1680, 1680, 1680, 1680, 67541 };
+uint32 PUMMEL_A[] = { 0, 0, 15615, 15615, 15615, 15615, 15615, 15615, 15615 };
+uint32 MORTALSTRIKE_A[] = { 0, 0, 0, 0, 12294, 21553, 30330, 47485, 47486 };
+uint32 SLAM_A[] = { 0, 0, 1464, 8820, 11604, 11605, 25241, 25242, 47475 };
+uint32 SUNDER_A[] = { 0, 7386, 7386, 7386, 7386, 7386, 7386, 7386, 16145 };
+uint32 SWEEPING_STRIKES_A[] = { 0, 0, 0, 12328, 12328, 12328, 12328, 12328, 12328 };
+
+//AURA
+#define FRENZY_AURA                            25801
+
+//PASSIVE
+#define DEMONIC_CRIT                           DEMONIC_CRIT_A[SPELL_LEVEL]
+uint32 DEMONIC_CRIT_A[] = { 30242, 30242, 30245, 30245, 30246, 30246, 30247, 30247, 30248 };
+//Demonic Tactics {    rank 1    |   rank 2    |    rank 3   |    rank 4   |    rank 5   };
+#define PRECISION  /*Twilight Precision*/    78243//+20% hit -5% enemy dodge
+#define FLURRY                                 FLURRY_A[SPELL_LEVEL]
+//uint32 FLURRY_A[] = { 0, 0, 12971, 12971, 12972, 12972, 12973, 12973, 12974, 12974 };
+uint32 FLURRY_A[] = { 0, 0, 16256, 16256, 16281, 16281, 16282, 16283, 16284 };
+#define SWORD_SPEC                             SWORD_SPEC_A[SPELL_LEVEL]
+uint32 SWORD_SPEC_A[] = { 0, 0, 0, 12281, 12812, 12813, 12814, 12815, 12815 };
+#define BLOOD_CRAZE                            BLOOD_CRAZE_A[SPELL_LEVEL]
+uint32 BLOOD_CRAZE_A[] = { 0, 0, 16487, 16489, 16492, 16492, 16492, 16492, 16492 };
+#define BLOOD_FRENZY                           BLOOD_FRENZY_A[SPELL_LEVEL]
+uint32 BLOOD_FRENZY_A[] = { 0, 0, 0, 0, 0, 29836, 29859, 29859, 29859 };
+#define UNRELENTING_ASSAULT                    UNRELENTING_ASSAULT_A[SPELL_LEVEL]
+uint32 UNRELENTING_ASSAULT_A[] = { 0, 0, 0, 0, 0, 46859, 46859, 46860, 46860 };
+#define WC1            /*WRECKING CREW1*/      46867
+#define WC2            /*WRECKING CREW2*/      56611
+#define WC3            /*WRECKING CREW3*/      56612
+#define WC4            /*WRECKING CREW4*/      56613
+#define WC5            /*WRECKING CREW5*/      56614
+#define DEFLECTION                             16466//rank 5
+#define RAMPAGE                                29801
+#define SECOND_WIND                            29838//rank 2
+#define TOUGHNESS                              12764//rank 5
+#define TRAUMA1                                46854
+#define TRAUMA2                                46855
\ No newline at end of file
diff --git a/src/server/scripts/Bots/script_bot_giver.cpp b/src/server/scripts/Bots/script_bot_giver.cpp
new file mode 100644
index 0000000..4138d65
--- /dev/null
+++ b/src/server/scripts/Bots/script_bot_giver.cpp
@@ -0,0 +1,294 @@
+#include "ScriptPCH.h"
+#include <cstring>
+#include "GroupMgr.h"
+
+//This function is called when the player opens the gossip menubool
+class script_bot_giver : public CreatureScript
+{
+    public:
+
+        script_bot_giver()
+            : CreatureScript("script_bot_giver")
+        {
+        }
+
+        bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 action)
+        {
+            switch(sender)
+            {
+                case 6006: SendCreateNPCBotMenu(player, creature, action); break;
+                case 6001: SendCreateNPCBot(player, creature, action); break;
+                case 6007: SendRemoveNPCBotMenu(player, creature, action); break;
+                case 6008: SendRemoveNPCBot(player, creature, action); break;
+                case 6002: SendCreatePlayerBotMenu(player, creature, action); break;
+                case 6003: SendCreatePlayerBot(player, creature, action); break;
+                case 6004: SendRemovePlayerBotMenu(player, creature, action); break;
+                case 6005: SendRemovePlayerBot(player, creature, action); break;
+            }
+            return true;
+        }
+
+        bool OnGossipHello(Player *player, Creature *creature)
+        {
+            WorldSession *session = player->GetSession();
+            uint8 count = 0;
+
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                if (count == 0)
+                    player->ADD_GOSSIP_ITEM(0, "Abandon Your Player?", 6004, GOSSIP_ACTION_INFO_DEF + 100);
+                ++count;
+            }
+
+            if (player->HaveBot())
+            {
+                count = 0;
+                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                    if (player->GetBotMap()[i].m_creature != NULL)
+                        ++count;
+                if (count > 0 )
+                    player->ADD_GOSSIP_ITEM(0, "Abandon Your Minion?", 6007, GOSSIP_ACTION_INFO_DEF + 101);
+                if (count < player->GetMaxNpcBots())
+                    player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+            } 
+            else
+                player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+
+            if (count < player->GetMaxPlayerBot())
+                player->ADD_GOSSIP_ITEM(0, "Recruit a Player", 6002, GOSSIP_ACTION_INFO_DEF + 1);
+
+            player->PlayerTalkClass->SendGossipMenu(907, creature->GetGUID());
+            return true;
+        }
+
+        void SendCreatePlayerBot(Player *player, Creature *creature, uint32 action)
+        {
+            std::list<std::string> *names;
+            names = player->GetCharacterList();
+            if (names == NULL || names->empty())
+            {
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+
+            int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+            std::list<std::string>::iterator iter, next;
+            for(iter = names->begin(); iter != names->end(); iter++)
+            {
+                if (x==0) player->CreatePlayerBot((*iter).c_str());
+                else {
+                    if (x == 1)
+                    {
+                        player->CreatePlayerBot((*iter).c_str());
+                        break;
+                    }
+                    --x;
+                }
+            }
+
+            player->CLOSE_GOSSIP_MENU();
+        } //end SendCreatePlayerBot
+
+        void SendCreatePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+        {
+            std::list<std::string> *names;
+            names = player->GetCharacterList();
+            if (names == NULL || names->empty())
+            {
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+
+            player->PlayerTalkClass->ClearMenus();
+            player->ADD_GOSSIP_ITEM(9, "ADD ALL" , 6003, GOSSIP_ACTION_INFO_DEF + 1);
+            int8 x = 2;
+
+            std::list<std::string>::iterator iter, next;
+            for(iter = names->begin(); iter != names->end(); iter++)
+            {
+                //sLog->outError("character : %s", (*iter).c_str());
+                player->ADD_GOSSIP_ITEM(9, (*iter).c_str() , 6003, GOSSIP_ACTION_INFO_DEF + x);
+                ++x;
+            }
+            player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+        } //end SendCreatePlayerBotMenu
+
+        void SendRemovePlayerBotAll(Player *player, Creature *creature) {
+            for (int8 x = 2; x<=10; x++ )
+            {
+                SendRemovePlayerBot (player, creature, GOSSIP_ACTION_INFO_DEF + 2);
+            }
+        }
+        void SendRemoveNPCBot(Player *player, Creature *creature, uint32 action)
+        {
+            int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+            WorldSession *session = player->GetSession();
+            if (x == 0)
+            {
+                /*WorldSession *session = player->GetSession();
+                for(NpcBotMap::const_iterator itr = session->GetNpcBotsBegin(); itr != session->GetNpcBotsEnd(); ++itr)
+                {
+                    x = 10;
+                    if (x > 0 && itr->second)
+                    {
+                        Creature *m_bot = itr->second;
+                        Group *m_group = player->GetGroup();
+
+                        //removing bot from group
+                        //if (m_group->IsMember(m_bot->GetGUID()))
+                        //    if (m_group->RemoveMember(m_bot->GetGUID())){}
+                        player->RemoveBot(m_bot->GetGUID());
+                        break;
+                    }
+                    --x;
+                }*/
+                for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                {
+                    Creature *bot = player->GetBotMap()[i].m_creature;
+                    if (bot)
+                        player->RemoveBot(bot->GetGUID(), true);
+                }
+            }
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = player->GetBotMap()[i].m_creature;
+                if (x == 1 && bot)
+                {
+                    player->RemoveBot(bot->GetGUID(), true);
+                    break;
+                }
+                --x;
+            }
+            player->CLOSE_GOSSIP_MENU();
+        }
+
+        void SendRemovePlayerBot(Player *player, Creature *creature, uint32 action)
+        {
+            int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+            if (x == 0) {
+                SendRemovePlayerBotAll(player, creature);
+                return;
+            }
+
+            WorldSession *session = player->GetSession();
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                if (x == 1 && itr->second && itr->second->GetGroup())
+                {
+                    Player *m_bot = itr->second;
+                    Group *m_group = m_bot->GetGroup();
+
+                    //removing bot from group
+                    if (m_group->IsMember(m_bot->GetGUID()))
+                        if (m_group->RemoveMember(m_bot->GetGUID())){}
+                    session->LogoutPlayerBot(m_bot->GetGUID(), true);
+                    break;
+                }
+                --x;
+            }
+            player->CLOSE_GOSSIP_MENU();
+        } //end SendRemovePlayerBot
+
+        void SendRemovePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6005, GOSSIP_ACTION_INFO_DEF + 1);
+
+            uint8 x = 2;
+            WorldSession *session = player->GetSession();
+            for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+            {
+                Player *bot = itr->second;
+                player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6005, GOSSIP_ACTION_INFO_DEF + x);
+                ++x;
+            }
+            player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+        } //end SendRemovePlayerBotMenu
+
+        void SendRemoveNPCBotMenu(Player *player, Creature *creature, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6008, GOSSIP_ACTION_INFO_DEF + 1);
+
+            uint8 x = 2;
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = player->GetBotMap()[i].m_creature;
+                if (!bot) continue;
+                player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6008, GOSSIP_ACTION_INFO_DEF + x);
+                ++x;
+            }
+            player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+        }
+
+        void SendCreateNPCBot(Player *player, Creature *creature, uint32 action)
+        {
+            uint8 bot_class = 0;
+            /*if (action == GOSSIP_ACTION_INFO_DEF + 101) //abandon bot
+            {
+                if (player->HaveBot())
+                    player->SetBotMustDie();
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+            else */if (action == GOSSIP_ACTION_INFO_DEF + 1)
+            { //playerbot
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+            else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+                bot_class = CLASS_WARRIOR;
+            //else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+            //    bot_class = CLASS_HUNTER;
+            else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+                bot_class = CLASS_PALADIN;
+            //else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+            //    bot_class = CLASS_SHAMAN;
+            //else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+            //    bot_class = CLASS_ROGUE;
+            else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+                bot_class = CLASS_DRUID;
+            else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+                bot_class = CLASS_MAGE;
+            else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+                bot_class = CLASS_PRIEST;
+            //else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+            //    bot_class = CLASS_WARLOCK;
+            //else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+                //bot_class = CLASS_DEATH_KNIGHT;
+
+            if (bot_class > 0)
+            {
+                //sLog->outError("script_bot_giver.SendCreateNPCBot class = %u", bot_class);
+                player->CreateNPCBot(bot_class);
+            }
+            //else
+                //creature->Say("Invalid selection.", LANG_UNIVERSAL, NULL);
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        void SendCreateNPCBotMenu(Player *player, Creature *creature, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            player->ADD_GOSSIP_ITEM(9, "Recruit a Warrior", 6001, GOSSIP_ACTION_INFO_DEF + 2);
+            //player->ADD_GOSSIP_ITEM(9, "Recruit a Hunter", 6001, GOSSIP_ACTION_INFO_DEF + 3);
+            player->ADD_GOSSIP_ITEM(9, "Recruit a Paladin", 6001, GOSSIP_ACTION_INFO_DEF + 4);
+            //player->ADD_GOSSIP_ITEM(9, "Recruit a Shaman", 6001, GOSSIP_ACTION_INFO_DEF + 5);
+            //player->ADD_GOSSIP_ITEM(9, "Recruit a Rogue", 6001, GOSSIP_ACTION_INFO_DEF + 6);
+            player->ADD_GOSSIP_ITEM(3, "Recruit a Druid", 6001, GOSSIP_ACTION_INFO_DEF + 7);
+            player->ADD_GOSSIP_ITEM(3, "Recruit a Mage", 6001, GOSSIP_ACTION_INFO_DEF + 8);
+            player->ADD_GOSSIP_ITEM(3, "Recruit a Priest", 6001, GOSSIP_ACTION_INFO_DEF + 9);
+            //player->ADD_GOSSIP_ITEM(3, "Recruit a Warlock", 6001, GOSSIP_ACTION_INFO_DEF + 10);
+            //player->ADD_GOSSIP_ITEM(9, "Recruit a Death Knight", 1, GOSSIP_ACTION_INFO_DEF + 11);
+            player->SEND_GOSSIP_MENU(907, creature->GetGUID());
+        } //end SendCreateNPCBotMenu
+};
+
+//This function is called when the player clicks an option on the gossip menu
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index de660b8..c3451d9 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -39,6 +39,7 @@ set(scripts_STAT_SRCS
 
 if(SCRIPTS)
   include(Custom/CMakeLists.txt)
+  include(Bots/CMakeLists.txt)
   include(World/CMakeLists.txt)
   include(OutdoorPvP/CMakeLists.txt)
   include(EasternKingdoms/CMakeLists.txt)
diff --git a/src/server/shared/Common.h b/src/server/shared/Common.h
index bc9c0c6..e512615 100755
--- a/src/server/shared/Common.h
+++ b/src/server/shared/Common.h
@@ -19,6 +19,10 @@
 #ifndef TRINITYCORE_COMMON_H
 #define TRINITYCORE_COMMON_H
 
+#ifndef PLAYERBOT_EXISTS
+#define PLAYERBOT_EXISTS
+#endif
+
 // config.h needs to be included 1st
 // TODO this thingy looks like hack, but its not, need to
 // make separate header however, because It makes mess here.
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 1e37f50..dba51bb 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2786,3 +2786,80 @@ PlayerDump.DisallowOverwrite = 1
 
 #
 ###################################################################################################
+
+###################################################################################################
+# BOT CONFIGURATION
+#
+#    Bot.FollowDistanceMin
+#    Bot.FollowDistanceMax
+#        Min. and max. follow distance for bots
+#        Default: 0.5 / 2.0
+
+Bot.FollowDistanceMin = 0.5
+Bot.FollowDistanceMax = 2.0
+
+#    Bot.MaxPlayerBots
+#        Maximum number of Player Bots allowed per account
+#        Default: 9
+
+Bot.MaxPlayerBots = 9
+
+#    Bot.PlayerBotsFly
+#        If PlayerBots fly with you when you use the flight master
+#        Default: 0
+#        0 = false
+#        1 = true
+
+Bot.PlayerBotsFly=0
+
+#    Bot.LootMethod
+#        Type of loot method
+#        Default: 2
+#        0 = Free for all
+#        1 = Round robin
+#        2 = Master loot
+#        3 = Group loot
+#        4 = Need before greed
+
+Bot.LootMethod=2
+
+#    Bot.SaveOrgLocation
+#        Puts playerbots back to their original location after use
+#        Default: 0
+#        0 = false - keep playerbots where they were camped out
+#        1 = true - puts playerbots back to where they were originally summoned
+
+Bot.SaveOrgLocation=0
+
+#
+###################################################################################################
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character
+#        Default: 4
+#        Max: 9
+
+Bot.MaxNpcBots=4
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass=1
+
+#    Bot.XpReductionPercent
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 100
+#        Default: 0
+
+Bot.XpReductionPercent=0
+
+#
+###################################################################################################
-- 
1.7.6.msysgit.0

