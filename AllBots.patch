From fb297df2ade19d2f2b7ea935b8f604cee2ee6a45 Mon Sep 17 00:00:00 2001
From: trickerer <onlysuffering@mail.ru>
Date: Fri, 7 Sep 2012 23:21:00 +0700
Subject: [PATCH] AllBots

---
 sql/Bots/character_NPC_bots.sql                    |   10 +
 sql/Bots/world.bots.sql                            |  283 +
 sql/Bots/world.script_bot_giver.sql                |    7 +
 src/server/game/AI/NpcBots/bot_ai.cpp              | 2168 ++++
 src/server/game/AI/NpcBots/bot_ai.h                |  666 ++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        | 1092 ++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  342 +
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |  803 ++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      |  955 ++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  854 ++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |  356 +
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  288 +
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |  325 +
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      | 1132 ++
 src/server/game/AI/NpcBots/botcommands.cpp         |  788 ++
 src/server/game/AI/NpcBots/botgiver.cpp            |  286 +
 src/server/game/AI/PlayerBots/PlayerbotAI.cpp      |11974 ++++++++++++++++++++
 src/server/game/AI/PlayerBots/PlayerbotAI.h        | 2113 ++++
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp  |  499 +
 .../game/AI/PlayerBots/PlayerbotDeathKnightAI.h    |  100 +
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp |  713 ++
 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h   |  199 +
 .../game/AI/PlayerBots/PlayerbotHunterAI.cpp       |  393 +
 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h  |  121 +
 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp  |  470 +
 src/server/game/AI/PlayerBots/PlayerbotMageAI.h    |  163 +
 .../game/AI/PlayerBots/PlayerbotPaladinAI.cpp      |  616 +
 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h |  187 +
 .../game/AI/PlayerBots/PlayerbotPriestAI.cpp       |  480 +
 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h  |  157 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp |  344 +
 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h   |  102 +
 .../game/AI/PlayerBots/PlayerbotShamanAI.cpp       |  554 +
 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h  |  119 +
 .../game/AI/PlayerBots/PlayerbotWarlockAI.cpp      |  568 +
 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h |  250 +
 .../game/AI/PlayerBots/PlayerbotWarriorAI.cpp      |  353 +
 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h |  103 +
 src/server/game/CMakeLists.txt                     |    2 +
 src/server/game/Entities/Creature/Creature.cpp     |  131 +
 src/server/game/Entities/Creature/Creature.h       |   33 +
 .../game/Entities/Creature/TemporarySummon.cpp     |    7 +
 src/server/game/Entities/Player/Player.cpp         |  651 ++
 src/server/game/Entities/Player/Player.h           |   66 +
 src/server/game/Entities/Unit/Unit.cpp             |  195 +
 src/server/game/Groups/Group.cpp                   |   13 +
 src/server/game/Groups/Group.h                     |    3 +
 src/server/game/Handlers/CharacterHandler.cpp      |  143 +
 src/server/game/Handlers/ChatHandler.cpp           |   31 +
 src/server/game/Handlers/GroupHandler.cpp          |   18 +
 src/server/game/Handlers/QuestHandler.cpp          |    8 +
 src/server/game/Scripting/ScriptLoader.cpp         |   24 +
 src/server/game/Server/WorldSession.cpp            |  115 +
 src/server/game/Server/WorldSession.h              |   36 +
 src/server/scripts/Spells/spell_priest.cpp         |    4 +
 src/server/worldserver/worldserver.conf.dist       |  188 +
 56 files changed, 32601 insertions(+), 0 deletions(-)
 create mode 100644 sql/Bots/character_NPC_bots.sql
 create mode 100644 sql/Bots/world.bots.sql
 create mode 100644 sql/Bots/world.script_bot_giver.sql
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botgiver.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotMageAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
 create mode 100644 src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h

diff --git a/sql/Bots/character_NPC_bots.sql b/sql/Bots/character_NPC_bots.sql
new file mode 100644
index 0000000..9cef1ee
--- /dev/null
+++ b/sql/Bots/character_NPC_bots.sql
@@ -0,0 +1,10 @@
+DROP TABLE IF EXISTS `character_npcbot`;
+CREATE TABLE `character_npcbot` (
+  `owner` int(10) default NULL,
+  `entry` int(10) default NULL,
+  `race` tinyint(3) default NULL,
+  `class` tinyint(3) default NULL,
+  `istank` tinyint(3) default NULL,
+  PRIMARY KEY  (`owner`,`entry`)
+)  ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
diff --git a/sql/Bots/world.bots.sql b/sql/Bots/world.bots.sql
new file mode 100644
index 0000000..2fce78d
--- /dev/null
+++ b/sql/Bots/world.bots.sql
@@ -0,0 +1,283 @@
+
+delete from `creature_template` where entry >= 60001 && entry < 60239;
+
+insert  into `creature_template`
+(`entry`,`difficulty_entry_1`,`difficulty_entry_2`,`difficulty_entry_3`,`KillCredit1`,`KillCredit2`,`modelid1`,`modelid2`,`modelid3`,`modelid4`,`name`,`subname`,`IconName`,`gossip_menu_id`,`minlevel`,`maxlevel`,`exp`,
+`faction_A`,`faction_H`,`npcflag`,`speed_walk`,`speed_run`,`scale`,`rank`,`mindmg`,`maxdmg`,`dmgschool`,`attackpower`,`dmg_multiplier`,`baseattacktime`,`rangeattacktime`,`unit_class`,`unit_flags`,`dynamicflags`,`family`,
+`trainer_type`,`trainer_spell`,`trainer_class`,`trainer_race`,`minrangedmg`,`maxrangedmg`,`rangedattackpower`,`type`,`type_flags`,`lootid`,`pickpocketloot`,`skinloot`,`resistance1`,`resistance2`,`resistance3`,`resistance4`,`resistance5`,`resistance6`,
+`spell1`,`spell2`,`spell3`,`spell4`,`spell5`,`spell6`,`spell7`,`spell8`,`PetSpellDataId`,`VehicleId`,`mingold`,`maxgold`,`AIName`,`MovementType`,`InhabitType`,`Health_mod`,`Mana_mod`,`Armor_mod`,`RacialLeader`,
+`questItem1`,`questItem2`,`questItem3`,`questItem4`,`questItem5`,`questItem6`,`movementId`,`RegenHealth`,`equipment_id`,`mechanic_immune_mask`,`flags_extra`,`ScriptName`,`WDBVerified`) values 
+(60001,0,0,0,0,0,5001,0,5001,0,'Khelden','Mage Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,0,0,0,0,0,8,1,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60002,0,0,0,0,0,1294,0,1294,0,'Zaldimar','Mage Bot','',0,80,80,2,12,12,1,0.98,1.14286,1,0,5,10,0,54,1,1500,0,8,0,0,0,0,0,8,1,21.5072,29.5724,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'mage_bot',0),
+(60003,0,0,0,0,0,1484,0,1484,0,'Maginor','Mage Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,0,0,0,0,0,8,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60004,0,0,0,0,0,3344,0,3344,0,'Anetta','Priest Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,0,0,0,0,0,5,1,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60005,0,0,0,0,0,1495,0,1495,0,'Laurena','Priest Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,0,0,0,0,0,5,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60006,0,0,0,0,0,1295,0,1295,0,'Josetta','Priest Bot','',0,80,80,2,12,12,1,0.98,1.14286,1,0,5,10,0,54,1,1500,0,8,0,0,0,0,0,5,1,21.5072,29.5724,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'priest_bot',0),
+(60007,0,0,0,0,0,3345,0,3345,0,'Drusilla','Warlock Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,8,0,0,0,0,0,9,1,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60008,0,0,0,0,0,1930,0,1930,0,'Alamar','Warlock Bot','',0,80,80,2,875,875,1,1.07,1.14286,1,0,2,5,0,23,1,1960,2156,8,0,0,0,0,0,9,7,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60009,0,0,0,0,0,1469,0,1469,0,'Demisette','Warlock Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,8,0,0,0,0,0,9,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60010,0,0,0,0,0,12749,0,12749,0,'Nalesette','Hunter Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,23,48,0,247,1,1500,1500,2,0,0,0,3,0,3,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,319,0,'hunter_bot',0),
+(60011,0,0,0,0,0,3401,0,3401,0,'Branstock','Priest Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,8,0,0,0,0,0,5,3,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60012,0,0,0,0,0,3395,0,3395,0,'Thorgas','Hunter Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,2,0,0,0,0,0,3,3,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60013,0,0,0,0,0,3343,0,3343,0,'Llane','Warrior Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,65,0,364,1,1500,0,1,0,0,0,0,0,1,1,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,702,0,'warrior_bot',0),
+(60014,0,0,0,0,0,3399,0,3399,0,'Thran','Warrior Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,55,0,267,1,1960,2156,1,0,0,0,0,0,1,3,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,702,0,'warrior_bot',0),
+(60015,0,0,0,0,0,1300,0,1300,0,'Lyria','Warrior Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,90,0,543,1,1500,0,1,0,0,0,0,0,1,1,19.9584,27.4428,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,647,0,'warrior_bot',0),
+(60016,0,0,0,0,0,3351,0,3351,0,'Jorik','Rogue Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,75,0,1489,1,1500,0,4,0,0,0,0,0,4,1,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60017,0,0,0,0,0,3407,0,3407,0,'Solm','Rogue Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,74,0,1489,1,1960,2156,4,0,0,0,0,0,4,3,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60018,0,0,0,0,0,1297,0,1297,0,'Keryn','Rogue Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,53,0,1489,1,2000,0,4,0,0,0,0,0,4,1,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,730,0,'rogue_bot',0),
+(60019,0,0,0,0,0,1507,0,1507,0,'Osborne','Rogue Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,1489,1,1500,0,4,0,0,0,0,0,4,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,392,0,'rogue_bot',0),
+(60020,0,0,0,0,0,3346,0,3346,0,'Sammuel','Paladin Bot','',0,80,80,2,12,12,1,0.93,1.14286,1,0,2,5,0,23,1,1500,0,2,0,0,0,0,0,2,1,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,429,0,'paladin_bot',0),
+(60021,0,0,0,0,0,3393,0,3393,0,'Bob','Paladin Bot','',0,80,80,2,55,55,1,0.93,1.14286,1,0,2,5,0,23,1,1960,2156,2,0,0,0,0,0,2,3,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,429,0,'paladin_bot',0),
+(60022,0,0,0,0,0,1299,0,1299,0,'Wilhelm','Paladin Bot','',0,80,80,2,12,12,1,0.97,1.14286,1,0,5,9,0,45,1,1500,0,2,0,0,0,0,0,2,1,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,426,0,'paladin_bot',0),
+(60023,0,0,0,0,0,1499,0,1499,0,'Brisombre','Paladin Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,1500,0,2,0,0,0,0,0,2,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,105,0,'paladin_bot',0),
+(60024,0,0,0,0,0,10216,0,10216,0,'Marry','Mage Bot','',0,80,80,2,875,875,1,1.07,1.14286,1,0,2,5,0,23,1,1960,2156,8,0,0,0,0,0,8,7,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60025,0,0,0,0,0,4552,0,4552,0,'Haromm','Shaman Bot','',0,80,80,2,29,29,1,1.05,1.14286,1,0,32,200,0,345,1,2000,0,2,0,0,0,0,0,7,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1691,0,'shaman_bot',0),
+(60026,0,0,0,0,0,4567,0,4567,0,'Kartosh','Warlock Bot','',0,80,80,2,29,29,1,1.05,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60027,0,0,0,0,0,3429,0,3429,0,'MaxanAnvol','Priest Bot','',0,80,80,2,55,55,1,0.96,1.14286,1,0,3,9,0,42,1,1500,0,8,0,0,0,0,0,5,3,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1315,0,'priest_bot',0),
+(60028,0,0,0,0,0,10215,0,10215,0,'Magis','Mage Bot','',0,80,80,2,875,875,1,1.1,1.14286,1,0,3,9,0,42,1,1500,0,8,0,0,0,0,0,8,7,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60029,0,0,0,0,0,3431,0,3431,0,'GranVivehache','Warrior Bot','',0,80,80,2,55,55,1,0.96,1.14286,1,0,3,75,0,422,1,1500,0,1,0,0,0,0,0,1,3,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,1309,0,'warrior_bot',0),
+(60030,0,0,0,0,0,1622,0,1622,0,'Azar','Paladin Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,2,0,0,0,0,0,2,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,105,0,'paladin_bot',0),
+(60031,0,0,0,0,0,3436,0,3436,0,'Hogral','Rogue Bot','',0,80,80,2,55,55,1,0.97,1.14286,1,0,5,56,0,1489,1,2000,0,4,0,0,0,0,0,4,3,19.9584,27.4428,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,397,0,'rogue_bot',0),
+(60032,0,0,0,0,0,3053,0,3053,0,'Kelstrum','Warrior Bot','',0,80,80,2,55,55,1,1.17,1.14286,1,0,27,57,0,294,1,1500,0,1,0,0,0,0,0,1,3,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1853,0,'warrior_bot',0),
+(60033,0,0,0,0,0,1578,0,1578,0,'Dannal','Warrior Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,67,0,364,1,2000,0,1,0,0,0,0,0,1,5,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,639,0,'warrior_bot',0),
+(60034,0,0,0,0,0,1579,0,1579,0,'SombreDuesten','Priest Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,0,0,0,0,0,5,5,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60035,0,0,0,0,0,1592,0,1592,0,'Isabella','Mage Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,0,0,0,0,0,8,5,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1022,0,'mage_bot',0),
+(60036,0,0,0,0,0,1581,0,1581,0,'Maximillion','Warlock Bot','',0,80,80,2,68,68,1,0.9,1.14286,1,0,2,5,0,23,1,2000,0,8,0,0,0,0,0,9,5,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,143,0,'warlock_bot',0),
+(60037,0,0,0,0,0,1604,0,1604,0,'Rupert','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,6,13,0,65,1,2000,0,8,0,0,0,0,0,9,5,24.552,33.759,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1022,0,'warlock_bot',0),
+(60038,0,0,0,0,0,1600,0,1600,0,'Cain','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,6,12,0,59,1,2000,0,8,0,0,0,0,0,8,5,23.0384,31.6778,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60039,0,0,0,0,0,1602,0,1602,0,'SombreBeryl','Priest Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,7,14,0,75,1,2000,0,8,0,0,0,0,0,5,5,27.5264,37.8488,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60041,0,0,0,0,0,10548,0,10548,0,'Milituus','Mage Bot','',0,80,80,2,55,55,1,1.35,1.14286,1,0,27,57,0,294,1,2000,0,8,0,0,0,0,0,8,3,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60042,0,0,0,0,0,2810,0,2810,0,'Lexington','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,19,40,0,205,1,2000,0,8,0,0,0,0,0,8,5,51.128,70.301,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60043,0,0,0,0,0,2123,0,2123,0,'Siln','Shaman Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,200,0,345,1,2000,0,2,0,0,0,0,0,7,6,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,586,0,'shaman_bot',0),
+(60044,0,0,0,0,0,19598,0,19598,0,'Umbrua','Shaman Bot','',0,80,80,2,1640,1640,1,1.125,1.14286,1,0,176,200,0,1235,1,2000,0,2,0,0,0,0,0,7,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1627,0,'shaman_bot',0),
+(60045,0,0,0,0,0,2102,0,2102,0,'Tigor','Shaman Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,200,0,247,1,2000,0,2,0,0,0,0,0,7,6,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,145,0,'shaman_bot',0),
+(60046,0,0,0,0,0,2082,0,2082,0,'Beram','Shaman Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,200,0,451,1,2000,0,2,0,0,0,0,0,7,6,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,157,0,'shaman_bot',0),
+(60047,0,0,0,0,0,2106,0,2106,0,'Turak','Druid Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,200,0,345,1,2000,0,2,0,0,0,0,0,11,6,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1069,0,'druid_bot',0),
+(60048,0,0,0,0,0,2121,0,2121,0,'Sheal','Druid Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,200,0,1034,1,2000,0,2,0,0,0,0,0,11,6,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60049,0,0,0,0,0,2115,0,2115,0,'Kym','Druid Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,123,248,0,1034,1,2000,0,2,0,0,0,0,0,11,6,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1034,0,'druid_bot',0),
+(60050,0,0,0,0,0,2112,0,2112,0,'Kary','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1200,2,0,0,0,0,0,3,6,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,920,0,'hunter_bot',0),
+(60051,0,0,0,0,0,2087,0,2087,0,'Holt','Hunter Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1000,2,0,0,0,0,0,3,6,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60052,0,0,0,0,0,2105,0,2105,0,'Urek','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1300,2,0,0,0,0,0,3,6,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,6,0,'hunter_bot',0),
+(60053,0,0,0,0,0,2103,0,2103,0,'Torm','Warrior Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,1,0,0,0,0,0,1,6,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,916,0,'warrior_bot',0),
+(60054,0,0,0,0,0,2096,0,2096,0,'Sark','Warrior Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,0,0,0,0,0,1,6,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,133,0,'warrior_bot',0),
+(60055,0,0,0,0,0,17211,0,17211,0,'Kerra','Warrior Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,1,0,0,0,0,0,1,6,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,491,18,0,'warrior_bot',0),
+(60056,0,0,0,0,0,2139,0,2139,0,'Miles Welsh','Priest Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,5,5,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,40,0,'priest_bot',0),
+(60057,0,0,0,0,0,2138,0,2138,0,'Malakai','Priest Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,5,5,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,65,0,'priest_bot',0),
+(60058,0,0,0,0,0,2137,0,2137,0,'Cobb','Priest Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,5,5,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1096,0,'priest_bot',0),
+(60059,0,0,0,0,0,2134,0,2134,0,'Shymm','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,8,5,74.448,102.366,100,7,1,0,0,0,0,0,0,0,0,0,0,143,145,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,108,0,'mage_bot',0),
+(60060,0,0,0,0,0,6058,0,6058,0,'Ursyn','Mage Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,8,5,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60061,0,0,0,0,0,2135,0,2135,0,'Thurston','Mage Bot','',0,80,80,2,68,68,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,8,5,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,129,0,'mage_bot',0),
+(60062,0,0,0,0,0,3793,0,3793,0,'Harutt','Warrior Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,40,99,0,637,1,2000,0,1,0,0,0,0,0,1,6,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,1977,0,'warrior_bot',0),
+(60063,0,0,0,0,0,3819,0,3819,0,'Gart','Druid Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,3,200,0,1034,1,2000,0,2,0,0,0,0,0,11,6,15.2064,20.9088,100,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1073,0,'druid_bot',0),
+(60064,0,0,0,0,0,3810,0,3810,0,'Lanka','Hunter Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,5,9,0,45,1,2000,1460,2,0,0,0,0,0,3,6,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,138,0,'hunter_bot',0),
+(60065,0,0,0,0,0,10180,0,10180,0,'Meela','Shaman Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,3,200,0,42,1,2000,0,2,0,0,0,0,0,7,6,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,157,0,'shaman_bot',0),
+(60066,0,0,0,0,0,3794,0,3794,0,'Krang','Warrior Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,40,68,0,575,1,2000,0,1,0,0,0,0,0,1,6,23.0384,31.6778,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1977,0,'warrior_bot',0),
+(60067,0,0,0,0,0,10734,0,10734,0,'Gennia','Druid Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,5,200,0,1034,1,2000,0,2,0,0,0,0,0,11,6,19.9584,27.4428,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1069,0,'druid_bot',0),
+(60068,0,0,0,0,0,3811,0,3811,0,'Yaw','Hunter Bot','',0,80,80,2,104,104,1,0.97,1.14286,1,0,5,9,0,45,1,2000,1200,2,0,0,0,0,0,3,6,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,127,0,'hunter_bot',0),
+(60069,0,0,0,0,0,3816,0,3816,0,'Narm','Shaman Bot','',0,80,80,2,104,104,1,0.98,1.14286,1,0,5,200,0,54,1,2000,0,2,0,0,0,0,0,7,6,21.5072,29.5724,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,446,0,'shaman_bot',0),
+(60070,0,0,0,0,0,1880,0,1880,0,'Frang','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,30,99,0,670,1,2000,2090,1,0,0,0,0,0,1,2,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1977,0,'warrior_bot',0),
+(60071,0,0,0,0,0,1882,0,1882,0,'Jenshan','Hunter Bot','',0,80,80,2,126,126,1,0.95,1.14286,1,0,2,7,0,33,1,2000,2123,2,0,0,0,0,0,3,8,13.5872,18.6824,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,193,0,'hunter_bot',0),
+(60072,0,0,0,0,0,1884,0,1884,0,'Nartok','Warlock Bot','',0,80,80,2,29,29,1,0.96,1.14286,1,0,3,9,0,38,1,2000,2112,8,0,0,0,0,0,9,2,15.2064,20.9088,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1022,0,'warlock_bot',0),
+(60073,0,0,0,0,0,1878,0,1878,0,'Shikrik','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,3,200,0,42,1,2000,2101,2,0,0,0,0,0,7,2,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,604,0,'shaman_bot',0),
+(60074,0,0,0,0,0,3743,0,3743,0,'Tarshaw','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,25,53,0,273,1,2000,1738,1,0,0,0,0,0,1,2,59.7872,82.2074,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,642,0,'warrior_bot',0),
+(60075,0,0,0,0,0,3744,0,3744,0,'Thotar','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,6,15,0,72,1,2000,2035,2,0,0,0,0,0,3,2,26.048,35.816,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,920,0,'hunter_bot',0),
+(60076,0,0,0,0,0,3745,0,3745,0,'Dhugru','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,21,43,0,220,1,2000,1804,8,0,0,0,0,0,9,2,53.3984,73.4228,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60077,0,0,0,0,0,3746,0,3746,0,'Swart','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,6,200,0,65,1,2000,2046,2,0,0,0,0,0,7,2,24.552,33.759,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,861,0,'shaman_bot',0),
+(60078,0,0,0,0,0,1324,0,1324,0,'Groldar','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60079,0,0,0,0,0,1325,0,1325,0,'Mirket','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60080,0,0,0,0,0,1326,0,1326,0,'Zevrost','Warlock Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60081,0,0,0,0,0,1360,0,1360,0,'Kardris','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,200,0,451,1,2000,0,2,0,0,0,0,0,7,2,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,586,0,'shaman_bot',0),
+(60082,0,0,0,0,0,1373,0,1373,0,'Ormak','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1551,2,0,0,0,0,0,3,2,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,8,0,'hunter_bot',0),
+(60083,0,0,0,0,0,1374,0,1374,0,'Grezz','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,0,0,0,0,0,1,2,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,1865,0,'warrior_bot',0),
+(60084,0,0,0,0,0,1375,0,1375,0,'Sorek','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,1,0,0,0,0,0,1,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,725,0,'warrior_bot',0),
+(60085,0,0,0,0,0,4231,0,4231,0,'Siantsu','Shaman Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,200,0,247,1,2000,0,2,0,0,0,0,0,7,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,170,0,'shaman_bot',0),
+(60086,0,0,0,0,0,4239,0,4239,0,'Xorjuul','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,2,0,0,0,0,0,3,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60087,0,0,0,0,0,4241,0,4241,0,'Siandur','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,0,0,0,0,0,3,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60088,0,0,0,0,0,4242,0,4242,0,'Zelmak','Warrior Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,1,0,0,0,0,0,1,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,1867,0,'warrior_bot',0),
+(60089,0,0,0,0,0,7915,0,7915,0,'ClaudeErksine','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,1610,1771,2,0,0,0,3,0,3,3,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60090,0,0,0,0,0,1721,0,1721,0,'Alyissia','Warrior Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,50,87,0,322,1,2000,0,1,0,0,0,0,0,1,4,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,639,0,'warrior_bot',0),
+(60091,0,0,0,0,0,1725,0,1725,0,'FrahunMurmombre','Rogue Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,5,43,0,1489,1,2000,0,4,0,0,0,0,0,4,4,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,220,0,'rogue_bot',0),
+(60092,0,0,0,0,0,1733,0,1733,0,'Shanda','Priest Bot','',0,80,80,2,80,80,1,0.96,1.14286,1,0,3,9,0,42,1,2000,0,8,0,0,0,0,0,5,4,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,604,0,'priest_bot',0),
+(60093,0,0,0,0,0,1732,0,1732,0,'Mardant','Druid Bot','',0,80,80,2,80,80,1,0.97,1.14286,1,0,5,367,0,45,1,2000,0,2,0,0,0,0,0,11,4,18.392,25.289,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,114,0,'druid_bot',0),
+(60094,0,0,0,0,0,1707,0,1707,0,'Kyra','Warrior Bot','',0,80,80,2,80,80,1,1.01,1.14286,1,0,25,87,0,422,1,2000,0,1,0,0,0,0,0,1,4,30.4304,41.8418,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1913,0,'warrior_bot',0),
+(60095,0,0,0,0,0,1704,0,1704,0,'Jannok','Rogue Bot','',0,80,80,2,80,80,1,1.02,1.14286,1,0,9,73,0,1489,1,2000,0,4,0,0,0,0,0,4,4,31.856,43.802,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,628,0,'rogue_bot',0),
+(60096,0,0,0,0,0,1708,0,1708,0,'Laurna','Priest Bot','',0,80,80,2,80,80,1,1.03,1.14286,1,0,9,20,0,100,1,2000,0,8,0,0,0,0,0,5,4,33.264,45.738,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60097,0,0,0,0,0,1706,0,1706,0,'Kal','Druid Bot','',0,80,80,2,80,80,1,1.03,1.14286,1,0,10,214,0,107,1,2000,0,2,0,0,0,0,0,11,4,34.6544,47.6498,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'druid_bot',0),
+(60098,0,0,0,0,0,4296,0,4296,0,'Harruk','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,0,0,0,3,0,3,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,344,0,'hunter_bot',0),
+(60099,0,0,0,0,0,4299,0,4299,0,'Reban','Hunter bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1100,2,0,0,0,3,0,3,6,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,865,0,'hunter_bot',0),
+(60100,0,0,0,0,0,4304,0,4304,0,'Bolyun','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,23,48,0,247,1,2000,1235,2,0,0,0,3,0,3,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60101,0,0,0,0,0,1897,0,1897,0,'Taijin','Priest Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,8,16,0,84,1,2000,2013,8,0,0,0,0,0,5,8,28.9872,39.8574,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60102,0,0,0,0,0,4068,0,4068,0,'Kenjai','Priest Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,3,9,0,42,1,2000,2101,8,0,0,0,0,0,5,8,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,458,0,'priest_bot',0),
+(60103,0,0,0,0,0,2066,0,2066,0,'Danlaar','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,19,40,0,205,1,2000,1382,2,0,0,0,0,0,3,4,51.128,70.301,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1,0,'hunter_bot',0),
+(60104,0,0,0,0,0,2196,0,2196,0,'Ariasta','Warrior Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,1,0,0,0,0,0,1,4,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,822,0,'warrior_bot',0),
+(60105,0,0,0,0,0,2198,0,2198,0,'Sildanair','Warrior Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,1,0,0,0,0,0,1,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,281,0,'warrior_bot',0),
+(60106,0,0,0,0,0,2200,0,2200,0,'Astarii','Priest Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,5,4,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60107,0,0,0,0,0,2201,0,2201,0,'Jandria','Priest Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,5,4,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60108,0,0,0,0,0,2202,0,2202,0,'Lariia','Priest Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,5,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60109,0,0,0,0,0,2231,0,2231,0,'Syurna','Rogue Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,48,0,1489,1,2000,0,4,0,0,0,0,0,4,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,220,0,'rogue_bot',0),
+(60110,0,0,0,0,0,7669,0,7669,0,'Elissa','Mage Bot','',0,80,80,2,80,80,1,1.11,1.14286,1,0,19,40,0,205,1,2000,0,8,0,0,0,0,0,8,4,51.128,70.301,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60111,0,0,0,0,0,2252,0,2252,0,'Erion','Rogue Bot','',0,80,80,2,80,80,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,0,0,0,0,0,4,4,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,277,0,'rogue_bot',0),
+(60112,0,0,0,0,0,2243,0,2243,0,'Anishar','Rogue Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,67,0,1489,1,2000,0,4,0,0,0,0,0,4,4,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,1913,0,'rogue_bot',0),
+(60113,0,0,0,0,0,2250,0,2250,0,'Denatharion','Druid Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,267,0,345,1,2000,0,2,0,0,0,0,0,11,4,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,258,0,'druid_bot',0),
+(60114,0,0,0,0,0,2255,0,2255,0,'Fylerian','Druid Bot','',0,80,80,2,80,80,1,1.14,1.14286,1,0,23,348,0,247,1,2000,0,2,0,0,0,0,0,11,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,358,0,'druid_bot',0),
+(60115,0,0,0,0,0,2416,0,2416,0,'Caelyb','Hunter Bot','',0,80,80,2,80,80,1,1.05,1.14286,1,0,23,48,0,247,1,2000,1186,2,0,0,0,3,0,3,4,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1073,0,'hunter_bot',0),
+(60116,0,0,0,0,0,2675,0,2675,0,'Kaal','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,9,5,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60117,0,0,0,0,0,16800,0,16800,0,'Lana','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,5,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1784,0,'warlock_bot',0),
+(60118,0,0,0,0,0,2646,0,2646,0,'Richard','Warlock Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,9,5,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,1217,0,'warlock_bot',0),
+(60119,0,0,0,0,0,10214,0,10214,0,'Kaelystia','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,8,5,74.448,102.366,100,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,8388624,'mage_bot',0),
+(60120,0,0,0,0,0,2644,0,2644,0,'Pierce','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,8,5,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60121,0,0,0,0,0,2657,0,2657,0,'Anastasia','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,8,5,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60122,0,0,0,0,0,2620,0,2620,0,'Chris','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,42,88,0,451,1,2000,0,1,0,0,0,0,0,1,5,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,801,0,'warrior_bot',0),
+(60123,0,0,0,0,0,2658,0,2658,0,'Angela','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,32,67,0,345,1,2000,0,1,0,0,0,0,0,1,5,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,1881,0,'warrior_bot',0),
+(60124,0,0,0,0,0,2614,0,2614,0,'Baltus','Warrior Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,23,48,0,247,1,2000,0,1,0,0,0,0,0,1,5,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,1882,0,'warrior_bot',0),
+(60125,0,0,0,0,0,3054,0,3054,0,'Kelv','Warrior Bot','',0,80,80,2,55,55,1,1.17,1.14286,1,0,27,57,0,294,1,1560,1716,1,0,0,0,0,0,1,3,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,136,0,'warrior_bot',0),
+(60126,0,0,0,0,0,3055,0,3055,0,'Bilban','Warrior Bot','',0,80,80,2,875,875,1,1.35,1.14286,1,0,27,57,0,294,1,1500,0,1,0,0,0,0,0,1,7,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,675,0,'warrior_bot',0),
+(60127,0,0,0,0,0,3056,0,3056,0,'Daera','Hunter Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,1410,1551,2,0,0,0,0,0,3,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60128,0,0,0,0,0,3072,0,3072,0,'Olmin','Hunter Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1033,2,0,0,0,0,0,3,3,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60129,0,0,0,0,0,3073,0,3073,0,'Regnus','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1012,2,0,0,0,0,0,3,3,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60130,0,0,0,0,0,3086,0,3086,0,'Theodrus','Priest Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,5,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60131,0,0,0,0,0,3066,0,3066,0,'Braenna','Priest Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,5,3,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60132,0,0,0,0,0,3085,0,3085,0,'Toldren','Priest Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,5,3,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'priest_bot',0),
+(60134,0,0,0,0,0,3108,0,3108,0,'Bink','Mage Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,8,7,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60135,0,0,0,0,0,10214,0,10214,0,'Juli','Mage Bot','',0,80,80,2,875,875,1,1.38,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,8,7,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60136,0,0,0,0,0,3109,0,3109,0,'Nittegousse','Mage Bot','',0,80,80,2,55,55,1,1.45,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,8,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,96,0,'mage_bot',0),
+(60137,0,0,0,0,0,3089,0,3089,0,'Valgar','Paladin Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,2,0,0,0,0,0,2,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,105,0,'paladin_bot',0),
+(60138,0,0,0,0,0,3088,0,3088,0,'Beldruk','Paladin Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,0,0,0,0,0,2,3,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,799,0,'paladin_bot',0),
+(60139,0,0,0,0,0,3087,0,3087,0,'Brandur','Paladin Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,0,0,0,0,0,2,3,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,799,0,'paladin_bot',0),
+(60140,0,0,0,0,0,3101,0,3101,0,'Hulfdan','Rogue Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,0,0,0,0,0,4,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,1886,0,'rogue_bot',0),
+(60141,0,0,0,0,0,3100,0,3100,0,'Ormyr','Rogue Bot','',0,80,80,2,55,55,1,1.2,1.14286,1,0,32,67,0,1489,1,2000,0,4,0,0,0,0,0,4,3,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,220,0,'rogue_bot',0),
+(60142,0,0,0,0,0,3113,0,3113,0,'Phenwick','Rogue Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,1489,1,2000,0,4,0,0,0,0,0,4,7,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1206,220,0,'rogue_bot',0),
+(60143,0,0,0,0,0,3115,0,3115,0,'Coeurdechardon','Warlock Bot','',0,80,80,2,55,55,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,9,3,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60144,0,0,0,0,0,3116,0,3116,0,'Eglantin','Warlock Bot','',0,80,80,2,875,875,1,1.38,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,7,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60145,0,0,0,0,0,3122,0,3122,0,'Alexander','Warlock Bot','',0,80,80,2,55,55,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,9,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,110,0,'warlock_bot',0),
+(60146,0,0,0,0,0,3280,0,3280,0,'Wu','Warrior Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,1500,0,1,0,0,0,0,0,1,1,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1022,727,0,'warrior_bot',0),
+(60147,0,0,0,0,0,3287,0,3287,0,'Ilsa','Warrior Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,1500,0,1,0,0,0,0,0,1,1,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1362,613,0,'warrior_bot',0),
+(60148,0,0,0,0,0,3283,0,3283,0,'Joshua','Priest Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,5,1,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'priest_bot',0),
+(60149,0,0,0,0,0,3284,0,3284,0,'Arthur','Paladin Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,2,0,0,0,0,0,2,1,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,799,0,'paladin_bot',0),
+(60150,0,0,0,0,0,3289,0,3289,0,'Katherine','Paladin Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,2,0,0,0,0,0,2,1,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,205,799,0,'paladin_bot',0),
+(60151,0,0,0,0,0,3291,0,3291,0,'Deline','Warlock Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,9,1,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,838,0,'warlock_bot',0),
+(60152,0,0,0,0,0,3286,0,3286,0,'Sandahl','Warlock Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,9,1,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1491,173,0,'warlock_bot',0),
+(60153,0,0,0,0,0,3292,0,3292,0,'Jennea','Mage Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,8,1,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60154,0,0,0,0,0,19803,0,19803,0,'Elsharin','Mage Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,0,8,0,0,0,0,0,8,1,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60155,0,0,0,0,0,3299,0,3299,0,'Kaerbrus','Hunter Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,39,80,0,418,1,2000,1263,2,0,0,0,0,0,3,4,72.2304,99.3168,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60156,0,0,0,0,0,3300,0,3300,0,'Sheldras','Druid Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,288,0,451,1,2000,0,2,0,0,0,0,0,11,4,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1071,0,'druid_bot',0),
+(60157,0,0,0,0,0,3301,0,3301,0,'Theridran','Druid Bot','',0,80,80,2,80,80,1,1.2,1.14286,1,0,32,467,0,345,1,2000,0,2,0,0,0,0,0,11,4,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,258,0,'druid_bot',0),
+(60158,0,0,0,0,0,3312,0,3312,0,'Einris','Hunter Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,451,1,2000,1157,2,0,0,0,0,0,3,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,613,0,'hunter_bot',0),
+(60159,0,0,0,0,0,3309,0,3309,0,'Ulfir','Hunter Bot','',0,80,80,2,12,12,1,1.2,1.14286,1,0,32,67,0,345,1,2000,1379,2,0,0,0,0,0,3,1,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,10,0,'hunter_bot',0),
+(60160,0,0,0,0,0,3310,0,3310,0,'Thorfin','Hunter Bot','',0,80,80,2,12,12,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1175,2,0,0,0,0,0,3,1,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,298,0,'hunter_bot',0),
+(60161,0,0,0,0,0,10171,0,10171,0,'UnThuwa','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,6,12,0,59,1,2000,2057,8,0,0,0,0,0,8,8,23.0384,31.6778,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'mage_bot',0),
+(60162,0,0,0,0,0,4524,0,4524,0,'Pephredo','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,42,88,0,451,1,2000,1551,8,0,0,0,0,0,8,2,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,559,0,'mage_bot',0),
+(60163,0,0,0,0,0,4522,0,4522,0,'Enyo','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,8,0,0,0,0,0,8,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,99,0,'mage_bot',0),
+(60164,0,0,0,0,0,4526,0,4526,0,'Mai','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,3,4,0,26,1,2000,2101,8,0,0,0,0,0,8,8,16.808,23.111,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'mage_bot',0),
+(60165,0,0,0,0,0,4523,0,4523,0,'Deino','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,0,0,0,0,0,8,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,21,0,'mage_bot',0),
+(60166,0,0,0,0,0,4665,0,4665,0,'Birgitte','Mage Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,27,57,0,294,1,1000,0,8,0,0,0,0,0,8,5,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60167,0,0,0,0,0,12849,0,12849,0,'Thuul','Mage Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,27,57,0,294,1,1000,1716,8,0,0,0,0,0,8,2,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,173,0,'mage_bot',0),
+(60168,0,0,0,0,0,4690,0,4690,0,'Zayus','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,62,131,0,677,1,2000,1551,8,0,0,0,0,0,5,2,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,143,0,'priest_bot',0),
+(60169,0,0,0,0,0,10473,0,10473,0,'Xyera','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,32,67,0,345,1,2000,1661,8,0,0,0,0,0,5,2,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,228,0,'priest_bot',0),
+(60170,0,0,0,0,0,4711,0,4711,0,'Urkyo','Priest Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,0,0,0,0,0,5,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,85,0,'priest_bot',0),
+(60171,0,0,0,0,0,6060,0,6060,0,'Uthelnay','Mage Bot','',0,80,80,2,126,126,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,8,0,0,0,0,0,8,8,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,1071,0,'mage_bot',0),
+(60172,0,0,0,0,0,6072,0,6072,0,'Dink','Mage Bot','',0,80,80,2,875,875,1,1.31,1.14286,1,0,23,48,0,247,1,2000,0,8,0,0,0,0,0,8,7,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,838,0,'mage_bot',0),
+(60173,0,0,0,0,0,6071,0,6071,0,'Darnath','Warrior Bot','',0,80,80,2,80,80,1,1.23,1.14286,1,0,36,77,0,394,1,2000,0,1,0,0,0,0,0,1,4,70.664,97.163,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,394,277,0,'warrior_bot',0),
+(60174,0,0,0,0,0,7356,0,7356,0,'Karman','Paladin Bot','',0,80,80,2,894,894,1,1.25,1.14286,1,0,27,57,0,294,1,2000,0,2,0,0,0,0,0,2,1,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,117,0,'paladin_bot',0),
+(60175,0,0,0,0,0,11037,0,11037,0,'Evencane','Warrior Bot','',0,80,80,2,894,894,1,1.25,1.14286,1,0,27,57,0,294,1,2000,0,1,0,0,0,0,0,1,1,61.776,84.942,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,110,639,0,'warrior_bot',0),
+(60176,0,0,0,0,0,7357,0,7357,0,'Jannos','Druid Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,32,200,0,1034,1,2000,0,2,0,0,0,0,0,11,6,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,119,0,'druid_bot',0),
+(60177,0,0,0,0,0,7538,0,7538,0,'Alenndaar','Hunter Bot','',0,80,80,2,1076,1076,1,1.05,1.14286,1,0,14,28,0,143,1,2000,1012,2,0,0,0,0,0,3,4,41.3424,56.8458,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,886,0,'hunter_bot',0),
+(60178,0,0,0,0,0,10738,0,10738,0,'Golhine','Druid Bot','',0,80,80,2,80,80,1,1.1,1.14286,1,0,42,288,0,451,1,2000,0,2,0,0,0,0,0,11,4,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60179,0,0,0,0,0,9337,0,9337,0,'Hesuwa','Hunter Bot','',0,80,80,2,104,104,1,1.2,1.14286,1,0,23,48,0,247,1,2000,1178,2,0,0,0,3,0,3,6,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,6,0,'hunter_bot',0),
+(60180,0,0,0,0,0,9336,0,9336,0,'Xao\'tsu','Hunter Bot','',0,80,80,2,29,29,1,1.1,1.14286,1,0,23,48,0,247,1,2000,1771,2,0,0,0,3,0,3,2,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,886,0,'hunter_bot',0),
+(60181,0,0,0,0,0,9338,0,9338,0,'Belia','Hunter Bot','',0,80,80,2,55,55,1,1.14,1.14286,1,0,23,48,0,247,1,2000,1426,2,0,0,0,3,0,3,3,56.672,77.924,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,1081,0,'hunter_bot',0),
+(60182,0,0,0,0,0,10245,0,10245,0,'Dargh','Hunter Bot','',0,80,80,2,55,55,1,1.05,1.14286,1,0,12,25,0,128,1,1760,1936,2,0,0,0,0,0,3,3,38.72,53.24,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1186,19,0,'hunter_bot',0),
+(60183,0,0,0,0,0,11044,0,11044,0,'Meideros','Priest Bot','',0,80,80,2,80,80,1,1.08,1.14286,1,0,16,32,0,164,1,2000,0,8,0,0,0,0,0,5,4,45.144,62.073,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60184,0,0,0,0,0,11048,0,11048,0,'Presse','Priest Bot','',0,80,80,2,1076,1076,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,5,4,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60185,0,0,0,0,0,11053,0,11053,0,'Rohan','Priest Bot','',0,80,80,2,122,122,1,1.26,1.14286,1,0,42,88,0,451,1,2000,0,8,0,0,0,0,0,5,3,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60186,0,0,0,0,0,12053,0,12053,0,'Loganaar','Druid Bot','',0,80,80,2,994,994,1,1.1,1.14286,1,0,33,269,0,353,1,2000,0,2,0,0,0,0,0,11,4,67.32,92.565,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,1252,0,'druid_bot',0),
+(60187,0,0,0,0,0,13171,0,13171,0,'Romano','Rogue Bot','',0,80,80,2,12,12,1,1.26,1.14286,1,0,42,88,0,1489,1,2000,0,4,0,0,0,0,0,4,1,74.448,102.366,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,1204,734,0,'rogue_bot',0),
+(60188,0,0,0,0,0,13341,0,13341,0,'Sagorne','Shaman Bot','',0,80,80,2,104,104,1,1.1,1.14286,1,0,32,200,0,345,1,2000,0,2,0,0,0,0,0,7,6,66.44,91.355,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,93,458,0,'shaman_bot',0),
+(60189,0,0,0,0,0,15522,0,15522,0,'Julia','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,0,0,0,0,0,8,10,23.4783,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1022,0,'mage_bot',0),
+(60190,0,0,0,0,0,15511,0,15511,0,'Jesthenis','Paladin Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,2,0,0,0,0,0,2,10,23.4783,32.7308,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1229,0,'paladin_bot',0),
+(60191,0,0,0,0,0,15524,0,15524,0,'Invocateur','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,0,0,0,0,0,9,10,23.4783,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,1455,0,'warlock_bot',0),
+(60192,0,0,0,0,0,15518,0,15518,0,'Matrone','Priest Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,0,8,0,0,0,0,0,5,10,23.4783,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1306,0,'priest_bot',0),
+(60193,0,0,0,0,0,2659,0,2659,0,'Eclaireur','Rogue Bot','',0,80,80,2,68,68,1,1.1,1.14286,1,0,62,99,0,1489,1,2000,0,4,0,0,0,0,0,4,5,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1204,0,0,'rogue_bot',0),
+(60194,0,0,0,0,0,15520,0,15520,0,'Sallina','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,5,0,23,1,1500,1543,2,0,0,0,0,0,3,10,23.4783,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,27,0,'hunter_bot',0),
+(60195,0,0,0,0,0,16685,0,16685,0,'Noellene','Paladin Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,7,0,33,1,1500,0,2,0,0,0,0,0,2,10,56.3478,78.5538,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,204,725,0,'paladin_bot',0),
+(60196,0,0,0,0,0,16707,0,16707,0,'Ponaris','Priest Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,2,7,0,33,1,1500,0,8,0,0,0,0,0,5,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1096,0,'priest_bot',0),
+(60197,0,0,0,0,0,16222,0,16222,0,'Keilnei','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,1180,2,0,0,0,0,0,3,11,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,1619,0,'hunter_bot',0),
+(60198,0,0,0,0,0,16223,0,16223,0,'Valaatu','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,0,8,0,0,0,0,0,8,11,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1624,0,'mage_bot',0),
+(60199,0,0,0,0,0,16224,0,16224,0,'Aurelon','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,18,0,79,1,2000,0,2,0,0,0,0,0,2,11,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,1610,0,'paladin_bot',0),
+(60200,0,0,0,0,0,16225,0,16225,0,'Zalduun','Priest Bot','',0,80,80,2,1638,1638,1,1.25,1.14286,1,0,5,18,0,79,1,2000,0,8,0,0,0,0,0,5,11,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1626,0,'priest_bot',0),
+(60201,0,0,0,0,0,16226,0,16226,0,'Kore','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,54,0,322,1,2000,0,1,0,0,0,0,0,1,11,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1022,1618,0,'warrior_bot',0),
+(60202,0,0,0,0,0,16787,0,16787,0,'Alamma','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,0,0,0,0,0,9,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,0,0,'warlock_bot',0),
+(60203,0,0,0,0,0,16800,0,16800,0,'Talionia','Warlock Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,0,0,0,0,0,9,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1491,0,0,'warlock_bot',0),
+(60204,0,0,0,0,0,16831,0,16831,0,'Zanien','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,18,66,0,290,1,2000,1180,2,0,0,0,0,0,9,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60205,0,0,0,0,0,16781,0,16781,0,'Zaedana','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,0,0,0,0,0,8,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60206,0,0,0,0,0,16824,0,16824,0,'Quithas','Mage Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,0,0,0,0,0,8,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60207,0,0,0,0,0,16739,0,16739,0,'Harene','Druid Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,18,366,0,290,1,2000,0,2,0,0,0,0,0,11,6,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,0,0,'druid_bot',0),
+(60208,0,0,0,0,0,16778,0,16778,0,'Tana','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,12,42,0,185,1,2000,1168,2,0,0,0,0,0,3,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60209,0,0,0,0,0,16816,0,16816,0,'Oninath','Hunter Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,14,53,0,236,1,1000,1084,2,0,0,0,0,0,3,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60210,0,0,0,0,0,16829,0,16829,0,'Bachi','Paladin Bot','',0,80,80,2,1604,1604,1,0.93,1.14286,1,0,38,68,0,367,1,2000,0,2,0,0,0,0,0,2,10,8.624,11.858,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,3,1,1,1,0,0,0,0,0,0,0,0,0,204,0,0,'paladin_bot',0),
+(60211,0,0,0,0,0,16767,0,16767,0,'Zelanis','Rogue Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,62,80,0,1489,1,2000,0,4,0,0,0,0,0,4,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1206,0,0,'rogue_bot',0),
+(60212,0,0,0,0,0,16798,0,16798,0,'Elara','Rogue Bot','',0,80,80,2,1604,1604,1,1.125,1.14286,1,0,52,77,0,1489,1,2000,0,4,0,0,0,0,0,4,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1204,0,0,'rogue_bot',0),
+(60213,0,0,0,0,0,16858,0,16858,0,'Shalannius','Druid Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,100,300,0,290,1,2000,0,2,0,0,0,0,0,11,6,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,0,0,'druid_bot',0),
+(60214,0,0,0,0,0,17434,0,17434,0,'Deremiis','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,1076,2,0,0,0,0,0,3,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60215,0,0,0,0,0,17247,0,17247,0,'Caedmos','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,8,0,0,0,0,0,5,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60216,0,0,0,0,0,17225,0,17225,0,'Baatun','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,2,0,0,0,0,0,2,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,0,0,'paladin_bot',0),
+(60217,0,0,0,0,0,17212,0,17212,0,'Ahonan','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,453,1,2000,0,1,0,0,0,0,0,1,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,394,0,0,'warrior_bot',0),
+(60218,0,0,0,0,0,17598,0,17598,0,'Firmanvaar','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,5,200,0,79,1,2000,0,2,0,0,0,0,0,7,11,28.1739,39.2769,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,1622,0,'shaman_bot',0),
+(60219,0,0,0,0,0,16860,0,16860,0,'Actron','Hunter Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,1125,2,0,0,0,0,0,3,11,46.9565,65.4615,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1186,0,0,'hunter_bot',0),
+(60220,0,0,0,0,0,17213,0,17213,0,'Behomat','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,18,66,0,290,1,2000,0,1,0,0,0,0,0,1,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1362,0,0,'warrior_bot',0),
+(60221,0,0,0,0,0,17600,0,17600,0,'Nobundo','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,21,200,0,345,1,2000,0,2,0,0,0,0,0,7,11,346.02,481.06,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60222,0,0,0,0,0,17599,0,17599,0,'Tuluun','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,41,200,0,393,1,2000,0,2,0,0,0,0,0,7,11,70.4348,98.1923,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,1086,0,'shaman_bot',0),
+(60223,0,0,0,0,0,16914,0,16914,0,'Sulaa','Shaman Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,200,0,236,1,2000,0,2,0,0,0,0,0,7,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60224,0,0,0,0,0,17215,0,17215,0,'Ruada','Warrior Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,76,0,643,1,2000,0,1,0,0,0,0,0,1,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,1022,797,0,'warrior_bot',0),
+(60225,0,0,0,0,0,17233,0,17233,0,'Semid','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,0,8,0,0,0,0,0,8,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,1304,0,'mage_bot',0),
+(60226,0,0,0,0,0,17232,0,17232,0,'Guvan','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,26,1,2000,0,8,0,0,0,0,0,5,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,94,0,'priest_bot',0),
+(60227,0,0,0,0,0,17234,0,17234,0,'Tullas','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,2,5,0,23,1,2000,0,2,0,0,0,0,0,2,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,204,422,0,'paladin_bot',0),
+(60228,0,0,0,0,0,17488,0,17488,0,'Killac','Hunter bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,2,0,0,0,0,0,3,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,'hunter_bot',0),
+(60229,0,0,0,0,0,17226,0,17226,0,'Jol','Paladin Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,2,0,0,0,0,0,2,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,205,0,0,'paladin_bot',0),
+(60230,0,0,0,0,0,17248,0,17248,0,'Fallat','Priest Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,0,0,0,0,0,5,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'priest_bot',0),
+(60231,0,0,0,0,0,17243,0,17243,0,'Harnan','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,14,53,0,236,1,2000,0,8,0,0,0,0,0,8,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60232,0,0,0,0,0,17241,0,17241,0,'Bati','Mage Bot','',0,80,80,2,1638,1638,1,1.125,1.14286,1,0,12,42,0,185,1,2000,0,8,0,0,0,0,0,8,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,127,0,0,'mage_bot',0),
+(60233,0,0,0,0,0,17792,0,17792,0,'Hobahken','Shaman Bot','',0,80,80,2,1638,1638,1,1.08,1.14286,1,0,18,200,0,290,1,2000,0,2,0,0,0,0,0,7,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60234,0,0,0,0,0,6820,0,6820,0,'Gurrag','Shaman Bot','',0,80,80,2,1638,1638,1,1.08,1.14286,1,0,12,200,0,185,1,2000,0,2,0,0,0,0,0,7,11,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,93,85,0,'shaman_bot',0),
+(60235,0,0,0,0,0,19596,0,19596,0,'Auberose','Paladin Bot','',0,80,80,2,1602,1602,1,1.1,1.14286,1,0,176,176,0,367,1,2000,0,2,0,0,0,0,0,2,10,0,0,100,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'0',0,1,1,1,1,0,0,0,0,0,0,0,0,0,897,1552,0,'paladin_bot',0),
+(60236,0,0,0,0,0,10335,10335,10335,10335,'Afina','Priest Bot','',0,80,80,2,35,35,1,0.95,1.14286,1,0,12,25,0,128,1,10000,0,8,0,0,0,0,0,5,2,40,53,100,7,1,0,0,0,100,100,100,100,100,100,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,0,0,0,0,0,0,0,0,1,1370,0,0,'priest_bot',0),
+(60237,0,0,0,0,0,1132,0,1132,0,'Voidwalker',NULL,NULL,0,80,80,2,14,14,0,1.1,1.14286,1,0,50,50,0,100,1,2000,0,1,0,0,16,0,0,1,0,23.0384,31.6778,100,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,1,1.1,0.77,1,0,0,0,0,0,0,0,0,1,0,0,0,'',0),
+(60238,0,0,0,0,0,1105,0,0,0,'Hunter\'s Pet',NULL,NULL,0,80,80,0,14,14,1,1.1,1.14286,1,0,87,117,0,214,1,2000,0,1,0,0,7,0,0,1,0,61,90,21,1,1,0,0,0,0,0,0,0,0,0,5708,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,0,0,0,0,0,0,0,149,1,0,0,0,'',0);
+
+
+-- OPTIONAL UPDATE
+-- Updated values I thought should be closer to the bots values at least for my server.
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 7, maxdmg:= 10,minlevel:=80,maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, minrangedmg:=0,     maxrangedmg:=0,         rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Druid Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 9, maxdmg:= 12,minlevel:=80,maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, minrangedmg:=950, maxrangedmg:=1450, rangedattackpower:=90,  dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Hunter Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 4, maxdmg:= 5,  minlevel:=80,maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, minrangedmg:=500, maxrangedmg:=900,    rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Mage Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 9, maxdmg:= 17,minlevel:=80,maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, minrangedmg:=0,     maxrangedmg:=0,         rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Paladin Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 4, maxdmg:= 5,  minlevel:=80,maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, minrangedmg:=300, maxrangedmg:=600,    rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Priest Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 7, maxdmg:= 11,minlevel:=80,maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, minrangedmg:=900, maxrangedmg:=1100, rangedattackpower:=50,  dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Rogue Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 6, maxdmg:= 9,  minlevel:=80,maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, minrangedmg:=0,      maxrangedmg:=0,        rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Shaman Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 4, maxdmg:= 6,  minlevel:=80,maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, minrangedmg:=500, maxrangedmg:=900,    rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Warlock Bot';
+UPDATE `creature_template` SET exp:=2, dmg_multiplier:=1.0, attackpower:=0, mindmg:= 9, maxdmg:= 21,minlevel:=80,maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, minrangedmg:=425, maxrangedmg:=625,    rangedattackpower:=0,    dynamicflags:=0,  speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, health_mod:=1, mana_mod:=1, armor_mod:=1, mechanic_immune_mask:=1, flags_extra:=0, AIName='' where entry >= 60000 && entry < 60239 and subname='Warrior Bot';
+
+-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		-- Druid		
+-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	-- Hunter	
+-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		-- Mage		
+-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	-- Paladin	
+-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		-- Priest		
+-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		-- Rogue		
+-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	-- Shaman	
+-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	-- Warlock	
+-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	-- Warrior	
+
+-- EQUIPS --
+-- to return old values use commented
+-- Warrior
+UPDATE `creature_equip_template` SET `itemEntry1`='27903' WHERE (`entry`='1022');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='43220' WHERE (`entry`='1022');
+UPDATE `creature_equip_template` SET `itemEntry1`='7723',`itemEntry2`='0',`itemEntry3`='0' WHERE (`entry`='110');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='27903',`itemEntry2`='0',`itemEntry3`='0' WHERE (`entry`='110');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='1905',`itemEntry2`='1905',`itemEntry3`='5856' WHERE (`entry`='110');
+UPDATE `creature_equip_template` SET `itemEntry1`='28367',`itemEntry2`='0' WHERE (`entry`='394');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='27903',`itemEntry2`='0' WHERE (`entry`='394');
+-- UPDATE `creature_equip_template` SET `itemEntry1`='5305',`itemEntry2`='12980' WHERE (`entry`='394');
+UPDATE `creature_template` SET `equipment_id`='394' WHERE (`entry`='60055');
\ No newline at end of file
diff --git a/sql/Bots/world.script_bot_giver.sql b/sql/Bots/world.script_bot_giver.sql
new file mode 100644
index 0000000..5b00cdc
--- /dev/null
+++ b/sql/Bots/world.script_bot_giver.sql
@@ -0,0 +1,7 @@
+
+DELETE FROM `creature_template` WHERE `entry`='60000';
+INSERT INTO creature_template
+  (entry, difficulty_entry_1, difficulty_entry_2, difficulty_entry_3, KillCredit1, KillCredit2, modelid1, modelid2, modelid3, modelid4, name, subname, IconName, gossip_menu_id, minlevel, maxlevel, exp, faction_A, faction_H, npcflag, speed_walk, speed_run, scale, rank, mindmg, maxdmg, dmgschool, attackpower, dmg_multiplier, baseattacktime, rangeattacktime, unit_class, unit_flags, dynamicflags, family, trainer_type, trainer_spell, trainer_class, trainer_race, minrangedmg, maxrangedmg, rangedattackpower, type, type_flags, lootid, pickpocketloot, skinloot, resistance1, resistance2, resistance3, resistance4, resistance5, resistance6, spell1, spell2, spell3, spell4, spell5, spell6, spell7, spell8, PetSpellDataId, VehicleId, mingold, maxgold, AIName, MovementType, InhabitType, Health_mod, Mana_mod, Armor_mod, RacialLeader, questItem1, questItem2, questItem3, questItem4, questItem5, questItem6, movementId, RegenHealth, equipment_id, mechanic_immune_mask, flags_extra, ScriptName, WDBVerified)
+VALUES
+  (60000, 0, 0, 0, 0, 0, 27541, 0, 27541, 0, "Lagretta", "Bot Officer", "", 0, 83, 83, 2, 35, 35, 1, "1.4", "1.14286", "0.4", 4, 228, 298, 0, 500, 1, 1500, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, "", 0, 3, "4.8", 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, "script_bot_giver", 12340);
+
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..f84b4e5
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,2168 @@
+#include "bot_ai.h"
+#include "Config.h"
+#include "Chat.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Graff (onlysuffering@mail.ru)
+Original patch from: LordPsyan http://bitbucket.org/lordpsyan/trinitycore-patches/
+TODO:
+Implement heal/tank/DD modes
+Implement Racial Abilities
+Implement Equipment Change (maybe)
+I NEED MORE
+*/
+//Need to replace it with something better
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080,
+};
+bot_ai::bot_ai(Creature *creature): ScriptedAI(creature)
+{
+    master = me->GetBotOwner();
+    m_spellpower = 0;
+    haste = 0;
+    regen_mp5 = 0.f;
+    myangle = 0.f;
+    tank = NULL;
+    extank = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    Potion_cd = 0;
+    checkAurasTimer = 20;
+    rezz_cd = 0;
+    //pet = NULL;
+    //petGuid = 0;
+    info = NULL;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    dmgmult_melee = ConfigMgr::GetFloatDefault("Bot.DamageMult.Melee", 1.0);
+    dmgmult_spell = ConfigMgr::GetFloatDefault("Bot.DamageMult.Spell", 1.0);
+    dmgmult_melee = std::max(dmgmult_melee, 0.01f);
+    dmgmult_spell = std::max(dmgmult_spell, 0.01f);
+    dmgmult_melee = std::min(dmgmult_melee, 10.f);
+    dmgmult_spell = std::min(dmgmult_spell, 10.f);
+    healTargetIconFlags = ConfigMgr::GetIntDefault("Bot.HealTargetIconsMask", 8);
+}
+
+bot_ai::~bot_ai(){}
+//Follow point calculation
+void bot_ai::CalculatePos(Position &pos)
+{
+    uint8 followdist = master->GetBotFollowDist();
+    Unit *followTarget = master;
+    float mydist, angle;
+    if (master->GetBotTankGuid() == me->GetGUID())
+    {
+        if (master->GetPlayerbotAI())
+            followTarget = master->GetSession()->m_master; 
+        mydist = frand(3.5f, 6.5f);
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f);
+    }
+    else
+    {
+        switch (me->GetBotClass())
+        {
+        case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case CLASS_PALADIN: case BEAR:
+            mydist = frand(0.2f, 1.f);//(1.f, 3.f);//RAND(1.f,1.5f,2.f,2.5f,3.f,3.5f);
+            angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f));//RAND(6.5f,7.f,7.5f,8.f,8.5f,9.f,9.5f,-6.5f,-7.f,-7.5f,-8.f,-8.5f,-9.f,-9.5f);
+            break;
+        case CLASS_WARLOCK: case CLASS_PRIEST: case CLASS_MAGE: case CAT:
+            mydist = frand(0.15f, 0.8f);//(0.5f, 2.f);//RAND(0.5f,1.f,1.5f,2.f);
+            angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f);//RAND(10.5f,11.f,11.5f,12.f,12.5f,13.f,13.5f);
+            break;
+        default:
+            mydist = frand(0.3f, 1.2f);//(2.5f, 4.f);//RAND(2.5f,3.f,3.5f,4.f);
+            angle = (M_PI/2.f) / 6.f * frand(9.f, 15.f);//RAND(9.f,10.f,11.f,12.f,13.f,14.f,15.f);
+            break;
+        }
+    }
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += followdist > 10 ? float(followdist - 10)/4.f : 0;
+    angle += followTarget->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        followTarget->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z))
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < followTarget->GetPositionZ())
+                z += 0.25f;
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //            T   
+    //           TTT
+    //    mmmmmmmm mmmmmmmm 
+    //   mmmmmmm MMM mmmmmmm 
+    //   mmmmm rrrrrrr mmmmm 
+    //    ddd rrrrrrrrr ddd
+    //     ddddddddddddddd
+    //       ddddddddddd
+    //         
+    //MMM - player
+    //TTT - bot tank
+    //m - melee (warrior, paladin, deathknight)
+    //d - default (druid, shaman, rogue, hunter)
+    //r - ranged/support (priest, warlock, mage)
+}
+// Movement set
+void bot_ai::SetBotCommandState(CommandStates st, bool force, Position *newpos)
+{
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->isAlive()) || force))
+    {
+        if (me->HasUnitState(UNIT_STATE_ROOT)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (!newpos)
+            CalculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+        //if (pet != NULL && pet->isAlive())
+        //{
+        //    //if (me->GetDistance(pet) > 25 || me->GetDistance(pet) < 0.2f)
+        //    {
+        //        //pet->Relocate(me->GetPositionX() + 5, me->GetPositionY() + 5);
+        //        pet->GetMotionMaster()->MoveFollow(me, PET_FOLLOW_DIST * 2.5, PET_FOLLOW_ANGLE);
+        //    }
+        //}
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->StopMoving();
+        me->GetMotionMaster()->Clear();
+        me->GetMotionMaster()->MoveIdle();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Get Maintank
+void bot_ai::FindTank()
+{
+    if (tank == me)
+        extank = me;
+    //check group flags in DB
+    tank = _GetBotGroupMainTank(master->GetGroup());
+    //check if master has set tank
+    if (!tank)
+        tank = master->GetBotTankGuid() != 0 ? sObjectAccessor->GetObjectInWorld(master->GetBotTankGuid(), (Unit*)NULL) : NULL;
+    //check if we have tank flag in master's motmap
+    if (!tank)
+        tank = master->GetBotTank(me->GetEntry());
+    //at last try to find tank by class if master is too lazy to set it
+    if (!tank)
+    {
+        Player *owner = master->GetPlayerbotAI() ? master->GetSession()->m_master : master;
+        uint8 Class = owner->getClass();
+        if (owner->isAlive() && 
+            (Class == CLASS_WARRIOR || Class == CLASS_PALADIN || Class == CLASS_DEATH_KNIGHT))
+            tank = owner;
+        else if (owner != master && master->isAlive())
+        {
+            Class = master->getClass();
+            if (Class == CLASS_WARRIOR || Class == CLASS_PALADIN || Class == CLASS_DEATH_KNIGHT)
+                tank = master;
+        }
+    }
+    //it happens to every bot so they all will know who the tank is
+    if (tank != extank)
+        me->SetBotTank(tank);
+    if (tank == me)
+    {
+        //if tank set by entry let master get right guid and set tank in botmap
+        if (master->GetBotTankGuid() != me->GetGUID())
+            master->SetBotTank(me->GetGUID());
+    }
+}
+//Get Group maintank
+Unit* bot_ai::_GetBotGroupMainTank(Group *group)
+{
+    if (!group)
+        return NULL;
+    QueryResult result = CharacterDatabase.PQuery("SELECT memberGuid, memberFlags FROM `group_member` WHERE `guid`='%u'", group->GetGUID());
+    if (!result)
+        return NULL;
+    Unit *unit = NULL;
+    do
+    {
+        Field *field = result->Fetch();
+        uint32 lowGuid = field[0].GetInt32();
+        uint8 flags = field[1].GetInt8();
+        if (flags & MEMBER_FLAG_MAINTANK)
+        {
+            Group::MemberSlotList const &members = group->GetMemberSlots();
+            for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                if (GUID_LOPART(itr->guid) == lowGuid)
+                    unit = sObjectAccessor->FindUnit(itr->guid);
+        }
+    } while (result->NextRow() && !unit);
+    return unit;
+}
+// Buffs And Heal (really)
+void bot_ai::BuffAndHealGroup(Player *gPlayer, const uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return; // if I'm already casting
+
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        HealTarget(master, GetHealthPCT(master), diff);
+        BuffTarget(master, diff);
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit *u = *itr;
+            if (!u || u->isDead()) continue;
+            if (HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature *cre = u->ToCreature())
+                if (cre->GetIAmABot())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *tPlayer = itr->getSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->GetMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (tPlayer->isDead()) continue;
+        if (HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *tPlayer = itr->getSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->GetMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit *u = *itr;
+                if (!u || u->isDead()) continue;
+                if (HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature *cre = u->ToCreature())
+                    if (cre->GetIAmABot())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+    {
+        if (healTargetIconFlags & GroupIconsFlags[i])
+        {
+            if (uint64 guid = pGroup->GetTargetIcons()[i])//check this one
+            {
+                if (Unit *unit = sObjectAccessor->FindUnit(guid))
+                {
+                    if (unit->isAlive() && me->GetMap() == unit->GetMap() && 
+                        master->getVictim() != unit && unit->getVictim() != master && 
+                        unit->GetReactionTo(master) >= REP_NEUTRAL)
+                    {
+                        HealTarget(unit, GetHealthPCT(unit), diff);
+                        //CureTarget(unit, getCureSpell(), diff);
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Targets either player or its corpse
+void bot_ai::RezGroup(uint32 REZZ, Player *gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (IsCasting()) return; // if I'm already casting
+    if (rezz_cd > 0) return;
+
+    //sLog->outBasic("RezGroup by %s", me->GetName());
+    Group *pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit *target = master;
+        if (master->isAlive()) return;
+        if (master->isRessurectRequested()) return; //ressurected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", master->GetGUID());
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *tPlayer = itr->getSource();
+        Unit *target = tPlayer;
+        if (!tPlayer || tPlayer->isAlive()) continue;
+        if (tPlayer->isRessurectRequested()) continue; //ressurected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (master->GetMap() != target->GetMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+//cycle through the group sending members for cure
+void bot_ai::CureGroup(Player *pTarget, uint32 cureSpell, const uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //sLog->outBasic("%s: CureGroup() on %s", me->GetName(), pTarget->GetName());
+    Group *pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        CureTarget(master, cureSpell, diff);
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature *cre = master->GetBotMap()[i]._Cre();
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *tPlayer = itr->getSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player *tPlayer = itr->getSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+            {
+                Creature *cre = tPlayer->GetBotMap()[i]._Cre();
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_ai::CureTarget(Unit *dTarget, uint32 cureSpell, const uint32 diff)
+{
+    return CanCureTarget(dTarget, cureSpell, diff) ? doCast(dTarget, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_ai::CanCureTarget(Unit *target, uint32 cureSpell, const uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || target->isDead()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const *info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info) return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    target->GetDispellableAuraList(me, dispelMask, dispel_list);
+    if (dispel_list.empty())
+        return false;
+    return true;
+}
+
+bool bot_ai::HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid, bool exclude) const
+{
+    if (!spellId) return false;
+    SpellInfo const *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo) return false;
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+    const std::string name = pSpellInfo->SpellName[loc];
+    if (name.length() == 0) return false;
+
+    return HasAuraName(unit, name, casterGuid, exclude);
+}
+
+bool bot_ai::HasAuraName(Unit *unit, const std::string spell, uint64 casterGuid, bool exclude) const
+{
+    if (spell.length() == 0) return false;
+
+    uint8 loc = master->GetSession()->GetSessionDbcLocale();
+    if (!unit || unit->isDead()) return false;
+
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (casterGuid != 0 && exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+// Can be used on your own or your playerbots' npcbot
+void bot_ai::listAuras(Player *player, Unit *unit) const
+{
+    if (!IsInBotParty(player)) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player);
+    ch.PSendSysMessage("ListAuras for %s", unit->GetName());
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[0],
+            rank = spellInfo->Rank[0];
+        std::string passive = "";
+        if (spellInfo->IsPassive()) 
+            passive = "(Passive)";
+        ch.PSendSysMessage("%u %s %s %s", spellInfo->Id, name.c_str(), rank.c_str(), passive.c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+        case STAT_STRENGTH: mystat = "str"; break;
+        case STAT_AGILITY: mystat = "agi"; break;
+        case STAT_STAMINA: mystat = "sta"; break;
+        case STAT_INTELLECT: mystat = "int"; break;
+        case STAT_SPIRIT: mystat = "spi"; break;
+        default: mystat = "unk stat"; break;
+        }
+        ch.PSendSysMessage("%s: %f", mystat.c_str(), unit->GetTotalStatValue(Stats(i)));
+    }
+    ch.PSendSysMessage("Melee AP: %f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %f'%'", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %f'%'", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %f'%'", unit->GetUnitParryChance());
+    ch.PSendSysMessage("Damage taken: %f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage range: min: %f, max: %f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    ch.PSendSysMessage("melee damage mult: %f", dmgmult_melee);
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("spellpower: %u", m_spellpower - m_spellpower % 50);
+        ch.PSendSysMessage("spell damage mult: %f", dmgmult_spell);
+        ch.PSendSysMessage("mana regen: %f", regen_mp5 - (int32(regen_mp5) % 45));
+        ch.PSendSysMessage("haste: %u *10 pct", haste);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            const char *resist = NULL;
+            switch (i)
+            {
+            case 1: resist = "holy";   break;
+            case 2: resist = "fire";   break;
+            case 3: resist = "nature"; break;
+            case 4: resist = "frost";  break;
+            case 5: resist = "shadow"; break;
+            case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, me->GetResistance(SpellSchools(i)));
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+        if (tank != NULL && tank->IsInWorld())
+        {
+            if (tank == me)
+                ch.PSendSysMessage("Is a MainTank!");
+            else
+                ch.PSendSysMessage("Maintank is %s", tank->GetName());
+        }
+    }
+}
+//SETSTATS
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_ai::setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force)
+{
+    if (myrace == 0 || myclass == 0) return;
+    if (myclass != BEAR && myclass != CAT && master->isDead()) return;
+    /*sLog->outBasic("setStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName(), myclass, myrace, mylevel, master->GetName());*/
+
+    //LEVEL
+    if (me->getLevel() != master->getLevel())
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+        InitSpells();
+    //if (pet != NULL && pet->getLevel() != master->getLevel())
+    //    pet->SetLevel(mylevel);
+
+    //FACTION
+    //restore charmer (prevent  <(someone else)'s Minion> after master has been charmed)
+    if (!master->GetCharmer())
+    {
+        //if (me->GetCharmerGUID() != master->GetGUID())
+        //    me->SetCharmerGUID(master->GetGUID());  //master
+        Player *owner = master->GetPlayerbotAI() ? master->GetSession()->m_master : master;
+        if (!owner->GetCharmer() && me->getFaction() != owner->getFaction())
+            me->setFaction(owner->getFaction()); //owner of all bots
+    }
+    //debug remove charmerguid from master if charmer is gone
+    //if (!master->GetCharmer() && master->GetCharmerGUID())
+    //    master->SetCharmerGUID(0);
+    //PHASE
+    if (!me->InSamePhase(master))
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    tempclass = myclass == BEAR || myclass == CAT ? CLASS_DRUID : myclass;
+    sObjectMgr->GetPlayerClassLevelInfo(tempclass, mylevel, &classinfo);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass());//use creature class
+    float value;
+    if (force)
+        for (uint8 i = STAT_STAMINA; i < MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), master->GetCreateStat(Stats(i)));
+
+    //MAXSTAT
+    for (uint8 i = 0; i < MAX_STATS; ++i)
+    {
+        value = master->GetTotalStatValue(Stats(i));
+        if (i == 0 || value > stat)
+            stat = value;//Get Hightest stat (on first cycle just set base value)
+    }
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+    case CLASS_WARRIOR:      ap_mod = 1.3f;  spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 0.75f; parry_mod = 1.75f; break;
+    case CLASS_DEATH_KNIGHT: ap_mod = 1.2f;  spp_mod = 1.0f; armor_mod = 1.15f; crit_mod = 0.9f; haste_mod = 0.65f; dodge_mod = 0.8f;  parry_mod = 2.0f;  break;//NYI
+    case CLASS_PALADIN:      ap_mod = 1.0f;  spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f;  parry_mod = 1.5f;  break;
+    case CLASS_ROGUE:        ap_mod = 1.5f;  spp_mod = 0.0f; armor_mod = 0.7f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f;  parry_mod = 0.8f;  break;//NYI
+    case CLASS_HUNTER:       ap_mod = 1.15f; spp_mod = 0.0f; armor_mod = 0.85f; crit_mod = 1.2f; haste_mod = 1.25f; dodge_mod = 1.2f;  parry_mod = 1.2f;  break;//NYI
+    case CLASS_SHAMAN:       ap_mod = 0.9f;  spp_mod = 1.0f; armor_mod = 0.9f;  crit_mod = 1.2f; haste_mod = 1.65f; dodge_mod = 0.8f;  parry_mod = 0.5f;  break;//NYI
+    case CLASS_DRUID:        ap_mod = 0.0f;  spp_mod = 1.3f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.95f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    case CLASS_MAGE:         ap_mod = 0.0f;  spp_mod = 0.8f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;          
+    case CLASS_PRIEST:       ap_mod = 0.0f;  spp_mod = 1.2f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    case CLASS_WARLOCK:      ap_mod = 0.0f;  spp_mod = 1.0f; armor_mod = 0.5f;  crit_mod = 0.7f; haste_mod = 1.75f; dodge_mod = 0.5f;  parry_mod = 0.0f;  break;
+    case BEAR:               ap_mod = 2.0f;  spp_mod = 1.3f; armor_mod = 2.25f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 2.5f;  parry_mod = 0.0f;  break;
+    case CAT:                ap_mod = 1.5f;  spp_mod = 1.3f; armor_mod = 1.1f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.35f; parry_mod = 0.0f;  break;
+    default:                 ap_mod = 0.0f;  spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.00f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+    if (spp_mod != 0.f && mylevel > 39)
+        spp_mod *= (float(mylevel - 39))/41.f;// gain spell power slowly
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+    
+    //ARMOR
+    //sLog->outBasic("Unpdating %s's ARMOR: ", me->GetName());
+    //sLog->outBasic("armor mod: %f", armor_mod);
+    armor_mod *= (master->GetModifierValue(UNIT_MOD_ARMOR, BASE_PCT) + master->GetModifierValue(UNIT_MOD_ARMOR, TOTAL_PCT))/2.f;
+    //sLog->outBasic("armor mod * master's modifier: %f", armor_mod);
+    value = float(classstats->BaseArmor);
+    //sLog->outBasic("base armor: %f", value);
+    value += float(master->GetArmor())/5.f;
+    //sLog->outBasic("base armor + 1/5 of master's armor: %f", value);
+    value *= armor_mod;
+    //sLog->outBasic("multiplied by armor mod (total base armor): %f", value);
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();//buffs will be took in consideration here
+
+    //RESISTANCES
+    //sLog->outBasic("Unpdating %s's RESISTANCES: ", me->GetName());
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(master->GetResistance(SpellSchools(i)));
+        //sLog->outBasic("master's resistance %u: %f, setting %f (triple) to bot", uint32(UNIT_MOD_RESISTANCE_START + i), value, value*3);
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value*2.5f + float(mylevel*2));
+        //me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_PCT, 1.f);
+        me->UpdateResistances(i);
+    }
+    //DAMAGE TAKEN
+    float directReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL);
+    float magicReduction = master->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC);
+    value = (directReduction + magicReduction)/2.f;// average
+    if (value > 1.f)
+    {
+        value = 1.f - value;//get clean bonus above 1.0
+        value = std::min(0.42f, value);
+        value/= 0.01f; //here we get percent like 0.42/0.01 = 42% (value * 100.f)
+        if (mylevel > 77)
+            value += float(mylevel - 77) * 6.f;// + 3 stacks for high level
+        RefreshAura(DMG_TAKEN, int8(value/6.f));//so max aura count = 10
+    }
+
+    //HEALTH
+    _OnHealthUpdate(myclass, myrace, mylevel);
+
+    //HASTE
+    value = 0.f;
+    for (uint8 i = CR_HASTE_MELEE; i != CR_HASTE_SPELL + 1; ++i)
+        if (float rating = master->GetRatingBonusValue(CombatRating(i)))
+            if (rating > value)//master got some haste
+                value = rating;//get hightest pct
+    for (uint8 i = EQUIPMENT_SLOT_BACK; i < EQUIPMENT_SLOT_END; ++i)
+        if (Item* item = master->GetItemByPos(0, i))//inventory weapons
+            if (item->GetTemplate()->ItemLevel > 280)//bears ICC 25H LK items
+                value += 10.f;//only weapons so we can add 1 or 2 stacks (rogue, warr, sham...)
+    value *= haste_mod;
+    if (isMeleeClass(myclass))
+        value *= 0.67f;//nerf melee haste by 1/3
+    value = value/10.f + float(mylevel/39);//get bonus at 78
+    if (myclass == CAT)//give cat lots of haste
+        value += float(mylevel/16);//or 20 (+ 4-5 stacks);
+    RefreshAura(HASTE,  uint8(value));//spell haste
+    RefreshAura(HASTE2, uint8(value));//melee haste
+    haste = uint8(value);//for show only
+
+    //HIT
+    int32 melee_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_HIT_CHANCE) + master->GetTotalAuraModifier(SPELL_AURA_MOD_ATTACKER_MELEE_HIT_CHANCE);
+    int32 spell_hit = master->GetTotalAuraModifier(SPELL_AURA_MOD_SPELL_HIT_CHANCE) + master->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_INCREASES_SPELL_PCT_TO_HIT, SPELL_SCHOOL_MASK_SPELL);
+    value = float(melee_hit > spell_hit ? melee_hit : spell_hit)*1.5f;//hightest, buff hit chance for bots
+    RefreshAura(PRECISION,  int8(value/3.f) + mylevel/39);//melee
+    RefreshAura(PRECISION2, int8(value/3.f) + mylevel/39);//spell
+
+    //CRIT
+    //chose melee or ranged cuz crit rating increases melee/spell, and hunter benefits from agility
+    value = master->GetUnitCriticalChance((master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK), me);
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if can
+    value *= crit_mod;
+    RefreshAura(CRITS, int8(value/5.f) + mylevel/39);
+    if (myclass == CLASS_PRIEST)
+        RefreshAura(HOLYCRIT, int8(value/7.f));//add holy crit to healers
+
+    //PARRY
+    value = master->GetFloatValue(PLAYER_PARRY_PERCENTAGE);
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    value *= parry_mod;
+    if (master->GetBotTankGuid() == me->GetGUID() && myclass != CAT && myclass != BEAR)//feral cannot parry so let it be base 5%
+        value += 10.f;
+    if (value > 55.f)
+        value = 55.f;
+    float parryAndDodge = value;//set temp value, this is needed to keep total avoidance within 65%
+    RefreshAura(PARRY, int8(value/5.f));
+
+    //DODGE
+    value = master->GetUnitDodgeChance();
+    value = value > 5.f ? value - 5.f : 0.f;//remove base chance if possible
+    value *= dodge_mod;
+    if (master->GetBotTankGuid() == me->GetGUID())
+        value += 10.f;
+    if (value > 55.f)
+        value = 55.f;
+    if (parryAndDodge + value > 55.f)
+        value = 55.f - parryAndDodge;//do not allow avoidance to be more than 65% (base 5+5)
+    RefreshAura(DODGE, int8(value/5.f));
+
+    //MANA
+    _OnManaUpdate(myclass, myrace, mylevel);
+
+    //MANA REGEN
+    if (mylevel >= 40 && me->getPowerType() == POWER_MANA)
+    {
+        regen_mp5 = master->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER);
+        //regen_mp5 = (master->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_POWER_REGEN, POWER_MANA) + sqrt(master->GetStat(STAT_INTELLECT)) * master->OCTRegenMPPerSpirit()) / 5.f;
+        //Unit::AuraEffectList const& regenAura = master->GetAuraEffectsByType(SPELL_AURA_MOD_MANA_REGEN_FROM_STAT);
+        //for (Unit::AuraEffectList::const_iterator i = regenAura.begin(); i != regenAura.end(); ++i)
+        //    regen_mp5 += master->GetStat(Stats((*i)->GetMiscValue())) * (*i)->GetAmount() / 500.f;
+        //regen_mp5 *= 0.8f;//custom modifier
+        float regen_mp5_a = stat * 0.2f;
+        //regen_mp5 += master->GetTotalStatValue(STAT_SPIRIT) * 0.1f;
+        regen_mp5 = regen_mp5 > regen_mp5_a ? regen_mp5 : regen_mp5_a;
+        if (regen_mp5 >= 45.f)
+        {
+            me->RemoveAurasDueToSpell(MANAREGEN100);
+            me->RemoveAurasDueToSpell(MANAREGEN45);
+            if      (regen_mp5 > 200.f)   RefreshAura(MANAREGEN100,int8(regen_mp5/100.f) + mylevel/20);
+            else/*if (regen_mp5 > 150.f)*/RefreshAura(MANAREGEN45, int8(regen_mp5/45.f)  + mylevel/20);
+        }
+    }
+
+    //SPELL POWER
+    if (mylevel >= 40 && spp_mod != 0.f)
+    {
+        //sLog->outBasic("Updating spellpower for %s:", me->GetName());
+        //sLog->outBasic("spp_mod: %f", spp_mod);
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+            if (power > sppower || i == SPELL_SCHOOL_HOLY)
+                sppower = power;
+        }
+        //sppower = master->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC);//"Spell Power" stat
+        //sLog->outBasic("Master's spell power: %i", sppower);
+        atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+        atpower *= 0.67f;
+        //sLog->outBasic("Master's 2/3 of attack power: %f", atpower);
+        m_spellpower = sppower > atpower ? sppower : atpower;
+        //sLog->outBasic("Chosen stat value: %i", m_spellpower);
+        m_spellpower = int32(float(m_spellpower)*spp_mod);
+        //sLog->outBasic("spellpower * mod: %i", m_spellpower);
+        if (myclass == CLASS_MAGE)
+            RefreshAura(FIREDAM_86, m_spellpower/4/86 + (mylevel >= 78)*2); //(86,172,258,344,430,516,602,688...) // fire spp, do not touch this
+        me->RemoveAurasDueToSpell(SPELL_BONUS_250);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_150);
+        me->RemoveAurasDueToSpell(SPELL_BONUS_50);
+        if      (mylevel < 60) RefreshAura(SPELL_BONUS_50,  m_spellpower/50);
+        else if (mylevel < 80) RefreshAura(SPELL_BONUS_150, m_spellpower/150 + 1);
+        else                   RefreshAura(SPELL_BONUS_250, m_spellpower/250 + 2);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+}
+//Emotion-based action 
+void bot_ai::ReceiveEmote(Player *player, uint32 emote)
+{
+    switch (emote)
+    {
+    case TEXT_EMOTE_BONK:
+        listAuras(player, me);
+        break;
+    case TEXT_EMOTE_SALUTE:
+        listAuras(player, player);
+        break;
+    case TEXT_EMOTE_STAND:
+        if (master != player)
+        {
+            me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+            return;
+        }
+        SetBotCommandState(COMMAND_STAY);
+        me->MonsterWhisper("Standing Still.", player->GetGUID());
+        break;
+    case TEXT_EMOTE_WAVE:
+        if (master != player)
+        {
+            me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+            return;
+        }
+        Follow(true);
+        me->MonsterWhisper("Following!", player->GetGUID());
+        break;
+    default:
+        break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members and your playerbots (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit *unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    //cheap check
+    if (Group *gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (healTargetIconFlags & GroupIconsFlags[i])
+                if (uint64 guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL && 
+                            master->getVictim() != unit && 
+                            unit->getVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature *cre = unit->ToCreature())
+    {
+        //npcbot case
+        if (Player *owner = cre->GetBotOwner())
+        {
+            if (owner == master || owner->GetSession()->m_master == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            //first case: constrolled by playerbot (possible without group)
+            uint64 ownerGuid = unit->GetOwnerGUID();
+            if (ownerGuid == 0 || !IS_PLAYER_GUID(ownerGuid))
+                return false;
+            uint32 masterId = master->GetSession()->GetAccountId();
+            uint32 ownerId = sObjectMgr->GetPlayerAccountIdByGUID(ownerGuid);
+            if (masterId == ownerId)
+                return true;
+            //second case: controlled by group member real player
+            if (Group *gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    //playerbot case
+    if (Player *plr = unit->ToPlayer())
+        if (plr->GetSession()->m_master == master)
+            return true;
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spell, int8 count, Unit *target) const
+{
+    if (!spell)
+        return false;
+    if (!target)
+        target = me;
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spell);
+    if (!spellInfo)
+        return false;
+    //if (!spellInfo->IsPassive())
+    //{
+    //    sLog->outError(LOG_FILTER_PLAYER, "bot_ai::RefreshAura(): bot %s received spell %u (%s) which is not a passive spell!", me->GetName(), spell, spellInfo->SpellName[0]);
+    //    //return false;
+    //}
+    if (target->HasAura(spell))
+        target->RemoveAurasDueToSpell(spell);
+    if (count > 0)
+        for (uint8 i = 0; i < count; ++i)
+            target->AddAura(spellInfo, MAX_EFFECT_MASK, target);
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_ai::CheckAuras(bool force)
+{
+    if (checkAurasTimer > 0 && !force) return;
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + master->GetNpcBotsCount()/2;
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+        {
+            opponent = me->getVictim();
+            if (opponent)
+            {
+                switch (me->GetBotClass())
+                {
+                case CLASS_MAGE: case CLASS_DRUID: case CLASS_WARLOCK: case CLASS_PRIEST:/* case CLASS_SHAMAN:*/
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true, false);
+                    break;
+                }
+            }
+        }
+        setStats(me->GetBotClass(), me->getRace(), master->getLevel());
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+        {
+            FindTank();
+            clear_cd = 15;
+        }
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent)
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    if (!me->isInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(master->GetCorpse()) > 5)
+                        me->GetMotionMaster()->MovePoint(master->GetCorpse()->GetMapId(), *master->GetCorpse());
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                CalculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); // check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->isInCombat())
+            {
+                if (me->GetSheath() != SHEATH_STATE_MELEE)
+                    me->SetSheath(SHEATH_STATE_MELEE);
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+                me->SetSheath(SHEATH_STATE_UNARMED);
+        }
+        UpdateMountedState();
+        UpdateStandState();
+        UpdateRations();
+    }
+}
+//GETTARGET
+//Returns attack target or 'no target'
+//uses follow distance if range isn't set
+Unit *bot_ai::getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    //check if no need to change target
+    Unit *u = master->GetPlayerbotAI() ? master->GetSession()->m_master->getVictim() : master->getVictim();
+    Unit *mytar = me->getVictim();
+    uint8 followdist = master->GetBotFollowDist();
+    if (u && u == mytar)
+    {
+        //sLog->outError(LOG_FILTER_PLAYER, "bot %s continues attack common target %s", me->GetName(), u->GetName());
+        return u;//forced
+    }
+    //Follow if...
+    float foldist = followdist > 10 ? float(followdist) * 0.67f : 6.7f;
+    if (!u && master->isAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //sLog->outError(LOG_FILTER_PLAYER, "bot %s cannot attack target %s, too far away", me->GetName(), mytar ? mytar->GetName() : "");
+        return NULL;
+    }
+
+    if (u && (master->isInCombat() || u->isInCombat()) && !InDuel(u) && !IsInBotParty(u))
+    {
+        //sLog->outError(LOG_FILTER_PLAYER, "bot %s starts attack master's target %s", me->GetName(), u->GetName());
+        return u;
+    }
+
+    if (CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //sLog->outError(LOG_FILTER_PLAYER, "bot %s continues attack opponent %s", me->GetName(), opponent->GetName());
+        if (me->GetDistance(opponent) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->isAlive())
+        return NULL; //do not bother
+
+    //check group
+    Group *gr = master->GetGroup();
+    if (!gr)
+    {
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature *bot = master->GetBotMap()[i]._Cre();
+            if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+            u = bot->getVictim();
+            if (u && CanBotAttack(u, byspell) && 
+                (bot->isInCombat() || u->isInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //sLog->outError(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName(), bot->GetName(), u->GetName());
+                return u;
+            }
+        }
+    }
+    else
+    {
+        for (GroupReference *ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+        {
+            Player *pl = ref->getSource();
+            if (!pl || me->GetMap() != pl->GetMap() || !pl->InSamePhase(me)) continue;
+            u = pl->getVictim();
+            if (u && pl != master && CanBotAttack(u, byspell) && 
+                (pl->isInCombat() || u->isInCombat()) && 
+                (master->isDead() || master->GetDistance(u) < foldist))
+            {
+                //sLog->outError(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName(), pl->GetName(), u->GetName());
+                return u;
+            }
+            if (!pl->HaveBot()) continue;
+            for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = pl->GetBotMap()[i]._Cre();
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                u = bot->getVictim();
+                if (u && CanBotAttack(u, byspell) && 
+                    (bot->isInCombat() || u->isInCombat()) && 
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //sLog->outError(LOG_FILTER_PLAYER, "bot %s hooked %s's victim %s", me->GetName(), bot->GetName(), u->GetName());
+                    return u;
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit *t = NULL;
+    float maxdist = float(followdist) * (me->IsMounted() ? 0.3f : 1.f);
+    maxdist += ranged ? float(followdist) * 0.25f : 0.f;
+    maxdist += master->isDead() ? sWorld->GetMaxVisibleDistanceOnContinents() * 0.5f : 0;//set max dist
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyWorldObject(maxdist, searcher);
+
+            TypeContainerVisitor<Trinity::UnitLastSearcher <NearestHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+            TypeContainerVisitor<Trinity::UnitLastSearcher <NearestHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+            cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, maxdist);
+            cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, maxdist);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+    {
+        //sLog->outError(LOG_FILTER_PLAYER, "bot %s has Found new target %s", me->GetName(), t->GetName());
+        reset = true;
+    }
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 myclass)
+{
+    bool byspell = false, ranged = false, reset = false;
+    switch (myclass)
+    {
+    case CLASS_DRUID:
+        byspell = me->GetShapeshiftForm() == FORM_NONE || 
+            me->GetShapeshiftForm() == FORM_TREE || 
+            me->GetShapeshiftForm() == FORM_MOONKIN;
+        ranged = byspell;
+        break;
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+    //case CLASS_SHAMAN:
+    //case CLASS_HUNTER:
+        byspell = true;
+        ranged = true;
+        break;
+    default:
+        break;
+    }
+
+    opponent = getTarget(byspell, ranged, reset);
+    if (!opponent)
+    {
+        me->AttackStop();
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    me->Attack(opponent, !ranged);
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit *target, Position &pos) const
+{
+    uint8 followdist = master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 30 ? 30.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, bool ranged, Unit *newtarget, Position *mypos)
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return;
+    if (!newtarget)
+        newtarget = me->getVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->isInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    uint8 followdist = master->GetBotFollowDist();
+    if (ranged)
+    {
+        if (newtarget->GetTypeId() == TYPEID_PLAYER && 
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > 8)
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else
+        me->GetMotionMaster()->MoveChase(newtarget);
+    me->Attack(newtarget, !ranged);
+}
+
+bool bot_ai::MoveBehind(Unit &target) const
+{
+    if (me->HasUnitState(UNIT_STATE_ROOT)) return false;
+    if (rand()%100 < 25 && //prevent cycle
+        target.getVictim() != me    && 
+        tank != me                  && 
+        target.HasInArc(M_PI, me)   && 
+        target.IsWithinCombatRange(me, ATTACK_DISTANCE) && 
+        !CCed(&target))//can we go behind?
+    {
+        float x,y,z;
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_ai::UpdateMountedState()
+{
+    if (master->IsMounted() && me->IsMounted())
+    {
+        if ((master->HasAuraType(SPELL_AURA_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)))
+        {
+            //creature don't benefit from mount flight speed, so force it
+            if (me->GetSpeed(MOVE_FLIGHT) != master->GetSpeed(MOVE_FLIGHT)/2)
+            me->SetSpeed(MOVE_FLIGHT, master->GetSpeed(MOVE_FLIGHT)/2);
+        }
+        return;
+    }
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+    if ((!master->IsMounted() || aura != mounted || (me->isInCombat() && opponent)) && (aura || mounted))
+    {
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        me->Dismount();
+        return;
+    }
+    if (me->isInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+    //fly
+    //if ((master->IsMounted() && master->HasAuraType(SPELL_AURA_FLY))/* || master->HasUnitMovementFlag(MOVEMENTFLAG_CAN_FLY) || master->HasUnitMovementFlag(MOVEMENTFLAG_FLYING)*/)
+    //{
+    //    if (!me->IsMounted() || !me->HasAuraType(SPELL_AURA_FLY))
+    //    {
+    //        //if (me->GetBotClass() == CLASS_DRUID && InitSpell(FLY_FORM))//TODO
+    //        //{
+    //        //}
+    //        //else
+    //        {
+    //            uint32 mount = 0;
+    //            Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    //            if (!mounts.empty())
+    //                mount = mounts.front()->GetId();
+    //            if (mount)
+    //            {
+    //                if (me->HasAuraType(SPELL_AURA_MOUNTED))
+    //                        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+    //                if (doCast(me, mount))
+    //                {
+    //                    if (Feasting())
+    //                    {
+    //                        me->RemoveAurasDueToSpell(DRINK);
+    //                        me->RemoveAurasDueToSpell(EAT);
+    //                    }
+    //                }
+    //            }
+    //        }
+    //    }
+    //}
+    ////ground
+    /*else */
+    if (master->IsMounted() && !me->IsMounted() && !master->isInCombat() && !me->isInCombat())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+            mount = mounts.front()->GetId();
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_ai::UpdateStandState() const
+{
+    if (master->getStandState() == UNIT_STAND_STATE_STAND && 
+        me->getStandState() == UNIT_STAND_STATE_SIT && 
+        !Feasting())
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if ((master->getStandState() == UNIT_STAND_STATE_SIT || Feasting()) && !me->isInCombat() && 
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+
+}
+//RATIONS
+void bot_ai::UpdateRations() const
+{
+    if (me->isInCombat() || CCed(me))
+    {
+        if (me->HasAura(EAT))   me->RemoveAurasDueToSpell(EAT);
+        if (me->HasAura(DRINK)) me->RemoveAurasDueToSpell(DRINK);
+    }
+
+    //drink
+    if (me->getPowerType() == POWER_MANA && !me->IsMounted() && !CCed(me) && 
+        !me->isInCombat() && !IsCasting() && rand()%100 < 30 && GetManaPCT(me) < 80 && 
+        !me->HasAura(DRINK))
+    {
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) && me->HasAura(DRINK))
+        me->ModifyPower(POWER_MANA, me->GetCreateMana()/20);
+
+    //eat
+    if (!me->IsMounted() && !CCed(me) && 
+        !me->isInCombat() && !IsCasting() && rand()%100 < 30 && GetHealthPCT(me) < 80 && 
+        !me->HasAura(EAT))
+    {
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+        me->SetHealth(me->GetHealth() + me->GetCreateHealth()/20);
+
+    //check
+    if (me->GetHealth() >= me->GetMaxHealth() && me->HasAura(EAT))
+        me->RemoveAurasDueToSpell(EAT);
+    if (me->getPowerType() == POWER_MANA && 
+        me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA) && 
+        me->HasAura(DRINK))
+        me->RemoveAurasDueToSpell(DRINK);
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives(Classes m_class) const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    //apply +healing taken
+    if (master->getLevel() >= 60) RefreshAura(BOR);//+40%
+    //apply -threat mod
+    switch(m_class)
+    {
+    case CLASS_WARRIOR: RefreshAura(RCP,1); break;
+    case CLASS_PRIEST:  RefreshAura(RCP,3); break;//-87%
+    default:            RefreshAura(RCP,2); break;//-54%
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit *target) const
+{
+    if (!target) return false;
+    Player *player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->GetIAmABot() ? target->ToCreature()->GetBotOwner() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+    if (!player) return false;
+
+    if (player->duel)
+    {
+        if (IsInBotParty(player))
+            return true;
+        else if (master->duel)
+            if (master->duel->opponent == player || player->duel->opponent == master)
+                return true;
+    }
+
+    return false;
+}
+//Used to find target for priest's dispels and mage's spellsteal (also shaman's purge in future)
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit *bot_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit *bot_ai::FindAffectedTarget(uint32 spellId, uint64 caster, float dist, uint8 hostile) const
+{
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph (maybe for Hex in future)
+Unit *bot_ai::FindPolyTarget(float dist, Unit *currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit *bot_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit *bot_ai::FindRepentanceTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit *bot_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit *bot_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    RootUnitCheck check(me, me->getVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit *bot_ai::FindCastingTarget(float dist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    CastingUnitCheck check(me, dist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit *bot_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (me->isMoving() || IsCasting()) return NULL;//prevent aoe casts while running away
+    Unit *unit = NULL;
+    Group *pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit *u = master->getVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature *bot = master->GetBotMap()[i]._Cre();
+            if (!bot || bot->isDead() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit *u = bot->getVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *tPlayer = itr->getSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (tPlayer->isDead() || master->GetMap() != tPlayer->GetMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit *u = tPlayer->getVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player *tPlayer = itr->getSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+        {
+            Creature *bot = tPlayer->GetBotMap()[i]._Cre();
+            if (!bot || bot->isDead() || master->GetMap() != bot->GetMap()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || (*iter)->isDead()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit *u = bot->getVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds second target for spells like Cleave, Swipe, (maybe Mind Sear) etc.
+Unit *bot_ai::FindSplashTarget(float dist, Unit *To) const
+{
+    if (!To)
+        To = me->getVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit *unit = NULL;
+
+    SecondEnemyCheck check(me, dist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//////////
+//Internal
+//////////
+uint32 bot_ai::InitSpell(uint32 spell) const
+{
+    uint8 lvl = me->getLevel();
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "Bot %s (owner: %s) failed to init spell %u! No spell info found!", me->GetName(), master->GetName(), spell);
+        return 0;//weird spell with no info, disable it
+    }
+
+    if (lvl < info->BaseLevel)//only 1st rank spells check
+        return 0;//cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell;//cannot use next rank, use this one
+        else
+            return InitSpell(spInfo->Id);//can use next rank, forward check
+    }
+
+    return spell;//max rank, use this
+}
+void bot_ai::_OnHealthUpdate(uint8 myclass, uint8 /*myrace*/, uint8 mylevel) const
+{
+    //sLog->outBasic("_OnHealthUpdate(): updating bot %s", me->GetName());
+    float pct = me->GetHealthPct();// needs for regeneration
+    uint32 m_basehp = classinfo.basehealth;
+    //sLog->outBasic("class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+    float stammod;
+    switch (myclass)
+    {
+    case CLASS_WARRIOR: case CLASS_DEATH_KNIGHT: case BEAR:
+        switch (master->getClass())
+        {
+            case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                stammod = 16.f;
+                break;
+            case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                stammod = 13.f;
+                break;
+            default: stammod = 9.8f; break;
+        }
+        break;
+    case CLASS_PALADIN:
+        switch (master->getClass())
+        {
+            case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                stammod = 15.5f;
+                break;
+            case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                stammod = 12.5f;
+                break;
+            case CLASS_PALADIN:
+                stammod = 9.8f;
+                break;
+            default: stammod = 9.f; break;
+        }
+        break;
+    case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+        switch (master->getClass())
+        {
+            case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                stammod = 9.8f;
+                break;
+            case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                stammod = 8.f;
+                break;
+            default: stammod = 5.f; break;
+        }
+        break;
+    case CLASS_DRUID: case CAT: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+        switch (master->getClass())
+        {
+            case CLASS_PRIEST: case CLASS_MAGE: case CLASS_WARLOCK:
+                stammod = 12.f;
+                break;
+            case CLASS_DRUID: case CLASS_SHAMAN: case CLASS_HUNTER: case CLASS_ROGUE:
+                stammod = 9.8f;
+                break;
+            default: stammod = 8.f; break;
+        }
+        break;
+    default: stammod = 10.f;
+        break;
+    }
+    //sLog->outBasic("stammod: %f", stammod);
+    
+    //manually pick up stamina from bot's buffs
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA);
+    //sLog->outBasic("bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue * 10.f);
+    //pick up master's stamina from items
+    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT) - 0.1f), 1.f);
+    stamValue = master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE) * master->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT) * total_pct;
+    //sLog->outBasic("stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    hp_add += int32(stamValue*stammod);
+    //float stamstat = stat*0.5f;
+    //if (stamValue > stamstat)
+    //{
+    //    //sLog->outBasic("selected stat to health add: Stamina (%f), value: %f", stamValue, stamValue*stammod);
+    //    hp_add += int32(stamValue*stammod);
+    //}
+    //else
+    //{
+    //    //sLog->outBasic("selected stat to health add: stamStat (%f), value: %f", stamstat, stamstat*stammod);
+    //    hp_add += int32(stamstat*stammod);
+    //}
+    //sLog->outBasic("health to add after master's stat mod: %i", hp_add);
+    int32 miscVal = me->getGender()*mylevel;
+    //sLog->outBasic("health to remove from gender mod: %i", -miscVal);
+    hp_add -= miscVal;//less hp for females lol
+    //sLog->outBasic("health to add after gender mod: %i", hp_add);
+    //miscVal = myrace*(mylevel/5);
+    //sLog->outBasic("health to add from race mod: %i", miscVal);
+    //hp_add += miscVal;//draenei tanks lol
+    //sLog->outBasic("health to add after race mod: %i", hp_add);
+    miscVal = master->GetNpcBotSlot(me->GetGUID())*(mylevel/5);
+    //sLog->outBasic("health to remove from slot mod: %i", -miscVal);
+    hp_add -= miscVal;
+    //sLog->outBasic("health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add;//m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //sLog->outBasic("total base health: %u", m_totalhp);
+    if (master->GetBotTankGuid() == me->GetGUID())
+    {
+        m_totalhp = (m_totalhp * 135) / 100;//35% hp bonus for tanks
+        //sLog->outBasic("total base health (isTank): %u", m_totalhp);
+    }
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));//replaces base 18900 hp at 80 lvl
+    me->UpdateMaxHealth();//will use our values we just set (update base health and buffs)
+    //sLog->outBasic("overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f));//restore pct
+    if (!me->isInCombat())
+        me->SetHealth(me->GetHealth() + m_basehp / 100);//regenerate
+}
+
+void bot_ai::_OnManaUpdate(uint8 myclass, uint8 /*myrace*/, uint8 mylevel) const
+{
+    if (me->getPowerType() != POWER_MANA)
+        return;
+    //sLog->outBasic("_OnManaUpdate(): updating bot %s", me->GetName());
+    float pct = (float(me->GetPower(POWER_MANA)) * 100.f) / me->GetMaxPower(POWER_MANA);
+    float m_basemana = classinfo.basemana > 0 ? classinfo.basemana : me->GetCreateMana();
+    //sLog->outBasic("classinfo base mana = %u", m_basemana);
+    me->SetCreateMana(m_basemana);//set base mana, critical
+    float manamod = 15.f;//here we set mana multiplier from intellect as we gain mana from MASTER's stats mostly
+    switch (myclass)
+    {
+    case CLASS_PALADIN: case CLASS_HUNTER: manamod =  4.5f; break;
+    case CLASS_SHAMAN:                     manamod = 11.5f; break;
+    case CLASS_DRUID:                      manamod = 12.5f; break;
+    case CLASS_PRIEST:                     manamod = 16.5f; break;
+    case CLASS_MAGE: case CLASS_WARLOCK:   manamod = 10.5f; break;
+    default:                                                break;
+    }
+    //manamod += 1.f;//custom
+    //manamod *= 0.70f;//custom
+    //sLog->outBasic("Manamod: %f", manamod);
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT);
+    //sLog->outBasic("bot's stats to mana add: Int (%f), value: %f", intValue, intValue*manamod);
+    m_basemana += uint32(intValue * 15.f/*manamod*/);
+    //intValue = master->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT)*0.67f;// 50% goes to bot (need to check items)
+    //pick up master's intellect from items
+    float total_pct = std::max((master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT) - 0.1f), 1.f);
+    intValue = master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE) * master->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT) * total_pct;
+    float intstat = stat*0.5f;
+    if (intValue > intstat)
+    {
+        //sLog->outBasic("selected stat to mana add: Int (%f), value: %f", intValue, intValue*manamod);
+        m_basemana += int32(intValue*manamod);
+    }
+    else
+    {
+        //sLog->outBasic("selected stat to mana add: intStat (%f), value: %f", intstat, intstat*manamod);
+        m_basemana += int32(intstat*manamod);
+    }
+    //sLog->outBasic("base mana + mana from master's intellect or stat: %u", m_basemana);
+    //intValue = me->GetTotalAuraModValue(UNIT_MOD_STAT_INTELLECT);
+    //sLog->outBasic("Intellect from buffs: %f", intValue);
+    //m_basemana += uint32(intValue) * manamod;
+    //sLog->outBasic("base mana + mana from intellect + mana from buffs: %u", m_basemana);
+    uint8 otherVal = me->getGender()*3*mylevel;
+    //sLog->outBasic("mana to add from gender mod: %u", otherVal);
+    m_basemana += otherVal;//more mana for females lol
+    //sLog->outBasic("base mana after gender mod: %u", m_basemana);
+    otherVal = master->GetNpcBotSlot(me->GetGUID())*(mylevel/5);// only to make mana unique
+    //sLog->outBasic("mana to remove from slot mod: %i", -otherVal);
+    m_basemana -= otherVal;
+    //sLog->outBasic("base mana after slot mod: %u", m_basemana);
+    float m_totalmana = m_basemana;
+    //sLog->outBasic("total mana to set: %u", m_totalmana);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, float(m_totalmana));
+    me->UpdateMaxPower(POWER_MANA);
+    //sLog->outBasic("Overall mana to set: %u", me->GetMaxPower(POWER_MANA));
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f));//restore pct
+    //No Regen
+}
+
+void bot_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (ap_mod == 0.f) return; //do not bother casters
+    //sLog->outBasic("_OnMeleeDamageUpdate: Updating bot %s", me->GetName());
+    float my_ap_mod = ap_mod;
+    float mod = master->getClass() == CLASS_HUNTER ? (master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT))/2.f : 
+        (master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) + master->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT))/2.f;
+    mod = std::max(mod, 1.f); // x1 is Minimum
+    mod = std::min(mod, 2.5f); // x2.5 is Maximum
+    //sLog->outBasic("got base damage modifier: %f", mod);
+    mod -= (mod - 1.f)*0.33f;//reduce bonus by 33%
+    //sLog->outBasic("damage modifier truencated to %f, applying", mod);
+    me->SetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT, mod);
+    me->SetCanDualWield(myclass == CLASS_ROGUE || myclass == CLASS_SHAMAN);
+    //if (myclass == CLASS_ROGUE || myclass == CLASS_SHAMAN)
+    //    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT, mod - 0.5f);
+    //else
+    //    me->SetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT, 0.000000f);//fix offhand whirlwind etc.
+    //me->SetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT, mod);//NUY
+    mod = (mod - 1.f)/2.f;
+    //sLog->outBasic("reduced damage modifier to gain bonus: %f", mod);
+    //sLog->outBasic("base ap modifier is %f", my_ap_mod);
+    my_ap_mod *= 0.5f;
+    //sLog->outBasic("ap modifier multiplied to %f", my_ap_mod);
+    my_ap_mod += my_ap_mod > 0.f ? mod : 0; //add reduced master's multiplier if can have damage
+    //sLog->outBasic("ap modifier + mod = %f", my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_PCT, my_ap_mod);
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_PCT, my_ap_mod);
+
+    int32 sppower = 0;
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        int32 power = master->SpellBaseDamageBonusDone(SpellSchoolMask(1 << i));
+        if (power > sppower)
+            sppower = power;
+    }
+    //sLog->outBasic("master's spellpower is %i, multiplying...", sppower);
+    sppower *= 1.5f;
+    //sLog->outBasic("got spellpower of %i", sppower);
+    //atpower = float(master->GetInt32Value(master->getClass() == CLASS_HUNTER ? UNIT_FIELD_RANGED_ATTACK_POWER : UNIT_FIELD_ATTACK_POWER));
+    float atpower = master->GetTotalAttackPowerValue(master->getClass() == CLASS_HUNTER ? RANGED_ATTACK : BASE_ATTACK);
+    //sLog->outBasic("master's base attack power is %f", atpower);
+    atpower = sppower > atpower ? sppower : atpower;//highest stat is used (either 1.5x spellpower or attack power)
+    //sLog->outBasic("chosen attack power stat value: %f", atpower);
+    //sLog->outBasic("expected attack power: %f", atpower*ap_mod);
+
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    if (myclass == CLASS_HUNTER || myclass == CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+    me->UpdateAttackPowerAndDamage();
+    //sLog->outBasic("listing stats: ");
+    //sLog->outBasic("attack power main hand: %f", me->GetTotalAttackPowerValue(BASE_ATTACK));
+    //sLog->outBasic("attack power off hand: %f", me->GetTotalAttackPowerValue(OFF_ATTACK));
+    //sLog->outBasic("attack power ranged: %f", me->GetTotalAttackPowerValue(RANGED_ATTACK));
+    //sLog->outBasic("damage multiplier main hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier off hand: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+    //sLog->outBasic("damage multiplier ranged: %f", me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * me->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+    //sLog->outBasic("Damage range main hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+    //sLog->outBasic("Damage range off hand: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+    //sLog->outBasic("Damage range ranged: min: %f, max: %f", me->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), me->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+}
+
+//emulates evade mode, removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally finds new target and interrupts casted spell if target is dead
+void bot_ai::_OnEvade() const
+{
+    for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+        if (Spell *spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+            if (!spell->GetSpellInfo()->IsChanneled())
+                if (Unit *u = spell->m_targets.GetUnitTarget())
+                    if (u->isDead() && !IsInBotParty(u))
+                        me->InterruptSpell(CurrentSpellTypes(i), false, false);
+    if (Rand() > 10) return;
+    if (!master->isInCombat() && !me->isInCombat()) return;
+    //ChatHandler ch(master->GetPlayerbotAI() ? master->GetSession()->m_master : master);
+    //ch.PSendSysMessage("_OnEvade() by bot %s", me->GetName());
+    if (master->isInCombat())
+    {
+        HostileRefManager& mgr = master->getHostileRefManager();
+        if (!mgr.isEmpty())
+        {
+            std::set<Unit*> Set;
+            HostileReference* ref = mgr.getFirst();
+            while (ref)
+            {
+                if (ref->getSource() && ref->getSource()->getOwner())
+                    Set.insert(ref->getSource()->getOwner());
+                ref = ref->next();
+            }
+            for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit *unit = (*i);
+                if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->isInCombat())
+                {
+                    //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName(), master->GetName());
+                    mgr.deleteReference(unit);
+                }
+            }
+        }
+        return;
+    }
+    else if (master->getHostileRefManager().isEmpty())
+    {
+        for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+        {
+            Creature *cre = master->GetBotMap()[i]._Cre();
+            if (!cre || !cre->isInCombat()) continue;
+            cre->DeleteThreatList();
+            HostileRefManager& mgr = cre->getHostileRefManager();
+            if (!mgr.isEmpty())
+            {
+                std::set<Unit*> Set;
+                HostileReference* ref = mgr.getFirst();
+                while (ref)
+                {
+                    if (ref->getSource() && ref->getSource()->getOwner())
+                        Set.insert(ref->getSource()->getOwner());
+                    ref = ref->next();
+                }
+                for (std::set<Unit*>::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit *unit = (*i);
+                    if (!unit->InSamePhase(me)) continue;
+                    if (/*unit->IsFriendlyTo(master)*/IsInBotParty(unit) || !unit->isInCombat())
+                    {
+                        //ch.PSendSysMessage("_OnEvade(): %s's hostile reference is removed from %s!", unit->GetName(), cre->GetName());
+                        mgr.deleteReference(unit);
+                    }
+                }
+            }
+            if (mgr.isEmpty())// has empty threat list and no hostile refs - we have all rights to stop combat
+            {
+                if (cre->isInCombat())
+                {
+                    //ch.PSendSysMessage("_OnEvade(): %s's HostileRef is empty! Combatstop!", cre->GetName());
+                    cre->CombatStop();
+                }
+            }
+        }
+        return;
+    }
+}
+//////////////
+//OnTriggered
+//////////////
+void bot_ai::OnSpellHit(Unit* /*caster*/, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        switch (spell->Effects[i].ApplyAuraName)
+        {
+        case SPELL_AURA_MOD_STAT:
+            doHealth = true;
+            doMana = true;
+            break;
+        case SPELL_AURA_MOD_INCREASE_HEALTH:
+        case SPELL_AURA_MOD_INCREASE_HEALTH_2:
+        case SPELL_AURA_230: // SPELL_AURA_MOD_INCREASE_HEALTH_2
+        case SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT:
+            doHealth = true;
+            break;
+        case SPELL_AURA_MOD_INCREASE_ENERGY:
+        case SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT:
+            doMana = true;
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32 &damage) const
+{
+    if (damage && dmgmult_melee != 1.0)
+        damage = float(damage) * dmgmult_melee;
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32 &damage) const
+{
+    if (damage && dmgmult_melee != 1.0)
+        damage = float(damage) * dmgmult_melee;
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32 &damage) const
+{
+    if (damage && dmgmult_spell != 1.0)
+        damage = float(damage) * dmgmult_spell;
+}
\ No newline at end of file
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..29dea60
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,666 @@
+#include "ScriptedCreature.h"
+#include "ScriptedGossip.h"
+#include "Group.h"
+#include "SpellAuras.h"
+#include "ScriptMgr.h"
+
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+enum Common
+{
+//COMMON SPELLS
+    MANAPOTION                          = 32453,
+    HEALINGPOTION                       = 15504,
+    DRINK                               = 66041,
+    EAT                                 = 66478,
+    //DEFIBRILLATE                        = 54732,
+//COMMON CDs
+    POTION_CD                           = 60000,
+//COMMON PASSIVES
+    //SPELL_BONUS_10                      = 33021,//10spp
+    SPELL_BONUS_50                      = 45011,//50spp
+    SPELL_BONUS_150                     = 28141,//150spp
+    SPELL_BONUS_250                     = 69709,//250spp
+    FIREDAM_86                          = 33816,//86 fire spp
+    MANAREGEN45                         = 35867,//45 mp5
+    MANAREGEN100                        = 45216,//100 mp5
+    HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
+    HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank2 10% haste, bonus for rend (warriors only)//13789//rank 3 10% haste 6% dodge
+    CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit
+    HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
+    DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
+    PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
+    PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit
+    DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 (-6%)
+    THREAT   /*Tank Class Passive*/     = 57339,//+43% threat
+    BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+};
+
+enum HoverSpells
+{
+    LEVITATE                            = 1706,
+    SLOW_FALL                           = 130,
+    //WATER_WALKING                       = 546,
+};
+
+enum DruidStances//bot's temp set class
+{
+    BEAR        = 15,
+    CAT         = 25,
+    //TRAVEL      = 35,                   //NUY
+    //FLY         = 45,                   //NUY
+};
+
+class bot_ai : public ScriptedAI
+{
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature *c);
+        static Unit *GetBotGroupMainTank(Group *group) { return _GetBotGroupMainTank(group); }
+        void SetBotCommandState(CommandStates st, bool force = false, Position *newpos = NULL);
+        void ApplyBotDamageMultiplierMelee(uint32 &damage) const;
+        void ApplyBotDamageMultiplierMelee(int32 &damage) const;
+        void ApplyBotDamageMultiplierSpell(int32 &damage) const;
+        inline void UpdateHealth() { doHealth = true; }
+        inline void SetBotTank(Unit *newtank) { tank = newtank; }
+
+    protected:
+        Player *master;
+        Unit *opponent;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, const uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, const uint32 /*diff*/) { return false; }
+
+        void BuffAndHealGroup(Player *gPlayer, const uint32 diff);
+        void RezGroup(uint32 REZZ, Player *gPlayer);
+
+        bool HasAuraName(Unit *unit, const std::string spell, uint64 casterGuid = 0, bool exclude = false) const;
+        bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid = 0, bool exclude = false) const;
+
+        //Cast engine
+        virtual bool doCast(Unit * /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //Can act or not
+        inline bool IAmDead() const { return (!master || ((master->isInCombat() || master->isDead()) && me->isDead())); }
+
+        // Cycles through the group and tries to cure every person
+        void CureGroup(Player *pTarget, uint32 cureSpell, const uint32 diff);
+        bool CureTarget(Unit *target, uint32 cureSpell, const uint32 diff);
+        //Finders
+        Unit *FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit *FindAffectedTarget(uint32 spellId, uint64 caster = 0, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit *FindPolyTarget(float dist = 30, Unit *currTarget = NULL) const;
+        Unit *FindFearTarget(float dist = 30) const;
+        Unit *FindRepentanceTarget(float dist = 20) const;
+        Unit *FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit *FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit *FindCastingTarget(float dist = 10, bool isFriend = false, uint32 spellId = 0) const;
+        Unit *FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit *FindSplashTarget(float dist = 5, Unit *To = NULL) const;
+        // misc checkers
+        bool InDuel(Unit *target) const;
+        bool IsInBotParty(Unit *unit) const;
+        // Checks common conditions of 'CCed' state
+        static bool CCed(Unit *target, bool root = false)
+        {
+            return target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && target->HasUnitState(UNIT_STATE_ROOT));
+        }
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        static uint32 GetLostHP(Unit *unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static uint8 GetHealthPCT(Unit *hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static uint8 GetManaPCT(Unit *hTarget) { if (!hTarget || hTarget->isDead() || hTarget->getPowerType() != POWER_MANA) return 100; return (hTarget->GetPower(POWER_MANA)*100/hTarget->GetMaxPower(POWER_MANA)); }
+        bool RefreshAura(uint32 spell, int8 count = 1, Unit *target = NULL) const;
+        void CheckAuras(bool force = false);
+        inline bool IsChanneling(Unit *u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit *u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCasted(false)); }
+        void Follow(bool force = false, Position *newpos = NULL)
+        {
+            if (force || 
+                (me->isAlive() && (!me->isInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+        Unit *getTarget(bool byspell, bool ranged, bool &reset) const;
+        bool CheckAttackTarget(uint8 myclass);
+        //inline Creature *GetPet() { pet = petGuid != 0 ? sObjectAccessor->GetObjectInWorld(petGuid, (Creature*)NULL) : NULL; return pet; }
+        //inline void SetPet(Creature *newpet) { petGuid = newpet ? newpet->GetGUID() : 0; pet = newpet; }
+        void ApplyPassives(Classes m_class) const;
+        void GetInPosition(bool force = false, bool ranged = true, Unit *newtarget = NULL, Position *pos = NULL);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit *target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+        inline bool isMeleeClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT || m_class == BEAR); }
+        virtual void DoNonCombatActions(const uint32 /*diff*/) { /*if (rezz_cd <= 0) RezGroup(DEFIBRILLATE, master);*/ }
+        virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) { }
+        virtual void InitSpells() { }
+        //virtual void CreatePet() { }
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+        uint8 GetWait()
+        {
+            if (doHealth)
+            {
+                doHealth = false;
+                _OnHealthUpdate(me->GetBotClass(), me->getRace(), master->getLevel());
+            }
+            if (doMana)
+            {
+                doMana = false;
+                _OnManaUpdate(me->GetBotClass(), me->getRace(), master->getLevel());
+            }
+            CheckAuras(true);
+            return (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+        }
+        inline uint8 GetHaste() const { return haste; }
+        inline uint16 Rand() const { return urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10); }
+        void CommonTimers(const uint32 diff)
+        {
+            if (Potion_cd > diff)           Potion_cd -= diff;
+            if (GC_Timer > diff)            GC_Timer -= diff;
+            if (temptimer > diff)           temptimer -= diff;
+            if (checkAurasTimer != 0)       --checkAurasTimer;
+            if (wait != 0)                  --wait;
+        }
+        void OnSpellHit(Unit* /*caster*/, SpellInfo const* /*spell*/);
+        inline void Evade() const { _OnEvade(); }
+
+        typedef std::set<Unit*> AttackerSet;
+        void setStats(uint8 myclass, uint8 myrace, uint8 mylevel, bool force = false);
+        uint32 InitSpell(uint32 spell) const;
+
+        Unit *tank;
+        SpellInfo const *info;
+        int32 cost, value;
+        uint32 Potion_cd, GC_Timer, temptimer, checkAurasTimer, wait;
+
+    private:
+        static Unit *_GetBotGroupMainTank(Group *group);
+        // Used to determine would we cure or not
+        bool CanCureTarget(Unit *target, uint32 cureSpell, const uint32 diff) const;
+        //Detemines, has bot any permission to attack target
+        bool CanBotAttack(Unit *target, int8 byspell = 0) const
+        {
+            if (!target) return false;
+            uint8 followdist = master->GetBotFollowDist();
+            float foldist = followdist > 10 ? float(followdist) * 0.67f : 6.7f;
+            return
+               (target->isAlive() && 
+               target->IsVisible() && 
+               (master->isDead() || (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) && //if master is killed pursue to the end
+                target->isTargetableForAttack() && 
+                !IsInBotParty(target) && 
+                (target->IsHostileTo(master) || 
+                (target->GetReactionTo(master) < REP_FRIENDLY && master->getVictim() == target && (master->isInCombat() || target->isInCombat())) || //master has pointed this target
+                target->IsHostileTo(me)) && //if master is controlled
+                //target->IsWithinLOSInMap(me) && 
+                (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+        }
+        void FindTank();
+        void ReceiveEmote(Player *player, uint32 emote);
+        void listAuras(Player *player, Unit *unit) const;
+        void CalculatePos(Position &pos);
+        void CalculateAttackPos(Unit *target, Position &pos) const;
+        void UpdateMountedState();
+        void UpdateStandState() const;
+        void UpdateRations() const;
+
+        void _OnHealthUpdate(uint8 myclass, uint8 myrace, uint8 mylevel) const;
+        void _OnManaUpdate(uint8 myclass, uint8 myrace, uint8 mylevel) const;
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+        void _OnEvade() const;
+
+        CommandStates m_botCommandState;
+        PlayerClassLevelInfo classinfo;
+        Position pos, attackpos;
+        Unit *extank;
+        bool doHealth, doMana;
+        int32 sppower, m_spellpower;
+        uint8 rezz_cd, clear_cd, haste, tempclass, healTargetIconFlags;
+        float stat, atpower, maxdist, myangle, regen_mp5,
+            ap_mod, spp_mod, armor_mod, crit_mod, haste_mod, dodge_mod, parry_mod,
+            dmgmult_melee, dmgmult_spell;
+        //uint64 petGuid;
+        //Creature *pet;
+
+//Unit Checkers
+    class HostileDispelTargetCheck
+    {
+        public:
+            explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const *m_ai = NULL) : 
+            me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { if (!ai) return; }
+            bool operator()(Unit* u)
+            {
+                if (u->IsWithinDistInMap(me, m_range) && 
+                    u->isAlive() && 
+                    u->InSamePhase(me) && 
+                    u->isInCombat() && 
+                    u->isTargetableForAttack() && 
+                    u->IsVisible() && 
+                    u->GetReactionTo(me) < REP_NEUTRAL && 
+                    (ai->IsInBotParty(u->getVictim()) || u->getThreatManager().getThreat(const_cast<Unit*>(me)) > 0.f))
+                {
+                    if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                    if (!checksteal)
+                    {
+                        if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                        if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                    }
+                    Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                    {
+                        Aura *aura = itr->second;
+                        SpellInfo const *Info = aura->GetSpellInfo();
+                        if (Info->Dispel != DISPEL_MAGIC) continue;
+                        if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                        if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                        AuraApplication *aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+                        if (aurApp && aurApp->IsPositive())
+                        {
+                            const std::string name = Info->SpellName[0];
+                            if (name == "Vengeance" || name == "Bloody Vengeance")
+                                continue;
+                            return true;
+                        }
+                    }
+                }
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            bool checksteal;
+            bot_ai const *ai;
+            HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+    };
+
+    class AffectedTargetCheck
+    {
+        public:
+            explicit AffectedTargetCheck(uint64 casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) : 
+            caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+            { if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+            bool operator()(Unit* u)
+            {
+                if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                    return false;
+                if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+                if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+                if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+                if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+                if (u->isAlive() && checker->IsWithinDistInMap(u, m_range))
+                {
+                    Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                    for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                    {
+                        Aura *aura = itr->second;
+                        if (aura->GetId() == spell)
+                            if (caster == 0 || aura->GetCasterGUID() == caster)
+                                return true;
+                    }
+                }
+                return false;
+            }
+        private:
+            uint64 const caster;
+            float m_range;
+            uint32 const spell;
+            Player const *checker;
+            uint8 needhostile;
+            Group const *gr;
+            AffectedTargetCheck(AffectedTargetCheck const&);
+    };
+
+    class PolyUnitCheck
+    {
+        public:
+            explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+            bool operator()(Unit* u)
+            {
+                if (u == mytar)
+                    return false;
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->isInCombat() || !u->isAlive() || !u->getVictim())
+                    return false;
+                if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID && 
+                    u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                    return false;
+                if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 || u->GetHealthPct() < 70)
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->IsVisible())
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (!u->IsHostileTo(me))
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->isFrozen() || 
+                    u->isInRoots() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                    //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                    //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                    //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                    //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                    u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(12826)))//Polymorph rank 4
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            Unit const *mytar;
+            PolyUnitCheck(PolyUnitCheck const&);
+    };
+
+    class FearUnitCheck
+    {
+        public:
+            explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->IsVisible())
+                    return false;
+                if (u->getAttackers().size() > 1)
+                    return false;
+                if (CCed(u))
+                    return false;
+                if (u->isFeared())
+                    return false;
+                if (u->GetReactionTo(me) > REP_NEUTRAL)
+                    return false;
+                
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            FearUnitCheck(FearUnitCheck const&);
+    };
+
+    class StunUnitCheck
+    {
+        public:
+            explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist)
+            {
+                ai = unit->ToCreature() ? unit->ToCreature()->GetBotAI() : NULL;
+                if (!ai) return;
+            }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (me->getVictim() == u || ai->master->getVictim() == u)
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (u->GetReactionTo(me) > REP_NEUTRAL)
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->IsVisible())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                    return false;
+                if (!(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to consecration
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            bot_ai *ai;
+            float m_range;
+            StunUnitCheck(StunUnitCheck const&);
+    };
+
+    class UndeadCCUnitCheck
+    {
+        public:
+            explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (u->GetReactionTo(me) > REP_NEUTRAL)
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (!u->IsVisible())
+                    return false;
+                if (me->getVictim() == u && u->getVictim() == me)
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                    (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                    return false;
+                //most horrible hacks
+                if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                    u->GetCreatureType() != CREATURE_TYPE_DEMON && 
+                    (m_spellId == 2812 || m_spellId == 10318 || //holy
+                    m_spellId == 27139 || m_spellId == 48816 || //wra
+                    m_spellId == 48817 ||                       //th or
+                    m_spellId == 10326))                        //turn evil
+                    return false;
+                if (CCed(u))
+                    return false;
+                if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) && 
+                    (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            uint32 m_spellId;
+            UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+    };
+
+    class RootUnitCheck
+    {
+        public:
+            explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+            { if (!spell) return; }
+            bool operator()(Unit* u)
+            {
+                if (u == curtar)
+                    return false;
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (me->GetDistance(u) < 8)
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->IsVisible())
+                    return false;
+                if (!u->isTargetableForAttack())
+                    return false;
+                if (u->GetReactionTo(me) > REP_NEUTRAL)
+                    return false;
+                if (u->isFrozen() || u->isInRoots())
+                    return false;
+                if (!u->getAttackers().empty())
+                    return false;
+                if (u->IsPolymorphed() || 
+                    u->HasAura(51514)/*hex*/ || 
+                    u->HasAura(20066)/*repentance*/ || 
+                    u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackleundead*/)
+                    return false;
+                if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            Unit const *curtar;
+            float m_range;
+            uint32 m_spellId;
+            RootUnitCheck(RootUnitCheck const&);
+    };
+
+    class CastingUnitCheck
+    {
+        public:
+            explicit CastingUnitCheck(Unit const* unit, float dist = 30, bool friendly = false, uint32 spell = 0) : me(unit), m_range(dist), m_friend(friendly), m_spell(spell) { if (!m_spell) return; }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->isAlive())
+                    return false;
+                if (!u->InSamePhase(me))
+                    return false;
+                if (!u->IsVisible())
+                    return false;
+                if (!m_friend && !u->isTargetableForAttack())
+                    return false;
+                //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+                //    return false;
+                if (!u->IsNonMeleeSpellCasted(false))
+                    return false;
+                if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                    return false;
+                if (m_spell == 10326 && //turn evil
+                    u->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                    u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                    return false;
+                if (m_spell == 20066 && //repentance
+                    !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID || 
+                    u->GetCreatureType() == CREATURE_TYPE_DEMON || 
+                    u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN || 
+                    u->GetCreatureType() == CREATURE_TYPE_GIANT || 
+                    u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                    return false;
+                if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            bool m_friend;
+            uint32 m_spell;
+            CastingUnitCheck(CastingUnitCheck const&);
+    };
+
+    class SecondEnemyCheck
+    {
+        public:
+            explicit SecondEnemyCheck(Unit const* unit, float dist, Unit const* currtarget, bot_ai const *m_ai) : me(unit), m_range(dist), mytar(currtarget), ai(m_ai) {}
+            bool operator()(Unit* u)
+            {
+                if (u == mytar)
+                    return false;//We need to find SECONDARY target
+                if (!u->isInCombat())
+                    return false;
+                if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                    return false;
+                if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                    return false;
+                if (mytar->GetDistance(u) > 4)//not close enough to each other
+                    return false;
+
+                if (ai->CanBotAttack(u))
+                    return true;
+
+                return false;
+            }
+        private:
+            Unit const *me;
+            float m_range;
+            Unit const* mytar;
+            bot_ai const *ai;
+            SecondEnemyCheck(SecondEnemyCheck const&);
+    };
+
+    class NearestHostileUnitCheck
+    {
+        public:
+            explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const *m_ai, bool targetCCed = false) : 
+            me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed) { }
+            bool operator()(Unit* u)
+            {
+                if (!me->IsWithinDistInMap(u, m_range))
+                    return false;
+                if (!u->isInCombat())
+                    return false;
+                if (!ai->CanBotAttack(u, byspell))
+                    return false;
+                if (ai->InDuel(u))
+                    return false;
+                if (!(ai->IsInBotParty(u->getVictim()) || (u->getThreatManager().getThreat(const_cast<Unit*>(me)) > 0.f && u->HasUnitState(UNIT_STATE_FLEEING))))
+                    return false;
+                if (!AttackCCed && CCed(u))
+                    return false;//do not allow CCed units if checked
+
+                m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+                return true;
+            }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const *ai;
+        bool AttackCCed;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+    };
+};
+#endif
\ No newline at end of file
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..f394be0
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1092 @@
+#include "bot_ai.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new bot_druid_ai(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_ai
+    {
+        bot_druid_ai(Creature *c) : bot_ai(c) { }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (!spellId) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (Feasting() && spellId != REVIVE && spellId != REBIRTH && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (InDuel(victim)) return false;
+            if (spellId != MANAPOTION && me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED)) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            if (me->GetShapeshiftForm() != FORM_NONE && info->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            {
+                removeFeralForm(true, true);
+                //sLog->outError("bot_druid_ai::doCast(): calls removeFeralForm(), spellId = %u, target = '%s'", spellId, victim->GetName());
+            }
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            if (me->GetShapeshiftForm() == FORM_CAT)
+                value = int32(1000.f - 1000.f * (float(GetHaste()) / 100.f));
+            else
+                value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+
+            if (swiftness && sSpellMgr->GetSpellInfo(spellId)->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == BEAR_FORM || spellId == CAT_FORM)
+            {
+                me->ModifyPower(POWER_MANA, - int32(sSpellMgr->GetSpellInfo(spellId)->CalcPowerCost(me, sSpellMgr->GetSpellInfo(spellId)->GetSchoolMask())));
+                mana = me->GetPower(POWER_MANA);
+                if (Unit *u = me->getVictim())
+                    GetInPosition(true, false, u);
+            }
+
+            DoCast(victim, spellId, triggered);
+
+            if (spellId != BEAR_FORM && spellId != CAT_FORM && 
+                spellId != MANAPOTION && spellId != WARSTOMP && 
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = info->CalcPowerCost(me, info->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return true;
+        }
+
+        void Aggro(Unit *){}
+        void AttackStart(Unit *) { }
+        void KilledUnit(Unit *) { }
+        void EnterEvadeMode() { }
+        void EnterCombat(Unit*) { }
+        void JustDied(Unit *) { removeFeralForm(true, false); master->SetNpcBotDied(me->GetGUID()); }
+
+        void warstomp(const uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (Warstomp_Timer > diff) return;
+            if (me->GetShapeshiftForm() != FORM_NONE)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit *u = me->SelectNearestTarget(5);
+                if (u && u->isInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP))
+                    {
+                        Warstomp_Timer = 30000; //30sec
+                        return;
+                    }
+                }
+            }
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(me, WARSTOMP))
+                        Warstomp_Timer = 30000; //30sec
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            //if (master->IsPlayerbot() && master->getAttackers().size() > 2)
+            //    return false;
+
+            if (Group *pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit *u = master->getVictim();
+            if (master->getAttackers().size() > 4 || 
+              (!master->getAttackers().empty() && 
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool force = false, bool init = true, const uint32 diff = 0)
+        {
+            if (!force && formtimer > diff) return;
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                case FORM_DIREBEAR:
+                case FORM_BEAR:
+                    me->RemoveAurasDueToSpell(BEAR_FORM);
+                    break;
+                case FORM_CAT:
+                    me->RemoveAurasDueToSpell(CAT_FORM);
+                    me->RemoveAurasDueToSpell(ENERGIZE);
+                    break;
+                default:
+                    break;
+                }
+                SetStats(CLASS_DRUID, init);
+            }
+        }
+
+        void StartAttack(Unit *u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u); 
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, me->GetShapeshiftForm() == FORM_NONE);
+        }
+
+        void doBearActions(const uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                HealTarget(me, GetHealthPCT(me), diff);
+            opponent = me->getVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (MangleB_Timer <= diff && rage >= 200 && doCast(opponent, MANGLE_BEAR))
+            {
+                MangleB_Timer = 6000 - me->getLevel()/4 * 100;
+                return;
+            }
+
+            if (GC_Timer <= diff && rage >= 200 && doCast(opponent, SWIPE))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(const uint32 diff)
+        {
+            if (GetHealthPCT(me) < 75)
+                HealTarget(me, GetHealthPCT(me), diff);
+            opponent = me->getVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //{ wait = 5; return; }
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (Mangle_Cat_Timer <= diff && energy > 45 && doCast(opponent, MANGLE_CAT))
+                Mangle_Cat_Timer = 6000;
+            if (Rake_Timer <= diff && energy > 40 && doCast(opponent, RAKE))
+                Rake_Timer = 10000;
+            if (Shred_Timer <= diff && energy > 60 && !opponent->HasInArc(M_PI, me) && doCast(opponent, SHRED))
+                Shred_Timer = 12000;
+            if (Rip_Timer <= diff && energy > 30 && doCast(opponent, RIP))
+                Rip_Timer = 15000;
+            if (Claw_Timer <= diff && energy > 45 && doCast(opponent, CLAW))
+                Claw_Timer = GC_Timer;
+        }//end doCatActions
+
+        void doBalanceActions(const uint32 diff)
+        {
+            removeFeralForm(true, true);
+            opponent = me->getVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check (melee) to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (HURRICANE && Hurricane_Timer <= diff && GC_Timer <= diff && Rand() > 35 && !IsCasting())
+            {
+                Unit *target = FindAOETarget(30, true);
+                if (target && doCast(target, HURRICANE))
+                {
+                    Hurricane_Timer = 5000;
+                    return;
+                }
+                Hurricane_Timer = 2000;//fail
+            }
+            if (GC_Timer <= diff && !opponent->HasAura(FAIRIE_FIRE))
+                if (doCast(opponent, FAIRIE_FIRE))
+                    return;
+            if (Rand() > 30 && Moonfire_Timer <= diff && GC_Timer <= diff && 
+                !opponent->HasAura(MOONFIRE, me->GetGUID()))
+                if (doCast(opponent, MOONFIRE))
+                {
+                    Moonfire_Timer = 5000;
+                    return;
+                }
+            if (Rand() > 30 && Starfire_Timer <= diff && GC_Timer <= diff && 
+                doCast(opponent, STARFIRE))
+            {
+                Starfire_Timer = 11000;
+                return;
+            }
+            if (Rand() > 50 && Wrath_Timer <= diff && GC_Timer <= diff && 
+                doCast(opponent, WRATH))
+            {
+                Wrath_Timer = uint32(sSpellMgr->GetSpellInfo(WRATH)->CalcCastTime()/100 * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 1);
+                return;
+            }
+        }
+
+        bool MassGroupHeal(Player *gPlayer, const uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff) return false;
+            if (!TRANQUILITY && !WILD_GROWTH) return false;
+            if (Tranquility_Timer > diff && Wild_Growth_Timer > diff) return false;
+            if (Rand() > 30) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            Group *pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit *healTarget = NULL;
+            for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player *tPlayer = itr->getSource();
+                if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature *bot = tPlayer->GetBotMap()[i]._Cre();
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && TRANQUILITY && Tranquility_Timer <= diff && 
+                doCast(me, TRANQUILITY))
+                { Tranquility_Timer = 45000; return true; }
+            if (LHPcount > 0 && WILD_GROWTH && Wild_Growth_Timer <= diff && 
+                doCast(healTarget, WILD_GROWTH))
+                { Wild_Growth_Timer = 6000; return true; }
+            return false;
+        }//end MassGroupHeal
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if ((me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR) && 
+                me->getPowerType() != POWER_RAGE)
+                me->setPowerType(POWER_RAGE);
+            if (me->GetShapeshiftForm() == CAT && me->getPowerType() != POWER_ENERGY)
+                me->setPowerType(POWER_ENERGY);
+            if (me->GetShapeshiftForm() == FORM_NONE && me->getPowerType() != POWER_MANA)
+                me->setPowerType(POWER_MANA);
+            if (IAmDead()) return;
+            if (!me->getVictim())
+                Evade();
+            if (me->GetShapeshiftForm() == FORM_DIREBEAR || me->GetShapeshiftForm() == FORM_BEAR)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer2 <= diff)
+                {
+                    if (me->isInCombat() && me->getLevel() >= 30)
+                    {
+                        if (rage < 990 && rage >= 0)
+                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000);//max
+                    }
+                    ragetimer2 = 2000;
+                }
+                if (ragetimer <= diff)
+                {
+                    if (!me->isInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);//min
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            if (INNERVATE && Innervate_Timer <= diff && GC_Timer <= diff)
+            {
+                doInnervate();
+                if (Innervate_Timer <= diff)//if failed or not found target
+                    Innervate_Timer = 3000;//set delay
+            }
+
+            MassGroupHeal(master, diff);
+            if (!me->isInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            CureTarget(master, CURE_POISON, diff);
+            CureGroup(master, CURE_POISON, diff);
+
+            if (!CheckAttackTarget(CLASS_DRUID))
+                return;
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting()) return;//Casting heal or something
+            CheckRoots(diff);
+
+            if (DamagePossible())
+            {
+                Unit *u = opponent->getVictim();
+                //if the target is attacking us, we want to go bear
+                if (BEAR_FORM && !CCed(opponent) && 
+                    (u == me || (tank == me && IsInBotParty(u))) || 
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_DIREBEAR && 
+                        me->GetShapeshiftForm() != FORM_BEAR && 
+                        formtimer <= diff && 
+                        doCast(me, BEAR_FORM))
+                    {
+                        SetStats(BEAR);
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_DIREBEAR || 
+                        me->GetShapeshiftForm() == FORM_BEAR)
+                    {
+                        doBearActions(diff);
+                        ScriptedAI::UpdateAI(diff);
+                    }
+                }
+                else
+                if (CAT_FORM && master->getVictim() != opponent && tank && 
+                    u == tank && u != me && 
+                    opponent->GetMaxHealth() < tank->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, CAT_FORM))
+                        {
+                            SetStats(CAT);
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                    {
+                        doCatActions(diff);
+                        ScriptedAI::UpdateAI(diff);
+                    }
+                }
+                else if (tank != me)
+                {
+                    doBalanceActions(diff);
+                }
+            }
+            else if (tank != me)
+            {
+                doBalanceActions(diff);
+            }
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, const uint32 diff)
+        {
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (tank == me && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false;//do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->isInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            if ((hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) && 
+                Nature_Swiftness_Timer <= diff && (target->isInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (NATURES_SWIFTNESS && doCast(me, NATURES_SWIFTNESS) && RefreshAura(CRIT_50, 2))//need to be critical
+                {
+                    swiftness = true;
+                    if (doCast(target, HEALING_TOUCH, true))
+                    {
+                        Nature_Swiftness_Timer = 120000;//2 min
+                        Heal_Timer = 3000;
+                        return true;
+                    }
+                }
+            }
+            if (SWIFTMEND && (hp < 25 || GetLostHP(target) > 5000) && Swiftmend_Timer <= 3000 && 
+                (HasAuraName(target, REGROWTH) || HasAuraName(target, REJUVENATION)))
+            {
+                if (doCast(target, SWIFTMEND))
+                {
+                    Swiftmend_Timer = 10000;
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, REGROWTH))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && NOURISH)
+            {
+                switch (urand(1,3))
+                {
+                case 1:
+                case 2:
+                    if (doCast(target, NOURISH))
+                    { Heal_Timer = 3000; return true; }
+                    break;
+                case 3:
+                    if (doCast(target, HEALING_TOUCH))
+                    { Heal_Timer = 3000; return true; }
+                    break;
+                }
+            }
+            //maintain HoTs
+            Unit *u = target->getVictim();
+            Creature *boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = tank == target && boss;
+            if (( (hp < 80 || GetLostHP(target) > 3500 || tanking) && 
+                Regrowth_Timer <= diff && GC_Timer <= diff && !target->HasAura(REGROWTH, me->GetGUID()) )
+                || 
+                (target->HasAura(REGROWTH, me->GetGUID()) && target->HasAura(REJUVENATION, me->GetGUID()) && 
+                (hp < 70 || GetLostHP(target) > 3000) && Regrowth_Timer <= diff && GC_Timer <= diff))
+            {
+                if (doCast(target, REGROWTH))
+                { Regrowth_Timer = 2000; return true; }
+            }
+            if (hp > 25 && (hp < 90 || GetLostHP(target) > 2000 || tanking) && GC_Timer <= diff && 
+                !HasAuraName(target, REJUVENATION, me->GetGUID()))
+            {
+                if (doCast(target, REJUVENATION))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (SWIFTMEND && Swiftmend_Timer <= diff && doCast(target, SWIFTMEND))
+                            Swiftmend_Timer = 10000;
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (LIFEBLOOM != 0 && GC_Timer <= diff && 
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) || 
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH) && HasAuraName(target, REJUVENATION)) || 
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura *bloom = target->GetAura(LIFEBLOOM, me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, LIFEBLOOM))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff && 
+                doCast(target, HEALING_TOUCH))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit *target, const uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 40) return false;
+            if (me->isInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (target && target->isAlive() && me->GetExactDist(target) < 30)
+            {
+                if (!HasAuraName(target, MARK_OF_THE_WILD))
+                    if (doCast(target, MARK_OF_THE_WILD))
+                        return true;
+                if (!HasAuraName(target, THORNS))
+                    if (doCast(target, THORNS))
+                        return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(const uint32 diff)
+        {
+            //if eating or drinking don't do anything
+            if (GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(REVIVE, master);
+
+            if (Feasting()) return;
+
+            if (BuffTarget(master, diff))
+            {
+                /*GC_Timer = 800;*/
+                return;
+            }
+            if (BuffTarget(me, diff))
+            {
+                /*GC_Timer = 800;*/
+                return;
+            }
+        }
+
+        void doInnervate(uint8 minmanaval = 30)
+        {
+            Unit *iTarget = NULL;
+
+            if (GetManaPCT(master) < 20)
+                iTarget = master;
+            else if (GetManaPCT(me) < 20)
+                iTarget = me;
+
+            Group *group = master->GetGroup();
+            if (!iTarget && !group)//first check master's bots
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    Creature *bot = master->GetBotMap()[i]._Cre();
+                    if (!bot || bot->isDead()) continue;
+                    if (me->GetExactDist(bot) > 30) continue;
+                    if (GetManaPCT(bot) < minmanaval)
+                    {
+                        iTarget = bot;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget)//cycle through player members...
+            {
+                for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (tPlayer == NULL || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (GetManaPCT(tPlayer) < minmanaval)
+                    {
+                        iTarget = tPlayer;
+                        break;
+                    }
+                }
+            }
+            if (!iTarget)//... and their bots.
+            {
+                for (GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature *bot = tPlayer->GetBotMap()[i]._Cre();
+                        if (!bot || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (GetManaPCT(bot) < minmanaval)
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+            }
+            
+            if (iTarget && !iTarget->HasAura(INNERVATE) && doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    me->MonsterWhisper("Innervate on You!", iTarget->GetGUID());
+                Innervate_Timer = iTarget->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000;//1 min if player and 30 sec if bot
+            }
+        }
+
+        void CheckRoots(const uint32 diff)
+        {
+            if (!ENTANGLING_ROOTS || GC_Timer > diff) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit *target = FindRootTarget(30, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(const uint32 diff)
+        {
+            if (!REBIRTH || Rebirth_Timer > diff || Rand() > 10 || IsCasting() || me->IsMounted()) return;
+            Group *gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit *target = master;
+                if (master->isAlive()) return;
+                if (master->isRessurectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    Rebirth_Timer = 1500;
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, REBIRTH))//rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", master->GetGUID());
+                    Rebirth_Timer = me->getLevel() >= 60 ? 300000 : 600000; //5-10 min (improved possible)
+                }
+                return;
+            }
+            for (GroupReference *itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player *tPlayer = itr->getSource();
+                Unit *target = tPlayer;
+                if (!tPlayer || tPlayer->isAlive()) continue;
+                if (tPlayer->isRessurectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (master->GetMap() != target->GetMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    Rebirth_Timer = 1500;
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, REBIRTH))//rezzing
+                {
+                    me->MonsterWhisper("Rezzing You", tPlayer->GetGUID());
+                    Rebirth_Timer = me->getLevel() >= 60 ? 300000 : 600000; //5-10 min (improved possible)
+                    return;
+                }
+            }
+        }
+
+        void SetStats(uint8 form, bool init = true)
+        {
+            switch(form)
+            {
+            case BEAR:
+                me->SetBotClass(BEAR);
+                if (me->getPowerType() != POWER_RAGE)
+                {
+                    me->setPowerType(POWER_RAGE);
+                    me->SetMaxPower(POWER_RAGE, 1000);
+                }
+                if (me->getLevel() >= 15)
+                    me->SetPower(POWER_RAGE, 200);
+                else
+                    me->SetPower(POWER_RAGE, 0);
+                if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                    RefreshAura(LEADER_OF_THE_PACK);
+                setStats(BEAR, me->getRace(), master->getLevel());
+                break;
+            case CAT:
+                me->SetBotClass(CAT);
+                if (me->getPowerType() != POWER_ENERGY)
+                {
+                    me->setPowerType(POWER_ENERGY);
+                    me->SetMaxPower(POWER_ENERGY, 100);
+                    me->SetPower(POWER_ENERGY, 0);
+                }
+                if (me->getLevel() >= 15)
+                    me->SetPower(POWER_ENERGY, 60);
+                else
+                    me->SetPower(POWER_ENERGY, 0);
+                if (me->getLevel() >= 40 && !me->HasAura(LEADER_OF_THE_PACK))
+                    RefreshAura(LEADER_OF_THE_PACK);
+                RefreshAura(ENERGIZE, me->getLevel()/40 + master->Has310Flyer(false));
+                setStats(CAT, me->getRace(), master->getLevel());
+                break;
+            case CLASS_DRUID:
+                me->SetBotClass(CLASS_DRUID);
+                if (me->getPowerType() != POWER_MANA)
+                    me->setPowerType(POWER_MANA);
+                if (init)
+                    me->SetPower(POWER_MANA, mana);
+                setStats(CLASS_DRUID, me->getRace(), master->getLevel());
+                break;
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Regrowth_Timer = 0;
+            Swiftmend_Timer = 0;
+            Wild_Growth_Timer = 0;
+            Tranquility_Timer = 0;
+            Nature_Swiftness_Timer = 0;
+            Rebirth_Timer = 0;
+            Warstomp_Timer = 0;
+            MangleB_Timer = 0;
+            Claw_Timer = 0;
+            Rake_Timer = 0;
+            Shred_Timer = 0;
+            Rip_Timer = 0;
+            Mangle_Cat_Timer = 0;
+            Moonfire_Timer = 0;
+            Starfire_Timer = 0;
+            Wrath_Timer = 0;
+            Hurricane_Timer = 0;
+            Innervate_Timer = 0;
+            formtimer = 0;
+            clearcast = false;
+            swiftness = false;
+            power = POWER_MANA;
+            mana = 0;
+            rage = 0;
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            ragetimer = 0;
+            ragetimer2 = 0;
+        
+            if (master)
+            {
+                setStats(CLASS_DRUID, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_DRUID);
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (MangleB_Timer > diff)               MangleB_Timer -= diff;
+            if (Claw_Timer > diff)                  Claw_Timer -= diff;
+            if (Rake_Timer > diff)                  Rake_Timer -= diff;
+            if (Shred_Timer > diff)                 Shred_Timer -= diff;
+            if (Mangle_Cat_Timer > diff)            Mangle_Cat_Timer -= diff;
+            if (Moonfire_Timer > diff)              Moonfire_Timer -= diff;
+            if (Starfire_Timer > diff)              Starfire_Timer -= diff;
+            if (Wrath_Timer > diff)                 Wrath_Timer -= diff;
+            if (Hurricane_Timer > diff)             Hurricane_Timer -= diff;
+            if (Innervate_Timer > diff)             Innervate_Timer -= diff;
+            if (Rip_Timer > diff)                   Rip_Timer -= diff;
+            if (Regrowth_Timer > diff)              Regrowth_Timer -= diff;
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Swiftmend_Timer > diff)             Swiftmend_Timer -= diff;
+            if (Wild_Growth_Timer > diff)           Wild_Growth_Timer -= diff;
+            if (Nature_Swiftness_Timer > diff)      Nature_Swiftness_Timer -= diff;
+            if (Tranquility_Timer > diff)           Tranquility_Timer -= diff;
+            if (Rebirth_Timer > diff)               Rebirth_Timer -= diff;
+            if (Warstomp_Timer > diff)              Warstomp_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            MARK_OF_THE_WILD                        = InitSpell(MARK_OF_THE_WILD_1);
+            THORNS                                  = InitSpell(THORNS_1);
+            HEALING_TOUCH                           = InitSpell(HEALING_TOUCH_1);
+            REGROWTH                                = InitSpell(REGROWTH_1);
+            REJUVENATION                            = InitSpell(REJUVENATION_1);
+            LIFEBLOOM                               = InitSpell(LIFEBLOOM_1);
+            NOURISH                                 = InitSpell(NOURISH_1);
+     /*tal*/WILD_GROWTH                 = lvl >= 60 ? InitSpell(WILD_GROWTH_1) : 0;
+     /*tal*/SWIFTMEND                   = lvl >= 40 ? InitSpell(SWIFTMEND_1) : 0;
+            TRANQUILITY                             = InitSpell(TRANQUILITY_1);
+            REVIVE                                  = InitSpell(REVIVE_1);
+            REBIRTH                                 = InitSpell(REBIRTH_1);
+            BEAR_FORM                               = InitSpell(BEAR_FORM_1);
+            SWIPE                                   = InitSpell(SWIPE_1);
+     /*tal*/MANGLE_BEAR                 = lvl >= 50 ? InitSpell(MANGLE_BEAR_1) : 0;
+            BASH                                    = InitSpell(BASH_1);
+            CAT_FORM                                = InitSpell(CAT_FORM_1);
+            CLAW                                    = InitSpell(CLAW_1);
+            RAKE                                    = InitSpell(RAKE_1);
+            SHRED                                   = InitSpell(SHRED_1);
+            RIP                                     = InitSpell(RIP_1);
+     /*tal*/MANGLE_CAT                  = lvl >= 50 ? InitSpell(MANGLE_CAT_1) : 0;
+            MOONFIRE                                = InitSpell(MOONFIRE_1);
+            STARFIRE                                = InitSpell(STARFIRE_1);
+            WRATH                                   = InitSpell(WRATH_1);
+            HURRICANE                               = InitSpell(HURRICANE_1);
+            FAIRIE_FIRE                             = InitSpell(FAIRIE_FIRE_1);
+            CURE_POISON                             = InitSpell(CURE_POISON_1);
+            INNERVATE                               = InitSpell(INNERVATE_1);
+            ENTANGLING_ROOTS                        = InitSpell(ENTANGLING_ROOTS_1);
+     /*tal*/NATURES_SWIFTNESS           = lvl >= 30 ? InitSpell(NATURES_SWIFTNESS_1) : 0;
+            WARSTOMP                                = WARSTOMP_1;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 78)
+                RefreshAura(SPELLDMG2, 3); //+18%
+            else if (level >= 65)
+                RefreshAura(SPELLDMG2, 2); //+12%
+            else if (level >= 50)
+                RefreshAura(SPELLDMG2); //+6%
+            if (level >= 45)
+                RefreshAura(NATURAL_PERFECTION3); //4%
+            else if (level >= 43)
+                RefreshAura(NATURAL_PERFECTION2); //3%
+            else if (level >= 41)
+                RefreshAura(NATURAL_PERFECTION1); //2%
+            if (level >= 50)
+                RefreshAura(LIVING_SEED3); //100%
+            else if (level >= 48)
+                RefreshAura(LIVING_SEED2); //66%
+            else if (level >= 46)
+                RefreshAura(LIVING_SEED1); //33%
+            if (level >= 55)
+                RefreshAura(REVITALIZE3, 5); //75% (15%)x5
+            else if (level >= 53)
+                RefreshAura(REVITALIZE2, 3); //30% (10%)x3
+            else if (level >= 51)
+                RefreshAura(REVITALIZE1, 3); //15%  (5%)x3
+            if (level >= 70)
+                RefreshAura(OMEN_OF_CLARITY, 3); //x3
+            else if (level >= 40)
+                RefreshAura(OMEN_OF_CLARITY, 2); //x2
+            else if (level >= 20)
+                RefreshAura(OMEN_OF_CLARITY); //x1
+            if (level >= 45)
+                RefreshAura(GLYPH_SWIFTMEND); //no comsumption
+            if (level >= 40)
+                RefreshAura(GLYPH_INNERVATE); //no comsumption
+            if (level >= 20)
+                RefreshAura(NATURESGRACE);
+            if (level >= 78)
+            {
+                RefreshAura(T9_RESTO_P4_BONUS);
+                RefreshAura(T8_RESTO_P4_BONUS);
+                RefreshAura(T9_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P2_BONUS);
+                RefreshAura(T10_BALANCE_P4_BONUS);
+            }
+        }
+
+    private:
+        uint32
+   /*Buffs*/MARK_OF_THE_WILD, THORNS, 
+/*Heal/Rez*/HEALING_TOUCH, REGROWTH, REJUVENATION, LIFEBLOOM, NOURISH, WILD_GROWTH, SWIFTMEND, TRANQUILITY, REVIVE, REBIRTH, 
+    /*Bear*/BEAR_FORM, SWIPE, MANGLE_BEAR, BASH, 
+     /*Cat*/CAT_FORM, CLAW, RAKE, SHRED, RIP, MANGLE_CAT, 
+ /*Balance*/MOONFIRE, STARFIRE, WRATH, HURRICANE, FAIRIE_FIRE, 
+    /*Misc*/CURE_POISON, INNERVATE, ENTANGLING_ROOTS, NATURES_SWIFTNESS, WARSTOMP;
+        //Timers/other
+/*Heal*/uint32 Heal_Timer, Regrowth_Timer, Swiftmend_Timer, Wild_Growth_Timer,
+/*Heal*/    Tranquility_Timer, Nature_Swiftness_Timer, Rebirth_Timer;
+/*Bear*/uint32 MangleB_Timer;
+/*Cat*/ uint32 Claw_Timer, Rake_Timer, Shred_Timer, Rip_Timer, Mangle_Cat_Timer;
+/*Bal*/ uint32 Moonfire_Timer, Starfire_Timer, Wrath_Timer, Hurricane_Timer, Innervate_Timer;
+/*Misc*/uint32 formtimer, ragetimer, ragetimer2, Warstomp_Timer;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power; uint32 mana, rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 55428,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211,
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAIRIE_FIRE_1                       = 770,
+            CURE_POISON_1                       = 8946,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549,
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            REVITALIZE3                         = 48545,//rank 3
+  /*Talent*/LEADER_OF_THE_PACK                  = 24932,
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal 
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434,//50% spell crit
+        };
+        enum DruidSpecial
+        {
+            //NATURESGRACEBUFF                    = 16886,
+            OMEN_OF_CLARITY_BUFF                = 16870,
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..04fb08e
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,342 @@
+#include "bot_ai.h"
+
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new hunter_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct hunter_botAI : public bot_ai
+    {
+        hunter_botAI(Creature *c) :bot_ai(c)
+        {
+            Reset();
+        }
+
+        //void CreatePet()
+        //{
+
+        //    pet = me->GetBotsPet(60238);
+
+        //    if (pet == NULL)
+        //        return;
+
+        //    pet->UpdateCharmAI();
+        //    pet->setFaction(me->getFaction());
+        //    pet->SetReactState(REACT_DEFENSIVE);
+        //    pet->GetMotionMaster()->MoveFollow(me, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+        //    CharmInfo *charmInfonewbot = pet->InitCharmInfo();
+        //    pet->GetCharmInfo()->SetCommandState(COMMAND_FOLLOW);
+        //    pet->UpdateStats(STAT_STRENGTH);
+        //    pet->UpdateStats(STAT_AGILITY);
+        //    pet->SetLevel(master->getLevel());
+
+        //    /*float val2 = master->getLevel()*4.f + pet->GetStat(STAT_STRENGTH)*5.f;
+
+        //    val2=100.0;
+        //    uint32 attPowerMultiplier=1;
+        //    pet->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, uint32(val2));
+        //    pet->UpdateAttackPowerAndDamage();
+        //    pet->SetBaseWeaponDamage(BASE_ATTACK, MINDAMAGE, uint32(val2 * attPowerMultiplier));
+        //    pet->SetBaseWeaponDamage(BASE_ATTACK, MAXDAMAGE, uint32(val2 * attPowerMultiplier)*3+master->getLevel());
+        //    pet->UpdateDamagePhysical(BASE_ATTACK);*/
+
+        //}
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (me->IsMounted()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (me->HasUnitState(UNIT_STATE_CASTING)) return false;
+            if (Feasting() && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (me->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != MANAPOTION && spellId != HEALINGPOTION && spellId != AUTO_SHOT) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void EnterEvadeMode() { }
+        void Aggro(Unit *){}
+        void JustDied(Unit *) { master->SetNpcBotDied(me->GetGUID()); }
+        void KilledUnit(Unit *) { }
+        void AttackStart(Unit *) { }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+
+            if (IAmDead()) return;
+
+            if (!me->isInCombat())
+                DoNonCombatActions(diff);
+
+            //if (pet && pet != NULL && pet->isDead())
+            //{
+            //    me->SetBotsPetDied();
+            //    pet = NULL;
+            //}
+
+            //if we think we have a pet, but master doesn't, it means we teleported
+            //if (pet && !me->getBotsPet())
+            //{
+            //    me->SetBotsPetDied();
+            //    pet = NULL;
+            //}
+
+            DoNormalAttack(diff);
+            ScriptedAI::UpdateAI(diff);
+
+            //if low on health, drink a potion
+            if (GetHealthPCT(me) < 65)
+            {
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            //if low on mana, drink a potion
+            if (GetManaPCT(me) < 65 && Potion_cd <= diff)
+            {
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            opponent = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+            if (!opponent && !me->getVictim())
+            {
+                me->CombatStop();
+                //ResetOrGetNextTarget();
+
+                //to reduce the number of crashes, remove pet whenever we are not in combat
+                //if (pet != NULL && pet->isAlive())
+                //{
+                //    me->SetBotsPetDied();
+                //    pet = NULL;
+                //}
+                return;
+            }
+
+            //if (pet == NULL)
+            //    CreatePet();
+
+            //if (pet && pet->isAlive() &&
+            //    !pet->isInCombat() &&
+            //    me->getVictim())
+            //{
+            //    pet->Attack (me->getVictim(), true);
+            //    pet->GetMotionMaster()->MoveChase(me->getVictim(), 1, 0);
+            //}
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            if (!opponent || opponent->isDead()) return;
+
+            // try to get rid of enrage effect
+            if (TRANQ_SHOT && (HasAuraName(opponent, "Enrage") || (HasAuraName(opponent, "Frenzy")))) 
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                me->MonsterSay("Tranquil shot!", LANG_UNIVERSAL, NULL);
+                doCast(opponent, TRANQ_SHOT, true);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // silence it
+            if (SILENCING_SHOT && opponent->HasUnitState(UNIT_STATE_CASTING) && SilencingShot_Timer <= diff)
+            {
+                doCast(opponent, SILENCING_SHOT);
+                SilencingShot_Timer = 25000;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // mark it
+            if (!HasAuraName(opponent, "Hunter's Mark"))
+            {
+                doCast(opponent, HUNTERS_MARK);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            // sting it
+            if (SCORPID_STING && !opponent->HasAura(SCORPID_STING, me->GetGUID())) 
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, SCORPID_STING);
+               // me->MonsterSay("Scorpid Sting!", LANG_UNIVERSAL, NULL);
+               // doCast(opponent, AUTO_SHOT);
+               // return;
+            }
+
+             if (CHIMERA_SHOT && ChimeraShot_Timer <= diff && GC_Timer <= diff)
+             {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, CHIMERA_SHOT);
+                ChimeraShot_Timer = 10000;
+               // me->MonsterSay("Chimera Sting!", LANG_UNIVERSAL, NULL);
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if (ARCANE_SHOT && ArcaneShot_cd <= diff && GC_Timer <= diff)
+            {
+                me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                doCast(opponent, ARCANE_SHOT);
+               // me->MonsterSay("Arcane shot!", LANG_UNIVERSAL, NULL);
+                ArcaneShot_cd = 60;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+
+            if (AIMED_SHOT && AimedShot_Timer <= diff && GC_Timer <= diff)
+            {
+                me->InterruptNonMeleeSpells( true, AUTO_SHOT );
+                doCast(opponent, AIMED_SHOT);
+               // me->MonsterSay("Aimed shot!", LANG_UNIVERSAL, NULL);
+                AimedShot_Timer = 120;
+              //  doCast(opponent, AUTO_SHOT);
+              //  return;
+            }
+            //Temp Feign death For Debug
+            AttackerSet b_attackers = me->getAttackers();
+            if (!b_attackers.empty())
+            {
+            for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                if (*iter && (*iter)->getVictim()->GetGUID() == me->GetGUID() && 
+                    me->GetDistance(*iter) < 10 && 
+                    Feign_Death_Timer <= diff && GC_Timer <= diff)
+                {
+                    doCast(me, FEIGN_DEATH, true);
+                    opponent->AddThreat(me, -100000);
+                    me->CombatStop();
+                    Feign_Death_Timer = 25000;
+                    me->CombatStart(opponent);
+                }
+            }
+
+            doCast(opponent, AUTO_SHOT);
+        }
+
+        void DoNonCombatActions(const uint32 /*diff*/)
+        {
+            //if (ASPECT_OF_THE_DRAGONHAWK && 
+            //    !HasAuraName(me, "Aspect of the Dragonhawk") && 
+            //    doCast(master, ASPECT_OF_THE_DRAGONHAWK))
+            //    me->AddAura(ASPECT_OF_THE_DRAGONHAWK, me);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            ArcaneShot_cd = 0;
+            ChimeraShot_Timer = 0;
+            SilencingShot_Timer = 0;
+            AimedShot_Timer = 0;
+            Feign_Death_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_HUNTER, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_HUNTER);
+             }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (ArcaneShot_cd > diff)               ArcaneShot_cd -= diff;
+            if (ChimeraShot_Timer > diff)           ChimeraShot_Timer -= diff;
+            if (SilencingShot_Timer > diff)         SilencingShot_Timer -= diff;
+            if (AimedShot_Timer > diff)             AimedShot_Timer -= diff;
+            if (Feign_Death_Timer > diff)           Feign_Death_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            AUTO_SHOT                               = AUTO_SHOT_1;
+            TRANQ_SHOT                              = InitSpell(TRANQ_SHOT_1);
+            SCORPID_STING                           = InitSpell(SCORPID_STING_1);
+            HUNTERS_MARK                            = InitSpell(HUNTERS_MARK_1);
+            ARCANE_SHOT                             = InitSpell(ARCANE_SHOT_1);
+            CHIMERA_SHOT                = lvl >= 60 ? CHIMERA_SHOT_1 : 0;
+            AIMED_SHOT                  = lvl >= 20 ? InitSpell(AIMED_SHOT_1) : 0;
+            SILENCING_SHOT              = lvl >= 50 ? SILENCING_SHOT_1 : 0;
+            ASPECT_OF_THE_DRAGONHAWK                = InitSpell(ASPECT_OF_THE_DRAGONHAWK_1);
+            FEIGN_DEATH                             = InitSpell(FEIGN_DEATH_1);
+        }
+
+        void ApplyClassPassives()
+        { }
+
+    private:
+        uint32
+        AUTO_SHOT, TRANQ_SHOT, SCORPID_STING, HUNTERS_MARK, ARCANE_SHOT, CHIMERA_SHOT, AIMED_SHOT, 
+        SILENCING_SHOT, ASPECT_OF_THE_DRAGONHAWK, FEIGN_DEATH;
+        //Timers
+        uint32 ArcaneShot_cd, ChimeraShot_Timer, SilencingShot_Timer, AimedShot_Timer, Feign_Death_Timer;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SCORPID_STING_1                     = 3043,
+            HUNTERS_MARK_1                      = 14325,
+            ARCANE_SHOT_1                       = 3044,
+            CHIMERA_SHOT_1                      = 53209,
+            AIMED_SHOT_1                        = 19434,
+            SILENCING_SHOT_1                    = 34490,
+            ASPECT_OF_THE_DRAGONHAWK_1          = 61846,
+            FEIGN_DEATH_1                       = 5384,
+        };
+
+        enum HunterPassives
+        {
+        };
+
+        enum HunterSpecial
+        {
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..3886437
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,803 @@
+#include "bot_ai.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new mage_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct mage_botAI : public bot_ai
+    {
+        mage_botAI(Creature *c) : bot_ai(c) { }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (Feasting() && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (InDuel(victim)) return false;
+            if (spellId != MANAPOTION && spellId != HEALINGPOTION && me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED)) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            if (spellId != HEALINGPOTION)
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            if (me->HasAura(CLEARCASTBUFF))
+            {
+                cost = info->CalcPowerCost(me, info->GetSchoolMask());
+                clearcast = true;
+            }
+            return true;
+        }
+
+        void KilledUnit(Unit *) { }
+        void EnterEvadeMode() { }
+        void EnterCombat(Unit*) { }
+        void JustDied(Unit *) { master->SetNpcBotDied(me->GetGUID()); }
+        void Aggro(Unit *) { }
+        void AttackStart(Unit *) { }
+
+        void StartAttack(Unit *u, bool force = false)
+        {
+            if (GetBotCommandState() == (COMMAND_ATTACK) && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, true);
+        }
+
+        void Counter()
+        {
+            Unit *u = me->getVictim();
+            bool cSpell = CounterSpell_cd <= 5000;
+            bool blast = FireBlast_cd <= 3000 && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCasted(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, COUNTERSPELL))
+                    CounterSpell_cd = 15000;
+                else if (blast && doCast(u, FIREBLAST))
+                    FireBlast_cd = 6000;
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit *target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCasted(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, COUNTERSPELL))
+                    {
+                        CounterSpell_cd = 15000;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckSpellSteal(const uint32 diff)
+        {
+            if (!SPELLSTEAL || Rand() > 25 || GC_Timer > diff || IsCasting()) return;
+            Unit *target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, SPELLSTEAL))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(const uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+            if (Feasting()) return;
+
+            if (!HasAuraName(me, DAMPENMAGIC) && 
+                doCast(me, DAMPENMAGIC))
+            { /*GC_Timer = 800;*/ return; }
+
+            if (!HasAuraName(me, ICEARMOR) && 
+                doCast(me, ICEARMOR))
+            { /*GC_Timer = 800;*/ return; }
+        }
+
+        bool BuffTarget(Unit *target, const uint32 diff)
+        {
+            if (GC_Timer > diff || !target || target->isDead() || Rand() > 50) return false;
+            if (me->isInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (target->getPowerType() == POWER_MANA && 
+                !HasAuraName(target, ARCANEINTELLECT) && 
+                doCast(target, ARCANEINTELLECT))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            return false;
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->getVictim())
+                Evade();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCasted(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            if (CCed(me) && (!ICEBLOCK || !me->HasAura(ICEBLOCK))) return;//TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureTarget(master, REMOVE_CURSE, diff);
+            CureTarget(me, REMOVE_CURSE, diff);
+            CureGroup(master, REMOVE_CURSE, diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->isInCombat())
+                DoNonCombatActions(diff);
+            
+            if (!CheckAttackTarget(CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            opponent = me->getVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit *u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            if (ICE_BARRIER && Ice_Barrier_cd <= diff && u && u->getVictim() == me && 
+                u->GetDistance(me) < 8 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    Ice_Barrier_cd = 41000 - me->getLevel()*200;//down to 25 sec on 80
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if ((!ICE_BARRIER || Ice_Barrier_cd > diff) && 
+                BLINK && Blink_cd < 3000 && u && u->getVictim() == me && 
+                !me->HasAura(ICE_BARRIER) && u->GetDistance(me) < 6)
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, BLINK))
+                {
+                    Blink_cd = 15000 - me->getLevel()/4 * 100;
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            if (me->HasAura(ICEBLOCK))
+                if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) && Iceblock_cd <= 57000 && tank)
+                    me->RemoveAurasDueToSpell(ICEBLOCK);
+            //ICEBLOCK
+            if (ICEBLOCK && Rand() < 50 && !b_attackers.empty() && tank && Iceblock_cd <= diff && 
+                (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) && 
+                !me->HasAura(ICEBLOCK))
+            {
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICEBLOCK))
+                {
+                    Iceblock_cd = 60000;
+                    return;
+                }
+            }
+
+            if (IsCasting()) return;
+
+            BOLT = (CCed(opponent, true) || (opponent->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED) && me->HasAura(COMBUSTION))) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FIREBALL && BLASTWAVE ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            float dist = me->GetExactDist(opponent);
+            if (dist > 30)
+                return;
+
+            if (COMBUSTION && Rand() < 15 && 
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*10 || 
+                m_attackers.size() > 1 || b_attackers.size() > 2))
+            {
+                if (!HasAuraName(me, "Combustion") && Combustion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, COMBUSTION))
+                    {
+                        Combustion_cd = 60000;
+                        //Reset timers for fun
+                        Nova_cd = 0; FireBlast_cd = 0; DragonBreath_cd = 0;
+                    }
+                    GC_Timer = temptimer;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (PYROBLAST && Rand() < 75 && Pyroblast_cd <= diff && GC_Timer <= diff && 
+                b_attackers.size() < 2 && dist < 30 && opponent->IsPolymorphed() && 
+                doCast(opponent, PYROBLAST))
+                Pyroblast_cd = 50;
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(7);
+            if (u && NOVA && Nova_cd <= diff && !CCed(u, true) && IsInBotParty(u->getVictim()))
+            {
+                Unit *tar = u->getVictim();
+                if (tar && IsInBotParty(tar) && doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    return;
+                }
+            }
+            //living bomb
+            if (LIVINGBOMB && Rand() < 25 && Living_Bomb_cd <= diff && GC_Timer <= diff && 
+                dist < 30 && opponent->GetHealth() > me->GetHealth()/2 && 
+                !opponent->HasAura(LIVINGBOMB, me->GetGUID()) && 
+                doCast(opponent, LIVINGBOMB))
+            {
+                Living_Bomb_cd = 6000;
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (CONEOFCOLD && ConeofCold_cd <= diff && GC_Timer <= diff && dist < 7 && 
+                me->HasInArc(M_PI, opponent) && 
+                doCast(opponent, CONEOFCOLD))
+            {
+                ConeofCold_cd = 14000;
+                GC_Timer = 500;
+                return;
+            }
+            //dragon's breath
+            u = me->SelectNearestTarget(7);
+            if (DRAGONBREATH && u && DragonBreath_cd <= diff && GC_Timer <= diff && 
+                me->HasInArc(M_PI, opponent) && !HasAuraName(u, FROSTNOVA) && 
+                doCast(opponent, DRAGONBREATH))
+            {
+                DragonBreath_cd = 25000;
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) && 
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) && 
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (FireBlast_cd <= diff && GC_Timer <= diff && dist < 20 && 
+                Rand() < 20 + 80*(!opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)) && 
+                doCast(opponent, FIREBLAST))
+            {
+                FireBlast_cd = 6000;
+                GC_Timer = 500;
+                return;
+            }
+            //flamestrike
+            if (GC_Timer <= diff && Rand() < 60 && me->HasAura(FIRESTARTERBUFF))
+            {
+                Unit *FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, FLAMESTRIKE, true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 0;
+                    return;
+                }
+            }
+            //blizzard
+            if (BLIZZARD && Rand() < 80 && Blizzard_cd <= diff)
+            {
+                Unit *blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, BLIZZARD))
+                {
+                    Blizzard_cd = 5000;
+                    return;
+                }
+                Blizzard_cd = 2000;//fail
+            }
+            //Frost of Fire Bolt
+            if (Rand() < 75 && Bolt_cd <= diff && dist < 30 && 
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                return;
+            }
+            //Arcane Missiles
+            if (Rand() < 10 && GC_Timer <= diff && !me->isMoving() && dist < 20 && 
+                doCast(opponent, ARCANEMISSILES))
+                return;
+        }
+
+        void CheckPoly(const uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(POLYMORPH, me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500)
+            {
+                if (Unit *target = FindPolyTarget(30, me->getVictim()))
+                {
+                    if (doCast(target, POLYMORPH))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer = 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(const uint32 diff)
+        {
+            if (GetHealthPCT(me) < 70 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 35)
+            {
+                if (Evocation_cd <= diff && me->getAttackers().empty() && doCast(me, EVOCATION))
+                    Evocation_cd = 60000;
+                else if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                        Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void CheckBlink(const uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted()) return;
+            if (Blink_cd > diff || me->getLevel() < 20 || IsCasting()) return;
+            if (me->GetExactDist(master) > std::max(float(master->GetBotFollowDist()), 25.f)/* && me->IsWithinLOSInMap(master)*/)
+            {
+                me->SetFacingTo(me->GetAngle(master));
+                if (doCast(me, BLINK))
+                {
+                    Blink_cd = 15000 - me->getLevel()/4 * 100; //13 sec with improved
+                    GC_Timer = 500;
+                }
+                return;
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist(master) > 15)
+            {
+                if (Unit *op = me->SelectNearestTarget(10))
+                {
+                    if (op->getVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        if (doCast(me, BLINK))
+                        {
+                            Blink_cd = 15000 - me->getLevel()/4 * 100; //13 sec with improved
+                            GC_Timer = 500;
+                        }
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(const uint32 diff)
+        {
+            if (!FOCUSMAGIC || me->getLevel() < 20 || fmCheckTimer > diff || GC_Timer > diff || Rand() < 50 || IsCasting())
+                return;
+            if (Unit *target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 2))
+            {
+                fmCheckTimer = 30000;
+                return;
+            }
+            else
+            {
+                Group *pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && !master->HasAura(FOCUSMAGIC) && me->GetExactDist(master) < 30)
+                    target = master;
+                }
+                else
+                {
+                    for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player *pPlayer = itr->getSource();
+                        if (!pPlayer || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if ((pPlayer->getClass() == CLASS_MAGE || 
+                            pPlayer->getClass() == CLASS_PRIEST || 
+                            pPlayer->getClass() == CLASS_SHAMAN || 
+                            pPlayer->getClass() == CLASS_DRUID || 
+                            pPlayer->getClass() == CLASS_PALADIN) && 
+                            !pPlayer->HasAura(FOCUSMAGIC) && me->GetExactDist(pPlayer) < 30)
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player *pPlayer = itr->getSource();
+                            if (!pPlayer || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            for (uint8 i = 0; i != pPlayer->GetMaxNpcBots(); ++i)
+                            {
+                                Creature *cre = pPlayer->GetBotMap()[i]._Cre();
+                                if (!cre || cre == me || cre->isDead() || cre->getPowerType() != POWER_MANA) continue;
+                                if ((cre->GetBotClass() == CLASS_MAGE || 
+                                    cre->GetBotClass() == CLASS_PRIEST || 
+                                    cre->GetBotClass() == CLASS_SHAMAN || 
+                                    cre->GetBotClass() == CLASS_DRUID) && 
+                                    !cre->HasAura(FOCUSMAGIC) && me->GetExactDist(cre) < 30)
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+            fmCheckTimer = 5000;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            Pyroblast_cd = 0;
+            FireBlast_cd = 0;
+            DragonBreath_cd = 0;
+            Combustion_cd = 300;//30 sec for reset
+            Ice_Barrier_cd = 0;
+            Iceblock_cd = 0;
+            ConeofCold_cd = 0;
+            Blizzard_cd = 10000;
+            CounterSpell_cd = 0;
+            Evocation_cd = 0;
+            Blink_cd = 0;
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = FROSTBOLT;//default frost
+            NOVA = BLASTWAVE != 0 ? BLASTWAVE : FROSTNOVA;
+
+            if (master)
+            {
+                setStats(CLASS_MAGE, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_MAGE);
+           }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Pyroblast_cd > diff)            Pyroblast_cd -= diff;
+            if (Ice_Barrier_cd > diff)          Ice_Barrier_cd -= diff;
+            if (Iceblock_cd > diff)             Iceblock_cd -= diff;
+            if (ConeofCold_cd > diff)           ConeofCold_cd -= diff;
+            if (Living_Bomb_cd > diff)          Living_Bomb_cd -= diff;
+            if (FireBlast_cd > diff)            FireBlast_cd -= diff;
+            if (Bolt_cd > diff)                 Bolt_cd -= diff;
+            if (Blizzard_cd > diff)             Blizzard_cd -= diff;
+            if (CounterSpell_cd > diff)         CounterSpell_cd -= diff;
+            if (Nova_cd > diff)                 Nova_cd -= diff;
+            if (DragonBreath_cd > diff)         DragonBreath_cd -= diff;
+            if (Blink_cd > diff)                Blink_cd -= diff;
+            if (Combustion_cd > diff)           Combustion_cd -= diff;
+            if (Evocation_cd > diff)            Evocation_cd -= diff;
+            if (polyCheckTimer > diff)          polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)            fmCheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DAMPENMAGIC                             = InitSpell(DAMPENMAGIC_1);
+            ARCANEINTELLECT                         = InitSpell(ARCANEINTELLECT_1);
+            ARCANEMISSILES                          = InitSpell(ARCANEMISSILES_1); 
+            POLYMORPH                               = InitSpell(POLYMORPH_1);
+            COUNTERSPELL                            = InitSpell(COUNTERSPELL_1);
+            SPELLSTEAL                              = InitSpell(SPELLSTEAL_1);
+            EVOCATION                               = InitSpell(EVOCATION_1);
+            BLINK                                   = InitSpell(BLINK_1);
+            REMOVE_CURSE                            = InitSpell(REMOVE_CURSE_1);
+            //INVISIBILITY                            = InitSpell(INVISIBILITY_1);
+            FIREBALL                                = InitSpell(FIREBALL_1);
+            BLASTWAVE                   = lvl >= 30 ? InitSpell(BLASTWAVE_1) : 0;
+            DRAGONBREATH                = lvl >= 40 ? InitSpell(DRAGONBREATH_1) : 0;
+            FIREBLAST                               = InitSpell(FIREBLAST_1);
+            PYROBLAST                   = lvl >= 20 ? InitSpell(PYROBLAST_1) : 0;
+            LIVINGBOMB                  = lvl >= 60 ? InitSpell(LIVINGBOMB_1) : 0;
+            FLAMESTRIKE                             = InitSpell(DAMPENMAGIC_1);
+            COMBUSTION                  = lvl >= 50 ? COMBUSTION_1 : 0;
+            FROSTBOLT                               = InitSpell(FROSTBOLT_1);
+            FROSTNOVA                               = InitSpell(FROSTNOVA_1);
+            CONEOFCOLD                              = InitSpell(CONEOFCOLD_1);
+            BLIZZARD                                = InitSpell(BLIZZARD_1);
+            ICEARMOR                    = lvl >= 20 ? InitSpell(ICEARMOR_1) : InitSpell(FROSTARMOR_1);
+            ICE_BARRIER                 = lvl >= 40 ? InitSpell(ICE_BARRIER_1) : 0;
+            ICEBLOCK                                = InitSpell(ICEBLOCK_1);
+            FOCUSMAGIC                  = lvl >= 20 ? FOCUSMAGIC_1 : 0;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //Dam+(-Hit)
+            if (level >= 50)
+                RefreshAura(ARCTIC_WINDS,3); //+15%/-15%
+            else if (level >= 25)
+                RefreshAura(ARCTIC_WINDS,2); //+10%/-10%
+            else if (level >= 10)
+                RefreshAura(ARCTIC_WINDS); //+5%/-5%
+            //CHILL
+            if (level >= 30)
+                RefreshAura(WINTERS_CHILL3); //100%
+            else if (level >= 25)
+                RefreshAura(WINTERS_CHILL2); //66%
+            else if (level >= 20)
+                RefreshAura(WINTERS_CHILL1); //33%
+            //Imp Blizzard
+            if (level >= 20)
+                RefreshAura(IMPROVED_BLIZZARD); //50% slow
+            //Frostbite
+            if (level >= 80)
+                FROSTBITE = FROSTBITE3;
+            else if (level >= 50)
+                FROSTBITE = FROSTBITE2;
+            else if (level >= 10)
+                FROSTBITE = FROSTBITE1;
+            if (level >= 60)
+                RefreshAura(FROSTBITE,3);//3x
+            else if (level >= 30)
+                RefreshAura(FROSTBITE,2);//2x
+            else if (level >= 10)
+                RefreshAura(FROSTBITE);//1x
+            //Shattered Barrier
+            if (level >= 45)
+                RefreshAura(SHATTERED_BARRIER);
+            //Bonus
+            if (level >= 65)
+                RefreshAura(ARCANE_INSTABILITY,4); //+12%dmg crit
+            else if (level >= 55)
+                RefreshAura(ARCANE_INSTABILITY,3); //+9%dmg crit
+            else if (level >= 45)
+                RefreshAura(ARCANE_INSTABILITY,2); //+6%dmg crit
+            else if (level >= 35)
+                RefreshAura(ARCANE_INSTABILITY); //+3%dmg crit
+            //Absorb
+            if (level >= 50)
+                RefreshAura(INCANTERS_ABSORPTION3);
+            else if (level >= 45)
+                RefreshAura(INCANTERS_ABSORPTION2);
+            else if (level >= 40)
+                RefreshAura(INCANTERS_ABSORPTION1);
+            //Shatter
+            if (level >= 35)
+                RefreshAura(SHATTER3);
+            else if (level >= 30)
+                RefreshAura(SHATTER2);
+            else if (level >= 25)
+                RefreshAura(SHATTER1);
+            //ClearCasting
+            if (level >= 75)
+                RefreshAura(CLEARCAST,3);//30%
+            else if (level >= 40)
+                RefreshAura(CLEARCAST,2);//20%
+            else if (level >= 15)
+                RefreshAura(CLEARCAST);//10%
+            //Fingers
+            if (level >= 45)
+                RefreshAura(FINGERS_OF_FROST);//15%
+            //Potency
+            if (level >= 40)
+                RefreshAura(ARCANE_POTENCY2);//30% bonus
+            else if (level >= 35)
+                RefreshAura(ARCANE_POTENCY1);//15% bonus
+            //Ignite
+            if (level >= 15)
+                RefreshAura(IGNITE);
+            //Impact
+            if (level >= 60)
+                RefreshAura(IMPACT,2);
+            else if (level >= 20)
+                RefreshAura(IMPACT);
+            //Imp. Counterspell
+            if (level >= 35)
+                RefreshAura(IMPROVED_COUNTERSPELL2);//4 sec
+            else if (level >= 25)
+                RefreshAura(IMPROVED_COUNTERSPELL1);//2 sec
+            //Firestarter
+            if (level >= 55)
+                RefreshAura(FIRESTARTER2);//100% chance
+            else if (level >= 45)
+                RefreshAura(FIRESTARTER1);//50% chance
+            //Spells
+            if (LIVINGBOMB != 0)
+                RefreshAura(GLYPH_LIVING_BOMB);
+            if (POLYMORPH != 0)
+                RefreshAura(GLYPH_POLYMORPH);
+        }
+
+    private:
+        uint32
+  /*Arcane*/DAMPENMAGIC, ARCANEINTELLECT, ARCANEMISSILES, POLYMORPH, COUNTERSPELL, FOCUSMAGIC, 
+  /*Arcane*/SPELLSTEAL, EVOCATION, BLINK, REMOVE_CURSE, /*INVISIBILITY, */
+    /*Fire*/FIREBALL, FIREBLAST, FLAMESTRIKE, PYROBLAST, COMBUSTION, BLASTWAVE, DRAGONBREATH, LIVINGBOMB, 
+   /*Frost*/FROSTBOLT, FROSTNOVA, CONEOFCOLD, BLIZZARD, ICEARMOR, ICEBLOCK, ICE_BARRIER, FROSTBITE;
+        //Timers
+/*fire*/uint32 Pyroblast_cd, FireBlast_cd, DragonBreath_cd, Living_Bomb_cd, Combustion_cd;
+/*frst*/uint32 Ice_Barrier_cd, ConeofCold_cd, Blizzard_cd, Iceblock_cd;
+/*arcn*/uint32 CounterSpell_cd, Blink_cd, Evocation_cd;
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 BOLT, NOVA;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells// all orignals
+        {
+            DAMPENMAGIC_1                       = 604, 
+            ARCANEINTELLECT_1                   = 1459, 
+            ARCANEMISSILES_1                    = 5143, 
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646,
+        };
+
+        enum MagePassives
+        {
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+            GLYPH_POLYMORPH                     = 56375,
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..3c7805c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,955 @@
+#include "bot_ai.h"
+#include "SpellAuraEffects.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 45-50%
+TODO: Repentance Work Improve, Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new paladin_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct paladin_botAI : public bot_ai
+    {
+        paladin_botAI(Creature *c) : bot_ai(c) { }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (!spellId) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (Feasting() && spellId != REDEMPTION && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (InDuel(victim)) return false;
+            if (spellId != MANAPOTION && spellId != HEALINGPOTION && spellId != CRUSADER_STRIKE && 
+                me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED)) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            if (spellId != HEALINGPOTION)
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void HOFGroup(Player *pTarget, const uint32 diff)
+        {
+            if (!HOF || HOF_Timer > diff || GC_Timer > diff || Rand() > 60) return;
+            if (IsCasting()) return;//I'm busy
+
+            if (Group *pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature *cre = tPlayer->GetBotMap()[i]._Cre();
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit *target, const uint32 diff)
+        {
+            if (!HOF || HOF_Timer > diff || GC_Timer > diff) return false;
+            if (!target || target->isDead()) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura *aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication *app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, HOF))
+                    {
+                        if (target->ToCreature())
+                            HOF_Timer = 10000;//10 sec for selfcast after stun
+                        else
+                            HOF_Timer = 15000;//improved
+                        HOFGuid = target->GetGUID();
+                        return true;
+                    }
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) || 
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = (spellInfo->Dispel == DISPEL_MAGIC || spellInfo->Dispel == DISPEL_DISEASE || spellInfo->Dispel == DISPEL_POISON) && CLEANSE ? CLEANSE : HOF;
+                    if (doCast(target, spell))
+                    {
+                        if (spell == HOF)
+                        {
+                            if (target->ToCreature())
+                                HOF_Timer = 5000;//5 sec for bots
+                            else
+                                HOF_Timer = 15000;//improved
+                            if (me->getLevel() >= 40)
+                                HOFGuid = target->GetGUID();
+                        }
+                        return true;
+                    }
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player *hTarget, const uint32 diff)
+        {
+            if (!HOS || HOS_Timer > diff || GC_Timer > diff || Rand() > 30) return;
+            if (IsCasting()) return;
+            if (Group *pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *HOSPlayer = itr->getSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot()) bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (tank && HOSPlayer == tank) continue;//tanks do not need it
+                    if (master->GetMap() != HOSPlayer->GetMap() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff)) return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference *itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *pl = itr->getSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->GetMap()) continue;
+                    for (uint8 i = 0; i != pl->GetMaxNpcBots(); ++i)
+                    {
+                        Creature *cre = pl->GetBotMap()[i]._Cre();
+                        if (!cre || cre->isDead()) continue;
+                        if (tank && cre == tank) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS)) continue;     //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff)) return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit *target, const uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!HOS || HOS_Timer > diff || GC_Timer > diff || Rand() > 50) return false;
+            if (tank && target == tank) return false;       //tanks do not need it
+            if (IsCasting()) return false;          //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS)) return false;     //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue;//too small threat
+                if ((*iter)->getThreatManager().getThreat(tank) < threat * 0.33f) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, HOS))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586))));//Fade
+                HOS_Timer = 25000 - 20000*IS_CREATURE_GUID(target->GetGUID());
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit *target, const uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!HOLY_SHOCK || HS_Timer > diff || GC_Timer > diff) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->isCharmed() || target->isPossessed())) return false;//do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, HOLY_SHOCK))
+            {
+                HS_Timer = target->ToCreature() ? 3500 : 5000;
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit *target, uint8 hp, const uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName(), target->GetName());
+            if (Rand() > 40 + 20*target->isInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (HAND_OF_PROTECTION && BOP_Timer <= diff && IS_PLAYER_GUID(target->GetGUID()) && 
+                (master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID()) || target == master) && 
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) && 
+                me->GetExactDist(target) < 30 && 
+                !HasAuraName(target, HAND_OF_PROTECTION) && 
+                !HasAuraName(target, "Forbearance"))
+            {
+                if (doCast(target, HAND_OF_PROTECTION))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        me->MonsterWhisper("BOP on you!", target->GetGUID());
+                    BOP_Timer = 60000; //1 min
+                    if (!HasAuraName(target, "Forbearance"))
+                        me->AddAura(25771, target);//Forbearance
+                    if (HasAuraName(target, "Forbearance") && !target->HasAura(HAND_OF_PROTECTION))
+                        me->AddAura(HAND_OF_PROTECTION, target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (LAY_ON_HANDS && LOH_Timer <= diff && hp < 20 && 
+                            target->GetTypeId() == TYPEID_PLAYER && 
+                            (target->isInCombat() || !target->getAttackers().empty()) && 
+                            !HasAuraName(target, "Forbearance"))
+                        {
+                            if (doCast(target, LAY_ON_HANDS))
+                            {
+                                me->MonsterWhisper("Lay of Hands on you!", target->GetGUID());
+                                LOH_Timer = 60000; //1 min
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (FLASH_OF_LIGHT && doCast(target, FLASH_OF_LIGHT))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HOLY_SHOCK && HS_Timer <= diff && HS(target, diff))
+                            return true;
+                }
+            }
+            if (GC_Timer > diff) return false;
+            Unit *u = target->getVictim();
+            if (SACRED_SHIELD && SSH_Timer <= diff && target->GetTypeId() == TYPEID_PLAYER && 
+                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->isInCombat())) && 
+                !target->HasAura(SACRED_SHIELD) && 
+                ((master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID())) || target == master))
+            {
+                Unit *aff = FindAffectedTarget(SACRED_SHIELD, me->GetGUID(), 50, 1);//use players since we cast only on them
+                if ((!aff || (aff->getAttackers().empty() && tank != aff)) && 
+                    doCast(target, SACRED_SHIELD))
+                {
+                    SSH_Timer = 3000;
+                    return true;
+                }
+            }
+            if (HOLY_SHOCK && (hp < 85 || GetLostHP(target) > 6000) && HS_Timer <= diff)
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!FLASH_OF_LIGHT && hp < 85))
+                if (doCast(target, HOLY_LIGHT))
+                    return true;
+            if (FLASH_OF_LIGHT && (hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, FLASH_OF_LIGHT))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit *u, bool force = false)
+        {
+            if (GetBotCommandState() == (COMMAND_ATTACK) && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void KilledUnit(Unit *) { }
+        void EnterEvadeMode() { }
+        void EnterCombat(Unit*) { }
+        void JustDied(Unit *) { master->SetNpcBotDied(me->GetGUID()); }
+        void Aggro(Unit *) { }
+        void AttackStart(Unit *) { }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (HOFGuid != 0)
+            {
+                if (Unit *ally = sObjectAccessor->FindUnit(HOFGuid))
+                {
+                    if (Aura *hof = ally->GetAura(HOF, me->GetGUID()))
+                    {
+                        hof->SetDuration(hof->GetDuration() + 4000);//Guardian's Favor part 2 (handled separately)
+                    }
+                }
+                HOFGuid = 0;
+            }
+            if (IAmDead()) return;
+            if (me->getVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (GetManaPCT(me) < 30 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 40 && DIVINE_PLEA && Divine_Plea_Timer <= diff)
+                if (doCast(me, DIVINE_PLEA))
+                    Divine_Plea_Timer = 45000;
+
+            CureTarget(me, CLEANSE, diff);//maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff);//maybe unnecessary
+            CureTarget(master, CLEANSE, diff);//maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master, CLEANSE, diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (!me->isInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (SEAL_OF_COMMAND && !me->HasAura(SEAL_OF_COMMAND) && GC_Timer <= diff && 
+                doCast(me, SEAL_OF_COMMAND))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(const uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(REDEMPTION, master);
+
+            if (Feasting()) return;
+
+            //aura
+            if (master->isAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura *concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura *devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == CLASS_MAGE || 
+                    master->getClass() == CLASS_PRIEST || 
+                    master->getClass() == CLASS_WARLOCK || 
+                    master->getClass() == CLASS_DRUID || devAura) && 
+                    !concAura && 
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit *target, const uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->isInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            if (HasAuraName(target, "Blessing of Wisdom", me->GetGUID()) || 
+                HasAuraName(target, "Blessing of Might", me->GetGUID()) || 
+                HasAuraName(target, "Blessing of Kings", me->GetGUID()) || 
+                HasAuraName(target, "Blessing of Sanctuary", me->GetGUID()))
+                return false;
+            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) || 
+            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) || 
+            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) || 
+            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
+            //    return false;
+            bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM) || HasAuraName(target, "Greater Blessing of Wisdom");
+            bool kings = HasAuraName(target, BLESSING_OF_KINGS) || HasAuraName(target, "Greater Blessing of Kings");
+            bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY) || HasAuraName(target, "Greater Blessing of Sanctuary");
+            bool might = (HasAuraName(target, BLESSING_OF_MIGHT) || HasAuraName(target, "Greater Blessing of Might") || HasAuraName(target, "Battle Shout"));
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->ToPlayer()->getClass();
+            else if (target->ToCreature())
+                Class = target->ToCreature()->GetBotClass();
+            switch (Class)
+            {
+            case CLASS_PRIEST:
+                if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                break;
+            case CLASS_DEATH_KNIGHT:
+            case CLASS_WARRIOR:
+            case CLASS_PALADIN:
+            case CLASS_ROGUE:
+            case CLASS_HUNTER:
+            case CLASS_SHAMAN:
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                break;
+            default:
+                if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                    return true;
+                else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                    return true;
+                else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                    return true;
+                else if (!might && doCast(target, BLESSING_OF_MIGHT))
+                    return true;
+                break;
+            }
+            return false;
+        }
+
+        void Repentance(const uint32 diff, Unit *target = NULL)
+        {
+            if (target && Repentance_Timer < 25000 && doCast(target, REPENTANCE))
+            {
+                temptimer = GC_Timer;
+                Repentance_Timer = 45000;
+                GC_Timer = temptimer;
+                return;
+            }
+            if (REPENTANCE && Repentance_Timer <= diff)
+            {
+                Unit *u = FindRepentanceTarget();
+                if (u && u->getVictim() != me && doCast(u, REPENTANCE))
+                    Repentance_Timer = 45000;
+            }
+        }
+
+        void Counter(const uint32 diff)
+        {
+            if (Rand() > 60 || IsCasting()) return;
+            Unit *target = Repentance_Timer < 25000 ? FindCastingTarget(20, false, REPENTANCE) : NULL;
+            if (target)
+                Repentance(diff, target);//first check repentance
+            else if (TURN_EVIL && Turn_Evil_Timer < 1500)
+            {
+                target = FindCastingTarget(20, false, TURN_EVIL);
+                temptimer = GC_Timer;
+                if (target && doCast(target, TURN_EVIL, true))
+                    Turn_Evil_Timer = 3000;
+                GC_Timer = temptimer;
+            }
+            else if (HOLY_WRATH && Holy_Wrath_Timer < 8000)
+            {
+                target = FindCastingTarget(8, false, TURN_EVIL);//here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, HOLY_WRATH))
+                    Holy_Wrath_Timer = 23000 - me->getLevel() * 100; //23 - 0...8 sec (15 sec on 80 as with glyph)
+                GC_Timer = temptimer;
+            }
+            else if (HAMMER_OF_JUSTICE && HOJ_Timer <= 7000/* && GC_Timer <= diff*/)
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 65000 - master->getLevel()*500; //25 sec on 80
+            }
+        }
+
+        void TurnEvil(const uint32 diff)
+        {
+            if (!TURN_EVIL || Turn_Evil_Timer > diff || GC_Timer > diff || Rand() > 50 || 
+                FindAffectedTarget(TURN_EVIL, me->GetGUID(), 50))
+                return;
+            Unit *target = FindUndeadCCTarget(20, TURN_EVIL);
+            if (target && 
+                (target != me->getVictim() || GetHealthPCT(me) < 70 || target->getVictim() == master) && 
+                doCast(target, TURN_EVIL, true))
+            {
+                Turn_Evil_Timer = 3000;
+                return;
+            }
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                !CCed(opponent) && 
+                opponent->getVictim() && tank && opponent->getVictim() != tank && opponent->getVictim() != me && 
+                GetHealthPCT(me) < 90 && 
+                doCast(opponent, TURN_EVIL, true))
+                Turn_Evil_Timer = 3000;
+        }
+
+        void Wrath(const uint32 diff)
+        {
+            if (!HOLY_WRATH || Holy_Wrath_Timer > diff || GC_Timer > diff || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) && 
+                me->GetExactDist(opponent) <= 8 && doCast(me, HOLY_WRATH))
+                Holy_Wrath_Timer = 23000 - me->getLevel() * 100; //23 - 0...8 sec (15 sec on 80 as with glyph)
+            else 
+            {
+                Unit *target = FindUndeadCCTarget(8, HOLY_WRATH);
+                if (target && doCast(me, HOLY_WRATH))
+                    Holy_Wrath_Timer = 23000 - me->getLevel() * 100; //23 - 0...8 sec (15 sec on 80 as with glyph)
+            }
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            opponent = me->getVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //{ wait = 5; return; }
+
+            if (HOW && HOW_Timer <= diff && GC_Timer <= diff && Rand() < 50 && GetHealthPCT(opponent) < 20 && 
+                me->GetExactDist(opponent) < 30)
+                if (doCast(opponent, HOW))
+                    HOW_Timer = 6000; //6 sec
+
+            Unit *u = opponent->getVictim();
+            if (Rand() < 50 && HANDOFRECKONING && Hand_Of_Reckoning_Timer <= diff && me->GetExactDist(opponent) < 30 && 
+                u && u != me && u != tank && (IsInBotParty(u) || tank == me))//No GCD
+            {
+                Creature *cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !isMeleeClass(u->getClass())) || 
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || tank == me) && 
+                    doCast(opponent, HANDOFRECKONING))
+                    Hand_Of_Reckoning_Timer = 8000 - (me == tank)*2000;
+                GC_Timer = temptimer;
+            }
+
+            if (Rand() < 20 && HAMMER_OF_JUSTICE && HOJ_Timer <= diff && GC_Timer <= diff && 
+                !CCed(opponent) && me->GetExactDist(opponent) < 10)
+                if (doCast(opponent, HAMMER_OF_JUSTICE))
+                    HOJ_Timer = 65000 - master->getLevel()*500; //25 sec on 80
+
+            if (JUDGEMENT_OF_LIGHT && JOL_Timer <= diff && GC_Timer <= diff && Rand() < 50 && 
+                me->GetExactDist(opponent) < 10 && me->HasAura(SEAL_OF_COMMAND))
+                if (doCast(opponent, JUDGEMENT_OF_LIGHT))
+                    JOL_Timer = 8000;
+
+            if (Rand() < 50 && CONSECRATION && Consecration_cd <= diff && GC_Timer <= diff && 
+                me->GetDistance(opponent) < 7 && !opponent->isMoving())
+                if (doCast(me, CONSECRATION))
+                    Consecration_cd = 8000;
+
+            if (Rand() < 25 && AVENGING_WRATH && AW_Timer <= diff && 
+                (opponent->GetHealth() > master->GetMaxHealth()*2/3))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, AVENGING_WRATH))
+                    AW_Timer = 60000; //1 min
+                GC_Timer = temptimer;
+            }
+
+            if (CRUSADER_STRIKE && Crusader_cd <= diff && GC_Timer <= diff && me->GetDistance(opponent) < 5)
+                if (doCast(opponent, CRUSADER_STRIKE))
+                    Crusader_cd = 12000 - me->getLevel() * 100;//4 sec on 80
+
+            if (EXORCISM && Exorcism_Timer <= diff && GC_Timer <= diff && me->GetExactDist(opponent) < 30)
+                if (doCast(opponent, EXORCISM/*, true)*/))//possible instacast here
+                    Exorcism_Timer = 15000;
+
+            Wrath(diff);
+
+            if (DIVINE_STORM && DS_Timer <= diff && GC_Timer <= diff && me->GetExactDist(opponent) < 7)
+                if (doCast(opponent, DIVINE_STORM))
+                    DS_Timer = 10000 - me->getLevel()/4 * 100; //10 - 2 sec
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            Crusader_cd = 0;
+            Consecration_cd = 0;
+            LOH_Timer = 0;
+            HOJ_Timer = 0;
+            HOF_Timer = 0;
+            JOL_Timer = 0;
+            HS_Timer = 0;
+            BOP_Timer = 0;
+            HOW_Timer = 0;
+            DS_Timer = 0;
+            AW_Timer = 10000;
+            HOS_Timer = 0;
+            SSH_Timer = 0;
+            Hand_Of_Reckoning_Timer = 0;
+            Divine_Plea_Timer = 0;
+            Repentance_Timer = 0;
+            Exorcism_Timer = 0;
+            Holy_Wrath_Timer = 0;
+            Turn_Evil_Timer = 0;
+
+            HOFGuid = 0;
+
+            if (master)
+            {
+                setStats(CLASS_PALADIN, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_PALADIN);
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (HOW_Timer > diff)                   HOW_Timer -= diff;
+            if (DS_Timer > diff)                    DS_Timer -= diff;
+            if (AW_Timer > diff)                    AW_Timer -= diff;
+            if (HOS_Timer > diff)                   HOS_Timer -= diff;
+            if (HS_Timer > diff)                    HS_Timer -= diff;
+            if (BOP_Timer > diff)                   BOP_Timer -= diff;
+            if (Consecration_cd > diff)             Consecration_cd -= diff;
+            if (Crusader_cd > diff)                 Crusader_cd -= diff;
+            if (LOH_Timer > diff)                   LOH_Timer -= diff;
+            if (HOJ_Timer > diff)                   HOJ_Timer -= diff;
+            if (HOF_Timer > diff)                   HOF_Timer -= diff;
+            if (JOL_Timer > diff)                   JOL_Timer -= diff;
+            if (SSH_Timer > diff)                   SSH_Timer -= diff;
+            if (Hand_Of_Reckoning_Timer > diff)     Hand_Of_Reckoning_Timer -= diff;
+            if (Divine_Plea_Timer > diff)           Divine_Plea_Timer -= diff;
+            if (Repentance_Timer > diff)            Repentance_Timer -= diff;
+            if (Exorcism_Timer > diff)              Exorcism_Timer -= diff;
+            if (Holy_Wrath_Timer > diff)            Holy_Wrath_Timer -= diff;
+            if (Turn_Evil_Timer > diff)             Turn_Evil_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            FLASH_OF_LIGHT                          = InitSpell(FLASH_OF_LIGHT_1);
+            HOLY_LIGHT                              = InitSpell(HOLY_LIGHT_1);
+            LAY_ON_HANDS                            = InitSpell(LAY_ON_HANDS_1);
+            SACRED_SHIELD                           = InitSpell(SACRED_SHIELD_1);
+            HOLY_SHOCK                  = lvl >= 40 ? InitSpell(HOLY_SHOCK_1) : 0;
+            CLEANSE                                 = InitSpell(CLEANSE_1);
+            REDEMPTION                              = InitSpell(REDEMPTION_1);
+            HAMMER_OF_JUSTICE                       = InitSpell(HAMMER_OF_JUSTICE_1);
+            REPENTANCE                  = lvl >= 45 ? REPENTANCE_1 : 0;
+            TURN_EVIL                               = InitSpell(TURN_EVIL_1);
+            HOLY_WRATH                              = InitSpell(HOLY_WRATH_1);
+            EXORCISM                                = InitSpell(EXORCISM_1);
+            SEAL_OF_COMMAND             = lvl >= 25 ? SEAL_OF_COMMAND_1 : 0;
+            CRUSADER_STRIKE             = lvl >= 20 ? CRUSADER_STRIKE_1 : 0;//exception
+            JUDGEMENT_OF_LIGHT                      = InitSpell(JUDGEMENT_OF_LIGHT_1);
+            CONSECRATION                            = InitSpell(CONSECRATION_1);
+            DIVINE_STORM                = lvl >= 60 ? DIVINE_STORM_1 : 0;
+            HOW /*Hammer of Wrath*/                 = InitSpell(HOW_1);
+            AVENGING_WRATH                          = InitSpell(AVENGING_WRATH_1);
+            BLESSING_OF_MIGHT                       = InitSpell(BLESSING_OF_MIGHT_1);
+            BLESSING_OF_WISDOM                      = InitSpell(BLESSING_OF_WISDOM_1);
+            BLESSING_OF_KINGS                       = InitSpell(BLESSING_OF_KINGS_1);
+            BLESSING_OF_SANCTUARY       = lvl >= 30 ? BLESSING_OF_SANCTUARY_1 : 0;
+            DEVOTION_AURA                           = InitSpell(DEVOTION_AURA_1);
+            CONCENTRATION_AURA                      = InitSpell(CONCENTRATION_AURA_1);
+            DIVINE_PLEA                             = InitSpell(DIVINE_PLEA_1);
+            HAND_OF_PROTECTION                      = InitSpell(HAND_OF_PROTECTION_1);
+            HOF/*Hand of Freedom*/                  = InitSpell(HOF_1);
+            HOS /*Hand of salvation*/               = InitSpell(HOS_1);
+            HANDOFRECKONING                         = InitSpell(HANDOFRECKONING_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            //1 - SPD 3% crit 3%
+            if (level >= 78)
+                RefreshAura(SPELLDMG,5); //+15%
+            else if (level >= 75)
+                RefreshAura(SPELLDMG,4); //+12%
+            else if (level >= 55)
+                RefreshAura(SPELLDMG,3); //+9%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG,2); //+6%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG); //+3%
+            //2 - SPD 6%
+            if (level >= 55)
+                RefreshAura(SPELLDMG2,3); //+18%
+            else if (level >= 35)
+                RefreshAura(SPELLDMG2,2); //+12%
+            else if (level >= 15)
+                RefreshAura(SPELLDMG2); //+6%
+            //Talents
+            if (level >= 55)
+                RefreshAura(PURE);
+            if (level >= 35)
+                RefreshAura(WISE);
+            if (level >= 50)
+                RefreshAura(RECKONING5); //10%
+            else if (level >= 45)
+                RefreshAura(RECKONING4); //8%
+            else if (level >= 40)
+                RefreshAura(RECKONING3); //6%
+            else if (level >= 35)
+                RefreshAura(RECKONING2); //4%
+            else if (level >= 30)
+                RefreshAura(RECKONING1); //2%
+            if (level >= 50)
+                RefreshAura(RIGHTEOUS_VENGEANCE3);
+            else if (level >= 47)
+                RefreshAura(RIGHTEOUS_VENGEANCE2);
+            else if (level >= 45)
+                RefreshAura(RIGHTEOUS_VENGEANCE1);
+            if (level >= 30)
+                RefreshAura(VENGEANCE3);
+            else if (level >= 27)
+                RefreshAura(VENGEANCE2);
+            else if (level >= 25)
+                RefreshAura(VENGEANCE1);
+            if (level >= 60)
+                RefreshAura(SHOFL3);
+            else if (level >= 55)
+                RefreshAura(SHOFL2);
+            else if (level >= 50)
+                RefreshAura(SHOFL1);
+            if (level >= 45)
+                RefreshAura(SACRED_CLEANSING);
+            if (level >= 35)
+                RefreshAura(DIVINE_PURPOSE);
+            if (level >= 25)
+                RefreshAura(VINDICATION2);
+            else if (level >= 20)
+                RefreshAura(VINDICATION1);
+            if (level >= 30)
+                RefreshAura(LAYHANDS);
+            if (level >= 20)
+                RefreshAura(FANATICISM,2); //-60% aggro
+            if (level >= 15)
+                RefreshAura(GLYPH_HOLY_LIGHT); //10% heal
+            if (level >= 70)
+                RefreshAura(PALADIN_T9_2P_BONUS); //Righteous Vengeance Crits
+        }
+
+    private:
+        uint32
+   /*Heals*/FLASH_OF_LIGHT, HOLY_LIGHT, HOLY_SHOCK, LAY_ON_HANDS, SACRED_SHIELD,
+      /*CC*/HAMMER_OF_JUSTICE, REPENTANCE, TURN_EVIL,
+  /*Damage*/SEAL_OF_COMMAND, HOLY_WRATH, EXORCISM, CRUSADER_STRIKE, JUDGEMENT_OF_LIGHT,
+  /*Damage*/CONSECRATION, DIVINE_STORM, AVENGING_WRATH, HOW,//hammer of wrath
+/*Blessing*/BLESSING_OF_MIGHT, BLESSING_OF_WISDOM, BLESSING_OF_KINGS, BLESSING_OF_SANCTUARY,
+   /*Auras*/DEVOTION_AURA, CONCENTRATION_AURA,
+   /*Hands*/HAND_OF_PROTECTION, HOF, HOS, HANDOFRECKONING,
+    /*Misc*/CLEANSE, REDEMPTION, DIVINE_PLEA;
+        //Timers
+        uint32 Crusader_cd, Consecration_cd, Exorcism_Timer, Holy_Wrath_Timer, JOL_Timer, HOF_Timer,
+            HS_Timer, HOW_Timer, DS_Timer, HOS_Timer, SSH_Timer, Hand_Of_Reckoning_Timer, Turn_Evil_Timer,
+            LOH_Timer, HOJ_Timer, BOP_Timer, AW_Timer, Divine_Plea_Timer, Repentance_Timer;
+        uint64 HOFGuid;
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_COMMAND_1                   = 20375,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_OF_LIGHT_1                = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746,
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            PURE/*Judgements of the Pure*/      = 54155,
+            WISE/*Judgements of the Wise*/      = 31878,
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452 ,//rank 1
+            VINDICATION2                        = 26016,//rank 2
+            LAYHANDS  /*Improved LOH rank 2*/   = 20235,
+            FANATICISM                          = 31881,//rank 3
+            RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHOFL1      /*Sheath of Light*/     = 53501,//rank 1
+            SHOFL2                              = 53502,//rank 2
+            SHOFL3                              = 53503,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937,
+        //other
+            SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            PALADIN_T9_2P_BONUS                 = 67188,//Righteous Vengeance Crits
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA,
+            DEVOTIONAURA,
+            CONCENTRATIONAURA,
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..8cb92a8
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,854 @@
+#include "bot_ai.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new priest_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct priest_botAI : public bot_ai
+    {
+        priest_botAI(Creature *c) : bot_ai(c) { }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (!spellId) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (Feasting() && spellId != RESURRECTION && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (InDuel(victim)) return false;
+            if (spellId != MANAPOTION && spellId != HEALINGPOTION && spellId != DISPERSION && me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED)) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        bool MassGroupHeal(Player *player, const uint32 diff)
+        {
+            if (!PRAYER_OF_HEALING && !DIVINE_HYMN) return false;
+            if (!player->GetGroup()) return false;
+            if (Rand() > 30) return false;
+            if (IsCasting()) return false;
+
+            if (DIVINE_HYMN && Divine_Hymn_Timer <= diff)
+            {
+                Group *gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference *itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player *tPlayer = itr->getSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->GetMap() || 
+                        tPlayer->isPossessed() || tPlayer->isCharmed()) continue;
+                    if (tPlayer->isAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature *bot = tPlayer->GetBotMap()[i]._Cre();
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, DIVINE_HYMN))
+                {
+                    Divine_Hymn_Timer = 180000; //3 min
+                    return true;
+                }
+            }
+            if (PRAYER_OF_HEALING)
+            {
+                Group *gr = player->GetGroup();
+                Unit *castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference *itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player *tPlayer = itr->getSource();
+                    if (!tPlayer || me->GetMap() != tPlayer->GetMap() || 
+                        tPlayer->isPossessed() || tPlayer->isCharmed()) continue;
+                    if (tPlayer->isAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                    {
+                        Creature *bot = tPlayer->GetBotMap()[i]._Cre();
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+                if (LHPcount > 2 && castTarget && doCast(castTarget, PRAYER_OF_HEALING))
+                    return true;
+            }
+            return false;
+        }//end MassGroupHeal
+
+        bool ShieldTarget(Unit *target, const uint32 diff)
+        {
+            if (PWS_Timer > diff || Rand() > 50 || IsCasting()) return false;
+            if (target->HasAura(WEAKENED_SOUL)) return false;
+            if (HasAuraName(target, PW_SHIELD)) return false;
+            //if (me->GetExactDist(target) > 40) return false;//checked already in HealTarget()
+
+            if (!target->getAttackers().empty() || GetHealthPCT(target) < 33 || target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+            {
+                if (doCast(target, PW_SHIELD))
+                {
+                    if (me->getLevel() >= 30 || // improved
+                        (target->ToCreature() && target->ToCreature()->GetIAmABot()))
+                        PWS_Timer = 0;
+                    else
+                        PWS_Timer = 4000;
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void StartAttack(Unit *u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, true);
+            SetBotCommandState(COMMAND_ATTACK);
+        }
+        void KilledUnit(Unit *) { }
+        void EnterEvadeMode() { }
+        void EnterCombat(Unit*) { }
+        void JustDied(Unit *) { master->SetNpcBotDied(me->GetGUID()); }
+        void Aggro(Unit *) { }
+        void AttackStart(Unit *) { }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->getVictim())
+                Evade();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckAuras();
+            Disperse(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (GetManaPCT(me) < 33 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, DISPELMAGIC, diff);
+            CureGroup(master, CURE_DISEASE, diff);
+            //ShieldGroup(master);
+            if (master->isInCombat() || me->isInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+            if (me->isInCombat())
+                CheckShackles(diff);
+
+            if (!me->isInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 && 
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) && 
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->getVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                bool isBoss = opponent->GetTypeId() == TYPEID_UNIT ? opponent->ToCreature()->isWorldBoss() : false;
+                if (me->GetExactDist(opponent) < 30)
+                {
+                    if (SW_DEATH && Rand() < 50 && SW_Death_Timer <= diff && 
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) && 
+                        doCast(opponent, SW_DEATH))
+                    {
+                        SW_Death_Timer = 10000;
+                        return;
+                    }
+                    if (Rand() < 30 && GC_Timer <= diff && !opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/4 && 
+                        doCast(opponent, SW_PAIN))
+                        return;
+                    if (VAMPIRIC_TOUCH && GC_Timer <= diff && !isBoss && Rand() < 50 && !opponent->HasAura(VAMPIRIC_TOUCH, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/4 && 
+                        doCast(opponent, VAMPIRIC_TOUCH))
+                        return;
+                    if (DEVOURING_PLAGUE && GC_Timer <= diff && !isBoss && Rand() < 30 && !Devcheck && !opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()) && 
+                        opponent->GetHealth() > me->GetMaxHealth()/3 && 
+                        doCast(opponent, DEVOURING_PLAGUE))
+                        return;
+                    if (Mind_Blast_Timer <= diff && GC_Timer <= 300 && !isBoss && Rand() < 50 && (!VAMPIRIC_TOUCH || HasAuraName(opponent, VAMPIRIC_TOUCH)) && 
+                        doCast(opponent, MIND_BLAST))
+                    {
+                        Mind_Blast_Timer = 7500 - me->getLevel()/4*100;//5.5 sec on 80 lvl (as improved)
+                        return;
+                    }
+                    if (MIND_FLAY && Mind_Flay_Timer <= diff && GC_Timer <= 300 && !isBoss && !me->isMoving() && Rand() < 40 && me->GetExactDist(opponent) < 30 && 
+                        
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/3 || 
+                        (opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()))) && 
+                        doCast(opponent, MIND_FLAY))
+                    {
+                        Mind_Flay_Timer = 3000;
+                        return;
+                    }
+                    if (MIND_SEAR && GC_Timer <= diff && !opponent->isMoving() && Rand() < 50 && 
+                        opponent->HasAura(SW_PAIN, me->GetGUID()) && 
+                        opponent->HasAura(DEVOURING_PLAGUE, me->GetGUID()))
+                        if (Unit *u = FindSplashTarget(30, opponent))
+                            if (doCast(u, MIND_SEAR))
+                                return;
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (PSYCHIC_HORROR && Psychic_Horror_Timer <= diff && Rand() < 30 && 
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD && 
+                opponent->GetHealth() > me->GetMaxHealth()/5 && 
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR) && 
+                !CCed(opponent))
+            {
+                if (doCast(opponent, PSYCHIC_HORROR))
+                {
+                    Psychic_Horror_Timer = 60000;
+                    return;
+                }
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit *target, uint8 hp, const uint32 diff)
+        {
+            if (hp > 98) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->isInCombat() + 50*master->GetMap()->IsRaid()) return false;
+
+            //GUARDIAN SPIRIT
+            if (GUARDIAN_SPIRIT && Guardian_Spirit_Timer <= diff && Rand() < 70 && 
+                target->isInCombat() && !target->getAttackers().empty() && 
+                hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) && 
+                (master->GetGroup() && master->GetGroup()->IsMember(target->GetGUID()) || target == master) && 
+                !target->HasAura(GUARDIAN_SPIRIT))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCasted(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(target, GUARDIAN_SPIRIT))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (target->HasAura(GUARDIAN_SPIRIT, me->GetGUID()))
+                            me->MonsterWhisper("Guardin Spirit on you!", target->GetGUID());
+                        Guardian_Spirit_Timer = 90000;//1.5 min
+                    }
+                    else
+                        Guardian_Spirit_Timer = 30000;//30 sec for creatures
+                    GC_Timer = temptimer;
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && PAIN_SUPPRESSION && Pain_Suppression_Timer <= diff && Rand() < 50 && 
+                (target->isInCombat() || !target->getAttackers().empty()) && 
+                !target->HasAura(PAIN_SUPPRESSION))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, PAIN_SUPPRESSION))
+                {
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                    {
+                        if (target->HasAura(PAIN_SUPPRESSION, me->GetGUID()))
+                            me->MonsterWhisper("Pain Suppression on you!", target->GetGUID());
+                        Pain_Suppression_Timer = 45000;//45 sec
+                    }
+                    else
+                        Pain_Suppression_Timer = 15000;//15 sec for creatures
+                    GC_Timer = temptimer;
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) && 
+                PWS_Timer <= diff && ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (PENANCE && Penance_Timer <= diff && 
+                    !me->isMoving() && //better check then stop moving every try (furthermore it doesn't always work properly)
+                    (target->GetTypeId() != TYPEID_PLAYER || !(target->ToPlayer()->isCharmed() || target->ToPlayer()->isPossessed())) && 
+                    doCast(target, PENANCE))
+                {
+                    Penance_Timer = 8000;
+                    return true;
+                }
+                else if (Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) && 
+                GC_Timer <= diff && FLASH_HEAL && 
+                doCast(target, FLASH_HEAL))
+                    return true;
+            //maintain HoTs
+            Unit *u = target->getVictim();
+            Creature *boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = tank == target && boss;
+            //Renew
+            if (((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) && 
+                !HasAuraName(target, RENEW, me->GetGUID()) && 
+                GC_Timer <= diff && doCast(target, RENEW))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit *target, const uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 60) return false;
+            if (!target || target->isDead() || me->GetExactDist(target) > 30) return false;
+
+            if (Fear_Ward_Timer <= diff && !HasAuraName(target, FEAR_WARD) && doCast(target, FEAR_WARD))
+            {
+                Fear_Ward_Timer = target->GetTypeId() == TYPEID_PLAYER ? 60000 : 30000;//30sec for bots
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                if (!me->HasAura(INNER_FIRE) && doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) && doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->isInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (Rand() < 70 && !HasAuraName(target, PW_FORTITUDE) && doCast(target, PW_FORTITUDE))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            if (Rand() < 30 && !HasAuraName(target, SHADOW_PROTECTION) && doCast(target, SHADOW_PROTECTION))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            if (Rand() < 30 && !HasAuraName(target, DIVINE_SPIRIT) && doCast(target, DIVINE_SPIRIT))
+            {
+                /*GC_Timer = 800;*/
+                return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(const uint32 diff)
+        {
+            if (Rand() > 50 || GC_Timer > diff || me->IsMounted()) return;
+
+            RezGroup(RESURRECTION, master);
+
+            if (Feasting()) return;
+
+            if (BuffTarget(master, diff))
+                return;
+            if (BuffTarget(me, diff))
+                return;
+        }
+
+        void CheckDispel(const uint32 diff)
+        {
+            if (CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+            Unit *target = FindHostileDispelTarget();
+            if (target && doCast(target, DISPELMAGIC))
+            {
+                CheckDispelTimer = 3000;
+                GC_Timer = 500;
+            }
+            CheckDispelTimer = 1000;
+        }
+
+        void CheckShackles(const uint32 diff)
+        {
+            if (!SHACKLE_UNDEAD || ShackleTimer > diff || GC_Timer > diff || IsCasting())
+                return;
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+                return;
+            Unit *target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                ShackleTimer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(const uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (SILENCE && Silence_Timer <= diff)
+            {
+                if (Unit *target = FindCastingTarget(30))
+                    if (doCast(target, SILENCE))
+                        Silence_Timer = 30000;
+            }
+            else if (PSYCHIC_HORROR && Psychic_Horror_Timer <= 20000)
+            {
+                if (Unit *target = FindCastingTarget(30))
+                    if (doCast(target, PSYCHIC_HORROR))
+                        Psychic_Horror_Timer = 60000;
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(const uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            //fear master's attackers
+            if (!m_attackers.empty() && PSYCHIC_SCREAM && Fear_Timer <= diff && 
+                (master != tank || GetHealthPCT(master) < 75))
+            {
+                uint8 tCount = 0;
+                for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (me->GetExactDist((*iter)) > 7) continue;
+                    if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                    if (me->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 1 && doCast(me, PSYCHIC_SCREAM))
+                {
+                    Fear_Timer = 24000;//with improved 24 sec
+                    return;
+                }
+            }
+
+            // Defend myself (psychic horror)
+            if (!b_attackers.empty() && PSYCHIC_SCREAM && Fear_Timer <= diff)
+            {
+                uint8 tCount = 0;
+                for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter)) continue;
+                    if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                    if (me->GetExactDist((*iter)) > 7) continue;
+                    if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                    if (me->IsValidAttackTarget(*iter))
+                        ++tCount;
+                }
+                if (tCount > 0 && doCast(me, PSYCHIC_SCREAM))
+                {
+                    Fear_Timer = 24000;//with improved 24 sec
+                    return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 99 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (FADE && Fade_Timer <= diff && me->isInCombat())
+                {
+                    if (b_attackers.empty()) return; //no aggro
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) <= 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, FADE))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            Fade_Timer = 6000;
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(const uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(DEVOURING_PLAGUE, me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(const uint32 diff)
+        {
+            if (!DISPERSION || GC_Timer > diff || Dispersion_Timer > diff || IsCasting()) return;
+            //attackers case
+            if ((me->getAttackers().size() > 3 && Fade_Timer > diff && GetHealthPCT(me) < 90) || 
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) || 
+                (GetManaPCT(me) < 30) || 
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, DISPERSION))
+                    Dispersion_Timer = 75000;//with glyph
+                GC_Timer = temptimer;
+            }
+            Dispersion_Timer = 2000;//fail
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Divine_Hymn_Timer = 0;
+            Pain_Suppression_Timer = 0;
+            Guardian_Spirit_Timer = 0;
+            PWS_Timer = 0;
+            Fade_Timer = 0;
+            Fear_Timer = 0;
+            Mind_Blast_Timer = 0;
+            SW_Death_Timer = 0;
+            Fear_Ward_Timer = 0;
+            Psychic_Horror_Timer = 0;
+            Silence_Timer = 0;
+            Dispersion_Timer = 0;
+            Mind_Flay_Timer = 0;
+            Penance_Timer = 0;
+            CheckDispelTimer = 0;
+            ShackleTimer = 0;
+            DevcheckTimer = 20;
+            Devcheck = false;
+
+            if (master)
+            {
+                setStats(CLASS_PRIEST, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_PRIEST);
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Heal_Timer > diff)                 Heal_Timer -= diff;
+            if (Fade_Timer > diff)                 Fade_Timer -= diff;
+            if (Divine_Hymn_Timer > diff)          Divine_Hymn_Timer -= diff;
+            if (Pain_Suppression_Timer > diff)     Pain_Suppression_Timer -= diff;
+            if (Guardian_Spirit_Timer > diff)      Guardian_Spirit_Timer -= diff;
+            if (PWS_Timer > diff)                  PWS_Timer -= diff;
+            if (Fear_Timer > diff)                 Fear_Timer -= diff;
+            if (Mind_Blast_Timer > diff)           Mind_Blast_Timer -= diff;
+            if (SW_Death_Timer > diff)             SW_Death_Timer -= diff;
+            if (Fear_Ward_Timer > diff)            Fear_Ward_Timer -= diff;
+            if (Psychic_Horror_Timer > diff)       Psychic_Horror_Timer -= diff;
+            if (Silence_Timer > diff)              Silence_Timer -= diff;
+            if (Dispersion_Timer > diff)           Dispersion_Timer -= diff;
+            if (Mind_Flay_Timer > diff)            Mind_Flay_Timer -= diff;
+            if (Penance_Timer > diff)              Penance_Timer -= diff;
+            if (CheckDispelTimer > diff)           CheckDispelTimer -= diff;
+            if (ShackleTimer > diff)               ShackleTimer -= diff;
+            if (DevcheckTimer > diff)              DevcheckTimer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            DISPELMAGIC                = lvl >= 70 ? MASS_DISPEL_1 : InitSpell(DISPEL_MAGIC_1);
+            CURE_DISEASE                            = InitSpell(CURE_DISEASE_1);
+            FEAR_WARD                               = InitSpell(FEAR_WARD_1);
+  /*Talent*/PAIN_SUPPRESSION            = lvl >= 50 ? PAIN_SUPPRESSION_1 : 0;
+            PSYCHIC_SCREAM                          = InitSpell(PSYCHIC_SCREAM_1);
+            FADE                                    = InitSpell(FADE_1);
+  /*Talent*/PSYCHIC_HORROR              = lvl >= 50 ? PSYCHIC_HORROR_1 : 0;
+  /*Talent*/SILENCE                     = lvl >= 30 ? SILENCE_1 : 0;
+  /*Talent*/PENANCE                     = lvl >= 60 ? InitSpell(PENANCE_1) : 0;
+  /*Talent*/VAMPIRIC_EMBRACE            = lvl >= 30 ? VAMPIRIC_EMBRACE_1 : 0;
+  /*Talent*/DISPERSION                  = lvl >= 60 ? DISPERSION_1 : 0;
+            MIND_SEAR                               = InitSpell(MIND_SEAR_1);
+  /*Talent*/GUARDIAN_SPIRIT             = lvl >= 60 ? GUARDIAN_SPIRIT_1 : 0;
+            SHACKLE_UNDEAD                          = InitSpell(SHACKLE_UNDEAD_1);
+            HEAL = lvl >= 40 ? InitSpell(GREATER_HEAL_1) : lvl >= 16 ? InitSpell(NORMAL_HEAL_1) : InitSpell(LESSER_HEAL_1);
+            RENEW                                   = InitSpell(RENEW_1);
+            FLASH_HEAL                              = InitSpell(FLASH_HEAL_1);
+            PRAYER_OF_HEALING                       = InitSpell(PRAYER_OF_HEALING_1);
+            DIVINE_HYMN                             = InitSpell(DIVINE_HYMN_1);
+            RESURRECTION                            = InitSpell(RESURRECTION_1);
+            PW_SHIELD                               = InitSpell(PW_SHIELD_1);
+            INNER_FIRE                              = InitSpell(INNER_FIRE_1);
+            PW_FORTITUDE                            = InitSpell(PW_FORTITUDE_1);
+            SHADOW_PROTECTION                       = InitSpell(SHADOW_PROTECTION_1);
+            DIVINE_SPIRIT                           = InitSpell(DIVINE_SPIRIT_1);
+            SW_PAIN                                 = InitSpell(SW_PAIN_1);
+            MIND_BLAST                              = InitSpell(MIND_BLAST_1);
+            SW_DEATH                                = InitSpell(SW_DEATH_1);
+            DEVOURING_PLAGUE                        = InitSpell(DEVOURING_PLAGUE_1);
+  /*Talent*/MIND_FLAY                   = lvl >= 20 ? InitSpell(MIND_FLAY_1) : 0;
+  /*Talent*/VAMPIRIC_TOUCH              = lvl >= 50 ? InitSpell(VAMPIRIC_TOUCH_1) : 0;
+        }
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 65)
+                RefreshAura(BORROWED_TIME); //25%haste/40%bonus
+            if (level >= 55)
+                RefreshAura(DIVINE_AEGIS); //30%
+            if (level >= 55)
+                RefreshAura(EMPOWERED_RENEW3); //15%
+            else if (level >= 50)
+                RefreshAura(EMPOWERED_RENEW2); //10%
+            else if (level >= 45)
+                RefreshAura(EMPOWERED_RENEW1); //5%
+            if (level >= 45)
+                RefreshAura(BODY_AND_SOUL1); //30%
+            if (level >= 50)
+                RefreshAura(PAINANDSUFFERING3); //100%
+            else if (level >= 48)
+                RefreshAura(PAINANDSUFFERING2); //66%
+            else if (level >= 45)
+                RefreshAura(PAINANDSUFFERING1); //33%
+            if (level >= 50)
+                RefreshAura(MISERY3); //3%
+            else if (level >= 48)
+                RefreshAura(MISERY2); //2%
+            else if (level >= 45)
+                RefreshAura(MISERY1); //1%
+            if (level >= 45)
+                RefreshAura(GRACE); //100%
+            if (level >= 35)
+                RefreshAura(IMP_DEV_PLAG); //30%
+            if (level >= 25)
+                RefreshAura(INSPIRATION3); //10%
+            else if (level >= 23)
+                RefreshAura(INSPIRATION2); //6%
+            else if (level >= 20)
+                RefreshAura(INSPIRATION1); //3%
+            if (level >= 30)
+                RefreshAura(SHADOW_WEAVING3); //100%
+            else if (level >= 28)
+                RefreshAura(SHADOW_WEAVING2); //66%
+            else if (level >= 25)
+                RefreshAura(SHADOW_WEAVING1); //33%
+            if (level >= 15)
+            {
+                RefreshAura(GLYPH_SW_PAIN);
+                RefreshAura(GLYPH_PW_SHIELD); //20% heal
+            }
+            if (level >= 40)
+                RefreshAura(SHADOWFORM); //allows dots to crit, passive
+            if (level >= 70)
+                RefreshAura(PRIEST_T10_2P_BONUS);
+        }
+
+    private:
+        uint32
+   /*Buffs*/INNER_FIRE, PW_FORTITUDE, DIVINE_SPIRIT, SHADOW_PROTECTION,
+    /*Disc*/FEAR_WARD, PAIN_SUPPRESSION, SHACKLE_UNDEAD, PW_SHIELD, DISPELMAGIC, CURE_DISEASE, PENANCE,
+    /*Holy*/HEAL, FLASH_HEAL, RENEW, PRAYER_OF_HEALING, DIVINE_HYMN, GUARDIAN_SPIRIT, RESURRECTION,
+  /*Shadow*/SW_PAIN, MIND_BLAST, SW_DEATH, DEVOURING_PLAGUE, MIND_FLAY, VAMPIRIC_TOUCH,
+  /*Shadow*/PSYCHIC_SCREAM, FADE, PSYCHIC_HORROR, VAMPIRIC_EMBRACE, DISPERSION, MIND_SEAR, SILENCE;
+        //Timers/other
+/*Disc*/uint32 Penance_Timer, PWS_Timer, Pain_Suppression_Timer, Fear_Ward_Timer;
+/*Holy*/uint32 Heal_Timer, Divine_Hymn_Timer, Guardian_Spirit_Timer;
+/*Shdw*/uint32 Fade_Timer, Fear_Timer, Mind_Blast_Timer, SW_Death_Timer, Mind_Flay_Timer,
+/*Shdw*/    Psychic_Horror_Timer, Silence_Timer, Dispersion_Timer;
+/*Misc*/uint16 CheckDispelTimer, ShackleTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914,
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMP_DEV_PLAG                    = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770,//33% renew
+        };
+        enum PriestSpecial
+        {
+            WEAKENED_SOUL                   = 6788,
+        };
+    }; //end priest_bot
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..5cbe379
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,356 @@
+#include "bot_ai.h"
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new rogue_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct rogue_botAI : public bot_ai
+    {
+        rogue_botAI(Creature *c) : bot_ai(c)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (InDuel(victim)) return false;
+            if (me->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != HEALINGPOTION/* && spellId != THISTLEPOTION*/) return false;
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1000.f - 1000.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void EnterEvadeMode() { }
+        void Aggro(Unit *){ }
+        void MoveInLineOfSight(Unit *) { }
+        void KilledUnit(Unit *) { }
+        void JustDied(Unit *) { master->SetNpcBotDied(me->GetGUID()); }
+        void AttackStart(Unit *) { }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            opponent = SelectTarget(SELECT_TARGET_TOPAGGRO, 0);
+            if (!opponent && !me->getVictim())
+            {
+                me->CombatStop(true);
+                comboPoints = 1;
+                energy = 100;
+                //ResetOrGetNextTarget();
+                return;
+            }
+
+            me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+            me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+            energy += 2;
+            if (comboPoints > 5) comboPoints = 5;
+
+            //interrupt any spells
+            if (opponent->HasUnitState(UNIT_STATE_CASTING) && energy >= 25)
+            {
+                if (Kick_Timer <= diff)
+                {
+                    doCast(opponent, KICK);
+                    Kick_Timer = 8000;
+                    energy -= 25;
+                }
+                else if (comboPoints > 0)
+                {
+                    switch (comboPoints)
+                    {
+                        case 1: doCast(opponent, KIDNEY_SHOT_1); --comboPoints; break;
+                        //case 2: doCast(opponent, KIDNEY_SHOT_2); comboPoints-=2; break;
+                        //default: doCast(opponent, KIDNEY_SHOT_3); comboPoints=0; break;
+                    }
+                    energy -= 25;
+                }
+            }
+
+            if (!opponent->isInFrontInMap(me, 5) && BS_Timer <= diff && GC_Timer <= diff && energy >= 40)
+            {
+                doCast(opponent, BACKSTAB);
+                BS_Timer = 5000;
+                energy -= 40;
+            }
+            else if (Shadowstep_Timer <= diff && energy > 10 && me->GetDistance(opponent) < 25)
+            {
+                //doCast(opponent, SHADOWSTEP);
+                Shadowstep_Timer = 20000;
+                energy -= 10;
+
+                //NPCs can't really shadowstep so fake it
+                float x = opponent->GetPositionX();
+                float y = opponent->GetPositionY();
+                float z = opponent->GetPositionZ();
+                float o = opponent->GetOrientation();
+
+                me->Relocate(x-4, y-4, z, o);
+                //replace with aura//me->SendMonsterMoveWithSpeed(x-4, y-4, 0, 0);
+                doCast(opponent, BACKSTAB, true);
+                return;
+            }
+
+            if (SliceDice_Timer <= diff && GC_Timer <= diff && comboPoints > 0 && !me->HasAura(SLICE_DICE))
+            {
+                doCast(opponent, SLICE_DICE);
+
+                // since npcs don't use combo points, they can only case
+                // first level of spell.  So only remove 1 combo point
+                --comboPoints;
+
+                SliceDice_Timer = 15000;
+                energy -= 25;
+            }
+
+            /*if (isTimerReady(Mutilate_Timer) && energy>60) 
+            {
+                // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+                // for now use same formula as evicerate
+                uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+                //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+                float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+                int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+                // compensate for lack of attack power
+                damage = damage*(rand()%4+1);
+
+                me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+                //doCast (me, MUTILATE);
+                Mutilate_Timer = 10;
+                comboPoints+=3;
+                energy -= 60;
+            }*/
+
+            /*if (isTimerReady(Eviscerate_Timer) && comboPoints>0 && energy>30) {
+                uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+                //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+                float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+                int damage = irand(int32(base_attPower*5*0.03f),int32(base_attPower*5*0.07f))+minDmg+me->getLevel();
+    //sLog->outError ("EVISCERTE: base_attPower = %u", base_attPower);
+    //sLog->outError("\tminDmg = %f", minDmg);
+    //sLog->outError("\tmaxDmg = %f", me->GetWeaponDamageRange(BASE_ATTACK, MAXDAMAGE));
+    //sLog->outError ("\tMINDAMAGE after setting it = %f", me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE));
+
+    // compensate for lack of attack power
+    //sLog->outError ("\tdamage before = %u", damage);
+                damage = damage*(rand()%4+1);
+    //sLog->outError ("\tdamage after = %u", damage);
+                // Eviscerate and Envenom Bonus Damage (Deathmantle item set effect)
+                if (me->HasAura(37169))
+                    damage += comboPoints*100;
+
+                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false, NULL, NULL);
+                //doCast(opponent, EVISCERATE);
+                comboPoints = 1;
+
+                energy -= 30;
+                Eviscerate_Timer = 150;
+             //   return;
+            }*/
+
+            if (SinisterStrike_Timer <= diff && GC_Timer <= diff && comboPoints < 5 && energy>40)
+            {
+                doCast(opponent, SINISTER_STRIKE);
+                //me->Say("sinister strike", LANG_UNIVERSAL, NULL);
+                ++comboPoints;
+                SinisterStrike_Timer = 6000;
+                energy -= 40;
+            }
+
+            if (Rupture_Timer <= diff && GC_Timer <= diff && energy>25)
+            {
+                doCast(opponent, RUPTURE);
+                comboPoints = 0;
+                Rupture_Timer = 12000;
+                energy -= 25;
+            }
+
+            /*if (!opponent->HasAuraType(SPELL_AURA_MOD_DISARM))
+                doCast(opponent, DISMANTLE);*/
+
+            /*
+                since npc can't really use poison, we'll pretend that we were able to poison his blades.
+            */
+            if (Poison_Timer <= diff)
+            {
+                //Deadly Poison has 40% chance of proccing
+                switch(rand()%5)
+                {
+                    case 0:
+                    case 1:
+                    case 2:
+                        break;
+                    case 4:
+                    case 5:
+                        if (DEADLY_POISON) DoCast(opponent, DEADLY_POISON, true); 
+                        break;
+                }
+
+                //Wound Poison has 50% chance of procing
+                switch (rand()%2)
+                {
+                    case 0:
+                         break;
+                    case 1:
+                         if (WOUND_POISON) DoCast(opponent, WOUND_POISON, true); 
+                         break;
+                }
+                //Mind Numbing Poison = 50% - in help to other bots' 'counters'
+                switch (rand()%2)
+                {
+                    case 0:
+                        break;
+                    case 1:
+                        if (MIND_NUMBING_POISON) DoCast(opponent, MIND_NUMBING_POISON, true);
+                        break;
+                }
+
+                Poison_Timer = 1200;
+            }
+
+            //if low on health, drink a potion
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+            }
+
+            me->SetPower(POWER_ENERGY, energy);
+
+            ScriptedAI::UpdateAI(diff);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            BS_Timer = 0;
+            Mutilate_Timer = 0;
+            SinisterStrike_Timer = 0;
+            Eviscerate_Timer = 0;
+            SliceDice_Timer = 0;
+            Rupture_Timer = 0;
+            Kick_Timer = 0;
+            Poison_Timer = 0;
+            Shadowstep_Timer = 0;
+            comboPoints = 0;
+
+            me->setPowerType(POWER_ENERGY);
+            me->SetMaxPower(POWER_ENERGY, 100);
+            me->SetPower(POWER_ENERGY, 100);
+
+            if (master)
+            {
+                setStats(CLASS_ROGUE, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_ROGUE);
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (BS_Timer > diff)                    BS_Timer -= diff;
+            if (Kick_Timer > diff)                  Kick_Timer -= diff;
+            if (SliceDice_Timer > diff)             SliceDice_Timer -= diff;
+            if (SinisterStrike_Timer > diff)        SinisterStrike_Timer -= diff;
+            if (Eviscerate_Timer > diff)            Eviscerate_Timer -= diff;
+            if (Rupture_Timer > diff)               Rupture_Timer -= diff;
+            if (Poison_Timer > diff)                Poison_Timer -= diff;
+            if (Shadowstep_Timer > diff)            Shadowstep_Timer -= diff;
+            if (Mutilate_Timer > diff)              Mutilate_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            BACKSTAB                                = InitSpell(BACKSTAB_1);
+            SINISTER_STRIKE                         = InitSpell(SINISTER_STRIKE_1);
+            SLICE_DICE                              = InitSpell(SLICE_DICE_1);
+            EVISCERATE                              = InitSpell(EVISCERATE_1);
+            KICK                                    = InitSpell(KICK_1);
+            RUPTURE                                 = InitSpell(RUPTURE_1);
+            KIDNEY_SHOT                             = InitSpell(KIDNEY_SHOT_1);
+            MUTILATE                    = lvl >= 50 ? InitSpell(MUTILATE_1) : 0;
+            SHADOWSTEP                  = lvl >= 50 ? SHADOWSTEP_1 : 0;
+            DISMANTLE                               = InitSpell(DISMANTLE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+        }
+
+    private:
+        uint32
+            BACKSTAB, SINISTER_STRIKE, SLICE_DICE, EVISCERATE, KICK, RUPTURE, KIDNEY_SHOT, MUTILATE,
+            SHADOWSTEP, DISMANTLE;
+        //Timers/other
+        uint32 BS_Timer, SinisterStrike_Timer, Eviscerate_Timer, SliceDice_Timer, Rupture_Timer, Kick_Timer, 
+            Poison_Timer, Shadowstep_Timer, Mutilate_Timer;
+        uint8 energy, comboPoints;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1757,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,//11300
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,//8643
+  /*Talent*/MUTILATE_1                          = 1329,//48666
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+        };
+
+        enum RoguePassives
+        {
+        };
+
+        enum RogueSpecial
+        {
+            WOUND_POISON                        = 13218,
+            DEADLY_POISON                       = 2818,
+            MIND_NUMBING_POISON                 = 5760,
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..885e9aa
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,288 @@
+#include "bot_ai.h"
+
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new shaman_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct shaman_botAI : public bot_ai
+    {
+        shaman_botAI(Creature *c) : bot_ai(c)
+        {
+            Reset();
+        }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (Feasting() && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (InDuel(victim)) return false;
+            if (me->HasAuraWithMechanic(MECHANIC_SILENCE) && spellId != MANAPOTION && spellId != HEALINGPOTION) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void KilledUnit(Unit *) { }
+        void JustDied(Unit *) { master->SetNpcBotDied(me->GetGUID()); }
+        void Aggro(Unit *){}
+        void EnterEvadeMode() { }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->getVictim()) Evade();
+            if (me->getVictim())
+                DoMeleeAttackIfReady();
+            CheckAuras();
+            if (CCed(me)) return;
+            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
+            {
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+            }
+            BuffAndHealGroup(master, diff);
+            // Heal myself
+            HealTarget(me, GetHealthPCT(me), diff);
+
+            //the rest are combat so return if not fighting
+            opponent = SelectTarget(SELECT_TARGET_TOPAGGRO);
+            if (!opponent && !me->getVictim())
+            {
+                me->CombatStop(true);
+                DoNonCombatActions(diff);
+                return;
+            }
+
+            //Cast totems.
+            if (me->isInCombat() && GC_Timer <= diff && !HasAuraName(master, STONESKIN_AURA))
+            {
+                doCast(me, STONESKIN_TOTEM);
+                return;
+            }
+
+            //if (me->isInCombat() &&
+            //    GC_Timer <= diff)
+            //{
+            //    doCast(me, SEARING_TOTEM);
+            //    return;
+            //}
+
+            if (me->isInCombat() && GC_Timer <= diff && !HasAuraName(master, WINDFURY_TOTEM))
+            {
+                doCast(me, WINDFURY_TOTEM);
+                return;
+            }
+
+            if (me->isInCombat())
+            {
+                switch (master->getClass())
+                {
+                    case CLASS_WARRIOR:
+                    case CLASS_DEATH_KNIGHT:
+                    case CLASS_ROGUE:
+                    {
+                        if (GC_Timer <= diff && !HasAuraName(master, HEALINGSTREAM_AURA))
+                        {
+                            doCast(me, HEALINGSTREAM_TOTEM);
+                            return;
+                        }
+                        break;
+                    }
+                    default: //everyone else gets a mana totem
+                    {
+                        if (GC_Timer <= diff && !HasAuraName(master, MANASPRING_AURA))
+                        {
+                            doCast(me, MANASPRING_TOTEM);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            if (Flame_Shock_Timer <= diff && GC_Timer <= diff &&
+                !opponent->HasAura(FLAME_SHOCK))
+            {
+                doCast(opponent, FLAME_SHOCK);
+                Flame_Shock_Timer = 15000;
+                return;
+            }
+
+            if (Lightning_Bolt_Timer <= diff && GC_Timer <= diff)
+            {
+                doCast(opponent, LIGHTNING_BOLT);
+                Lightning_Bolt_Timer = 9000;
+                return;
+            }
+
+            if (Earth_Shock_Timer <= diff &&
+                !opponent->HasAura(FLAME_SHOCK))
+            {
+                doCast(opponent, EARTH_SHOCK);
+                Earth_Shock_Timer = 21000;
+                return;
+            }
+        }
+
+        void DoNonCombatActions(const uint32 diff)
+        {
+            if (GC_Timer <= diff && !me->HasAura(LIGHTNING_SHIELD))
+                doCast(me, LIGHTNING_SHIELD);
+
+            if (master->GetGroup())
+            {
+                RezGroup(ANCESTRAL_SPIRIT, master);
+                BuffAndHealGroup(master, diff);
+               // CureGroup(master, diff);
+            }
+        }
+
+        bool HealTarget(Unit *target, uint8 hp, const uint32 diff)
+        {
+            if (hp > 95) return false;
+            if (GC_Timer > diff) return false;
+            if (IsCasting()) return false;
+            if (!target || target->isDead()) return false;
+
+            if (hp < 100 && Lesser_Heal_Timer <= diff)
+            {
+                doCast(target, LESSER_HEAL);
+                Lesser_Heal_Timer = 1000;
+                return true;
+            } 
+            else
+
+            if (hp < 75 && Heal_Timer <= diff)
+            {
+                doCast(target, CHAIN_HEAL);
+            }
+            return true;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Lesser_Heal_Timer = 0;
+            Flame_Shock_Timer = 0;
+            Lightning_Bolt_Timer = 0;
+            Earth_Shock_Timer = 0;
+
+            if (master)
+            {
+                setStats(CLASS_SHAMAN, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_SHAMAN);
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Heal_Timer > diff)              Heal_Timer -= diff;
+            if (Lesser_Heal_Timer > diff)       Lesser_Heal_Timer -= diff;
+            if (Flame_Shock_Timer > diff)       Flame_Shock_Timer -= diff;
+            if (Earth_Shock_Timer > diff)       Earth_Shock_Timer -= diff;
+            if (Lightning_Bolt_Timer > diff)    Lightning_Bolt_Timer -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            //uint8 lvl = me->getLevel();
+            CHAIN_HEAL                              = InitSpell(CHAIN_HEAL_1);
+            LESSER_HEAL                             = InitSpell(LESSER_HEAL_1);
+            ANCESTRAL_SPIRIT                        = InitSpell(ANCESTRAL_SPIRIT_1);
+            FLAME_SHOCK                             = InitSpell(FLAME_SHOCK_1);
+            EARTH_SHOCK                             = InitSpell(EARTH_SHOCK_1);
+            LIGHTNING_BOLT                          = InitSpell(LIGHTNING_BOLT_1);
+            LIGHTNING_SHIELD                        = InitSpell(LIGHTNING_SHIELD_1);
+            STONESKIN_TOTEM                         = InitSpell(STONESKIN_TOTEM_1);
+            HEALINGSTREAM_TOTEM                     = InitSpell(HEALINGSTREAM_TOTEM_1);
+            MANASPRING_TOTEM                        = InitSpell(MANASPRING_TOTEM_1);
+            SEARING_TOTEM                           = InitSpell(SEARING_TOTEM_1);
+            WINDFURY_TOTEM                          = InitSpell(WINDFURY_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+        }
+
+    private:
+        uint32
+            CHAIN_HEAL, LESSER_HEAL, ANCESTRAL_SPIRIT,
+            FLAME_SHOCK, EARTH_SHOCK, LIGHTNING_BOLT, LIGHTNING_SHIELD,
+            STONESKIN_TOTEM, HEALINGSTREAM_TOTEM, MANASPRING_TOTEM, SEARING_TOTEM, WINDFURY_TOTEM;
+        //Timers
+        uint32 Heal_Timer, Lesser_Heal_Timer, Flame_Shock_Timer, Earth_Shock_Timer, Lightning_Bolt_Timer;
+
+        enum ShamanBaseSpells
+        {
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEAL_1                       = 8004,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            LIGHTNING_BOLT_1                    = 403,
+            LIGHTNING_SHIELD_1                  = 324,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+        };
+
+        enum ShamanPassives
+        {
+        };
+
+        enum ShamanSpecial
+        {
+            STONESKIN_AURA                      = 8072,
+            HEALINGSTREAM_AURA                  = 5672,
+            MANASPRING_AURA                     = 5677,
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..7229eeb
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,325 @@
+#include "bot_ai.h"
+
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new warlock_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct warlock_botAI : public bot_ai
+    {
+        warlock_botAI(Creature *c) : bot_ai(c) { }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (me->IsMounted()) return false;
+            if (IsCasting()) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (Feasting() && !master->isInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) return false;
+            if (InDuel(victim)) return false;
+            if (spellId != MANAPOTION && spellId != HEALINGPOTION && me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED)) return false;
+
+            if (spellId == MANAPOTION)
+            {
+                int32 value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+                me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+                return true;
+            }
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void MoveInLineOfSight(Unit *) { }
+        void KilledUnit(Unit *) { }
+        void EnterEvadeMode() { }
+        void EnterCombat(Unit*) { }
+        void JustDied(Unit *) { /*if (GetPet()) RemovePet();*/ master->SetNpcBotDied(me->GetGUID()); }
+        void Aggro(Unit *) { }
+        void AttackStart(Unit *) { }
+
+        void DoNonCombatActions()
+        {}
+
+        void StartAttack(Unit *u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            GetInPosition(force, true);
+            SetBotCommandState(COMMAND_ATTACK);
+            fear_cd = std::max(fear_cd, uint32(1000));
+            //if (Creature *pet = GetPet())
+            //{
+            //    if (pet->isAlive())
+            //    {
+            //        pet->AddThreat(u, 0.001f);
+            //        u->AddThreat(pet, 0.001f);
+            //        //pet->SetBotCommandState(COMMAND_ATTACK);
+            //    }
+            //}
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (!me->getVictim())
+                Evade();
+            //if pet is dead or no permission
+            //if (Creature *pet = GetPet())
+            //    if (pet->isDead() || 
+            //        me->GetExactDist(pet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f || 
+            //        !me->canSeeOrDetect(pet, true, true))
+            //        RemovePet();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            //if (!pet)
+            //    CreatePet();
+            CheckAuras();
+            if (CCed(me)) return;
+
+            //TODO: implement healthstone
+            if (GetHealthPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (GetManaPCT(me) < 50 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                    Potion_cd = POTION_CD;
+                GC_Timer = temptimer;
+            }
+            if (!me->isInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(const uint32 diff)
+        {
+            opponent = me->getVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+            //double check that pet didn't just die
+            //if (GetPet() && pet->isDead())
+            //    RemovePet();
+            //send in the pet
+            //if (Creature *pet = GetPet())
+            //{
+            //    if (pet->isAlive() && pet->getVictim() != opponent)
+            //    {
+            //        pet->Attack(opponent, true);
+            //        pet->GetMotionMaster()->MoveChase(opponent);
+            //    }
+            //}
+
+            //TODO: add more damage spells, add pet relations n' handling
+
+            if (fear_cd <= diff && GC_Timer <= diff)
+            { CheckFear(); fear_cd = 2000; }
+
+            if (RAIN_OF_FIRE && Rand() < 25 && Rain_of_fire_cd <= diff && GC_Timer <= diff)
+            {
+                Unit *blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, RAIN_OF_FIRE))
+                {
+                    Rain_of_fire_cd = 5000;
+                    return;
+                }
+                Rain_of_fire_cd = 2000;//fail
+            }
+
+            if (Rand() < 25 && CURSE_OF_THE_ELEMENTS && GC_Timer <= diff && !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS) && 
+                doCast(opponent, CURSE_OF_THE_ELEMENTS))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (GC_Timer <= 0 && Rand() < 25 && !opponent->HasAura(CORRUPTION, me->GetGUID()) && 
+                doCast(opponent, CORRUPTION))
+                { return; }
+
+            if (HAUNT && Rand() < 25 && Haunt_cd <= diff && GC_Timer <= diff && !opponent->HasAura(HAUNT, me->GetGUID()) && 
+                doCast(opponent, HAUNT))
+            {
+                Haunt_cd = 8000;
+                return;
+            }
+
+            if (GC_Timer <= diff && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (conflagarate_cd <= 8000 && doCast(opponent, IMMOLATE))
+                    return;
+                else if (UNSTABLE_AFFLICTION && doCast(opponent, UNSTABLE_AFFLICTION))
+                    return;
+            }
+
+            if (CONFLAGRATE && Rand() < 35 && conflagarate_cd <= diff && GC_Timer <= diff && 
+                HasAuraName(opponent, IMMOLATE) && 
+                doCast(opponent, CONFLAGRATE))
+            {
+                conflagarate_cd = 10000;
+                return;
+            }
+
+            if (CHAOS_BOLT && Rand() < 50 && chaos_bolt_cd <= diff && GC_Timer <= diff && doCast(opponent, CHAOS_BOLT))
+            {
+                chaos_bolt_cd = 16000 - me->getLevel() * 100;
+                return;
+            }
+
+            if (GC_Timer <= diff && doCast(opponent, SHADOW_BOLT))
+                return;
+
+        } //DoNormalAttack
+
+        uint8 Afflicted(Unit *target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            if (Unit *u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura *aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit *feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR)) {}
+        }
+
+        //void CreatePet()
+        //{
+        //    if (master->getLevel() >= 20 && !me->isInCombat() && !GetPet())
+        //        SetPet(me->GetBotsPet(60237));
+        //}
+
+        //void RemovePet()
+        //{
+        //    me->SetBotsPetDied();
+        //    SetPet(NULL);
+        //}
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            Rain_of_fire_cd = 0;
+            Haunt_cd = 0;
+            conflagarate_cd = 0;
+            chaos_bolt_cd = 0;
+            fear_cd = 0;
+
+            if (master)
+            {
+                setStats(CLASS_WARLOCK, me->getRace(), master->getLevel(), true);
+                //TODO: passives
+                ApplyClassPassives();
+                ApplyPassives(CLASS_WARLOCK);
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (Rain_of_fire_cd > diff)     Rain_of_fire_cd -= diff;
+            if (Haunt_cd > diff)            Haunt_cd -= diff;
+            if (conflagarate_cd > diff)     conflagarate_cd -= diff;
+            if (chaos_bolt_cd > diff)       chaos_bolt_cd -= diff;
+            if (fear_cd > diff)             fear_cd -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            CURSE_OF_THE_ELEMENTS                   = InitSpell(CURSE_OF_THE_ELEMENTS_1);
+            SHADOW_BOLT                             = InitSpell(SHADOW_BOLT_1);
+            IMMOLATE                                = InitSpell(IMMOLATE_1);
+            CONFLAGRATE                 = lvl >= 40 ? CONFLAGRATE_1 : 0;
+  /*Talent*/CHAOS_BOLT                  = lvl >= 60 ? InitSpell(CHAOS_BOLT_1) : 0;
+            RAIN_OF_FIRE                            = InitSpell(RAIN_OF_FIRE_1);
+  /*Talent*/HAUNT                       = lvl >= 60 ? InitSpell(HAUNT_1) : 0;
+            CORRUPTION                              = InitSpell(CORRUPTION_1);
+  /*Talent*/UNSTABLE_AFFLICTION         = lvl >= 50 ? InitSpell(UNSTABLE_AFFLICTION_1) : 0;
+            FEAR                                    = InitSpell(FEAR_1);
+        }
+
+        void ApplyClassPassives() {}
+
+    private:
+        uint32 
+  /*Curses*/CURSE_OF_THE_ELEMENTS, 
+/*Destruct*/SHADOW_BOLT, IMMOLATE, CONFLAGRATE, CHAOS_BOLT, RAIN_OF_FIRE, 
+ /*Afflict*/HAUNT, CORRUPTION, UNSTABLE_AFFLICTION, 
+   /*Other*/FEAR;
+        //Timers
+        uint32 Rain_of_fire_cd, Haunt_cd, conflagarate_cd, chaos_bolt_cd, fear_cd;
+
+        enum WarlockBaseSpells// all orignals
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215,
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..09e5857
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1132 @@
+#include "bot_ai.h"
+#include "SpellAuraEffects.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@mail.ru)
+Complete - Around 50-55%
+TODO: Solve 'DeathWish + Enrage', Thunder Clap, Piercing Howl, Challenging Shout, other tanking stuff
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI *GetAI(Creature *pCreature) const
+    {
+        return new warrior_botAI(pCreature);
+    }
+
+    bool OnGossipHello(Player *player, Creature * /*creature*/)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct warrior_botAI : public bot_ai
+    {
+        warrior_botAI(Creature *c) : bot_ai(c) { }
+
+        bool doCast(Unit *victim, uint32 spellId, bool triggered = false)
+        {
+            if (spellId == 0) return false;
+            if (me->IsMounted()) return false;
+            if (me->IsNonMeleeSpellCasted(true)) return false;
+            if (!CheckImmunities(spellId, victim)) return false;
+            if (me->HasAura(BLADESTORM)) return false;
+            if (InDuel(victim)) return false;
+            info = sSpellMgr->GetSpellInfo(spellId);
+            if (info->CalcPowerCost(me, info->GetSchoolMask()) > me->GetPower(Powers(info->PowerType)))
+                return false;
+            if (spellId != HEALINGPOTION)
+                me->SetStandState(UNIT_STAND_STATE_STAND);
+            value = int32(1500.f - 1500.f * (float(GetHaste()) / 100.f));
+            GC_Timer = value < 500 ? 500 : value;
+
+            if (!victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+                me->Relocate(victim);
+            DoCast(victim, spellId, triggered);
+            return true;
+        }
+
+        void UpdateAI(const uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            if (me->getVictim())
+                DoMeleeAttackIfReady();
+            else
+                Evade();
+            if (checkAurasTimer == 0)
+            {
+                SS = SWEEPING_STRIKES && me->HasAura(SWEEPING_STRIKES);
+                CheckAuras();
+            }
+
+            if (ragetimer2 <= diff)
+            {
+                if (me->isInCombat() && me->getLevel() >= 20)
+                {
+                    if (getrage() < 990)
+                        me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000);//max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->isInCombat() && !HasAuraName(me, BLOODRAGE_1))
+                {
+                    if (getrage() > uint32(10.f*rageLossMult))
+                        me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult));//-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0);//min
+                }
+                ragetimer = 1500;
+                //if (getrage() > 1000) me->SetPower(POWER_RAGE, 1000);
+                //if (getrage() < 10) me->SetPower(POWER_RAGE, 0);
+            }
+
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (GetHealthPCT(me) < 67 && Potion_cd <= diff)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckIntervene(diff);
+            if (!me->isInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(CLASS_WARRIOR))
+            {
+                if (tank != me && !me->isInCombat() && battleStance != true && master->getAttackers().empty() && stancetimer <= diff)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (Rand() < 30 && battleShout_cd <= diff && GC_Timer <= diff && getrage() > 100 && 
+                !HasAuraName(master, BATTLESHOUT) && 
+                !HasAuraName(master, "Blessing of Might") && 
+                !HasAuraName(master, "Greater Blessing of Might") && 
+                master->IsWithinLOSInMap(me) && 
+                doCast(me, BATTLESHOUT))
+                battleShout_cd = BATTLESHOUT_CD;
+
+            if (Rand() < 20 && BLOODRAGE && bloodrage_cd <= diff && me->isInCombat() && getrage() < 500 && 
+                !me->HasAura(ENRAGED_REGENERATION))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOODRAGE))
+                {
+                    bloodrage_cd = BLOODRAGE_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit *u, bool force = false)
+        {
+            if (GetBotCommandState() == (COMMAND_ATTACK) && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            GetInPosition(force, false);
+        }
+
+        void Aggro(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void EnterCombat(Unit*) { }
+        void JustDied(Unit*) { master->SetNpcBotDied(me->GetGUID()); }
+        void AttackStart(Unit*) { }
+        void DoNonCombatActions(const uint32 /*diff*/)
+        {}
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+            {
+                //sLog->outBasic("bot_ai::warrior_ai::modrage(): %s is trying to set rage to a negative value!", me->GetName());
+                return;
+            }
+            if (mod < 0 && rage < uint32(abs(mod)))
+            {
+                //sLog->outBasic("bot_ai::warrior_ai::modrage(): %s is trying to modify rage to a negative value!", me->GetName());
+                return;
+            }
+            if (set)
+                rage = mod*10;
+            else
+                rage += mod*10;
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        uint32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            return rage;
+        }
+
+        void BreakCC(const uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (BERSERKERRAGE && !me->HasAura(ENRAGED_REGENERATION) && 
+                    berserkerRage_cd <= diff && GC_Timer <= diff && doCast(me, BERSERKERRAGE))
+                {
+                    berserkerRage_cd = BERSERKERRAGE_CD;
+                    if (me->getLevel() >= 40)
+                        modrage(20);
+                    return;
+                }
+                else if (pvpTrinket_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, PVPTRINKET))
+                    {
+                        pvpTrinket_cd = PVPTRINKET_CD;
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+            if (pvpTrinket_cd <= diff && (CCed(me) || HasAuraName(me, "Sleep")))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, PVPTRINKET))
+                {
+                    pvpTrinket_cd = PVPTRINKET_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void Attack(const uint32 diff)
+        {
+            opponent = me->getVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep stance in raid if tank
+            if (master->GetBotTankGuid() == me->GetGUID() && 
+                defensiveStance != true && stancetimer <= diff/* && 
+                (!master->GetGroup() || master->GetGroup()->isRaidGroup())*/)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (ENRAGED_REGENERATION)
+            {
+                if (Rand() < 20 && GetHealthPCT(me) < 40 && getrage() > 150 && regen_cd <= diff && 
+                    me->HasAuraWithMechanic(MECHANIC_ENRAGED))//no GC_Timer
+                {
+                    temptimer = 0;
+                    if (doCast(me, ENRAGED_REGENERATION))
+                    {
+                        regen_cd = ENRAGED_REGENERATION_CD;
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                //maybe not needed part
+                if (me->HasAura(ENRAGED_REGENERATION))
+                {
+                    if (HasAuraName(me, "Enrage"))
+                        me->RemoveAurasWithMechanic(MECHANIC_ENRAGED);
+                    if (HasAuraName(me, BLOODRAGE))
+                        me->RemoveAurasDueToSpell(BLOODRAGE);
+                    if (HasAuraName(me, DEATHWISH))
+                        me->RemoveAurasDueToSpell(DEATHWISH);
+                    if (HasAuraName(me, BERSERKERRAGE))
+                        me->RemoveAurasDueToSpell(BERSERKERRAGE);
+                }
+            }//end SelfHeal
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (CHARGE && charge_cd <= diff && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) && 
+                (me->getLevel() >= 50 || 
+                (!me->isInCombat() && (battleStance == true || stanceChange(diff, 1)))))
+            {
+                bool combat = me->isInCombat();
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 50)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, CHARGE, combat))
+                {
+                    charge_cd = CHARGE_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (INTERCEPT && intercept_cd <= diff && 
+                getrage() > 100 && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) && 
+                !CCed(opponent) && (berserkerStance == true || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, INTERCEPT))
+                {
+                    intercept_cd = INTERCEPT_CD;
+                    //modrage(-10);
+                    return;
+                }
+            }
+            //FEAR
+            if (Rand() < 70 && INTIMIDATING_SHOUT && getrage() > 250 && intimidatingShout_cd <= diff && GC_Timer <= diff)
+            {
+                if (opponent->IsNonMeleeSpellCasted(false, false, true) && dist <= 8 && 
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, INTIMIDATING_SHOUT))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        return;
+                    }
+                }
+                Unit *fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() && 
+                    ((master->getClass() != CLASS_DEATH_KNIGHT && 
+                    master->getClass() != CLASS_WARRIOR && 
+                    master->getClass() != CLASS_PALADIN) || 
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        if (triggered)
+                            modrage(-25);
+                        return;
+                    }
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 0) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 0 && doCast(fearTarget, INTIMIDATING_SHOUT, triggered))
+                    {
+                        intimidatingShout_cd = INTIMIDATINGSHOUT_CD;
+                        if (triggered)
+                            modrage(-25);
+                        return;
+                    }
+                }
+            }//end FEAR
+            //OVERPOWER
+            if (OVERPOWER && getrage() > 50 && meleedist <= 5 && GC_Timer <= diff && (battleStance == true || stancetimer <= diff))
+            {
+                bool blood = me->HasAura(TASTE_FOR_BLOOD_BUFF);
+                if ((((opponent->GetTypeId() == TYPEID_PLAYER && UNRELENTING_ASSAULT && me->HasAura(TASTE_FOR_BLOOD_BUFF) && opponent->IsNonMeleeSpellCasted(false) && overpower_cd <= 3000) || 
+                    (opponent->IsNonMeleeSpellCasted(false) && blood) || 
+                    (overpower_cd <= diff && me->HasAura(TASTE_FOR_BLOOD_BUFF)))))
+                {
+                    if (battleStance == true || stanceChange(diff, 1))
+                    {
+                        if (doCast(opponent, OVERPOWER))
+                        {
+                            overpower_cd = 5000;
+                            if (blood)
+                                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+            //{ wait = 5; return; }
+            //HAMSTRING
+            if (HAMSTRING && Rand() < 50 && getrage() > 100 && GC_Timer <= diff && meleedist <= 5 && opponent->isMoving() && 
+                (battleStance == true || berserkerStance == true || stancetimer <= diff) && 
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance == true || berserkerStance == true || stanceChange(diff, 5))
+                    if (doCast(opponent, HAMSTRING))
+                        return;
+            }
+            //UBERS
+            //Dont use RETA unless capable circumstances
+            if (Rand() < 20 && uber_cd <= diff && GC_Timer <= diff)//mod here
+            {
+                if (RETALIATION && b_attackers.size() > 4 && 
+                    (battleStance == true || stanceChange(diff, 1)))
+                {
+                    if (doCast(me, RETALIATION))
+                    {
+                        uber_cd = UBER_CD;
+                        return;
+                    }
+                }
+                //Dont use RECKL unless capable circumstances
+                if (RECKLESSNESS && tank != me && 
+                    (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth()*10) && 
+                    (berserkerStance == true || stanceChange(diff, 3)))
+                {
+                    if (doCast(me, RECKLESSNESS))
+                    {
+                        uber_cd = UBER_CD;
+                        return;
+                    }
+                }
+            }
+            //DEATHWISH
+            if (DEATHWISH && Rand() < 20 && deathwish_cd <= diff && GC_Timer <= diff && 
+                getrage() > 100 && opponent->GetHealth() > me->GetHealth()/2 && 
+                !me->HasAura(ENRAGED_REGENERATION))//mod here
+            {
+                if (doCast(me, DEATHWISH))
+                {
+                    //modrage(-10);
+                    deathwish_cd = DEATHWISH_CD;
+                    return;
+                }
+            }
+            //TAUNT
+            Unit *u = opponent->getVictim();
+            if (TAUNT && taunt_cd <= diff && u && u != me && u != tank && dist <= 30 &&
+                (IsInBotParty(u) || tank == me) && !CCed(opponent) && 
+                (defensiveStance == true || (stancetimer <= diff && stanceChange(diff, 2))))//No GCD
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, TAUNT, true))
+                {
+                    taunt_cd = TAUNT_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //EXECUTE
+            if (EXECUTE && tank != me && Rand() < 70 && GC_Timer <= diff && getrage() > 150 && meleedist <= 5 && GetHealthPCT(opponent) < 19.8f && 
+                (battleStance == true || berserkerStance == true || stancetimer <= diff))
+            {
+                if ((battleStance == true || berserkerStance == true || stanceChange(diff, 5)) && 
+                    doCast(opponent, EXECUTE))
+                {
+                    //sudden death
+                    if (me->getLevel() >= 50 && getrage() <= 400)
+                        modrage(10, true);
+                    else if (getrage() > 300)
+                        modrage(-30);
+                    else
+                        modrage(0, true);
+                    return;
+                }
+            }
+            //SUNDER
+            if (SUNDER && Rand() < 35 && meleedist <= 5 && tank == me && 
+                opponent->GetHealth() > me->GetMaxHealth() && 
+                GC_Timer <= diff && getrage() > 150 && (sunder_cd <= diff || getrage() > 500))
+            {
+                Aura *sunder = opponent->GetAura(SUNDER, me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) && 
+                    doCast(opponent, SUNDER))
+                {
+                    sunder_cd = SUNDER_CD;
+                    GC_Timer = 1000;
+                    return;
+                }
+            }
+            //SS
+            if (SWEEPING_STRIKES && tank != me && Rand() < 20 && 
+                (battleStance == true || berserkerStance == true || stancetimer <= diff) && 
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)) && sweeping_strikes_cd <= diff)//no GC_Timer
+            {
+                temptimer = GC_Timer;
+                if ((battleStance == true || berserkerStance == true || stanceChange(diff, 5)) && 
+                    doCast(me, SWEEPING_STRIKES, true))//no rage use as with glyph
+                {
+                    SS = true;
+                    sweeping_strikes_cd = SWEEPING_STRIKES_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (WHIRLWIND && Rand() < 50 && whirlwind_cd <= diff && GC_Timer <= diff && getrage() >= 250 && 
+               (FindSplashTarget(7, opponent) || (getrage() > 500 && dist <= 7)) && 
+               (berserkerStance == true || stancetimer <= diff))
+            {
+                if ((berserkerStance == true || stanceChange(diff, 3)) && 
+                    doCast(me, WHIRLWIND))
+                {
+                    whirlwind_cd = WHIRLWIND_CD;
+                    return;
+                }
+            }
+            //BLADESTORM
+            if (BLADESTORM && bladestorm_cd <= diff && GC_Timer <= diff && 
+               getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS)) && 
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            {
+                if (doCast(me, BLADESTORM))
+                {
+                    bladestorm_cd = BLADESTORM_CD;
+                    return;
+                }
+            }
+            //Mortal Strike
+            if (MORTALSTRIKE && getrage() > 300 && meleedist <= 5 && mortalStrike_cd <= diff && GC_Timer <= diff)
+            {
+                if (doCast(opponent, MORTALSTRIKE/*, true*/))
+                {
+                    mortalStrike_cd = MORTALSTRIKE_CD;
+                    slam_cd = 0;//reset here
+                }
+            }
+            //Slam
+            bool triggered = mortalStrike_cd >= 6900;
+            if (SLAM && Rand() < (30 + triggered*60) && slam_cd <= diff && getrage() > 150 && meleedist <= 5)
+            {
+                if (doCast(opponent, SLAM, triggered))
+                {
+                    slam_cd = 4500;//4.5sec (must be > MORTALSTRIKE_CD/2)
+                    if (triggered)
+                        modrage(-15);
+                    return;
+                }
+            }
+            //PUMMEL
+            if (PUMMEL && Rand() < 80 && pummel_cd <= diff && getrage() > 100 && meleedist <= 5 && 
+                opponent->IsNonMeleeSpellCasted(false) && 
+                (berserkerStance == true || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((berserkerStance == true || stanceChange(diff, 3)) && 
+                    doCast(opponent, PUMMEL))
+                {
+                    pummel_cd = PUMMEL_CD;
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (REND && Rand() < 30 && getrage() > 100 && GC_Timer <= diff && meleedist <= 5 && 
+                opponent->GetHealth() > me->GetHealth()/2 && 
+                (battleStance == true || defensiveStance == true || stancetimer <= diff) && 
+                !opponent->HasAura(REND, me->GetGUID()))
+            {
+                if ((battleStance == true || defensiveStance == true || stanceChange(diff, 1)) && 
+                    doCast(opponent, REND))
+                    return;
+            }
+            //Cleave
+            if (Rand() < 30 && CLEAVE && cleave_cd <= diff && me->getLevel() >= 20 && getrage() > 200 && meleedist <= 5)//noGC_Timer
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, CLEAVE))
+                {
+                    rage -= 200;//not visible
+                    cleave_cd = me->getAttackTimer(BASE_ATTACK);//once per swing, prevents rage loss
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            else {}//HEROIC STRIKE placeholder
+            //DISARM DEPRECATED
+            /*if (disarm_cd <= diff && meleedist < 5 &&
+                (opponent->getVictim()->GetGUID() == master->GetGUID() || 
+                opponent->getVictim()->GetGUID() == m_creature->GetGUID()) &&
+                getrage() > 15 &&
+                !HasAuraName(opponent, GetSpellName(DISARM)) &&
+                GC_Timer <= diff)
+            {
+                if (opponent->getClass() == CLASS_ROGUE  ||
+                    opponent->getClass() == CLASS_WARRIOR   ||
+                    opponent->getClass() == CLASS_SHAMAN    ||
+                    opponent->getClass() == CLASS_PALADIN)
+                {
+                    if (defensiveStance == true)
+                    {
+                        doCast(opponent, DISARM, true);
+                        //rage -= 100;
+                        disarm_cd = DISARM_CD;
+                    }
+                    else stanceChange(diff, 2);
+                }
+            }*/
+        }//end Attack
+
+        void CheckIntervene(const uint32 diff)
+        {
+            if (INTERVENE && intervene_cd <= diff && getrage() > 100 && Rand() < ((tank == me) ? 80 : 30) && 
+                (defensiveStance == true || (stancetimer <= diff && !SS)))
+            {
+                if (!master->isInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 25 && mydist > 18 && (defensiveStance == true || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, INTERVENE))
+                        {
+                            //modrage(-10);
+                            intervene_cd = INTERVENE_CD;
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                //sLog->outBasic("%s: Intervene check.", me->GetName());
+                Group *gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() && 
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance == true || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, INTERVENE))
+                        {
+                            //modrage(-10);
+                            intervene_cd = INTERVENE_CD;
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference *itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player *tPlayer = itr->getSource();
+                        if (!tPlayer) continue;
+                        if (tPlayer->GetMap() != me->GetMap()) continue;
+                        //sLog->outBasic("checking player %s", tPlayer->GetName());
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || tank == tPlayer) continue;
+                        //sLog->outBasic("alive and health < 80%");
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        //sLog->outBasic("attackers checked");
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 25 || dist < 10) continue;
+                        //sLog->outBasic("and whithin reach");
+                        if ((defensiveStance == true || stanceChange(diff, 2)))
+                        {
+                            //sLog->outBasic("defensive stance acuired, attempt cast");
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, INTERVENE))
+                            {
+                                //sLog->outBasic("cast succeed");
+                                //modrage(-10);
+                                intervene_cd = INTERVENE_CD;
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference *itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player *tPlayer = itr->getSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (tPlayer->GetMap() != me->GetMap()) continue;
+                        for (uint8 i = 0; i != tPlayer->GetMaxNpcBots(); ++i)
+                        {
+                            Creature *bot = tPlayer->GetBotMap()[i]._Cre();
+                            if (!bot || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || tank == bot) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if ((defensiveStance == true || stanceChange(diff, 2)))
+                            {
+                                //sLog->outBasic("defensive stance acuired, attempt cast");
+                                temptimer = GC_Timer;
+                                if (doCast(bot, INTERVENE))
+                                {
+                                    //sLog->outBasic("cast succeed");
+                                    //modrage(-10);
+                                    intervene_cd = INTERVENE_CD/2; //half for bot
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            switch (spell->Id)
+            {
+            case OVERPOWER_1:
+                if (target->GetTypeId() != TYPEID_UNIT || //only creatures lol
+                    !UNRELENTING_ASSAULT)
+                    return;
+                if (target->HasUnitState(UNIT_STATE_CASTING))
+                {
+                    uint32 spell = 0;
+                    if (me->HasAura(UNRELENTING_ASSAULT2))
+                        spell = UNRELENTING_ASSAULT_SPELL2;
+                    else if (me->HasAura(UNRELENTING_ASSAULT1))
+                        spell = UNRELENTING_ASSAULT_SPELL1;
+                    if (!spell)
+                        return;
+                    target->CastSpell(target, spell, true);
+                }
+                break;
+            default:
+                break;
+            }
+        }
+
+        bool stanceChange(const uint32 diff, uint8 stance)
+        {
+            if (!(stancetimer <= diff) || !stance) return false;
+
+            if (stance == 5)
+            {
+                switch (urand(0,1))
+                {
+                case 0: stance = 1; break;
+                case 1: if (me->getLevel() < 30) stance = 1; else stance = 3; break;
+                }
+            }
+            if (stance == 2 && (me->getLevel() < 10 || SS)) return false;
+            if (stance == 3 && me->getLevel() < 30) return false;
+
+            temptimer = GC_Timer;
+            uint32 temprage = 0;
+            uint32 myrage = me->GetPower(POWER_RAGE);
+            if (me->getLevel() >= 15)
+                temprage = myrage > 250 ? 250 : myrage;
+            else if (me->getLevel() >= 10)
+                temprage = myrage > 100 ? 100 : myrage;
+            switch(stance)
+            {
+            case 1:
+                if (doCast(me, BATTLESTANCE))
+                {
+                    if (me->HasAura(BATTLESTANCE)) 
+                    {
+                        battleStance = true;
+                        defensiveStance = false;
+                        berserkerStance = false;
+                        me->SetPower(POWER_RAGE, temprage);
+                        stancetimer = 2100 - me->getLevel()*20;//2100-1600 on 80
+                        GC_Timer = temptimer;
+                        return true;
+                    }
+                }
+                break;
+            case 2:
+                if (doCast(me, DEFENSIVESTANCE))
+                {
+                    if (me->HasAura(DEFENSIVESTANCE))
+                    {
+                        defensiveStance = true;
+                        battleStance = false;
+                        berserkerStance = false;
+                        me->SetPower(POWER_RAGE, temprage);
+                        stancetimer = 2100 - me->getLevel()*20;//2100-1600 on 80
+                        GC_Timer = temptimer;
+                        return true;
+                    }
+                }
+                break;
+            case 3:
+                if (doCast(me, BERSERKERSTANCE))
+                {
+                    if (me->HasAura(BERSERKERSTANCE))
+                    {
+                        berserkerStance = true;
+                        battleStance = false;
+                        defensiveStance = false;
+                        me->SetPower(POWER_RAGE, temprage);
+                        stancetimer = 2100 - me->getLevel()*20;//2100-1600 on 80
+                        GC_Timer = temptimer;
+                        return true;
+                    }
+                }
+                break;
+            default:
+                break;
+            }
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void Reset()
+        {
+            slam_cd = 0;
+            regen_cd = 20000;
+            sweeping_strikes_cd = 0;
+            charge_cd = 0;
+            deathwish_cd = 0;
+            mortalStrike_cd = 0;
+            overpower_cd = 0;
+            uber_cd = 0;
+            berserkerRage_cd = 0;
+            battleShout_cd = 0;
+            intercept_cd = 0;
+            intimidatingShout_cd = 0;
+            pummel_cd = 0;
+            whirlwind_cd = 5000;
+            cleave_cd = 0;
+            bladestorm_cd = 10000;
+            bloodrage_cd = 0;
+            intervene_cd = 0;
+            pvpTrinket_cd = 0;
+            taunt_cd = 0;
+            sunder_cd = 0;
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            if (master)
+            {
+                setStats(CLASS_WARRIOR, me->getRace(), master->getLevel(), true);
+                ApplyClassPassives();
+                ApplyPassives(CLASS_WARRIOR);
+                //mob generates abnormal amounts rage so increase/reduce rate with level(from 188% down to 30% at level 80)//not seems to work
+                for (int8 i = 0; i < 3; ++i)
+                    me->ApplyEffectModifiers(sSpellMgr->GetSpellInfo(29623), i, float(90 - master->getLevel()*2));
+            }
+        }
+
+        void ReduceCD(const uint32 diff)
+        {
+            CommonTimers(diff);
+            if (pvpTrinket_cd > diff)               pvpTrinket_cd -= diff;
+            if (regen_cd > diff)                    regen_cd -= diff;
+            if (slam_cd > diff)                     slam_cd -= diff;
+            if (battleShout_cd > diff)              battleShout_cd -= diff;
+            if (sweeping_strikes_cd > diff)         sweeping_strikes_cd -= diff;
+            if (deathwish_cd > diff)                deathwish_cd -= diff;
+            if (mortalStrike_cd > diff)             mortalStrike_cd -= diff;
+            if (overpower_cd > diff)                overpower_cd -= diff;
+            if (uber_cd > diff)                     uber_cd -= diff;
+            if (berserkerRage_cd > diff)            berserkerRage_cd -= diff;
+            if (charge_cd > diff)                   charge_cd -= diff;
+            if (intercept_cd > diff)                intercept_cd -= diff;
+            if (intimidatingShout_cd > diff)        intimidatingShout_cd -= diff;
+            if (pummel_cd > diff)                   pummel_cd -= diff;
+            if (whirlwind_cd > diff)                whirlwind_cd -= diff;
+            if (bladestorm_cd > diff)               bladestorm_cd -= diff;
+            if (cleave_cd > diff)                   cleave_cd -= diff;
+            if (bloodrage_cd > diff)                bloodrage_cd -= diff;
+            if (intervene_cd > diff)                intervene_cd -= diff;
+            if (taunt_cd > diff)                    taunt_cd -= diff;
+            if (sunder_cd > diff)                   sunder_cd -= diff;
+
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        bool CanRespawn()
+        {return false;}
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //CHALLENGING_SHOUT                       = InitSpell(CHALLENGING_SHOUT_1);
+            INTIMIDATING_SHOUT                      = InitSpell(INTIMIDATING_SHOUT_1);
+            ENRAGED_REGENERATION                    = InitSpell(ENRAGED_REGENERATION_1);
+            CHARGE                                  = InitSpell(CHARGE_1);
+            OVERPOWER                               = InitSpell(OVERPOWER_1);
+   /*Quest*/TAUNT                       = lvl >= 10 ? TAUNT_1 : 0;
+            //DISARM                                  = InitSpell(DISARM_1);
+            BLOODRAGE                               = InitSpell(BLOODRAGE_1);
+            BERSERKERRAGE                           = InitSpell(BERSERKERRAGE_1);
+            INTERCEPT                               = InitSpell(INTERCEPT_1);
+            CLEAVE                                  = InitSpell(CLEAVE_1);
+            HAMSTRING                               = InitSpell(HAMSTRING_1);
+            INTERVENE                               = InitSpell(INTERVENE_1);
+            WHIRLWIND                               = InitSpell(WHIRLWIND_1);
+  /*Talent*/BLADESTORM                  = lvl >= 60 ? BLADESTORM_1 : 0;
+            BATTLESHOUT                             = InitSpell(BATTLESHOUT_1);
+            REND                                    = InitSpell(REND_1);
+            EXECUTE                                 = InitSpell(EXECUTE_1);
+            PUMMEL                                  = InitSpell(PUMMEL_1);
+  /*Talent*/MORTALSTRIKE                = lvl >= 40 ? InitSpell(MORTALSTRIKE_1) : 0;
+            SLAM                                    = InitSpell(SLAM_1);
+   /*Quest*/SUNDER                      = lvl >= 10 ? InitSpell(SUNDER_1) : 0;
+  /*Talent*/SWEEPING_STRIKES            = lvl >= 30 ? SWEEPING_STRIKES_1 : 0;
+            BATTLESTANCE                            = BATTLESTANCE_1;
+   /*Quest*/DEFENSIVESTANCE             = lvl >= 10 ? DEFENSIVESTANCE_1 : 0;
+   /*Quest*/BERSERKERSTANCE             = lvl >= 30 ? BERSERKERSTANCE_1 : 0;
+            RECKLESSNESS                            = InitSpell(RECKLESSNESS_1);
+            RETALIATION                             = InitSpell(RETALIATION_1);
+  /*Talent*/DEATHWISH                   = lvl >= 30 ? DEATHWISH_1 : 0;
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+            if (level >= 70)
+                RefreshAura(WC5); //10%
+            else if (level >= 68)
+                RefreshAura(WC4); //8%
+            else if (level >= 66)
+                RefreshAura(WC3); //6%
+            else if (level >= 64)
+                RefreshAura(WC2); //4%
+            else if (level >= 62)
+                RefreshAura(WC1); //2%
+            if (level >= 39)
+                RefreshAura(FLURRY5); //30%
+            else if (level >= 38)
+                RefreshAura(FLURRY4); //24%
+            else if (level >= 37)
+                RefreshAura(FLURRY3); //18%
+            else if (level >= 36)
+                RefreshAura(FLURRY2); //12%
+            else if (level >= 35)
+                RefreshAura(FLURRY1); //6%
+            if (level >= 60)
+                RefreshAura(SWORD_SPEC5,2);//twice
+            else if (level >= 50)
+                RefreshAura(SWORD_SPEC5);//once
+            else if (level >= 45)
+                RefreshAura(SWORD_SPEC4);//once
+            else if (level >= 40)
+                RefreshAura(SWORD_SPEC3);//once
+            else if (level >= 35)
+                RefreshAura(SWORD_SPEC2);//once
+            else if (level >= 30)
+                RefreshAura(SWORD_SPEC1);//once
+            if (level >= 60)
+                RefreshAura(RAMPAGE);
+            if (level >= 55)
+                RefreshAura(TRAUMA2);//30%
+            else if (level >= 35)
+                RefreshAura(TRAUMA1);//15%
+            if (level >= 50)
+            {
+                RefreshAura(UNRELENTING_ASSAULT2);
+                UNRELENTING_ASSAULT = true;
+            }
+            else if (level >= 45)
+            {
+                RefreshAura(UNRELENTING_ASSAULT1);
+                UNRELENTING_ASSAULT = true;
+            }
+            if (level >= 45)
+                RefreshAura(BLOOD_FRENZY);
+            if (level >= 40)
+                RefreshAura(SECOND_WIND);
+            if (level >= 40)
+                RefreshAura(TOUGHNESS,2);//-60%
+            else if (level >= 15)
+                RefreshAura(TOUGHNESS);//-30%
+            if (level >= 40)
+                RefreshAura(IMP_HAMSTRING,2);//30%
+            else if (level >= 35)
+                RefreshAura(IMP_HAMSTRING);//15%
+            if (level >= 30)
+                RefreshAura(TASTE_FOR_BLOOD3);//100%
+            else if (level >= 28)
+                RefreshAura(TASTE_FOR_BLOOD2);//66%
+            else if (level >= 25)
+                RefreshAura(TASTE_FOR_BLOOD1);//33%
+            if (level >= 30)
+                RefreshAura(BLOOD_CRAZE3);
+            else if (level >= 25)
+                RefreshAura(BLOOD_CRAZE2);
+            else if (level >= 20)
+                RefreshAura(BLOOD_CRAZE1);
+            //BloodRage Absorb
+            if (level >= 60)
+                RefreshAura(WARRIOR_T10_4P);
+        }
+
+    private:
+        uint32
+  /*Shouts*/INTIMIDATING_SHOUT, BATTLESHOUT, CHALLENGING_SHOUT, 
+ /*Charges*/CHARGE, INTERCEPT, INTERVENE, 
+  /*Damage*/OVERPOWER, CLEAVE, REND, EXECUTE, WHIRLWIND, BLADESTORM, MORTALSTRIKE, SLAM, 
+ /*Stances*/BATTLESTANCE, DEFENSIVESTANCE, BERSERKERSTANCE, 
+   /*Ubers*/RECKLESSNESS, RETALIATION, DEATHWISH, 
+  /*Others*/TAUNT, DISARM, BLOODRAGE, ENRAGED_REGENERATION, BERSERKERRAGE, HAMSTRING, PUMMEL, SUNDER, SWEEPING_STRIKES;
+
+        //CDs/Timers/misc
+/*shts*/uint32 battleShout_cd, intimidatingShout_cd;
+/*chrg*/uint32 charge_cd, intercept_cd, intervene_cd;;
+ /*Dmg*/uint32 mortalStrike_cd, overpower_cd, slam_cd, whirlwind_cd, cleave_cd, bladestorm_cd;
+/*else*/uint32 regen_cd, sweeping_strikes_cd, deathwish_cd, uber_cd, berserkerRage_cd, pummel_cd, 
+            bloodrage_cd, taunt_cd, pvpTrinket_cd, sunder_cd;
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2;
+/*misc*/uint32 rage; float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, SS, UNRELENTING_ASSAULT;
+
+        enum WarriorBaseSpells
+        {
+            //CHALLENGING_SHOUT_1                     = 1161,
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            //DISARM_1                                = 676,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,//59992,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,//67541,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+            MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,//16145,
+            SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,//7165, //2457, original warrior one
+            DEFENSIVESTANCE_1                       = 71,//71, original warrior one
+            BERSERKERSTANCE_1                       = 2458,//7366, //2458, original warrior spell
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 22857,//20230, original warrior spell
+            DEATHWISH_1                             = 12292,
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844,
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            UNRELENTING_ASSAULT_SPELL1              = 64849,
+            UNRELENTING_ASSAULT_SPELL2              = 64850,
+            PVPTRINKET                              = 42292,
+        };
+        enum WarriorCooldowns
+        {
+            ENRAGED_REGENERATION_CD = 90000, //1.5 min
+            SWEEPING_STRIKES_CD     = 30000,
+            CHARGE_CD               = 15000,
+            DEATHWISH_CD            = 90000, //1.5 min
+            MORTALSTRIKE_CD         = 7000,
+            UBER_CD                 = 150000, //RETALIATION_RECKLESSNESS_SHIELDWALL 2.5 min NEED SEPARATE
+            BERSERKERRAGE_CD        = 25000,
+            INTERCEPT_CD            = 15000,
+            INTIMIDATINGSHOUT_CD    = 45000,
+            PUMMEL_CD               = 10000,
+            WHIRLWIND_CD            = 8000,
+            BLADESTORM_CD           = 60000,
+            BLOODRAGE_CD            = 40000,
+            //DISARM_CD               = 40000,
+            INTERVENE_CD            = 25000,
+            BATTLESHOUT_CD          = 25000,
+            //SPELLREFLECTION_CD      = 8000,
+            PVPTRINKET_CD           = 45000,
+            TAUNT_CD                = 8000,
+            SUNDER_CD               = 7000,
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..32b7922
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,788 @@
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Playerbot and Npcbot related commands
+Category: commandscripts
+*/
+
+#include "ScriptMgr.h"
+#include "Chat.h"
+#include "ObjectMgr.h"
+#include "bot_ai.h"
+#include "PlayerbotAI.h"
+
+class script_bot_commands : public CommandScript
+{
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand npcbotCommandTable[] =
+        {
+            { "info",           SEC_PLAYER,         false, &HandleNpcBotInfoCommand,                    "", NULL },
+            { "add",            SEC_PLAYER,         false, &HandleNpcBotAddCommand,                     "", NULL },
+            { "revive",         SEC_MODERATOR,      false, &HandleNpcBotReviveCommand,                  "", NULL },
+            { "remove",         SEC_PLAYER,         false, &HandleNpcBotRemoveCommand,                  "", NULL },
+            { "reset",          SEC_PLAYER,         false, &HandleNpcBotResetCommand,                   "", NULL },
+            { "command",        SEC_PLAYER,         false, &HandleNpcBotCommandCommand,                 "", NULL },
+            { "distance",       SEC_PLAYER,         false, &HandleNpcBotDistanceCommand,                "", NULL },
+            { NULL,             0,                  false, NULL,                                        "", NULL }
+        };
+        static ChatCommand commandTable[] =
+        {
+            { "bot",            SEC_PLAYER,         false, &HandlePlayerbotCommand,                     "", NULL },
+            { "maintank",       SEC_PLAYER,         false, &HandleMainTankCommand,                      "", NULL },
+            { "mt",             SEC_PLAYER,         false, &HandleMainTankCommand,                      "", NULL },
+            { "npcbot",         SEC_PLAYER,         false, NULL,                          "", npcbotCommandTable },
+            { NULL,             0,                  false, NULL,                                        "", NULL }
+        };
+        return commandTable;
+    }
+
+    static bool HandlePlayerbotCommand(ChatHandler* handler, const char *args)
+    {
+        if (!handler->GetSession())
+        {
+            handler->PSendSysMessage("You may only add bots from an active session");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!*args)
+        {
+            handler->PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player *player = handler->GetSession()->GetPlayer();
+
+        char *cmd = strtok ((char*)args, " ");
+        if (!cmd)
+        {
+            handler->PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        std::string cmdStr = cmd;
+        
+        if (cmdStr.compare("tele") == 0 || cmdStr.compare("teleport") == 0 || cmdStr.compare("summ") == 0 || cmdStr.compare("summon") == 0)
+        {
+            if (handler->GetSession()->m_playerBots.empty())
+            {
+                handler->PSendSysMessage("You Have No Playerbots!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            for(PlayerBotMap::const_iterator itr = handler->GetSession()->GetPlayerBotsBegin(); itr != handler->GetSession()->GetPlayerBotsEnd(); ++itr)
+            {
+                Player *botPlayer = itr->second;
+                if (!botPlayer)
+                    continue;
+                botPlayer->TeleportTo(*player);
+            }
+            return true;
+        }
+        char *charname = strtok (NULL, " ");
+        if (!charname)
+        {
+            handler->PSendSysMessage("usage: add PLAYERNAME  or  remove PLAYERNAME");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        std::string charnameStr = charname;
+
+        uint64 guid;
+
+       if (charnameStr.compare("all") != 0)
+       {
+           if (!normalizePlayerName(charnameStr))
+               return false;
+
+           guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+           if (guid == 0 || (guid == handler->GetSession()->GetPlayer()->GetGUID()))
+           {
+               handler->PSendSysMessage(LANG_PLAYER_NOT_FOUND);
+               handler->SetSentErrorMessage(true);
+               return false;
+           }
+
+           uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+           if (accountId != handler->GetSession()->GetAccountId())
+           {
+               handler->PSendSysMessage("You may only add bots from the same account.");
+               handler->SetSentErrorMessage(true);
+               return false;
+           }
+       }
+
+        if (cmdStr.compare("add") == 0 || cmdStr.compare("login") == 0)
+        {
+            if (charnameStr.compare("all") == 0)
+            {
+                std::list<std::string> *names;
+                names = handler->GetSession()->GetPlayer()->GetCharacterList();
+                std::list<std::string>::iterator iter,next;
+                for (iter = names->begin(); iter != names->end(); iter++)
+                {
+                    std::stringstream arg;
+                    arg << "add " << (*iter).c_str();
+                    HandlePlayerbotCommand(handler, arg.str().c_str());
+                }
+                handler->PSendSysMessage("Bots added successfully.");
+                return true;
+            }
+            else
+            {
+                guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+                if (player->GetSession()->GetPlayerBot(guid) != NULL)
+                {
+                    handler->PSendSysMessage("Bot already exists in world.");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                player->GetSession()->AddPlayerBot(guid);
+            }
+        }
+        else if (cmdStr.compare("remove") == 0 || cmdStr.compare("logout") == 0)
+        {
+            if (charnameStr.compare("all") == 0)
+            {
+                std::list<std::string> *names = new std::list<std::string>;
+                for (PlayerBotMap::const_iterator iter = handler->GetSession()->GetPlayerBotsBegin(); iter != handler->GetSession()->GetPlayerBotsEnd(); ++iter)
+                {
+                    names->push_back(iter->second->GetName());
+                }
+                std::list<std::string>::iterator iter, next;
+                for (iter = names->begin(); iter != names->end(); iter++)
+                {
+                    std::stringstream arg;
+                    arg << "remove " << (*iter).c_str();
+                    HandlePlayerbotCommand(handler, arg.str().c_str());
+                }
+                return true;
+            }
+            else
+            {
+                guid = sObjectMgr->GetPlayerGUIDByName(charnameStr.c_str());
+                if (!handler->GetSession()->GetPlayerBot(guid))
+                {
+                    handler->PSendSysMessage("Bot can not be removed because bot does not exist in world.");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                handler->GetSession()->LogoutPlayerBot(guid);
+                handler->PSendSysMessage("Bot removed successfully.");
+                return true;
+            }
+        }
+        else if (cmdStr == "co" || cmdStr == "combatorder")
+        {
+            Unit *target = NULL;
+            char *orderChar = strtok(NULL, " ");
+            if (!orderChar || handler->GetSession()->m_playerBots.empty())
+            {
+                handler->PSendSysMessage("|cffff0000Syntax error:|cffffffff .bot co <botName> <order=reset|tank|assist|heal|protect> [targetPlayer]");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            std::string orderStr = orderChar;
+            if (orderStr == "protect" || orderStr == "assist")
+            {
+                char *targetChar = strtok(NULL, " ");
+                uint64 targetGUID = handler->GetSession()->GetPlayer()->GetSelection();
+                if (!targetChar && !targetGUID)
+                {
+                    handler->PSendSysMessage("|cffff0000Combat orders protect and assist expect a target either by selection or by giving target player in command string!");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                if (targetChar)
+                {
+                    std::string targetStr = targetChar;
+                    targetGUID = sObjectMgr->GetPlayerGUIDByName(targetStr.c_str());
+                }
+                target = sObjectAccessor->GetUnit(*handler->GetSession()->GetPlayer(), targetGUID);
+                if (!target)
+                {
+                    handler->PSendSysMessage("|cffff0000Invalid target for combat order protect or assist!");
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+            }
+            //if (handler->GetSession()->GetPlayerBot(guid) == NULL)
+            //{
+            //    handler->PSendSysMessage("|cffff0000Bot can not receive combat order because bot does not exist in world.");
+            //    handler->SetSentErrorMessage(true);
+            //    return false;
+            //}
+            //if (mgr)
+            PlayerBotMap::const_iterator itr;
+            for (itr = handler->GetSession()->GetPlayerBotsBegin(); itr != handler->GetSession()->GetPlayerBotsEnd(); ++itr)
+                if (Player *bot = sObjectAccessor->GetPlayer(*player, itr->first))
+                    bot->GetPlayerbotAI()->SetCombatOrderByStr(orderStr, target);
+        }
+        return true;
+    }
+
+    static bool HandleMainTankCommand(ChatHandler* handler, const char *args)
+    {
+        Group *group = handler->GetSession()->GetPlayer()->GetGroup();
+        if (!group)
+        {
+            handler->PSendSysMessage("Must be in a group to use main tank command.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        uint64 myguid = handler->GetSession()->GetPlayer()->GetGUID();
+        if (!group->IsLeader(myguid) && !group->IsAssistant(myguid))
+        {
+            handler->PSendSysMessage("you have no permission to set main tank.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!*args)
+        {
+            if (uint64 selection = handler->GetSession()->GetPlayer()->GetSelection())
+            {
+                if (group->IsMember(selection))
+                {
+                    if (Unit *u = sObjectAccessor->FindUnit(selection))
+                    {
+                        bool isabot = u->GetTypeId() == TYPEID_UNIT && u->ToCreature()->GetIAmABot();
+                        if (isabot && group->GetMemberSlots().size() < 3 && handler->GetSession()->GetSecurity() == SEC_PLAYER)
+                        {
+                            handler->PSendSysMessage("Your party is too small to set a npcbot main tank.");
+                            handler->SetSentErrorMessage(true);
+                            return false;
+                        }
+                        group->RemoveUniqueGroupMemberFlag(MEMBER_FLAG_MAINTANK);
+                        Group::MemberSlotList const &members = group->GetMemberSlots();
+                        for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                        {
+                            uint8 flags = itr->flags;
+                            if (group->isRaidGroup())
+                            {
+                                //try to set flags in group (will fail if not raid)
+                                group->SetGroupMemberFlag(itr->guid, itr->guid == selection, MEMBER_FLAG_MAINTANK);
+                            }
+                            else //force flags for non-raid group (DB only) this will allow bots to find tank
+                            {
+                                if (itr->guid == selection && !(flags & MEMBER_FLAG_MAINTANK))
+                                    flags |= MEMBER_FLAG_MAINTANK;
+                            }
+                            //store result if DB
+                            if (itr->guid != selection || !group->isRaidGroup())
+                            {
+                                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
+                                stmt->setUInt8(0, flags);
+                                stmt->setUInt32(1, GUID_LOPART(itr->guid));
+                                CharacterDatabase.Execute(stmt);
+                            }
+                            //send result to players and their bots
+                            if (!IS_PLAYER_GUID(itr->guid))
+                                continue;
+                            if (Player *player = sObjectAccessor->FindPlayer(itr->guid))
+                            {
+                                ChatHandler(player).PSendSysMessage("Main tank is set to %s.", u->GetName());
+                                player->SetBotTank(selection);
+                                if (player->HaveBot())
+                                {
+                                    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                                    {
+                                        Creature *cre = player->GetBotMap()[i]._Cre();
+                                        if (cre)
+                                            cre->SetBotTank(u);
+                                    }
+                                }
+                            }
+                        }
+                        u->HandleEmoteCommand(EMOTE_ONESHOT_CHEER);
+                        handler->SetSentErrorMessage(true);
+                        return true;
+                    }
+                }
+            }
+            if (Unit *unit = bot_ai::GetBotGroupMainTank(group))
+            {
+                bool bot = unit->GetTypeId() == TYPEID_UNIT && unit->ToCreature()->GetIAmABot();
+                handler->PSendSysMessage("Main tank is %s (%s%s).", unit->GetName(), (bot ? "npcbot" : "player"), (unit->isAlive() ? "" : ", dead"));
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage(".maintank");
+            handler->PSendSysMessage("Allows to set a main tank in bot party (can be used on npcbots). Determines npcbots' actions");
+            handler->PSendSysMessage("Npcbot maintank also receives damage reduction, avoidance and threat generation bonus");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        else
+        {
+            //clear tank in whole bot party
+            std::string cmdStr = strtok((char*)args, " ");
+            if (!cmdStr.compare("clear") || !cmdStr.compare("cl") || !cmdStr.compare("cle") ||
+                !cmdStr.compare("reset") || !cmdStr.compare("res"))
+            {
+                Group::MemberSlotList const &members = group->GetMemberSlots();
+                for (Group::MemberSlotList::const_iterator itr = members.begin(); itr != members.end(); ++itr)
+                {
+                    uint8 flags = itr->flags;
+                    if (group->isRaidGroup())
+                    {
+                        if (flags & MEMBER_FLAG_MAINTANK)
+                            group->SetGroupMemberFlag(itr->guid, false, MEMBER_FLAG_MAINTANK);
+                    }
+                    else
+                    {
+                        if (itr->flags & MEMBER_FLAG_MAINTANK)
+                            flags &= ~MEMBER_FLAG_MAINTANK;
+                    }
+                    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GROUP_MEMBER_FLAG);
+                    stmt->setUInt8(0, flags);
+                    stmt->setUInt32(1, GUID_LOPART(itr->guid));
+                    CharacterDatabase.Execute(stmt);
+                    if (!IS_PLAYER_GUID(itr->guid))
+                        continue;
+                    Player *player = sObjectAccessor->FindPlayer(itr->guid);
+                    if (!player) continue;
+                    ChatHandler(player).PSendSysMessage("Main tank has been reset by %s.", handler->GetSession()->GetPlayer()->GetName());
+                    player->SetBotTank(0);
+                    if (player->HaveBot())
+                    {
+                        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                        {
+                            Creature *cre = player->GetBotMap()[i]._Cre();
+                            if (cre)
+                                cre->SetBotTank(NULL);
+                        }
+                    }
+                }
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetSelection())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your Playerbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (master && master != owner && master->GetSession()->m_master != owner))
+        {
+            handler->PSendSysMessage("You should select one of your PlayerBots or self.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        //create list
+        std::set<Player*> Players;
+        Players.insert(master);
+        if (!master->GetSession()->m_playerBots.empty())
+            for (PlayerBotMap::const_iterator itr = master->GetSession()->GetPlayerBotsBegin(); itr != master->GetSession()->GetPlayerBotsEnd(); ++itr)
+                Players.insert(itr->second);
+        //cycle through
+        for (std::set<Player*>::const_iterator it = Players.begin(); it != Players.end(); ++it)
+        {
+            Player *pl = *it;
+            if (!pl->HaveBot())
+            {
+                handler->PSendSysMessage("%s has no NpcBots!", pl->GetName());
+                continue;
+            }
+            const std::string plType = pl == owner ? ", player" : ", playerbot";
+            handler->PSendSysMessage("Listing NpcBots for %s%s", pl->GetName(), plType.c_str());
+            handler->PSendSysMessage("Owned NpcBots: %u", pl->GetNpcBotsCount());
+            for (uint8 i = CLASS_WARRIOR; i != MAX_CLASSES; ++i)
+            {
+                uint8 count = 0;
+                for (uint8 pos = 0; pos != pl->GetMaxNpcBots(); ++pos)
+                    if (Creature *cre = pl->GetBotMap()[pos]._Cre())
+                        if (cre->GetBotClass() == i)
+                            ++count;
+                char* bclass;
+                switch (i)
+                {
+                case CLASS_WARRIOR:         bclass = "Warriors";        break;
+                case CLASS_PALADIN:         bclass = "Paladins";        break;
+                case CLASS_MAGE:            bclass = "Mages";           break;
+                case CLASS_PRIEST:          bclass = "Priests";         break;
+                case CLASS_WARLOCK:         bclass = "Warlocks";        break;
+                case CLASS_DRUID:           bclass = "Druids";          break;
+                case CLASS_DEATH_KNIGHT:    bclass = "DeathKnights";    break;
+                case CLASS_ROGUE:           bclass = "Rogues";          break;
+                case CLASS_SHAMAN:          bclass = "Shamans";         break;
+                case CLASS_HUNTER:          bclass = "Hunters";         break;
+                default:                    bclass = "Unknown Class";   break;
+                }
+                if (count > 0)
+                    handler->PSendSysMessage("%s: %u", bclass, count);
+            }
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything");
+            handler->PSendSysMessage("min: 0, max: 50");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char *distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 50)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->isInCombat() && owner->HaveBot())
+            {
+                for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+                {
+                    Creature *cre = owner->GetBotMap()[i]._Cre();
+                    if (!cre || !cre->IsInWorld()) continue;
+                    owner->SendBotCommandState(cre, COMMAND_FOLLOW);
+                }
+            }
+            for (PlayerBotMap::const_iterator itr = handler->GetSession()->GetPlayerBotsBegin(); itr != handler->GetSession()->GetPlayerBotsEnd(); ++itr)
+            {
+                if (Player *bot = itr->second)
+                {
+                    bot->SetBotFollowDist(dist);
+                    if (!bot->isInCombat() && bot->HaveBot())
+                    {
+                        for (uint8 i = 0; i != bot->GetMaxNpcBots(); ++i)
+                        {
+                            Creature *cre = bot->GetBotMap()[i]._Cre();
+                            if (!cre || !cre->IsInWorld()) continue;
+                            bot->SendBotCommandState(cre, COMMAND_FOLLOW);
+                        }
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position. Can be used on Playerbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (master && master != owner && master->GetSession()->m_master != owner))
+            master = owner;
+        char *command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && master->HaveBot())
+        {
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                Creature *cre = master->GetBotMap()[i]._Cre();
+                if (!cre || !cre->IsInWorld()) continue;
+                master->SendBotCommandState(cre, CommandStates(state));
+            }
+            return true;
+        }
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        uint64 guid = owner->GetSelection();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Remove npcbots for selected Playerbot, you can also remove npcbots manually");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player *master = sObjectAccessor->GetPlayer(*owner, guid);
+        if (master)
+        {
+            if (master != owner && master->GetSession()->m_master != owner)
+            {
+                handler->PSendSysMessage("You can only remove bots from self and your own playerbots!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (master->HaveBot())
+            {
+                for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+                {
+                    master->RemoveBot(master->GetBotMap()[i]._Guid(), true);
+                }
+                if (!master->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Error!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Creature *cre = sObjectAccessor->GetCreature(*owner, guid);
+        if (cre && cre->GetIAmABot())
+        {
+            master = cre->GetBotOwner();
+            if (!master || (master && master != owner && master->GetSession()->m_master != owner))
+            {
+                handler->PSendSysMessage("You can only remove bots from self and your own playerbots");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            uint8 pos = master->GetNpcBotSlot(guid);
+            master->RemoveBot(cre->GetGUID(), true);
+            if (master->GetBotMap()[pos]._Cre() == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot is NOT removed for some reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        handler->PSendSysMessage("You should select Player or it's Npcbot!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        uint64 guid = owner->GetSelection();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot or npcbots for selected Playerbot, you can also reset your npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (IS_PLAYER_GUID(guid))
+        {
+            master = sObjectAccessor->FindPlayer(guid);
+            all = true;
+        }
+        if (IS_CREATURE_GUID(guid))
+        {
+            if (Creature *cre = sObjectAccessor->GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && (master == owner || master->GetSession()->m_master == owner))
+        {
+            if (master->isInCombat() && master->GetSession()->GetSecurity() == SEC_PLAYER)
+            {
+                handler->PSendSysMessage("Cannot reset bots in combat!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            for (uint8 i = 0; i != master->GetMaxNpcBots(); ++i)
+            {
+                if (all)
+                    master->RemoveBot(master->GetBotMap()[i]._Guid());
+                else if (master->GetBotMap()[i]._Guid() == guid)
+                {
+                    master->RemoveBot(guid);
+                    break;
+                }
+            }
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot or npcbot for selected Playerbot, you can also reset your npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    //For debug purposes only
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        if (handler->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            handler->PSendSysMessage("Revive command is disabled");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (owner->InBattleground())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in pvp matches");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->isInCombat())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in combat");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->isInFlight())
+        {
+            handler->PSendSysMessage("Bot revival is disabled in flight");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (owner->HaveBot())
+        {
+            for (uint8 i = 0; i != owner->GetMaxNpcBots(); ++i)
+            {
+                Creature *bot = owner->GetBotMap()[i]._Cre();
+                if (!bot) continue;
+                if (bot->isDead())
+                {
+                    owner->SetBot(bot);
+                    owner->CreateBot(0, 0, 0, false, true);
+                }
+            }
+            handler->PSendSysMessage("NpcBots revived");
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot revive");
+        handler->PSendSysMessage("Revive your npcbots if you are all hopelessly dead");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || !*args)
+        {
+            handler->PSendSysMessage(".npcbot add");
+            handler->PSendSysMessage("Allows to create npcbot of given class for targeted Playerbot, can be also used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (master != owner && master->GetSession()->m_master != owner)
+            master = owner;
+        if (master->InBattleground())
+        {
+            handler->PSendSysMessage("Bot creation is disabled in pvp matches");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (master->isDead())
+        {
+            if (master == owner)
+                owner->GetSession()->SendNotification("You're dead!");
+            else
+                owner->GetSession()->SendNotification("%s is dead!", master->GetName());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (master->GetGroup() && master->GetGroup()->isRaidGroup() && master->GetGroup()->IsFull())
+        {
+            handler->PSendSysMessage("Group is full, aborted");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (master->GetNpcBotsCount() >= master->GetMaxNpcBots())
+        {
+            handler->PSendSysMessage("Npcbots limit exceed");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char *bclass = strtok((char*)args, " ");
+        uint8 botclass = CLASS_NONE;
+
+        if (!strncmp(bclass, "deathknight", 12) || !strncmp(bclass, "dk", 3) || !strncmp(bclass, "de", 3))
+            botclass = CLASS_DEATH_KNIGHT;
+        else if (!strncmp(bclass, "druid", 6) || !strncmp(bclass, "dru", 4) || !strncmp(bclass, "dr", 3))
+            botclass = CLASS_DRUID;
+        else if (!strncmp(bclass, "hunter", 7) || !strncmp(bclass, "hunt", 5) || !strncmp(bclass, "hu", 3))
+            botclass = CLASS_HUNTER;
+        else if (!strncmp(bclass, "mage", 5) || !strncmp(bclass, "ma", 3))
+            botclass = CLASS_MAGE;
+        else if (!strncmp(bclass, "paladin", 8) || !strncmp(bclass, "pal", 4) || !strncmp(bclass, "pa", 3))
+            botclass = CLASS_PALADIN;
+        else if (!strncmp(bclass, "priest", 7) || !strncmp(bclass, "pri", 4) || !strncmp(bclass, "pr", 3))
+            botclass = CLASS_PRIEST;
+        else if (!strncmp(bclass, "rogue", 6) || !strncmp(bclass, "rog", 4) || !strncmp(bclass, "ro", 3))
+            botclass = CLASS_ROGUE;
+        else if (!strncmp(bclass, "shaman", 7) || !strncmp(bclass, "sha", 4) || !strncmp(bclass, "sh", 3))
+            botclass = CLASS_SHAMAN;
+        else if (!strncmp(bclass, "warlock", 8) || !strncmp(bclass, "warl", 5) || !strncmp(bclass, "lock", 5))
+            botclass = CLASS_WARLOCK;
+        else if (!strncmp(bclass, "warrior", 8) || !strncmp(bclass, "warr", 5))
+            botclass = CLASS_WARRIOR;
+
+        if (botclass == CLASS_NONE)
+        {
+            handler->PSendSysMessage("Wrong bot class");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint8 bots = master->GetNpcBotsCount();
+        master->CreateNPCBot(botclass);
+        master->RefreshBot(0);
+        if (master->GetNpcBotsCount() > bots)
+        {
+            if (master->isInCombat())
+                handler->PSendSysMessage("NpcBot successfully created (%s). Will appear out of combat", master->GetName());
+            else
+                handler->PSendSysMessage("NpcBot successfully created (%s).", master->GetName());
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botgiver.cpp b/src/server/game/AI/NpcBots/botgiver.cpp
new file mode 100644
index 0000000..1e5eabb
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botgiver.cpp
@@ -0,0 +1,286 @@
+#include "ScriptMgr.h"
+#include "ScriptedGossip.h"
+#include "ObjectMgr.h"
+#include "Config.h"
+#include "Group.h"
+
+//This function is called when the player opens the gossip menubool
+class script_bot_giver : public CreatureScript
+{
+public:
+    script_bot_giver() : CreatureScript("script_bot_giver") { }
+
+    bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 action)
+    {
+        switch (sender)
+        {
+            case 6006: SendCreateNPCBotMenu(player, creature, action); break;
+            case 6001: SendCreateNPCBot(player, creature, action); break;
+            case 6002: SendCreatePlayerBotMenu(player, creature, action); break;
+            case 6003: SendCreatePlayerBot(player, creature, action); break;
+
+            case 6004: SendRemovePlayerBotMenu(player, creature, action); break;
+            case 6005: SendRemovePlayerBot(player, creature, action); break;
+            case 6007: SendRemoveNPCBotMenu(player, creature, action); break;
+            case 6008: SendRemoveNPCBot(player, creature, action); break;
+
+            case 6009: SendBotHelpWhisper(player, creature, action); break;
+        }
+        return true;
+    }
+
+    bool OnGossipHello(Player *player, Creature *creature)
+    {
+        WorldSession *session = player->GetSession();
+        uint8 count = 0;
+        uint8 maxcount = ConfigMgr::GetIntDefault("Bot.MaxPlayerbots", 9);
+        bool allowPBots = ConfigMgr::GetBoolDefault("Bot.EnablePlayerBots", true);
+        bool allowNBots = ConfigMgr::GetBoolDefault("Bot.EnableNpcBots", true);
+
+        for (PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+        {
+            if (count == 0)
+                player->ADD_GOSSIP_ITEM(0, "Abandon my Player", 6004, GOSSIP_ACTION_INFO_DEF + 100);
+            ++count;
+        }
+        if (count < maxcount && allowPBots)
+            player->ADD_GOSSIP_ITEM(0, "Recruit a Player", 6002, GOSSIP_ACTION_INFO_DEF + 1);
+
+        maxcount = player->GetMaxNpcBots();
+        if (player->HaveBot())
+        {
+            count = 0;
+            for (uint8 i = 0; i != maxcount; ++i)
+                if (player->GetBotMap()[i]._Cre() != NULL)
+                    ++count;
+            if (count > 0)
+                player->ADD_GOSSIP_ITEM(0, "Abandon my Minion", 6007, GOSSIP_ACTION_INFO_DEF + 101);
+            if (count < maxcount && allowNBots)
+                player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+        }
+        else if (allowNBots)
+            player->ADD_GOSSIP_ITEM(0, "Recruit a Minion", 6006, GOSSIP_ACTION_INFO_DEF + 2);
+
+        player->ADD_GOSSIP_ITEM(0, "Tell me about these bots", 6009, GOSSIP_ACTION_INFO_DEF + 200);
+
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+        return true;
+    }
+
+    void SendCreatePlayerBot(Player *player, Creature *creature, uint32 action)
+    {
+        std::list<std::string> *names = player->GetCharacterList();
+        if (names == NULL || names->empty())
+        {
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+        for(std::list<std::string>::iterator iter = names->begin(); iter != names->end(); iter++)
+        {
+            if (x == 0)
+            {
+                uint64 guid = sObjectMgr->GetPlayerGUIDByName((*iter).c_str());
+                if (player->GetSession()->GetPlayerBot(guid) != NULL)
+                    return;
+                player->GetSession()->AddPlayerBot(guid);
+            }
+            else
+            {
+                if (x == 1)
+                {
+                    uint64 guid = sObjectMgr->GetPlayerGUIDByName((*iter).c_str());
+                    if (player->GetSession()->GetPlayerBot(guid) != NULL)
+                        return;
+                    player->GetSession()->AddPlayerBot(guid);
+                    break;
+                }
+                --x;
+            }
+        }
+        player->CLOSE_GOSSIP_MENU();
+    } //end SendCreatePlayerBot
+
+    void SendCreatePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+    {
+        std::list<std::string> *names = player->GetCharacterList();
+        if (names == NULL || names->empty())
+        {
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+
+        player->PlayerTalkClass->ClearMenus();
+        player->ADD_GOSSIP_ITEM(9, "ADD ALL" , 6003, GOSSIP_ACTION_INFO_DEF + 1);
+        int8 x = 2;
+
+        for (std::list<std::string>::iterator iter = names->begin(); iter != names->end(); iter++)
+        {
+            player->ADD_GOSSIP_ITEM(9, (*iter).c_str() , 6003, GOSSIP_ACTION_INFO_DEF + x);
+            ++x;
+        }
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    } //end SendCreatePlayerBotMenu
+
+    void SendRemovePlayerBotAll(Player *player, Creature *creature)
+    {
+        for (int8 x = 2; x<=10; x++ )
+        {
+            SendRemovePlayerBot(player, creature, GOSSIP_ACTION_INFO_DEF + 2);
+        }
+    }
+    void SendRemoveNPCBot(Player *player, Creature *creature, uint32 action)
+    {
+        int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+        WorldSession *session = player->GetSession();
+        if (x == 0)
+        {
+            player->CLOSE_GOSSIP_MENU();
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                player->RemoveBot(player->GetBotMap()[i]._Guid(), true);
+            return;
+        }
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+        {
+            if (x == 1 && player->GetBotMap()[i]._Cre())
+            {
+                player->RemoveBot(player->GetBotMap()[i]._Guid(), true);
+                break;
+            }
+            --x;
+        }
+        player->CLOSE_GOSSIP_MENU();
+    }
+
+    void SendRemovePlayerBot(Player *player, Creature *creature, uint32 action)
+    {
+        int8 x = action - GOSSIP_ACTION_INFO_DEF - 1;
+
+        if (x == 0)
+        {
+            SendRemovePlayerBotAll(player, creature);
+            return;
+        }
+
+        WorldSession *session = player->GetSession();
+        for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+        {
+            if (x == 1 && itr->second)
+            {
+                session->LogoutPlayerBot(itr->second->GetGUID());
+                break;
+            }
+            --x;
+        }
+        player->CLOSE_GOSSIP_MENU();
+    } //end SendRemovePlayerBot
+
+    void SendRemovePlayerBotMenu(Player *player, Creature *creature, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6005, GOSSIP_ACTION_INFO_DEF + 1);
+
+        uint8 x = 2;
+        WorldSession *session = player->GetSession();
+        for(PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+        {
+            Player *bot = itr->second;
+            player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6005, GOSSIP_ACTION_INFO_DEF + x);
+            ++x;
+        }
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    } //end SendRemovePlayerBotMenu
+
+    void SendRemoveNPCBotMenu(Player *player, Creature *creature, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        if (player->GetNpcBotsCount() == 1)
+        {
+            for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                player->RemoveBot(player->GetBotMap()[i]._Guid(), true);
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+        player->ADD_GOSSIP_ITEM(9, "REMOVE ALL", 6008, GOSSIP_ACTION_INFO_DEF + 1);
+
+        uint8 x = 2;
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+        {
+            Creature *bot = player->GetBotMap()[i]._Cre();
+            if (!bot) continue;
+            player->ADD_GOSSIP_ITEM(9, bot->GetName(), 6008, GOSSIP_ACTION_INFO_DEF + x);
+            ++x;
+        }
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    }
+
+    void SendCreateNPCBot(Player *player, Creature *creature, uint32 action)
+    {
+        uint8 bot_class = 0;
+        if (action == GOSSIP_ACTION_INFO_DEF + 1)//"Back"
+        {
+            player->CLOSE_GOSSIP_MENU();
+            return;
+        }
+        else if (action == GOSSIP_ACTION_INFO_DEF + 2)
+            bot_class = CLASS_WARRIOR;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 3)
+        //    bot_class = CLASS_HUNTER;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 4)
+            bot_class = CLASS_PALADIN;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 5)
+        //    bot_class = CLASS_SHAMAN;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 6)
+        //    bot_class = CLASS_ROGUE;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 7)
+            bot_class = CLASS_DRUID;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 8)
+            bot_class = CLASS_MAGE;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 9)
+            bot_class = CLASS_PRIEST;
+        else if (action == GOSSIP_ACTION_INFO_DEF + 10)
+            bot_class = CLASS_WARLOCK;
+        //else if (action == GOSSIP_ACTION_INFO_DEF + 11)
+        //    bot_class = CLASS_DEATH_KNIGHT;
+
+        if (bot_class > 0)
+            player->CreateNPCBot(bot_class);
+        player->CLOSE_GOSSIP_MENU();
+        return;
+    }
+
+    void SendCreateNPCBotMenu(Player *player, Creature *creature, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        player->ADD_GOSSIP_ITEM(9, "Recruit a Warrior", 6001, GOSSIP_ACTION_INFO_DEF + 2);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Hunter", 6001, GOSSIP_ACTION_INFO_DEF + 3);
+        player->ADD_GOSSIP_ITEM(9, "Recruit a Paladin", 6001, GOSSIP_ACTION_INFO_DEF + 4);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Shaman", 6001, GOSSIP_ACTION_INFO_DEF + 5);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Rogue", 6001, GOSSIP_ACTION_INFO_DEF + 6);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Druid", 6001, GOSSIP_ACTION_INFO_DEF + 7);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Mage", 6001, GOSSIP_ACTION_INFO_DEF + 8);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Priest", 6001, GOSSIP_ACTION_INFO_DEF + 9);
+        player->ADD_GOSSIP_ITEM(3, "Recruit a Warlock", 6001, GOSSIP_ACTION_INFO_DEF + 10);
+        //player->ADD_GOSSIP_ITEM(9, "Recruit a Death Knight", 1, GOSSIP_ACTION_INFO_DEF + 11);
+        player->PlayerTalkClass->SendGossipMenu(8446, creature->GetGUID());
+    }
+
+    static void SendBotHelpWhisper(Player *player, Creature *creature, uint32 action)
+    {
+        player->CLOSE_GOSSIP_MENU();
+        std::string msg1 = "To see list of Playerbot commands whisper 'help' to one of your playerbots",
+        msg2 = "To see list of available Npcbot commands type .npcbot or .npcb",
+        msg3 = "You can also use .maintank (or .mt or .main) command on any party member (even npcbot) so your bots will stick to your plan";
+        creature->MonsterWhisper(msg1.c_str(), player->GetGUID());
+        creature->MonsterWhisper(msg2.c_str(), player->GetGUID());
+        creature->MonsterWhisper(msg3.c_str(), player->GetGUID());
+    }
+};
+
+//This function is called when the player clicks an option on the gossip menu
+void AddSC_script_bot_giver()
+{
+    new script_bot_giver();
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
new file mode 100644
index 0000000..1478bfe
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.cpp
@@ -0,0 +1,11974 @@
+/*
+Name:       PlayerBot AI Core by Graff (onlysuffering@mail.ru)
+Converted:  from original blueboy's Playerbots: https://github.com/blueboy/portal/
+Revision:   bbbd930771eb48804f96651f5e15a098b2cecb43
+Merged with:
+xx-xx-xxxx LordPsyan's Playerbots: http://207.223.240.182/lordpsyan/trinitycore-patches/
+09-08-2012 blueBoy's Playerbots: e13fb1bd41111f99ad39aa54a0b28751efb4f2cd
+Notes:      Just converted, needs major cleanup and changes
+*/
+#include "PlayerbotAI.h"
+#include "Config.h"
+#include "GridNotifiersImpl.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "PlayerbotDeathKnightAI.h"
+#include "PlayerbotDruidAI.h"
+#include "PlayerbotHunterAI.h"
+#include "PlayerbotMageAI.h"
+#include "PlayerbotPaladinAI.h"
+#include "PlayerbotPriestAI.h"
+#include "PlayerbotRogueAI.h"
+#include "PlayerbotShamanAI.h"
+#include "PlayerbotWarlockAI.h"
+#include "PlayerbotWarriorAI.h"
+#include "Group.h"
+#include "GroupMgr.h"
+#include "Spell.h"
+#include "SpellAuraEffects.h"
+#include "GossipDef.h"
+#include "AuctionHouseMgr.h"
+#include <iomanip>
+#include "GameEventMgr.h"
+
+// ChatHandler already implements some useful commands the master can call on bots
+// These commands are protected inside the ChatHandler class so this class provides access to the commands
+// we'd like to call on our bots
+class PlayerbotChatHandler : protected ChatHandler
+{
+public:
+    PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer) {}
+    bool revive(Player& botPlayer) { botPlayer.ResurrectPlayer(1.0f); botPlayer.SpawnCorpseBones(); botPlayer.SaveToDB(); return true; }
+    bool teleport(const Player &botPlayer){ return HandleSummonCommand(this, botPlayer.GetName()); }
+    bool teleport(Player& botPlayer, WorldObject &obj) { botPlayer.Relocate(obj); return true; }
+    void sysmessage(const char *str) { SendSysMessage(str); }
+    bool dropQuest(char *str) { return HandleQuestRemove(this, str); }
+private:
+    static bool HandleSummonCommand(ChatHandler* handler, char const* args)
+    {
+        Player* target;
+        uint64 targetGuid;
+        std::string targetName;
+        if (!handler->extractPlayerTarget((char*)args, &target, &targetGuid, &targetName))
+            return false;
+
+        Player* _player = handler->GetSession()->GetPlayer();
+        if (target == _player || targetGuid == _player->GetGUID())
+        {
+            handler->PSendSysMessage(LANG_CANT_TELEPORT_SELF);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (target)
+        {
+            std::string nameLink = handler->playerLink(targetName);
+
+            if (target->IsBeingTeleported())
+            {
+                handler->PSendSysMessage(LANG_IS_TELEPORTED, nameLink.c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+
+            Map* map = handler->GetSession()->GetPlayer()->GetMap();
+
+            if (map->IsBattlegroundOrArena())
+            {
+                // only allow if gm mode is on
+                if (!_player->isGameMaster())
+                {
+                    handler->PSendSysMessage(LANG_CANNOT_GO_TO_BG_GM, nameLink.c_str());
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+                // if both players are in different bgs
+                else if (target->GetBattlegroundId() && handler->GetSession()->GetPlayer()->GetBattlegroundId() != target->GetBattlegroundId())
+                    target->LeaveBattleground(false); // Note: should be changed so target gets no Deserter debuff
+
+                // all's well, set bg id
+                // when porting out from the bg, it will be reset to 0
+                target->SetBattlegroundId(handler->GetSession()->GetPlayer()->GetBattlegroundId(), handler->GetSession()->GetPlayer()->GetBattlegroundTypeId());
+                // remember current position as entry point for return at bg end teleportation
+                if (!target->GetMap()->IsBattlegroundOrArena())
+                    target->SetBattlegroundEntryPoint();
+            }
+            else if (map->IsDungeon())
+            {
+                Map* map = target->GetMap();
+
+                if (map->Instanceable() && map->GetInstanceId() != map->GetInstanceId())
+                    target->UnbindInstance(map->GetInstanceId(), target->GetDungeonDifficulty(), true);
+
+                // we are in instance, and can summon only player in our group with us as lead
+                if (!handler->GetSession()->GetPlayer()->GetGroup() || !target->GetGroup() ||
+                    (target->GetGroup()->GetLeaderGUID() != handler->GetSession()->GetPlayer()->GetGUID()) ||
+                    (handler->GetSession()->GetPlayer()->GetGroup()->GetLeaderGUID() != handler->GetSession()->GetPlayer()->GetGUID()))
+                    // the last check is a bit excessive, but let it be, just in case
+                {
+                    handler->PSendSysMessage(LANG_CANNOT_SUMMON_TO_INST, nameLink.c_str());
+                    handler->SetSentErrorMessage(true);
+                    return false;
+                }
+            }
+
+            handler->PSendSysMessage(LANG_SUMMONING, nameLink.c_str(), "");
+            if (handler->needReportToTarget(target))
+                ChatHandler(target).PSendSysMessage(LANG_SUMMONED_BY, handler->playerLink(_player->GetName()).c_str());
+
+            // stop flight if need
+            if (target->isInFlight())
+            {
+                target->GetMotionMaster()->MovementExpired();
+                target->CleanupAfterTaxiFlight();
+            }
+            // save only in non-flight case
+            else
+                target->SaveRecallPosition();
+
+            // before GM
+            float x, y, z;
+            handler->GetSession()->GetPlayer()->GetClosePoint(x, y, z, target->GetObjectSize());
+            target->TeleportTo(handler->GetSession()->GetPlayer()->GetMapId(), x, y, z, target->GetOrientation());
+            target->SetPhaseMask(handler->GetSession()->GetPlayer()->GetPhaseMask(), true);
+        }
+        else
+        {
+            std::string nameLink = handler->playerLink(targetName);
+
+            handler->PSendSysMessage(LANG_SUMMONING, nameLink.c_str(), handler->GetTrinityString(LANG_OFFLINE));
+
+            // in point where GM stay
+            Player::SavePositionInDB(handler->GetSession()->GetPlayer()->GetMapId(),
+                handler->GetSession()->GetPlayer()->GetPositionX(),
+                handler->GetSession()->GetPlayer()->GetPositionY(),
+                handler->GetSession()->GetPlayer()->GetPositionZ(),
+                handler->GetSession()->GetPlayer()->GetOrientation(),
+                handler->GetSession()->GetPlayer()->GetZoneId(),
+                targetGuid);
+        }
+
+        return true;
+    }
+
+    static bool HandleQuestRemove(ChatHandler* handler, const char* args)
+    {
+        Player* player = handler->getSelectedPlayer();
+        if (!player)
+        {
+            handler->SendSysMessage(LANG_NO_CHAR_SELECTED);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        // .removequest #entry'
+        // number or [name] Shift-click form |color|Hquest:quest_id:quest_level|h[name]|h|r
+        char* cId = handler->extractKeyFromLink((char*)args, "Hquest");
+        if (!cId)
+            return false;
+
+        uint32 entry = atol(cId);
+
+        Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+
+        if (!quest)
+        {
+            handler->PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        // remove all quest entries for 'entry' from quest log
+        for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+        {
+            uint32 logQuest = player->GetQuestSlotQuestId(slot);
+            if (logQuest == entry)
+            {
+                player->SetQuestSlot(slot, 0);
+
+                // we ignore unequippable quest items in this case, its' still be equipped
+                player->TakeQuestSourceItem(logQuest, false);
+            }
+        }
+
+        player->RemoveActiveQuest(entry);
+        player->RemoveRewardedQuest(entry);
+
+        handler->SendSysMessage(LANG_COMMAND_QUEST_REMOVED);
+        return true;
+    }
+};
+
+PlayerbotAI::PlayerbotAI(Player* const master, Player* const bot) :
+    m_master(master), m_bot(bot), m_classAI(0), m_ignoreAIUpdatesUntilTime(0),
+    m_combatOrder(ORDERS_NONE), m_ScenarioType(SCENARIO_PVEEASY),
+    m_TimeDoneEating(0), m_TimeDoneDrinking(0),
+    m_CurrentlyCastingSpellId(0), m_spellIdCommand(0),
+    m_targetGuidCommand(0), m_taxiMaster(0)
+{
+
+    // load config variables
+    m_changeFaction = ConfigMgr::GetBoolDefault("Bot.ChangeFaction", true);
+
+    m_confMaxNumBots = ConfigMgr::GetIntDefault("Bot.MaxNumBots", 9);
+    m_confDebugWhisper = ConfigMgr::GetBoolDefault("Bot.DebugWhisper", false);
+    m_confFollowDistance[0] = ConfigMgr::GetFloatDefault("Bot.FollowDistanceMin", 0.5f);
+    m_confFollowDistance[1] = ConfigMgr::GetFloatDefault("Bot.FollowDistanceMax", 1.0f);
+    m_confCollectCombat = ConfigMgr::GetBoolDefault("Bot.Collect.Combat", true);
+    m_confCollectQuest = ConfigMgr::GetBoolDefault("Bot.Collect.Quest", true);
+    m_confCollectProfession = ConfigMgr::GetBoolDefault("Bot.Collect.Profession", true);
+    m_confCollectLoot = ConfigMgr::GetBoolDefault("Bot.Collect.Loot", true);
+    m_confCollectSkin = ConfigMgr::GetBoolDefault("Bot.Collect.Skin", true);
+    m_confCollectObjects = ConfigMgr::GetBoolDefault("Bot.Collect.Objects", true);
+    gConfigSellLevelDiff = ConfigMgr::GetIntDefault("PlayerbotAI.SellAll.LevelDiff", 10);
+    m_confCollectDistanceMax = ConfigMgr::GetIntDefault("Bot.Collect.DistanceMax", 50);
+    if (m_confCollectDistanceMax > 100)
+    {
+        //sLog->outError("Playerbot: Bot.Collect.DistanceMax higher than allowed. Using 100");
+        m_confCollectDistanceMax = 100;
+    }
+    m_confCollectDistance = ConfigMgr::GetIntDefault("Bot.Collect.Distance", 25);
+    if (m_confCollectDistance > m_confCollectDistanceMax)
+    {
+        //sLog->outError("Playerbot: Bot.Collect.Distance higher than Bot.Collect.DistanceMax. Using DistanceMax value");
+        m_confCollectDistance = m_confCollectDistanceMax;
+    }
+    m_confSellGarbage = ConfigMgr::GetBoolDefault("Bot.SellGarbage", true);
+    // set bot state
+    m_botState = BOTSTATE_NORMAL;
+
+    // reset some pointers
+    m_targetChanged = false;
+    m_targetType = TARGET_NORMAL;
+    m_targetCombat = 0;
+    m_targetAssist = 0;
+    m_targetProtect = 0;
+
+    // set collection options
+    m_collectionFlags = 0;
+    //m_collectDist = m_confCollectDistance;
+    if (m_confCollectCombat)
+        SetCollectFlag(COLLECT_FLAG_COMBAT);
+    if (m_confCollectQuest)
+        SetCollectFlag(COLLECT_FLAG_QUEST);
+    if (m_confCollectProfession)
+        SetCollectFlag(COLLECT_FLAG_PROFESSION);
+    if (m_confCollectLoot)
+        SetCollectFlag(COLLECT_FLAG_LOOT);
+    if (m_confCollectSkin && m_bot->HasSkill(SKILL_SKINNING))
+        SetCollectFlag(COLLECT_FLAG_SKIN);
+    if (m_confCollectObjects)
+        SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+
+    // set needed item list
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+
+    // start following master (will also teleport bot to master)
+    SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+
+    //add bot to group
+    ChatHandler ch(master);
+    if (Group *group = master->GetGroup())
+    {
+        if (!group->IsMember(m_bot->GetGUID()))
+        {
+            if (!group->IsFull())
+            {
+                if (!group->AddMember(m_bot))
+                {
+                    ch.PSendSysMessage("Playerbot %u is not added cuz group is full! #1", m_bot->GetGUID());
+                    master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+                    return;
+                }
+            }
+            else if (!group->isRaidGroup())
+            {
+                group->ConvertToRaid();
+                if (!group->AddMember(m_bot))
+                {
+                    ch.PSendSysMessage("Playerbot %u is not added! #2", m_bot->GetGUID());
+                    master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+                    return;
+                }
+            }
+            else//raid group is full
+            {
+                ch.PSendSysMessage("Playerbot %u is not added cuz group is full! #2", m_bot->GetGUID());
+                master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+                return;
+            }
+        }
+    }
+    else
+    {
+        group = new Group;
+        if (!group->Create(master))
+        {
+            delete group;
+            return;
+        }
+
+        //critical part
+        sGroupMgr->AddGroup(group);
+
+        if (!group->AddMember(m_bot))
+        {
+            ch.PSendSysMessage("Playerbot %u is not added! #2", m_bot->GetGUID());
+            master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+            return;
+        }
+    }
+
+    // get class specific ai
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(m_master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(m_master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            if (m_bot->GetSpec() == SHAMAN_SPEC_ENHANCEMENT)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(m_master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(m_master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(m_master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            if (m_bot->GetSpec() == DRUID_SPEC_FERAL)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(m_master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(m_master, m_bot, this);
+            ASPECT_OF_THE_MONKEY = initSpell(ASPECT_OF_THE_MONKEY_1);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDeathKnightAI(m_master, m_bot, this);
+            break;
+    }
+
+    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
+    MINING              = initSpell(MINING_1);
+    SKINNING            = initSpell(SKINNING_1);
+
+    ClearActiveTalentSpec();
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    if (m_classAI) delete m_classAI;
+}
+
+// finds spell ID for matching substring args
+// in priority of full text match, spells not taking reagents, and highest rank
+uint32 PlayerbotAI::getSpellId(const char* args, bool master) const
+{
+    if (!*args)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = 0;
+    if (master)
+        loc = m_master->GetSession()->GetSessionDbcLocale();
+    else
+        loc = m_bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo || pSpellInfo->IsPassive())
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length());
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0);
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::getPetSpellId(const char* args) const
+{
+    if (!*args)
+        return 0;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return 0;
+
+    std::string namepart = args;
+    std::wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    // converting string that we try to find to lower case
+    wstrToLower(wnamepart);
+
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundExactMatch = false;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        const std::string name = pSpellInfo->SpellName[loc];
+        if (name.empty() || !Utf8FitTo(name, wnamepart))
+            continue;
+
+        bool isExactMatch = (name.length() == wnamepart.length()) ? true : false;
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0) ? true : false;
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0)
+        {
+            if (isExactMatch && !foundExactMatch) {}
+            else if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell)
+        {
+            foundSpellId = spellId;
+            foundExactMatch = isExactMatch;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    return foundSpellId;
+}
+
+uint32 PlayerbotAI::initSpell(uint32 spellId) const
+{
+    // Check if bot knows this spell
+    if (!m_bot->HasSpell(spellId))
+        return 0;
+
+    uint32 next = 0;
+    SpellChainNode const *Node = sSpellMgr->GetSpellChainNode(spellId);
+    next = Node && Node->next ? Node->next->Id : 0;
+    //const SpellInfo *const spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (next == 0 || !m_bot->HasSpell(next))
+    {
+        //// Add spell to spellrange map
+        //Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+        //float range = spellInfo->GetMaxRange(spellInfo->IsPositive());
+        //m_bot->ApplySpellMod(spellId, SPELLMOD_RANGE, range, spell);
+        //m_spellRangeMap.insert(std::pair<uint32, float>(spellId, range));
+        //delete spell;
+        ////sLog->outBasic("Pbot::InitSpell() proceed spell %u (%s): returned %u (%s)", spellId, spellInfo->SpellName[0], spellId, spellInfo->SpellName[0]);
+        return spellId;
+    }
+    else
+    {
+        //sLog->outBasic("Pbot::InitSpell() proceed spell %u (%s): forwarding to %u (%s)", spellId, spellInfo->SpellName[0], next, sSpellMgr->GetSpellInfo(next)->SpellName[0]);
+        return initSpell(next);
+    }
+    //return (next == 0) ? spellId : next;
+}
+
+// Pet spells do not form chains like player spells.
+// One of the options to initialize a spell is to use spell icon id
+uint32 PlayerbotAI::initPetSpell(uint32 spellIconId)
+{
+    Pet * pet = m_bot->GetPet();
+
+    if (!pet)
+        return 0;
+
+    for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second.state == PETSPELL_REMOVED || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+            continue;
+
+        const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (pSpellInfo->SpellIconID == spellIconId)
+            return spellId;
+    }
+
+    // Nothing found
+    return 0;
+}
+
+/*
+ * Send list of the equipment in bot's inventory not currently equipped.
+ * This is called when the master is inspecting the bot.
+ */
+void PlayerbotAI::SendNotEquipList(Player& /*player*/)
+{
+    // find all unequipped items and put them in
+    // a vector of dynamically created lists where the vector index is from 0-18
+    // and the list contains Item* that can be equipped to that slot
+    // Note: each dynamically created list in the vector must be deleted at end
+    // so NO EARLY RETURNS!
+    // see enum EquipmentSlots in Player.h to see what equipment slot each index in vector
+    // is assigned to. (The first is EQUIPMENT_SLOT_HEAD=0, and last is EQUIPMENT_SLOT_TABARD=18)
+    std::list<Item*>* equip[19];
+    for (uint8 i = 0; i < 19; ++i)
+        equip[i] = NULL;
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+
+        // the dest looks like it includes the old loc in the 8 higher bits
+        // so casting it to a uint8 strips them
+        int8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+
+        // create a list if one doesn't already exist
+        if (equip[equipSlot] == NULL)
+            equip[equipSlot] = new std::list<Item*>;
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        itemListForEqSlot->push_back(pItem);
+    }
+
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+
+                uint16 dest;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+
+                int8 equipSlot = uint8(dest);
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+
+                // create a list if one doesn't already exist
+                if (equip[equipSlot] == NULL)
+                    equip[equipSlot] = new std::list<Item*>;
+
+                std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+                itemListForEqSlot->push_back(pItem);
+            }
+    }
+
+    ChatHandler ch(m_master);
+    bool bAnyEquippable = false;
+
+    const std::string descr[] = { "head", "neck", "shoulders", "body", "chest",
+                                  "waist", "legs", "feet", "wrists", "hands", "finger1", "finger2",
+                                  "trinket1", "trinket2", "back", "mainhand", "offhand", "ranged",
+                                  "tabard" };
+
+    // now send client all items that can be equipped by slot
+    for (uint8 equipSlot = 0; equipSlot < 19; ++equipSlot)
+    {
+        if (equip[equipSlot] == NULL)
+            continue;
+
+        if (!bAnyEquippable)
+        {
+            TellMaster("Here's all the items in my inventory that I can equip:");
+            bAnyEquippable = true;
+        }
+
+        std::list<Item*>* itemListForEqSlot = equip[equipSlot];
+        std::ostringstream out;
+        out << descr[equipSlot] << ": ";
+        for (std::list<Item*>::iterator it = itemListForEqSlot->begin(); it != itemListForEqSlot->end(); ++it)
+        {
+            if ((*it))
+                MakeItemLink((*it), out, true);
+            //const ItemTemplate* const pItemProto = (*it)->GetTemplate();
+            //std::string itemName = pItemProto->Name1;
+            //ItemLocalization(itemName, pItemProto->ItemId);
+            //out << " |cffffffff|Hitem:" << pItemProto->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+        }
+        ch.SendSysMessage(out.str().c_str());
+
+        delete itemListForEqSlot; // delete list of Item*
+    }
+
+    if (!bAnyEquippable)
+        TellMaster("There are no items in my inventory that I can equip.");
+}
+
+void PlayerbotAI::FollowAutoReset(Player& /*player*/)
+{
+    if (FollowAutoGo != 0)
+    {
+        FollowAutoGo = 3;
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+    }
+}
+
+void PlayerbotAI::AutoUpgradeEquipment(Player& /*player*/) // test for autoequip
+{
+    ChatHandler ch(m_master);
+    std::ostringstream out;
+    std::ostringstream msg;
+    uint32 calc = .10;
+    if (AutoEquipPlug != 1)
+        if (AutoEquipPlug == 2)
+            AutoEquipPlug = 0;
+        else
+            return;
+    // check equipped items for anything that is worn and UNequip them first if possible
+    for (uint8 eqslot = EQUIPMENT_SLOT_START; eqslot < EQUIPMENT_SLOT_END; eqslot++)
+    {
+        Item* const eqitem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, eqslot);
+        if (!eqitem)
+            continue;
+        // if item durability is less than 10% of max durability, UNequip it.
+        if (eqitem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY) > 0 && eqitem->GetUInt32Value(ITEM_FIELD_DURABILITY) <= (calc * eqitem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY)))
+        {
+            ItemPosCountVec sDest;
+            InventoryResult msg = m_bot->CanStoreItem( NULL_BAG, NULL_SLOT, sDest, eqitem, false );
+            if(msg == EQUIP_ERR_OK)
+            {
+                m_bot->RemoveItem(INVENTORY_SLOT_BAG_0, eqslot, true);
+                m_bot->StoreItem( sDest, eqitem, true );
+            }
+            else
+            {
+                m_bot->SendEquipError(msg, eqitem, NULL);
+            }
+        }
+    }
+    // Find equippable items in main backpack one at a time
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+        // if item durability is less than 10% of max durability, ignore it..
+        if (pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY) > 0 && pItem->GetUInt32Value(ITEM_FIELD_DURABILITY) <= (calc * pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY)))
+        {
+            MakeItemLink(pItem, out, true);
+            continue;
+        }
+        uint32 spellId = 0;
+        for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            if (pItem->GetTemplate()->Spells[i].SpellId > 0)
+            {
+                spellId = pItem->GetTemplate()->Spells[i].SpellId;
+                break;
+            }
+        }
+        if (pItem->GetTemplate()->Flags & ITEM_PROTO_FLAG_OPENABLE && spellId == 0)
+        {
+            std::string oops = "Oh.. Look!! Theres something Inside this!!!";
+            m_bot->Say(oops, LANG_UNIVERSAL);
+            UseItem(pItem);
+            continue;
+        }
+        if (uint32 questid = pItem->GetTemplate()->StartQuest)
+        {
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+            if (m_bot->GetQuestStatus(questid) == QUEST_STATUS_COMPLETE)
+                continue;
+            else if (!m_bot->CanTakeQuest(qInfo, false))
+            {
+                std::string oops = "Great..more junk..can I get rid of this please?";
+                m_bot->Say(oops, LANG_UNIVERSAL);
+                continue;
+            }
+            UseItem(pItem);
+        }
+        uint16 dest;
+        uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+        if (msg != EQUIP_ERR_OK)
+            continue;
+        int8 equipSlot = uint8(dest);
+        if (!(equipSlot >= 0 && equipSlot < 19))
+            continue;
+        Item* const pItem2 = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, equipSlot); // do we have anything equipped of this type?
+        if (!pItem2)// no item to compare to see if has stats useful for this bots class/style so check for stats and equip if possible
+        {
+            ItemTemplate const *pProto2 = pItem->GetTemplate();
+            if (!ItemStatComparison(pProto2, pProto2))
+                continue;
+            EquipItem(pItem); //no item equipped so equip new one and go to next item.
+            continue;
+        }
+        // we have an equippable item, ..now lets send it to the comparison function to see if its better than we have on.
+        AutoEquipComparison(pItem, pItem2); //pItem is new item, pItem2 is equipped item.
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (!pItem)
+                    continue;
+                // if item durability is less than 10% of max durability, ignore it..
+                if (pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY) > 0 && pItem->GetUInt32Value(ITEM_FIELD_DURABILITY) <= (calc * pItem->GetUInt32Value(ITEM_FIELD_MAXDURABILITY)))
+                {
+                    MakeItemLink(pItem, out, true);
+                    continue;
+                }
+                uint16 dest;
+                uint8 msg = m_bot->CanEquipItem(NULL_SLOT, dest, pItem, !pItem->IsBag());
+                if (msg != EQUIP_ERR_OK)
+                    continue;
+                int8 equipSlot = uint8(dest);
+                if (!(equipSlot >= 0 && equipSlot < 19))
+                    continue;
+                Item* const pItem2 = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, equipSlot); // do we have anything equipped of this type?
+                if (!pItem2)
+                {
+                    ItemTemplate const *pProto2 = pItem->GetTemplate();
+                    if (!ItemStatComparison(pProto2, pProto2))
+                        continue;
+                    EquipItem(pItem); //no item equipped so equip new one if useable stats and go to next item.
+                    continue;
+                }
+                // we have an equippable item, but something else is equipped..now lets send it to the comparison function to see if its better than we have on.
+                AutoEquipComparison(pItem, pItem2); //pItem is new item, pItem2 is equipped item.
+            }
+    }
+    if (out.str().size() != 0)
+    {
+        std::ostringstream tmp;
+        tmp << "|h|cff00ffff _______________________________________ ";
+        ch.SendSysMessage(tmp.str().c_str());
+        ch.SendSysMessage(out.str().c_str());
+        ch.SendSysMessage(tmp.str().c_str());
+        TellMaster("These items are worn too badly to use.");// check inventory items.. we'll deal with equipped items elsewhere
+    }
+    InspectUpdate();
+}
+void PlayerbotAI::AutoEquipComparison(Item *pItem, Item *pItem2)
+{
+    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
+    {
+        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0, 0
+    };
+    ItemTemplate const *pProto = pItem2->GetTemplate(); // equipped item if any
+    ItemTemplate const *pProto2 = pItem->GetTemplate(); // new item to compare
+    // DEBUG_LOG("Item Class (%s)",(pProto->Class == ITEM_CLASS_WEAPON ? "Weapon" : "Not Weapon"));
+    switch (pProto->Class)
+    {
+    case ITEM_CLASS_WEAPON:
+        {
+            // DEBUG_LOG("Current Item DPS (%f) Equippable Item DPS (%f)",pProto->getDPS(),pProto2->getDPS());
+            // m_bot->GetSkillValue(pProto->RequiredSkill) < m_bot->GetSkillValue(pProto2->RequiredSkill)
+            if (pProto->getDPS() < pProto2->getDPS())   // if new item has a better DPS
+            {
+                EquipItem(pItem);
+                pProto = pProto2; // ensure that the item with the highest DPS is equipped
+            }
+            break;
+        }
+    case ITEM_CLASS_ARMOR:
+        {
+            if (pProto->ItemLevel < pProto2->ItemLevel && pProto->Armor <= pProto2->Armor && m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) &&
+                !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
+            {
+                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
+                if (pProto2->StatsCount > 0)
+                {
+                    if (!ItemStatComparison(pProto, pProto2))
+                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
+                }
+                EquipItem(pItem);
+                break;
+            }
+            // now in case they are same itemlevel, but one is better than the other..
+            if (pProto->ItemLevel == pProto2->ItemLevel && pProto->Quality < pProto2->Quality && pProto->Armor <= pProto2->Armor &&
+                m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
+            {
+                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
+                if (pProto2->StatsCount > 0)
+                {
+                    if (!ItemStatComparison(pProto, pProto2))
+                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
+                }
+                EquipItem(pItem);
+                break;
+            }
+            if (pProto->ItemLevel <= pProto2->ItemLevel && pProto->Quality < pProto2->Quality && pProto->Armor > pProto2->Armor &&
+                m_bot->HasSkill(item_armor_skills[pProto2->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto2->SubClass + 1])) // itemlevel + armour + armour class
+            {
+                // First check to see if this item has stats, and if the bot REALLY wants to lose its old item
+                if (pProto2->StatsCount > 0)
+                {
+                    if (!ItemStatComparison(pProto, pProto2))
+                        return; // stats on equipped item are better, OR stats are not useful for this bots class/style
+                }
+                EquipItem(pItem);
+                break;
+            }
+        }
+    }
+    InspectUpdate();
+}
+bool PlayerbotAI::ItemStatComparison(const ItemTemplate *pProto, const ItemTemplate *pProto2)
+{
+    uint8 isclass = 0; // 1= caster 2 = hybrid 3 = melee
+    uint8 ishybrid = 0;
+    uint8 olditemscore = 0;
+    uint8 newitemscore = 0;
+    // get class and style to make it easier to compare later
+    switch (m_bot->getClass())
+    {
+    case CLASS_SHAMAN:
+        {
+            isclass = 2;
+            ishybrid = 1; // hybrid caster
+            break;
+        }
+    case CLASS_PRIEST:
+        {
+            isclass = 1;
+            break;
+        }
+    case CLASS_MAGE:
+        {
+            isclass = 1;
+            break;
+        }
+    case CLASS_WARLOCK:
+        {
+            isclass = 1;
+            break;
+        }
+    case CLASS_DRUID:
+        {
+            ishybrid = 1;
+            isclass = 2; // caster
+            break;
+        }
+    }
+    switch (m_bot->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_ROGUE:
+        isclass = 3; // melee
+        break;
+    }
+    switch (m_bot->getClass())
+    {
+    case CLASS_HUNTER:
+        isclass = 2;
+        ishybrid = 2;
+    case CLASS_PALADIN:
+    case CLASS_DEATH_KNIGHT:
+        isclass = 2; // hybrid melee
+        ishybrid = 1;
+        break;
+    }
+    for (int i = 0; i < MAX_ITEM_PROTO_STATS; ++i) // item can only have 10 stats. We check each stat slot available for stat and type.
+    {
+        uint32 itemmod = pProto->ItemStat[i].ItemStatType; // equipped item stats if any
+        uint32 itemmod2 = pProto2->ItemStat[i].ItemStatType; // newitem stats
+        //if (!itemmod) // if no stat type in this slot, continue to next slot
+        //   continue;
+        // caster stats
+        if (itemmod == ITEM_MOD_MANA || itemmod == ITEM_MOD_INTELLECT || itemmod == ITEM_MOD_SPIRIT || itemmod == ITEM_MOD_HIT_SPELL_RATING ||
+            itemmod == ITEM_MOD_CRIT_SPELL_RATING || itemmod == ITEM_MOD_HASTE_SPELL_RATING || itemmod == ITEM_MOD_SPELL_DAMAGE_DONE ||
+            itemmod == ITEM_MOD_MANA_REGENERATION || itemmod == ITEM_MOD_SPELL_POWER || itemmod == ITEM_MOD_SPELL_PENETRATION ||
+            itemmod2 == ITEM_MOD_MANA || itemmod2 == ITEM_MOD_INTELLECT || itemmod2 == ITEM_MOD_SPIRIT || itemmod2 == ITEM_MOD_HIT_SPELL_RATING ||
+            itemmod2 == ITEM_MOD_CRIT_SPELL_RATING || itemmod2 == ITEM_MOD_HASTE_SPELL_RATING || itemmod2 == ITEM_MOD_SPELL_DAMAGE_DONE ||
+            itemmod2 == ITEM_MOD_MANA_REGENERATION || itemmod2 == ITEM_MOD_SPELL_POWER || itemmod2 == ITEM_MOD_SPELL_PENETRATION)
+        {
+            switch (isclass) // 1 caster, 2 hybrid, 3 melee
+            {
+            case 1:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+
+                    break;
+                }
+            case 2:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (ishybrid != 2) //not a hunter
+                    {
+                        if (itemmod == itemmod2) //same stat type
+                        {
+                            if (itemmodval < itemmodval2) // which one has the most
+                            {
+                                if (olditemscore > 0)
+                                    olditemscore = (olditemscore - 1);
+                                newitemscore = (newitemscore + 1);
+                            }
+                            else
+                            {
+                                if (newitemscore > 0)
+                                    newitemscore = (newitemscore - 1);
+                                olditemscore = (olditemscore + 1);
+                            }
+                        }
+                        else
+                        {
+                            if (itemmod)
+                                olditemscore = (olditemscore + 1);
+                            if (itemmod2)
+                                newitemscore = (newitemscore + 1);
+                        }
+                    }
+                    else //is a hunter
+                    {
+                        if (itemmod)
+                        {
+                            if (olditemscore > 0) //we dont want any negative returns
+                                olditemscore = (olditemscore - 1);
+                        }
+                        if (itemmod2)
+                        {
+                            if (newitemscore > 0) //we dont want any negative returns
+                                newitemscore = (newitemscore - 1);
+                        }
+                    }
+                    break;
+                }  // pure melee need nothing from this list.
+            case 3:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            default:
+                break;
+            }
+        }
+        // melee only stats (warrior/rogue) or stats that only apply to melee style combat
+        if (itemmod == ITEM_MOD_HEALTH || itemmod == ITEM_MOD_AGILITY || itemmod == ITEM_MOD_STRENGTH ||
+            itemmod == ITEM_MOD_DEFENSE_SKILL_RATING || itemmod == ITEM_MOD_DODGE_RATING || itemmod == ITEM_MOD_PARRY_RATING ||
+            itemmod == ITEM_MOD_BLOCK_RATING ||	itemmod == ITEM_MOD_HIT_MELEE_RATING || itemmod == ITEM_MOD_CRIT_MELEE_RATING ||
+            itemmod == ITEM_MOD_HIT_TAKEN_MELEE_RATING || itemmod == ITEM_MOD_HIT_TAKEN_RANGED_RATING ||itemmod == ITEM_MOD_HIT_TAKEN_SPELL_RATING ||
+            itemmod == ITEM_MOD_CRIT_TAKEN_MELEE_RATING || itemmod == ITEM_MOD_CRIT_TAKEN_RANGED_RATING ||
+            itemmod == ITEM_MOD_CRIT_TAKEN_SPELL_RATING || itemmod == ITEM_MOD_HASTE_MELEE_RATING ||
+            itemmod == ITEM_MOD_HIT_TAKEN_RATING || itemmod == ITEM_MOD_CRIT_TAKEN_RATING || itemmod == ITEM_MOD_ATTACK_POWER ||
+            itemmod == ITEM_MOD_BLOCK_VALUE || itemmod2 == ITEM_MOD_HEALTH || itemmod2 == ITEM_MOD_AGILITY || itemmod2 == ITEM_MOD_STRENGTH ||
+            itemmod2 == ITEM_MOD_DEFENSE_SKILL_RATING || itemmod2 == ITEM_MOD_DODGE_RATING || itemmod2 == ITEM_MOD_PARRY_RATING ||
+            itemmod2 == ITEM_MOD_BLOCK_RATING ||	itemmod2 == ITEM_MOD_HIT_MELEE_RATING || itemmod2 == ITEM_MOD_CRIT_MELEE_RATING ||
+            itemmod2 == ITEM_MOD_HIT_TAKEN_MELEE_RATING || itemmod2 == ITEM_MOD_HIT_TAKEN_RANGED_RATING ||itemmod2 == ITEM_MOD_HIT_TAKEN_SPELL_RATING ||
+            itemmod2 == ITEM_MOD_CRIT_TAKEN_MELEE_RATING || itemmod2 == ITEM_MOD_CRIT_TAKEN_RANGED_RATING ||
+            itemmod2 == ITEM_MOD_CRIT_TAKEN_SPELL_RATING || itemmod2 == ITEM_MOD_HASTE_MELEE_RATING ||
+            itemmod2 == ITEM_MOD_HIT_TAKEN_RATING || itemmod2 == ITEM_MOD_CRIT_TAKEN_RATING || itemmod2 == ITEM_MOD_ATTACK_POWER ||
+            itemmod2 == ITEM_MOD_BLOCK_VALUE)
+        {
+            switch (isclass) // 1 caster, 2 hybrid, 3 melee
+            {
+            case 1:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            case 2:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            case 3:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+
+                    break;
+                }
+            default:
+                break;
+            }
+        }
+        // stats which aren't strictly caster or melee (hybrid perhaps or style dependant)
+        if (itemmod == ITEM_MOD_HIT_RATING || itemmod == ITEM_MOD_CRIT_RATING ||
+            itemmod == ITEM_MOD_RESILIENCE_RATING || itemmod == ITEM_MOD_HASTE_RATING || itemmod == ITEM_MOD_EXPERTISE_RATING ||
+            itemmod == ITEM_MOD_ARMOR_PENETRATION_RATING || itemmod == ITEM_MOD_HEALTH_REGEN ||	itemmod == ITEM_MOD_STAMINA ||
+            itemmod2 == ITEM_MOD_HIT_RATING || itemmod2 == ITEM_MOD_CRIT_RATING || itemmod2 == ITEM_MOD_RESILIENCE_RATING ||
+            itemmod2 == ITEM_MOD_HASTE_RATING || itemmod2 == ITEM_MOD_EXPERTISE_RATING || itemmod2 == ITEM_MOD_ARMOR_PENETRATION_RATING ||
+            itemmod2 == ITEM_MOD_HEALTH_REGEN || itemmod2 == ITEM_MOD_STAMINA)
+        {
+            switch (isclass) // 1 caster, 2 hybrid, 3 melee
+            {
+            case 1:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            case 2:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            case 3:
+                {
+                    uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                    uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                    if (itemmod == itemmod2) //same stat type
+                    {
+                        if (itemmodval < itemmodval2) // which one has the most
+                        {
+                            if (olditemscore > 0)
+                                olditemscore = (olditemscore - 1);
+                            newitemscore = (newitemscore + 1);
+                        }
+                        else
+                        {
+                            if (newitemscore > 0)
+                                newitemscore = (newitemscore - 1);
+                            olditemscore = (olditemscore + 1);
+                        }
+                    }
+                    else
+                    {
+                        if (itemmod)
+                            olditemscore = (olditemscore + 1);
+                        if (itemmod2)
+                            newitemscore = (newitemscore + 1);
+                    }
+                    break;
+                }
+            default:
+                break;
+            }
+            }
+            // stats relating to ranged only
+            if (itemmod == ITEM_MOD_HIT_RANGED_RATING || itemmod == ITEM_MOD_CRIT_RANGED_RATING || itemmod == ITEM_MOD_HASTE_RANGED_RATING ||
+                itemmod == ITEM_MOD_RANGED_ATTACK_POWER || itemmod2 == ITEM_MOD_HIT_RANGED_RATING || itemmod2 == ITEM_MOD_CRIT_RANGED_RATING ||
+                itemmod2 == ITEM_MOD_HASTE_RANGED_RATING || itemmod2 == ITEM_MOD_RANGED_ATTACK_POWER)
+            {
+                switch (isclass) // 1 caster, 2 hybrid, 3 melee
+                {
+                case 1:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            case 2:
+                {
+                    if (ishybrid != 2) //not a hunter
+                    {
+                        if (itemmod)
+                        {
+                            if (olditemscore > 0) //we dont want any negative returns
+                                olditemscore = (olditemscore - 1);
+                        }
+                        if (itemmod2)
+                        {
+                            if (newitemscore > 0) //we dont want any negative returns
+                                newitemscore = (newitemscore - 1);
+                        }
+                    }
+                    else //is a hunter
+                    {
+                        uint32 itemmodval = pProto->ItemStat[i].ItemStatValue; // equipped item stats if any
+                        uint32 itemmodval2 = pProto2->ItemStat[i].ItemStatValue;  // newitem stats
+                        if (itemmod == itemmod2) //same stat type
+                        {
+                            if (itemmodval < itemmodval2) // which one has the most
+                            {
+                                if (olditemscore > 0)
+                                    olditemscore = (olditemscore - 1);
+                                newitemscore = (newitemscore + 1);
+                            }
+                            else
+                            {
+                                if (newitemscore > 0)
+                                    newitemscore = (newitemscore - 1);
+                                olditemscore = (olditemscore + 1);
+                            }
+                        }
+                        else
+                        {
+                            if (itemmod)
+                                olditemscore = (olditemscore + 1);
+                            if (itemmod2)
+                                newitemscore = (newitemscore + 1);
+                        }
+                    }
+                    break;
+                }
+            case 3:
+                {
+                    if (itemmod)
+                    {
+                        if (olditemscore > 0) //we dont want any negative returns
+                            olditemscore = (olditemscore - 1);
+                    }
+                    if (itemmod2)
+                    {
+                        if (newitemscore > 0) //we dont want any negative returns
+                            newitemscore = (newitemscore - 1);
+                    }
+                    break;
+                }
+            default:
+                break;
+            }
+        }
+    }
+    if (olditemscore <= newitemscore)
+        return true;
+    else
+        return false;
+}
+
+void PlayerbotAI::SendQuestNeedList()
+{
+    std::ostringstream out;
+
+    for (BotNeedItem::iterator itr = m_needItemList.begin(); itr != m_needItemList.end(); ++itr)
+    {
+        ItemTemplate const* pItemProto = sObjectMgr->GetItemTemplate(itr->first);
+        if (pItemProto)
+        {
+            std::string itemName = pItemProto->Name1;
+            ItemLocalization(itemName, pItemProto->ItemId);
+
+            out << " " << itr->second << "x|cffffffff|Hitem:" << pItemProto->ItemId
+                << ":0:0:0:0:0:0:0" << "|h[" << itemName
+                << "]|h|r";
+        }
+    }
+
+    for (BotNeedItem::iterator itr = m_needCreatureOrGOList.begin(); itr != m_needCreatureOrGOList.end(); ++itr)
+    {
+        CreatureTemplate const* cInfo = sObjectMgr->GetCreatureTemplate(itr->first);
+        if (cInfo)
+        {
+            std::string creatureName = cInfo->Name;
+            CreatureLocalization(creatureName, cInfo->Entry);
+            out << " " << itr->second << "x|cFFFFFF00|Hcreature_entry:" << itr->first << "|h[" << creatureName << "]|h|r";
+        }
+
+        if (m_bot->HasQuestForGO(itr->first))
+        {
+            GameObjectTemplate const* gInfo = sObjectMgr->GetGameObjectTemplate(itr->first);
+            if (gInfo)
+            {
+                std::string gameobjectName = gInfo->name;
+                GameObjectLocalization(gameobjectName, gInfo->entry);
+                out << " " << itr->second << "x|cFFFFFF00|Hgameobject_entry:" << itr->first << "|h[" << gameobjectName << "]|h|r";
+            }
+        }
+    }
+
+    TellMaster("Here's a list of all things needed for quests:");
+    if (!out.str().empty())
+        TellMaster(out.str().c_str());
+}
+
+bool PlayerbotAI::IsItemUseful(uint32 itemid)
+{
+    const static uint32 item_weapon_skills[MAX_ITEM_SUBCLASS_WEAPON] =
+    {
+        SKILL_AXES,     SKILL_2H_AXES,  SKILL_BOWS,          SKILL_GUNS,      SKILL_MACES,
+        SKILL_2H_MACES, SKILL_POLEARMS, SKILL_SWORDS,        SKILL_2H_SWORDS, 0,
+        SKILL_STAVES,   0,              0,                   SKILL_UNARMED,   0,
+        SKILL_DAGGERS,  SKILL_THROWN,   SKILL_ASSASSINATION, SKILL_CROSSBOWS, SKILL_WANDS,
+        SKILL_FISHING
+    };
+
+    const static uint32 item_armor_skills[MAX_ITEM_SUBCLASS_ARMOR] =
+    {
+        0, SKILL_CLOTH, SKILL_LEATHER, SKILL_MAIL, SKILL_PLATE_MAIL, 0, SKILL_SHIELD, 0, 0, 0, 0
+    };
+
+    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+    if (!pProto || pProto->Quality < ITEM_QUALITY_NORMAL)
+        return false;
+
+    // do we already have the max allowed of item if more than zero?
+    if (pProto->MaxCount > 0 && m_bot->HasItemCount(itemid, pProto->MaxCount, true))
+        return false;
+
+    // quest related items
+    if (pProto->StartQuest > 0 && HasCollectFlag(COLLECT_FLAG_QUEST))
+        return true;
+
+    switch (pProto->Class)
+    {
+        case ITEM_CLASS_WEAPON:
+            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_WEAPON)
+                return false;
+            else
+                return m_bot->HasSkill(item_weapon_skills[pProto->SubClass]);
+            break;
+        case ITEM_CLASS_ARMOR:
+            if (pProto->SubClass >= MAX_ITEM_SUBCLASS_ARMOR)
+                return false;
+            else
+                return (m_bot->HasSkill(item_armor_skills[pProto->SubClass]) && !m_bot->HasSkill(item_armor_skills[pProto->SubClass + 1]));
+            break;
+        case ITEM_CLASS_QUEST:
+            if (!HasCollectFlag(COLLECT_FLAG_QUEST))
+                break;
+        case ITEM_CLASS_KEY:
+            return true;
+        case ITEM_CLASS_GEM:
+            if ((m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                 m_bot->HasSkill(SKILL_ENGINEERING) ||
+                 m_bot->HasSkill(SKILL_JEWELCRAFTING)))
+                return true;
+            break;
+        case ITEM_CLASS_TRADE_GOODS:
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_PARTS:
+                case ITEM_SUBCLASS_EXPLOSIVES:
+                case ITEM_SUBCLASS_DEVICES:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_JEWELCRAFTING:
+                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_CLOTH:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_LEATHER:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_METAL_STONE:
+                    if ((m_bot->HasSkill(SKILL_BLACKSMITHING) ||
+                         m_bot->HasSkill(SKILL_ENGINEERING) ||
+                         m_bot->HasSkill(SKILL_MINING)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_MEAT:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_HERB:
+                    if ((m_bot->HasSkill(SKILL_HERBALISM) ||
+                         m_bot->HasSkill(SKILL_ALCHEMY) ||
+                         m_bot->HasSkill(SKILL_INSCRIPTION)))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ELEMENTAL:
+                    return true;    // pretty much every profession uses these a bit
+                case ITEM_SUBCLASS_ENCHANTING:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case ITEM_CLASS_RECIPE:
+        {
+            if (!HasCollectFlag(COLLECT_FLAG_PROFESSION))
+                break;
+
+            // skip recipes that we have
+            if (m_bot->HasSpell(pProto->Spells[2].SpellId))
+                break;
+
+            switch (pProto->SubClass)
+            {
+                case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_TAILORING_PATTERN:
+                    if (m_bot->HasSkill(SKILL_TAILORING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                    if (m_bot->HasSkill(SKILL_ENGINEERING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_BLACKSMITHING:
+                    if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_COOKING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_COOKING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                    if (m_bot->HasSkill(SKILL_ALCHEMY))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FIRST_AID))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                    if (m_bot->HasSkill(SKILL_ENCHANTING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_FISHING_MANUAL:
+                    if (m_bot->HasSkill(SKILL_FISHING))
+                        return true;
+                    break;
+                case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                    if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+                        return true;
+                    break;
+                default:
+                    break;
+            }
+        }
+        default:
+            break;
+    }
+
+    return false;
+}
+
+void PlayerbotAI::ReloadAI()
+{
+    switch (m_bot->getClass())
+    {
+        case CLASS_PRIEST:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPriestAI(m_master, m_bot, this);
+            break;
+        case CLASS_MAGE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotMageAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARLOCK:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarlockAI(m_master, m_bot, this);
+            break;
+        case CLASS_WARRIOR:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotWarriorAI(m_master, m_bot, this);
+            break;
+        case CLASS_SHAMAN:
+            if (m_classAI) delete m_classAI;
+            if (m_bot->GetSpec() == SHAMAN_SPEC_ENHANCEMENT)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotShamanAI(m_master, m_bot, this);
+            break;
+        case CLASS_PALADIN:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotPaladinAI(m_master, m_bot, this);
+            break;
+        case CLASS_ROGUE:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotRogueAI(m_master, m_bot, this);
+            break;
+        case CLASS_DRUID:
+            if (m_classAI) delete m_classAI;
+            if (m_bot->GetSpec() == DRUID_SPEC_FERAL)
+                m_combatStyle = COMBAT_MELEE;
+            else
+                m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDruidAI(m_master, m_bot, this);
+            break;
+        case CLASS_HUNTER:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_RANGED;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotHunterAI(m_master, m_bot, this);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            if (m_classAI) delete m_classAI;
+            m_combatStyle = COMBAT_MELEE;
+            m_classAI = (PlayerbotClassAI *) new PlayerbotDeathKnightAI(m_master, m_bot, this);
+            break;
+    }
+
+    HERB_GATHERING      = initSpell(HERB_GATHERING_1);
+    MINING              = initSpell(MINING_1);
+    SKINNING            = initSpell(SKINNING_1);
+}
+
+void PlayerbotAI::SendOrders(Player& /*player*/)
+{
+    std::ostringstream out;
+
+    if (!m_combatOrder)
+        out << "Got no combat orders!";
+    else if (m_combatOrder & ORDERS_TANK)
+        out << "I TANK";
+    else if (m_combatOrder & ORDERS_ASSIST)
+        out << "I ASSIST " << (m_targetAssist ? m_targetAssist->GetName() : "unknown");
+    else if (m_combatOrder & ORDERS_HEAL)
+        out << "I HEAL and DISPEL";
+    else if (m_combatOrder & ORDERS_NODISPEL)
+        out << "I HEAL and WON'T DISPEL";
+    else if (m_combatOrder & ORDERS_PASSIVE)
+        out << "I'M PASSIVE";
+    if ((m_combatOrder & ORDERS_PRIMARY) && (m_combatOrder & ORDERS_SECONDARY))
+        out << " and ";
+    if (m_combatOrder & ORDERS_PROTECT)
+        out << "I PROTECT " << (m_targetProtect ? m_targetProtect->GetName() : "unknown");
+    out << ".";
+
+    if (m_confDebugWhisper)
+    {
+        out << " " << (IsInCombat() ? "I'm in COMBAT! " : "Not in combat. ");
+        out << "Current state is ";
+        if (m_botState == BOTSTATE_NORMAL)
+            out << "NORMAL";
+        else if (m_botState == BOTSTATE_COMBAT)
+            out << "COMBAT";
+        else if (m_botState == BOTSTATE_TAME)
+            out << "TAMING";
+        else if (m_botState == BOTSTATE_DEAD)
+            out << "DEAD";
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+            out << "RELEASED";
+        else if (m_botState == BOTSTATE_LOOTING)
+            out << "LOOTING";
+        else if (m_botState == BOTSTATE_FLYING)
+            out << "FLYING";
+        out << ". Movement order is ";
+        if (m_movementOrder == MOVEMENT_NONE)
+            out << "NONE";
+        else if (m_movementOrder == MOVEMENT_FOLLOW)
+            out << "FOLLOW " << (m_followTarget ? m_followTarget->GetName() : "unknown");
+        else if (m_movementOrder == MOVEMENT_STAY)
+            out << "STAY";
+        out << ". Got " << m_attackerInfo.size() << " attacker(s) in list.";
+        out << " Next action in " << (m_ignoreAIUpdatesUntilTime - time(NULL)) << "sec.";
+    }
+
+    TellMaster(out.str().c_str());
+}
+
+// handle outgoing packets the server would send to the client
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+        case MSG_MOVE_TELEPORT_ACK:
+        {
+            HandleTeleportAck();
+            return;
+        }
+
+        case SMSG_DUEL_WINNER:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_APPLAUD);
+            return;
+        }
+        case SMSG_DUEL_COMPLETE:
+        {
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 4;
+            m_ScenarioType = SCENARIO_PVEEASY;
+            ReloadAI();
+            m_bot->GetMotionMaster()->Clear(true);
+            return;
+        }
+        case SMSG_DUEL_OUTOFBOUNDS:
+        {
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_CHICKEN);
+            return;
+        }
+        case SMSG_DUEL_REQUESTED:
+        {
+            m_ignoreAIUpdatesUntilTime = 0;
+            WorldPacket p(packet);
+            uint64 flagGuid;
+            p >> flagGuid;
+            uint64 playerGuid;
+            p >> playerGuid;
+            Player* pPlayer = sObjectAccessor->FindPlayer(playerGuid);
+            if (canObeyCommandFrom(*pPlayer))
+            {
+                m_bot->GetMotionMaster()->Clear(true);
+                WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+                *packet << flagGuid;
+                m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+
+                // follow target in casting range
+                float angle = frand(0, float(M_PI));
+                float dist = frand(4, 10);
+
+                m_bot->GetMotionMaster()->Clear(true);
+                m_bot->GetMotionMaster()->MoveFollow(pPlayer, dist, angle);
+
+                m_bot->SetSelection(playerGuid);
+                m_ignoreAIUpdatesUntilTime = time(NULL) + 4;
+                m_ScenarioType = SCENARIO_DUEL;
+            }
+            return;
+        }
+
+        case SMSG_PET_TAME_FAILURE:
+        {
+            // sLog->outDebug(LOG_FILTER_NONE, "SMSG_PET_TAME_FAILURE");
+            WorldPacket p(packet);
+            uint8 reason;
+            p >> reason;
+
+            switch (reason)
+            {
+                case PETTAME_INVALIDCREATURE:           // = 1,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Invalid Creature");
+                    break;
+                case PETTAME_TOOMANY:                   // = 2,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Too many Creature");
+                    break;
+                case PETTAME_CREATUREALREADYOWNED:      // = 3,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature already owned");
+                    break;
+                case PETTAME_NOTTAMEABLE:               // = 4,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature not tameable");
+                    break;
+                case PETTAME_ANOTHERSUMMONACTIVE:       // = 5,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Another summon active");
+                    break;
+                case PETTAME_UNITSCANTTAME:             // = 6,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Unit cant tame");
+                    break;
+                case PETTAME_NOPETAVAILABLE:            // = 7,    // not used in taming
+                    //sLog->outDebug(LOG_FILTER_NONE, "No pet available");
+                    break;
+                case PETTAME_INTERNALERROR:             // = 8,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Internal error");
+                    break;
+                case PETTAME_TOOHIGHLEVEL:              // = 9,
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature level too high");
+                    break;
+                case PETTAME_DEAD:                      // = 10,   // not used in taming
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature dead");
+                    break;
+                case PETTAME_NOTDEAD:                   // = 11,   // not used in taming
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature not dead");
+                    break;
+                case PETTAME_CANTCONTROLEXOTIC:         // = 12,   // 3.x
+                    //sLog->outDebug(LOG_FILTER_NONE, "Creature exotic");
+                    break;
+                case PETTAME_UNKNOWNERROR:              // = 13
+                    //sLog->outDebug(LOG_FILTER_NONE, "Unknown error");
+                    break;
+            }
+            return;
+        }
+
+        case SMSG_BUY_FAILED:
+        {
+            WorldPacket p(packet); // 8+4+4+1
+            uint64 vendorguid;
+            p >> vendorguid;
+            uint32 itemid;
+            p >> itemid;
+            uint8 msg;
+            p >> msg; // error msg
+            p.resize(13);
+
+            switch (msg)
+            {
+                case BUY_ERR_CANT_FIND_ITEM:
+                    break;
+                case BUY_ERR_ITEM_ALREADY_SOLD:
+                    break;
+                case BUY_ERR_NOT_ENOUGHT_MONEY:
+                {
+                    Announce(CANT_AFFORD);
+                    break;
+                }
+                case BUY_ERR_SELLER_DONT_LIKE_YOU:
+                    break;
+                case BUY_ERR_DISTANCE_TOO_FAR:
+                    break;
+                case BUY_ERR_ITEM_SOLD_OUT:
+                    break;
+                case BUY_ERR_CANT_CARRY_MORE:
+                {
+                    Announce(INVENTORY_FULL);
+                    break;
+                }
+                case BUY_ERR_RANK_REQUIRE:
+                    break;
+                case BUY_ERR_REPUTATION_REQUIRE:
+                    break;
+            }
+            return;
+        }
+
+        case SMSG_AUCTION_COMMAND_RESULT:
+        {
+            uint32 auctionId, Action, ErrorCode;
+            std::string action[3] = {"Creating", "Cancelling", "Bidding"};
+            std::ostringstream out;
+
+            WorldPacket p(packet);
+            p >> auctionId;
+            p >> Action;
+            p >> ErrorCode;
+            p.resize(12);
+
+            switch (ErrorCode)
+            {
+                case AUCTION_OK:
+                {
+                    out << "|cff1eff00|h" << action[Action] << " was successful|h|r";
+                    break;
+                }
+                case AUCTION_INTERNAL_ERROR:
+                {
+                    out << "|cffff0000|hWhile" << action[Action] << ", an internal error occured|h|r";
+                    break;
+                }
+                case AUCTION_NOT_ENOUGHT_MONEY:
+                {
+                    out << "|cffff0000|hWhile " << action[Action] << ", I didn't have enough money|h|r";
+                    break;
+                }
+                case AUCTION_ITEM_NOT_FOUND:
+                {
+                    out << "|cffff0000|hItem was not found!|h|r";
+                    break;
+                }
+                case CANNOT_BID_YOUR_AUCTION_ERROR:
+                {
+                    out << "|cffff0000|hI cannot bid on my own auctions!|h|r";
+                    break;
+                }
+            }
+            TellMaster(out.str().c_str());
+            return;
+        }
+
+        case SMSG_INVENTORY_CHANGE_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 err;
+            p >> err;
+
+            if (err != EQUIP_ERR_OK)
+            {
+                switch (err)
+                {
+                    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+                        TellMaster("I can't carry anymore of those.");
+                        return;
+                    case EQUIP_ERR_MISSING_REAGENT:
+                        TellMaster("I'm missing some reagents for that.");
+                        return;
+                    case EQUIP_ERR_ITEM_LOCKED:
+                        TellMaster("That item is locked.");
+                        return;
+                    case EQUIP_ERR_ALREADY_LOOTED:
+                        TellMaster("That is already looted.");
+                        return;
+                    case EQUIP_ERR_INVENTORY_FULL:
+                    {
+                        if (m_inventory_full)
+                            return;
+
+                        TellMaster("My inventory is full.");
+                        m_inventory_full = true;
+                        return;
+                    }
+                    case EQUIP_ERR_NOT_IN_COMBAT:
+                        TellMaster("I can't use that in combat.");
+                        return;
+                    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+                        TellMaster("I can't get that now.");
+                        return;
+                    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+                        TellMaster("I can only have one of those equipped.");
+                        return;
+                    case EQUIP_ERR_BANK_FULL:
+                        TellMaster("My bank is full.");
+                        return;
+                    case EQUIP_ERR_ITEM_NOT_FOUND:
+                        TellMaster("I can't find the item.");
+                        return;
+                    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+                        TellMaster("I'm too far from the bank.");
+                        return;
+                    case EQUIP_ERR_NONE:
+                        TellMaster("I can't use it on that");
+                        return;
+                    default:
+                        TellMaster("I can't use that.");
+                        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: HandleBotOutgoingPacket - SMSG_INVENTORY_CHANGE_FAILURE: %u", err);
+                        return;
+                }
+            }
+        }
+
+        case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            uint8 castCount;
+            uint32 spellId;
+            uint8 result;
+            std::ostringstream out;
+
+            p >> castCount >> spellId >> result;
+
+            if (result != SPELL_CAST_OK)
+            {
+                switch (result)
+                {
+                    case SPELL_FAILED_INTERRUPTED:  // 40
+                        //sLog->outDebug(LOG_FILTER_NONE, "spell interrupted (%u)",result);
+                        return;
+
+                    case SPELL_FAILED_BAD_TARGETS:  // 12
+                    {
+                        // sLog->outDebug(LOG_FILTER_NONE, "[%s]bad target (%u) for spellId (%u) & m_CurrentlyCastingSpellId (%u)",m_bot->GetName(),result,spellId,m_CurrentlyCastingSpellId);
+                        Spell* const pSpell = GetCurrentSpell();
+                        if (pSpell)
+                            pSpell->cancel();
+                        return;
+                    }
+                    case SPELL_FAILED_REQUIRES_SPELL_FOCUS: // 102
+                    {
+                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!spellInfo)
+                            return;
+
+                        switch (spellInfo->RequiresSpellFocus) // SpellFocusObject.dbc id
+                        {
+                            case 1:  // need an anvil
+                                out << "|cffff0000I require an anvil.";
+                                break;
+                            case 2:  // need a loom
+                                out << "|cffff0000I require a loom.";
+                                break;
+                            case 3:  // need forge
+                                out << "|cffff0000I require a forge.";
+                                break;
+                            case 4:  // need cooking fire
+                                out << "|cffff0000I require a cooking fire.";
+                                break;
+                            default:
+                                out << "|cffff0000I Require Spell Focus on " << spellInfo->RequiresSpellFocus;
+                        }
+                        break;
+                    }
+                    case SPELL_FAILED_CANT_BE_DISENCHANTED:  // 14
+                    {
+                        out << "|cffff0000Item cannot be disenchanted.";
+                        break;
+                    }
+                    case SPELL_FAILED_CANT_BE_MILLED:  // 16
+                    {
+                        out << "|cffff0000I cannot mill that.";
+                        break;
+                    }
+                    case SPELL_FAILED_CANT_BE_PROSPECTED:  // 17
+                    {
+                        out << "|cffff0000There are no gems in this.";
+                        break;
+                    }
+                    case SPELL_FAILED_EQUIPPED_ITEM_CLASS:  // 29
+                    {
+                        out << "|cffff0000That item is not a valid target.";
+                        break;
+                    }
+                    case SPELL_FAILED_NEED_MORE_ITEMS:  // 55
+                    {
+                        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!spellInfo)
+                            return;
+
+                        ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(m_itemTarget);
+                        if (!pProto)
+                            return;
+
+                        out << "|cffff0000Requires 5 " << pProto->Name1 << ".";
+                        m_itemTarget = 0;
+                        break;
+                    }
+                    case SPELL_FAILED_REAGENTS:
+                    {
+                        out << "|cffff0000I don't have the reagents";
+                        break;
+                    }
+                    default:
+                        //sLog->outDebug(LOG_FILTER_NONE, "[%s] SMSG_CAST_FAIL: unknown (%u)", m_bot->GetName(), result);
+                        return;
+                }
+            }
+            TellMaster(out.str().c_str());
+            return;
+        }
+
+        case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            uint8 castCount;
+            uint32 spellId;
+            uint64 casterGuid;
+
+            //packetfix
+            p >> casterGuid;
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            p >> castCount >> spellId;
+            if (m_CurrentlyCastingSpellId == spellId)
+            {
+                m_ignoreAIUpdatesUntilTime = time(NULL);
+                m_CurrentlyCastingSpellId = 0;
+            }
+            return;
+        }
+
+        // if a change in speed was detected for the master
+        // make sure we have the same mount status
+        //case SMSG_FORCE_RUN_SPEED_CHANGE:
+        //{
+        //    WorldPacket p(packet);
+        //    uint64 guid;
+        //    //guid = extractGuid(p);
+
+        //    p >> guid;
+
+        //    if (guid != m_master->GetGUID())
+        //        return;
+        //    if (m_master->IsMounted() && !m_bot->IsMounted())
+        //    {
+        //        //Player Part
+        //        Unit::AuraEffectList const& AuraList = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        //        if (!AuraList.empty())
+        //        {
+        //            int32 master_speed1 = AuraList.front()->GetSpellInfo()->Effects[0].BasePoints;
+        //            int32 master_speed2 = AuraList.front()->GetSpellInfo()->Effects[1].BasePoints;
+        //            int32 master_speed3 = AuraList.front()->GetSpellInfo()->Effects[2].BasePoints;
+
+        //            //Bot Part
+        //            uint32 spellMount = 0;
+        //            for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+        //            {
+        //                if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+        //                    continue;
+        //                uint32 spellId = itr->first;
+        //                SpellInfo const *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        //                if (!pSpellInfo || pSpellInfo->IsPassive())
+        //                    continue;
+
+        //                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        //                {
+        //                    if (pSpellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOUNTED)
+        //                    {
+        //                        int32 points = pSpellInfo->Effects[i].BasePoints;
+        //                        if (points == master_speed1 || 
+        //                            points == master_speed2 || 
+        //                            points == master_speed3)
+        //                        {
+        //                            spellMount = spellId;
+        //                            break;
+        //                        }
+        //                    }
+        //                }
+        //            }
+        //            if (spellMount)
+        //                m_bot->CastSpell(m_bot, spellMount, true);
+        //            else
+        //                SendWhisper("Cannot find approriate mount!", *m_master);
+        //        }
+        //    }
+        //    else if (!m_master->IsMounted() && m_bot->IsMounted())
+        //    {
+        //        WorldPacket emptyPacket;
+        //        m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+        //    }
+        //    return;
+        //}
+
+        // handle flying acknowledgement
+        //case SMSG_MOVE_SET_CAN_FLY:
+        //{
+        //    WorldPacket p(packet);
+        //    uint64 guid;
+        //    //packetfix
+        //    //guid = extractGuid(p);
+
+        //    p >> guid;
+        //    if (guid != m_bot->GetGUID())
+        //        return;
+        //    m_bot->m_movementInfo.AddMovementFlag(MOVEMENTFLAG_FLYING);
+        //    //m_bot->SetSpeed(MOVE_RUN, m_master->GetSpeed(MOVE_FLIGHT) +0.1f, true);
+        //    return;
+        //}
+
+        // handle dismount flying acknowledgement
+        //case SMSG_MOVE_UNSET_CAN_FLY:
+        //{
+        //    WorldPacket p(packet);
+        //    uint64 guid;
+        //    //packetfix
+        //    //guid = extractGuid(p);
+
+        //    p >> guid;
+        //    if (guid != m_bot->GetGUID())
+        //        return;
+        //    m_bot->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+        //    //m_bot->SetSpeed(MOVE_RUN,m_master->GetSpeedRate(MOVE_RUN),true);
+        //    return;
+        //}
+
+        // If the leader role was given to the bot automatically give it to the master
+        // if the master is in the group, otherwise leave group
+        case SMSG_GROUP_SET_LEADER:
+        {
+            WorldPacket p(packet);
+            std::string name;
+            p >> name;
+            if (m_bot->GetGroup() && name == m_bot->GetName())
+            {
+                if (m_bot->GetGroup()->IsMember(m_master->GetGUID()))
+                {
+                    p.resize(8);
+                    p << m_master->GetGUID();
+                    m_bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                }
+                else
+                {
+                    p.clear(); // not really needed
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p); // packet not used updated code
+                }
+            }
+            return;
+        }
+
+        // If the master leaves the group, then the bot leaves too
+        case SMSG_PARTY_COMMAND_RESULT:
+        {
+            WorldPacket p(packet);
+            uint32 operation;
+            p >> operation;
+            std::string member;
+            p >> member;
+            uint32 result;
+            p >> result;
+            p.clear();
+            if (operation == PARTY_OP_LEAVE)
+                if (member == m_master->GetName())
+                    m_bot->GetSession()->HandleGroupDisbandOpcode(p);  // packet not used updated code
+            return;
+        }
+
+        // Handle Group invites (auto accept if master is in group, otherwise decline & send message
+        case SMSG_GROUP_INVITE:
+        {
+            if (const Group* const grp = m_bot->GetGroupInvite())
+            {
+                Player* inviter = sObjectAccessor->FindPlayer(grp->GetLeaderGUID());
+                if (!inviter)
+                    return;
+
+                WorldPacket p;
+                if (!canObeyCommandFrom(*inviter))
+                {
+                    std::string buf = "I can't accept your invite unless you first invite my master ";
+                    buf += m_master->GetName();
+                    buf += ".";
+                    SendWhisper(buf, *inviter);
+                    m_bot->GetSession()->HandleGroupDeclineOpcode(p); // packet not used
+                }
+                else
+                    m_bot->GetSession()->HandleGroupAcceptOpcode(p);  // packet not used
+            }
+            return;
+        }
+
+        // Handle when another player opens the trade window with the bot
+        // also sends list of tradable items bot can trade if bot is allowed to obey commands from
+        case SMSG_TRADE_STATUS:
+        {
+            if (m_bot->GetTrader() == NULL)
+                break;
+
+            WorldPacket p(packet);
+            uint32 status;
+            p >> status;
+            p.resize(4);
+
+            //4 == TRADE_STATUS_TRADE_ACCEPT
+            if (status == 4)
+            {
+                m_bot->GetSession()->HandleAcceptTradeOpcode(p);  // packet not used
+                SetQuestNeedItems();
+            }
+
+            //1 == TRADE_STATUS_BEGIN_TRADE
+            else if (status == 1)
+            {
+                m_bot->GetSession()->HandleBeginTradeOpcode(p); // packet not used
+
+                if (!canObeyCommandFrom(*(m_bot->GetTrader())))
+                {
+                    // TODO: Really? What if I give a bot all my junk so it's inventory is full when a nice green/blue/purple comes along?
+                    SendWhisper("I'm not allowed to trade you any of my items, but you are free to give me money or items.", *(m_bot->GetTrader()));
+                    return;
+                }
+
+                // list out items available for trade
+                std::ostringstream out;
+                std::list<std::string> lsItemsTradable;
+                std::list<std::string> lsItemsUntradable;
+
+                // list out items in main backpack
+                for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+                {
+                    const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    if (pItem)
+                    {
+                        MakeItemLink(pItem, out, true);
+                        if (pItem->CanBeTraded())
+                            lsItemsTradable.push_back(out.str());
+                        else
+                            lsItemsUntradable.push_back(out.str());
+                        out.str("");
+                    }
+                }
+
+                // list out items in other removable backpacks
+                for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+                {
+                    const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                    if (pBag)
+                        // Very cool, but unnecessary
+                        //const ItemTemplate* const pBagProto = pBag->GetTemplate();
+                        //std::string bagName = pBagProto->Name1;
+                        //ItemLocalization(bagName, pBagProto->ItemId);
+
+                        for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                        {
+                            const Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                            if (pItem)
+                            {
+                                MakeItemLink(pItem, out, true);
+                                if (pItem->CanBeTraded())
+                                    lsItemsTradable.push_back(out.str());
+                                else
+                                    lsItemsUntradable.push_back(out.str());
+                                out.str("");
+                            }
+                        }
+                }
+
+                ChatHandler ch(m_bot->GetTrader());
+                out.str("");
+                out << "Items I have but cannot trade:";
+                uint32 count = 0;
+                for (std::list<std::string>::iterator iter = lsItemsUntradable.begin(); iter != lsItemsUntradable.end(); iter++)
+                {
+                    out << (*iter);
+                    // Why this roundabout way of posting max 20 items per whisper? To keep the list scrollable.
+                    count++;
+                    if (count % 20 == 0)
+                    {
+                        ch.SendSysMessage(out.str().c_str());
+                        out.str("");
+                    }
+                }
+                if (count > 0)
+                    ch.SendSysMessage(out.str().c_str());
+
+                out.str("");
+                out << "I could give you:";
+                count = 0;
+                for (std::list<std::string>::iterator iter = lsItemsTradable.begin(); iter != lsItemsTradable.end(); iter++)
+                {
+                    out << (*iter);
+                    // Why this roundabout way of posting max 20 items per whisper? To keep the list scrollable.
+                    count++;
+                    if (count % 20 == 0)
+                    {
+                        ch.SendSysMessage(out.str().c_str());
+                        out.str("");
+                    }
+                }
+                if (count > 0)
+                    ch.SendSysMessage(out.str().c_str());
+                else
+                    ch.SendSysMessage("I have nothing to give you.");
+
+                // calculate how much money bot has
+                // send bot the message
+                uint32 copper = m_bot->GetMoney();
+                out.str("");
+                out << "I have |cff00ff00" << Cash(copper) << "|r";
+                SendWhisper(out.str().c_str(), *(m_bot->GetTrader()));
+            }
+            return;
+        }
+
+        case SMSG_SPELL_START:
+        {
+            WorldPacket p(packet);
+
+            //packetfix
+            uint64 castItemGuid;
+            uint64 casterGuid;
+            p >> castItemGuid;
+            p >> casterGuid;
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            p >> castCount;
+            uint32 spellId;
+            p >> spellId;
+            uint32 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                return;
+
+            if (pSpellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_NOT_SEATED)
+                return;
+
+            m_ignoreAIUpdatesUntilTime = time(NULL) + (msTime / 1000) + 1;
+
+            return;
+        }
+
+        case SMSG_SPELL_GO:
+        {
+            WorldPacket p(packet);
+
+            //packetfix
+            uint64 castItemGuid;
+            uint64 casterGuid;
+            p >> castItemGuid;
+            p >> casterGuid;
+            if (casterGuid != m_bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            p >> castCount;
+            uint32 spellId;
+            p >> spellId;
+            uint32 castFlags;
+            p >> castFlags;
+            uint32 msTime;
+            p >> msTime;
+
+            return;
+        }
+
+        // if someone tries to resurrect, then accept
+        case SMSG_RESURRECT_REQUEST:
+        {
+            if (!m_bot->isAlive())
+            {
+                WorldPacket p(packet);
+                uint64 guid;
+                p >> guid;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8 + 1);
+                *packet << guid;
+                *packet << uint8(1);                        // accept
+                m_bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+                // set back to normal
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            return;
+        }
+
+        case SMSG_LOOT_RESPONSE:
+        {
+            WorldPacket p(packet); // (8+1+4+1+1+4+4+4+4+4+1)
+            uint64 guid;
+            uint8 loot_type;
+            uint32 gold;
+            uint8 items;
+
+            p >> guid;      // 8 corpse guid
+            p >> loot_type; // 1 loot type
+            p >> gold;      // 4 money on corpse
+            p >> items;     // 1 number of items on corpse
+
+            if (gold > 0)
+            {
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+                m_bot->GetSession()->QueuePacket(packet);
+            }
+
+            for (uint8 i = 0; i < items; ++i)
+            {
+                uint32 itemid;
+                uint32 itemcount;
+                uint8 lootslot_type;
+                uint8 itemindex;
+
+                p >> itemindex;         // 1 counter
+                p >> itemid;            // 4 itemid
+                p >> itemcount;         // 4 item stack count
+                p.read_skip<uint32>();  // 4 item model
+                p.read_skip<uint32>();  // 4 randomSuffix
+                p.read_skip<uint32>();  // 4 randomPropertyId
+                p >> lootslot_type;     // 1 LootSlotType
+
+                if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+                    continue;
+
+                // skinning or collect loot flag = just auto loot everything for getting object
+                // corpse = run checks
+                if (loot_type == LOOT_SKINNING || HasCollectFlag(COLLECT_FLAG_LOOT) ||
+                    (loot_type == LOOT_CORPSE && (IsInQuestItemList(itemid) || IsItemUseful(itemid))))
+                {
+                    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+                    *packet << itemindex;
+                    m_bot->GetSession()->QueuePacket(packet);
+                }
+            }
+
+            // release loot
+            WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+            *packet << guid;
+            m_bot->GetSession()->QueuePacket(packet);
+
+            return;
+        }
+
+        case SMSG_LOOT_RELEASE_RESPONSE:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+
+            p >> guid;
+
+            if (guid == m_lootCurrent)
+            {
+                Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+
+                if (c && c->GetCreatureTemplate()->SkinLootId && c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE)/*!c->lootForSkin*/)
+                {
+                    uint32 reqSkill = c->GetCreatureTemplate()->GetRequiredLootSkill();
+                    // check if it is a leather skin and if it is to be collected (could be ore or herb)
+                    if (m_bot->HasSkill(reqSkill) && ((reqSkill != SKILL_SKINNING) ||
+                        (HasCollectFlag(COLLECT_FLAG_SKIN) && reqSkill == SKILL_SKINNING)))
+                    {
+                        // calculate skill requirement
+                        uint32 skillValue = m_bot->GetPureSkillValue(reqSkill);
+                        uint32 targetLevel = c->getLevel();
+                        uint32 reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                        if (skillValue >= reqSkillValue)
+                        {
+                            if (m_lootCurrent != m_lootPrev)    // if this wasn't previous loot try again
+                            {
+                                m_lootPrev = m_lootCurrent;
+                                SetIgnoreUpdateTime(0);
+                                return; // so that the DoLoot function is called again to get skin
+                            }
+                        }
+                        else
+                            TellMaster("My skill is %u but it requires %u", skillValue, reqSkillValue);
+                    }
+                }
+
+                // if previous is current, clear
+                if (m_lootPrev == m_lootCurrent)
+                    m_lootPrev = 0;
+                // clear current target
+                m_lootCurrent = 0;
+                // clear movement
+                m_bot->GetMotionMaster()->Clear();
+                m_bot->GetMotionMaster()->MoveIdle();
+                SetIgnoreUpdateTime(0);
+            }
+
+            return;
+        }
+
+        case SMSG_BUY_ITEM:
+        {
+            WorldPacket p(packet);  // (8+4+4+4
+            uint64 vguid;
+            p >> vguid;
+            uint32 vendorslot;
+            p >> vendorslot;
+            p.resize(20);
+
+            vendorslot = vendorslot - 1;
+            Creature *pCreature = m_bot->GetNPCIfCanInteractWith(vguid, UNIT_NPC_FLAG_VENDOR);
+            if (!pCreature)
+                return;
+
+            VendorItemData const* vItems = pCreature->GetVendorItems();
+            if (!vItems || vItems->Empty())
+                return;
+
+            uint32 vCount = vItems ? vItems->GetItemCount() : 0;
+
+            if (vendorslot >= vCount)
+                return;
+
+            VendorItem const* crItem = vendorslot < vCount ? vItems->GetItem(vendorslot) : NULL;
+            if (!crItem)
+                return;
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(crItem->item);
+            if (pProto)
+            {
+                std::ostringstream out;
+                out << "|cff009900" << "I received item: |r";
+                MakeItemLink(pProto, out);
+                TellMaster(out.str().c_str());
+            }
+            return;
+        }
+
+        case SMSG_ITEM_PUSH_RESULT:
+        {
+            WorldPacket p(packet);  // (8+4+4+4+1+4+4+4+4+4+4)
+            uint64 guid;
+
+            p >> guid;              // 8 player guid
+            if (m_bot->GetGUID() != guid)
+                return;
+
+            uint8 bagslot;
+            uint32 itemslot, itemid, count, totalcount, received, created;
+
+            p >> received;          // 4 0=looted, 1=from npc
+            p >> created;           // 4 0=received, 1=created
+            p.read_skip<uint32>();  // 4 IsShowChatMessage
+            p >> bagslot;           // 1 bagslot
+            p >> itemslot;          // 4 item slot, but when added to stack: 0xFFFFFFFF
+            p >> itemid;            // 4 item entry id
+            p.read_skip<uint32>();  // 4 SuffixFactor
+            p.read_skip<uint32>();  // 4 random item property id
+            p >> count;             // 4 count of items
+            p >> totalcount;        // 4 count of items in inventory
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+            if (pProto)
+            {
+                std::ostringstream out;
+                if (received == 1)
+                {
+                    if (created == 1)
+                        out << "|cff009900" << "I created: |r";
+                    else
+                        out << "|cff009900" << "I received: |r";
+                    MakeItemLink(pProto, out);
+                    TellMaster(out.str().c_str());
+                    Player* const bot = GetPlayerBot();
+                    AutoUpgradeEquipment(*bot);
+                }
+            }
+
+            if (IsInQuestItemList(itemid))
+            {
+                m_needItemList[itemid] = (m_needItemList[itemid] - count);
+                if (m_needItemList[itemid] <= 0)
+                    m_needItemList.erase(itemid);
+            }
+
+            return;
+        }
+
+            /* uncomment this and your bots will tell you all their outgoing packet opcode names
+               case SMSG_MONSTER_MOVE:
+               case SMSG_UPDATE_WORLD_STATE:
+               case SMSG_COMPRESSED_UPDATE_OBJECT:
+               case MSG_MOVE_SET_FACING:
+               case MSG_MOVE_STOP:
+               case MSG_MOVE_HEARTBEAT:
+               case MSG_MOVE_STOP_STRAFE:
+               case MSG_MOVE_START_STRAFE_LEFT:
+               case SMSG_UPDATE_OBJECT:
+               case MSG_MOVE_START_FORWARD:
+               case MSG_MOVE_START_STRAFE_RIGHT:
+               case SMSG_DESTROY_OBJECT:
+               case MSG_MOVE_START_BACKWARD:
+               case SMSG_AURA_UPDATE_ALL:
+               case MSG_MOVE_FALL_LAND:
+               case MSG_MOVE_JUMP:
+                return;
+
+               default:
+               {
+                const char* oc = LookupOpcodeName(packet.GetOpcode());
+
+                std::ostringstream out;
+                out << "botout: " << oc;
+                //sLog->outError(out.str().c_str());
+
+                //TellMaster(oc);
+               }
+             */
+    }
+}
+
+uint8 PlayerbotAI::GetHealthPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetHealth()) / target.GetMaxHealth()) * 100;
+}
+
+uint8 PlayerbotAI::GetHealthPercent() const
+{
+    return GetHealthPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetManaPercent(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetMaxPower(POWER_MANA)) * 100;
+}
+
+uint8 PlayerbotAI::GetManaPercent() const
+{
+    return GetManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent(const Unit& target) const
+{
+    if (target.GetPower(POWER_MANA) >= target.GetCreateMana())
+        return (100);
+    else
+        return (static_cast<float> (target.GetPower(POWER_MANA)) / target.GetCreateMana()) * 100;
+}
+
+uint8 PlayerbotAI::GetBaseManaPercent() const
+{
+    return GetBaseManaPercent(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRageAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_RAGE)));
+}
+
+uint8 PlayerbotAI::GetRageAmount() const
+{
+    return GetRageAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetEnergyAmount(const Unit& target) const
+{
+    return (static_cast<float> (target.GetPower(POWER_ENERGY)));
+}
+
+uint8 PlayerbotAI::GetEnergyAmount() const
+{
+    return GetEnergyAmount(*m_bot);
+}
+
+uint8 PlayerbotAI::GetRunicPower(const Unit& target) const
+{
+    return (static_cast<float>(target.GetPower(POWER_RUNIC_POWER)));
+}
+
+uint8 PlayerbotAI::GetRunicPower() const
+{
+    return GetRunicPower(*m_bot);
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit& player) const
+{
+    if (spellId <= 0)
+        return false;
+    return player.HasAura(spellId);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName) const
+{
+    return HasAura(spellName, *m_bot);
+}
+
+bool PlayerbotAI::HasAura(const char* spellName, const Unit& player) const
+{
+    uint32 spellId = getSpellId(spellName);
+    return (spellId) ? HasAura(spellId, player) : false;
+}
+
+Item* PlayerbotAI::FindFood() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+            {
+                //TellMaster("Found Consumable %s in backpack, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, slot);
+                for (uint8 i = 0; i != 5; ++i)
+                {
+                    if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_FOOD)
+                    {
+                        //TellMaster("It's a food! (spell: %u)", i);
+                        return pItem;
+                    }
+                }
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+                    {
+                        //TellMaster("Found Consumable %s in bag %u, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, bag, slot);
+                        for (uint8 i = 0; i != 5; ++i)
+                        {
+                            if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_FOOD)
+                            {
+                                //TellMaster("It's a food! (spell: %u)", i);
+                                return pItem;
+                            }
+                        }
+                    }
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindDrink() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+            {
+                //TellMaster("Found Consumable %s in backpack, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, slot);
+                for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+                {
+                    if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_DRINK)
+                    {
+                        //TellMaster("It's a drink! (spell: %u)", i);
+                        return pItem;
+                    }
+                }
+            }
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_FOOD)
+                    {
+                        //TellMaster("Found Consumable %s in bag %u, slot %u", !pItemProto->Name1.empty() ? pItemProto->Name1.c_str() : NULL, bag, slot);
+                        for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+                        {
+                            if (pItemProto->Spells[i].SpellCategory == SPELL_CATEGORY_DRINK)
+                            {
+                                //TellMaster("It's a drink! (spell: %u)", i);
+                                return pItem;
+                            }
+                        }
+                    }
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBandage() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_BANDAGE)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+//Find Poison ...Natsukawa
+Item* PlayerbotAI::FindPoison() const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindConsumable(uint32 displayId) const
+{
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+            if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                continue;
+
+            if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->DisplayInfoID == displayId)
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+
+                    if (!pItemProto || m_bot->CanUseItem(pItemProto) != EQUIP_ERR_OK)
+                        continue;
+
+                    if (pItemProto->Class == ITEM_CLASS_CONSUMABLE && pItemProto->DisplayInfoID == displayId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+void PlayerbotAI::InterruptCurrentCastingSpell()
+{
+    //TellMaster("I'm interrupting my current spell!");
+    WorldPacket* const packet = new WorldPacket(CMSG_CANCEL_CAST, 5);  //changed from thetourist suggestion
+    *packet << m_CurrentlyCastingSpellId;
+    *packet << m_targetGuidCommand;   //changed from thetourist suggestion
+    m_CurrentlyCastingSpellId = 0;
+    m_bot->GetSession()->QueuePacket(packet);
+}
+
+void PlayerbotAI::Feast()
+{
+    // stand up if we are done feasting
+    if (!(m_bot->GetHealth() < m_bot->GetMaxHealth() || (m_bot->getPowerType() == POWER_MANA && m_bot->GetPower(POWER_MANA) < m_bot->GetMaxPower(POWER_MANA))))
+    {
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+
+    // wait 3 seconds before checking if we need to drink more or eat more
+    time_t currentTime = time(NULL);
+    m_ignoreAIUpdatesUntilTime = currentTime + 3;
+
+    // should we drink another
+    if (m_bot->getPowerType() == POWER_MANA && currentTime > m_TimeDoneDrinking
+        && ((static_cast<float> (m_bot->GetPower(POWER_MANA)) / m_bot->GetMaxPower(POWER_MANA)) < 0.8))
+    {
+        Item* pItem = FindDrink();
+        if (pItem != NULL)
+        {
+            UseItem(pItem);
+            m_TimeDoneDrinking = currentTime + 30;
+            return;
+        }
+        TellMaster("I need water.");
+    }
+
+    // should we eat another
+    if (currentTime > m_TimeDoneEating && ((static_cast<float> (m_bot->GetHealth()) / m_bot->GetMaxHealth()) < 0.8))
+    {
+        Item* pItem = FindFood();
+        if (pItem != NULL)
+        {
+            //TellMaster("eating now...");
+            UseItem(pItem);
+            m_TimeDoneEating = currentTime + 30;
+            return;
+        }
+        TellMaster("I need food.");
+    }
+
+    // if we are no longer eating or drinking
+    // because we are out of items or we are above 80% in both stats
+    if (currentTime > m_TimeDoneEating && currentTime > m_TimeDoneDrinking)
+    {
+        TellMaster("done feasting!");
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+    }
+}
+
+// intelligently sets a reasonable combat order for this bot
+// based on its class / level / etc
+void PlayerbotAI::GetCombatTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        // m_lootCurrent = ObjectGuid(); This was clearing loot target, causing bots to leave corpses unlooted if interupted by combat. Needs testing.
+        // using this caused bot to remove current loot target, and add this new threat to the loot list.  Now it remembers the loot target and adds a new one.
+        // Bot will still clear the target if the master gets too far away from it.
+        m_targetCombat = 0;
+    }
+
+    // update attacker info now
+    UpdateAttackerInfo();
+
+    // check for attackers on protected unit, and make it a forcedTarget if any
+    if (!forcedTarget && (m_combatOrder & ORDERS_PROTECT) && m_targetProtect != 0)
+    {
+        Unit *newTarget = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_HIGHESTTHREAT), m_targetProtect);
+        if (newTarget && newTarget != m_targetCombat)
+        {
+            forcedTarget = newTarget;
+            m_targetType = TARGET_THREATEN;
+            if (m_confDebugWhisper)
+                TellMaster("Changing target to %s to protect %s", forcedTarget->GetName(), m_targetProtect->GetName());
+        }
+    }
+    else if (forcedTarget)
+    {
+        if (m_confDebugWhisper)
+            TellMaster("Changing target to %s by force!", forcedTarget->GetName());
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+    }
+
+    // we already have a target and we are not forced to change it
+    if (m_targetCombat && !forcedTarget)
+        return;
+
+    // are we forced on a target?
+    if (forcedTarget)
+    {
+        m_targetCombat = forcedTarget;
+        m_targetChanged = true;
+    }
+    // do we have to assist someone?
+    if (!m_targetCombat && (m_combatOrder & ORDERS_ASSIST) && m_targetAssist != 0)
+    {
+        m_targetCombat = FindAttacker((ATTACKERINFOTYPE) (AIT_VICTIMNOTSELF | AIT_LOWESTTHREAT), m_targetAssist);
+        if (m_confDebugWhisper && m_targetCombat)
+            TellMaster("Attacking %s to assist %s", m_targetCombat->GetName(), m_targetAssist->GetName());
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // are there any other attackers?
+    if (!m_targetCombat)
+    {
+        m_targetCombat = FindAttacker();
+        m_targetType = (m_combatOrder == ORDERS_TANK ? TARGET_THREATEN : TARGET_NORMAL);
+        m_targetChanged = true;
+    }
+    // no attacker found anyway
+    if (!m_targetCombat || !m_targetCombat->IsVisible() || !m_targetCombat->isTargetableForAttack())
+    {
+        m_targetType = TARGET_NORMAL;
+        m_targetChanged = false;
+        return;
+    }
+
+    // if thing to attack is in a duel, then ignore and don't call updateAI for 6 seconds
+    // this method never gets called when the bot is in a duel and this code
+    // prevents bot from helping
+    if (m_targetCombat->GetTypeId() == TYPEID_PLAYER && m_targetCombat->ToPlayer()->duel)
+    {
+        m_ignoreAIUpdatesUntilTime = time(NULL) + 6;
+        return;
+    }
+
+    m_bot->SetSelection(m_targetCombat->GetGUID());
+    m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    m_bot->Attack(m_targetCombat, true);
+    //temp
+    if (m_targetCombat->GetMapId() == m_bot->GetMapId())
+    {
+        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+        GetClassAI()->DoNextCombatManeuver(m_targetCombat);
+    }
+    m_targetCombatGUID = m_targetCombat->GetGUID();
+
+    // add thingToAttack to loot list
+    if (Creature *cre = m_targetCombat->ToCreature())
+        if (cre->GetCreatureTemplate()->lootid != 0)
+            m_lootTargets.push_back(m_targetCombat->GetGUID());
+
+    return;
+}
+
+void PlayerbotAI::GetDuelTarget(Unit* forcedTarget)
+{
+    // set combat state, and clear looting, etc...
+    if (m_botState != BOTSTATE_COMBAT)
+    {
+        SetState(BOTSTATE_COMBAT);
+        m_targetChanged = true;
+        m_targetCombat = forcedTarget;
+        m_targetType = TARGET_THREATEN;
+        m_combatStyle = COMBAT_MELEE;
+    }
+    m_bot->Attack(m_targetCombat, true);
+}
+
+void PlayerbotAI::DoNextCombatManeuver()
+{
+    if (m_combatOrder == ORDERS_PASSIVE)
+        return;
+
+    // check for new targets
+    if (m_ScenarioType == SCENARIO_DUEL)
+        GetDuelTarget(m_master);
+    else if (Unit *u = m_master->getVictim())
+        GetCombatTarget(u);
+    else
+        GetCombatTarget();
+
+    // check if we have a target - fixes crash reported by rrtn (kill hunter's pet bug)
+    // if current target for attacks doesn't make sense anymore
+    // clear our orders so we can get orders in next update
+    m_targetCombat = sObjectAccessor->FindUnit(m_targetCombatGUID);
+    if (!m_targetCombat || 
+        m_targetCombat->isDead() || 
+        !m_targetCombat->IsInWorld() || 
+        !m_targetCombat->IsVisible() || 
+        !m_targetCombat->isTargetableForAttack() || 
+        !m_bot->IsHostileTo(m_targetCombat) || 
+        !m_bot->IsInMap(m_targetCombat))
+    {
+        m_bot->AttackStop();
+        m_bot->SetSelection(0);
+        MovementReset();
+        m_bot->InterruptNonMeleeSpells(true);
+        m_targetCombat = 0;
+        m_targetChanged = false;
+        m_targetType = TARGET_NORMAL;
+        SetQuestNeedCreatures();
+        return;
+    }
+
+    // do opening moves, if we changed target
+    if (m_targetChanged)
+    {
+        if (m_classAI)
+            m_targetChanged = m_classAI->DoFirstCombatManeuver(m_targetCombat);
+        else
+            m_targetChanged = false;
+    }
+
+    // do normal combat movement
+    DoCombatMovement();
+
+    if (m_classAI && !m_targetChanged)
+        m_classAI->DoNextCombatManeuver(m_targetCombat);
+}
+
+void PlayerbotAI::DoCombatMovement()
+{
+    if (!m_targetCombat) return;
+
+    float targetDist = m_classAI->GetCombatDistance(m_targetCombat);
+    //float radius = m_targetCombat->GetFloatValue(UNIT_FIELD_COMBATREACH)/* + m_bot->GetFloatValue(UNIT_FIELD_COMBATREACH)*/;
+    //float dx = m_bot->GetPositionX() - m_targetCombat->GetPositionX();
+    //float dy = m_bot->GetPositionY() - m_targetCombat->GetPositionY();
+    //float dz = m_bot->GetPositionZ() - m_targetCombat->GetPositionZ();
+    //float targetDist = sqrt((dx*dx) + (dy*dy) + (dz*dz)) - radius;
+    targetDist > 0 ? targetDist : 0;
+
+    m_bot->SetFacingTo(m_bot->GetAngle(m_targetCombat));
+
+    if (m_combatStyle == COMBAT_MELEE && !m_bot->HasUnitState(UNIT_STATE_CHASE) && ((m_movementOrder == MOVEMENT_STAY && targetDist < ATTACK_DISTANCE) || (m_movementOrder != MOVEMENT_STAY)))
+        // melee combat - chase target if in range or if we are not forced to stay
+        m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+    else if (m_combatStyle == COMBAT_RANGED && m_movementOrder != MOVEMENT_STAY)
+    {
+        // ranged combat - just move within spell range
+        // TODO: just follow in spell range! how to determine bots spell range?
+        if (targetDist > 20.0f)
+            m_bot->GetMotionMaster()->MoveChase(m_targetCombat);
+        else
+            MovementClear();
+    }
+}
+
+void PlayerbotAI::SetQuestNeedCreatures()
+{
+    // reset values first
+    m_needCreatureOrGOList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.Status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // All creature/GO slain/casted (not required, but otherwise it will display "Creature slain 0/10")
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->RequiredNpcOrGoCount[i] || (qInfo->RequiredNpcOrGoCount[i] - qData.CreatureOrGOCount[i]) <= 0)
+                continue;
+            m_needCreatureOrGOList[qInfo->RequiredNpcOrGo[i]] = (qInfo->RequiredNpcOrGoCount[i] - qData.CreatureOrGOCount[i]);
+        }
+    }
+}
+
+void PlayerbotAI::SetQuestNeedItems()
+{
+    // reset values first
+    m_needItemList.clear();
+
+    // run through accepted quests, get quest info and data
+    for (int qs = 0; qs < MAX_QUEST_LOG_SIZE; ++qs)
+    {
+        uint32 questid = m_bot->GetQuestSlotQuestId(qs);
+        if (questid == 0)
+            continue;
+
+        QuestStatusData &qData = m_bot->getQuestStatusMap()[questid];
+        // only check quest if it is incomplete
+        if (qData.Status != QUEST_STATUS_INCOMPLETE)
+            continue;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (!qInfo)
+            continue;
+
+        // check for items we not have enough of
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+        {
+            if (!qInfo->RequiredItemCount[i] || (qInfo->RequiredItemCount[i] - qData.ItemCount[i]) <= 0)
+                continue;
+            m_needItemList[qInfo->RequiredItemId[i]] = (qInfo->RequiredItemCount[i] - qData.ItemCount[i]);
+
+            // collect flags not set to gather quest objects skip remaining section
+            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && !HasCollectFlag(COLLECT_FLAG_QUEST))
+                continue;
+
+            // TODO: find faster way to handle this look up instead of using SQL lookup for each item
+            QueryResult result;
+            // determine if GOs are needed
+            result = WorldDatabase.PQuery("SELECT entry FROM gameobject_template WHERE questItem1='%u' "
+                "OR questItem2='%u' OR questItem3='%u' OR questItem4='%u' OR questItem5='%u' OR questItem6='%u'",
+                qInfo->RequiredItemId[i], qInfo->RequiredItemId[i], qInfo->RequiredItemId[i], qInfo->RequiredItemId[i],
+                qInfo->RequiredItemId[i], qInfo->RequiredItemId[i]);
+
+            if (result)
+            {
+                do
+                {
+                    Field *fields = result->Fetch();
+                    uint32 entry = fields[0].GetUInt32();
+
+                    GameObjectTemplate const * gInfo = sObjectMgr->GetGameObjectTemplate(entry);
+                    if (!gInfo)
+                        continue;
+
+                    // add this GO to our collection list if is chest/ore/herb
+                    if (gInfo->type == GAMEOBJECT_TYPE_CHEST)
+                    {
+                        m_collectObjects.push_back(entry);
+                        m_collectObjects.sort();
+                        m_collectObjects.unique();
+                    }
+                } while (result->NextRow());
+
+                ////delete result;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::SetState(BotState state)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: SetState - %s switch state %d to %d", m_bot->GetName(), m_botState, state );
+    m_botState = state;
+}
+
+uint8 PlayerbotAI::GetFreeBagSpace() const
+{
+    uint8 space = 0;
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (!pItem)
+            ++space;
+    }
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        Bag* pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pBag && pBag->GetTemplate()->BagFamily == BAG_FAMILY_MASK_NONE)
+            space += pBag->GetFreeSlots();
+    }
+    return space;
+}
+
+void PlayerbotAI::DoFlight()
+{
+    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoFlight - %s : %u", m_bot->GetName(), m_taxiMaster);
+
+    Creature *npc = m_bot->GetNPCIfCanInteractWith(m_taxiMaster, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!npc)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoFlight - %u not found or you can't interact with it.");
+        return;
+    }
+
+    m_bot->ActivateTaxiPathTo(m_taxiNodes, npc);
+}
+
+void PlayerbotAI::DoLoot()
+{
+    // clear BOTSTATE_LOOTING if no more loot targets
+    if (!m_lootCurrent && m_lootTargets.empty())
+    {
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoLoot - %s is going back to idle", m_bot->GetName() );
+        SetState(BOTSTATE_NORMAL);
+        m_bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
+        m_inventory_full = false;
+        return;
+    }
+
+    // set first in list to current
+    if (!m_lootCurrent)
+    {
+        m_lootCurrent = m_lootTargets.front();
+        m_lootTargets.pop_front();
+    }
+
+    WorldObject *wo = //sObjectAccessor->GetObjectInMap(m_lootCurrent, m_bot->GetMap(), (WorldObject*)NULL);
+    (WorldObject*)sObjectAccessor->GetObjectByTypeMask(*m_bot, m_lootCurrent, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+
+    // clear invalid object or object that is too far from master
+    if (!wo || m_master->GetDistance(wo) > float(m_confCollectDistanceMax))
+    {
+        m_lootCurrent = 0;
+        return;
+    }
+
+    Creature *c = m_bot->GetMap()->GetCreature(m_lootCurrent);
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+
+    // clear creature or object that is not spawned or if not creature or object
+    if ((c && !m_bot->canSeeOrDetect(c)) || (go && !go->isSpawned()) || (!c && !go))
+    {
+        m_lootCurrent = 0;
+        return;
+    }
+
+    uint32 skillId = 0;
+
+    if (c)
+    {
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureTemplate()->GetRequiredLootSkill();
+
+        // not a lootable creature, clear it
+        if (!c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) &&
+            (!c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) ||
+             (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && !m_bot->HasSkill(skillId))))
+        {
+            m_lootCurrent = 0;
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+            return;
+        }
+    }
+
+    if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectSize())
+    {
+        float x, y, z;
+        wo->GetContactPoint(m_bot, x, y, z, 0.1f);
+        m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z);
+        // give time to move to point before trying again
+        SetIgnoreUpdateTime(1);
+    }
+
+    if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+    {
+        uint32 reqSkillValue = 0;
+        uint32 SkillValue = 0;
+        bool keyFailed = false;
+        bool skillFailed = false;
+        bool forceFailed = false;
+
+        if (c)  // creature
+        {
+            if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            {
+                // loot the creature
+                WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+                *packet << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packet);
+                return; // no further processing is needed
+                // m_lootCurrent is reset in SMSG_LOOT_RELEASE_RESPONSE after checking for skinloot
+            }
+            else if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+                // not all creature skins are leather, some are ore or herb
+                if (m_bot->HasSkill(skillId) && ((skillId != SKILL_SKINNING) ||
+                    (HasCollectFlag(COLLECT_FLAG_SKIN) && skillId == SKILL_SKINNING)))
+                {
+                    // calculate skinning skill requirement
+                    uint32 targetLevel = c->getLevel();
+                    reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+                }
+
+            // creatures cannot be unlocked or forced open
+            keyFailed = true;
+            forceFailed = true;
+        }
+
+        if (go) // object
+        {
+            // add this GO to our collection list if active and is chest/ore/herb
+            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
+            {
+                m_collectObjects.push_back(go->GetEntry());
+                m_collectObjects.sort();
+                m_collectObjects.unique();
+            }
+
+            uint32 reqItem = 0;
+
+            // check skill or lock on object
+            uint32 lockId = go->GetGOInfo()->GetLockId();
+            LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+            if (lockInfo)
+                for (int i = 0; i < 8; ++i)
+                {
+                    if (lockInfo->Type[i] == LOCK_KEY_ITEM)
+                    {
+                        if (lockInfo->Index[i] > 0)
+                        {
+                            reqItem = lockInfo->Index[i];
+                            if (m_bot->HasItemCount(reqItem, 1))
+                                break;
+                            continue;
+                        }
+                    }
+                    else if (lockInfo->Type[i] == LOCK_KEY_SKILL)
+                    {
+                        switch (LockType(lockInfo->Index[i]))
+                        {
+                            case LOCKTYPE_OPEN:
+                                if (CastSpell(3365))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_CLOSE:
+                                if (CastSpell(6233))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_OPEN:
+                                if (CastSpell(6247))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_QUICK_CLOSE:
+                                if (CastSpell(6247))    // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_TINKERING:
+                                if (CastSpell(6477))    // Opening
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_KNEELING:
+                                if (CastSpell(6478))    // Opening; listed with 17667 and 22810
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_ATTACKING:
+                                if (CastSpell(8386))    // Attacking
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_OPEN:
+                                if (CastSpell(21651))   // Opening; also had 26868
+                                    return;
+                                break;
+                            case LOCKTYPE_SLOW_CLOSE:
+                                if (CastSpell(21652))   // Closing
+                                    return;
+                                break;
+                            case LOCKTYPE_OPEN_FROM_VEHICLE:
+                                if (CastSpell(61437))   // Opening
+                                    return;
+                                break;
+                            default:
+                                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                                {
+                                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                                    reqSkillValue = lockInfo->Skill[i];
+                                }
+                        }
+                    }
+                }
+
+            // use key on object if available
+            if (reqItem > 0 && m_bot->HasItemCount(reqItem, 1))
+            {
+                UseItem(m_bot->GetItemByEntry(reqItem), TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                m_lootCurrent = 0;
+                return;
+            }
+            else
+                keyFailed = true;
+        }
+
+        // determine bot's skill value for object's required skill
+        if (skillId != SKILL_NONE)
+            SkillValue = uint32(m_bot->GetSkillValue(skillId));
+
+        // bot has the specific skill or object requires no skill at all
+        if ((m_bot->HasSkill(skillId) && skillId != SKILL_NONE) || (skillId == SKILL_NONE && go))
+        {
+            if (SkillValue >= reqSkillValue)
+            {
+                switch (skillId)
+                {
+                    case SKILL_MINING:
+                        if (HasTool(TC_MINING_PICK) && CastSpell(MINING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_HERBALISM:
+                        if (CastSpell(HERB_GATHERING))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_SKINNING:
+                        if (c && HasCollectFlag(COLLECT_FLAG_SKIN) &&
+                            HasTool(TC_SKINNING_KNIFE) && CastSpell(SKINNING, *c))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_LOCKPICKING:
+                        if (CastSpell(PICK_LOCK_1))
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    case SKILL_NONE:
+                        if (CastSpell(3365)) //Spell 3365 = Opening?
+                            return;
+                        else
+                            skillFailed = true;
+                        break;
+                    default:
+                        TellMaster("I'm not sure how to get that.");
+                        skillFailed = true;
+                        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]:DoLoot Skill %u is not implemented", skillId);
+                        break;
+                }
+            }
+            else
+            {
+                TellMaster("My skill is not high enough. It requires %u, but mine is %u.",
+                           reqSkillValue, SkillValue);
+                skillFailed = true;
+            }
+        }
+        else
+        {
+            TellMaster("I do not have the required skill.");
+            skillFailed = true;
+        }
+
+        if (go) // only go's can be forced
+        {
+            // if pickable, check if a forcible item is available for the bot
+            if (skillId == SKILL_LOCKPICKING && 
+                (m_bot->HasSkill(SKILL_BLACKSMITHING) || m_bot->HasSkill(SKILL_ENGINEERING)))
+            {
+                // check for skeleton keys appropriate for lock value
+                if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+                {
+                    Item *kItem = FindKeyForLockValue(reqSkillValue);
+                    if (kItem)
+                    {
+                        TellMaster("I have a skeleton key that can open it!");
+                        UseItem(kItem, TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have no skeleton keys that can open that lock.");
+                        forceFailed = true;
+                    }
+                }
+
+                // check for a charge that can blast it open
+                if (m_bot->HasSkill(SKILL_ENGINEERING))
+                {
+                    Item *bItem = FindBombForLockValue(reqSkillValue);
+                    if (bItem)
+                    {
+                        TellMaster("I can blast it open!");
+                        UseItem(bItem, TARGET_FLAG_GAMEOBJECT, m_lootCurrent);
+                        return;
+                    }
+                    else
+                    {
+                        TellMaster("I have nothing to blast it open with.");
+                        forceFailed = true;
+                    }
+                }
+            }
+            else
+                forceFailed = true;
+        }
+
+        // if all attempts failed in some way then clear because it won't get SMSG_LOOT_RESPONSE
+        if (keyFailed && skillFailed && forceFailed)
+        {
+            //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoLoot attempts failed on [%s]", go ? go->GetGOInfo()->name : c->GetCreatureTemplate()->Name);
+            m_lootCurrent = 0;
+
+            // remove this GO from our list using the same settings that it was added with earlier
+            if (go && HasCollectFlag(COLLECT_FLAG_NEAROBJECT) && go->GetGoType() == GAMEOBJECT_TYPE_CHEST)
+                m_collectObjects.remove(go->GetEntry());
+
+            // clear movement target, take next target on next update
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+void PlayerbotAI::AcceptQuest(Quest const *qInfo, Player *pGiver)
+{
+    if (!qInfo || !pGiver)
+        return;
+
+    uint32 quest = qInfo->GetQuestId();
+
+    if (!pGiver->CanShareQuest(qInfo->GetQuestId()))
+    {
+        // giver can't share quest
+        m_bot->SetDivider(0);
+        return;
+    }
+
+    if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        // can't take quest
+        m_bot->SetDivider(0);
+        return;
+    }
+
+    if (m_bot->GetDivider())
+    {
+        // send msg to quest giving player
+        pGiver->SendPushToPartyResponse(m_bot, QUEST_PARTY_MSG_ACCEPT_QUEST);
+        m_bot->SetDivider(0);
+    }
+
+    if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, pGiver);
+
+        if (m_bot->CanCompleteQuest(quest))
+            m_bot->CompleteQuest(quest);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if (qInfo->GetSrcSpell() > 0)
+            m_bot->CastSpell(m_bot, qInfo->GetSrcSpell(), true);
+    }
+}
+
+void PlayerbotAI::TurnInQuests(WorldObject *questgiver)
+{
+    uint64 giverGUID = questgiver->GetGUID();
+
+    if (!m_bot->IsInMap(questgiver))
+        TellMaster("hey you are turning in quests without me!");
+    else
+    {
+        m_bot->SetSelection(giverGUID);
+
+        // auto complete every completed quest this NPC has
+        m_bot->PrepareQuestMenu(giverGUID);
+        QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+        for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+        {
+            QuestMenuItem const& qItem = questMenu.GetItem(iI);
+            uint32 questID = qItem.QuestId;
+            Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+            std::ostringstream out;
+            std::string questTitle  = pQuest->GetTitle();
+            QuestLocalization(questTitle, questID);
+
+            QuestStatus status = m_bot->GetQuestStatus(questID);
+
+            // if quest is complete, turn it in
+            if (status == QUEST_STATUS_COMPLETE)
+            {
+                // if bot hasn't already turned quest in
+                if (!m_bot->GetQuestRewardStatus(questID))
+                {
+                    // auto reward quest if no choice in reward
+                    if (pQuest->GetRewChoiceItemsCount() == 0)
+                    {
+                        if (m_bot->CanRewardQuest(pQuest, false))
+                        {
+                            m_bot->RewardQuest(pQuest, 0, questgiver, false);
+                            out << "Quest complete: |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                    }
+
+                    // auto reward quest if one item as reward
+                    else if (pQuest->GetRewChoiceItemsCount() == 1)
+                    {
+                        int rewardIdx = 0;
+                        ItemTemplate const *pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        std::string itemName = pRewardItem->Name1;
+                        ItemLocalization(itemName, pRewardItem->ItemId);
+                        if (m_bot->CanRewardQuest(pQuest, rewardIdx, false))
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, questgiver, true);
+
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            out << "Quest complete: "
+                                << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                                << "|h[" << questTitle << "]|h|r reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                        else
+                            out << "|cffff0000Unable to turn quest in:|r "
+                                << "|cff808080|Hquest:" << questID << ':'
+                                << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r"
+                                << " reward: |cffffffff|Hitem:"
+                                << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                    }
+
+                    // else multiple rewards - let master pick
+                    else
+                    {
+                        out << "What reward should I take for |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel()
+                            << "|h[" << questTitle << "]|h|r? ";
+                        for (uint8 i = 0; i < pQuest->GetRewChoiceItemsCount(); ++i)
+                        {
+                            ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[i]);
+                            std::string itemName = pRewardItem->Name1;
+                            ItemLocalization(itemName, pRewardItem->ItemId);
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r";
+                        }
+                    }
+                }
+            }
+
+            else if (status == QUEST_STATUS_INCOMPLETE)
+                out << "|cffff0000Quest incomplete:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            else if (status == QUEST_STATUS_NONE && m_bot->CanTakeQuest(pQuest, false))
+                out << "|cff00ff00Quest available:|r "
+                    << " |cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+            if (!out.str().empty())
+                TellMaster(out.str());
+        }
+        AutoUpgradeEquipment(*m_bot);
+    }
+}
+
+bool PlayerbotAI::IsInCombat()
+{
+    Pet *pet;
+    bool inCombat = false;
+    inCombat |= m_bot->isInCombat();
+    pet = m_bot->GetPet();
+    if (pet)
+        inCombat |= pet->isInCombat();
+    inCombat |= m_master->isInCombat();
+    if (m_bot->GetGroup())
+    {
+        GroupReference *ref = m_bot->GetGroup()->GetFirstMember();
+        while (ref)
+        {
+            inCombat |= ref->getSource()->isInCombat();
+            pet = ref->getSource()->GetPet();
+            if (pet)
+                inCombat |= pet->isInCombat();
+            ref = ref->next();
+        }
+    }
+    return inCombat;
+}
+
+void PlayerbotAI::UpdateAttackersForTarget(Unit *victim)
+{
+    HostileReference *ref = victim->getHostileRefManager().getFirst();
+    while (ref)
+    {
+        ThreatManager *target = ref->getSource();
+        uint64 guid = target->getOwner()->GetGUID();
+        m_attackerInfo[guid].attacker = target->getOwner();
+        m_attackerInfo[guid].victim = target->getOwner()->getVictim();
+        m_attackerInfo[guid].threat = target->getThreat(victim);
+        m_attackerInfo[guid].count = 1;
+        //m_attackerInfo[guid].source = 1; // source is not used so far.
+        ref = ref->next();
+    }
+}
+
+void PlayerbotAI::UpdateAttackerInfo()
+{
+    // clear old list
+    m_attackerInfo.clear();
+
+    // check own attackers
+    UpdateAttackersForTarget(m_bot);
+    Pet *pet = m_bot->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check master's attackers
+    UpdateAttackersForTarget(m_master);
+    pet = m_master->GetPet();
+    if (pet)
+        UpdateAttackersForTarget(pet);
+
+    // check all group members now
+    if (m_bot->GetGroup())
+    {
+        GroupReference *gref = m_bot->GetGroup()->GetFirstMember();
+        while (gref)
+        {
+            if (gref->getSource() == m_bot || gref->getSource() == m_master)
+            {
+                gref = gref->next();
+                continue;
+            }
+
+            UpdateAttackersForTarget(gref->getSource());
+            pet = gref->getSource()->GetPet();
+            if (pet)
+                UpdateAttackersForTarget(pet);
+
+            gref = gref->next();
+        }
+    }
+
+    // get highest threat not caused by bot for every entry in AttackerInfoList...
+    for (AttackerInfoList::iterator itr = m_attackerInfo.begin(); itr != m_attackerInfo.end(); ++itr)
+    {
+        if (!itr->second.attacker)
+            continue;
+        Unit *a = itr->second.attacker;
+        float t = 0.00;
+        std::list<HostileReference*>::const_iterator i = a->getThreatManager().getThreatList().begin();
+        for (; i != a->getThreatManager().getThreatList().end(); ++i)
+        {
+            if ((*i)->getThreat() > t && (*i)->getTarget() != m_bot)
+                t = (*i)->getThreat();
+        }
+        m_attackerInfo[itr->first].threat2 = t;
+    }
+
+    // DEBUG: output attacker info
+    //sLog->outBasic( "[PlayerbotAI]: %s m_attackerInfo = {", m_bot->GetName() );
+    //for( AttackerInfoList::iterator i=m_attackerInfo.begin(); i!=m_attackerInfo.end(); ++i )
+    //    //sLog->outBasic( "[PlayerbotAI]:     [%016I64X] { %08X, %08X, %.2f, %.2f, %d, %d }",
+    //        i->first,
+    //        (i->second.attacker?i->second.attacker->GetGUIDLow():0),
+    //        (i->second.victim?i->second.victim->GetGUIDLow():0),
+    //        i->second.threat,
+    //        i->second.threat2,
+    //        i->second.count,
+    //        i->second.source );
+    //sLog->outBasic( "[PlayerbotAI]: };" );
+}
+
+uint32 PlayerbotAI::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(((INVENTORY_SLOT_BAG_0 << 8) | i));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for (int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for (int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(((j << 8) | i));
+    return TotalCost;
+}
+
+uint32 PlayerbotAI::EstRepair(uint16 pos)
+{
+    Item* item = m_bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if (!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if (!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if (LostDurability > 0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if (!dcost)
+        {
+            //sLog->outError("RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality + 1) * 2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if (!dQualitymodEntry)
+        {
+            //sLog->outError("RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class, ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability * dmultiplier * double(dQualitymodEntry->quality_mod));
+
+        if (costs == 0)                                 //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
+
+Unit* PlayerbotAI::FindAttacker(ATTACKERINFOTYPE ait, Unit *victim)
+{
+    // list empty? why are we here?
+    if (m_attackerInfo.empty())
+        return 0;
+
+    // not searching something specific - return first in list
+    if (!ait)
+        return (m_attackerInfo.begin())->second.attacker;
+
+    float t = ((ait & AIT_HIGHESTTHREAT) ? 0.00 : 9999.00);
+    Unit *a = 0;
+    AttackerInfoList::iterator itr = m_attackerInfo.begin();
+    for (; itr != m_attackerInfo.end(); ++itr)
+    {
+        if ((ait & AIT_VICTIMSELF) && !(ait & AIT_VICTIMNOTSELF) && itr->second.victim != m_bot)
+            continue;
+
+        if (!(ait & AIT_VICTIMSELF) && (ait & AIT_VICTIMNOTSELF) && itr->second.victim == m_bot)
+            continue;
+
+        if ((ait & AIT_VICTIMNOTSELF) && victim && itr->second.victim != victim)
+            continue;
+
+        if (!(ait & (AIT_LOWESTTHREAT | AIT_HIGHESTTHREAT)))
+        {
+            a = itr->second.attacker;
+            itr = m_attackerInfo.end();
+        }
+        else
+        {
+            if ((ait & AIT_HIGHESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat >= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+            else if ((ait & AIT_LOWESTTHREAT) && /*(itr->second.victim==m_bot) &&*/ itr->second.threat <= t)
+            {
+                t = itr->second.threat;
+                a = itr->second.attacker;
+            }
+        }
+    }
+    return a;
+}
+
+void PlayerbotAI::SetCombatOrderByStr(std::string str, Unit *target)
+{
+    CombatOrderType co;
+    if (str == "tank") co = ORDERS_TANK;
+    else if (str == "assist") co = ORDERS_ASSIST;
+    else if (str == "heal") co = ORDERS_HEAL;
+    else if (str == "protect") co = ORDERS_PROTECT;
+    else if (str == "passive") co = ORDERS_PASSIVE;
+    else if (str == "nodispel") co = ORDERS_NODISPEL;
+    else if (str == "resistfrost") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_FROST;
+    }
+    else if (str == "resistnature") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_NATURE;
+    }
+    else if (str == "resistfire") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_FIRE;
+    }
+    else if (str == "resistshadow") {
+        co = ORDERS_RESIST;
+        m_resistType = SCHOOL_SHADOW;
+    }
+    else
+        co = ORDERS_RESET;
+    SetCombatOrder(co, target);
+    if (FollowAutoGo != 0)
+        FollowAutoGo = 1;
+}
+
+void PlayerbotAI::SetCombatOrder(CombatOrderType co, Unit *target)
+{
+    // reset m_combatOrder after ORDERS_PASSIVE
+    if (m_combatOrder == ORDERS_PASSIVE)
+    {
+        m_combatOrder = ORDERS_NONE;
+        m_targetAssist = 0;
+        m_targetProtect = 0;
+        m_resistType = SCHOOL_NONE;
+    }
+
+    if ((co == ORDERS_ASSIST || co == ORDERS_PROTECT) && !target) {
+        TellMaster("Erf, you forget to target assist/protect characters!");
+        return;
+    }
+    if (co == ORDERS_RESET) {
+        m_combatOrder = ORDERS_NONE;
+        m_targetAssist = 0;
+        m_targetProtect = 0;
+        TellMaster("Orders are cleaned!");
+        return;
+    }
+    if (co == ORDERS_PASSIVE)
+    {
+        m_combatOrder = ORDERS_PASSIVE;
+        SendOrders(*m_master);
+        return;
+    }
+    if (co == ORDERS_PROTECT)
+        m_targetProtect = target;
+    else if (co == ORDERS_ASSIST)
+        m_targetAssist = target;
+    if ((co & ORDERS_PRIMARY))
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_SECONDARY) | (uint32) co);
+    else
+        m_combatOrder = (CombatOrderType) (((uint32) m_combatOrder & (uint32) ORDERS_PRIMARY) | (uint32) co);
+    SendOrders(*m_master);
+}
+
+void PlayerbotAI::SetMovementOrder(MovementOrderType mo, Unit *followTarget)
+{
+    m_movementOrder = mo;
+    m_followTarget = followTarget;
+    MovementReset();
+}
+
+void PlayerbotAI::MovementReset()
+{
+    //TellMaster("Debug: MovementReset()");
+    // stop moving...
+    MovementClear();
+
+    if (m_movementOrder == MOVEMENT_FOLLOW)
+    {
+        if (!m_followTarget)
+            return;
+
+        WorldObject* distTarget = m_followTarget;   // target to distance check
+
+        // don't follow while in combat
+        if (m_bot->isInCombat())
+            return;
+        // new check bot
+        if (!m_bot->isAlive() || m_bot->IsBeingTeleported() || m_bot->isInFlight())
+            return;
+
+        Player* pTarget = NULL;                     // target is player
+        if (m_followTarget->GetTypeId() == TYPEID_PLAYER)
+            pTarget = m_followTarget->ToPlayer();
+
+        if (pTarget)
+        {
+            // check player for follow situations
+            if (pTarget->IsBeingTeleported() || pTarget->isInFlight())
+                return;
+
+            // use player's corpse as distance check target
+            if (pTarget->GetCorpse())
+                distTarget = pTarget->GetCorpse();
+        }
+
+        // is bot too far from the follow target
+        if (!m_bot->IsWithinDistInMap(distTarget, 50))
+        {
+            //DoTeleport(*m_followTarget);
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 3;
+            PlayerbotChatHandler ch(m_master);
+            if (!ch.teleport(*m_bot, *m_followTarget))
+            {
+                TellMaster("I cannot be teleported...");
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+            }
+            return;
+        }
+
+        float angle = frand(0, float(M_PI));
+        float dist = frand(m_confFollowDistance[0], m_confFollowDistance[1]);
+        m_bot->GetMotionMaster()->MoveFollow(m_followTarget, dist, angle);
+        //m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+        if (FollowAutoGo == 5)
+            FollowAutoGo = 1;
+    }
+}
+
+void PlayerbotAI::MovementClear()
+{
+    //TellMaster("Debug: MovementClear()");
+    // stop...
+    m_bot->GetMotionMaster()->Clear(true);
+    m_bot->ClearUnitState(UNIT_STATE_CHASE);
+    m_bot->ClearUnitState(UNIT_STATE_FOLLOW);
+
+    // stand up...
+    if (!m_bot->IsStandState())
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+void PlayerbotAI::BotPlaySound(uint32 soundid)
+{
+    WorldPacket data(SMSG_PLAY_SOUND, 4);
+    data << soundid;
+    m_master->GetSession()->SendPacket(&data);
+}
+
+// BotPlaySound data from SoundEntries.dbc
+void PlayerbotAI::Announce(AnnounceFlags msg)
+{
+    switch (m_bot->getRace())
+    {
+        case RACE_HUMAN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1908) : BotPlaySound(2032); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1875) : BotPlaySound(1999); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1924) : BotPlaySound(2048); break;
+                default: break;
+            }
+            break;
+        case RACE_ORC:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2319) : BotPlaySound(2374); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2284) : BotPlaySound(2341); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2335) : BotPlaySound(2390); break;
+                default: break;
+            }
+            break;
+        case RACE_DWARF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1630) : BotPlaySound(1686); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1581) : BotPlaySound(1654); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1636) : BotPlaySound(1702); break;
+                default: break;
+            }
+            break;
+        case RACE_NIGHTELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2151) : BotPlaySound(2262); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2118) : BotPlaySound(2229); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2167) : BotPlaySound(2278); break;
+                default: break;
+            }
+            break;
+        case RACE_UNDEAD_PLAYER:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2096) : BotPlaySound(2207); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2054) : BotPlaySound(2173); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2112) : BotPlaySound(2223); break;
+                default: break;
+            }
+            break;
+        case RACE_TAUREN:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2463) : BotPlaySound(2462); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2396) : BotPlaySound(2397); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(2495) : BotPlaySound(2494); break;
+                default: break;
+            }
+            break;
+        case RACE_GNOME:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1743) : BotPlaySound(1798); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1708) : BotPlaySound(1709); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1759) : BotPlaySound(1814); break;
+                default: break;
+            }
+            break;
+        case RACE_TROLL:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1853) : BotPlaySound(1963); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1820) : BotPlaySound(1930); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(1869) : BotPlaySound(1993); break;
+                default: break;
+            }
+            break;
+        case RACE_BLOODELF:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9583) : BotPlaySound(9584); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9549) : BotPlaySound(9550); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9565) : BotPlaySound(9566); break;
+                default: break;
+            }
+            break;
+        case RACE_DRAENEI:
+            switch (msg)
+            {
+                case CANT_AFFORD: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9498) : BotPlaySound(9499); break;
+                case INVENTORY_FULL: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9465) : BotPlaySound(9466); break;
+                case CANT_USE_TOO_FAR: m_bot->getGender() == GENDER_MALE ? BotPlaySound(9481) : BotPlaySound(9482); break;
+                default: break;
+            }
+            break;
+        default:
+            break;
+    }
+}
+
+bool PlayerbotAI::IsMoving()
+{
+    //return m_bot->isMoving();
+    return (m_bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == IDLE_MOTION_TYPE ? false : true);
+}
+
+// some possible things to use in AI
+// GetRandomContactPoint
+// GetPower, GetMaxPower
+// HasSpellCooldown
+// IsAffectedBySpellmod
+// isMoving
+// HasUnitState(FLAG) FLAG like: UNIT_STATE_ROOT, UNIT_STATE_CONFUSED, UNIT_STATE_STUNNED
+// hasAuraType
+
+void PlayerbotAI::UpdateAI(const uint32 /*p_time*/)
+{
+    if (m_bot->IsBeingTeleported() || m_bot->GetTrader())
+        return;
+
+    if (!m_master->GetGroup() || !m_master->GetGroup()->IsMember(m_bot->GetGUID()))
+    {
+        m_master->GetSession()->LogoutPlayerBot(m_bot->GetGUID());
+        return;
+    }
+    if (m_changeFaction && !m_master->GetCharmer())
+    {
+        //new
+        Team masterteam = Team(m_master->GetTeam());
+        if (m_bot->GetTeam() != masterteam)
+            m_bot->SetBotTeam(masterteam);
+        //new
+        uint32 masterfaction = m_master->getFaction();
+        if (m_bot->getFaction() != masterfaction || !m_bot->IsFriendlyTo(m_master))
+            m_bot->setFaction(masterfaction);
+        for (uint8 i = 0; i != m_bot->GetMaxNpcBots(); ++i)
+        {
+            Creature *cre = m_bot->GetBotMap()[i]._Guid() != 0 ? sObjectAccessor->GetObjectInWorld(m_bot->GetBotMap()[i]._Guid(), (Creature*)NULL) : NULL;
+            if (!cre) continue;
+            if (cre->getFaction() != masterfaction || !cre->IsFriendlyTo(m_master))
+                cre->setFaction(masterfaction);
+        }
+    }
+    if(m_master->GetBotTankGuid() != m_bot->GetBotTankGuid())
+        m_bot->SetBotTank(m_master->GetBotTankGuid());
+
+    time_t currentTime = time(NULL);
+    if (currentTime < m_ignoreAIUpdatesUntilTime)
+        return;
+
+    // default updates occur every two seconds
+    m_ignoreAIUpdatesUntilTime = time(NULL) + 1;
+    if (FollowAutoGo == 1)
+    {
+        if (m_combatOrder & ORDERS_TANK)
+            DistOverRide = 1;
+        else if (m_combatOrder & ORDERS_ASSIST)
+            DistOverRide = 3;
+        else
+            DistOverRide = 4;
+        FollowAutoGo = 2;
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+    }
+    if (!m_bot->isAlive())
+    {
+        if (m_botState != BOTSTATE_DEAD && m_botState != BOTSTATE_DEADRELEASED)
+        {
+            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s died and is not in correct state...", m_bot->GetName() );
+            // clear loot list on death
+            m_lootTargets.clear();
+            m_lootCurrent = 0;
+            // clear combat orders
+            m_bot->SetSelection(0);
+            m_bot->GetMotionMaster()->Clear(true);
+            // set state to dead
+            SetState(BOTSTATE_DEAD);
+            // wait 30sec
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 30;
+        }
+        else if (m_botState == BOTSTATE_DEAD)
+        {
+            // become ghost
+            if (m_bot->GetCorpse())
+            {
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s already has a corpse...", m_bot->GetName() );
+                SetState(BOTSTATE_DEADRELEASED);
+                return;
+            }
+            m_bot->SetBotDeathTimer();
+            m_bot->BuildPlayerRepop();
+            // relocate ghost
+            //Position loc;
+            if (Corpse *corpse = m_bot->GetCorpse())
+            {
+                m_bot->TeleportTo(corpse->GetMapId(), corpse->GetPositionX(), corpse->GetPositionY(), corpse->GetPositionZ(), m_bot->GetOrientation());
+                //m_bot->TeleportTo(*corpse);
+            }
+            // set state to released
+            SetState(BOTSTATE_DEADRELEASED);
+        }
+        else if (m_botState == BOTSTATE_DEADRELEASED)
+        {
+            // get bot's corpse
+            Corpse *corpse = m_bot->GetCorpse();
+            if (!corpse)
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s has no corpse!", m_bot->GetName() );
+                return;
+            // teleport ghost from graveyard to corpse
+            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - Teleport %s to corpse...", m_bot->GetName() );
+            //DoTeleport(*corpse);
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 3;
+            PlayerbotChatHandler ch(m_master);
+            if (!ch.teleport(*m_bot, *corpse))
+            {
+                ch.sysmessage(".. could not be teleported ..");
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+            }
+            // check if we are allowed to resurrect now
+            if ((corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP)) > time(NULL))
+            {
+                m_ignoreAIUpdatesUntilTime = corpse->GetGhostTime() + m_bot->GetCorpseReclaimDelay(corpse->GetType() == CORPSE_RESURRECTABLE_PVP);
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - %s has to wait for %d seconds to revive...", m_bot->GetName(), m_ignoreAIUpdatesUntilTime-time(NULL) );
+                return;
+            }
+            // resurrect now
+            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: UpdateAI - Reviving %s to corpse...", m_bot->GetName() );
+            m_ignoreAIUpdatesUntilTime = time(NULL) + 6;
+            //PlayerbotChatHandler ch(m_master);
+            if (!ch.revive(*m_bot))
+            {
+                ch.sysmessage(".. could not be revived ..");
+                return;
+            }
+            // set back to normal
+            SetState(BOTSTATE_NORMAL);
+        }
+    }
+    else//if bot is alive
+    {
+        if (!m_findNPC.empty())
+            findNearbyCreature();
+
+        // if we are casting a spell then interrupt it
+        // make sure any actions that cast a spell set a proper m_ignoreAIUpdatesUntilTime!
+        //DEBUG
+        Spell* const pSpell = GetCurrentSpell();
+        //if (pSpell && !pSpell->IsChannelActive() && !pSpell->IsAutoRepeat())
+        //{
+        //    TellMaster("UpdateAI(): wrong m_ignoreAIUpdatesUntilTime! Interrupting spell! (%s - %u)", pSpell->GetSpellInfo()->SpellName[0], pSpell->GetSpellInfo()->Id);
+        //    InterruptCurrentCastingSpell();
+        //}
+        //else 
+        //DEBUG
+        if (m_botState == BOTSTATE_TAME)
+        {
+            Unit* pTarget = sObjectAccessor->GetUnit(*m_bot, m_targetGuidCommand);
+            if (!pTarget)
+                return;
+
+            m_bot->SetSelection(m_targetGuidCommand);
+
+            if (!IsInRange(pTarget, TAME_BEAST_1))
+                m_bot->ClearUnitState(UNIT_STATE_CHASE);
+
+            if (!m_bot->HasUnitState(UNIT_STATE_CHASE))
+            {
+                m_bot->GetMotionMaster()->MoveChase(pTarget);
+                return;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(TAME_BEAST_1);
+            if (!spellInfo)
+                return;
+
+            Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+            if (!spell)
+                return;
+
+            if (m_bot->GetPetGUID() || spell->CheckCast(true) != SPELL_CAST_OK || !pTarget ||
+                pTarget->isDead() || !m_bot->IsInMap(pTarget) ||
+                !(pTarget->ToCreature() && (((Creature *)pTarget)->GetCreatureTemplate()->type_flags & CREATURE_TYPEFLAGS_TAMEABLE)))
+            {
+                MovementReset();
+                m_bot->SetSelection(0);
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            else if (!m_bot->HasAura(TAME_BEAST_1, 0, 0, 1))
+            {
+                m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+                SpellCastTargets targets;
+                targets.SetUnitTarget(pTarget);
+                spell->prepare(&targets);
+                SetIgnoreUpdateTime(10);
+            }
+            return;
+        }
+
+        // direct cast command from master
+        else if (m_spellIdCommand != 0)
+        {
+            Unit* pTarget = sObjectAccessor->GetUnit(*m_bot, m_targetGuidCommand);
+            if (pTarget)
+                CastSpell(m_spellIdCommand, *pTarget);
+            m_spellIdCommand = 0;
+            m_targetGuidCommand = 0;
+        }
+
+        else if (m_botState == BOTSTATE_ENCHANT)
+        {
+            SetState(BOTSTATE_NORMAL);
+            InspectUpdate();
+        }
+
+        else if (m_botState == BOTSTATE_CRAFT)
+        {
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(m_CurrentlyCastingSpellId);
+            if (!spellInfo)
+                return;
+
+            Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+            if (!spell)
+                return;
+
+            if (GetSpellCharges(m_CurrentlyCastingSpellId) == 0 || spell->CheckCast(true) != SPELL_CAST_OK)
+            {
+                SetState(BOTSTATE_NORMAL);
+                SetIgnoreUpdateTime(0);
+            }
+            else
+            {
+                SpellCastTargets targets;
+                spell->prepare(&targets);
+                SetIgnoreUpdateTime(3);
+            }
+        }
+
+        else if (m_master->IsMounted() && !m_bot->IsMounted() && !m_bot->HasUnitState(UNIT_STATE_CASTING))
+        {
+            //Player Part
+            Unit::AuraEffectList const& AuraList = m_master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+            if (!AuraList.empty())
+            {
+                SpellInfo const *pSpellInfo = AuraList.front()->GetSpellInfo();
+
+                //Bot Part
+                uint32 spellMount = 0;
+                //cheap check if we know this spell
+                for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                {
+                    if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+                        continue;
+                    uint32 spellId = itr->first;
+                    if (pSpellInfo->Id == spellId)
+                    {
+                        spellMount = spellId;
+                        break;
+                    }
+                }
+                if (!spellMount)
+                {
+                    //analyze and find proper mount spell
+                    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+                    {
+                        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled)
+                            continue;
+                        uint32 spellId = itr->first;
+                        SpellInfo const *bSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+                        if (!bSpellInfo || bSpellInfo->IsPassive())
+                            continue;
+
+                        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                        {
+                            if (bSpellInfo->Effects[i].ApplyAuraName == SPELL_AURA_MOUNTED)
+                            {
+                                //arrange values
+                                int8 j = i-1, k = i+1;
+                                if (j < 0)// i == 0
+                                    j = k+1;//2
+                                else if (k >= MAX_SPELL_EFFECTS)// i == 2
+                                    k = j-1;//0
+
+                                if (bSpellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[j].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                                else if (bSpellInfo->Effects[k].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[k].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                                else if (bSpellInfo->Effects[j].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[j].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                                else if (bSpellInfo->Effects[k].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED)
+                                {
+                                    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                                    {
+                                        if (pSpellInfo->Effects[i].BasePoints == bSpellInfo->Effects[k].BasePoints)
+                                        {
+                                            spellMount = spellId;
+                                            break;
+                                        }
+                                    }
+                                    if (spellMount)
+                                        break;
+                                }
+                            }
+                        }
+                        if (spellMount)
+                            break;
+                    }
+                }
+                if (spellMount)
+                    CastSpell(spellMount);
+                else
+                    SendWhisper("Cannot find approriate mount!", *m_master);
+            }
+        }
+
+        //if master is unmounted, unmount the bot
+        else if (!m_master->IsMounted() && m_bot->IsMounted())
+        {
+            WorldPacket emptyPacket;
+            m_bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);  //updated code
+        }
+
+        // handle combat (either self/master/group in combat, or combat state and valid target)
+        else if (IsInCombat() || (m_botState == BOTSTATE_COMBAT && m_targetCombat) ||  m_ScenarioType == SCENARIO_DUEL)
+        {
+            //check if the bot is Mounted
+            if (!m_bot->IsMounted())
+            {
+                if (!pSpell || !pSpell->IsChannelActive())
+                    DoNextCombatManeuver();
+                else
+                    SetIgnoreUpdateTime(1);  // It's better to update AI more frequently during combat
+            }
+        }
+        // bot was in combat recently - loot now
+        else if (m_botState == BOTSTATE_COMBAT)
+        {
+            SetState(BOTSTATE_LOOTING);
+            m_attackerInfo.clear();
+            if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+                m_lootTargets.unique();
+            else
+                m_lootTargets.clear();
+            SetIgnoreUpdateTime(0);
+        }
+        else if (m_botState == BOTSTATE_LOOTING)
+        {
+            DoLoot();
+        }
+        else if (m_botState == BOTSTATE_FLYING)
+        {
+            /* std::ostringstream out;
+               out << "Taxi: " << m_bot->GetName() << m_ignoreAIUpdatesUntilTime;
+               TellMaster(out.str().c_str()); */
+            DoFlight();
+            SetState(BOTSTATE_NORMAL);
+            SetIgnoreUpdateTime(0);
+        }
+        // if commanded to follow master and not already following master then follow master
+        else if (!m_bot->isInCombat() && !IsMoving())
+        {
+            //TellMaster("UpdateAI():I am not in combat and not moving - reset movement");
+            MovementReset();
+        }
+
+        // do class specific non combat actions
+        else if (m_classAI && !m_bot->IsMounted())
+        {
+            (m_classAI)->DoNonCombatActions();
+
+            // have we been told to collect GOs
+            if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+            {
+                findNearbyGO();
+                // start looting if have targets
+                if (!m_lootTargets.empty())
+                    SetState(BOTSTATE_LOOTING);
+            }
+        }
+        //debug
+        if (!m_bot->HasUnitState(UNIT_STATE_CASTING))
+            m_bot->RemoveAura(SPELL_ROOT);
+        //end debug
+        // debug
+        if (m_botState == BOTSTATE_NORMAL)
+        {
+            if (m_master->getStandState() == UNIT_STAND_STATE_SIT)
+                m_bot->SetStandState(UNIT_STAND_STATE_SIT);
+            else if (m_bot->getStandState() == UNIT_STAND_STATE_SIT && m_TimeDoneDrinking < time(0) && m_TimeDoneEating < time(0)) //Do no interrupt if bot is eating/drinking
+                m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+            m_bot->SendUpdateToPlayer(m_master);
+        }
+        // end debug
+    }//end is alive
+}
+
+Spell* PlayerbotAI::GetCurrentSpell() const
+{
+    if (m_CurrentlyCastingSpellId == 0)
+        return NULL;
+
+    return m_bot->FindCurrentSpellBySpellId(m_CurrentlyCastingSpellId);
+}
+
+void PlayerbotAI::TellMaster(const std::string& text) const
+{
+    SendWhisper(text, *m_master);
+}
+
+void PlayerbotAI::TellMaster(const char *fmt, ...) const
+{
+    char temp_buf[2048];
+    va_list ap;
+    va_start(ap, fmt);
+    vsnprintf(temp_buf, 2048, fmt, ap);
+    va_end(ap);
+    std::string str = temp_buf;
+    TellMaster(str);
+}
+
+void PlayerbotAI::SendWhisper(const std::string& text, Player& player) const
+{
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    m_bot->BuildPlayerChat(&data, CHAT_MSG_WHISPER, text, LANG_UNIVERSAL);
+    player.GetSession()->SendPacket(&data);
+}
+
+bool PlayerbotAI::canObeyCommandFrom(const Player& player) const
+{
+    return player.GetSession()->GetAccountId() == m_master->GetSession()->GetAccountId();
+}
+
+bool PlayerbotAI::IsInRange(Unit* Target, uint32 spellId)
+{
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    bool positive = (Target->ToPlayer() && Target->ToPlayer()->GetGroup() == m_bot->GetGroup()) || Target->IsFriendlyTo(m_bot);
+    return m_bot->IsInRange(Target, pSpellInfo->GetMinRange(positive), pSpellInfo->GetMaxRange(positive));
+
+    //SpellRangeEntry const* TempRange = GetSpellRangeStore()->LookupEntry(pSpellInfo->rangeIndex);
+
+    ////Spell has invalid range store so we can't use it
+    //if (!TempRange)
+    //    return false;
+
+    //if ((TempRange->minRange == 0.0f) && (TempRange->maxRange == 0.0f))
+    //    return true;
+
+    ////Unit is out of range for this spell
+    //if (!m_bot->IsInRange(Target, TempRange->minRange, TempRange->maxRange))
+    //    return false;
+
+    //return true;
+}
+
+bool PlayerbotAI::CastSpell(const char* args)
+{
+    uint32 spellId = getSpellId(args);
+    return (spellId) ? CastSpell(spellId) : false;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit& target)
+{
+    uint64 oldSel = m_bot->GetSelection();
+    m_bot->SetSelection(target.GetGUID());
+    bool rv = CastSpell(spellId);
+    m_bot->SetSelection(oldSel);
+    return rv;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId)
+{
+    // some AIs don't check if the bot doesn't have spell before using it
+    // so just return false when this happens
+    if (spellId == 0)
+        return false;
+    //debug
+    //prevent interrupting
+    if (m_bot->IsNonMeleeSpellCasted(false))
+        return false;
+    //debug
+
+    // check spell cooldown
+    if (m_bot->HasSpellCooldown(spellId))
+        return false;
+
+    // see Creature.cpp 1738 for reference
+    // don't allow bot to cast damage spells on friends
+    SpellInfo const *pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastSpell for spellid %u.", spellId);
+        return false;
+    }
+
+    // set target
+    Unit* pTarget = m_bot->GetSelection() ? sObjectAccessor->GetUnit(*m_bot, m_bot->GetSelection()) : m_bot;
+
+    if (pSpellInfo->IsPositive())
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+    }
+
+    float CastTime = 0.0f;
+
+    // stop movement to prevent cancel spell casting
+    SpellCastTimesEntry const * castTimeEntry = pSpellInfo->CastTimeEntry;
+    if (castTimeEntry && castTimeEntry->CastTime)
+    {
+        CastTime = (castTimeEntry->CastTime / 1000);
+        //TellMaster("CastSpell - movement reset for casting %s (%u, cast time: %f)", pSpellInfo->SpellName[0], spellId, CastTime);
+        m_bot->StopMoving();
+        //debug See also UpdateAI
+        m_bot->AddAura(SPELL_ROOT, m_bot);
+        //TellMaster("CastSpell - Applying root (%s - %u, cast time: %f)", pSpellInfo->SpellName[0], spellId, CastTime);
+        //end debug
+    }
+
+    uint32 target_type = TARGET_FLAG_UNIT;
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK)
+        target_type = TARGET_FLAG_GAMEOBJECT;
+
+    m_CurrentlyCastingSpellId = spellId;
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effects[0].Effect == SPELL_EFFECT_SKINNING)
+    {
+        if (m_lootCurrent)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_CAST_SPELL, 1 + 4 + 1 + 4 + 8);
+            *packet << uint8(0);                            // spells cast count;
+            *packet << spellId;
+            *packet << uint8(0);                            // unk_flags
+            *packet << uint32(target_type);
+            *packet << m_lootCurrent;//.WriteAsPacked();
+            m_bot->GetSession()->QueuePacket(packet);       // queue the packet to get around race condition
+
+            if (target_type == TARGET_FLAG_GAMEOBJECT)
+            {
+                WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+                *packetgouse << m_lootCurrent;
+                m_bot->GetSession()->QueuePacket(packetgouse);  // queue the packet to get around race condition
+
+                GameObject *obj = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+                if (!obj)
+                    return false;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    m_bot->PrepareQuestMenu(m_lootCurrent);
+                    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.QuestId;
+                        if (!AddQuest(questID, obj))
+                            TellMaster("Couldn't take quest");
+                    }
+                    m_lootCurrent = 0;
+                    m_bot->GetMotionMaster()->Clear();
+                    m_bot->GetMotionMaster()->MoveIdle();
+                }
+            }
+        }
+        else
+            return false;
+    }
+    else
+    {
+        // Check spell range
+        if (!IsInRange(pTarget, spellId))
+        {
+            //TellMaster("CastSpell - i'm not in range! (spell: %s, target: %s)", pSpellInfo->SpellName[0], pTarget->GetName());
+            return false;
+        }
+
+        // Check line of sight
+        if (!m_bot->IsWithinLOSInMap(pTarget))
+        {
+            //TellMaster("CastSpell - i'm not wothin LOS! (spell: %s, target: %s)", pSpellInfo->SpellName[0], pTarget->GetName());
+            return false;
+        }
+
+        ////temp
+        //Spell *spell = new Spell(m_bot, pSpellInfo, TRIGGERED_NONE);
+        //if (!spell->CheckCast(true))
+        //    TellMaster("CastSpell:CheckCast() cannot cast spell %u (%s), target: %s)", pSpellInfo->Id, pSpellInfo->SpellName[0], pTarget->GetName());
+
+        m_bot->CastSpell(pTarget, pSpellInfo, false/*true*/);       // actually cast spell
+        //TellMaster("CastSpell - processing spell %u (%s), target: %s)", pSpellInfo->Id, pSpellInfo->SpellName[0], pTarget->GetName());
+    }
+
+    //DEBUG
+    //if (pSpellInfo->IsChanneled())
+    //    m_ignoreAIUpdatesUntilTime = time(NULL) + CastTime + 0.1f;
+    //else
+    //    m_ignoreAIUpdatesUntilTime = time(NULL) + 2;
+    //DEBUG
+
+    //m_CurrentlyCastingSpellId = 0;
+    m_CurrentlyCastingSpellId = pSpellInfo->Id;
+
+    // if this caused the caster to move (blink) update the position
+    // I think this is normally done on the client
+    // this should be done on spell success
+    /*
+       if (name == "Blink") {
+       float x,y,z;
+       m_bot->GetPosition(x,y,z);
+       m_bot->GetNearPoint(m_bot, x, y, z, 1, 5, 0);
+       m_bot->Relocate(x,y,z);
+       m_bot->SendHeartBeat();
+
+       }
+     */
+
+    return true;
+}
+
+bool PlayerbotAI::CastPetSpell(uint32 spellId, Unit* target)
+{
+    if (spellId == 0)
+        return false;
+
+    Pet* pet = m_bot->GetPet();
+    if (!pet)
+        return false;
+
+    if (pet->HasSpellCooldown(spellId))
+        return false;
+
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+    {
+        TellMaster("Missing spell entry in CastPetSpell()");
+        return false;
+    }
+
+    // set target
+    Unit* pTarget;
+    if (!target)
+    {
+        uint64 targetGUID = m_bot->GetSelection();
+        pTarget = sObjectAccessor->GetUnit(*m_bot, targetGUID);
+    }
+    else
+        pTarget = target;
+
+    if (sSpellMgr->GetSpellInfo(spellId)->IsPositive())
+    {
+        if (pTarget && !m_bot->IsFriendlyTo(pTarget))
+            pTarget = m_bot;
+    }
+    else
+    {
+        if (pTarget && m_bot->IsFriendlyTo(pTarget))
+            return false;
+
+        if (!pet->isInFrontInMap(pTarget, 10)) // distance probably should be calculated
+            pet->SetFacingTo(pet->GetAngle(pTarget));
+    }
+
+    pet->CastSpell(pTarget, pSpellInfo, false);
+
+    Spell* const pSpell = pet->FindCurrentSpellBySpellId(spellId);
+    if (!pSpell)
+        return false;
+
+    return true;
+}
+
+// Perform sanity checks and cast spell
+bool PlayerbotAI::Buff(uint32 spellId, Unit* target, void (*beforeCast)(Player *))
+{
+    if (spellId == 0)
+        return false;
+
+    SpellInfo const * spellProto = sSpellMgr->GetSpellInfo(spellId);
+
+    if (!spellProto)
+        return false;
+
+    if (!target)
+        return false;
+
+    // Select appropriate spell rank for target's level
+    spellProto = spellProto->GetAuraRankForLevel(target->getLevel());
+    if (!spellProto)
+        return false;
+
+    // Check if spell will boost one of already existent auras
+    bool willBenefitFromSpell = false;
+    for (uint8 i = 0; i < MAX_SPELL_EFFECTS; ++i)
+    {
+        if (spellProto->Effects[i].ApplyAuraName == SPELL_AURA_NONE)
+            break;
+
+        bool sameOrBetterAuraFound = false;
+        int32 bonus = m_bot->CalculateSpellDamage(target, spellProto, i);
+        Unit::AuraEffectList const& auras = target->GetAuraEffectsByType(AuraType(spellProto->Effects[i].ApplyAuraName));
+        for (Unit::AuraEffectList::const_iterator it = auras.begin(); it != auras.end(); ++it)
+        {
+            if ((*it)->GetMiscValue() == spellProto->Effects[i].MiscValue && (*it)->GetAmount() >= bonus)
+            {
+                sameOrBetterAuraFound = true;
+                break;
+            }
+        }
+        willBenefitFromSpell = willBenefitFromSpell || !sameOrBetterAuraFound;
+    }
+
+    if (!willBenefitFromSpell)
+        return false;
+
+    // Druids may need to shapeshift before casting
+    if (beforeCast)
+        (*beforeCast)(m_bot);
+
+    return CastSpell(spellProto->Id, *target);
+}
+
+// Can be used for personal buffs like Mage Armor and Inner Fire
+bool PlayerbotAI::SelfBuff(uint32 spellId)
+{
+    if (spellId == 0)
+        return false;
+
+    if (m_bot->HasAura(spellId))
+        return false;
+
+    return CastSpell(spellId, *m_bot);
+}
+
+// Checks if spell is single per target per caster and will make any effect on target
+bool PlayerbotAI::CanReceiveSpecificSpell(uint8 spec, Unit* target) const
+{
+    if (IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific(spec), SpellSpecific(spec)))
+    {
+        Unit::AuraMap const &holders = target->GetOwnedAuras();
+        Unit::AuraMap::const_iterator it;
+        for (it = holders.begin(); it != holders.end(); ++it)
+            if ((*it).second->GetCasterGUID() == m_bot->GetGUID() && (*it).second->GetSpellInfo()->GetSpellSpecific() == SpellSpecific(spec))
+                return false;
+    }
+    return true;
+}
+
+bool PlayerbotAI::IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific spellSpec1, SpellSpecific spellSpec2) const
+{
+    switch (spellSpec1)
+    {
+        case SPELL_BLESSING:
+        case SPELL_AURA:
+        case SPELL_STING:
+        case SPELL_CURSE:
+        case SPELL_ASPECT:
+        case SPELL_POSITIVE_SHOUT:
+        case SPELL_JUDGEMENT:
+        case SPELL_HAND:
+        case SPELL_UA_IMMOLATE:
+            return spellSpec1==spellSpec2;
+        default:
+            return false;
+    }
+}
+
+uint8 PlayerbotAI::_findItemSlot(Item* target)
+{
+    // list out items equipped & in main backpack
+    //INVENTORY_SLOT_ITEM_START = 23
+    //INVENTORY_SLOT_ITEM_END = 39
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == target->GetTemplate()->ItemId)   // have required item
+                return slot;
+        }
+    }
+    // list out items in other removable backpacks
+    //INVENTORY_SLOT_BAG_START = 19
+    //INVENTORY_SLOT_BAG_END = 23
+
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);   // 255, 20 to 23
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == target->GetTemplate()->ItemId)        // have required item
+                        return slot;
+                }
+            }
+    }
+    return 0;
+}
+
+Item* PlayerbotAI::FindItem(uint32 ItemId)
+{
+    // list out items equipped & in main backpack
+    //INVENTORY_SLOT_ITEM_START = 23
+    //INVENTORY_SLOT_ITEM_END = 39
+
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]backpack slot = %u",m_bot->GetName(),slot); // 23 to 38 = 16
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);  // 255, 23 to 38
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in other removable backpacks
+    //INVENTORY_SLOT_BAG_START = 19
+    //INVENTORY_SLOT_BAG_END = 23
+
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)  // 20 to 23 = 4
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);   // 255, 20 to 23
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: FindItem - [%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);  // 1 to bagsize = ?
+                Item* const pItem = m_bot->GetItemByPos(bag, slot); // 20 to 23, 1 to bagsize
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindItemInBank(uint32 ItemId)
+{
+    // list out items in bank item slots
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        // sLog->outDebug("[%s's]backpack slot = %u",m_bot->GetName(),slot);
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+    // list out items in bank bag slots
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                // sLog->outDebug("[%s's]bag[%u] slot = %u", m_bot->GetName(), bag, slot);
+                Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)        // have required item
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
+
+Item* PlayerbotAI::FindKeyForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 25 && m_bot->HasItemCount(SILVER_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(SILVER_SKELETON_KEY);
+    if (reqSkillValue <= 125 && m_bot->HasItemCount(GOLDEN_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(GOLDEN_SKELETON_KEY);
+    if (reqSkillValue <= 200 && m_bot->HasItemCount(TRUESILVER_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(TRUESILVER_SKELETON_KEY);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(ARCANITE_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(ARCANITE_SKELETON_KEY);
+    if (reqSkillValue <= 375 && m_bot->HasItemCount(TITANIUM_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(TITANIUM_SKELETON_KEY);
+    if (reqSkillValue <= 400 && m_bot->HasItemCount(COBALT_SKELETON_KEY, 1))
+        return m_bot->GetItemByEntry(COBALT_SKELETON_KEY);
+
+    return NULL;
+}
+
+Item* PlayerbotAI::FindBombForLockValue(uint32 reqSkillValue)
+{
+    if (reqSkillValue <= 150 && m_bot->HasItemCount(SMALL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(SMALL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 250 && m_bot->HasItemCount(LARGE_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(LARGE_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 300 && m_bot->HasItemCount(POWERFUL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(POWERFUL_SEAFORIUM_CHARGE);
+    if (reqSkillValue <= 350 && m_bot->HasItemCount(ELEMENTAL_SEAFORIUM_CHARGE, 1))
+        return m_bot->GetItemByEntry(ELEMENTAL_SEAFORIUM_CHARGE);
+
+    return NULL;
+}
+
+bool PlayerbotAI::HasTool(uint32 TC)
+{
+    std::ostringstream out;
+
+    switch (TC)
+    {
+        case TC_MINING_PICK:                //  = 165
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a MINING PICK!";
+            break;
+
+        case TC_ARCLIGHT_SPANNER:          //  = 14
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have an ARCLIGHT SPANNER!";
+            break;
+
+        case TC_BLACKSMITH_HAMMER:         //  = 162
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a BLACKSMITH's HAMMER!";
+            break;
+
+        case TC_SKINNING_KNIFE:            //  = 166
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a SKINNING KNIFE!";
+            break;
+
+        case TC_COPPER_ROD:                //  = 6,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED COPPER ROD!";
+            break;
+
+        case TC_SILVER_ROD:                //  = 7,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED SILVER ROD!";
+            break;
+
+        case TC_GOLDEN_ROD:                //  = 8,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED GOLDEN ROD!";
+            break;
+
+        case TC_TRUESILVER_ROD:            //  = 9,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED TRUESILVER ROD!";
+            break;
+
+        case TC_ARCANITE_ROD:              //  = 10,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED ARCANITE ROD!";
+            break;
+
+        case TC_FEL_IRON_ROD:              //  = 41,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED FEL IRON ROD!";
+            break;
+
+        case TC_ADAMANTITE_ROD:            //  = 62,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED ADAMANTITE ROD!";
+            break;
+
+        case TC_ETERNIUM_ROD:              //  = 63,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED ETERNIUM ROD!";
+            break;
+
+        case TC_RUNED_AZURITE_ROD:         //  = 101,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED AZURITE ROD!";
+            break;
+
+        case TC_VIRTUOSO_INKING_SET:       //  = 121,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a VIRTUOSO INKING SET!";
+            break;
+
+        case TC_RUNED_COBALT_ROD:          //  = 189,
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED COBALT ROD!";
+            break;
+
+        case TC_RUNED_TITANIUM_ROD:        //  = 190,
+
+            if (m_bot->HasItemTotemCategory(TC))
+                return true;
+            else
+                out << "|cffff0000I do not have a RUNED TITANIUM ROD!";
+            break;
+        default:
+            out << "|cffffffffI do not know what tool that needs! TC (" << TC << ")";
+    }
+    TellMaster(out.str().c_str());
+    return false;
+}
+
+bool PlayerbotAI::HasSpellReagents(uint32 spellId)
+{
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return false;
+
+    if (m_bot->CanNoReagentCast(pSpellInfo))
+        return true;
+
+    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+    {
+        if (pSpellInfo->Reagent[i] <= 0)
+            continue;
+
+        uint32 itemid = pSpellInfo->Reagent[i];
+        uint32 count = pSpellInfo->ReagentCount[i];
+
+        if (!m_bot->HasItemCount(itemid, count))
+            return false;
+    }
+
+    return true;
+}
+
+uint32 PlayerbotAI::GetSpellCharges(uint32 spellId)
+{
+    const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return 0;
+
+    if (m_bot->CanNoReagentCast(pSpellInfo))
+        return 0;
+
+    uint32 charges = 0;
+    std::list<uint32> chargeList;
+    for (uint32 i = 0; i < MAX_SPELL_REAGENTS; ++i)
+    {
+        if (pSpellInfo->Reagent[i] <= 0)
+            continue;
+
+        uint32 totalcount = 0;
+        uint32 itemid = pSpellInfo->Reagent[i];
+        uint32 count = pSpellInfo->ReagentCount[i];
+        ItemCountInInv(itemid, totalcount);
+        chargeList.push_back((totalcount / count));
+    }
+
+    for (uint32 i = 0; i < 3; ++i)
+    {
+        if (pSpellInfo->TotemCategory[i] == 0)
+            continue;
+
+        if (!m_bot->HasItemTotemCategory(pSpellInfo->TotemCategory[i]))
+        {
+            m_noToolList.push_back(pSpellInfo->TotemCategory[i]);
+            return 0;
+        }
+    }
+
+    if (!chargeList.empty())
+    {
+        charges = chargeList.front();
+        chargeList.pop_front();
+        for (std::list<uint32>::iterator it = chargeList.begin(); it != chargeList.end(); ++it)
+            if (*it < charges)
+                charges = *it;
+    }
+    return charges;
+}
+
+void PlayerbotAI::ItemCountInInv(uint32 itemid, uint32 &count)
+{
+    for (int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+    {
+        Item *pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+        if (pItem && pItem->GetEntry() == itemid && !pItem->IsInTrade())
+            count += pItem->GetCount();
+    }
+
+    for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+    {
+        if (Bag * pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+            {
+                Item* pItem = m_bot->GetItemByPos(i, j);
+                if (pItem && pItem->GetEntry() == itemid && !pItem->IsInTrade())
+                    count += pItem->GetCount();
+            }
+    }
+}
+
+// extracts all item ids in format below
+// I decided to roll my own extractor rather then use the one in ChatHandler
+// because this one works on a const string, and it handles multiple links
+// |color|linkType:key:something1:...:somethingN|h[name]|h|r
+void PlayerbotAI::extractItemIds(const std::string& text, std::list<uint32>& itemIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractMailIds(const std::string& text, std::list<uint32>& mailIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hmail:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            mailIds.push_back(id);
+    }
+}
+
+/**
+ * Checks whether the TalentSpec database contains any obvious errors
+ *
+ * return 0  -> all ok
+ * return x  -> return the talentspec_id of the first talentspec that errors out
+ */
+
+// TODO: the way this is built is just begging for a memory leak (by adding a return case and forgetting to delete result)
+uint32 PlayerbotAI::TalentSpecDBContainsError()
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT * FROM playerbot_talentspec ORDER BY class ASC");
+
+    //if (!result)
+    //{
+    //    // Do you really need a progress bar? No, but all the other kids jumped off the bridge too...
+    //    //BarGoLink bar(1);
+
+    //    //bar.step();
+
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, table is empty.");
+
+    //    return 0;   // Because, well, no specs means none contain errors...
+    //}
+
+    ////BarGoLink bar(result->GetRowCount());
+
+    //do
+    //{
+    //    //bar.step();
+
+    //    /* 0            talentspec_id
+    //       1            name
+    //       2            class
+    //       3            purpose
+    //       4 to 74        talent_10 to 71
+    //       75 to 80        major_glyph_15, 30, 80, minor_glyph_15, 50, 70
+    //     */
+    //    Field* fields = result->Fetch();
+
+    //    uint32 ts_id = fields[0].GetUInt32();
+    //    if (!ts_id)    // Nice bit of paranoia: ts_id is a non-zero NOT NULL AUTO_INCREMENT value
+    //        continue;  // Of course, if the impossible ever does happen, we can't very well identify a TalentSpec without an ID...
+
+    //    std::string ts_name = fields[1].GetCString();
+    //    /*    Commented out? Because it's only required if you assume only players (not the server) pick talentspecs
+    //       if (0 == ts_name.size())
+    //       {
+    //       TellMaster("TalentSpec ID: %u does not have a name.", ts_id);
+
+    //       //delete result;
+    //       return ts_id;
+    //       }
+    //     */
+
+    //    long ts_class = fields[2].GetInt32();
+    //    if (ts_class != CLASS_DEATH_KNIGHT && ts_class != CLASS_DRUID && ts_class != CLASS_HUNTER && ts_class != CLASS_MAGE && ts_class != CLASS_PALADIN && ts_class != CLASS_PRIEST && ts_class != CLASS_ROGUE && ts_class != CLASS_SHAMAN && ts_class != CLASS_WARLOCK && ts_class != CLASS_WARRIOR &&
+    //        ts_class != CLASS_PET_CUNNING && ts_class != CLASS_PET_FEROCITY && ts_class != CLASS_PET_TENACITY)
+    //    {
+    //        TellMaster("TalentSpec: %u. \"%s\" contains an invalid class: %i.", ts_id, ts_name.c_str(), ts_class);
+
+    //        ////delete result;
+    //        return ts_id;    // invalid class
+    //    }
+
+    //    // Can't really be error checked, can it?
+    //    // uint32 ts_purpose = fields[3].GetUInt32();
+
+    //    // check all talents
+    //    for (uint8 i = 0; i < 71; i++)
+    //    {
+    //        uint8 fieldLoc = i + 4;
+    //        if (fields[fieldLoc].GetUInt16() == 0)
+    //        {
+    //            for (uint8 j = (i + 1); j < 71; j++)
+    //            {
+    //                fieldLoc = j + 4;
+    //                if (fields[fieldLoc].GetUInt16() != 0)
+    //                {
+    //                    TellMaster("TalentSpec: %u. \"%s\" contains an empty talent for level: %u while a talent for level: %u exists.", ts_id, ts_name.c_str(), (i + 10), (j + 10));
+
+    //                    ////delete result;
+    //                    return ts_id;
+    //                }
+    //            }
+    //            break;
+    //        }
+    //        else if (!ValidateTalent(fields[fieldLoc].GetUInt16(), ts_class))
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" (class: %i) contains an invalid talent for level %u: %u", ts_id, ts_name.c_str(), ts_class, (i + 10), fields[fieldLoc].GetUInt16());
+
+    //            ////delete result;
+    //            return ts_id;    // invalid talent
+    //        }
+    //    }
+
+    //    for (uint8 i = 75; i < 78; i++)  // as in, the 3 major glyphs
+    //    {
+    //        if (fields[i].GetUInt16() != 0 && !ValidateMajorGlyph(fields[i].GetUInt16(), ts_class))
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" contains an invalid Major glyph %u: %u", ts_id, ts_name.c_str(), (i - 74), fields[i].GetUInt16());
+    //            if (!ValidateGlyph(fields[i].GetUInt16(), ts_class))
+    //                TellMaster("In fact, according to our records, it's no glyph at all");
+
+    //            ////delete result;
+    //            return ts_id;
+    //        }
+    //    }
+    //    for (uint8 i = 78; i < 81; i++)  // as in, the 3 minor glyphs
+    //    {
+    //        if (fields[i].GetUInt16() != 0 && !ValidateMinorGlyph(fields[i].GetUInt16(), ts_class))
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" contains an invalid Minor glyph %u: %u", ts_id, ts_name.c_str(), (i - 77), fields[i].GetUInt16());
+    //            if (!ValidateGlyph(fields[i].GetUInt16(), ts_class))
+    //                TellMaster("In fact, according to our records, it's no glyph at all");
+
+    //            ////delete result;
+    //            return ts_id;
+    //        }
+    //    }
+    //} while (result->NextRow());
+
+    ////delete result;
+    return 0;
+}
+
+uint32 PlayerbotAI::GetTalentSpecsAmount()
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT COUNT(*) FROM playerbot_talentspec");
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, table is empty.");
+
+        return 0;
+    //}
+
+    //Field* fields = result->Fetch();
+
+    //uint32 count = fields[0].GetUInt32();
+
+    ////delete result;
+    //return count;
+}
+
+uint32 PlayerbotAI::GetTalentSpecsAmount(long specClass)
+{
+    //QueryResult result = CharacterDatabase.PQuery("SELECT COUNT(*) FROM playerbot_talentspec WHERE class = '%li'", specClass);
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, found no talentspecs for class %li.", specClass);
+
+        return 0;
+    //}
+
+    //Field* fields = result->Fetch();
+
+    //uint32 count = fields[0].GetUInt32();
+
+    ////delete result;
+    //return count;
+}
+
+/**
+ * GetTalentSpecs queries DB for the talentspecs (for a class), returning them in a list of TS structures
+ *
+ * *** for the most part, GetTalentSpecs assumes ALL SPECS ARE VALID ***
+ */
+std::list<TalentSpec> PlayerbotAI::GetTalentSpecs(long specClass)
+{
+    TalentSpec ts;
+    std::list<TalentSpec> tsList;
+    tsList.clear();
+    return tsList;
+
+    //QueryResult result = CharacterDatabase.PQuery("SELECT * FROM playerbot_talentspec WHERE class = %li ORDER BY talentspec_id ASC", specClass);
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, found no talentspecs for class %li.", specClass);
+
+    //    return tsList; // empty
+    //}
+
+    //do
+    //{
+    //    /* 0            talentspec_id
+    //       1            name
+    //       2            class
+    //       3            purpose
+    //       4 to 74        talent_10 to 71
+    //       75 to 80        major_glyph_15, 30, 80, minor_glyph_15, 50, 70
+    //     */
+    //    Field* fields = result->Fetch();
+
+    //    /* ts_id = fields[0].GetUInt32(); // not used
+    //       if (!ts_id)    // Nice bit of paranoia: ts_id is an AUTO_INCREMENT value
+    //       continue;  // Of course, if the impossible ever does happen, we can't very well identify a TalentSpec without an ID...
+    //     */
+
+    //    ts.specName = fields[1].GetCString();
+    //    ts.specClass = fields[2].GetInt16();
+    //    if (ts.specClass != CLASS_DEATH_KNIGHT && ts.specClass != CLASS_DRUID && ts.specClass != CLASS_HUNTER && ts.specClass != CLASS_MAGE && ts.specClass != CLASS_PALADIN && ts.specClass != CLASS_PRIEST && ts.specClass != CLASS_ROGUE && ts.specClass != CLASS_SHAMAN && ts.specClass != CLASS_WARLOCK && ts.specClass != CLASS_WARRIOR &&
+    //        ts.specClass != CLASS_PET_CUNNING && ts.specClass != CLASS_PET_FEROCITY && ts.specClass != CLASS_PET_TENACITY)
+    //    {
+    //        TellMaster("TalentSpec: %u. \"%s\" contains an invalid class.", fields[0].GetUInt32(), ts.specName.c_str());
+
+    //        continue;    // this spec is clearly broken, the next may or may not be
+    //    }
+
+    //    ts.specPurpose = (TalentSpecPurpose) fields[3].GetUInt32();
+
+    //    // check all talents
+    //    for (uint8 i = 0; i < 71; i++)
+    //    {
+    //        ts.talentId[i] = fields[i + 4].GetUInt16();
+    //    }
+
+    //    for (uint8 i = 0; i < 3; i++)  // as in, the 3 major glyphs
+    //    {
+    //        ts.glyphIdMajor[i] = fields[i + 75].GetUInt16();
+    //    }
+    //    for (uint8 i = 0; i < 3; i++)  // as in, the 3 minor glyphs
+    //    {
+    //        ts.glyphIdMajor[i] = fields[i + 78].GetUInt16();
+    //    }
+
+    //    tsList.push_back(ts);
+    //} while (result->NextRow());
+
+    ////delete result;
+    //return tsList;
+}
+
+/**
+ * GetTalentSpec queries DB for a talentspec given a class and a choice.
+ * The choice applies to the results for that class only, and is volatile.
+ *
+ * *** for the most part, GetTalentSpec assumes ALL SPECS ARE VALID ***
+ */
+TalentSpec PlayerbotAI::GetTalentSpec(long specClass, long choice)
+{
+    TalentSpec ts;
+    // Let's zero it out to be safe
+    ts.specName = "";
+    ts.specClass = 0;
+    ts.specPurpose = TSP_NONE;
+    for (int i = 0; i < 71; i++) ts.talentId[i] = 0;
+    for (int i = 0; i < 3; i++) ts.glyphIdMajor[i] = 0;
+    for (int i = 0; i < 3; i++) ts.glyphIdMinor[i] = 0;
+    return ts;
+
+    //// Weed out invalid choice - ts has been zero'd out anyway
+    //if (0 >= choice || (long) GetTalentSpecsAmount(specClass) < choice) return ts;
+
+    //QueryResult result = CharacterDatabase.PQuery("SELECT * FROM playerbot_talentspec WHERE class = %li ORDER BY talentspec_id ASC", specClass);
+
+    //if (!result)
+    //{
+    //    //sLog->outString();
+    //    //sLog->outString(">> Loaded `playerbot_talentspec`, found no talentspecs for class %li.", specClass);
+
+    //    //delete result;
+    //    return ts; // empty
+    //}
+
+    //for (int i = 1; i <= (int) GetTalentSpecsAmount(specClass); i++)
+    //{
+
+    //    if (i == choice)
+    //    {
+    //        /*
+    //           0            talentspec_id
+    //           1            name
+    //           2            class
+    //           3            purpose
+    //           4 to 74    talent_10 to 71
+    //           75 to 80    major_glyph_15, 30, 80, minor_glyph_15, 50, 70
+    //         */
+    //        Field* fields = result->Fetch();
+
+    //        /* ts_id = fields[0].GetUInt32(); // not used
+    //           if (!ts_id)    // Nice bit of paranoia: ts_id is an AUTO_INCREMENT value
+    //           continue;  // Of course, if the impossible ever does happen, we can't very well identify a TalentSpec without an ID...
+    //         */
+
+    //        ts.specName = fields[1].GetCString();
+    //        ts.specClass = fields[2].GetInt16();
+    //        if (ts.specClass != CLASS_DEATH_KNIGHT && ts.specClass != CLASS_DRUID && ts.specClass != CLASS_HUNTER && ts.specClass != CLASS_MAGE && ts.specClass != CLASS_PALADIN && ts.specClass != CLASS_PRIEST && ts.specClass != CLASS_ROGUE && ts.specClass != CLASS_SHAMAN && ts.specClass != CLASS_WARLOCK && ts.specClass != CLASS_WARRIOR &&
+    //            ts.specClass != CLASS_PET_CUNNING && ts.specClass != CLASS_PET_FEROCITY && ts.specClass != CLASS_PET_TENACITY)
+    //        {
+    //            TellMaster("TalentSpec: %u. \"%s\" contains an invalid class.", fields[0].GetUInt32(), ts.specName.c_str());
+
+    //            ts.specName = "";
+    //            ts.specClass = 0;
+    //            //delete result;
+    //            return ts;
+    //        }
+
+    //        ts.specPurpose = (TalentSpecPurpose) fields[3].GetUInt32();
+
+    //        // check all talents
+    //        for (uint8 i = 0; i < 71; i++)
+    //        {
+    //            ts.talentId[i] = fields[i + 4].GetUInt16();
+    //        }
+
+    //        for (uint8 i = 0; i < 3; i++)  // as in, the 3 major glyphs
+    //        {
+    //            ts.glyphIdMajor[i] = fields[i + 75].GetUInt16();
+    //        }
+    //        for (uint8 i = 0; i < 3; i++)  // as in, the 3 minor glyphs
+    //        {
+    //            ts.glyphIdMajor[i] = fields[i + 78].GetUInt16();
+    //        }
+
+    //        //delete result;
+    //        return ts;
+    //    }
+
+    //    // TODO: okay, this won't bog down the system, but it's still a waste. Figure out a better way.
+    //    result->NextRow();
+    //}
+
+    ////delete result;
+    //return ts;
+}
+
+/**
+ * ApplyActiveTalentSpec takes the active talent spec and attempts to apply it
+ *
+ * return true  -> ok, talentspec applied as fully as possible
+ * return false -> talentspec was not or only partially applied
+ */
+bool PlayerbotAI::ApplyActiveTalentSpec()
+{
+    //DISABLED
+    //// empty talent spec -> nothing to apply -> fully applied
+    //if (m_activeTalentSpec.specClass == 0 || m_activeTalentSpec.specPurpose == TSP_NONE)
+    //    return true;
+
+    //// Some basic error checking just in case
+    //if (m_activeTalentSpec.specClass != m_bot->getClass())
+    //    return false;
+
+    //std::vector<uint16> talentsToLearn;
+    //talentsToLearn.reserve(71);
+    //for (int i = 0; i < 71; i++)
+    //{
+    //    if (m_activeTalentSpec.talentId[i] != 0)
+    //        talentsToLearn.push_back(m_activeTalentSpec.talentId[i]);
+    //}
+
+    //PlayerTalentMap *ptm = m_bot->GetTalents(m_bot->GetActiveSpec());
+    //// First do a check as to whether all known talents are in the talent spec
+    //for (PlayerTalentMap::iterator iter = ptm->begin(); iter != ptm->end(); iter++)
+    //{
+    //    PlayerTalent* talent = (*iter).second;
+
+    //    // WARNING: There may be more than 71 'talents' in the PTM - unlearned talents are simply set as disabled - not removed
+    //    if (talent.state == PLAYERSPELL_REMOVED)
+    //        continue;
+
+    //    // currentRank = 0 to (MAX_RANK-1) not 1 to MAX_RANK
+    //    for (int i = 0; i <= (int) talent.currentRank; i++)
+    //    {
+    //        int j = 0; // why 0 and not -1? Because if talentsToCheck (no TalentSpec) is empty and talents have been learned -> NOK
+    //        for (std::vector<uint16>::iterator it = talentsToLearn.begin(); it != talentsToLearn.end(); it++)
+    //        {
+    //            if (talentsToLearn.at(j) == talent.talentEntry->TalentID)
+    //            {
+    //                talentsToLearn.erase(it);
+    //                j = -1; // So j = -1 -> learned talent found in talentspec
+    //                break;
+    //            }
+    //            j++;
+    //        }
+
+    //        // j == -1 signifies talent has been found in talent spec
+    //        if (-1 != j)
+    //        {
+    //            TellMaster("I've learned talents that are not in my talent spec. If you want me to learn the talent spec anyway you should have me reset my talents.");
+    //            return false;
+    //        }
+    //    }
+    //}
+
+    //int x = 0;
+    //for (std::vector<uint16>::iterator iter = talentsToLearn.begin(); iter != talentsToLearn.end(); iter++)
+    //{
+    //    // find current talent rank
+    //    uint32 learnTalentRank = 0;
+    //    if (PlayerTalent const* talent = m_bot->GetKnownTalentById(talentsToLearn.at(x)))
+    //        learnTalentRank = talent->currentRank + 1;
+    //    // else -> not known -> to learn = 0
+
+    //    // check if we have enough talent points
+    //    uint32 freeTalentPointsBefore = m_bot->GetFreeTalentPoints();
+    //    if (0 == freeTalentPointsBefore)
+    //        return true;
+
+    //    m_bot->LearnTalent(talentsToLearn.at(x), learnTalentRank);
+    //    if (freeTalentPointsBefore == m_bot->GetFreeTalentPoints())
+    //    {
+    //        // Do not tell master - error is logged server side, master gets generic failure warning from calling function.
+    //        //TellMaster("Failed to learn talent - Class: %i; TalentId: %i; TalentRank: %i. This error has been logged.", m_bot->getClass(), talentsToLearn.at(x), learnTalentRank);
+    //        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: ApplyActiveTalentSpec failure - Class: %i; TalentId: %i; TalentRank: %i.", m_bot->getClass(), talentsToLearn.at(x), learnTalentRank);
+    //        return false;
+    //    }
+
+    //    x++;
+    //}
+
+    return true;
+}
+
+/**
+ * ValidateTalent tests a talent against class to see if it belongs to that class
+ *
+ * uint16 talent:        talent ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid talent for that class
+ */
+bool PlayerbotAI::ValidateTalent(uint16 talent, long charClass)
+{
+    if (charClass == CLASS_DEATH_KNIGHT)
+    {
+        // this looong 'if' is to see if any talent is not a Death Knight talent when the class clearly is
+        if (DEATHKNIGHT_BUTCHERY != talent && DEATHKNIGHT_SUBVERSION != talent && DEATHKNIGHT_BLADE_BARRIER != talent && DEATHKNIGHT_BLADED_ARMOR != talent && DEATHKNIGHT_SCENT_OF_BLOOD != talent && DEATHKNIGHT_TWOHANDED_WEAPON_SPECIALIZATION != talent && DEATHKNIGHT_RUNE_TAP != talent && DEATHKNIGHT_DARK_CONVICTION != talent && DEATHKNIGHT_DEATH_RUNE_MASTERY != talent && DEATHKNIGHT_IMPROVED_RUNE_TAP != talent && DEATHKNIGHT_SPELL_DEFLECTION != talent && DEATHKNIGHT_VENDETTA != talent && DEATHKNIGHT_BLOODY_STRIKES != talent && DEATHKNIGHT_VETERAN_OF_THE_THIRD_WAR != talent && DEATHKNIGHT_MARK_OF_BLOOD != talent && DEATHKNIGHT_BLOODY_VENGEANCE != talent && DEATHKNIGHT_ABOMINATIONS_MIGHT != talent && DEATHKNIGHT_BLOOD_WORMS != talent && DEATHKNIGHT_HYSTERIA != talent && DEATHKNIGHT_IMPROVED_BLOOD_PRESENCE != talent && DEATHKNIGHT_IMPROVED_DEATH_STRIKE != talent && DEATHKNIGHT_SUDDEN_DOOM != talent && DEATHKNIGHT_VAMPIRIC_BLOOD != talent && DEATHKNIGHT_WILL_OF_THE_NECROPOLIS != talent && DEATHKNIGHT_HEART_STRIKE != talent && DEATHKNIGHT_MIGHT_OF_MOGRAINE != talent && DEATHKNIGHT_BLOOD_GORGED != talent && DEATHKNIGHT_DANCING_RUNE_WEAPON != talent && DEATHKNIGHT_IMPROVED_ICY_TOUCH != talent && DEATHKNIGHT_RUNIC_POWER_MASTERY != talent && DEATHKNIGHT_TOUGHNESS != talent && DEATHKNIGHT_ICY_REACH != talent && DEATHKNIGHT_BLACK_ICE != talent && DEATHKNIGHT_NERVES_OF_COLD_STEEL != talent && DEATHKNIGHT_ICY_TALONS != talent && DEATHKNIGHT_LICHBORNE != talent && DEATHKNIGHT_ANNIHILATION != talent && DEATHKNIGHT_KILLING_MACHINE != talent && DEATHKNIGHT_CHILL_OF_THE_GRAVE != talent && DEATHKNIGHT_ENDLESS_WINTER != talent && DEATHKNIGHT_FRIGID_DREADPLATE != talent && DEATHKNIGHT_GLACIER_ROT != talent && DEATHKNIGHT_DEATHCHILL != talent && DEATHKNIGHT_IMPROVED_ICY_TALONS != talent && DEATHKNIGHT_MERCILESS_COMBAT != talent && DEATHKNIGHT_RIME != talent && DEATHKNIGHT_CHILLBLAINS != talent && DEATHKNIGHT_HUNGERING_COLD != talent && DEATHKNIGHT_IMPROVED_FROST_PRESENCE != talent && DEATHKNIGHT_THREAT_OF_THASSARIAN != talent && DEATHKNIGHT_BLOOD_OF_THE_NORTH != talent && DEATHKNIGHT_UNBREAKABLE_ARMOR != talent && DEATHKNIGHT_ACCLIMATION != talent && DEATHKNIGHT_FROST_STRIKE != talent && DEATHKNIGHT_GUILE_OF_GOREFIEND != talent && DEATHKNIGHT_TUNDRA_STALKER != talent && DEATHKNIGHT_HOWLING_BLAST != talent && DEATHKNIGHT_VICIOUS_STRIKES != talent && DEATHKNIGHT_VIRULENCE != talent && DEATHKNIGHT_ANTICIPATION != talent && DEATHKNIGHT_EPIDEMIC != talent && DEATHKNIGHT_MORBIDITY != talent && DEATHKNIGHT_UNHOLY_COMMAND != talent && DEATHKNIGHT_RAVENOUS_DEAD != talent && DEATHKNIGHT_OUTBREAK != talent && DEATHKNIGHT_NECROSIS != talent && DEATHKNIGHT_CORPSE_EXPLOSION != talent && DEATHKNIGHT_ON_A_PALE_HORSE != talent && DEATHKNIGHT_BLOODCAKED_BLADE != talent && DEATHKNIGHT_NIGHT_OF_THE_DEAD != talent && DEATHKNIGHT_UNHOLY_BLIGHT != talent && DEATHKNIGHT_IMPURITY != talent && DEATHKNIGHT_DIRGE != talent && DEATHKNIGHT_DESECRATION != talent && DEATHKNIGHT_MAGIC_SUPPRESSION != talent && DEATHKNIGHT_REAPING != talent && DEATHKNIGHT_MASTER_OF_GHOULS != talent && DEATHKNIGHT_DESOLATION != talent && DEATHKNIGHT_ANTIMAGIC_ZONE != talent && DEATHKNIGHT_IMPROVED_UNHOLY_PRESENCE != talent && DEATHKNIGHT_GHOUL_FRENZY != talent && DEATHKNIGHT_CRYPT_FEVER != talent && DEATHKNIGHT_BONE_SHIELD != talent && DEATHKNIGHT_WANDERING_PLAGUE != talent && DEATHKNIGHT_EBON_PLAGUEBRINGER != talent && DEATHKNIGHT_SCOURGE_STRIKE != talent && DEATHKNIGHT_RAGE_OF_RIVENDARE != talent && DEATHKNIGHT_SUMMON_GARGOYLE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_DRUID)
+    {
+        if (DRUID_FEROCITY != talent && DRUID_FERAL_AGGRESSION != talent && DRUID_FERAL_INSTINCT != talent && DRUID_SAVAGE_FURY != talent && DRUID_THICK_HIDE != talent && DRUID_FERAL_SWIFTNESS != talent && DRUID_SURVIVAL_INSTINCTS != talent && DRUID_SHARPENED_CLAWS != talent && DRUID_SHREDDING_ATTACKS != talent && DRUID_PREDATORY_STRIKES != talent && DRUID_PRIMAL_FURY != talent && DRUID_PRIMAL_PRECISION != talent && DRUID_BRUTAL_IMPACT != talent && DRUID_FERAL_CHARGE != talent && DRUID_NURTURING_INSTINCT != talent && DRUID_NATURAL_REACTION != talent && DRUID_HEART_OF_THE_WILD != talent && DRUID_SURVIVAL_OF_THE_FITTEST != talent && DRUID_LEADER_OF_THE_PACK != talent && DRUID_IMPROVED_LEADER_OF_THE_PACK != talent && DRUID_PRIMAL_TENACITY != talent && DRUID_PROTECTOR_OF_THE_PACK != talent && DRUID_PREDATORY_INSTINCTS != talent && DRUID_INFECTED_WOUNDS != talent && DRUID_KING_OF_THE_JUNGLE != talent && DRUID_MANGLE != talent && DRUID_IMPROVED_MANGLE != talent && DRUID_REND_AND_TEAR != talent && DRUID_PRIMAL_GORE != talent && DRUID_BERSERK != talent && DRUID_IMPROVED_MARK_OF_THE_WILD != talent && DRUID_NATURES_FOCUS != talent && DRUID_FUROR != talent && DRUID_NATURALIST != talent && DRUID_SUBTLETY != talent && DRUID_NATURAL_SHAPESHIFTER != talent && DRUID_INTENSITY != talent && DRUID_OMEN_OF_CLARITY != talent && DRUID_MASTER_SHAPESHIFTER != talent && DRUID_TRANQUIL_SPIRIT != talent && DRUID_IMPROVED_REJUVENATION != talent && DRUID_NATURES_SWIFTNESS != talent && DRUID_GIFT_OF_NATURE != talent && DRUID_IMPROVED_TRANQUILITY != talent && DRUID_EMPOWERED_TOUCH != talent && DRUID_NATURES_BOUNTY != talent && DRUID_LIVING_SPIRIT != talent && DRUID_SWIFTMEND != talent && DRUID_NATURAL_PERFECTION != talent && DRUID_EMPOWERED_REJUVENATION != talent && DRUID_LIVING_SEED != talent && DRUID_REVITALIZE != talent && DRUID_TREE_OF_LIFE != talent && DRUID_IMPROVED_TREE_OF_LIFE != talent && DRUID_IMPROVED_BARKSKIN != talent && DRUID_GIFT_OF_THE_EARTHMOTHER != talent && DRUID_WILD_GROWTH != talent && DRUID_STARLIGHT_WRATH != talent && DRUID_GENESIS != talent && DRUID_MOONGLOW != talent && DRUID_NATURES_MAJESTY != talent && DRUID_IMPROVED_MOONFIRE != talent && DRUID_BRAMBLES != talent && DRUID_NATURES_GRACE != talent && DRUID_NATURES_SPLENDOR_A != talent && DRUID_NATURES_REACH != talent && DRUID_VENGEANCE != talent && DRUID_CELESTIAL_FOCUS != talent && DRUID_LUNAR_GUIDANCE != talent && DRUID_INSECT_SWARM != talent && DRUID_IMPROVED_INSECT_SWARM != talent && DRUID_DREAMSTATE != talent && DRUID_MOONFURY != talent && DRUID_BALANCE_OF_POWER != talent && DRUID_MOONKIN_FORM != talent && DRUID_IMPROVED_MOONKIN_FORM != talent && DRUID_IMPROVED_FAERIE_FIRE != talent && DRUID_OWLKIN_FRENZY != talent && DRUID_WRATH_OF_CENARIUS != talent && DRUID_ECLIPSE != talent && DRUID_TYPHOON != talent && DRUID_FORCE_OF_NATURE != talent && DRUID_GALE_WINDS != talent && DRUID_EARTH_AND_MOON != talent && DRUID_STARFALL != talent)
+            return false;
+    }
+    else if (charClass == CLASS_HUNTER)
+    {
+        if (HUNTER_IMPROVED_ASPECT_OF_THE_HAWK != talent && HUNTER_ENDURANCE_TRAINING != talent && HUNTER_FOCUSED_FIRE != talent && HUNTER_IMPROVED_ASPECT_OF_THE_MONKEY != talent && HUNTER_THICK_HIDE != talent && HUNTER_IMPROVED_REVIVE_PET != talent && HUNTER_PATHFINDING != talent && HUNTER_ASPECT_MASTERY != talent && HUNTER_UNLEASHED_FURY != talent && HUNTER_IMPROVED_MEND_PET != talent && HUNTER_FEROCITY != talent && HUNTER_SPIRIT_BOND != talent && HUNTER_INTIMIDATION != talent && HUNTER_BESTIAL_DISCIPLINE != talent && HUNTER_ANIMAL_HANDLER != talent && HUNTER_FRENZY != talent && HUNTER_FEROCIOUS_INSPIRATION != talent && HUNTER_BESTIAL_WRATH != talent && HUNTER_CATLIKE_REFLEXES != talent && HUNTER_INVIGORATION != talent && HUNTER_SERPENTS_SWIFTNESS != talent && HUNTER_LONGEVITY != talent && HUNTER_THE_BEAST_WITHIN != talent && HUNTER_COBRA_STRIKES != talent && HUNTER_KINDRED_SPIRITS != talent && HUNTER_BEAST_MASTERY != talent && HUNTER_IMPROVED_TRACKING != talent && HUNTER_HAWK_EYE != talent && HUNTER_SAVAGE_STRIKES != talent && HUNTER_SUREFOOTED != talent && HUNTER_ENTRAPMENT != talent && HUNTER_TRAP_MASTERY != talent && HUNTER_SURVIVAL_INSTINCTS != talent && HUNTER_SURVIVALIST != talent && HUNTER_SCATTER_SHOT != talent && HUNTER_DEFLECTION != talent && HUNTER_SURVIVAL_TACTICS != talent && HUNTER_TNT != talent && HUNTER_LOCK_AND_LOAD != talent && HUNTER_HUNTER_VS_WILD != talent && HUNTER_KILLER_INSTINCT != talent && HUNTER_COUNTERATTACK != talent && HUNTER_LIGHTNING_REFLEXES != talent && HUNTER_RESOURCEFULNESS != talent && HUNTER_EXPOSE_WEAKNESS != talent && HUNTER_WYVERN_STING != talent && HUNTER_THRILL_OF_THE_HUNT != talent && HUNTER_MASTER_TACTICIAN != talent && HUNTER_NOXIOUS_STINGS != talent && HUNTER_POINT_OF_NO_ESCAPE != talent && HUNTER_BLACK_ARROW != talent && HUNTER_SNIPER_TRAINING != talent && HUNTER_HUNTING_PARTY != talent && HUNTER_EXPLOSIVE_SHOT != talent && HUNTER_IMPROVED_CONCUSSIVE_SHOT != talent && HUNTER_FOCUSED_AIM != talent && HUNTER_LETHAL_SHOTS != talent && HUNTER_CAREFUL_AIM != talent && HUNTER_IMPROVED_HUNTERS_MARK != talent && HUNTER_MORTAL_SHOTS != talent && HUNTER_GO_FOR_THE_THROAT != talent && HUNTER_IMPROVED_ARCANE_SHOT != talent && HUNTER_AIMED_SHOT != talent && HUNTER_RAPID_KILLING != talent && HUNTER_IMPROVED_STINGS != talent && HUNTER_EFFICIENCY != talent && HUNTER_CONCUSSIVE_BARRAGE != talent && HUNTER_READINESS != talent && HUNTER_BARRAGE != talent && HUNTER_COMBAT_EXPERIENCE != talent && HUNTER_RANGED_WEAPON_SPECIALIZATION != talent && HUNTER_PIERCING_SHOTS != talent && HUNTER_TRUESHOT_AURA != talent && HUNTER_IMPROVED_BARRAGE != talent && HUNTER_MASTER_MARKSMAN != talent && HUNTER_RAPID_RECUPERATION != talent && HUNTER_WILD_QUIVER != talent && HUNTER_SILENCING_SHOT != talent && HUNTER_IMPROVED_STEADY_SHOT != talent && HUNTER_MARKED_FOR_DEATH != talent && HUNTER_CHIMERA_SHOT != talent)
+            return false;
+    }
+    else if (charClass == CLASS_MAGE)
+    {
+        if (MAGE_IMPROVED_FIRE_BLAST != talent && MAGE_INCINERATION != talent && MAGE_IMPROVED_FIREBALL != talent && MAGE_IGNITE != talent && MAGE_BURNING_DETERMINATION != talent && MAGE_WORLD_IN_FLAMES != talent && MAGE_FLAME_THROWING != talent && MAGE_IMPACT != talent && MAGE_PYROBLAST != talent && MAGE_BURNING_SOUL != talent && MAGE_IMPROVED_SCORCH != talent && MAGE_MOLTEN_SHIELDS != talent && MAGE_MASTER_OF_ELEMENTS != talent && MAGE_PLAYING_WITH_FIRE != talent && MAGE_CRITICAL_MASS != talent && MAGE_BLAST_WAVE != talent && MAGE_BLAZING_SPEED != talent && MAGE_FIRE_POWER != talent && MAGE_PYROMANIAC != talent && MAGE_COMBUSTION != talent && MAGE_MOLTEN_FURY != talent && MAGE_FIERY_PAYBACK != talent && MAGE_EMPOWERED_FIRE != talent && MAGE_FIRESTARTER != talent && MAGE_DRAGONS_BREATH != talent && MAGE_HOT_STREAK != talent && MAGE_BURNOUT != talent && MAGE_LIVING_BOMB != talent && MAGE_FROSTBITE != talent && MAGE_IMPROVED_FROSTBOLT != talent && MAGE_ICE_FLOES != talent && MAGE_ICE_SHARDS != talent && MAGE_FROST_WARDING != talent && MAGE_PRECISION != talent && MAGE_PERMAFROST != talent && MAGE_PIERCING_ICE != talent && MAGE_ICY_VEINS != talent && MAGE_IMPROVED_BLIZZARD != talent && MAGE_ARCTIC_REACH != talent && MAGE_FROST_CHANNELING != talent && MAGE_SHATTER != talent && MAGE_COLD_SNAP != talent && MAGE_IMPROVED_CONE_OF_COLD != talent && MAGE_FROZEN_CORE != talent && MAGE_COLD_AS_ICE != talent && MAGE_WINTERS_CHILL != talent && MAGE_SHATTERED_BARRIER != talent && MAGE_ICE_BARRIER != talent && MAGE_ARCTIC_WINDS != talent && MAGE_EMPOWERED_FROSTBOLT != talent && MAGE_FINGERS_OF_FROST != talent && MAGE_BRAIN_FREEZE != talent && MAGE_SUMMON_WATER_ELEMENTAL != talent && MAGE_ENDURING_WINTER != talent && MAGE_CHILLD_TO_THE_BONE != talent && MAGE_DEEP_FREEZE != talent && MAGE_ARCANE_SUBTLETY != talent && MAGE_ARCANE_FOCUS != talent && MAGE_ARCANE_STABILITY != talent && MAGE_ARCANE_FORTITUDE != talent && MAGE_MAGIC_ABSORPTION != talent && MAGE_ARCANE_CONCENTRATION != talent && MAGE_MAGIC_ATTUNEMENT != talent && MAGE_SPELL_IMPACT != talent && MAGE_STUDENT_OF_THE_MIND != talent && MAGE_FOCUS_MAGIC != talent && MAGE_ARCANE_SHIELDING != talent && MAGE_IMPROVED_COUNTERSPELL != talent && MAGE_ARCANE_MEDITATION != talent && MAGE_TORMENT_THE_WEAK != talent && MAGE_IMPROVED_BLINK != talent && MAGE_PRESENCE_OF_MIND != talent && MAGE_ARCANE_MIND != talent && MAGE_PRISMATIC_CLOAK != talent && MAGE_ARCANE_INSTABILITY != talent && MAGE_ARCANE_POTENCY != talent && MAGE_ARCANE_EMPOWERMENT != talent && MAGE_ARCANE_POWER != talent && MAGE_INCANTERS_ABSORPTION != talent && MAGE_ARCANE_FLOWS != talent && MAGE_MIND_MASTERY != talent && MAGE_SLOW != talent && MAGE_MISSILE_BARRAGE != talent && MAGE_NETHERWIND_PRESENCE != talent && MAGE_SPELL_POWER != talent && MAGE_ARCANE_BARRAGE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PALADIN)
+    {
+        if (PALADIN_DEFLECTION != talent && PALADIN_BENEDICTION != talent && PALADIN_IMPROVED_JUDGEMENTS != talent && PALADIN_HEART_OF_THE_CRUSADER != talent && PALADIN_IMPROVED_BLESSING_OF_MIGHT != talent && PALADIN_VINDICATION != talent && PALADIN_CONVICTION != talent && PALADIN_SEAL_OF_COMMAND != talent && PALADIN_PURSUIT_OF_JUSTICE != talent && PALADIN_EYE_FOR_AN_EYE != talent && PALADIN_SANCTITY_OF_BATTLE != talent && PALADIN_CRUSADE != talent && PALADIN_TWOHANDED_WEAPON_SPECIALIZATION != talent && PALADIN_SANCTIFIED_RETRIBUTION != talent && PALADIN_VENGEANCE != talent && PALADIN_DIVINE_PURPOSE != talent && PALADIN_THE_ART_OF_WAR != talent && PALADIN_REPENTANCE != talent && PALADIN_JUDGEMENTS_OF_THE_WISE != talent && PALADIN_FANATICISM != talent && PALADIN_SANCTIFIED_WRATH != talent && PALADIN_SWIFT_RETRIBUTION != talent && PALADIN_CRUSADER_STRIKE != talent && PALADIN_SHEATH_OF_LIGHT != talent && PALADIN_RIGHTEOUS_VENGEANCE != talent && PALADIN_DIVINE_STORM != talent && PALADIN_SPIRITUAL_FOCUS != talent && PALADIN_SEALS_OF_THE_PURE != talent && PALADIN_HEALING_LIGHT != talent && PALADIN_DIVINE_INTELLECT != talent && PALADIN_UNYIELDING_FAITH != talent && PALADIN_AURA_MASTERY != talent && PALADIN_ILLUMINATION != talent && PALADIN_IMPROVED_LAY_ON_HANDS != talent && PALADIN_IMPROVED_CONCENTRATION_AURA != talent && PALADIN_IMPROVED_BLESSING_OF_WISDOM != talent && PALADIN_BLESSED_HANDS != talent && PALADIN_PURE_OF_HEART != talent && PALADIN_DIVINE_FAVOR != talent && PALADIN_SANCTIFIED_LIGHT != talent && PALADIN_PURIFYING_POWER != talent && PALADIN_HOLY_POWER != talent && PALADIN_LIGHTS_GRACE != talent && PALADIN_HOLY_SHOCK != talent && PALADIN_BLESSED_LIFE != talent && PALADIN_SACRED_CLEANSING != talent && PALADIN_HOLY_GUIDANCE != talent && PALADIN_DIVINE_ILLUMINATION != talent && PALADIN_JUDGEMENTS_OF_THE_PURE != talent && PALADIN_INFUSION_OF_LIGHT != talent && PALADIN_ENLIGHTENED_JUDGEMENTS != talent && PALADIN_BEACON_OF_LIGHT != talent && PALADIN_DIVINITY != talent && PALADIN_DIVINE_STRENGTH != talent && PALADIN_STOICISM != talent && PALADIN_GUARDIANS_FAVOR != talent && PALADIN_ANTICIPATION != talent && PALADIN_DIVINE_SACRIFICE != talent && PALADIN_IMPROVED_RIGHTEOUS_FURY != talent && PALADIN_TOUGHNESS != talent && PALADIN_DIVINE_GUARDIAN != talent && PALADIN_IMPROVED_HAMMER_OF_JUSTICE != talent && PALADIN_IMPROVED_DEVOTION_AURA != talent && PALADIN_BLESSING_OF_SANCTUARY != talent && PALADIN_RECKONING != talent && PALADIN_SACRED_DUTY != talent && PALADIN_ONEHANDED_WEAPON_SPECIALIZATION != talent && PALADIN_SPIRITUAL_ATTUNEMENT != talent && PALADIN_HOLY_SHIELD != talent && PALADIN_ARDENT_DEFENDER != talent && PALADIN_REDOUBT != talent && PALADIN_COMBAT_EXPERTISE != talent && PALADIN_TOUCHER_BY_THE_LIGHT != talent && PALADIN_AVENGERS_SHIELD != talent && PALADIN_GUARDED_BY_THE_LIGHT != talent && PALADIN_SHIELD_OF_THE_TEMPLAR != talent && PALADIN_JUDGEMENT_OF_THE_JUST != talent && PALADIN_HAMMER_OF_THE_RIGHTEOUS != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PRIEST)
+    {
+        if (PRIEST_UNBREAKABLE_WILL != talent && PRIEST_TWIN_DISCIPLINES != talent && PRIEST_SILENT_RESOLVE != talent && PRIEST_IMPROVED_INNER_FIRE != talent && PRIEST_IMPROVED_POWER_WORD_FORTITUDE != talent && PRIEST_MARTYRDOM != talent && PRIEST_MEDITATION != talent && PRIEST_INNER_FOCUS != talent && PRIEST_IMPROVED_POWER_WORD_SHIELD != talent && PRIEST_ABSOLUTION != talent && PRIEST_MENTAL_AGILITY != talent && PRIEST_IMPROVED_MANA_BURN != talent && PRIEST_REFLECTIVE_SHIELD != talent && PRIEST_MENTAL_STRENGTH != talent && PRIEST_SOUL_WARDING != talent && PRIEST_FOCUSED_POWER != talent && PRIEST_ENLIGHTENMENT != talent && PRIEST_FOCUSED_WILL != talent && PRIEST_POWER_INFUSION != talent && PRIEST_IMPROVED_FLASH_HEAL != talent && PRIEST_RENEWED_HOPE != talent && PRIEST_RAPTURE != talent && PRIEST_ASPIRATION != talent && PRIEST_DIVINE_AEGIS != talent && PRIEST_PAIN_SUPPRESSION != talent && PRIEST_GRACE != talent && PRIEST_BORROWED_TIME != talent && PRIEST_PENANCE != talent && PRIEST_HEALING_FOCUS != talent && PRIEST_IMPROVED_RENEW != talent && PRIEST_HOLY_SPECIALIZATION != talent && PRIEST_SPELL_WARDING != talent && PRIEST_DIVINE_FURY != talent && PRIEST_DESPERATE_PRAYER != talent && PRIEST_BLESSED_RECOVERY != talent && PRIEST_INSPIRATION != talent && PRIEST_HOLY_REACH != talent && PRIEST_IMPROVED_HEALIN != talent && PRIEST_SEARING_LIGHT != talent && PRIEST_HEALING_PRAYERS != talent && PRIEST_SPIRIT_OF_REDEMPTION != talent && PRIEST_SPIRITUAL_GUIDANCE != talent && PRIEST_SURGE_OF_LIGHT != talent && PRIEST_SPIRITUAL_HEALING != talent && PRIEST_HOLY_CONCENTRATION != talent && PRIEST_LIGHTWELL != talent && PRIEST_BLESSED_RESILIENCE != talent && PRIEST_BODY_AND_SOUL != talent && PRIEST_EMPOWERED_HEALING != talent && PRIEST_SERENDIPITY != talent && PRIEST_EMPOWERED_RENEW != talent && PRIEST_CIRCLE_OF_HEALING != talent && PRIEST_TEST_OF_FAITH != talent && PRIEST_DIVINE_PROVIDENCE != talent && PRIEST_GUARDIAN_SPIRIT != talent && PRIEST_SPIRIT_TAP != talent && PRIEST_IMPROVED_SPIRIT_TAP != talent && PRIEST_DARKNESS != talent && PRIEST_SHADOW_AFFINITY != talent && PRIEST_IMPROVED_SHADOW_WORD_PAIN != talent && PRIEST_SHADOW_FOCUS != talent && PRIEST_IMPROVED_PSYCHIC_SCREAM != talent && PRIEST_IMPROVED_MIND_BLAST != talent && PRIEST_MIND_FLAY != talent && PRIEST_VEILED_SHADOWS != talent && PRIEST_SHADOW_REACH != talent && PRIEST_SHADOW_WEAVING != talent && PRIEST_SILENCE != talent && PRIEST_VAMPIRIC_EMBRACE != talent && PRIEST_IMPROVED_VAMPIRIC_EMBRACE != talent && PRIEST_FOCUSED_MIND != talent && PRIEST_MIND_MELT != talent && PRIEST_IMPROVED_DEVOURING_PLAGUE != talent && PRIEST_SHADOWFORM != talent && PRIEST_SHADOW_POWER != talent && PRIEST_IMPROVED_SHADOWFORM != talent && PRIEST_MISERY != talent && PRIEST_PSYCHIC_HORROR != talent && PRIEST_VAMPIRIC_TOUCH != talent && PRIEST_PAIN_AND_SUFFERING != talent && PRIEST_TWISTED_FAITH != talent && PRIEST_DISPERSION != talent)
+            return false;
+    }
+    else if (charClass == CLASS_ROGUE)
+    {
+        if (ROGUE_IMPROVED_GOUGE != talent && ROGUE_IMPROVED_SINISTER_STRIKE != talent && ROGUE_DUAL_WIELD_SPECIALIZATION != talent && ROGUE_IMPROVED_SLICE_AND_DICE != talent && ROGUE_DEFLECTION != talent && ROGUE_PRECISION != talent && ROGUE_ENDURANCE != talent && ROGUE_RIPOSTE != talent && ROGUE_CLOSE_QUARTERS_COMBAT != talent && ROGUE_IMPROVED_KICK != talent && ROGUE_IMPROVED_SPRINT != talent && ROGUE_LIGHTNING_REFLEXES != talent && ROGUE_AGGRESSION != talent && ROGUE_MACE_SPECIALIZATION != talent && ROGUE_BLADE_FLURRY != talent && ROGUE_HACK_AND_SLASH != talent && ROGUE_WEAPON_EXPERTISE != talent && ROGUE_BLADE_TWISTING != talent && ROGUE_VITALITY != talent && ROGUE_ADRENALINE_RUSH != talent && ROGUE_NERVES_OF_STEEL != talent && ROGUE_THROWING_SPECIALIZATION != talent && ROGUE_COMBAT_POTENCY != talent && ROGUE_UNFAIR_ADVANTAGE != talent && ROGUE_SURPRISE_ATTACKS != talent && ROGUE_SAVAGE_COMBAT != talent && ROGUE_PREY_ON_THE_WEAK != talent && ROGUE_KILLING_SPREE != talent && ROGUE_IMPROVED_EVISCERATE != talent && ROGUE_REMORSELESS_ATTACKS != talent && ROGUE_MALICE != talent && ROGUE_RUTHLESSNESS != talent && ROGUE_BLOOD_SPATTER != talent && ROGUE_PUNCTURING_WOUNDS != talent && ROGUE_VIGOR != talent && ROGUE_IMPROVED_EXPOSE_ARMOR != talent && ROGUE_LETHALITY != talent && ROGUE_VILE_POISONS != talent && ROGUE_IMPROVED_POISONS != talent && ROGUE_FLEET_FOOTED != talent && ROGUE_COLD_BLOOD != talent && ROGUE_IMPROVED_KIDNEY_SHOT != talent && ROGUE_QUICK_RECOVERY != talent && ROGUE_SEAL_FATE != talent && ROGUE_MURDER != talent && ROGUE_DEADLY_BREW != talent && ROGUE_OVERKILL != talent && ROGUE_DEADENED_NERVES != talent && ROGUE_FOCUSED_ATTACKS != talent && ROGUE_FIND_WEAKNESS != talent && ROGUE_MASTER_POISONER != talent && ROGUE_MUTILATE != talent && ROGUE_TURN_THE_TABLES != talent && ROGUE_CUT_TO_THE_CHASE != talent && ROGUE_HUNGER_FOR_BLOOD != talent && ROGUE_RELENTLESS_STRIKES != talent && ROGUE_MASTER_OF_DECEPTION != talent && ROGUE_OPPORTUNITY != talent && ROGUE_SLEIGHT_OF_HAND != talent && ROGUE_DIRTY_TRICKS != talent && ROGUE_CAMOUFLAGE != talent && ROGUE_ELUSIVENESS != talent && ROGUE_GHOSTLY_STRIKE != talent && ROGUE_SERRATED_BLADES != talent && ROGUE_SETUP != talent && ROGUE_INITIATIVE != talent && ROGUE_IMPROVED_AMBUSH != talent && ROGUE_HEIGHTENED_SENSES != talent && ROGUE_PREPARATION != talent && ROGUE_DIRTY_DEEDS != talent && ROGUE_HEMORRHAGE != talent && ROGUE_MASTER_OF_SUBTLETY != talent && ROGUE_DEADLINESS != talent && ROGUE_ENVELOPING_SHADOWS != talent && ROGUE_PREMEDITATION != talent && ROGUE_CHEAT_DEATH != talent && ROGUE_SINISTER_CALLING != talent && ROGUE_WAYLAY != talent && ROGUE_HONOR_AMONG_THIEVES != talent && ROGUE_SHADOWSTEP != talent && ROGUE_FILTHY_TRICKS != talent && ROGUE_SLAUGHTER_FROM_THE_SHADOWS != talent && ROGUE_SHADOW_DANCE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_SHAMAN)
+    {
+        if (SHAMAN_CONVECTION != talent && SHAMAN_CONCUSSION != talent && SHAMAN_CALL_OF_FLAME != talent && SHAMAN_ELEMENTAL_WARDING != talent && SHAMAN_ELEMENTAL_DEVASTATION != talent && SHAMAN_REVERBERATION != talent && SHAMAN_ELEMENTAL_FOCUS != talent && SHAMAN_ELEMENTAL_FURY != talent && SHAMAN_IMPROVED_FIRE_NOVA != talent && SHAMAN_EYE_OF_THE_STORM != talent && SHAMAN_ELEMENTAL_REACH != talent && SHAMAN_CALL_OF_THUNDER != talent && SHAMAN_UNRELENTING_STORM != talent && SHAMAN_ELEMENTAL_PRECISION != talent && SHAMAN_LIGHTNING_MASTERY != talent && SHAMAN_ELEMENTAL_MASTERY != talent && SHAMAN_STORM_EARTH_AND_FIRE != talent && SHAMAN_BOOMING_ECHOES != talent && SHAMAN_ELEMENTAL_OATH != talent && SHAMAN_LIGHTNING_OVERLOAD != talent && SHAMAN_ASTRAL_SHIFT != talent && SHAMAN_TOTEM_OF_WRATH != talent && SHAMAN_LAVA_FLOWS != talent && SHAMAN_SHAMANISM != talent && SHAMAN_THUNDERSTORM != talent && SHAMAN_IMPROVED_HEALING_WAVE != talent && SHAMAN_TOTEMIC_FOCUS != talent && SHAMAN_IMPROVED_REINCARNATION != talent && SHAMAN_HEALING_GRACE != talent && SHAMAN_TIDAL_FOCUS != talent && SHAMAN_IMPROVED_WATER_SHIELD != talent && SHAMAN_HEALING_FOCUS != talent && SHAMAN_TIDAL_FORCE != talent && SHAMAN_ANCESTRAL_HEALING != talent && SHAMAN_RESTORATIVE_TOTEMS != talent && SHAMAN_TIDAL_MASTERY != talent && SHAMAN_HEALING_WAY != talent && SHAMAN_NATURES_SWIFTNESS != talent && SHAMAN_FOCUSED_MIND != talent && SHAMAN_PURIFICATION != talent && SHAMAN_NATURES_GUARDIAN != talent && SHAMAN_MANA_TIDE_TOTEM != talent && SHAMAN_CLEANSE_SPIRIT != talent && SHAMAN_BLESSING_OF_THE_ETERNALS != talent && SHAMAN_IMPROVED_CHAIN_HEAL != talent && SHAMAN_NATURES_BLESSING != talent && SHAMAN_ANCESTRAL_AWAKENING != talent && SHAMAN_EARTH_SHIELD != talent && SHAMAN_IMPROVED_EARTH_SHIELD != talent && SHAMAN_TIDAL_WAVES != talent && SHAMAN_RIPTIDE != talent && SHAMAN_ENHANCING_TOTEMS != talent && SHAMAN_EARTHS_GRASP != talent && SHAMAN_ANCESTRAL_KNOWLEDGE != talent && SHAMAN_GUARDIAN_TOTEMS != talent && SHAMAN_THUNDERING_STRIKES != talent && SHAMAN_IMPROVED_GHOST_WOLF != talent && SHAMAN_IMPROVED_SHIELDS != talent && SHAMAN_ELEMENTAL_WEAPONS != talent && SHAMAN_SHAMANISTIC_FOCUS != talent && SHAMAN_ANTICIPATION != talent && SHAMAN_FLURRY != talent && SHAMAN_TOUGHNESS != talent && SHAMAN_IMPROVED_WINDFURY_TOTEM != talent && SHAMAN_SPIRIT_WEAPONS != talent && SHAMAN_MENTAL_DEXTERITY != talent && SHAMAN_UNLEASHED_RAGE != talent && SHAMAN_WEAPON_MASTERY != talent && SHAMAN_FROZEN_POWER != talent && SHAMAN_DUAL_WIELD_SPECIALIZATION != talent && SHAMAN_DUAL_WIELD != talent && SHAMAN_STORMSTRIKE != talent && SHAMAN_STATIC_SHOCK != talent && SHAMAN_LAVA_LASH != talent && SHAMAN_IMPROVED_STORMSTRIKE != talent && SHAMAN_MENTAL_QUICKNESS != talent && SHAMAN_SHAMANISTIC_RAGE != talent && SHAMAN_EARTHEN_POWER != talent && SHAMAN_MAELSTROM_WEAPON != talent && SHAMAN_FERAL_SPIRIT != talent)
+            return false;
+    }
+    else if (charClass == CLASS_WARLOCK)
+    {
+        if (WARLOCK_IMPROVED_SHADOW_BOLT != talent && WARLOCK_BANE != talent && WARLOCK_AFTERMATH != talent && WARLOCK_MOLTEN_SKIN != talent && WARLOCK_CATACLYSM != talent && WARLOCK_DEMONIC_POWER != talent && WARLOCK_SHADOWBURN != talent && WARLOCK_RUIN != talent && WARLOCK_INTENSITY != talent && WARLOCK_DESTRUCTIVE_REACH != talent && WARLOCK_IMPROVED_SEARING_PAIN != talent && WARLOCK_BACKLASH != talent && WARLOCK_IMPROVED_IMMOLATE != talent && WARLOCK_DEVASTATION != talent && WARLOCK_NETHER_PROTECTION != talent && WARLOCK_EMBERSTORM != talent && WARLOCK_CONFLAGRATE != talent && WARLOCK_SOUL_LEECH != talent && WARLOCK_PYROCLASM != talent && WARLOCK_SHADOW_AND_FLAME != talent && WARLOCK_IMPROVED_SOUL_LEECH != talent && WARLOCK_BACKDRAFT != talent && WARLOCK_SHADOWFURY != talent && WARLOCK_EMPOWERED_IMP != talent && WARLOCK_FIRE_AND_BRIMSTONE != talent && WARLOCK_CHAOS_BOLT != talent && WARLOCK_IMPROVED_CURSE_OF_AGONY != talent && WARLOCK_SUPPRESSION != talent && WARLOCK_IMPROVED_CORRUPTION != talent && WARLOCK_IMPROVED_CURSE_OF_WEAKNESS != talent && WARLOCK_IMPROVED_DRAIN_SOUL != talent && WARLOCK_IMPROVED_LIFE_TAP != talent && WARLOCK_SOUL_SIPHON != talent && WARLOCK_IMPROVED_FEAR != talent && WARLOCK_FEL_CONCENTRATION != talent && WARLOCK_AMPLIFY_CURSE != talent && WARLOCK_GRIM_REACH != talent && WARLOCK_NIGHTFALL != talent && WARLOCK_EMPOWERED_CORRUPTION != talent && WARLOCK_SHADOW_EMBRACE != talent && WARLOCK_SIPHON_LIFE != talent && WARLOCK_CURSE_OF_EXHAUSTION != talent && WARLOCK_IMPROVED_FELHUNTER != talent && WARLOCK_SHADOW_MASTERY != talent && WARLOCK_ERADICATION != talent && WARLOCK_CONTAGION != talent && WARLOCK_DARK_PACT != talent && WARLOCK_IMPROVED_HOWL_OF_TERROR != talent && WARLOCK_MALEDICTION != talent && WARLOCK_DEATHS_EMBRACE != talent && WARLOCK_UNSTABLE_AFFLICTION != talent && WARLOCK_PANDEMIC != talent && WARLOCK_EVERLASTING_AFFLICTION != talent && WARLOCK_HAUNT != talent && WARLOCK_IMPROVED_HEALTHSTONE != talent && WARLOCK_IMPROVED_IMP != talent && WARLOCK_DEMONIC_EMBRACE != talent && WARLOCK_FEL_SYNERGY != talent && WARLOCK_IMPROVED_HEALTH_FUNNEL != talent && WARLOCK_DEMONIC_BRUTALITY != talent && WARLOCK_FEL_VITALITY != talent && WARLOCK_IMPROVED_SUCCUBUS != talent && WARLOCK_SOUL_LINK != talent && WARLOCK_FEL_DOMINATION != talent && WARLOCK_DEMONIC_AEGIS != talent && WARLOCK_UNHOLY_POWER != talent && WARLOCK_MASTER_SUMMONER != talent && WARLOCK_MANA_FEED != talent && WARLOCK_MASTER_CONJURER != talent && WARLOCK_MASTER_DEMONOLOGIST != talent && WARLOCK_MOLTEN_CORE != talent && WARLOCK_DEMONIC_RESILIENCE != talent && WARLOCK_DEMONIC_EMPOWERMENT != talent && WARLOCK_DEMONIC_KNOWLEDGE != talent && WARLOCK_DEMONIC_TACTICS != talent && WARLOCK_DECIMATION != talent && WARLOCK_IMPROVED_DEMONIC_TACTICS != talent && WARLOCK_SUMMON_FELGUARD != talent && WARLOCK_NEMESIS != talent && WARLOCK_DEMONIC_PACT != talent && WARLOCK_METAMORPHOSIS != talent)
+            return false;
+    }
+    else if (charClass == CLASS_WARRIOR)
+    {
+        if (WARRIOR_IMPROVED_HEROIC_STRIKE != talent && WARRIOR_DEFLECTION != talent && WARRIOR_IMPROVED_REND != talent && WARRIOR_IMPROVED_CHARGE != talent && WARRIOR_IRON_WILL != talent && WARRIOR_TACTICAL_MASTERY != talent && WARRIOR_IMPROVED_OVERPOWER != talent && WARRIOR_ANGER_MANAGEMENT != talent && WARRIOR_IMPALE != talent && WARRIOR_DEEP_WOUNDS != talent && WARRIOR_TWOHANDED_WEAPON_SPECIALIZATION != talent && WARRIOR_TASTE_FOR_BLOOD != talent && WARRIOR_POLEAXE_SPECIALIZATION != talent && WARRIOR_SWEEPING_STRIKES != talent && WARRIOR_MACE_SPECIALIZATION != talent && WARRIOR_SWORD_SPECIALIZATION != talent && WARRIOR_WEAPON_MASTERY != talent && WARRIOR_IMPROVED_HAMSTRING != talent && WARRIOR_TRAUMA != talent && WARRIOR_SECOND_WIND != talent && WARRIOR_MORTAL_STRIKE != talent && WARRIOR_STRENGTH_OF_ARMS != talent && WARRIOR_IMPROVED_SLAM != talent && WARRIOR_JUGGERNAUT != talent && WARRIOR_IMPROVED_MORTAL_STRIKE != talent && WARRIOR_UNRELENTING_ASSAULT != talent && WARRIOR_SUDDEN_DEATH != talent && WARRIOR_ENDLESS_RAGE != talent && WARRIOR_BLOOD_FRENZY != talent && WARRIOR_WRECKING_CREW != talent && WARRIOR_BLADESTORM != talent && WARRIOR_IMPROVED_BLOODRAGE != talent && WARRIOR_SHIELD_SPECIALIZATION != talent && WARRIOR_IMPROVED_THUNDER_CLAP != talent && WARRIOR_INCITE != talent && WARRIOR_ANTICIPATION != talent && WARRIOR_LAST_STAND != talent && WARRIOR_IMPROVED_REVENGE != talent && WARRIOR_SHIELD_MASTERY != talent && WARRIOR_TOUGHNESS != talent && WARRIOR_IMPROVED_SPELL_REFLECTION != talent && WARRIOR_IMPROVED_DISARM != talent && WARRIOR_PUNCTURE != talent && WARRIOR_IMPROVED_DISCIPLINES != talent && WARRIOR_CONCUSSION_BLOW != talent && WARRIOR_GAG_ORDER != talent && WARRIOR_ONEHANDED_WEAPON_SPECIALIZATION != talent && WARRIOR_IMPROVED_DEFENSIVE_STANCE != talent && WARRIOR_VIGILANCE != talent && WARRIOR_FOCUSED_RAGE != talent && WARRIOR_VITALITY != talent && WARRIOR_SAFEGUARD != talent && WARRIOR_WARBRINGER != talent && WARRIOR_DEVASTATE != talent && WARRIOR_CRITICAL_BLOCK != talent && WARRIOR_SWORD_AND_BOARD != talent && WARRIOR_DAMAGE_SHIELD != talent && WARRIOR_SHOCKWAVE != talent && WARRIOR_ARMORED_TO_THE_TEETH != talent && WARRIOR_BOOMING_VOICE != talent && WARRIOR_CRUELTY != talent && WARRIOR_IMPROVED_DEMORALIZING_SHOUT != talent && WARRIOR_UNBRIDLED_WRATH != talent && WARRIOR_IMPROVED_CLEAVE != talent && WARRIOR_PIERCING_HOWL != talent && WARRIOR_BLOOD_CRAZE != talent && WARRIOR_COMMANDING_PRESENCE != talent && WARRIOR_DUAL_WIELD_SPECIALIZATION != talent && WARRIOR_IMPROVED_EXECUTE != talent && WARRIOR_ENRAGE != talent && WARRIOR_PRECISION != talent && WARRIOR_DEATH_WISH != talent && WARRIOR_IMPROVED_INTERCEPT != talent && WARRIOR_IMPROVED_BERSERKER_RAGE != talent && WARRIOR_FLURRY != talent && WARRIOR_INTENSIFY_RAGE != talent && WARRIOR_BLOODTHIRST != talent && WARRIOR_IMPROVED_WHIRLWIND != talent && WARRIOR_FURIOUS_ATTACKS != talent && WARRIOR_IMPROVED_BERSERKER_STANCE != talent && WARRIOR_HEROIC_FURY != talent && WARRIOR_RAMPAGE != talent && WARRIOR_BLOODSURGE != talent && WARRIOR_UNENDING_FURY != talent && WARRIOR_TITANS_GRIP != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PET_CUNNING)
+    {
+        if (PET_CUNNING_COBRA_REFLEXES != talent && PET_CUNNING_DASHDIVE1 != talent && PET_CUNNING_DASHDIVE2 != talent && PET_CUNNING_GREAT_STAMINA != talent && PET_CUNNING_NATURAL_ARMOR != talent && PET_CUNNING_BOARS_SPEED != talent && PET_CUNNING_MOBILITY1 != talent && PET_CUNNING_MOBILITY2 != talent && PET_CUNNING_OWLS_FOCUS != talent && PET_CUNNING_SPIKED_COLLAR != talent && PET_CUNNING_CULLING_THE_HERD != talent && PET_CUNNING_LIONHEARTED != talent && PET_CUNNING_CARRION_FEEDER != talent && PET_CUNNING_GREAT_RESISTANCE != talent && PET_CUNNING_CORNERED != talent && PET_CUNNING_FEEDING_FRENZY != talent && PET_CUNNING_WOLVERINE_BITE != talent && PET_CUNNING_ROAR_OF_RECOVERY != talent && PET_CUNNING_BULLHEADED != talent && PET_CUNNING_GRACE_OF_THE_MANTIS != talent && PET_CUNNING_WILD_HUNT != talent && PET_CUNNING_ROAR_OF_SACRIFICE != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PET_FEROCITY)
+    {
+        if (PET_FEROCITY_COBRA_REFLEXES != talent && PET_FEROCITY_DASHDIVE1 != talent && PET_FEROCITY_DASHDIVE2 != talent && PET_FEROCITY_GREAT_STAMINA != talent && PET_FEROCITY_NATURAL_ARMOR != talent && PET_FEROCITY_IMPROVED_COWER != talent && PET_FEROCITY_BLOODTHIRSTY != talent && PET_FEROCITY_SPIKED_COLLAR != talent && PET_FEROCITY_BOARS_SPEED != talent && PET_FEROCITY_CULLING_THE_HERD != talent && PET_FEROCITY_LIONHEARTED != talent && PET_FEROCITY_CHARGESWOOP1 != talent && PET_FEROCITY_CHARGESWOOP2 != talent && PET_FEROCITY_HEART_OF_THE_PHOENIX != talent && PET_FEROCITY_SPIDERS_BITE != talent && PET_FEROCITY_GREAT_RESISTANCE != talent && PET_FEROCITY_RABID != talent && PET_FEROCITY_LICK_YOUR_WOUNDS != talent && PET_FEROCITY_CALL_OF_THE_WILD != talent && PET_FEROCITY_SHARK_ATTACK != talent && PET_FEROCITY_WILD_HUNT != talent)
+            return false;
+    }
+    else if (charClass == CLASS_PET_TENACITY)
+    {
+        if (PET_TENACITY_COBRA_REFLEXES != talent && PET_TENACITY_CHARGE != talent && PET_TENACITY_GREAT_STAMINA != talent && PET_TENACITY_NATURAL_ARMOR != talent && PET_TENACITY_SPIKED_COLLAR != talent && PET_TENACITY_BOARS_SPEED != talent && PET_TENACITY_BLOOD_OF_THE_RHINO != talent && PET_TENACITY_PET_BARDING != talent && PET_TENACITY_CULLING_THE_HERD != talent && PET_TENACITY_GUARD_DOG != talent && PET_TENACITY_LIONHEARTED != talent && PET_TENACITY_THUNDERSTOMP != talent && PET_TENACITY_GRACE_OF_THE_MANTIS != talent && PET_TENACITY_GREAT_RESISTANCE != talent && PET_TENACITY_LAST_STAND != talent && PET_TENACITY_TAUNT != talent && PET_TENACITY_ROAR_OF_SACRIFICE != talent && PET_TENACITY_INTERVENE != talent && PET_TENACITY_SILVERBACK != talent && PET_TENACITY_WILD_HUNT != talent)
+            return false;
+    }
+    else // charClass unknown
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone was naughty and supplied an invalid class to ValidateTalent: %u", (uint32) charClass);
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * ValidateGlyph tests a glyph against class to see if it belongs to that class - accepts both Major and Minor glyphs
+ *
+ * uint16 glyph:        glyph ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid glyph for that class
+ */
+bool PlayerbotAI::ValidateGlyph(uint16 glyph, long charClass)
+{
+    // XOR the two helper functions. Both true (supposedly impossible) or both false -> false
+    return ValidateMajorGlyph(glyph, charClass) ^ ValidateMinorGlyph(glyph, charClass);
+}
+
+/**
+ * ValidateMajorGlyph tests a glyph against class to see if it belongs to that class - only accepts Major glyphs
+ *
+ * uint16 glyph:        glyph ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid major glyph for that class
+ */
+bool PlayerbotAI::ValidateMajorGlyph(uint16 glyph, long charClass)
+{
+    if (charClass == CLASS_DEATH_KNIGHT)
+    {
+        // this looong 'if' is to see if any glyph is not a Death Knight glyph when the class clearly is
+        if (DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_COMMAND != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_ANTIMAGIC_SHELL != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_HEART_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_BONE_SHIELD != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_CHAINS_OF_ICE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_GRIP != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_AND_DECAY != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_FROST_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_ICEBOUND_FORTITUDE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_ICY_TOUCH != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_OBLITERATE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_PLAGUE_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_THE_GHOUL != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_SCOURGE_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_STRANGULATE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_UNBREAKABLE_ARMOR != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_VAMPIRIC_BLOOD != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_TAP != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_BLOOD_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_STRIKE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DANCING_RUNE_WEAPON != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_HUNGERING_COLD != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_UNHOLY_BLIGHT != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_DEATH != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_DISEASE != glyph && DEATH_KNIGHT_MAJOR_GLYPH_OF_HOWLING_BLAST != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_DRUID)
+    {
+        if (DRUID_MAJOR_GLYPH_OF_FRENZIED_REGENERATION != glyph && DRUID_MAJOR_GLYPH_OF_MAUL != glyph && DRUID_MAJOR_GLYPH_OF_MANGLE != glyph && DRUID_MAJOR_GLYPH_OF_SHRED != glyph && DRUID_MAJOR_GLYPH_OF_RIP != glyph && DRUID_MAJOR_GLYPH_OF_RAKE != glyph && DRUID_MAJOR_GLYPH_OF_SWIFTMEND != glyph && DRUID_MAJOR_GLYPH_OF_INNERVATE != glyph && DRUID_MAJOR_GLYPH_OF_REBIRTH != glyph && DRUID_MAJOR_GLYPH_OF_REGROWTH != glyph && DRUID_MAJOR_GLYPH_OF_REJUVENATION != glyph && DRUID_MAJOR_GLYPH_OF_HEALING_TOUCH != glyph && DRUID_MAJOR_GLYPH_OF_LIFEBLOOM != glyph && DRUID_MAJOR_GLYPH_OF_STARFIRE != glyph && DRUID_MAJOR_GLYPH_OF_INSECT_SWARM != glyph && DRUID_MAJOR_GLYPH_OF_HURRICANE != glyph && DRUID_MAJOR_GLYPH_OF_STARFALL != glyph && DRUID_MAJOR_GLYPH_OF_WRATH != glyph && DRUID_MAJOR_GLYPH_OF_MOONFIRE != glyph && DRUID_MAJOR_GLYPH_OF_ENTANGLING_ROOTS != glyph && DRUID_MAJOR_GLYPH_OF_FOCUS != glyph && DRUID_MAJOR_GLYPH_OF_BERSERK != glyph && DRUID_MAJOR_GLYPH_OF_WILD_GROWTH != glyph && DRUID_MAJOR_GLYPH_OF_NOURISH != glyph && DRUID_MAJOR_GLYPH_OF_SAVAGE_ROAR != glyph && DRUID_MAJOR_GLYPH_OF_MONSOON != glyph && DRUID_MAJOR_GLYPH_OF_BARKSKIN != glyph && DRUID_MAJOR_GLYPH_OF_SURVIVAL_INSTINCTS != glyph && DRUID_MAJOR_GLYPH_OF_CLAW != glyph && DRUID_MAJOR_GLYPH_OF_RAPID_REJUVENATION != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_HUNTER)
+    {
+        if (HUNTER_MAJOR_GLYPH_OF_AIMED_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_ARCANE_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_THE_BEAST != glyph && HUNTER_MAJOR_GLYPH_OF_MENDING != glyph && HUNTER_MAJOR_GLYPH_OF_ASPECT_OF_THE_VIPER != glyph && HUNTER_MAJOR_GLYPH_OF_BESTIAL_WRATH != glyph && HUNTER_MAJOR_GLYPH_OF_DETERRENCE != glyph && HUNTER_MAJOR_GLYPH_OF_DISENGAGE != glyph && HUNTER_MAJOR_GLYPH_OF_FREEZING_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_FROST_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_HUNTERS_MARK != glyph && HUNTER_MAJOR_GLYPH_OF_IMMOLATION_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_MULTISHOT != glyph && HUNTER_MAJOR_GLYPH_OF_RAPID_FIRE != glyph && HUNTER_MAJOR_GLYPH_OF_SERPENT_STING != glyph && HUNTER_MAJOR_GLYPH_OF_SNAKE_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_STEADY_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_TRUESHOT_AURA != glyph && HUNTER_MAJOR_GLYPH_OF_VOLLEY != glyph && HUNTER_MAJOR_GLYPH_OF_WYVERN_STING != glyph && HUNTER_MAJOR_GLYPH_OF_CHIMERA_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_KILL_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_TRAP != glyph && HUNTER_MAJOR_GLYPH_OF_SCATTER_SHOT != glyph && HUNTER_MAJOR_GLYPH_OF_RAPTOR_STRIKE != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_MAGE)
+    {
+        if (MAGE_MAJOR_GLYPH_OF_ARCANE_EXPLOSION != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_MISSILES != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_POWER != glyph && MAGE_MAJOR_GLYPH_OF_BLINK != glyph && MAGE_MAJOR_GLYPH_OF_EVOCATION != glyph && MAGE_MAJOR_GLYPH_OF_FIREBALL != glyph && MAGE_MAJOR_GLYPH_OF_FIRE_BLAST != glyph && MAGE_MAJOR_GLYPH_OF_FROST_NOVA != glyph && MAGE_MAJOR_GLYPH_OF_FROSTBOLT != glyph && MAGE_MAJOR_GLYPH_OF_ICE_ARMOR != glyph && MAGE_MAJOR_GLYPH_OF_ICE_BLOCK != glyph && MAGE_MAJOR_GLYPH_OF_ICE_LANCE != glyph && MAGE_MAJOR_GLYPH_OF_ICY_VEINS != glyph && MAGE_MAJOR_GLYPH_OF_SCORCH != glyph && MAGE_MAJOR_GLYPH_OF_INVISIBILITY != glyph && MAGE_MAJOR_GLYPH_OF_MAGE_ARMOR != glyph && MAGE_MAJOR_GLYPH_OF_MANA_GEM != glyph && MAGE_MAJOR_GLYPH_OF_MOLTEN_ARMOR != glyph && MAGE_MAJOR_GLYPH_OF_POLYMORPH != glyph && MAGE_MAJOR_GLYPH_OF_REMOVE_CURSE != glyph && MAGE_MAJOR_GLYPH_OF_WATER_ELEMENTAL != glyph && MAGE_MAJOR_GLYPH_OF_FROSTFIRE != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_BLAST != glyph && MAGE_MAJOR_GLYPH_OF_DEEP_FREEZE != glyph && MAGE_MAJOR_GLYPH_OF_LIVING_BOMB != glyph && MAGE_MAJOR_GLYPH_OF_ARCANE_BARRAGE != glyph && MAGE_MAJOR_GLYPH_OF_MIRROR_IMAGE != glyph && MAGE_MAJOR_GLYPH_OF_ICE_BARRIER != glyph && MAGE_MAJOR_GLYPH_OF_ETERNAL_WATER != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PALADIN)
+    {
+        if (PALADIN_MAJOR_GLYPH_OF_JUDGEMENT != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_COMMAND != glyph && PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_JUSTICE != glyph && PALADIN_MAJOR_GLYPH_OF_SPIRITUAL_ATTUNEMENT != glyph && PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_WRATH != glyph && PALADIN_MAJOR_GLYPH_OF_CRUSADER_STRIKE != glyph && PALADIN_MAJOR_GLYPH_OF_CONSECRATION != glyph && PALADIN_MAJOR_GLYPH_OF_RIGHTEOUS_DEFENSE != glyph && PALADIN_MAJOR_GLYPH_OF_AVENGERS_SHIELD != glyph && PALADIN_MAJOR_GLYPH_OF_TURN_EVIL != glyph && PALADIN_MAJOR_GLYPH_OF_EXORCISM != glyph && PALADIN_MAJOR_GLYPH_OF_CLEANSING != glyph && PALADIN_MAJOR_GLYPH_OF_FLASH_OF_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_HOLY_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_AVENGING_WRATH != glyph && PALADIN_MAJOR_GLYPH_OF_DIVINITY != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_WISDOM != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_HOLY_WRATH != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_RIGHTEOUSNESS != glyph && PALADIN_MAJOR_GLYPH_OF_SEAL_OF_VENGEANCE != glyph && PALADIN_MAJOR_GLYPH_OF_BEACON_OF_LIGHT != glyph && PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_THE_RIGHTEOUS != glyph && PALADIN_MAJOR_GLYPH_OF_DIVINE_STORM != glyph && PALADIN_MAJOR_GLYPH_OF_SHIELD_OF_RIGHTEOUSNESS != glyph && PALADIN_MAJOR_GLYPH_OF_DIVINE_PLEA != glyph && PALADIN_MAJOR_GLYPH_OF_HOLY_SHOCK != glyph && PALADIN_MAJOR_GLYPH_OF_SALVATION != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PRIEST)
+    {
+        if (PRIEST_MAJOR_GLYPH_OF_CIRCLE_OF_HEALING != glyph && PRIEST_MAJOR_GLYPH_OF_DISPEL_MAGIC != glyph && PRIEST_MAJOR_GLYPH_OF_FADE != glyph && PRIEST_MAJOR_GLYPH_OF_FEAR_WARD != glyph && PRIEST_MAJOR_GLYPH_OF_FLASH_HEAL != glyph && PRIEST_MAJOR_GLYPH_OF_HOLY_NOVA != glyph && PRIEST_MAJOR_GLYPH_OF_INNER_FIRE != glyph && PRIEST_MAJOR_GLYPH_OF_LIGHTWELL != glyph && PRIEST_MAJOR_GLYPH_OF_MASS_DISPEL != glyph && PRIEST_MAJOR_GLYPH_OF_MIND_CONTROL != glyph && PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_PAIN != glyph && PRIEST_MAJOR_GLYPH_OF_SHADOW != glyph && PRIEST_MAJOR_GLYPH_OF_POWER_WORD_SHIELD != glyph && PRIEST_MAJOR_GLYPH_OF_PRAYER_OF_HEALING != glyph && PRIEST_MAJOR_GLYPH_OF_PSYCHIC_SCREAM != glyph && PRIEST_MAJOR_GLYPH_OF_RENEW != glyph && PRIEST_MAJOR_GLYPH_OF_SCOURGE_IMPRISONMENT != glyph && PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_DEATH != glyph && PRIEST_MAJOR_GLYPH_OF_MIND_FLAY != glyph && PRIEST_MAJOR_GLYPH_OF_SMITE != glyph && PRIEST_MAJOR_GLYPH_OF_SPIRIT_OF_REDEMPTION != glyph && PRIEST_MAJOR_GLYPH_OF_DISPERSION != glyph && PRIEST_MAJOR_GLYPH_OF_GUARDIAN_SPIRIT != glyph && PRIEST_MAJOR_GLYPH_OF_PENANCE != glyph && PRIEST_MAJOR_GLYPH_OF_MIND_SEAR != glyph && PRIEST_MAJOR_GLYPH_OF_HYMN_OF_HOPE != glyph && PRIEST_MAJOR_GLYPH_OF_PAIN_SUPPRESSION != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_ROGUE)
+    {
+        if (ROGUE_MAJOR_GLYPH_OF_ADRENALINE_RUSH != glyph && ROGUE_MAJOR_GLYPH_OF_AMBUSH != glyph && ROGUE_MAJOR_GLYPH_OF_BACKSTAB != glyph && ROGUE_MAJOR_GLYPH_OF_BLADE_FLURRY != glyph && ROGUE_MAJOR_GLYPH_OF_CRIPPLING_POISON != glyph && ROGUE_MAJOR_GLYPH_OF_DEADLY_THROW != glyph && ROGUE_MAJOR_GLYPH_OF_EVASION != glyph && ROGUE_MAJOR_GLYPH_OF_EVISCERATE != glyph && ROGUE_MAJOR_GLYPH_OF_EXPOSE_ARMOR != glyph && ROGUE_MAJOR_GLYPH_OF_FEINT != glyph && ROGUE_MAJOR_GLYPH_OF_GARROTE != glyph && ROGUE_MAJOR_GLYPH_OF_GHOSTLY_STRIKE != glyph && ROGUE_MAJOR_GLYPH_OF_GOUGE != glyph && ROGUE_MAJOR_GLYPH_OF_HEMORRHAGE != glyph && ROGUE_MAJOR_GLYPH_OF_PREPARATION != glyph && ROGUE_MAJOR_GLYPH_OF_RUPTURE != glyph && ROGUE_MAJOR_GLYPH_OF_SAP != glyph && ROGUE_MAJOR_GLYPH_OF_VIGOR != glyph && ROGUE_MAJOR_GLYPH_OF_SINISTER_STRIKE != glyph && ROGUE_MAJOR_GLYPH_OF_SLICE_AND_DICE != glyph && ROGUE_MAJOR_GLYPH_OF_SPRINT != glyph && ROGUE_MAJOR_GLYPH_OF_HUNGER_FOR_BLOOD != glyph && ROGUE_MAJOR_GLYPH_OF_KILLING_SPREE != glyph && ROGUE_MAJOR_GLYPH_OF_SHADOW_DANCE != glyph && ROGUE_MAJOR_GLYPH_OF_FAN_OF_KNIVES != glyph && ROGUE_MAJOR_GLYPH_OF_TRICKS_OF_THE_TRADE != glyph && ROGUE_MAJOR_GLYPH_OF_MUTILATE != glyph && ROGUE_MAJOR_GLYPH_OF_CLOAK_OF_SHADOWS != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_SHAMAN)
+    {
+        if (SHAMAN_MAJOR_GLYPH_OF_WATER_MASTERY != glyph && SHAMAN_MAJOR_GLYPH_OF_CHAIN_HEAL != glyph && SHAMAN_MAJOR_GLYPH_OF_CHAIN_LIGHTNING != glyph && SHAMAN_MAJOR_GLYPH_OF_LAVA != glyph && SHAMAN_MAJOR_GLYPH_OF_SHOCKING != glyph && SHAMAN_MAJOR_GLYPH_OF_EARTHLIVING_WEAPON != glyph && SHAMAN_MAJOR_GLYPH_OF_FIRE_ELEMENTAL_TOTEM != glyph && SHAMAN_MAJOR_GLYPH_OF_FIRE_NOVA != glyph && SHAMAN_MAJOR_GLYPH_OF_FLAME_SHOCK != glyph && SHAMAN_MAJOR_GLYPH_OF_FLAMETONGUE_WEAPON != glyph && SHAMAN_MAJOR_GLYPH_OF_FROST_SHOCK != glyph && SHAMAN_MAJOR_GLYPH_OF_HEALING_STREAM_TOTEM != glyph && SHAMAN_MAJOR_GLYPH_OF_HEALING_WAVE != glyph && SHAMAN_MAJOR_GLYPH_OF_LESSER_HEALING_WAVE != glyph && SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_SHIELD != glyph && SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_BOLT != glyph && SHAMAN_MAJOR_GLYPH_OF_STORMSTRIKE != glyph && SHAMAN_MAJOR_GLYPH_OF_LAVA_LASH != glyph && SHAMAN_MAJOR_GLYPH_OF_ELEMENTAL_MASTERY != glyph && SHAMAN_MAJOR_GLYPH_OF_WINDFURY_WEAPON != glyph && SHAMAN_MAJOR_GLYPH_OF_THUNDER != glyph && SHAMAN_MAJOR_GLYPH_OF_FERAL_SPIRIT != glyph && SHAMAN_MAJOR_GLYPH_OF_RIPTIDE != glyph && SHAMAN_MAJOR_GLYPH_OF_EARTH_SHIELD != glyph && SHAMAN_MAJOR_GLYPH_OF_TOTEM_OF_WRATH != glyph && SHAMAN_MAJOR_GLYPH_OF_HEX != glyph && SHAMAN_MAJOR_GLYPH_OF_STONECLAW_TOTEM != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARLOCK)
+    {
+        if (WARLOCK_MAJOR_GLYPH_OF_INCINERATE != glyph && WARLOCK_MAJOR_GLYPH_OF_CONFLAGRATE != glyph && WARLOCK_MAJOR_GLYPH_OF_CORRUPTION != glyph && WARLOCK_MAJOR_GLYPH_OF_CURSE_OF_AGONY != glyph && WARLOCK_MAJOR_GLYPH_OF_DEATH_COIL != glyph && WARLOCK_MAJOR_GLYPH_OF_FEAR != glyph && WARLOCK_MAJOR_GLYPH_OF_FELGUARD != glyph && WARLOCK_MAJOR_GLYPH_OF_FELHUNTER != glyph && WARLOCK_MAJOR_GLYPH_OF_HEALTH_FUNNEL != glyph && WARLOCK_MAJOR_GLYPH_OF_HEALTHSTONE != glyph && WARLOCK_MAJOR_GLYPH_OF_HOWL_OF_TERROR != glyph && WARLOCK_MAJOR_GLYPH_OF_IMMOLATE != glyph && WARLOCK_MAJOR_GLYPH_OF_IMP != glyph && WARLOCK_MAJOR_GLYPH_OF_SEARING_PAIN != glyph && WARLOCK_MAJOR_GLYPH_OF_SHADOW_BOLT != glyph && WARLOCK_MAJOR_GLYPH_OF_SHADOWBURN != glyph && WARLOCK_MAJOR_GLYPH_OF_SIPHON_LIFE != glyph && WARLOCK_MAJOR_GLYPH_OF_SOULSTONE != glyph && WARLOCK_MAJOR_GLYPH_OF_SUCCUBUS != glyph && WARLOCK_MAJOR_GLYPH_OF_UNSTABLE_AFFLICTION != glyph && WARLOCK_MAJOR_GLYPH_OF_VOIDWALKER != glyph && WARLOCK_MAJOR_GLYPH_OF_HAUNT != glyph && WARLOCK_MAJOR_GLYPH_OF_METAMORPHOSIS != glyph && WARLOCK_MAJOR_GLYPH_OF_CHAOS_BOLT != glyph && WARLOCK_MAJOR_GLYPH_OF_DEMONIC_CIRCLE != glyph && WARLOCK_MAJOR_GLYPH_OF_SHADOWFLAME != glyph && WARLOCK_MAJOR_GLYPH_OF_LIFE_TAP != glyph && WARLOCK_MAJOR_GLYPH_OF_SOUL_LINK != glyph && WARLOCK_MAJOR_GLYPH_OF_QUICK_DECAY != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARRIOR)
+    {
+        if (WARRIOR_MAJOR_GLYPH_OF_MORTAL_STRIKE != glyph && WARRIOR_MAJOR_GLYPH_OF_BLOODTHIRST != glyph && WARRIOR_MAJOR_GLYPH_OF_RAPID_CHARGE != glyph && WARRIOR_MAJOR_GLYPH_OF_CLEAVING != glyph && WARRIOR_MAJOR_GLYPH_OF_DEVASTATE != glyph && WARRIOR_MAJOR_GLYPH_OF_EXECUTION != glyph && WARRIOR_MAJOR_GLYPH_OF_HAMSTRING != glyph && WARRIOR_MAJOR_GLYPH_OF_HEROIC_STRIKE != glyph && WARRIOR_MAJOR_GLYPH_OF_INTERVENE != glyph && WARRIOR_MAJOR_GLYPH_OF_BARBARIC_INSULTS != glyph && WARRIOR_MAJOR_GLYPH_OF_OVERPOWER != glyph && WARRIOR_MAJOR_GLYPH_OF_RENDING != glyph && WARRIOR_MAJOR_GLYPH_OF_REVENGE != glyph && WARRIOR_MAJOR_GLYPH_OF_BLOCKING != glyph && WARRIOR_MAJOR_GLYPH_OF_LAST_STAND != glyph && WARRIOR_MAJOR_GLYPH_OF_SUNDER_ARMOR != glyph && WARRIOR_MAJOR_GLYPH_OF_SWEEPING_STRIKES != glyph && WARRIOR_MAJOR_GLYPH_OF_TAUNT != glyph && WARRIOR_MAJOR_GLYPH_OF_RESONATING_POWER != glyph && WARRIOR_MAJOR_GLYPH_OF_VICTORY_RUSH != glyph && WARRIOR_MAJOR_GLYPH_OF_WHIRLWIND != glyph && WARRIOR_MAJOR_GLYPH_OF_BLADESTORM != glyph && WARRIOR_MAJOR_GLYPH_OF_SHOCKWAVE != glyph && WARRIOR_MAJOR_GLYPH_OF_VIGILANCE != glyph && WARRIOR_MAJOR_GLYPH_OF_ENRAGED_REGENERATION != glyph && WARRIOR_MAJOR_GLYPH_OF_SPELL_REFLECTION != glyph && WARRIOR_MAJOR_GLYPH_OF_SHIELD_WALL != glyph)
+            return false;
+    }
+    // pets don't have glyphs... yet
+    else if (charClass == CLASS_PET_CUNNING || charClass == CLASS_PET_FEROCITY || charClass == CLASS_PET_TENACITY)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone tried to validate a glyph for a pet... ValidateMajorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+    else // charClass unknown
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone was naughty and supplied an invalid class to ValidateMajorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+
+    return true;
+}
+
+/**
+ * ValidateMinorGlyph tests a glyph against class to see if it belongs to that class - only accepts Minor glyphs
+ *
+ * uint16 glyph:        glyph ID
+ * long charClass:    member of the Classes enum or ClassesCombatPets enum
+ *
+ * return true  -> ok
+ * return false -> not a valid minor glyph for that class
+ */
+bool PlayerbotAI::ValidateMinorGlyph(uint16 glyph, long charClass)
+{
+    if (charClass == CLASS_DEATH_KNIGHT)
+    {
+        // this looong 'if' is to see if any glyph is not a Death Knight glyph when the class clearly is
+        if (DEATH_KNIGHT_MINOR_GLYPH_OF_BLOOD_TAP != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_DEATHS_EMBRACE != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_HORN_OF_WINTER != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_PESTILENCE != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_CORPSE_EXPLOSION != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD != glyph && DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD2 != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_DRUID)
+    {
+        if (DRUID_MINOR_GLYPH_OF_AQUATIC_FORM != glyph && DRUID_MINOR_GLYPH_OF_CHALLENGING_ROAR != glyph && DRUID_MINOR_GLYPH_OF_THE_WILD != glyph && DRUID_MINOR_GLYPH_OF_UNBURDENED_REBIRTH != glyph && DRUID_MINOR_GLYPH_OF_THORNS != glyph && DRUID_MINOR_GLYPH_OF_DASH != glyph && DRUID_MINOR_GLYPH_OF_TYPHOON != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_HUNTER)
+    {
+        if (HUNTER_MINOR_GLYPH_OF_REVIVE_PET != glyph && HUNTER_MINOR_GLYPH_OF_MEND_PET != glyph && HUNTER_MINOR_GLYPH_OF_FEIGN_DEATH != glyph && HUNTER_MINOR_GLYPH_OF_SCARE_BEAST != glyph && HUNTER_MINOR_GLYPH_OF_THE_PACK != glyph && HUNTER_MINOR_GLYPH_OF_POSSESSED_STRENGTH != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_MAGE)
+    {
+        if (MAGE_MINOR_GLYPH_OF_ARCANE_INTELLECT != glyph && MAGE_MINOR_GLYPH_OF_BLAST_WAVE != glyph && MAGE_MINOR_GLYPH_OF_FIRE_WARD != glyph && MAGE_MINOR_GLYPH_OF_FROST_WARD != glyph && MAGE_MINOR_GLYPH_OF_FROST_ARMOR != glyph && MAGE_MINOR_GLYPH_OF_THE_PENGUIN != glyph && MAGE_MINOR_GLYPH_OF_SLOW_FALL != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PALADIN)
+    {
+        if (PALADIN_MINOR_GLYPH_OF_BLESSING_OF_KINGS != glyph && PALADIN_MINOR_GLYPH_OF_BLESSING_OF_MIGHT != glyph && PALADIN_MINOR_GLYPH_OF_BLESSING_OF_WISDOM != glyph && PALADIN_MINOR_GLYPH_OF_LAY_ON_HANDS != glyph && PALADIN_MINOR_GLYPH_OF_SENSE_UNDEAD != glyph && PALADIN_MINOR_GLYPH_OF_THE_WISE != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_PRIEST)
+    {
+        if (PRIEST_MINOR_GLYPH_OF_FADING != glyph && PRIEST_MINOR_GLYPH_OF_LEVITATE != glyph && PRIEST_MINOR_GLYPH_OF_FORTITUDE != glyph && PRIEST_MINOR_GLYPH_OF_SHACKLE_UNDEAD != glyph && PRIEST_MINOR_GLYPH_OF_SHADOW_PROTECTION != glyph && PRIEST_MINOR_GLYPH_OF_SHADOWFIEND != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_ROGUE)
+    {
+        if (ROGUE_MINOR_GLYPH_OF_DISTRACT != glyph && ROGUE_MINOR_GLYPH_OF_PICK_LOCK != glyph && ROGUE_MINOR_GLYPH_OF_PICK_POCKET != glyph && ROGUE_MINOR_GLYPH_OF_SAFE_FALL != glyph && ROGUE_MINOR_GLYPH_OF_BLURRED_SPEED != glyph && ROGUE_MINOR_GLYPH_OF_VANISH != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_SHAMAN)
+    {
+        if (SHAMAN_MINOR_GLYPH_OF_ASTRAL_RECALL != glyph && SHAMAN_MINOR_GLYPH_OF_RENEWED_LIFE != glyph && SHAMAN_MINOR_GLYPH_OF_WATER_BREATHING != glyph && SHAMAN_MINOR_GLYPH_OF_WATER_SHIELD != glyph && SHAMAN_MINOR_GLYPH_OF_WATER_WALKING != glyph && SHAMAN_MINOR_GLYPH_OF_GHOST_WOLF != glyph && SHAMAN_MINOR_GLYPH_OF_THUNDERSTORM != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARLOCK)
+    {
+        if (WARLOCK_MINOR_GLYPH_OF_UNENDING_BREATH != glyph && WARLOCK_MINOR_GLYPH_OF_DRAIN_SOUL != glyph && WARLOCK_MINOR_GLYPH_OF_KILROGG != glyph && WARLOCK_MINOR_GLYPH_OF_ENSLAVE_DEMON != glyph && WARLOCK_MINOR_GLYPH_OF_SOULS != glyph)
+            return false;
+    }
+    else if (charClass == CLASS_WARRIOR)
+    {
+        if (WARRIOR_MINOR_GLYPH_OF_BATTLE != glyph && WARRIOR_MINOR_GLYPH_OF_BLOODRAGE != glyph && WARRIOR_MINOR_GLYPH_OF_CHARGE != glyph && WARRIOR_MINOR_GLYPH_OF_MOCKING_BLOW != glyph && WARRIOR_MINOR_GLYPH_OF_THUNDER_CLAP != glyph && WARRIOR_MINOR_GLYPH_OF_ENDURING_VICTORY != glyph && WARRIOR_MINOR_GLYPH_OF_COMMAND != glyph)
+            return false;
+    }
+    // pets don't have glyphs... yet
+    else if (charClass == CLASS_PET_CUNNING || charClass == CLASS_PET_FEROCITY || charClass == CLASS_PET_TENACITY)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone tried to validate a glyph for a pet... ValidateMinorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+    else // charClass unknown
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Someone was naughty and supplied an invalid class to ValidateMinorGlyph: %u", (uint32) charClass);
+        return false;
+    }
+
+    return true;
+}
+
+void PlayerbotAI::extractQuestIds(const std::string& text, std::list<uint32>& questIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hquest:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            questIds.push_back(id);
+    }
+}
+
+// Build an hlink for Weapon skills in Aqua
+void PlayerbotAI::MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid)
+{
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+    out << "|cff00ffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << " : " << m_bot->GetSkillValue(skillid) << " /" << m_bot->GetMaxSkillValue(skillid) << "]|h|r";
+}
+
+// Build an hlink for spells in White
+void PlayerbotAI::MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out)
+{
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[loc] << "]|h|r";
+}
+
+// Builds a hlink for an item, but since its
+// only a ItemTemplate, we cant fill in everything
+void PlayerbotAI::MakeItemLink(const ItemTemplate *item, std::ostringstream &out)
+{
+    // Color
+    out << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << item->ItemId << ":";
+
+    // Permanent enchantment, gems, 4 unknowns, and reporter_level
+    // ->new items wont have enchantments or gems so..
+    out << "0:0:0:0:0:0:0:0:0";
+
+    // Name
+    std::string name = item->Name1;
+    ItemLocalization(name, item->ItemId);
+    out << "|h[" << name << "]|h|r";
+
+    // Stacked items
+    if (item->BuyCount > 1)
+        out << "|cff009900x" << item->BuyCount << ".|r";
+    else
+        out << "|cff009900.|r";
+}
+
+// Builds a hlink for an item, includes everything
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:0:0:0:reporter_level|h[name]|h|r
+void PlayerbotAI::MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+    const ItemTemplate *proto = item->GetTemplate();
+    // Color
+    out << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+    out << "|Hitem:";
+
+    // Item Id
+    out << proto->ItemId << ":";
+
+    // Permanent enchantment
+    out << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":";
+
+    // Gems
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+        if (!eId) continue;
+
+        SpellItemEnchantmentEntry const* entry = sSpellItemEnchantmentStore.LookupEntry(eId);
+        if (!entry) continue;
+
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 1: g1 = entry->GemID; break;
+            case 2: g2 = entry->GemID; break;
+            case 3: g3 = entry->GemID; break;
+        }
+    }
+    out << g1 << ":" << g2 << ":" << g3 << ":";
+
+    // Temp enchantment, Bonus Enchantment, Prismatic Enchantment?
+    // Other stuff, don't know what it is
+    out << "0:0:0:0:";
+
+    // Reporter Level
+    out << "0";
+
+    // Name
+    std::string name = proto->Name1;
+    ItemLocalization(name, proto->ItemId);
+    out << "|h[" << name << "]|h|r";
+
+    // Stacked items
+    if (item->GetCount() > 1 && IncludeQuantity)
+        out << "x" << item->GetCount() << ' ';
+}
+
+// Builds a string for an item   |color[name]|r
+void PlayerbotAI::MakeItemText(const Item *item, std::ostringstream &out, bool IncludeQuantity /*= true*/)
+{
+    const ItemTemplate *proto = item->GetTemplate();
+    // Color
+    out << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     out << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   out << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: out << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     out << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     out << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY: out << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: out << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    out << "ffff0000"; break;  //Don't know color, so red?
+    }
+
+    // Name
+    std::string name = proto->Name1;
+    ItemLocalization(name, proto->ItemId);
+    out << "[" << name << "]|r";
+
+    // Stacked items
+    if (item->GetCount() > 1 && IncludeQuantity)
+        out << "x" << item->GetCount() << ' ';
+}
+
+void PlayerbotAI::extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const
+{
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htitle:", pos);
+        if (i == -1)
+            break;
+        pos = i + 7;
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            auctionIds.push_back(id);
+    }
+}
+
+void PlayerbotAI::extractSpellId(const std::string& text, uint32 &spellId) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+
+    int i = text.find("Hspell:", pos);
+    if (i == -1)
+        return;
+
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellId - first pos %u i %u",pos,i);
+    pos = i + 7;     // start of window in text 16 + 7 = 23
+    int endPos = text.find('|', pos);
+    if (endPos == -1)
+        return;
+
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellId - second endpos : %u pos : %u",endPos,pos);
+    std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+    spellId = atol(idC.c_str());
+    pos = endPos;     // end
+}
+
+void PlayerbotAI::extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const
+{
+
+    //   Link format
+    //   |cffffffff|Hspell:" << spellId << ":" << "|h[" << pSpellInfo->SpellName[loc] << "]|h|r";
+    //   cast |cff71d5ff|Hspell:686|h[Shadow Bolt]|h|r";
+    //   012345678901234567890123456
+    //        base = 16 >|  +7 >|
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hspell:", pos);
+        if (i == -1)
+            break;
+
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellIdList - first pos %u i %u",pos,i);
+        pos = i + 7;     // start of window in text 16 + 7 = 23
+        int endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+
+        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: extractSpellIdList - second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);     // 26 - 23
+        uint32 spellId = atol(idC.c_str());
+        pos = endPos;     // end
+
+        if (spellId)
+            m_spellsToLearn.push_back(spellId);
+    }
+}
+
+void PlayerbotAI::extractTalentIds(const std::string &text, std::list<talentPair> &talentIds) const
+{
+    // Link format:
+    // |color|Htalent:talent_id:rank|h[name]|h|r
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Htalent:", pos);
+        if (i == -1)
+            break;
+        pos = i + 8;
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentIds first pos %u i %u",pos,i);
+        // extract talent_id
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentId second endpos : %u pos : %u",endPos,pos);
+        std::string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos + 1;
+        // extract rank
+        endPos = text.find('|', pos);
+        if (endPos == -1)
+            break;
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentId third endpos : %u pos : %u",endPos,pos);
+        std::string rankC = text.substr(pos, endPos - pos);
+        uint32 rank = atol(rankC.c_str());
+        pos = endPos + 1;
+
+        // sLog->outDebug(LOG_FILTER_NONE, "extractTalentId second id : %u  rank : %u",id,rank);
+
+        if (id)
+            talentIds.push_back(std::pair<uint32, uint32>(id, rank));
+    }
+}
+
+void PlayerbotAI::extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const
+{
+
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        std::string guidC = text.substr(pos, endPos - pos);     // get string within window i.e guid 22 - 18 =  4
+        uint32 guid = atol(guidC.c_str());     // convert ascii to long int
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        //uint64 lootCurrent = uint64(HIGHGUID_GAMEOBJECT, entry, guid);
+        uint64 lootCurrent = MAKE_NEW_GUID(guid, 0, HIGHGUID_GAMEOBJECT);
+
+        if (guid)
+            m_lootTargets.push_back(lootCurrent);
+    }
+}
+
+// extracts currency in #g#s#c format
+uint32 PlayerbotAI::extractMoney(const std::string& text) const
+{
+    // if user specified money in ##g##s##c format
+    std::string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+// finds items in equipment and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; itemIdSearchList.size() > 0 && slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+}
+
+// finds items in inventory and adds Item* to foundItemList
+// also removes found item IDs from itemIdSearchList when found
+void PlayerbotAI::findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const
+{
+
+    // look for items in main bag
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; itemIdSearchList.size() > 0 && slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (!pItem)
+            continue;
+
+        for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+        {
+            if (pItem->GetTemplate()->ItemId != *it)
+                continue;
+
+            if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetGUID()))
+                continue;
+
+            foundItemList.push_back(pItem);
+            itemIdSearchList.erase(it);
+            break;
+        }
+    }
+
+    // for all for items in other bags
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; itemIdSearchList.size() > 0 && bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (!pBag)
+            continue;
+
+        for (uint8 slot = 0; itemIdSearchList.size() > 0 && slot < pBag->GetBagSize(); ++slot)
+        {
+            Item* const pItem = m_bot->GetItemByPos(bag, slot);
+            if (!pItem)
+                continue;
+
+            for (std::list<uint32>::iterator it = itemIdSearchList.begin(); it != itemIdSearchList.end(); ++it)
+            {
+                if (pItem->GetTemplate()->ItemId != *it)
+                    continue;
+
+                if (m_bot->GetTrader() && m_bot->GetTradeData()->HasItem(pItem->GetGUID()))
+                    continue;
+
+                foundItemList.push_back(pItem);
+                itemIdSearchList.erase(it);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyGO()
+{
+    if (m_collectObjects.empty())
+        return;
+
+    std::list<GameObject*> tempTargetGOList;
+
+    for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); itr++)
+    {
+        uint32 entry = *(itr);
+        GameObjectTemplate const * gInfo = sObjectMgr->GetGameObjectTemplate(entry);
+        bool questGO = false;
+        uint8 needCount = 0;
+
+        for (uint32 i = 0; i < 6; ++i)
+        {
+            if (gInfo->questItems[i] != 0)  // check whether the gameobject contains quest items
+            {
+                questGO = true;
+                if (IsInQuestItemList(gInfo->questItems[i]))    // quest item needed
+                    needCount++;
+            }
+        }
+
+        if (questGO && needCount == 0)
+        {
+            m_collectObjects.remove(entry); // remove gameobject from collect list
+            return;
+        }
+
+        // search for GOs with entry, within range of m_bot
+        Trinity::GameObjectInRangeCheck go_check(m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), float(m_confCollectDistance), entry);
+        Trinity::GameObjectListSearcher<Trinity::GameObjectInRangeCheck> checker(m_bot, tempTargetGOList, go_check);
+        m_bot->VisitNearbyWorldObject(m_confCollectDistance, checker);
+        //VisitGridObjects(m_bot, checker, float(m_collectDist));
+
+        // no objects found, continue to next entry
+        if (tempTargetGOList.empty())
+            continue;
+
+        // add any objects found to our lootTargets
+        for (std::list<GameObject*>::iterator iter = tempTargetGOList.begin(); iter != tempTargetGOList.end(); iter++)
+        {
+            GameObject* go = (*iter);
+            if (go->isSpawned())
+                m_lootTargets.push_back(go->GetGUID());
+        }
+    }
+}
+
+void PlayerbotAI::findNearbyCreature()
+{
+    std::list<Creature*> creatureList;
+    float radius = INTERACTION_DISTANCE;
+
+    CellCoord pair(Trinity::ComputeCellCoord(m_bot->GetPositionX(), m_bot->GetPositionY()));
+    Cell cell(pair);
+
+    Trinity::AnyUnitInObjectRangeCheck go_check(m_bot, radius);
+    Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck> go_search(m_bot, creatureList, go_check);
+    TypeContainerVisitor<Trinity::CreatureListSearcher<Trinity::AnyUnitInObjectRangeCheck>, GridTypeMapContainer> go_visit(go_search);
+
+    // Get Creatures
+    cell.Visit(pair, go_visit, *(m_bot->GetMap()), *(m_bot), radius);
+
+    // if (!creatureList.empty())
+    //    TellMaster("Found %i Creatures.", creatureList.size());
+
+    for (std::list<Creature*>::iterator iter = creatureList.begin(); iter != creatureList.end(); iter++)
+    {
+        Creature* currCreature = *iter;
+
+        for (std::list<enum NPCFlags>::iterator itr = m_findNPC.begin(); itr != m_findNPC.end(); itr = m_findNPC.erase(itr))
+        {
+            uint32 npcflags = currCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+            if (!(*itr & npcflags))
+                continue;
+
+            if ((*itr == UNIT_NPC_FLAG_TRAINER_CLASS) && !currCreature->isCanTrainingAndResetTalentsOf(m_bot))
+                continue;
+
+            //WorldObject *wo = sObjectAccessor->GetObjectInMap(currCreature->GetGUID(), m_bot->GetMap(), (WorldObject*)NULL);
+            Creature *wo = sObjectAccessor->GetCreature(*m_bot, currCreature->GetGUID());
+            if (!wo) continue;
+            if (m_bot->GetDistance(wo) > CONTACT_DISTANCE + wo->GetObjectSize())
+            {
+                float x, y, z;
+                wo->GetContactPoint(m_bot, x, y, z, 1.0f);
+                m_bot->GetMotionMaster()->MovePoint(wo->GetMapId(), x, y, z);
+                // give time to move to point before trying again
+                SetIgnoreUpdateTime(1);
+            }
+
+            if (m_bot->GetDistance(wo) < INTERACTION_DISTANCE)
+            {
+
+                // sLog->outDebug(LOG_FILTER_NONE, "%s is interacting with (%s)",m_bot->GetName(),currCreature->GetCreatureTemplate()->Name);
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(currCreature->GetCreatureTemplate()->GossipMenuId);
+
+                // prepares quest menu when true
+                bool canSeeQuests = currCreature->GetCreatureTemplate()->GossipMenuId == m_bot->GetDefaultGossipMenuForSource(wo);
+
+                // if canSeeQuests (the default, top level menu) and no menu options exist for this, use options from default options
+                if (pMenuItemBounds.first == pMenuItemBounds.second && canSeeQuests)
+                    pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(0);
+
+                for (GossipMenuItemsContainer::const_iterator it = pMenuItemBounds.first; it != pMenuItemBounds.second; it++)
+                {
+                    if (!(it->second.OptionNpcflag & npcflags))
+                        continue;
+
+                    switch (it->second.OptionType)
+                    {
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // Manage banking actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // withdraw items
+                                        case BANK_WITHDRAW:
+                                        {
+                                            // TellMaster("Withdraw items");
+                                            if (!Withdraw(ait->second))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "Withdraw: Couldn't withdraw (%u)", ait->second);
+                                            break;
+                                        }
+                                        // deposit items
+                                        case BANK_DEPOSIT:
+                                        {
+                                            // TellMaster("Deposit items");
+                                            if (!Deposit(ait->second))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "Deposit: Couldn't deposit (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            BankBalance();
+                            break;
+                        }
+                        case GOSSIP_OPTION_TAXIVENDOR:
+                        case GOSSIP_OPTION_GOSSIP:
+                        case GOSSIP_OPTION_INNKEEPER:
+                        case GOSSIP_OPTION_TRAINER:
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        case GOSSIP_OPTION_VENDOR:
+                        case GOSSIP_OPTION_UNLEARNTALENTS:
+                        {
+                            // Manage questgiver, trainer, innkeeper & vendor actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // reset talents
+                                        case RESET_TALENTS:
+                                        {
+                                            // TellMaster("Reset all talents");
+                                            if (Talent(currCreature))
+                                                InspectUpdate();
+                                            break;
+                                        }
+                                        // take new quests
+                                        case TAKE_QUEST:
+                                        {
+                                            // TellMaster("Accepting quest");
+                                            if (!AddQuest(ait->second, wo))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "AddQuest: Couldn't add quest (%u)", ait->second);
+                                            break;
+                                        }
+                                        // list npc quests
+                                        case LIST_QUEST:
+                                        {
+                                            // TellMaster("Show available npc quests");
+                                            ListQuests(wo);
+                                            break;
+                                        }
+                                        // end quests
+                                        case END_QUEST:
+                                        {
+                                            // TellMaster("Turn in available quests");
+                                            TurnInQuests(wo);
+                                            break;
+                                        }
+                                        // sell items
+                                        case SELL_ITEMS:
+                                        {
+                                            // TellMaster("Selling items");
+                                            Sell(ait->second);
+                                            break;
+                                        }
+                                        // repair items
+                                        //case REPAIR_ITEMS:
+                                        //{
+                                            // TellMaster("Repairing items");
+                                            //Repair(ait->second, currCreature);
+                                            //break;
+                                        //}
+                                        default:
+                                            break;
+                                    }
+                                }
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // Manage auctioneer actions
+                            if (!m_tasks.empty())
+                                for (std::list<taskPair>::iterator ait = m_tasks.begin(); ait != m_tasks.end(); ait = m_tasks.erase(ait))
+                                {
+                                    switch (ait->first)
+                                    {
+                                        // add new auction item
+                                        case ADD_AUCTION:
+                                        {
+                                            // TellMaster("Creating auction");
+                                            AddAuction(ait->second, currCreature);
+                                            break;
+                                        }
+                                        // cancel active auction
+                                        case REMOVE_AUCTION:
+                                        {
+                                            // TellMaster("Cancelling auction");
+                                            if (!RemoveAuction(ait->second))
+                                                //sLog->outDebug(LOG_FILTER_NONE, "RemoveAuction: Couldn't remove auction (%u)", ait->second);
+                                            break;
+                                        }
+                                        default:
+                                            break;
+                                    }
+                                }
+                            ListAuctions();
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                    m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+                }
+            }
+            m_bot->GetMotionMaster()->Clear();
+            m_bot->GetMotionMaster()->MoveIdle();
+        }
+    }
+}
+
+/**
+ * GiveLevel sets the bot's level to 'level'
+ * Not the clearest of function names, we're just mirroring Player.cpp's function name
+ */
+void PlayerbotAI::GiveLevel(uint32 level)
+{
+    // Talent function in Player::GetLevel take care of resetting talents in case level < getLevel()
+    ApplyActiveTalentSpec();
+}
+
+bool PlayerbotAI::CanStore()
+{
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+    }
+    return totalfree;
+}
+
+// use item on self
+void PlayerbotAI::UseItem(Item *item)
+{
+    UseItem(item, TARGET_FLAG_NONE, 0);
+}
+
+// use item on equipped item
+void PlayerbotAI::UseItem(Item *item, uint8 targetInventorySlot)
+{
+    if (targetInventorySlot >= EQUIPMENT_SLOT_END)
+        return;
+
+    Item* const targetItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, targetInventorySlot);
+    if (!targetItem)
+        return;
+
+    UseItem(item, TARGET_FLAG_ITEM, targetItem->GetGUID());
+}
+
+// use item on unit
+void PlayerbotAI::UseItem(Item *item, Unit *target)
+{
+    if (!target)
+        return;
+
+    UseItem(item, TARGET_FLAG_UNIT, target->GetGUID());
+}
+
+// generic item use method
+void PlayerbotAI::UseItem(Item *item, uint32 targetFlag, uint64 targetGUID)
+{
+    if (!item)
+        return;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    uint64 item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    if (uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        std::ostringstream report;
+
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            m_bot->GetMotionMaster()->Clear(true);
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8 + 4 + 4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            report << "|cffffff00Quest taken |r" << qInfo->GetTitle();
+            TellMaster(report.str());
+        }
+        return;
+    }
+
+    uint32 spellId = 0;
+    for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        if (item->GetTemplate()->Spells[i].SpellId > 0)
+        {
+            spellId = item->GetTemplate()->Spells[i].SpellId;
+            break;
+        }
+    }
+
+    if (item->GetTemplate()->Flags & ITEM_FLAG_UNLOCKED && spellId == 0)
+    {
+        // Open quest item in inventory, containing related items (e.g Gnarlpine necklace, containing Tallonkai's Jewel)
+        WorldPacket* const packet = new WorldPacket(CMSG_OPEN_ITEM, 2);
+        *packet << item->GetBagSlot();
+        *packet << item->GetSlot();
+        m_bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+        return;
+    }
+
+    WorldPacket *packet = new WorldPacket(CMSG_USE_ITEM, 28);
+    *packet << bagIndex << slot << cast_count << spellId << item_guid
+            << glyphIndex << unk_flags << targetFlag;
+
+    if (targetFlag & (TARGET_FLAG_UNIT | TARGET_FLAG_ITEM | TARGET_FLAG_GAMEOBJECT))
+        *packet << targetGUID;//.WriteAsPacked();
+
+    m_bot->GetSession()->QueuePacket(packet);
+
+    SpellInfo const * spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TellMaster("Can't find spell entry for spell %u on item %u", spellId, item->GetEntry());
+        return;
+    }
+
+    SpellCastTimesEntry const * castingTimeEntry = spellInfo->CastTimeEntry;
+    if (!castingTimeEntry)
+    {
+        TellMaster("Can't find casting time entry for spell %u with index %u", spellId, spellInfo->CastTimeEntry);
+        return;
+    }
+
+    uint8 duration, castTime;
+    castTime = (uint8) ((float) castingTimeEntry->CastTime / 1000.0f);
+
+    if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        duration = (uint8) ((float)spellInfo->GetDuration() / 1000.0f);
+        SetIgnoreUpdateTime(castTime + duration);
+    }
+    else
+        SetIgnoreUpdateTime(castTime);
+}
+
+// submits packet to use an item
+void PlayerbotAI::EquipItem(Item* src_Item)
+{
+    uint8 src_bagIndex = src_Item->GetBagSlot();
+    uint8 src_slot = src_Item->GetSlot();
+
+    // sLog->outDebug(LOG_FILTER_NONE, "PlayerbotAI::EquipItem: %s in srcbag = %u, srcslot = %u", src_Item->GetTemplate()->Name1, src_bagIndex, src_slot);
+
+    uint16 dest;
+    InventoryResult msg = m_bot->CanEquipItem(NULL_SLOT, dest, src_Item, !src_Item->IsBag());
+    if (msg != EQUIP_ERR_OK)
+    {
+        m_bot->SendEquipError(msg, src_Item, NULL);
+        return;
+    }
+
+    uint16 src = src_Item->GetPos();
+    if (dest == src)                                        // prevent equip in same slot, only at cheat
+        return;
+
+    Item *dest_Item = m_bot->GetItemByPos(dest);
+    if (!dest_Item)                                          // empty slot, simple case
+    {
+        m_bot->RemoveItem(src_bagIndex, src_slot, true);
+        m_bot->EquipItem(dest, src_Item, true);
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+    else                                                    // have currently equipped item, not simple case
+    {
+        uint8 dest_bagIndex = dest_Item->GetBagSlot();
+        uint8 dest_slot = dest_Item->GetSlot();
+
+        msg = m_bot->CanUnequipItem(dest, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, NULL);
+            return;
+        }
+
+        // check dest->src move possibility
+        ItemPosCountVec sSrc;
+        if (m_bot->IsInventoryPos(src))
+        {
+            msg = m_bot->CanStoreItem(src_bagIndex, src_slot, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(src_bagIndex, NULL_SLOT, sSrc, dest_Item, true);
+            if (msg != EQUIP_ERR_OK)
+                msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, sSrc, dest_Item, true);
+        }
+
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, dest_Item, src_Item);
+            return;
+        }
+
+        // now do moves, remove...
+        m_bot->RemoveItem(dest_bagIndex, dest_slot, false);
+        m_bot->RemoveItem(src_bagIndex, src_slot, false);
+
+        // add to dest
+        m_bot->EquipItem(dest, src_Item, true);
+
+        // add to src
+        if (m_bot->IsInventoryPos(src))
+            m_bot->StoreItem(sSrc, dest_Item, true);
+
+        m_bot->AutoUnequipOffhandIfNeed();
+    }
+}
+
+// submits packet to trade an item (trade window must already be open)
+// default slot is -1 which means trade slots 0 to 5. if slot is set
+// to TRADE_SLOT_NONTRADED (which is slot 6) item will be shown in the
+// 'Will not be traded' slot.
+bool PlayerbotAI::TradeItem(const Item& item, int8 slot)
+{
+    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: TradeItem - slot=%d, hasTrader=%d, itemInTrade=%d, itemTradeable=%d",
+               //slot,
+               //(m_bot->GetTrader() ? 1 : 0),
+               //(item.IsInTrade() ? 1 : 0),
+               //(item.CanBeTraded() ? 1 : 0)
+               //);
+
+    if (!m_bot->GetTrader() || item.IsInTrade() || (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED))
+        return false;
+
+    int8 tradeSlot = -1;
+
+    TradeData* pTrade = m_bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+    else
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                tradeSlot = i;
+                // reserve trade slot to allow multiple items to be traded
+                pTrade->SetItem(TradeSlots(i), const_cast<Item*>(&item));
+            }
+        }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+            << (uint8) item.GetSlot();
+    m_bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+// submits packet to trade copper (trade window must be open)
+bool PlayerbotAI::TradeCopper(uint32 copper)
+{
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        m_bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+    return false;
+}
+
+//bool PlayerbotAI::DoTeleport(WorldObject &obj)
+//{
+//    m_ignoreAIUpdatesUntilTime = time(NULL) + 6;
+//    Player *mstr = m_master;
+//    PlayerbotChatHandler ch(mstr);
+//    if (!ch.teleport(*m_bot, obj))
+//    {
+//        ch.sysmessage(".. could not be teleported ..");
+//        // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: DoTeleport - %s failed to teleport", m_bot->GetName() );
+//        return false;
+//    }
+//    return true;
+//}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+    //TellMaster("Debug: HandleTeleportAck()");
+    m_ignoreAIUpdatesUntilTime = time(NULL) + 2;
+    m_bot->GetMotionMaster()->Clear(true);
+    if (m_bot->IsBeingTeleportedNear())
+    {
+        WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+        p.appendPackGUID(m_bot->GetGUID());
+        p << (uint32) 0; // supposed to be flags? not used currently
+        p << (uint32) time(NULL); // time - not currently used
+        m_bot->GetSession()->HandleMoveTeleportAck(p);
+    }
+    else if (m_bot->IsBeingTeleportedFar())
+        m_bot->GetSession()->HandleMoveWorldportAckOpcode();
+}
+
+// Localization support
+void PlayerbotAI::ItemLocalization(std::string& itemName, const uint32 itemID) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const *pItemInfo = sObjectMgr->GetItemLocale(itemID);
+    if (pItemInfo)
+        if (pItemInfo->Name.size() > loc && !pItemInfo->Name[loc].empty())
+        {
+            const std::string name = pItemInfo->Name[loc];
+            if (Utf8FitTo(name, wnamepart))
+                itemName = name.c_str();
+        }
+}
+
+void PlayerbotAI::QuestLocalization(std::string& questTitle, const uint32 questID) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const *pQuestInfo = sObjectMgr->GetQuestLocale(questID);
+    if (pQuestInfo)
+        if (pQuestInfo->Title.size() > loc && !pQuestInfo->Title[loc].empty())
+        {
+            const std::string title = pQuestInfo->Title[loc];
+            if (Utf8FitTo(title, wnamepart))
+                questTitle = title.c_str();
+        }
+}
+
+void PlayerbotAI::CreatureLocalization(std::string& creatureName, const uint32 entry) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const *pCreatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (pCreatureInfo)
+        if (pCreatureInfo->Name.size() > loc && !pCreatureInfo->Name[loc].empty())
+        {
+            const std::string title = pCreatureInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                creatureName = title.c_str();
+        }
+}
+
+void PlayerbotAI::GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const
+{
+    uint32 loc = m_master->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const *pGameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (pGameObjectInfo)
+        if (pGameObjectInfo->Name.size() > loc && !pGameObjectInfo->Name[loc].empty())
+        {
+            const std::string title = pGameObjectInfo->Name[loc];
+            if (Utf8FitTo(title, wnamepart))
+                gameobjectName = title.c_str();
+        }
+}
+
+// Helper function for automatically selling poor quality items to the vendor
+void PlayerbotAI::_doSellItem(Item *item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold)
+{
+    if (!item)
+        return;
+
+    uint8 autosell = 0;
+
+    std::ostringstream mout;
+    if (item->CanBeTraded() && item->GetTemplate()->Quality == ITEM_QUALITY_POOR) // trash sells automatically.
+        autosell = 1;
+    if (SellWhite == 1) // set this with the command 'sell all'
+    {
+        // here we'll do some checks for other items that are safe to automatically sell such as
+        // white items that are a number of levels lower than anything we could possibly use.
+        // We'll check to make sure its not a tradeskill tool, quest item etc, things that we don't want to lose.
+        if (item->GetTemplate()->SellPrice > 0 && (item->GetTemplate()->Quality == ITEM_QUALITY_NORMAL || item->GetTemplate()->Quality == ITEM_QUALITY_UNCOMMON) && item->GetTemplate()->SubClass != ITEM_SUBCLASS_QUEST)
+        {
+            ItemTemplate const *pProto = item->GetTemplate();
+            if (pProto->RequiredLevel < (m_bot->getLevel() - gConfigSellLevelDiff) && pProto->SubClass != ITEM_SUBCLASS_WEAPON_MISC && pProto->FoodType == 0)
+            {
+                if (pProto->Class == ITEM_CLASS_WEAPON)
+                    autosell = 1;
+                if (pProto->Class == ITEM_CLASS_ARMOR)
+                    autosell = 1;
+            }
+            if (pProto->SubClass == ITEM_SUBCLASS_FOOD && (pProto->RequiredLevel < (m_bot->getLevel() - gConfigSellLevelDiff)))
+            {
+                autosell = 1;
+            }
+        }
+    }
+
+    if (autosell == 1) // set this switch above and this item gets sold automatically. Only set this for automatic sales e.g junk etc.
+    {
+
+        uint32 cost = item->GetCount() * item->GetTemplate()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(item->GetBagSlot(), item->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(item);
+
+        ++TotalSold;
+        TotalCost += cost;
+
+        report << "Sold ";
+        MakeItemLink(item, report, true);
+        report << " for ";
+
+        report << Cash(cost);
+    }
+    else if (item->GetTemplate()->SellPrice > 0)
+        MakeItemLink(item, canSell, true);
+}
+
+bool PlayerbotAI::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, NULL);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->StoreItem(dest, pItem, true);
+
+        report << "Withdrawn ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+bool PlayerbotAI::Deposit(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        ItemPosCountVec dest;
+        InventoryResult msg = m_bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+        if (msg != EQUIP_ERR_OK)
+        {
+            m_bot->SendEquipError(msg, pItem, NULL);
+            return false;
+        }
+
+        m_bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->BankItem(dest, pItem, true);
+
+        report << "Deposited ";
+        MakeItemLink(pItem, report, true);
+
+        TellMaster(report.str());
+    }
+    return true;
+}
+
+void PlayerbotAI::BankBalance()
+{
+    std::ostringstream report;
+
+    report << "In my bank\n ";
+    report << "My item slots: ";
+
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            MakeItemLink(item, report, true);
+    }
+    TellMaster(report.str());
+
+    // and each of my bank bags
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        std::ostringstream goods;
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            goods << "\nMy ";
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+            ItemLocalization(bagName, pBagProto->ItemId);
+            goods << bagName << " slot: ";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    MakeItemLink(item, goods, true);
+            }
+            TellMaster(goods.str());
+        }
+    }
+}
+
+bool PlayerbotAI::Talent(Creature* trainer)
+{
+    if (!(m_bot->resetTalents()))
+    {
+        WorldPacket* const packet = new WorldPacket(MSG_TALENT_WIPE_CONFIRM, 8 + 4);    //you do not have any talent
+        *packet << uint64(0);
+        *packet << uint32(0);
+        m_bot->GetSession()->QueuePacket(packet);
+        return false;
+    }
+
+    m_bot->SendTalentsInfoData(false);
+    trainer->CastSpell(m_bot, 14867, true);                  //spell: "Untalent Visual Effect"
+    return true;
+}
+
+void PlayerbotAI::InspectUpdate()
+{
+    WorldPacket packet(SMSG_INSPECT_TALENT, 50);
+    packet.append(m_bot->GetPackGUID());
+    m_bot->BuildPlayerTalentsInfoData(&packet);
+    m_bot->BuildEnchantmentsInfoData(&packet);
+    m_master->GetSession()->SendPacket(&packet);
+}
+
+void PlayerbotAI::Repair(const uint32 itemid, Creature* rCreature)
+{
+    Item* rItem = FindItem(itemid); // if item equipped or in bags
+    uint8 IsInGuild = (m_bot->GetGuildId() != 0) ? uint8(1) : uint8(0);
+    uint64 itemGuid = (rItem) ? rItem->GetGUID() : 0;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_REPAIR_ITEM, 8 + 8 + 1);
+    *packet << rCreature->GetGUID();  // repair npc guid
+    *packet << itemGuid; // if item specified then repair this, else repair all
+    *packet << IsInGuild;  // guildbank yes=1 no=0
+    m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+}
+
+bool PlayerbotAI::RemoveAuction(const uint32 auctionid)
+{
+    QueryResult result = CharacterDatabase.PQuery(
+        //"SELECT houseid,itemguid,item_template,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auction WHERE id = '%u'", auctionid);
+        "SELECT auctioneerguid,itemguid,itemowner,buyoutprice,time,buyguid,lastbid,startbid,deposit FROM auctionhouse WHERE id = '%u'", auctionid);
+
+    AuctionEntry *auction;
+
+    if (result)
+    {
+        Field *fields = result->Fetch();
+
+        auction = new AuctionEntry;
+        auction->Id = auctionid;
+        auction->auctioneer = fields[0].GetUInt32();
+        auction->item_guidlow = fields[1].GetUInt32();
+        auction->item_template = fields[2].GetUInt32();
+        auction->owner = fields[3].GetUInt32();
+        auction->buyout = fields[4].GetUInt32();
+        auction->expire_time = fields[5].GetUInt32();
+        auction->bidder = fields[6].GetUInt32();
+        auction->bid = fields[7].GetUInt32();
+        auction->startbid = fields[8].GetUInt32();
+        auction->deposit = fields[9].GetUInt32();
+        auction->auctionHouseEntry = NULL;                  // init later
+
+        // check if sold item exists for guid
+        // and item_template in fact (GetAItem will fail if problematic in result check in AuctionHouseMgr::LoadAuctionItems)
+        Item* pItem = sAuctionMgr->GetAItem(auction->item_guidlow);
+        if (!pItem)
+        {
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            auction->DeleteFromDB(trans);
+            CharacterDatabase.CommitTransaction(trans);
+            //sLog->outError("Auction %u has not a existing item : %u, deleted", auction->Id, auction->item_guidlow);
+            delete auction;
+            //delete result;
+            return false;
+        }
+
+        auction->auctionHouseEntry = sAuctionHouseStore.LookupEntry(auction->auctioneer);
+
+        // Attempt send item back to owner
+        std::ostringstream msgAuctionCanceledOwner;
+        msgAuctionCanceledOwner << auction->item_template << ":0:" << AUCTION_CANCELED << ":0:0";
+
+        // item will deleted or added to received mail list
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+        MailDraft(msgAuctionCanceledOwner.str(), "")    // TODO: fix body
+        .AddItem(pItem)
+        .SendMailTo(trans, MailReceiver(auction->owner), auction, MAIL_CHECK_MASK_COPIED);
+        
+
+        if (sAuctionMgr->RemoveAItem(auction->item_guidlow))
+            m_bot->GetSession()->SendAuctionCommandResult(auction->Id, AUCTION_CANCEL, AUCTION_OK);
+
+        auction->DeleteFromDB(trans);
+
+        CharacterDatabase.CommitTransaction(trans);
+
+        delete auction;
+        //delete result;
+    }
+    return true;
+}
+
+// Subject - 9360:0:2
+// Subject - item:0:MailAuctionAnswer
+// Body - 0:2650:2650:120:132
+// Body - 0:High Bid:Buyout:Deposit:AuctionHouse Cut
+
+std::string PlayerbotAI::AuctionResult(std::string subject, std::string body)
+{
+    std::ostringstream out;
+    std::string winner;
+    int pos;
+
+    subject.append(":");
+    if (body.size() > 0)
+    {
+        pos = body.find_first_not_of(" ");
+        subject.append(body, pos, body.size() - pos);
+        subject.append(":");
+    }
+
+    //sLog->outDebug(LOG_FILTER_NONE, "Auctions string (%s)", subject.c_str());
+    pos = 0;
+    int sublen = subject.size() / 2;
+    uint32 a_info[15];
+    for (int i = 0; i < sublen; i++)
+    {
+        int endpos = subject.find(':', pos);
+        std::string idc = subject.substr(pos, endpos - pos);
+        a_info[i] = atol(idc.c_str());
+        //sLog->outDebug(LOG_FILTER_NONE, "a_info[%d] = (%u)", i, a_info[i]);
+        pos = endpos + 1;
+    }
+
+    if (a_info[4] != a_info[5])
+        winner =  "High Bidder";
+    else
+        winner =  "Buyout";
+
+    ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(a_info[0]);
+    if (!pProto)
+        return out.str();
+
+    switch (a_info[2])
+    {
+        case AUCTION_OUTBIDDED:           //= 0,
+            out << "Subject: Outbid on: " << pProto->Name1;
+            break;
+        case AUCTION_WON:                 //= 1,
+            out << "Subject: Auction won: " << pProto->Name1 << "\n";
+            out << "Item Purchased: " << pProto->Name1 << "\n";
+            break;
+        case AUCTION_SUCCESSFUL:          //= 2,
+        {
+            out << "Subject: Auction successful: " << pProto->Name1 << "\n";
+            out << "Item Sold: " << pProto->Name1 << "\n";
+            out << "\n[" << winner << " Sale: " << Cash(a_info[4]) << "]";
+            out << "\n( |cff1eff00Deposit:|cffccffff " << Cash(a_info[6]) << " |cffff0000- Tax:|cffccffff " << Cash(a_info[7]) << " ) |cff1eff00+|cffccffff";
+            break;
+        }
+        case AUCTION_EXPIRED:             //= 3,
+            out << "Subject: Auction expired: " << pProto->Name1;
+            break;
+        case AUCTION_CANCELLED_TO_BIDDER: //= 4,
+            out << "Subject: Auction cancelled to bidder: " << pProto->Name1;
+            break;
+        case AUCTION_CANCELED:            //= 5,
+            out << "Subject: Auction cancelled: " << pProto->Name1;
+            break;
+        case AUCTION_SALE_PENDING:        //= 6
+            out << "Subject: Auction sale pending: " << pProto->Name1;
+            break;
+    }
+    return out.str();
+}
+
+std::string PlayerbotAI::Cash(uint32 copper)
+{
+    using namespace std;
+    std::ostringstream change;
+
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+
+    if (gold > 0)
+        change << gold <<  " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+    if (silver > 0)
+        change << std::setfill(' ') << std::setw(2) << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+    change << std::setfill(' ') << std::setw(2) << copper << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+
+    return change.str();
+}
+
+void PlayerbotAI::ListQuests(WorldObject * questgiver)
+{
+    if (!questgiver)
+        return;
+
+    // list all bot quests this NPC has
+    m_bot->PrepareQuestMenu(questgiver->GetGUID());
+    QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+    std::ostringstream out;
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+
+        std::string questTitle  = pQuest->GetTitle();
+        QuestLocalization(questTitle, questID);
+
+        if (m_bot->SatisfyQuestStatus(pQuest, false))
+            out << "|cff808080|Hquest:" << questID << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+    }
+    if (!out.str().empty())
+        TellMaster(out.str());
+}
+
+bool PlayerbotAI::AddQuest(const uint32 entry, WorldObject * questgiver)
+{
+    std::ostringstream out;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(entry);
+    if (!qInfo)
+    {
+        ChatHandler(m_master).PSendSysMessage(LANG_COMMAND_QUEST_NOTFOUND, entry);
+        return false;
+    }
+
+    if (m_bot->GetQuestStatus(entry) == QUEST_STATUS_COMPLETE)
+    {
+        TellMaster("I already completed that quest.");
+        return false;
+    }
+    else if (!m_bot->CanTakeQuest(qInfo, false))
+    {
+        if (!m_bot->SatisfyQuestStatus(qInfo, false))
+            TellMaster("I already have that quest.");
+        else
+            TellMaster("I can't take that quest.");
+        return false;
+    }
+    else if (!m_bot->SatisfyQuestLog(false))
+    {
+        TellMaster("My quest log is full.");
+        return false;
+    }
+    else if (m_bot->CanAddQuest(qInfo, false))
+    {
+        m_bot->AddQuest(qInfo, questgiver);
+
+        std::string questTitle  = qInfo->GetTitle();
+        QuestLocalization(questTitle, entry);
+
+        out << "|cffffff00Quest taken " << "|cff808080|Hquest:" << entry << ':' << qInfo->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+
+        if (m_bot->CanCompleteQuest(entry))
+            m_bot->CompleteQuest(entry);
+
+        // build needed items if quest contains any
+        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredItemCount[i] > 0)
+            {
+                SetQuestNeedItems();
+                break;
+            }
+
+        // build needed creatures if quest contains any
+        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+            {
+                SetQuestNeedCreatures();
+                break;
+            }
+
+        TellMaster(out.str());
+        return true;
+    }
+    return false;
+}
+
+void PlayerbotAI::ListAuctions()
+{
+    std::ostringstream report;
+
+    QueryResult result = CharacterDatabase.PQuery(
+        //"SELECT id,itemguid,item_template,time,buyguid,lastbid FROM auction WHERE itemowner = '%u'", m_bot->GetGUIDLow());
+        "SELECT id,itemguid,time,buyguid,lastbid FROM auctionhouse WHERE itemowner = '%u'", m_bot->GetGUIDLow());
+    if (result)
+    {
+        report << "My active auctions are: \n";
+        do
+        {
+            Field *fields = result->Fetch();
+
+            uint32 Id = fields[0].GetUInt32();
+            uint32 itemGuidLow = fields[1].GetUInt32();
+            AuctionEntry *auction = AuctionHouseObject().GetAuction(Id);
+            uint32 itemTemplate = auction->item_template;//fields[2].GetUInt32();
+            time_t expireTime = fields[2].GetUInt32();
+            uint32 bidder = fields[3].GetUInt32();
+            uint32 bid = fields[4].GetUInt32();
+
+            // current time
+            time_t currtime = time(NULL);
+            time_t remtime = expireTime - currtime;
+
+            tm* aTm = gmtime(&remtime);
+
+            if (expireTime > currtime)
+            {
+                Item* aItem = sAuctionMgr->GetAItem(itemGuidLow);
+                if (aItem)
+                {
+                    // Name
+                    uint32 count = aItem->GetCount();
+                    std::string name = aItem->GetTemplate()->Name1;
+                    ItemLocalization(name, itemTemplate);
+                    report << "\n|cffffffff|Htitle:" << Id << "|h[" << name;
+                    if (count > 1)
+                        report << "|cff00ff00x" << count << "|cffffffff" << "]|h|r";
+                    else
+                        report << "]|h|r";
+                }
+
+                if (bidder)
+                {
+                    uint64 guid = bidder;
+                    std::string bidder_name;
+                    if (sObjectMgr->GetPlayerNameByGUID(guid, bidder_name))
+                        report << " " << bidder_name << ": ";
+
+                    report << Cash(bid);
+                }
+                if (aItem)
+                    report << " ends: " << aTm->tm_hour << "|cff0070dd|hH|h|r " << aTm->tm_min << "|cff0070dd|hmin|h|r";
+            }
+        } while (result->NextRow());
+
+        //delete result;
+        TellMaster(report.str().c_str());
+    }
+}
+
+void PlayerbotAI::AddAuction(const uint32 itemid, Creature* aCreature)
+{
+    Item* aItem = FindItem(itemid);
+    if (aItem)
+    {
+        std::ostringstream out;
+        srand(time(NULL));
+        uint32 duration[3] = { 720, 1440, 2880 };  // 720 = 12hrs, 1440 = 24hrs, 2880 = 48hrs
+        uint32 etime = duration[rand() % 3];
+
+        uint32 min = urand(aItem->GetTemplate()->SellPrice * aItem->GetCount(), aItem->GetTemplate()->BuyPrice * aItem->GetCount()) * (aItem->GetTemplate()->Quality + 1);
+        uint32 max = urand(aItem->GetTemplate()->SellPrice * aItem->GetCount(), aItem->GetTemplate()->BuyPrice * aItem->GetCount()) * (aItem->GetTemplate()->Quality + 1);
+
+        out << "Auctioning ";
+        MakeItemLink(aItem, out, true);
+        out << " with " << aCreature->GetCreatureTemplate()->Name;
+        TellMaster(out.str().c_str());
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUCTION_SELL_ITEM, 8 + 4 + 8 + 4 + 4 + 4 + 4);
+        *packet << aCreature->GetGUID();     // auctioneer guid
+        *packet << uint32(1);                      // const 1
+        *packet << aItem->GetGUID();         // item guid
+        *packet << aItem->GetCount();      // stacksize
+        *packet << uint32((min < max) ? min : max);  // starting bid
+        *packet << uint32((max > min) ? max : min);  // buyout
+        *packet << uint32(etime);  // auction duration
+
+        m_bot->GetSession()->QueuePacket(packet);  // queue the packet to get around race condition
+    }
+}
+
+void PlayerbotAI::Buy(uint64 vendorguid, const uint32 itemid)
+{
+    Creature *pCreature = m_bot->GetNPCIfCanInteractWith(vendorguid, UNIT_NPC_FLAG_VENDOR);
+
+    if (!pCreature)
+        return;
+
+    VendorItemData const* vItems = pCreature->GetVendorItems();
+    VendorItemData const* tItems = pCreature->GetVendorItems();
+
+    uint8 customitems = vItems ? vItems->GetItemCount() : 0;
+    uint8 numitems = customitems + (tItems ? tItems->GetItemCount() : 0);
+
+    for (uint8 vendorslot = 0; vendorslot < numitems; ++vendorslot)
+    {
+        VendorItem const* crItem = vendorslot < customitems ? vItems->GetItem(vendorslot) : tItems->GetItem(vendorslot - customitems);
+
+        if (crItem)
+        {
+            if (itemid != crItem->item)
+                continue;
+
+            ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(itemid);
+            if (pProto)
+            {
+                // class wrong item skip only for bindable case
+                if ((pProto->AllowableClass & m_bot->getClassMask()) == 0 && pProto->Bonding == BIND_WHEN_PICKED_UP)
+                    continue;
+
+                // race wrong item skip always
+                if ((pProto->Flags2 & 1) && m_bot->GetTeam() != HORDE)//Horde only
+                    continue;
+
+                if ((pProto->Flags2 & 2) && m_bot->GetTeam() != ALLIANCE)//Alliance only
+                    continue;
+
+                if ((pProto->AllowableRace & m_bot->getRaceMask()) == 0)
+                    continue;
+
+                //// possible item coverting for BoA case
+                //if (pProto->Flags == ITEM_PROTO_FLAG_BIND_TO_ACCOUNT)
+                //    // convert if can use and then buy
+                //    if (pProto->RequiredReputationFaction && uint32(m_bot->GetReputationRank(pProto->RequiredReputationFaction)) >= pProto->RequiredReputationRank)
+                //        // checked at convert data loading as existed
+                //        if (uint32 newItemId = sObjectMgr->GetItemConvert(itemid, m_bot->getRaceMask()))
+                //            pProto = sObjectMgr->GetItemTemplate(newItemId);
+                m_bot->BuyItemFromVendorSlot(vendorguid, vendorslot, itemid, 1, NULL_BAG, NULL_SLOT);
+                return;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::Sell(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        uint32 cost = pItem->GetCount() * pItem->GetTemplate()->SellPrice;
+        m_bot->ModifyMoney(cost);
+        m_bot->MoveItemFromInventory(pItem->GetBagSlot(), pItem->GetSlot(), true);
+        m_bot->AddItemToBuyBackSlot(pItem);
+
+        report << "Sold ";
+        MakeItemLink(pItem, report, true);
+        report << " for ";
+
+        report << Cash(cost);
+
+        TellMaster(report.str());
+    }
+}
+
+void PlayerbotAI::SellGarbage(Player & /*plyer*/, bool bListNonTrash, bool bDetailTrashSold, bool bVerbose)
+{
+    uint32 SoldCost = 0;
+    uint32 SoldQuantity = 0;
+    std::ostringstream report, goods;
+    ChatHandler ch(m_master);
+
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; ++slot)
+    {
+        Item* const item = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (item)
+            _doSellItem(item, report, goods, SoldCost, SoldQuantity);
+    }
+
+    uint8 notempty = 0;
+    if (goods.str().size() != 0)
+    {
+        notempty = 1;
+        TellMaster("Heres a list of items I can sell:");
+    }
+    // and each of our other packs
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag) // check for extra bags
+    {
+        // we want to output the item list to links one bag at a time and clear it, to prevent the list from overloading
+        if (goods.str().size() != 0) // This will be one bag behind in the check. if the previous bag listed anything, llist that now and clear the list
+        {
+            if (notempty == 0)
+            {
+                TellMaster("Heres a list of items I can sell:");
+                notempty = 1; // at least one bag must have had something in it, used at end of this function
+            }
+            else
+            {
+                ch.SendSysMessage(goods.str().c_str()); // previous bags list contents, including main backpack first.
+                goods.str(""); // clear the list for next bag
+            }
+        }
+
+        const Bag* const pBag = static_cast<Bag *>(m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            // Very nice, but who cares what bag it's in?
+            //const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            //std::string bagName = pBagProto->Name1;
+            //ItemLocalization(bagName, pBagProto->ItemId);
+            //goods << "\nIn my " << bagName << ":";
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = m_bot->GetItemByPos(bag, slot);
+                if (item)
+                    _doSellItem(item, report, goods, SoldCost, SoldQuantity);
+            }
+        }
+    }
+
+    if (goods.str().size() != 0) // This will make sure items in the last bag were output to links
+    {
+        ch.SendSysMessage(goods.str().c_str());
+        goods.str(""); // clear the list
+        notempty = 1; // at least one bag must have had something in it, used at end of this function
+    }
+    if (notempty == 1)
+        TellMaster("All of the above items could be sold"); // links are complete, notify master
+
+    if (!bDetailTrashSold) // no trash got sold
+        report.str("");  // clear ostringstream
+
+    if (SoldCost > 0)
+    {
+        if (bDetailTrashSold)
+            report << "Sold total " << SoldQuantity << " item(s) for ";
+        else
+            report << "Sold " << SoldQuantity << " trash item(s) for ";
+        report << Cash(SoldCost);
+
+        if (bVerbose)
+            TellMaster(report.str());
+        if (SellWhite == 1)
+            SellWhite = 0;
+    }
+
+    // For all bags, non-gray sellable items
+    if (bVerbose)
+    {
+        if (SoldQuantity == 0 && notempty == 0)
+            TellMaster("No items to sell, trash or otherwise.");
+    }
+}
+
+std::string PlayerbotAI::DropItem(const uint32 itemid)
+{
+    Item* pItem = FindItem(itemid);
+    if (pItem)
+    {
+        std::ostringstream report;
+
+        // Yea, that's right, get the item info BEFORE you destroy it :)
+        MakeItemText(pItem, report, true);
+
+        m_bot->DestroyItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+
+        return report.str();
+    }
+
+    return "";
+}
+
+void PlayerbotAI::GetTaxi(uint64 guid, BotTaxiNode& nodes)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: GetTaxi - %s node[0] %d node[1] %d", m_bot->GetName(), nodes[0], nodes[1]);
+
+    Creature *unit = m_bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_FLIGHTMASTER);
+    if (!unit)
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: GetTaxi - %u not found or you can't interact with it.", guid);
+        return;
+    }
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[0]) ? 0 : 1)
+        return;
+
+    if (m_bot->m_taxi.IsTaximaskNodeKnown(nodes[nodes.size() - 1]) ? 0 : 1)
+        return;
+
+    if (m_bot->GetPlayerbotAI()->GetMovementOrder() != MOVEMENT_STAY)
+    {
+        m_taxiNodes = nodes;
+        m_taxiMaster = guid;
+        SetState(BOTSTATE_FLYING);
+    }
+}
+
+// handle commands sent through chat channels
+void PlayerbotAI::HandleCommand(const std::string& text, Player& fromPlayer)
+{
+    // prevent bot task spam
+    m_inventory_full = false;
+    m_tasks.unique();
+    m_findNPC.unique();
+
+    // sLog->outDebug(LOG_FILTER_NONE, "chat(%s)",text.c_str());
+
+    // ignore any messages from Addons
+    if (text.empty() ||
+        text.find("X-Perl") != std::wstring::npos ||
+        text.find("HealBot") != std::wstring::npos ||
+        text.find("LOOT_OPENED") != std::wstring::npos ||
+        text.find("CTRA") != std::wstring::npos ||
+        text.find("GathX") == 0) // Gatherer
+        return;
+
+    // if message is not from a player in the masters account auto reply and ignore
+    if (!canObeyCommandFrom(fromPlayer))
+    {
+        // only tell the player once instead of endlessly nagging them
+        if (m_ignorePlayersChat.find(fromPlayer.GetGUID()) == m_ignorePlayersChat.end())
+        {
+            std::string msg = "I can't talk to you. Please speak to my master ";
+            msg += m_master->GetName();
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_NO);
+            m_ignorePlayersChat.insert(fromPlayer.GetGUID());
+        }
+        return;
+    }
+
+    // Passed along to ExtractCommand, if (sub)command is found "input" will only contain the rest of the string (or "")
+    std::string input = text.c_str();
+
+    // if in the middle of a trade, and player asks for an item/money
+    // WARNING: This makes it so you can't use any other commands during a trade!
+    if (m_bot->GetTrader() && m_bot->GetTrader()->GetGUID() == fromPlayer.GetGUID())
+    {
+        uint32 copper = extractMoney(text);
+        if (copper > 0)
+            TradeCopper(copper);
+
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (itemIds.size() == 0)
+            SendWhisper("Show me what item you want by shift clicking the item in the chat window.", fromPlayer);
+        else if (!strncmp(text.c_str(), "nt ", 3))
+        {
+            if (itemIds.size() > 1)
+                SendWhisper("There is only one 'Will not be traded' slot. Shift-click just one item, please!", fromPlayer);
+            else
+            {
+                std::list<Item*> itemList;
+                findItemsInEquip(itemIds, itemList);
+                findItemsInInv(itemIds, itemList);
+                if (itemList.size() > 0)
+                    TradeItem((**itemList.begin()), TRADE_SLOT_NONTRADED);
+                else
+                    SendWhisper("I do not have this item equipped or in my bags!", fromPlayer);
+            }
+        }
+        else
+        {
+            std::list<Item*> itemList;
+            findItemsInInv(itemIds, itemList);
+            for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+                TradeItem(**it);
+        }
+    }
+
+    else if (ExtractCommand("help", input))
+        _HandleCommandHelp(input, fromPlayer);
+
+    else if (fromPlayer.GetSession()->GetSecurity() > SEC_PLAYER && ExtractCommand("gm", input))
+        _HandleCommandGM(input, fromPlayer);
+
+    else if (ExtractCommand("reset", input))
+        _HandleCommandReset(input, fromPlayer);
+    else if (ExtractCommand("orders", input))
+        _HandleCommandOrders(input, fromPlayer);
+    else if (ExtractCommand("follow", input) || ExtractCommand("come", input))
+        _HandleCommandFollow(input, fromPlayer);
+    else if (ExtractCommand("stay", input) || ExtractCommand("stop", input))
+        _HandleCommandStay(input, fromPlayer);
+    else if (ExtractCommand("attack", input))
+        _HandleCommandAttack(input, fromPlayer);
+
+    else if (ExtractCommand("cast", input, true)) // true -> "cast" OR "c"
+        _HandleCommandCast(input, fromPlayer);
+
+    else if (ExtractCommand("sell", input))
+        _HandleCommandSell(input, fromPlayer);
+
+    else if (ExtractCommand("buy", input))
+        _HandleCommandBuy(input, fromPlayer);
+
+    else if (ExtractCommand("drop", input))
+        _HandleCommandDrop(input, fromPlayer);
+
+    else if (ExtractCommand("repair", input))
+        _HandleCommandRepair(input, fromPlayer);
+
+    else if (ExtractCommand("auction", input))
+        _HandleCommandAuction(input, fromPlayer);
+
+    else if (ExtractCommand("mail", input))
+        _HandleCommandMail(input, fromPlayer);
+
+    else if (ExtractCommand("bank", input))
+        _HandleCommandBank(input, fromPlayer);
+
+    else if (ExtractCommand("talent", input))
+        _HandleCommandTalent(input, fromPlayer);
+
+    else if (ExtractCommand("use", input, true)) // true -> "use" OR "u"
+        _HandleCommandUse(input, fromPlayer);
+
+    else if (ExtractCommand("equip", input, true)) // true -> "equip" OR "e"
+        _HandleCommandEquip(input, fromPlayer);
+
+    else if (ExtractCommand("autoequip", input, true)) // switches autoequip on or off if on already
+        _HandleCommandAutoEquip(input, fromPlayer);
+
+    // find project: 20:50 02/12/10 rev.4 item in world and wait until ordered to follow
+    else if (ExtractCommand("find", input, true)) // true -> "find" OR "f"
+        _HandleCommandFind(input, fromPlayer);
+
+    // get project: 20:50 02/12/10 rev.4 compact edition, handles multiple linked gameobject & improves visuals
+    else if (ExtractCommand("get", input, true)) // true -> "get" OR "g"
+        _HandleCommandGet(input, fromPlayer);
+
+    // Handle all collection related commands here
+    else if (ExtractCommand("collect", input))
+        _HandleCommandCollect(input, fromPlayer);
+
+    else if (ExtractCommand("quest", input))
+        _HandleCommandQuest(input, fromPlayer);
+
+    else if (ExtractCommand("craft", input))
+        _HandleCommandCraft(input, fromPlayer);
+
+    else if (ExtractCommand("enchant", input))
+        _HandleCommandEnchant(input, fromPlayer);
+
+    else if (ExtractCommand("process", input))
+        _HandleCommandProcess(input, fromPlayer);
+
+    else if (ExtractCommand("pet", input))
+        _HandleCommandPet(input, fromPlayer);
+
+    else if (ExtractCommand("spells", input))
+        _HandleCommandSpells(input, fromPlayer);
+
+    // survey project: 20:50 02/12/10 rev.4 compact edition
+    else if (ExtractCommand("survey", input))
+        _HandleCommandSurvey(input, fromPlayer);
+
+    // Handle class & professions training:
+    else if (ExtractCommand("skill", input))
+        _HandleCommandSkill(input, fromPlayer);
+
+    // stats project: 11:30 15/12/10 rev.2 display bot statistics
+    else if (ExtractCommand("stats", input))
+        _HandleCommandStats(input, fromPlayer);
+
+    else
+    {
+        // if this looks like an item link, reward item it completed quest and talking to NPC
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        if (!itemIds.empty()) {
+            uint32 itemId = itemIds.front();
+            bool wasRewarded = false;
+            uint64 questRewarderGUID = m_bot->GetSelection();
+            Object* pNpc = sObjectAccessor->GetObjectByTypeMask(*m_bot, questRewarderGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            QuestMenu& questMenu = m_bot->PlayerTalkClass->GetQuestMenu();
+            for (uint32 iI = 0; !wasRewarded && iI < questMenu.GetMenuItemCount(); ++iI)
+            {
+                QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+                uint32 questID = qItem.QuestId;
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+                QuestStatus status = m_bot->GetQuestStatus(questID);
+
+                // if quest is complete, turn it in
+                if (status == QUEST_STATUS_COMPLETE &&
+                    !m_bot->GetQuestRewardStatus(questID) &&
+                    pQuest->GetRewChoiceItemsCount() > 1 &&
+                    m_bot->CanRewardQuest(pQuest, false))
+                    for (uint8 rewardIdx = 0; !wasRewarded && rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+                    {
+                        ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                        if (itemId == pRewardItem->ItemId)
+                        {
+                            m_bot->RewardQuest(pQuest, rewardIdx, pNpc, false);
+
+                            std::string questTitle  = pQuest->GetTitle();
+                            m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questID);
+                            std::string itemName = pRewardItem->Name1;
+                            m_bot->GetPlayerbotAI()->ItemLocalization(itemName, pRewardItem->ItemId);
+
+                            std::ostringstream out;
+                            out << "|cffffffff|Hitem:" << pRewardItem->ItemId << ":0:0:0:0:0:0:0" << "|h[" << itemName << "]|h|r rewarded";
+                            SendWhisper(out.str(), fromPlayer);
+                            wasRewarded = true;
+                        }
+                    }
+            }
+        }
+        else
+        {
+            // TODO: make this only in response to direct whispers (chatting in party chat can in fact be between humans)
+            std::string msg = "What? For a list of commands, ask for 'help'.";
+            SendWhisper(msg, fromPlayer);
+            m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        }
+    }
+}
+
+/**
+ * ExtractCommand looks for a command in a text string
+ * sLookingFor       - string you're looking for (e.g. "help")
+ * text              - string which may or may not start with sLookingFor
+ * bUseShort         - does this command accept the shorthand command? If true, "help" would ALSO look for "h"
+ *
+ * returns true if the string has been found
+ * returns false if the string has not been found
+ */
+bool PlayerbotAI::ExtractCommand(const std::string sLookingFor, std::string &text, bool bUseShort)
+{
+    // ("help" + " ") < "help X"  AND  text's start (as big as sLookingFor) == sLookingFor
+    // Recommend AGAINST adapting this for non-space situations (thinking MangosZero)
+    // - unknown would risk being (short for "use") 'u' + "nknown"
+    if (sLookingFor.size() + 1 < text.size() && text.at(sLookingFor.size()) == ' '
+        && 0 == text.substr(0, sLookingFor.size()).compare(sLookingFor))
+    {
+        text = text.substr(sLookingFor.size() + 1);
+        return true;
+    }
+
+    if (0 == text.compare(sLookingFor))
+    {
+        text = "";
+        return true;
+    }
+
+    if (bUseShort)
+    {
+        if (text.size() > 1 && sLookingFor.at(0) == text.at(0) && text.at(1) == ' ')
+        {
+            text = text.substr(2);
+            return true;
+        }
+        else if (text.size() == 1 && sLookingFor.at(0) == text.at(0))
+        {
+            text = "";
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotAI::_HandleCommandReset(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("reset does not have a subcommand.", fromPlayer);
+        return;
+    }
+    SetState(BOTSTATE_NORMAL);
+    MovementReset();
+    SetQuestNeedItems();
+    SetQuestNeedCreatures();
+    UpdateAttackerInfo();
+    m_lootTargets.clear();
+    m_lootCurrent = 0;
+    m_targetCombat = 0;
+    ClearActiveTalentSpec();
+}
+
+void PlayerbotAI::_HandleCommandOrders(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("orders cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SendOrders(*m_master);
+}
+
+void PlayerbotAI::_HandleCommandFollow(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("auto", text)) // switch to automatic follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        DistOverRide = 0; // this resets follow distance to config default
+        IsUpOrDown = 0;
+        std::ostringstream msg;
+        gTempDist = 1;
+        gTempDist2 = 2;
+
+        if (FollowAutoGo != 2)
+        {
+            FollowAutoGo = 1;
+            msg << "Automatic Follow Distance is now ON";
+            SendWhisper(msg.str(),fromPlayer);
+            return;
+        }
+        else
+        {
+            FollowAutoGo = 0;
+            msg << "Automatic Follow Distance is now OFF";
+            SendWhisper(msg.str(),fromPlayer);
+        }
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (ExtractCommand("reset", text)) // switch to reset follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        DistOverRide = 0; // this resets follow distance to config default
+        IsUpOrDown = 0;
+        std::ostringstream msg;
+        gTempDist = 1;
+        gTempDist2 = 2;
+        msg << "Bit crowded isn't it?";
+        SendWhisper(msg.str(),fromPlayer);
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (ExtractCommand("far", text)) // switch to increment follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        DistOverRide = (DistOverRide + 1); // this increments follow distance
+        std::ostringstream msg;
+        msg << "Increasing My follow distance";
+        SendWhisper(msg.str(),fromPlayer);
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (ExtractCommand("near", text)) // switch to increment follow distance
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'follow'", fromPlayer);
+            return;
+        }
+        if (DistOverRide > 0)
+            DistOverRide = (DistOverRide - 1); // this increments follow distance,
+
+        std::ostringstream msg;
+        if (DistOverRide == 0)
+        {
+            IsUpOrDown = 0;
+            DistOverRide = 0;
+            gTempDist = 1;
+            gTempDist2 = 2;
+            msg << "I'm NOT getting any closer than this";
+        }
+        if (DistOverRide != 0)
+            msg << "Decreasing My follow distance";
+        SendWhisper(msg.str(),fromPlayer);
+        SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+        return;
+    }
+    if (text != "")
+    {
+        SendWhisper("see help for details on using follow.", fromPlayer);
+        return;
+    }
+
+    SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+}
+
+void PlayerbotAI::_HandleCommandStay(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("stay cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    SetMovementOrder(MOVEMENT_STAY);
+}
+
+void PlayerbotAI::_HandleCommandAttack(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("attack cannot have a subcommand.", fromPlayer);
+        return;
+    }
+    uint64 attackOnGuid = fromPlayer.GetSelection();
+    if (attackOnGuid)
+    {
+        if (Unit * thingToAttack = sObjectAccessor->GetUnit(*m_bot, attackOnGuid))
+            if (!m_bot->IsFriendlyTo(thingToAttack) && m_bot->IsWithinLOSInMap(thingToAttack))
+                GetCombatTarget(thingToAttack);
+    }
+    else
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+}
+
+void PlayerbotAI::_HandleCommandCast(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("cast must be used with a single spell link (shift + click the spell).", fromPlayer);
+        return;
+    }
+
+    std::string spellStr = text;
+    uint32 spellId = uint32(atol(spellStr.c_str()));
+
+    // try and get spell ID by name
+    if (spellId == 0)
+    {
+        spellId = getSpellId(spellStr.c_str(), true);
+
+        // try link if text NOT (spellid OR spellname)
+        if (spellId == 0)
+            extractSpellId(text, spellId);
+    }
+
+    if (m_bot->HasAura(spellId))
+    {
+        m_bot->RemoveAurasDueToSpell(spellId, m_bot->GetGUID());
+        return;
+    }
+
+    uint64 castOnGuid = fromPlayer.GetSelection();
+    if (spellId != 0 && m_bot->HasSpell(spellId))
+    {
+        m_spellIdCommand = spellId;
+        if (castOnGuid)
+            m_targetGuidCommand = castOnGuid;
+        else
+            m_targetGuidCommand = m_bot->GetGUID();
+    }
+}
+
+// _HandleCommandSell: Handle selling items
+// sell [Item Link][Item Link] .. -- Sells bot(s) items from inventory
+void PlayerbotAI::_HandleCommandSell(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("all", text)) // switch to auto sell low level white items
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'sell all'", fromPlayer);
+            return;
+        }
+        SellWhite = 1; // this gets reset once sale is complete.  for testing purposes
+        std::ostringstream msg;
+        msg << "I will sell all my low level normal items the next time you sell.";
+        SendWhisper(msg.str(),fromPlayer);
+        return;
+    }
+    if (text == "")
+    {
+        SendWhisper("sell must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+
+    enum NPCFlags VENDOR_MASK = (enum NPCFlags) (UNIT_NPC_FLAG_VENDOR
+                                                 | UNIT_NPC_FLAG_VENDOR_AMMO
+                                                 | UNIT_NPC_FLAG_VENDOR_FOOD
+                                                 | UNIT_NPC_FLAG_VENDOR_POISON
+                                                 | UNIT_NPC_FLAG_VENDOR_REAGENT);
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(SELL_ITEMS, *it));
+    m_findNPC.push_back(VENDOR_MASK);
+}
+
+// _HandleCommandBuy: Handle buying items
+// buy [Item Link][Item Link] .. -- Buys items from vendor
+void PlayerbotAI::_HandleCommandBuy(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("buy must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+
+    uint64 vendorguid = fromPlayer.GetSelection();
+    if (!vendorguid)
+    {
+        SendWhisper("No vendor is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+        return;
+    }
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        Buy(vendorguid, *it);
+}
+
+// _HandleCommandDrop: Handle dropping items
+// drop [Item Link][Item Link] .. -- Drops item(s) from bot's inventory
+void PlayerbotAI::_HandleCommandDrop(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+    {
+        SendWhisper("drop must be used with one or more item links (shift + click the item).", fromPlayer);
+        return;
+    }
+
+    std::ostringstream report;
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+    report << "Dropped ";
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+        report << DropItem(*it);
+
+    if (report.str() == "Dropped ")
+    {
+        SendWhisper("No items were dropped. It would appear something has gone hinky.", fromPlayer);
+        return;
+    }
+
+    report << ".";
+    SendWhisper(report.str(), fromPlayer);
+}
+
+// _HandleCommandRepair: Handle repair items
+// repair  all                      -- repair all bot(s) items
+// repair [Item Link][Item Link] .. -- repair select bot(s) items
+void PlayerbotAI::_HandleCommandRepair(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("all", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("Invalid subcommand for 'repair all'", fromPlayer);
+            return;
+        }
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REPAIR_ITEMS, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+        return;
+    }
+
+    std::list<uint32> itemIds;
+    extractItemIds(text, itemIds);
+
+    for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); it++)
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REPAIR_ITEMS, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_REPAIR);
+    }
+}
+
+// _HandleCommandAuction: Handle auctions:
+// auction                                        -- Lists bot(s) active auctions.
+// auction add [Item Link][Item Link] ..          -- Create bot(s) active auction.
+// auction remove [Auction Link][Auction Link] .. -- Cancel bot(s) active auction. ([Auction Link] from auction)
+void PlayerbotAI::_HandleCommandAuction(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER); // list all bot auctions
+    else if (ExtractCommand("add", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(ADD_AUCTION, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+    else if (ExtractCommand("remove", text))
+    {
+        std::list<uint32> auctionIds;
+        extractAuctionIds(text, auctionIds);
+        for (std::list<uint32>::iterator it = auctionIds.begin(); it != auctionIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(REMOVE_AUCTION, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_AUCTIONEER);
+    }
+    else
+        SendWhisper("I don't understand what you're trying to do", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandMail(std::string &text, Player &fromPlayer)
+{
+    ChatHandler ch(&fromPlayer);
+
+    if (text == "")
+    {
+        ch.SendSysMessage("Syntax: mail <inbox [Mailbox] | getcash [mailid].. | getitem [mailid].. | delete [mailid]..>");
+        return;
+    }
+    else if (ExtractCommand("inbox", text))
+    {
+        uint32 mail_count = 0;
+        extractGOinfo(text, m_lootTargets);
+
+        if (m_lootTargets.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <inbox [Mailbox]>");
+            return;
+        }
+
+        uint64 m_mailboxGuid = m_lootTargets.front();
+        m_lootTargets.pop_front();
+        m_lootTargets.clear();
+
+        if (!m_bot->GetGameObjectIfCanInteractWith(m_mailboxGuid, GAMEOBJECT_TYPE_MAILBOX))
+        {
+            Announce(CANT_USE_TOO_FAR);
+            return;
+        }
+
+        TellMaster("Inbox:\n");
+
+        for (PlayerMails::iterator itr = m_bot->GetMailBegin(); itr != m_bot->GetMailEnd(); ++itr)
+        {
+            std::ostringstream msg;
+            ++mail_count;
+
+            msg << "|cffffcccc|Hmail:" << (*itr)->messageID << "|h[" << (*itr)->messageID << "]|h|r ";
+
+            switch ((*itr)->messageType)
+            {
+                case MAIL_NORMAL:
+                {
+                    msg << "|cffffffff"; // white
+                    if ((*itr)->subject != "")
+                        msg << "Subject: " << (*itr)->subject << "\n";
+
+                    if ((*itr)->body != "")
+                        msg << (*itr)->body << "\n";
+                    break;
+                }
+                case MAIL_CREATURE:
+                    msg << "|cffccffccMAIL_CREATURE\n"; // green
+                    break;
+                case MAIL_GAMEOBJECT:
+                    msg << "|cffccffccMAIL_GAMEOBJECT\n"; // green
+                    break;
+                case MAIL_AUCTION:
+                {
+                    msg << "|cffccffff"; // blue
+                    msg << AuctionResult((*itr)->subject, (*itr)->body) << "\n";
+                    break;
+                }
+                case MAIL_ITEM:
+                    msg << "|cffccffccMAIL_ITEM\n"; // green
+                    break;
+            }
+
+            if ((*itr)->money)
+                msg << "[To Collect: " << Cash((*itr)->money) << " ]\n";
+
+            uint8 item_count = (*itr)->items.size(); // max count is MAX_MAIL_ITEMS (12)
+            if (item_count > 0)
+            {
+                msg << "Items: ";
+                for (uint8 i = 0; i < item_count; ++i)
+                {
+                    Item *item = m_bot->GetMItem((*itr)->items[i].item_guid);
+                    if (item)
+                        MakeItemLink(item, msg, true);
+                }
+            }
+            msg << "\n";
+            ch.SendSysMessage(msg.str().c_str());
+        }
+
+        if (mail_count == 0)
+            ch.SendSysMessage("|cff009900My inbox is empty.");
+    }
+    else if (ExtractCommand("getcash", text))
+    {
+        std::ostringstream msg;
+        std::list<uint32> mailIds;
+        extractMailIds(text, mailIds);
+        uint32 total = 0;
+
+        if (mailIds.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <getcash [mailId]..>");
+            return;
+        }
+
+        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); ++it)
+        {
+            Mail* m = m_bot->GetMail(*it);
+            if (!m || m->state == MAIL_STATE_DELETED || m->deliver_time > time(NULL))
+            {
+                m_bot->SendMailResult(*it, MAIL_MONEY_TAKEN, MAIL_ERR_INTERNAL_ERROR);
+                return;
+            }
+
+            m_bot->SendMailResult(*it, MAIL_MONEY_TAKEN, MAIL_OK);
+            m_bot->ModifyMoney(m->money);
+            total += m->money;
+            m->money = 0;
+            m->state = MAIL_STATE_CHANGED;
+            m_bot->m_mailsUpdated = true;
+            m_bot->UpdateMail();
+        }
+        if (total > 0)
+        {
+            msg << "|cff009900" << "I received: |r" << Cash(total);
+            ch.SendSysMessage(msg.str().c_str());
+        }
+    }
+    else if (ExtractCommand("getitem", text))
+    {
+        std::list<uint32> mailIds;
+        extractMailIds(text, mailIds);
+
+        if (mailIds.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <getitem [mailId]..>");
+            return;
+        }
+
+        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); it++)
+        {
+            Mail* m = m_bot->GetMail(*it);
+            if (!m || m->state == MAIL_STATE_DELETED || m->deliver_time > time(NULL))
+            {
+                m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_INTERNAL_ERROR);
+                return;
+            }
+
+            // prevent cheating with skip client money check
+            if (m_bot->GetMoney() < m->COD)
+            {
+                m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_NOT_ENOUGH_MONEY);
+                return;
+            }
+
+            if (m->HasItems())
+            {
+                bool has_items = true;
+                std::ostringstream msg;
+
+                msg << "|cff009900" << "I received item: |r";
+                for (MailItemInfoVec::const_iterator itr = m->items.begin(); itr != m->items.end(); )
+                {
+                    has_items = true;
+                    Item *item = m_bot->GetMItem(itr->item_guid);
+                    if (!item)
+                    {
+                        ch.SendSysMessage("item not found");
+                        return;
+                    }
+
+                    ItemPosCountVec dest;
+
+                    InventoryResult res = m_bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, item, false);
+                    if (res == EQUIP_ERR_OK)
+                    {
+                        m->removedItems.push_back(itr->item_guid);
+
+                        if (m->COD > 0)  // if there is COD, take COD money from player and send them to sender by mail
+                        {
+                            uint64 sender_guid = MAKE_NEW_GUID(m->sender, 0, HIGHGUID_PLAYER);
+                            Player *sender = sObjectAccessor->FindPlayer(sender_guid);
+
+                            uint32 sender_accId = 0;
+
+                            if (m_master->GetSession()->GetSecurity() > SEC_PLAYER && sWorld->getBoolConfig(CONFIG_GM_LOG_TRADE))
+                            {
+                                std::string sender_name;
+                                if (sender)
+                                {
+                                    sender_accId = sender->GetSession()->GetAccountId();
+                                    sender_name = sender->GetName();
+                                }
+                                else if (sender_guid)
+                                {
+                                    // can be calculated early
+                                    sender_accId = sObjectMgr->GetPlayerAccountIdByGUID(sender_guid);
+
+                                    if (!sObjectMgr->GetPlayerNameByGUID(sender_guid, sender_name))
+                                        sender_name = sObjectMgr->GetTrinityStringForDBCLocale(LANG_UNKNOWN);
+                                }
+                                //sLog->outCommand(m_master->GetSession()->GetAccountId(), "GM %s (Account: %u) receive mail item: %s (Entry: %u Count: %u) and send COD money: %u to player: %s (Account: %u)",
+                                                //m_master->GetSession()->GetPlayerName(), m_master->GetSession()->GetAccountId(), item->GetTemplate()->Name1, item->GetEntry(), item->GetCount(), m->COD, sender_name.c_str(), sender_accId);
+                            }
+                            else if (!sender)
+                                sender_accId = sObjectMgr->GetPlayerAccountIdByGUID(sender_guid);
+
+                            // check player existence
+                            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                            if (sender || sender_accId)
+                                MailDraft(m->subject, "")
+                                .AddMoney(m->COD)
+                                .SendMailTo(trans, MailReceiver(sender, sender_guid), m_bot, MAIL_CHECK_MASK_COD_PAYMENT);
+                            CharacterDatabase.CommitTransaction(trans);
+                            m_bot->ModifyMoney(-int32(m->COD));
+                        }
+                        m->COD = 0;
+                        m->state = MAIL_STATE_CHANGED;
+                        m_bot->m_mailsUpdated = true;
+                        m_bot->RemoveMItem(item->GetGUIDLow());
+
+                        uint32 count = item->GetCount(); // save counts before store and possible merge with deleting
+                        m_bot->MoveItemToInventory(dest, item, true);
+                        m_bot->UpdateMail();
+                        m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_OK, 0, itr->item_guid, count);
+                        if (m->RemoveItem(itr->item_guid))
+                        {
+                            MakeItemLink(item, msg, true);
+                            has_items = false;
+                        }
+                    }
+                    else
+                        m_bot->SendMailResult(*it, MAIL_ITEM_TAKEN, MAIL_ERR_EQUIP_ERROR, res);
+                }
+
+                if (!has_items)
+                {
+                    //SQLTransaction trans = CharacterDatabase.BeginTransaction();
+                    CharacterDatabase.PExecute("UPDATE mail SET has_items = 0 WHERE id = %u", *it);
+                    //CharacterDatabase.CommitTransaction(trans);
+                }
+                msg << "\n";
+                ch.SendSysMessage(msg.str().c_str());
+            }
+        }
+    }
+    else if (ExtractCommand("delete", text))
+    {
+        std::ostringstream msg;
+        std::list<uint32> mailIds;
+        extractMailIds(text, mailIds);
+
+        if (mailIds.empty())
+        {
+            ch.SendSysMessage("Syntax: mail <delete [mailId]..>");
+            return;
+        }
+
+        msg << "|cff009900Mail ";
+        for (std::list<uint32>::iterator it = mailIds.begin(); it != mailIds.end(); ++it)
+        {
+            m_bot->m_mailsUpdated = true;
+
+            if (Mail * m = m_bot->GetMail(*it))
+            {
+                // delete shouldn't show up for COD mails
+                if (m->COD)
+                {
+                    m_bot->SendMailResult(*it, MAIL_DELETED, MAIL_ERR_INTERNAL_ERROR);
+                    return;
+                }
+                m->state = MAIL_STATE_DELETED;
+            }
+
+            m_bot->SendMailResult(*it, MAIL_DELETED, MAIL_OK);
+            //CharacterDatabase.BeginTransaction();
+            CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", *it);
+            CharacterDatabase.PExecute("DELETE FROM mail_items WHERE mail_id = '%u'", *it);
+            //CharacterDatabase.CommitTransaction();
+            m_bot->RemoveMail(*it);
+            msg << "|cffffcccc|h[" << *it << "]|h|r";
+        }
+        msg << "|cff009900 has been deleted..";
+        ch.SendSysMessage(msg.str().c_str());
+    }
+}
+
+// _HandleCommandBank: Handle bank:
+// bank                                        -- Lists bot(s) bank balance.
+// bank deposit [Item Link][Item Link] ..      -- Deposit item(s) in bank.
+// bank withdraw [Item Link][Item Link] ..     -- Withdraw item(s) from bank. ([Item Link] from bank)
+void PlayerbotAI::_HandleCommandBank(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER); // list all bot balance
+    else if (ExtractCommand("deposit", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_DEPOSIT, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+    else if (ExtractCommand("withdraw", text))
+    {
+        std::list<uint32> itemIds;
+        extractItemIds(text, itemIds);
+        for (std::list<uint32>::iterator it = itemIds.begin(); it != itemIds.end(); ++it)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(BANK_WITHDRAW, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_BANKER);
+    }
+    else
+        SendWhisper("I don't understand what you're trying to do", fromPlayer);
+}
+
+// _HandleCommandTalent: Handle talents & glyphs:
+// talent                           -- Lists bot(s) active talents [TALENT LINK] & glyphs [GLYPH LINK], unspent points & cost to reset
+// talent learn [TALENT LINK] ..    -- Learn selected talent from bot client 'inspect' dialog -> 'talent' tab or from talent command (shift click icon/link)
+// talent reset                     -- Resets all talents
+// talent spec                      -- Lists various talentspecs for this bot's class
+// talent spec #                    -- Sets talent spec # as active talentspec
+void PlayerbotAI::_HandleCommandTalent(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream out;
+    if (ExtractCommand("learn", text))
+    {
+        std::list<talentPair>talents;
+        extractTalentIds(text, talents);
+
+        for (std::list<talentPair>::iterator itr = talents.begin(); itr != talents.end(); ++itr)
+        {
+            uint32 talentid = itr->first;
+            uint32 rank = itr->second;
+
+            m_bot->LearnTalent(talentid, ++rank);
+            m_bot->SendTalentsInfoData(false);
+            InspectUpdate();
+        }
+
+        m_bot->MakeTalentGlyphLink(out);
+        SendWhisper(out.str(), fromPlayer);
+    }
+    else if (ExtractCommand("reset", text))
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(RESET_TALENTS, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_TRAINER_CLASS);
+    }
+    else if (ExtractCommand("spec", text))
+    {
+        if (0 == GetTalentSpecsAmount())
+        {
+            //SendWhisper("Database does not contain any Talent Specs (for any classes).", fromPlayer);
+            SendWhisper("spec subcommand is disabled. Sorry", fromPlayer);
+            return;
+        }
+        if (text.size() == 0) // no spec chosen nor other subcommand
+        {
+            std::list<TalentSpec> classSpecs = GetTalentSpecs(long(m_bot->getClass()));
+            std::list<TalentSpec>::iterator it;
+            int count = 0;
+
+            SendWhisper("Please select a talent spec to activate (reply 'talent spec #'):", fromPlayer);
+            for (it = classSpecs.begin(); it != classSpecs.end(); it++)
+            {
+                count++;
+
+                std::ostringstream oss;
+                oss << count << ". " << it->specName;
+                SendWhisper(oss.str(), fromPlayer);
+            }
+            if (count == 0)
+            {
+                std::ostringstream oss;
+                oss << "Error: No TalentSpecs listed. Specs retrieved from DB for this class: %u" << m_bot->getClass();
+                SendWhisper(oss.str(), fromPlayer);
+            }
+        }
+        else
+        {
+            uint32 chosenSpec = strtoul(text.c_str(), NULL, 0); // non-int returns 0; too big returns UINT MAX (or somesuch)
+
+            // Warning: also catches non-int sub2command's - e.g. 'talent spec foobar'
+            if (0 == chosenSpec)
+            {
+                ClearActiveTalentSpec();
+                SendWhisper("The talent spec has been cleared.", fromPlayer);
+            }
+            else if (chosenSpec > GetTalentSpecsAmount(long(m_bot->getClass())))
+                SendWhisper("The talent spec you have chosen is invalid. Please select one from the valid range (reply 'talent spec' for options).", fromPlayer);
+            else
+            {
+                TalentSpec ts = GetTalentSpec(long(m_bot->getClass()), chosenSpec);
+
+                // no use setting it to an invalid (and probably - hopefully - empty) TalentSpec
+                if (0 != ts.specClass && TSP_NONE != ts.specPurpose)
+                {
+                    out << "Activated talent spec: " << chosenSpec << ". " << ts.specName;
+                    SendWhisper(out.str(), fromPlayer);
+                    SetActiveTalentSpec(ts);
+                    if (!ApplyActiveTalentSpec())
+                        SendWhisper("The talent spec has been set active but could not be applied. It appears something has gone awry.", fromPlayer);
+                    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Could set TalentSpec but could not apply it - 'talent spec #': Class: %i; chosenSpec: %li", (long)m_bot->getClass(), chosenSpec);
+                    InspectUpdate();
+                }
+                else
+                {
+                    SendWhisper("An error has occured. Please let a Game Master know. This error has been logged.", fromPlayer);
+                    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: Could not GetTalentSpec to set & apply - 'talent spec #': Class: %i; chosenSpec: %li", (long) m_bot->getClass(), chosenSpec);
+                }
+            }
+        }
+    }
+    // no valid subcommand found for command 'talent'
+    else
+    {
+        uint32 gold = uint32(m_bot->resetTalentsCost() / 10000);
+
+        if (gold > 0)
+            out << "Cost to reset all Talents is " << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+
+        m_bot->MakeTalentGlyphLink(out);
+        SendWhisper(out.str(), fromPlayer);
+    }
+}
+
+void PlayerbotAI::_HandleCommandProcess(std::string &text, Player &fromPlayer)
+{
+    uint32 spellId;
+
+    if (ExtractCommand("disenchant", text, true)) // true -> "process disenchant" OR "process d"
+    {
+        if (m_bot->HasSkill(SKILL_ENCHANTING))
+            spellId = DISENCHANTING_1;
+        else
+        {
+            SendWhisper("|cffff0000I can't disenchant, I don't have the skill.", fromPlayer);
+            return;
+        }
+    }
+    else if (ExtractCommand("mill", text, true)) // true -> "process mill" OR "process m"
+    {
+        if (m_bot->HasSkill(SKILL_INSCRIPTION))
+            spellId = MILLING_1;
+        else
+        {
+            SendWhisper("|cffff0000I can't mill, I don't have the skill.", fromPlayer);
+            return;
+        }
+    }
+    else if (ExtractCommand("prospect", text, true)) // true -> "process prospect" OR "process p"
+    {
+        if (m_bot->HasSkill(SKILL_JEWELCRAFTING) && m_bot->GetPureSkillValue(SKILL_JEWELCRAFTING) >= 20)
+            spellId = PROSPECTING_1;
+        else
+        {
+            SendWhisper("|cffff0000I can't prospect, I don't have the skill.", fromPlayer);
+            return;
+        }
+    }
+    else
+        return;
+
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+
+    if (itemList.empty())
+    {
+        SendWhisper("|cffff0000I can't process that!", fromPlayer);
+        return;
+    }
+
+    Item* reagent = itemList.back();
+    itemList.pop_back();
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return;
+
+    if (reagent)
+    {
+        SpellCastTargets targets;
+        m_itemTarget = reagent->GetTemplate()->ItemId;
+        targets.SetItemTarget(reagent);
+        Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+        spell->prepare(&targets);
+    }
+}
+
+void PlayerbotAI::_HandleCommandUse(std::string &text, Player &fromPlayer)
+{
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+
+    if (itemList.empty())
+    {
+        SendWhisper("|cffff0000I can't use that!", fromPlayer);
+        return;
+    }
+
+    Item* tool = itemList.back();
+    itemList.pop_back();
+    if (tool)
+    {
+        // set target
+        Unit* unit = sObjectAccessor->GetUnit(*m_bot, fromPlayer.GetSelection());
+        findItemsInEquip(itemIds, itemList);
+        extractGOinfo(text, m_lootTargets);
+        // sLog->outDebug(LOG_FILTER_NONE, "tool (%s)",tool->GetTemplate()->Name1);
+
+        if (!itemList.empty())
+        {
+            Item* itarget = itemList.back();
+            if (itarget)
+            {
+                // sLog->outDebug(LOG_FILTER_NONE, "target (%s)",itarget->GetTemplate()->Name1);
+                UseItem(tool, _findItemSlot(itarget)); // on equipped item
+                SetState(BOTSTATE_ENCHANT);
+                SetIgnoreUpdateTime(1);
+            }
+        }
+        else if (!m_lootTargets.empty())
+        {
+            uint64 gotarget = m_lootTargets.front();
+            m_lootTargets.pop_front();
+
+            GameObject *go = m_bot->GetMap()->GetGameObject(gotarget);
+            if (go)
+                // sLog->outDebug(LOG_FILTER_NONE, "tool (%s) on target gameobject (%s)",tool->GetTemplate()->Name1,go->GetGOInfo()->name);
+                UseItem(tool, TARGET_FLAG_GAMEOBJECT, gotarget); // on gameobject
+        }
+        else if (unit)
+            // sLog->outDebug(LOG_FILTER_NONE, "tool (%s) on selected target unit",tool->GetTemplate()->Name1);
+            UseItem(tool, unit); // on unit
+        else
+            // sLog->outDebug(LOG_FILTER_NONE, "tool (%s) on self",tool->GetTemplate()->Name1);
+            UseItem(tool); // on self
+    }
+    return;
+}
+
+void PlayerbotAI::_HandleCommandAutoEquip(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream msg;
+    if (ExtractCommand("now", text, true)) // run autoequip cycle right now
+    {
+        msg << "Running Auto Equip cycle One time. My current setting is" << (AutoEquipPlug ? "ON" : "OFF");
+        SendWhisper(msg.str(),fromPlayer);
+        if (AutoEquipPlug == 0)
+            AutoEquipPlug = 2;
+        Player* const bot = GetPlayerBot();
+        AutoUpgradeEquipment(*bot);
+        return;
+    }
+    else if (ExtractCommand("on", text, true)) // true -> "autoequip on"
+    {
+        AutoEquipPlug = 1;
+        msg << "AutoEquip is now ON";
+        SendWhisper(msg.str(),fromPlayer);
+        return;
+    }
+    else if (ExtractCommand("off", text, true)) // true -> "autoequip off"
+    {
+        AutoEquipPlug = 0;
+        msg << "AutoEquip is now OFF";
+        SendWhisper(msg.str(),fromPlayer);
+        return;
+    }
+    if (AutoEquipPlug != 1)
+        AutoEquipPlug = 1;
+    else
+        AutoEquipPlug = 0;
+    msg << "AutoEquip is now " << (AutoEquipPlug ? "ON" : "OFF");
+    SendWhisper(msg.str(),fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandEquip(std::string &text, Player &fromPlayer)
+{
+    std::list<uint32> itemIds;
+    std::list<Item*> itemList;
+    extractItemIds(text, itemIds);
+    findItemsInInv(itemIds, itemList);
+    for (std::list<Item*>::iterator it = itemList.begin(); it != itemList.end(); ++it)
+        EquipItem(*it);
+    InspectUpdate();
+    SendNotEquipList(*m_bot);
+}
+
+void PlayerbotAI::_HandleCommandFind(std::string &text, Player &fromPlayer)
+{
+    if (text == "")
+        return;
+    extractGOinfo(text, m_lootTargets);
+
+    if (m_lootTargets.empty())
+        return;
+
+    m_lootCurrent = m_lootTargets.front();
+    m_lootTargets.pop_front();
+
+    GameObject *go = m_bot->GetMap()->GetGameObject(m_lootCurrent);
+    if (!go)
+    {
+        m_lootTargets.clear();
+        m_lootCurrent = 0;
+        return;
+    }
+
+    SetMovementOrder(MOVEMENT_STAY);
+    m_bot->GetMotionMaster()->MovePoint(go->GetMapId(), go->GetPositionX(), go->GetPositionY(), go->GetPositionZ());
+    m_lootTargets.clear();
+    m_lootCurrent = 0;
+}
+
+void PlayerbotAI::_HandleCommandGet(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        extractGOinfo(text, m_lootTargets);
+        SetState(BOTSTATE_LOOTING);
+        return;
+    }
+
+    // get a selected lootable corpse
+    uint64 getOnGuid = fromPlayer.GetSelection();
+    if (getOnGuid)
+    {
+        Creature *c = m_bot->GetMap()->GetCreature(getOnGuid);
+        if (!c)
+            return;
+
+        uint32 skillId = 0;
+        if (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+            skillId = c->GetCreatureTemplate()->GetRequiredLootSkill();
+
+        if (c->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE) ||
+            (c->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE) && m_bot->HasSkill(skillId)))
+        {
+            m_lootTargets.push_back(getOnGuid);
+            SetState(BOTSTATE_LOOTING);
+        }
+        else
+            SendWhisper("Target is not lootable by me.", fromPlayer);
+    }
+    else
+    {
+        SendWhisper("No target is selected.", fromPlayer);
+        m_bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+}
+
+void PlayerbotAI::_HandleCommandCollect(std::string &text, Player &fromPlayer)
+{
+    while (text.size() > 0)
+    {
+        if (ExtractCommand("combat", text))
+            SetCollectFlag(COLLECT_FLAG_COMBAT);
+        else if (ExtractCommand("loot", text))
+            SetCollectFlag(COLLECT_FLAG_LOOT);
+        else if (ExtractCommand("quest", text))
+            SetCollectFlag(COLLECT_FLAG_QUEST);
+        else if (ExtractCommand("profession", text) || ExtractCommand("skill", text))
+            SetCollectFlag(COLLECT_FLAG_PROFESSION);
+        else if (ExtractCommand("skin", text) && m_bot->HasSkill(SKILL_SKINNING)) // removes skin even if bot does not have skill
+            SetCollectFlag(COLLECT_FLAG_SKIN);
+        else if (ExtractCommand("objects", text) || ExtractCommand("nearby", text))
+        {
+            SetCollectFlag(COLLECT_FLAG_NEAROBJECT);
+            if (!HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+                m_collectObjects.clear();
+        }
+        else if (ExtractCommand("distance:", text))
+        {
+            uint32 distance;
+            sscanf(text.c_str(), "distance:%u", &distance);
+            if (distance > 0 && distance <= m_confCollectDistanceMax)
+            {
+                m_confCollectDistance = distance;
+                std::ostringstream oss;
+                oss << "I will now collect items within " << m_confCollectDistance << " yards.";
+                SendWhisper(oss.str(), fromPlayer);
+            }
+            else
+            {
+                m_confCollectDistance = m_confCollectDistanceMax;
+                std::stringstream oss;
+                oss << "I will now collect items within " << m_confCollectDistanceMax << " yards. " << distance << " yards is just too far away.",
+                SendWhisper(oss.str(), fromPlayer);
+            }
+        }
+        else if (ExtractCommand("none", text) || ExtractCommand("nothing", text))
+        {
+            m_collectionFlags = 0;
+            m_collectObjects.clear();
+            break;  // because none is an exclusive choice
+        }
+        else
+        {
+            std::ostringstream oss;
+            oss << "Collect <collectable(s)>: none | distance:<1-" << m_confCollectDistanceMax << ">, combat, loot, quest, profession, objects";
+            if (m_bot->HasSkill(SKILL_SKINNING))
+                oss << ", skin";
+            // TODO: perhaps change the command syntax, this way may be lacking in ease of use
+            SendWhisper(oss.str(), fromPlayer);
+            break;
+        }
+    }
+
+    std::string collset = "";
+    if (HasCollectFlag(COLLECT_FLAG_LOOT))
+        collset += ", all loot";
+    if (HasCollectFlag(COLLECT_FLAG_PROFESSION))
+        collset += ", profession";
+    if (HasCollectFlag(COLLECT_FLAG_QUEST))
+        collset += ", quest";
+    if (HasCollectFlag(COLLECT_FLAG_SKIN))
+        collset += ", skin";
+    if (collset.length() > 1)
+    {
+        if (HasCollectFlag(COLLECT_FLAG_COMBAT))
+            collset += " items after combat";
+        else
+            collset += " items";
+    }
+
+    if (HasCollectFlag(COLLECT_FLAG_NEAROBJECT))
+    {
+        if (collset.length() > 1)
+            collset += " and ";
+        else
+            collset += " ";    // padding for substr
+        collset += "nearby objects (";
+        if (!m_collectObjects.empty())
+        {
+            std::string strobjects = "";
+            for (BotEntryList::iterator itr = m_collectObjects.begin(); itr != m_collectObjects.end(); ++itr)
+            {
+                uint32 objectentry = *(itr);
+                GameObjectTemplate const * gInfo = sObjectMgr->GetGameObjectTemplate(objectentry);
+                strobjects += ", ";
+                strobjects += gInfo->name;
+            }
+            collset += strobjects.substr(2);
+        }
+        else
+            collset += "use survey and get to set";
+        collset += ")";
+    }
+
+    if (collset.length() > 1)
+        SendWhisper("I'm collecting " + collset.substr(2), fromPlayer);
+    else
+        SendWhisper("I'm collecting nothing.", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandEnchant(std::string &text, Player &fromPlayer)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "Enchant (%s)",text.c_str());
+
+    if (!m_bot->HasSkill(SKILL_ENCHANTING))
+    {
+        SendWhisper("|cffff0000I can't enchant, I don't have the skill.", fromPlayer);
+        return;
+    }
+
+    if (text.size() > 0)
+    {
+        uint32 spellId;
+        extractSpellId(text, spellId);
+
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo)
+            return;
+
+        std::list<uint32> itemIds;
+        std::list<Item*> itemList;
+        extractItemIds(text, itemIds);
+        findItemsInEquip(itemIds, itemList);
+        findItemsInInv(itemIds, itemList);
+
+        if (itemList.empty())
+        {
+            SendWhisper("|cffff0000I can't enchant that!", fromPlayer);
+            return;
+        }
+
+        Item* iTarget = itemList.back();
+        itemList.pop_back();
+
+        if (iTarget)
+        {
+            SpellCastTargets targets;
+            targets.SetItemTarget(iTarget);
+            Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+            spell->prepare(&targets);
+            SetState(BOTSTATE_ENCHANT);
+            SetIgnoreUpdateTime(1);
+        }
+        return;
+    }
+    else
+    {
+        std::ostringstream msg;
+        uint32 charges;
+        uint32 linkcount = 0;
+
+        m_spellsToLearn.clear();
+        m_bot->skill(m_spellsToLearn);
+        SendWhisper("I can enchant:\n", fromPlayer);
+        ChatHandler ch(&fromPlayer);
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+
+            if (SkillLine->categoryId == SKILL_CATEGORY_PROFESSION && *it == SKILL_ENCHANTING)
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *SkillAbility = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!SkillAbility)
+                        continue;
+
+                    SpellEntry const* spellInfo = sSpellStore.LookupEntry(SkillAbility->spellId);
+                    if (!spellInfo)
+                        continue;
+
+                    if (IsPrimaryProfessionSkill(*it) && spellInfo->Effect[0] != SPELL_EFFECT_ENCHANT_ITEM)
+                        continue;
+
+                    if (SkillAbility->skillId == *it && m_bot->HasSpell(SkillAbility->spellId) && SkillAbility->forward_spellid == 0 && ((SkillAbility->classmask & m_bot->getClassMask()) == 0))
+                    {
+                        MakeSpellLink(spellInfo, msg);
+                        ++linkcount;
+                        if ((charges = GetSpellCharges(SkillAbility->spellId)) > 0)
+                            msg << "[" << charges << "]";
+                        if (linkcount >= 10)
+                        {
+                            ch.SendSysMessage(msg.str().c_str());
+                            linkcount = 0;
+                            msg.str("");
+                        }
+                    }
+                }
+        }
+        m_noToolList.unique();
+        for (std::list<uint32>::iterator it = m_noToolList.begin(); it != m_noToolList.end(); it++)
+            HasTool(*it);
+        ch.SendSysMessage(msg.str().c_str());
+        m_noToolList.clear();
+        m_spellsToLearn.clear();
+    }
+}
+
+void PlayerbotAI::_HandleCommandCraft(std::string &text, Player &fromPlayer)
+{
+    // sLog->outDebug(LOG_FILTER_NONE, "Craft (%s)",text.c_str());
+
+    std::ostringstream msg;
+    uint32 charges;
+    uint32 skill;
+    int32 category;
+    uint32 linkcount = 0;
+
+    if (ExtractCommand("alchemy", text, true)) // true -> "craft alchemy" OR "craft a"
+    {
+        if (m_bot->HasSkill(SKILL_ALCHEMY))
+        {
+            skill = SKILL_ALCHEMY;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("blacksmithing", text, true)) // true -> "craft blacksmithing" OR "craft b"
+    {
+        if (m_bot->HasSkill(SKILL_BLACKSMITHING))
+        {
+            skill = SKILL_BLACKSMITHING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("cooking", text, true)) // true -> "craft cooking" OR "craft c"
+    {
+        if (m_bot->HasSkill(SKILL_COOKING))
+        {
+            skill = SKILL_COOKING;
+            category = SKILL_CATEGORY_SECONDARY;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("engineering", text, true)) // true -> "craft engineering" OR "craft e"
+    {
+        if (m_bot->HasSkill(SKILL_ENGINEERING))
+        {
+            skill = SKILL_ENGINEERING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("firstaid", text, true)) // true -> "craft firstaid" OR "craft f"
+    {
+        if (m_bot->HasSkill(SKILL_FIRST_AID))
+        {
+            skill = SKILL_FIRST_AID;
+            category = SKILL_CATEGORY_SECONDARY;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("inscription", text, true)) // true -> "craft inscription" OR "craft i"
+    {
+        if (m_bot->HasSkill(SKILL_INSCRIPTION))
+        {
+            skill = SKILL_INSCRIPTION;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("jewelcrafting", text, true)) // true -> "craft jewelcrafting" OR "craft j"
+    {
+        if (m_bot->HasSkill(SKILL_JEWELCRAFTING))
+        {
+            skill = SKILL_JEWELCRAFTING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("leatherworking", text, true)) // true -> "craft leatherworking" OR "craft l"
+    {
+        if (m_bot->HasSkill(SKILL_LEATHERWORKING))
+        {
+            skill = SKILL_LEATHERWORKING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("magic", text, true)) // true -> "craft magic" OR "craft m"
+    {
+        if (m_bot->HasSkill(SKILL_ENCHANTING))
+        {
+            skill = SKILL_ENCHANTING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("smelting", text, true)) // true -> "craft smelting" OR "craft s"
+    {
+        if (m_bot->HasSkill(SKILL_MINING))
+        {
+            skill = SKILL_MINING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else if (ExtractCommand("tailoring", text, true)) // true -> "craft tailoring" OR "craft t"
+    {
+        if (m_bot->HasSkill(SKILL_TAILORING))
+        {
+            skill = SKILL_TAILORING;
+            category = SKILL_CATEGORY_PROFESSION;
+        }
+        else
+            return;
+    }
+    else
+    {
+        uint32 spellId;
+        extractSpellId(text, spellId);
+
+        if (!m_bot->HasSpell(spellId))
+        {
+            SendWhisper("|cffff0000I don't have that spell.", fromPlayer);
+            return;
+        }
+
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo)
+            return;
+
+        SpellCastTargets targets;
+        Spell *spell = new Spell(m_bot, spellInfo, TRIGGERED_NONE);
+
+        if (text.find("all", 0) != std::string::npos)
+        {
+            SpellCastResult result = spell->CheckCast(true);
+
+            if (result != SPELL_CAST_OK)
+                spell->SendCastResult(result);
+            else
+            {
+                spell->prepare(&targets);
+                m_CurrentlyCastingSpellId = spellId;
+                SetState(BOTSTATE_CRAFT);
+            }
+        }
+        else
+            spell->prepare(&targets);
+        return;
+    }
+
+    m_spellsToLearn.clear();
+    m_bot->skill(m_spellsToLearn);
+    SendWhisper("I can create:\n", fromPlayer);
+    ChatHandler ch(&fromPlayer);
+    for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+    {
+        SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+
+        if (SkillLine->categoryId == category && *it == skill)
+            for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+            {
+                SkillLineAbilityEntry const *SkillAbility = sSkillLineAbilityStore.LookupEntry(j);
+                if (!SkillAbility)
+                    continue;
+
+                SpellEntry const* spellInfo = sSpellStore.LookupEntry(SkillAbility->spellId);
+                if (!spellInfo)
+                    continue;
+
+                if (IsPrimaryProfessionSkill(*it) && spellInfo->Effect[0] != SPELL_EFFECT_CREATE_ITEM)
+                    continue;
+
+                if (SkillAbility->skillId == *it && m_bot->HasSpell(SkillAbility->spellId) && SkillAbility->forward_spellid == 0 && ((SkillAbility->classmask & m_bot->getClassMask()) == 0))
+                {
+                    MakeSpellLink(spellInfo, msg);
+                    ++linkcount;
+                    if ((charges = GetSpellCharges(SkillAbility->spellId)) > 0)
+                        msg << "[" << charges << "]";
+                    if (linkcount >= 10)
+                    {
+                        ch.SendSysMessage(msg.str().c_str());
+                        linkcount = 0;
+                        msg.str("");
+                    }
+                }
+            }
+    }
+    m_noToolList.unique();
+    for (std::list<uint32>::iterator it = m_noToolList.begin(); it != m_noToolList.end(); it++)
+        HasTool(*it);
+    ch.SendSysMessage(msg.str().c_str());
+    m_noToolList.clear();
+    m_spellsToLearn.clear();
+}
+
+void PlayerbotAI::_HandleCommandQuest(std::string &text, Player &fromPlayer)
+{
+    std::ostringstream msg;
+
+    if (ExtractCommand("add", text, true)) // true -> "quest add" OR "quest a"
+    {
+        std::list<uint32> questIds;
+        extractQuestIds(text, questIds);
+        for (std::list<uint32>::iterator it = questIds.begin(); it != questIds.end(); it++)
+            m_tasks.push_back(std::pair<enum TaskFlags, uint32>(TAKE_QUEST, *it));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("drop", text, true)) // true -> "quest drop" OR "quest d"
+    {
+        fromPlayer.SetSelection(m_bot->GetGUID());
+        PlayerbotChatHandler ch(m_master);
+        int8 linkStart = text.find("|");
+        if (text.find("|") != std::string::npos)
+        {
+            if (!ch.dropQuest((char *) text.substr(linkStart).c_str()))
+                ch.sysmessage("ERROR: could not drop quest");
+            else
+            {
+                SetQuestNeedItems();
+                SetQuestNeedCreatures();
+            }
+        }
+    }
+    else if (ExtractCommand("list", text, true)) // true -> "quest list" OR "quest l"
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(LIST_QUEST, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else if (ExtractCommand("report", text))
+        SendQuestNeedList();
+    else if (ExtractCommand("end", text, true)) // true -> "quest end" OR "quest e"
+    {
+        m_tasks.push_back(std::pair<enum TaskFlags, uint32>(END_QUEST, 0));
+        m_findNPC.push_back(UNIT_NPC_FLAG_QUESTGIVER);
+    }
+    else
+    {
+        bool hasIncompleteQuests = false;
+        std::ostringstream incomout;
+        incomout << "my incomplete quests are:";
+        bool hasCompleteQuests = false;
+        std::ostringstream comout;
+        comout << "my complete quests are:";
+        for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+        {
+            if (uint32 questId = m_bot->GetQuestSlotQuestId(slot))
+            {
+                Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+
+                std::string questTitle  = pQuest->GetTitle();
+                m_bot->GetPlayerbotAI()->QuestLocalization(questTitle, questId);
+
+                if (m_bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+                {
+                    hasCompleteQuests = true;
+                    comout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+                }
+                else
+                {
+                    Item* qitem = FindItem(pQuest->GetSrcItemId());
+                    if (qitem)
+                        incomout << " use " << "|cffffffff|Hitem:" << qitem->GetTemplate()->ItemId << ":0:0:0:0:0:0:0" << "|h[" << qitem->GetTemplate()->Name1 << "]|h|r" << " on ";
+                    hasIncompleteQuests = true;
+                    incomout << " |cFFFFFF00|Hquest:" << questId << ':' << pQuest->GetQuestLevel() << "|h[" <<  questTitle << "]|h|r";
+                }
+            }
+        }
+        if (hasCompleteQuests)
+            SendWhisper(comout.str(), fromPlayer);
+        if (hasIncompleteQuests)
+            SendWhisper(incomout.str(), fromPlayer);
+        if (!hasCompleteQuests && !hasIncompleteQuests)
+            SendWhisper("I have no quests.", fromPlayer);
+    }
+}
+
+void PlayerbotAI::_HandleCommandPet(std::string &text, Player &fromPlayer)
+{
+    if (ExtractCommand("tame", text))
+    {
+        if (m_bot->GetPetGUID())
+        {
+            SendWhisper("I already have a pet!", fromPlayer);
+            return;
+        }
+
+        uint64 castOnGuid = fromPlayer.GetSelection();
+        if (castOnGuid && m_bot->HasSpell(TAME_BEAST_1))
+        {
+            if (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, 0))
+                CastSpell(ASPECT_OF_THE_MONKEY, *m_bot);
+            m_targetGuidCommand = castOnGuid;
+            SetState(BOTSTATE_TAME);
+        }
+        else
+            SendWhisper("I can't tame that!", fromPlayer);
+        return;
+    }
+
+    Pet * pet = m_bot->GetPet();
+    if (!pet)
+    {
+        SendWhisper("I have no pet.", fromPlayer);
+        return;
+    }
+
+    if (ExtractCommand("abandon", text))
+    {
+        // abandon pet
+        WorldPacket* const packet = new WorldPacket(CMSG_PET_ABANDON, 8);
+        *packet << pet->GetGUID();
+        m_bot->GetSession()->QueuePacket(packet);
+
+    }
+    else if (ExtractCommand("react", text))
+    {
+        if (ExtractCommand("aggressive", text, true))
+            pet->SetReactState(REACT_AGGRESSIVE);
+        else if (ExtractCommand("defensive", text, true))
+            pet->SetReactState(REACT_DEFENSIVE);
+        else if (ExtractCommand("passive", text, true))
+            pet->SetReactState(REACT_PASSIVE);
+        else
+            _HandleCommandHelp("pet react", fromPlayer);
+    }
+    else if (ExtractCommand("state", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("'pet state' does not support subcommands.", fromPlayer);
+            return;
+        }
+
+        std::string state;
+        switch (pet->GetReactState())
+        {
+            case REACT_AGGRESSIVE:
+                SendWhisper("My pet is aggressive.", fromPlayer);
+                break;
+            case REACT_DEFENSIVE:
+                SendWhisper("My pet is defensive.", fromPlayer);
+                break;
+            case REACT_PASSIVE:
+                SendWhisper("My pet is passive.", fromPlayer);
+        }
+    }
+    else if (ExtractCommand("cast", text))
+    {
+        if (text == "")
+        {
+            _HandleCommandHelp("pet cast", fromPlayer);
+            return;
+        }
+
+        uint32 spellId = (uint32) atol(text.c_str());
+
+        if (spellId == 0)
+        {
+            spellId = getPetSpellId(text.c_str());
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (spellId != 0 && pet->HasSpell(spellId))
+        {
+            if (pet->HasAura(spellId))
+            {
+                pet->RemoveAurasDueToSpell(spellId, pet->GetGUID());
+                return;
+            }
+
+            uint64 castOnGuid = fromPlayer.GetSelection();
+            Unit* pTarget = sObjectAccessor->GetUnit(*m_bot, castOnGuid);
+            CastPetSpell(spellId, pTarget);
+        }
+    }
+    else if (ExtractCommand("toggle", text))
+    {
+        if (text == "")
+        {
+            _HandleCommandHelp("pet toggle", fromPlayer);
+            return;
+        }
+
+        uint32 spellId = (uint32) atol(text.c_str());
+
+        if (spellId == 0)
+        {
+            spellId = getPetSpellId(text.c_str());
+            if (spellId == 0)
+                extractSpellId(text, spellId);
+        }
+
+        if (spellId != 0 && pet->HasSpell(spellId))
+        {
+            PetSpellMap::iterator itr = pet->m_spells.find(spellId);
+            if (itr != pet->m_spells.end())
+            {
+                if (itr->second.active == ACT_ENABLED)
+                {
+                    pet->ToggleAutocast(sSpellMgr->GetSpellInfo(spellId), false);
+                    if (pet->HasAura(spellId))
+                        pet->RemoveAurasDueToSpell(spellId, pet->GetGUID());
+                }
+                else
+                    pet->ToggleAutocast(sSpellMgr->GetSpellInfo(spellId), true);
+            }
+        }
+    }
+    else if (ExtractCommand("spells", text))
+    {
+        if (text != "")
+        {
+            SendWhisper("'pet spells' does not support subcommands.", fromPlayer);
+            return;
+        }
+
+        int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+        std::ostringstream posOut;
+        std::ostringstream negOut;
+
+        for (PetSpellMap::iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            const uint32 spellId = itr->first;
+
+            if (itr->second.state == PETSPELL_REMOVED || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+                continue;
+
+            const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            std::string color;
+            switch (itr->second.active)
+            {
+                case ACT_ENABLED:
+                    color = "cff35d22d"; // Some flavor of green
+                    break;
+                default:
+                    color = "cffffffff";
+            }
+
+            if (sSpellMgr->GetSpellInfo(spellId)->IsPositive())
+                posOut << " |" << color << "|Hspell:" << spellId << "|h["
+                       << pSpellInfo->SpellName[loc] << "]|h|r";
+            else
+                negOut << " |" << color << "|Hspell:" << spellId << "|h["
+                       << pSpellInfo->SpellName[loc] << "]|h|r";
+        }
+
+        ChatHandler ch(&fromPlayer);
+        SendWhisper("Here's my pet's non-attack spells:", fromPlayer);
+        ch.SendSysMessage(posOut.str().c_str());
+        SendWhisper("and here's my pet's attack spells:", fromPlayer);
+        ch.SendSysMessage(negOut.str().c_str());
+    }
+}
+
+void PlayerbotAI::_HandleCommandSpells(std::string &text, Player &fromPlayer)
+{
+    int loc = m_master->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    typedef std::map<std::string, uint32> spellMap;
+
+    spellMap posSpells, negSpells;
+    std::string spellName;
+
+    uint32 ignoredSpells[] = {1843, 5019, 2479, 6603, 3365, 8386, 21651, 21652, 6233, 6246, 6247,
+                              61437, 22810, 22027, 45927, 7266, 7267, 6477, 6478, 7355, 68398};
+    uint32 ignoredSpellsCount = sizeof(ignoredSpells) / sizeof(uint32);
+
+    for (PlayerSpellMap::iterator itr = m_bot->GetSpellMap().begin(); itr != m_bot->GetSpellMap().end(); ++itr)
+    {
+        const uint32 spellId = itr->first;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || sSpellMgr->GetSpellInfo(spellId)->IsPassive())
+            continue;
+
+        const SpellInfo * pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        spellName = pSpellInfo->SpellName[loc];
+
+        SkillLineAbilityMapBounds const bounds = sSpellMgr->GetSkillLineAbilityMapBounds(spellId);
+
+        bool isProfessionOrRidingSpell = false;
+        for (SkillLineAbilityMap::const_iterator skillIter = bounds.first; skillIter != bounds.second; ++skillIter)
+        {
+            if (IsProfessionOrRidingSkill(skillIter->second->skillId) && skillIter->first == spellId) {
+                isProfessionOrRidingSpell = true;
+                break;
+            }
+        }
+        if (isProfessionOrRidingSpell)
+            continue;
+
+        bool isIgnoredSpell = false;
+        for (uint8 i = 0; i < ignoredSpellsCount; ++i)
+        {
+            if (spellId == ignoredSpells[i]) {
+                isIgnoredSpell = true;
+                break;
+            }
+        }
+        if (isIgnoredSpell)
+            continue;
+
+        if (sSpellMgr->GetSpellInfo(spellId)->IsPositive()) {
+            if (posSpells.find(spellName) == posSpells.end())
+                posSpells[spellName] = spellId;
+            else if (posSpells[spellName] < spellId)
+                posSpells[spellName] = spellId;
+        }
+        else
+        {
+            if (negSpells.find(spellName) == negSpells.end())
+                negSpells[spellName] = spellId;
+            else if (negSpells[spellName] < spellId)
+                negSpells[spellName] = spellId;
+        }
+    }
+
+    for (spellMap::const_iterator iter = posSpells.begin(); iter != posSpells.end(); ++iter)
+    {
+        posOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
+    }
+
+    for (spellMap::const_iterator iter = negSpells.begin(); iter != negSpells.end(); ++iter)
+    {
+        negOut << " |cffffffff|Hspell:" << iter->second << "|h[" << iter->first << "]|h|r";
+    }
+
+    ChatHandler ch(&fromPlayer);
+    SendWhisper("here's my non-attack spells:", fromPlayer);
+    ch.SendSysMessage(posOut.str().c_str());
+    SendWhisper("and here's my attack spells:", fromPlayer);
+    ch.SendSysMessage(negOut.str().c_str());
+}
+
+void PlayerbotAI::_HandleCommandSurvey(std::string &text, Player &fromPlayer)
+{
+    uint32 count = 0;
+    std::ostringstream detectout;
+    QueryResult result;
+    GameEventMgr::ActiveEvents const& activeEventsList = sGameEventMgr->GetActiveEventList();
+    std::ostringstream eventFilter;
+    eventFilter << " AND (eventEntry IS NULL ";
+    bool initString = true;
+
+    for (GameEventMgr::ActiveEvents::const_iterator itr = activeEventsList.begin(); itr != activeEventsList.end(); ++itr)
+    {
+        if (initString)
+        {
+            eventFilter <<  "OR eventEntry IN (" << *itr;
+            initString = false;
+        }
+        else
+            eventFilter << "," << *itr;
+    }
+
+    if (!initString)
+        eventFilter << "))";
+    else
+        eventFilter << ")";
+
+    result = WorldDatabase.PQuery("SELECT gameobject.guid, id, position_x, position_y, position_z, map, "
+                                  "(POW(position_x - %f, 2) + POW(position_y - %f, 2) + POW(position_z - %f, 2)) AS order_ FROM gameobject "
+                                  "LEFT OUTER JOIN game_event_gameobject on gameobject.guid=game_event_gameobject.guid WHERE map = '%i' %s ORDER BY order_ ASC LIMIT 10",
+                                  m_bot->GetPositionX(), m_bot->GetPositionY(), m_bot->GetPositionZ(), m_bot->GetMapId(), eventFilter.str().c_str());
+
+    if (result)
+    {
+        do
+        {
+            Field *fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint32 entry = fields[1].GetUInt32();
+
+            GameObject *go = m_bot->GetMap()->GetGameObject(MAKE_NEW_GUID(guid, 0, HIGHGUID_GAMEOBJECT));
+            if (!go)
+                continue;
+
+            if (!go->isSpawned())
+                continue;
+
+            detectout << "|cFFFFFF00|Hfound:" << guid << ":" << entry  << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+            ++count;
+        } while (result->NextRow());
+
+        //delete result;
+    }
+    SendWhisper(detectout.str().c_str(), fromPlayer);
+}
+
+// _HandleCommandSkill: Handle class & professions training:
+// skill                           -- Lists bot(s) Primary profession skills & weapon skills
+// skill learn                     -- List available class or profession (Primary or Secondary) skills, spells & abilities from selected trainer.
+// skill learn [HLINK][HLINK] ..   -- Learn selected skill and spells, from selected trainer ([HLINK] from skill learn).
+// skill unlearn [HLINK][HLINK] .. -- Unlearn selected primary profession skill(s) and all associated spells ([HLINK] from skill)
+void PlayerbotAI::_HandleCommandSkill(std::string &text, Player &fromPlayer)
+{
+    uint32 rank[8] = {0, 75, 150, 225, 300, 375, 450, 525};
+
+    std::ostringstream msg;
+
+    if (ExtractCommand("learn", text))
+    {
+        uint32 totalCost = 0;
+
+        Unit* unit = sObjectAccessor->GetUnit(*m_bot, fromPlayer.GetSelection());
+        if (!unit)
+        {
+            SendWhisper("Please select the trainer!", fromPlayer);
+            return;
+        }
+
+        if (!unit->isTrainer())
+        {
+            SendWhisper("This is not a trainer!", fromPlayer);
+            return;
+        }
+
+        Creature *creature =  m_bot->GetMap()->GetCreature(fromPlayer.GetSelection());
+        if (!creature)
+            return;
+
+        if (!creature->isCanTrainingOf(m_bot, false))
+        {
+            SendWhisper("This trainer can not teach me anything!", fromPlayer);
+            return;
+        }
+
+        // check present spell in trainer spell list
+        TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+        //TrainerSpellData const* tSpells = creature->GetTrainerTemplateSpells();
+        if (!cSpells)
+        {
+            SendWhisper("No spells can be learnt from this trainer", fromPlayer);
+            return;
+        }
+
+        // reputation discount
+        float fDiscountMod =  m_bot->GetReputationPriceDiscount(creature);
+
+        // Handle: Learning class or profession (primary or secondary) skill & spell(s) for selected trainer, skill learn [HLINK][HLINK][HLINK].. ([HLINK] from skill train)
+        if (text.size() > 0)
+        {
+            msg << "I have learned the following spells:\r";
+            uint32 totalSpellLearnt = 0;
+            bool visuals = true;
+            m_spellsToLearn.clear();
+            extractSpellIdList(text, m_spellsToLearn);
+            for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); it++)
+            {
+                uint32 spellId = *it;
+
+                if (!spellId)
+                    break;
+
+                TrainerSpell const* trainer_spell = cSpells->Find(spellId);
+                if (!trainer_spell)
+                    continue;
+
+                uint32 reqLevel = 0;
+                if (!trainer_spell->learnedSpell[0] && !m_bot->IsSpellFitByClassAndRace(trainer_spell->learnedSpell[0]))
+                    continue;
+
+                if (sSpellMgr->GetSpellInfo(trainer_spell->learnedSpell[0])->IsPrimaryProfession() && m_bot->HasSpell(trainer_spell->learnedSpell[0]))
+                    continue;
+
+                reqLevel = trainer_spell->reqLevel ? trainer_spell->reqLevel : std::max(reqLevel, trainer_spell->reqLevel);
+
+                TrainerSpellState state =  m_bot->GetTrainerSpellState(trainer_spell);
+                if (state != TRAINER_SPELL_GREEN)
+                    continue;
+
+                // apply reputation discount
+                uint32 cost = uint32(floor(trainer_spell->spellCost * fDiscountMod));
+                // check money requirement
+                if (m_bot->GetMoney() < cost)
+                {
+                    Announce(CANT_AFFORD);
+                    continue;
+                }
+
+                m_bot->ModifyMoney(-int32(cost));
+                // learn explicitly or cast explicitly
+                if (trainer_spell->IsCastable())
+                    m_bot->CastSpell(m_bot, trainer_spell->spell, true);
+                else
+                    m_bot->learnSpell(spellId, false);
+                ++totalSpellLearnt;
+                totalCost += cost;
+                const SpellEntry *const pSpellInfo = sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+
+                if (visuals)
+                {
+                    visuals = false;
+                    WorldPacket data(SMSG_PLAY_SPELL_VISUAL, 12);           // visual effect on trainer
+                    data << uint64(fromPlayer.GetSelection());
+                    data << uint32(0xB3);                                   // index from SpellVisualKit.dbc
+                    m_master->GetSession()->SendPacket(&data);
+
+                    data.Initialize(SMSG_PLAY_SPELL_IMPACT, 12);            // visual effect on player
+                    data << m_bot->GetGUID();
+                    data << uint32(0x016A);                                 // index from SpellVisualKit.dbc
+                    m_master->GetSession()->SendPacket(&data);
+                }
+
+                WorldPacket data(SMSG_TRAINER_BUY_SUCCEEDED, 12);
+                data << uint64(fromPlayer.GetSelection());
+                data << uint32(spellId);                                // should be same as in packet from client
+                m_master->GetSession()->SendPacket(&data);
+
+                MakeSpellLink(pSpellInfo, msg);
+                msg << " ";
+                msg << Cash(cost) << "\n";
+            }
+            ReloadAI();
+            msg << "Total of " << totalSpellLearnt << " spell";
+            if (totalSpellLearnt != 1) msg << "s";
+            msg << " learnt, ";
+            msg << Cash(totalCost) << " spent.";
+        }
+        // Handle: List class or profession skills, spells & abilities for selected trainer
+        else
+        {
+            msg << "The spells I can learn and their cost:\r";
+
+            for (TrainerSpellMap::const_iterator itr =  cSpells->spellList.begin(); itr !=  cSpells->spellList.end(); ++itr)
+            {
+                TrainerSpell const* tSpell = &itr->second;
+
+                if (!tSpell)
+                    break;
+
+                uint32 reqLevel = 0;
+                if (!tSpell->learnedSpell[0] && !m_bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+                    continue;
+
+                if (sSpellMgr->GetSpellInfo(tSpell->learnedSpell[0])->IsPrimaryProfession() && m_bot->HasSpell(tSpell->learnedSpell[0]))
+                    continue;
+
+                reqLevel = tSpell->reqLevel ? tSpell->reqLevel : std::max(reqLevel, tSpell->reqLevel);
+
+                TrainerSpellState state =  m_bot->GetTrainerSpellState(tSpell);
+                if (state != TRAINER_SPELL_GREEN)
+                    continue;
+
+                uint32 spellId = tSpell->spell;
+                const SpellEntry *const pSpellInfo =  sSpellStore.LookupEntry(spellId);
+                if (!pSpellInfo)
+                    continue;
+                uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+                totalCost += cost;
+                MakeSpellLink(pSpellInfo, msg);
+                msg << " ";
+                msg << Cash(cost) << "\n";
+            }
+            int32 moneyDiff = m_bot->GetMoney() - totalCost;
+            if (moneyDiff >= 0)
+            {
+                // calculate how much money bot has
+                msg << " ";
+                msg << Cash(moneyDiff) << " left.";
+            }
+            else
+            {
+                Announce(CANT_AFFORD);
+                moneyDiff *= -1;
+                msg << "I need ";
+                msg << Cash(moneyDiff) << " more to learn all the spells!";
+            }
+        }
+    }
+    // Handle: Unlearning selected primary profession skill(s) and all associated spells, skill unlearn [HLINK][HLINK].. ([HLINK] from skill)
+    else if (ExtractCommand("unlearn", text))
+    {
+        m_spellsToLearn.clear();
+        extractSpellIdList(text, m_spellsToLearn);
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            if (sSpellMgr->GetSpellInfo(*it)->IsPrimaryProfession())
+            {
+                SpellLearnSkillNode const* spellLearnSkill = sSpellMgr->GetSpellLearnSkill(*it);
+
+                uint32 prev_spell = sSpellMgr->GetPrevSpellInChain(*it);
+                if (!prev_spell)                                    // first rank, remove skill
+                    GetPlayer()->SetSkill(spellLearnSkill->skill, GetPlayer()->GetSkillStep(spellLearnSkill->skill), 0, 0);
+                else
+                {
+                    // search prev. skill setting by spell ranks chain
+                    SpellLearnSkillNode const* prevSkill = sSpellMgr->GetSpellLearnSkill(prev_spell);
+                    while (!prevSkill && prev_spell)
+                    {
+                        prev_spell = sSpellMgr->GetPrevSpellInChain(prev_spell);
+                        prevSkill = sSpellMgr->GetSpellLearnSkill(sSpellMgr->GetFirstSpellInChain(prev_spell));
+                    }
+                    if (!prevSkill)                                 // not found prev skill setting, remove skill
+                        GetPlayer()->SetSkill(spellLearnSkill->skill, GetPlayer()->GetSkillStep(spellLearnSkill->skill), 0, 0);
+                }
+            }
+        }
+    }
+    // Handle: Lists bot(s) primary profession skills & weapon skills.
+    else
+    {
+        m_spellsToLearn.clear();
+        m_bot->skill(m_spellsToLearn);
+        msg << "My Primary Professions: ";
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            if (IsPrimaryProfessionSkill(*it))
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!skillLine)
+                        continue;
+
+                    // has skill
+                    if (skillLine->skillId == *it && skillLine->learnOnGetSkill == 0)
+                    {
+                        SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                        if (!spellInfo)
+                            continue;
+
+                        if (m_bot->GetSkillValue(*it) <= rank[sSpellMgr->GetSpellRank(skillLine->spellId)] && m_bot->HasSpell(skillLine->spellId))
+                        {
+                            // sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: HandleCommand - skill (%u)(%u)(%u):",skillLine->spellId, rank[sSpellMgr->GetSpellRank(skillLine->spellId)], m_bot->GetSkillValue(*it));
+                            MakeSpellLink(spellInfo, msg);
+                            break;
+                        }
+                    }
+                }
+        }
+
+        msg << "\nMy Weapon skills: ";
+        for (std::list<uint32>::iterator it = m_spellsToLearn.begin(); it != m_spellsToLearn.end(); ++it)
+        {
+            SkillLineEntry const *SkillLine = sSkillLineStore.LookupEntry(*it);
+            // has weapon skill
+            if (SkillLine->categoryId == SKILL_CATEGORY_WEAPON)
+                for (uint32 j = 0; j < sSkillLineAbilityStore.GetNumRows(); ++j)
+                {
+                    SkillLineAbilityEntry const *skillLine = sSkillLineAbilityStore.LookupEntry(j);
+                    if (!skillLine)
+                        continue;
+
+                    SpellEntry const* spellInfo = sSpellStore.LookupEntry(skillLine->spellId);
+                    if (!spellInfo)
+                        continue;
+
+                    if (skillLine->skillId == *it && spellInfo->Effect[0] == SPELL_EFFECT_WEAPON)
+                        MakeWeaponSkillLink(spellInfo, msg, *it);
+                }
+        }
+    }
+    SendWhisper(msg.str(), fromPlayer);
+    m_spellsToLearn.clear();
+    m_bot->GetPlayerbotAI()->GetClassAI();
+}
+
+void PlayerbotAI::_HandleCommandStats(std::string &text, Player &fromPlayer)
+{
+    if (text != "")
+    {
+        SendWhisper("'stats' does not have subcommands", fromPlayer);
+        return;
+    }
+
+    std::ostringstream out;
+
+    uint32 totalused = 0;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+                totalfree =  totalfree + pBag->GetFreeSlots();
+        }
+
+    }
+
+    // estimate how much item damage the bot has
+    out << "|cffffffff[|h|cff00ffff" << m_bot->GetName() << "|h|cffffffff] has |cff00ff00";
+    out << totalfree << " |h|cffffffff bag slots,|h" << " |cff00ff00";
+    out << Cash(EstRepairAll());
+
+    // calculate how much money bot has
+    uint32 copper = m_bot->GetMoney();
+    out << "|h|cffffffff item damage & has " << "|r|cff00ff00";
+    out << Cash(copper);
+    ChatHandler ch(&fromPlayer);
+    ch.SendSysMessage(out.str().c_str());
+}
+
+void PlayerbotAI::_HandleCommandGM(std::string &text, Player &fromPlayer)
+{
+    // Check should happen OUTSIDE this function, but this is account security we're talking about, so let's be doubly sure
+    if (fromPlayer.GetSession()->GetSecurity() <= SEC_PLAYER)
+        return;  // no excuses, no warning
+
+    if (text == "")
+    {
+        SendWhisper("gm must have a subcommand.", fromPlayer);
+        return;
+    }
+    else if (ExtractCommand("check", text))
+    {
+        if (ExtractCommand("talent", text))
+        {
+            if (ExtractCommand("spec", text))
+            {
+                uint32 tsDBError = TalentSpecDBContainsError();
+                if (0 != tsDBError)
+                {
+                    std::ostringstream oss;
+                    oss << "Error found in TalentSpec: " << tsDBError;
+                    SendWhisper(oss.str(), fromPlayer);
+                }
+                else
+                    SendWhisper("No errors found. High five!", fromPlayer);
+            }
+        }
+        else
+            SendWhisper("'gm check' does not have that subcommand.", fromPlayer);
+    }
+    else
+        SendWhisper("'gm' does not have that subcommand.", fromPlayer);
+}
+
+void PlayerbotAI::_HandleCommandHelp(std::string &text, Player &fromPlayer)
+{
+    ChatHandler ch(&fromPlayer);
+
+    // "help help"? Seriously?
+    if (ExtractCommand("help", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("help", "Lists all the things you can order me to do... But it's up to me whether to follow your orders... Or not.").c_str());
+        return;
+    }
+
+    bool bMainHelp = (text == "") ? true : false;
+    const std::string sInvalidSubcommand = "That's not a valid subcommand.";
+    std::string msg = "";
+    // All of these must containt the 'bMainHelp' clause -> help lists all major commands
+    // Further indented 'ExtractCommand("subcommand")' conditionals make sure these aren't printed for basic "help"
+    if (bMainHelp || ExtractCommand("attack", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("attack", "Attack the selected target. Which would, of course, require a valid target.", HL_TARGET).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("follow", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow", "I will follow you - this also revives me if dead and teleports me if I'm far away.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow far", "I will follow at a father distance away from you.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow near", "I will follow at a closer distance to you.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("follow reset", "I will reset my follow distance to its original state.").c_str());
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("stay", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("stay", "I will stay put until told otherwise.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("autoequip", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("autoequip", "Used with no parameter: Toggles Auto Equipping for one or all bots to ON or OFF depending on their current setting.").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("autoequip < on >", "Turns Auto equipping ON for one, or all bots in group").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("autoequip < off >", "Turns Auto equipping OFF for one, or all bots in group").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("autoequip < now >", "Ignores current autoequip setting, Runs the auto equip cycle ONCE for one or all bots (/t or /p)").c_str());
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("assist", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("assist", "I will assist the character listed, attacking as they attack.", HL_NAME).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("spells", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("spells", "I will list all the spells I know.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("craft", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("craft", "I will create a single specified recipe", HL_RECIPE).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("craft [RECIPE] all", "I will create all specified recipes").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < alchemy | a >", "List all learnt alchemy recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < blacksmithing | b >", "List all learnt blacksmith recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < cooking | c >", "List all learnt cooking recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < engineering | e >", "List all learnt engineering recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < firstaid | f >", "List all learnt firstaid recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < inscription | i >", "List all learnt inscription recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < jewelcrafting | j >", "List all learnt jewelcrafting recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < leatherworking | l >", "List all learnt leatherworking recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < magic | m >", "List all learnt enchanting recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < smelting | s >", "List all learnt mining recipes").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("craft < tailoring | t >", "List all learnt tailoring recipes").c_str());
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("process", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("process < disenchant | d >", "Disenchants a green coloured [ITEM] or better", HL_ITEM).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("process < mill | m >", "Grinds 5 herbs [ITEM] to produce pigments", HL_ITEM).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("process < prospect | p >", "Searches 5 metal ore [ITEM] for precious gems", HL_ITEM).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("enchant", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("enchant", "Lists all enchantments [SPELL] learnt by the bot").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("enchant [SPELL]", "Enchants selected tradable [ITEM] either equipped or in bag", HL_ITEM).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("cast", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("cast", "I will cast the spell or ability listed.", HL_SPELL).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("use", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("use", "I will use the linked item.", HL_ITEM).c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on a selected TARGET.", HL_TARGET).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on an equipped linked item.", HL_ITEM).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("use [ITEM]", "I will use the first linked item on a linked gameobject.", HL_GAMEOBJECT).c_str());
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("equip", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("equip", "I will equip the linked item(s).", HL_ITEM, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("reset", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("reset", "I will reset all my states, orders, loot list, talent spec, ... Hey, that's kind of like memory loss.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("stats", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("stats", "This will inform you of my wealth, free bag slots and estimated equipment repair costs.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("survey", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("survey", "Lists all available game objects near me.").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("find", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("find", "I will find said game object, walk right up to it, and wait.", HL_GAMEOBJECT).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("get", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("get", "I will get said game object and return to your side.", HL_GAMEOBJECT).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("quest", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("quest", "Lists my current quests.").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest add", "Adds this quest to my quest log.", HL_QUEST).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest drop", "Removes this quest from my quest log.", HL_QUEST).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest end", "Turns in my completed quests.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest list", "Lists the quests offered to me by this target.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("quest report", "This will give you a full report of all the items, creatures or gameobjects I still need to finish my quests.", HL_QUEST).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("add", text, true)) {}
+            else if (ExtractCommand("drop", text, true)) {}
+            else if (ExtractCommand("end", text, true)) {}
+            else if (ExtractCommand("list", text, true)) {}
+            else if (ExtractCommand("report", text, true)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("orders", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("orders", "Shows you my orders. Free will is overrated, right?").c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("pet", text))
+    {
+        if (bMainHelp)
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet", "Helps command my pet. Must always be used with a subcommand.").c_str());
+        else if (text == "") // not "help" AND "help pet"
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as...").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet abandon", "Abandons active hunter pet.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet cast", "Has my pet cast this spell. May require a treat. Or at least ask nicely.", HL_SPELL).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet react", "Sets my pet's aggro mode.", HL_PETAGGRO).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet spells", "Shows you the spells my pet knows.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet state", "Shows my pet's aggro mode.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet tame", "Allows a hunter to acquire a pet.", HL_TARGET).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("pet toggle", "Toggles autocast for this spell.", HL_SPELL).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("spells", text)) {}
+            else if (ExtractCommand("tame", text)) {}
+            else if (ExtractCommand("abandon", text)) {}
+            else if (ExtractCommand("cast", text)) {}
+            else if (ExtractCommand("toggle", text)) {}
+            else if (ExtractCommand("state", text)) {}
+            else if (ExtractCommand("react", text))
+            {
+                ch.SendSysMessage(_HandleCommandHelpHelper("pet react", "has three modes.").c_str());
+                ch.SendSysMessage(_HandleCommandHelpHelper("aggressive", "sets it so my precious attacks everything in sight.", HL_NONE, false, true).c_str());
+                ch.SendSysMessage(_HandleCommandHelpHelper("defensive", "sets it so it automatically attacks anything that attacks me, or anything I attack.", HL_NONE, false, true).c_str());
+                ch.SendSysMessage(_HandleCommandHelpHelper("passive", "makes it so my pet won't attack anything unless directly told to.", HL_NONE, false, true).c_str());
+
+                // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+                if (ExtractCommand("aggressive", text, true)) {}
+                else if (ExtractCommand("defensive", text, true)) {}
+                else if (ExtractCommand("passive", text, true)) {}
+                if (text != "")
+                    ch.SendSysMessage(sInvalidSubcommand.c_str());
+            }
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("collect", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("collect", "Tells you what my current collect status is. Also lists possible options.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("collect", "Sets what I collect. Obviously the 'none' option should be used alone, but all the others can be mixed.", HL_OPTION, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("sell", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("sell", "Adds this to my 'for sale' list.", HL_ITEM, true).c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("sell all", "The next time you sell, I'll sell all my low level white items.").c_str());
+        ch.SendSysMessage(_HandleCommandHelpHelper("sell all", "This command must be called each time before you sell, OR I won't auto sell white items.").c_str());
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("buy", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("buy", "Adds this to my 'purchase' list.", HL_ITEM, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("drop", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("drop", "Drops the linked item(s). Permanently.", HL_ITEM, true).c_str());
+
+        if (!bMainHelp)
+        {
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("auction", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("auction", "Lists all my active auctions. With pretty little links and such. Hi hi hi... I'm gonna be sooo rich!").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("auction add", "Adds the item to my 'auction off later' list. I have a lot of lists, you see...", HL_ITEM).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("auction remove", "Adds the item to my 'Don't auction after all' list. Hope it hasn't sold by then!", HL_AUCTION).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("add", text, true)) {}
+            else if (ExtractCommand("remove", text, true)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("repair", text))
+    {
+        if (!bMainHelp && text == "")
+            ch.SendSysMessage(_HandleCommandHelpHelper("repair", "This by itself is not a valid command. Just so you know. To be used with a subcommand, such as...").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("repair", "Has me find an armorer and repair the items you listed.", HL_ITEM).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("repair all", "Has me find an armorer and repair all my items, be they equipped or just taking up bagspace.").c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("all", text)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("talent", text))
+    {
+        msg = _HandleCommandHelpHelper("talent", "Lists my talents, glyphs, unspent talent points and the cost to reset all talents.");
+        ch.SendSysMessage(msg.c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent learn", "Has me learn the linked talent.", HL_TALENT).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent reset", "Resets my talents. Assuming I have the appropriate amount of sparkly gold, shiny silver, and... unrusted copper.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent spec", "Lists all talent specs I can use.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("talent spec #", "I will follow this talent spec. Well, I will if you picked a talent spec that exists.").c_str());
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+        if (!bMainHelp) return;
+    }
+    if (bMainHelp || ExtractCommand("bank", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("bank", "Gives you my bank balance. I thought that was private.").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("bank deposit", "Deposits the listed items in my bank.", HL_ITEM, true).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("bank withdraw", "Withdraw the listed items from my bank.", HL_ITEM, true).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("deposit", text)) {}
+            else if (ExtractCommand("withdraw", text)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("skill", text))
+    {
+        msg = _HandleCommandHelpHelper("skill", "Lists my primary professions & weapon skills.");
+        ch.SendSysMessage(msg.c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("skill learn", "Lists the things this trainer can teach me. If you've targeted a trainer, that is.").c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("skill learn", "Have me learn this skill from the selected trainer.", HL_SKILL).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("skill unlearn", "Unlearn the linked (primary) profession and everything that goes with it.", HL_PROFESSION).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("learn", text)) {}
+            else if (ExtractCommand("unlearn", text)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (fromPlayer.GetSession()->GetSecurity() > SEC_PLAYER && (bMainHelp || ExtractCommand("gm", text)))
+    {
+        msg = _HandleCommandHelpHelper("gm", "Lists actions available to GM account level and up.");
+        ch.SendSysMessage(msg.c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("gm check", "Lists the things you can run a check on.").c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("check", text))
+            {
+                ch.SendSysMessage(_HandleCommandHelpHelper("gm check talent", "Lists talent mechanics you can run a check on.").c_str());
+
+                if (ExtractCommand("talent", text))
+                {
+                    ch.SendSysMessage(_HandleCommandHelpHelper("gm check talent spec", "Checks the talent spec database for various errors. Only the first error (if any) is returned.").c_str());
+
+                    if (ExtractCommand("spec", text)) {}
+
+                    if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+                    return;
+                }
+
+                if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+                return;
+            }
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+    if (bMainHelp || ExtractCommand("mail", text))
+    {
+        ch.SendSysMessage(_HandleCommandHelpHelper("mail inbox |cFFFFFF00|h[Mailbox]|h|r", "Lists all bot mail from selected [Mailbox]").c_str());
+
+        if (!bMainHelp)
+        {
+            ch.SendSysMessage(_HandleCommandHelpHelper("mail getcash", "Gets money from all selected [Mailid]..", HL_MAIL, true).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("mail getitem", "Gets items from all selected [Mailid]..", HL_MAIL, true).c_str());
+            ch.SendSysMessage(_HandleCommandHelpHelper("mail delete", "Delete all selected [Mailid]..", HL_MAIL, true).c_str());
+
+            // Catches all valid subcommands, also placeholders for potential future sub-subcommands
+            if (ExtractCommand("inbox", text, true)) {}
+            else if (ExtractCommand("getcash", text, true)) {}
+            else if (ExtractCommand("getitem", text, true)) {}
+            else if (ExtractCommand("delete", text, true)) {}
+
+            if (text != "") ch.SendSysMessage(sInvalidSubcommand.c_str());
+            return;
+        }
+    }
+
+    if (bMainHelp)
+        ch.SendSysMessage(_HandleCommandHelpHelper("help", "Gives you this listing of main commands... But then, you know that already don't you.").c_str());
+
+    if (text != "")
+        ch.SendSysMessage("Either that is not a valid command, or someone forgot to add it to my help journal. I mean seriously, they can't expect me to remember *all* this stuff, can they?");
+}
+
+std::string PlayerbotAI::_HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink, bool bReqLinkMultiples, bool bCommandShort)
+{
+    if (sCommand == "")
+    {
+        //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI] _HandleCommandHelpHelper called with an empty sCommand. Ignoring call.");
+        return "";
+    }
+
+    std::ostringstream oss;
+    oss << "'|cffffffff";
+    if (bCommandShort)
+        oss << "(" << sCommand.at(0) << ")" << sCommand.substr(1);
+    else
+        oss << sCommand;
+
+    if (reqLink != HL_NONE)
+    {
+        if (reqLink == HL_PROFESSION)
+        {
+            oss << " [PROFESSION]";
+            if (bReqLinkMultiples)
+                oss << " [PROFESSION] ..";
+        }
+        else if (reqLink == HL_ITEM)
+        {
+            oss << " [ITEM]";
+            if (bReqLinkMultiples)
+                oss << " [ITEM] ..";
+        }
+        else if (reqLink == HL_TALENT)
+        {
+            oss << " [TALENT]";
+            if (bReqLinkMultiples)
+                oss << " [TALENT] ..";
+        }
+        else if (reqLink == HL_SKILL)
+        {
+            oss << " [SKILL]";
+            if (bReqLinkMultiples)
+                oss << " [SKILL] ..";
+        }
+        else if (reqLink == HL_OPTION)
+        {
+            oss << " <OPTION>";
+            if (bReqLinkMultiples)
+                oss << " <OPTION> ..";
+        }
+        else if (reqLink == HL_PETAGGRO)
+        {
+            oss << " <(a)ggressive | (d)efensive | (p)assive>";
+            //if (bReqLinkMultiples)
+                //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI] _HandleCommandHelpHelper: sCommand \"pet\" with bReqLinkMultiples \"true\". ... Why? Bug, surely.");
+        }
+        else if (reqLink == HL_QUEST)
+        {
+            oss << " [QUEST]";
+            if (bReqLinkMultiples)
+                oss << " [QUEST] ..";
+        }
+        else if (reqLink == HL_GAMEOBJECT)
+        {
+            oss << " [GAMEOBJECT]";
+            if (bReqLinkMultiples)
+                oss << " [GAMEOBJECT] ..";
+        }
+        else if (reqLink == HL_SPELL)
+        {
+            oss << " <Id# | (part of) name | [SPELL]>";
+            if (bReqLinkMultiples)
+                oss << " <Id# | (part of) name | [SPELL]> ..";
+        }
+        else if (reqLink == HL_TARGET)
+        {
+            oss << " (TARGET)";
+            if (bReqLinkMultiples)
+                oss << " (TARGET) ..";
+        }
+        else if (reqLink == HL_NAME)
+        {
+            oss << " <NAME>";
+            if (bReqLinkMultiples)
+                oss << " <NAME> ..";
+        }
+        else if (reqLink == HL_AUCTION)
+        {
+            oss << " [AUCTION]";
+            if (bReqLinkMultiples)
+                oss << " [AUCTION] ..";
+        }
+        else if (reqLink == HL_RECIPE)
+        {
+            oss << " [RECIPE]";
+            if (bReqLinkMultiples)
+                oss << " [RECIPE] ..";
+        }
+        else if (reqLink == HL_MAIL)
+        {
+            oss << " [MAILID]";
+            if (bReqLinkMultiples)
+                oss << " [MAILID] ..";
+        }
+        else
+        {
+            oss << " {unknown}";
+            if (bReqLinkMultiples)
+                oss << " {unknown} ..";
+            //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: _HandleCommandHelpHelper - Uncaught case");
+        }
+    }
+
+    oss << "|r': " << sExplain;
+
+    return oss.str();
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet, WorldSession& session)
+{
+    //WorldSession *session = m_master->GetSession();
+    switch (packet.GetOpcode())
+    {
+        case CMSG_ACTIVATETAXI:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            uint64 guid;
+            std::vector<uint32> nodes;
+            nodes.resize(2);
+            uint8 delay = 9;
+
+            p >> guid >> nodes[0] >> nodes[1];
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXI from %d to %d", nodes[0], nodes[1]);
+
+            //WorldSession *session = m_master->GetSession();
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+
+                delay = delay + 3;
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    continue;
+
+                Unit *target = sObjectAccessor->GetUnit(*bot, guid);
+
+                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
+
+                bot->GetMotionMaster()->Clear(true);
+                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
+                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
+            }
+            return;
+        }
+
+        case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+
+            uint64 guid;
+            uint32 node_count;
+            uint8 delay = 9;
+
+            p >> guid >> node_count;
+
+            std::vector<uint32> nodes;
+
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                nodes.push_back(node);
+            }
+
+            if (nodes.empty())
+                return;
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_ACTIVATETAXIEXPRESS from %d to %d", nodes.front(), nodes.back());
+
+            //WorldSession *session = m_master->GetSession();
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+
+                delay = delay + 3;
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    continue;
+
+                Unit *target = sObjectAccessor->GetUnit(*bot, guid);
+
+                bot->GetPlayerbotAI()->SetIgnoreUpdateTime(delay);
+
+                bot->GetMotionMaster()->Clear(true);
+                bot->GetMotionMaster()->MoveFollow(target, INTERACTION_DISTANCE, bot->GetOrientation());
+                bot->GetPlayerbotAI()->GetTaxi(guid, nodes);
+            }
+            return;
+        }
+
+        //case CMSG_MOVE_SPLINE_DONE:
+        //{
+            //// DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE");
+
+            //WorldPacket p(packet);
+            //p.rpos(0); // reset reader
+
+            //uint64 guid = extractGuid(p);                           // used only for proper packet read
+            //MovementInfo movementInfo;                              // used only for proper packet read
+
+            //p >> guid;
+            //p >> movementInfo;
+            //p >> Unused<uint32>();                          // unk
+
+            //for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+            //{
+
+            //    Player* const bot = it->second;
+            //    if (!bot)
+            //        return;
+
+            //    // in taxi flight packet received in 2 case:
+            //    // 1) end taxi path in far (multi-node) flight
+            //    // 2) switch from one map to other in case multi-map taxi path
+            //    // we need process only (1)
+            //    uint32 curDest = bot->m_taxi.GetTaxiDestination();
+            //    if (!curDest)
+            //        return;
+
+            //    TaxiNodesEntry const* curDestNode = sTaxiNodesStore.LookupEntry(curDest);
+
+            //    // far teleport case
+            //    if (curDestNode && curDestNode->map_id != bot->GetMapId())
+            //    {
+            //        if (bot->GetMotionMaster()->GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE)
+            //        {
+            //            // short preparations to continue flight
+            //            FlightPathMovementGenerator* flight = (FlightPathMovementGenerator *) (bot->GetMotionMaster()->top());
+
+            //            flight->Interrupt(*bot);                // will reset at map landing
+
+            //            flight->SetCurrentNodeAfterTeleport();
+            //            TaxiPathNodeEntry const& node = flight->GetPath()[flight->GetCurrentNode()];
+            //            flight->SkipCurrentNode();
+
+            //            bot->TeleportTo(curDestNode->map_id, node.x, node.y, node.z, bot->GetOrientation());
+            //        }
+            //        return;
+            //    }
+
+            //    uint32 destinationnode = bot->m_taxi.NextTaxiDestination();
+            //    if (destinationnode > 0)                                // if more destinations to go
+            //    {
+            //        // current source node for next destination
+            //        uint32 sourcenode = bot->m_taxi.GetTaxiSource();
+
+            //        // Add to taximask middle hubs in taxicheat mode (to prevent having player with disabled taxicheat and not having back flight path)
+            //        if (bot->isTaxiCheater())
+            //            if (bot->m_taxi.SetTaximaskNode(sourcenode))
+            //            {
+            //                WorldPacket data(SMSG_NEW_TAXI_PATH, 0);
+            //                bot->GetSession()->SendPacket(&data);
+            //            }
+
+            //        // DEBUG_LOG ("[PlayerbotMgr]: HandleMasterIncomingPacket - Received CMSG_MOVE_SPLINE_DONE Taxi has to go from %u to %u", sourcenode, destinationnode);
+
+            //        uint32 mountDisplayId = sObjectMgr.GetTaxiMountDisplayId(sourcenode, bot->GetTeam());
+
+            //        uint32 path, cost;
+            //        sObjectMgr.GetTaxiPath(sourcenode, destinationnode, path, cost);
+
+            //        if (path && mountDisplayId)
+            //            bot->GetSession()->SendDoFlight(mountDisplayId, path, 1);          // skip start fly node
+            //        else
+            //            bot->m_taxi.ClearTaxiDestinations();    // clear problematic path and next
+            //    }
+            //    else
+            //        /* std::ostringstream out;
+            //           out << "Destination reached" << bot->GetName();
+            //           ChatHandler ch(m_master);
+            //           ch.SendSysMessage(out.str().c_str()); */
+            //        bot->m_taxi.ClearTaxiDestinations();        // Destination, clear source node
+            //}
+            //return;
+        //}
+
+        // if master is logging out, log out all bots
+        //case CMSG_LOGOUT_REQUEST:
+        //{
+        //    LogoutAllBots();
+        //    return;
+        //}
+
+        // If master inspects one of his bots, give the master useful info in chat window
+        // such as inventory that can be equipped
+        //case CMSG_INSPECT:
+        //{
+        //    WorldPacket p(packet);
+        //    p.rpos(0); // reset reader
+        //    uint64 guid;
+        //    p >> guid;
+        //    Player* const bot = GetPlayerBot(guid);
+        //    if (bot) bot->GetPlayerbotAI()->SendNotEquipList(*bot);
+        //    return;
+        //}
+
+        case CMSG_REPAIR_ITEM:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); //reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            WorldObject *const pNpc = (WorldObject*)sObjectAccessor->GetObjectByTypeMask(*session.GetPlayer(), npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            //for all master's bots
+            for(PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player *const bot = it->second;
+                if (m_bot->GetDistance(pNpc) > 20.0f)
+                {
+                    TellMaster("I'm too far away to repair items!");
+                    continue;
+                }
+                else
+                {
+                    TellMaster("Repairing my items.");
+                    m_bot->DurabilityRepairAll(false, 0.0f, false);
+                }
+            }
+            return;
+        }
+
+        // handle emotes from the master
+        //case CMSG_EMOTE:
+        case CMSG_TEXT_EMOTE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0); // reset reader
+            uint32 emoteNum;
+            p >> emoteNum;
+
+            /* std::ostringstream out;
+               out << "emote is: " << emoteNum;
+               ChatHandler ch(m_master);
+               ch.SendSysMessage(out.str().c_str()); */
+
+            switch (emoteNum)
+            {
+                case TEXT_EMOTE_BOW:
+                {
+                    // Buff anyone who bows before me. Useful for players not in bot's group
+                    // How do I get correct target???
+                    //Player* const pPlayer = GetPlayerBot(m_master->GetSelection());
+                    //if (pPlayer->GetPlayerbotAI()->GetClassAI())
+                    //    pPlayer->GetPlayerbotAI()->GetClassAI()->BuffPlayer(pPlayer);
+                    return;
+                }
+                /*case TEXT_EMOTE_SALUTE:
+                {
+                    if (Player* const bot = session.GetPlayerBot(m_master->GetSelection()))
+                        if (PlayerbotAI *ai = bot->GetPlayerbotAI())
+                            ai->SendNotEquipList(*m_master);
+                    return;
+                }*/
+                
+                   case TEXT_EMOTE_BONK:
+                   {
+                    Player* const pPlayer = m_master->GetSession()->GetPlayerBot(m_master->GetSelection());
+                    if (!pPlayer || !pPlayer->GetPlayerbotAI())
+                        return;
+                    PlayerbotAI* const pBot = pPlayer->GetPlayerbotAI();
+
+                    ChatHandler ch(m_master);
+                    {
+                        std::ostringstream out;
+                        out << "time(0): " << time(0)
+                            << " m_ignoreAIUpdatesUntilTime: " << pBot->m_ignoreAIUpdatesUntilTime;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_TimeDoneEating: " << pBot->m_TimeDoneEating
+                            << " m_TimeDoneDrinking: " << pBot->m_TimeDoneDrinking;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "m_CurrentlyCastingSpellId: " << pBot->m_CurrentlyCastingSpellId;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsBeingTeleported() " << pBot->GetPlayer()->IsBeingTeleported();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        bool tradeActive = (pBot->GetPlayer()->GetTrader()) ? true : false;
+                        out << "tradeActive: " << tradeActive;
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    {
+                        std::ostringstream out;
+                        out << "IsCharmed() " << pBot->GetPlayer()->isCharmed();
+                        ch.SendSysMessage(out.str().c_str());
+                    }
+                    return;
+                   }
+                 
+
+                case TEXT_EMOTE_EAT:
+                case TEXT_EMOTE_DRINK:
+                {
+                    for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        bot->GetPlayerbotAI()->Feast();
+                    }
+                    return;
+                }
+
+                // emote to attack selected target
+                case TEXT_EMOTE_POINT:
+                {
+                    uint64 attackOnGuid = m_master->GetSelection();
+                    if (!attackOnGuid)
+                        return;
+
+                    Unit* thingToAttack = sObjectAccessor->GetUnit(*m_master, attackOnGuid);
+                    if (!thingToAttack) return;
+
+                    Player *bot = 0;
+                    for (PlayerBotMap::const_iterator itr = session.GetPlayerBotsBegin(); itr != session.GetPlayerBotsEnd(); ++itr)
+                    {
+                        bot = itr->second;
+                        if (!bot->IsFriendlyTo(thingToAttack) && bot->IsWithinLOSInMap(thingToAttack))
+                            bot->GetPlayerbotAI()->GetCombatTarget(thingToAttack);
+                    }
+                    return;
+                }
+
+                // emote to stay
+                case TEXT_EMOTE_STAND:
+                {
+                    Player* const bot = session.GetPlayerBot(m_master->GetSelection());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder(MOVEMENT_STAY);
+                    else
+                        for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder(MOVEMENT_STAY);
+                        }
+                    return;
+                }
+
+                // 324 is the followme emote (not defined in enum)
+                // if master has bot selected then only bot follows, else all bots follow
+                case 324:
+                case TEXT_EMOTE_WAVE:
+                {
+                    Player* const bot = session.GetPlayerBot(m_master->GetSelection());
+                    if (bot)
+                        bot->GetPlayerbotAI()->SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+                    else
+                        for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+                        {
+                            Player* const bot = it->second;
+                            bot->GetPlayerbotAI()->SetMovementOrder(MOVEMENT_FOLLOW, m_master);
+                        }
+                    return;
+                }
+            }
+            return;
+        } /* EMOTE ends here */
+
+        case CMSG_GAMEOBJ_USE: // not sure if we still need this one
+        case CMSG_GAMEOBJ_REPORT_USE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);     // reset reader
+            uint64 objGUID;
+            p >> objGUID;
+
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+
+                GameObject *obj = m_master->GetMap()->GetGameObject(objGUID);
+                if (!obj)
+                    return;
+
+                // add other go types here, i.e.:
+                // GAMEOBJECT_TYPE_CHEST - loot quest items of chest
+                if (obj->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+                {
+                    bot->GetPlayerbotAI()->TurnInQuests(obj);
+
+                    // auto accept every available quest this NPC has
+                    bot->PrepareQuestMenu(objGUID);
+                    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+                    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+                    {
+                        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+                        uint32 questID = qItem.QuestId;
+                        if (!bot->GetPlayerbotAI()->AddQuest(questID, obj))
+                            bot->Whisper("Couldn't take quest", LANG_UNIVERSAL, m_master->GetGUID());
+                    }
+                }
+            }
+        }
+        //break;
+        return;
+
+        case CMSG_QUESTGIVER_HELLO:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            WorldObject* pNpc = (WorldObject*)sObjectAccessor->GetObjectByTypeMask(*m_bot, npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+            }
+
+            return;
+        }
+
+        // if master accepts a quest, bots should also try to accept quest
+        case CMSG_QUESTGIVER_ACCEPT_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint64 guid;
+            uint32 quest;
+            uint32 unk1;
+            p >> guid >> quest >> unk1;
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_ACCEPT_QUEST npc = %s, quest = %u, unk1 = %u", guid.GetString().c_str(), quest, unk1);
+
+            Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+            if (qInfo)
+                for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+                {
+                    Player* const bot = it->second;
+
+                    if (bot->GetQuestStatus(quest) == QUEST_STATUS_COMPLETE)
+                        bot->GetPlayerbotAI()->TellMaster("I already completed that quest.");
+                    else if (!bot->CanTakeQuest(qInfo, false))
+                    {
+                        if (!bot->SatisfyQuestStatus(qInfo, false))
+                            bot->GetPlayerbotAI()->TellMaster("I already have that quest.");
+                        else
+                            bot->GetPlayerbotAI()->TellMaster("I can't take that quest.");
+                    }
+                    else if (!bot->SatisfyQuestLog(false))
+                        bot->GetPlayerbotAI()->TellMaster("My quest log is full.");
+                    else if (!bot->CanAddQuest(qInfo, false))
+                        bot->GetPlayerbotAI()->TellMaster("I can't take that quest because it requires that I take items, but my bags are full!");
+
+                    else
+                    {
+                        p.rpos(0);         // reset reader
+                        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+                        bot->GetPlayerbotAI()->TellMaster("Got the quest.");
+
+                        // build needed items if quest contains any
+                        for (int i = 0; i < QUEST_ITEM_OBJECTIVES_COUNT; i++)
+                            if (qInfo->RequiredItemCount[i] > 0)
+                            {
+                                bot->GetPlayerbotAI()->SetQuestNeedItems();
+                                break;
+                            }
+
+                        // build needed creatures if quest contains any
+                        for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+                            if (qInfo->RequiredNpcOrGoCount[i] > 0)
+                            {
+                                bot->GetPlayerbotAI()->SetQuestNeedCreatures();
+                                break;
+                            }
+                    }
+                }
+            return;
+        }
+
+        case CMSG_AREATRIGGER:
+        {
+            WorldPacket p(packet);
+
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot)
+                    continue;
+
+                if (bot->IsWithinDistInMap(m_master, 50))
+                {
+                    p.rpos(0);         // reset reader
+                    bot->GetSession()->HandleAreaTriggerOpcode(p);
+                }
+            }
+            return;
+        }
+
+        case CMSG_QUESTGIVER_COMPLETE_QUEST:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);    // reset reader
+            uint32 quest;
+            uint64 npcGUID;
+            p >> npcGUID >> quest;
+
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_QUESTGIVER_COMPLETE_QUEST npc = %s, quest = %u", npcGUID.GetString().c_str(), quest);
+
+            Creature* pNpc = sObjectAccessor->GetCreature(*m_master, npcGUID);
+            if (!pNpc)
+                return;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                bot->GetPlayerbotAI()->TurnInQuests(pNpc);
+            }
+            return;
+        }
+
+        case CMSG_LOOT_ROLL:
+        {
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+            uint64 Guid;
+            uint32 NumberOfPlayers;
+            uint8 rollType;
+            p.rpos(0);              //reset packet pointer
+            p >> Guid;              //guid of the lootable target
+            p >> NumberOfPlayers;   //number of players invited to roll
+            p >> rollType;          //need,greed or pass on roll
+
+            Creature *c = m_master->GetMap()->GetCreature(Guid);
+            GameObject *g = m_master->GetMap()->GetGameObject(Guid);
+            if (!c && !g)
+                return;
+
+            Loot *loot = &c->loot;
+            if (!loot)
+                loot = &g->loot;
+
+            LootItem& lootItem = loot->items[NumberOfPlayers];
+
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                uint32 choice = 0;
+
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Group* group = bot->GetGroup();
+                if (!group)
+                    return;
+
+                ItemTemplate const *pProto = sObjectMgr->GetItemTemplate(lootItem.itemid);
+                if (!pProto)
+                    return;
+
+                if (bot->GetPlayerbotAI()->CanStore())
+                {
+                    if (bot->CanUseItem(pProto) == EQUIP_ERR_OK && bot->GetPlayerbotAI()->IsItemUseful(lootItem.itemid))
+                        choice = 1;  // Need
+                    else if (bot->HasSkill(SKILL_ENCHANTING))
+                        choice = 3;  // Disenchant
+                    else
+                        choice = 2;  // Greed
+                }
+                else
+                    choice = 0;  // Pass
+
+                group->CountRollVote(bot->GetGUID(), Guid, RollVote(choice));
+
+                switch (choice)
+                {
+                    case ROLL_NEED:
+                        bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_NEED, 1);
+                        break;
+                    case ROLL_GREED:
+                        bot->GetAchievementMgr().UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ROLL_GREED, 1);
+                        break;
+                }
+            }
+            return;
+        }
+
+        // Handle GOSSIP activate actions, prior to GOSSIP select menu actions
+        case CMSG_GOSSIP_HELLO:
+        {
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_GOSSIP_HELLO");
+
+            WorldPacket p(packet);    //WorldPacket packet for CMSG_GOSSIP_HELLO, (8)
+            uint64 guid;
+            p.rpos(0);                //reset packet pointer
+            p >> guid;
+
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                if (!bot)
+                    return;
+
+                Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+                if (!pCreature)
+                {
+                    //sLog->outDebug(LOG_FILTER_NONE, "[PlayerbotAI]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO object %s not found or you can't interact with him.", pCreature ? pCreature->GetName() : (char*)guid);
+                    return;
+                }
+
+                GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureTemplate()->GossipMenuId);
+                for (GossipMenuItemsContainer::const_iterator itr = pMenuItemBounds.first; itr != pMenuItemBounds.second; ++itr)
+                {
+                    uint32 npcflags = pCreature->GetUInt32Value(UNIT_NPC_FLAGS);
+
+                    if (!(itr->second.OptionNpcflag & npcflags))
+                        continue;
+
+                    switch (itr->second.OptionType)
+                    {
+                        case GOSSIP_OPTION_TAXIVENDOR:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_TAXIVENDOR");
+                            bot->GetSession()->SendLearnNewTaxiNode(pCreature);
+                            break;
+                        }
+                        case GOSSIP_OPTION_QUESTGIVER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_QUESTGIVER");
+                            bot->GetPlayerbotAI()->TurnInQuests(pCreature);
+                            break;
+                        }
+                        case GOSSIP_OPTION_VENDOR:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_VENDOR");
+                            if (!m_confSellGarbage)
+                                return;
+
+                            bot->GetPlayerbotAI()->SellGarbage(*bot);
+                            break;
+                        }
+                        case GOSSIP_OPTION_STABLEPET:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_STABLEPET");
+                            break;
+                        }
+                        case GOSSIP_OPTION_AUCTIONEER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_AUCTIONEER");
+                            break;
+                        }
+                        case GOSSIP_OPTION_BANKER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_BANKER");
+                            break;
+                        }
+                        case GOSSIP_OPTION_INNKEEPER:
+                        {
+                            // bot->GetPlayerbotAI()->TellMaster("PlayerbotAI:GOSSIP_OPTION_INNKEEPER");
+                            break;
+                        }
+                    }
+                }
+            }
+            return;
+        }
+
+        case CMSG_SPIRIT_HEALER_ACTIVATE:
+        {
+            // DEBUG_LOG ("[PlayerbotAI]: HandleMasterIncomingPacket - Received CMSG_SPIRIT_HEALER_ACTIVATE SpiritHealer is resurrecting the Player %s",m_master->GetName());
+            for (PlayerBotMap::const_iterator itr = session.GetPlayerBotsBegin(); itr != session.GetPlayerBotsEnd(); ++itr)
+            {
+                Player* const bot = itr->second;
+                Group *grp = bot->GetGroup();
+                if (grp)
+                    grp->RemoveMember(bot->GetGUID(), GROUP_REMOVEMETHOD_KICK);
+            }
+            return;
+        }
+
+        case CMSG_LIST_INVENTORY:
+        {
+            if (m_confSellGarbage)
+                return;
+
+            WorldPacket p(packet);
+            p.rpos(0);  // reset reader
+            uint64 npcGUID;
+            p >> npcGUID;
+
+            // for all master's bots
+            for (PlayerBotMap::const_iterator it = session.GetPlayerBotsBegin(); it != session.GetPlayerBotsEnd(); ++it)
+            {
+                Player* const bot = it->second;
+                WorldObject* pNpc = (WorldObject*)sObjectAccessor->GetObjectByTypeMask(*bot, npcGUID, TYPEMASK_UNIT|TYPEMASK_GAMEOBJECT);
+
+                if (!pNpc)
+                    continue;
+                if (!bot->IsInMap(pNpc))
+                {
+                    bot->GetPlayerbotAI()->TellMaster("I'm too far away to sell items!");
+                    continue;
+                }
+                else
+                    bot->GetPlayerbotAI()->SellGarbage(*bot);
+            }
+            return;
+        }
+
+            /*
+               case CMSG_NAME_QUERY:
+               case MSG_MOVE_START_FORWARD:
+               case MSG_MOVE_STOP:
+               case MSG_MOVE_SET_FACING:
+               case MSG_MOVE_START_STRAFE_LEFT:
+               case MSG_MOVE_START_STRAFE_RIGHT:
+               case MSG_MOVE_STOP_STRAFE:
+               case MSG_MOVE_START_BACKWARD:
+               case MSG_MOVE_HEARTBEAT:
+               case CMSG_STANDSTATECHANGE:
+               case CMSG_QUERY_TIME:
+               case CMSG_CREATURE_QUERY:
+               case CMSG_GAMEOBJECT_QUERY:
+               case MSG_MOVE_JUMP:
+               case MSG_MOVE_FALL_LAND:
+                return;
+
+               default:
+               {
+                const char* oc = LookupOpcodeName(packet.GetOpcode());
+                // ChatHandler ch(m_master);
+                // ch.SendSysMessage(oc);
+
+                std::ostringstream out;
+                out << "masterin: " << oc;
+                //sLog->outError(out.str().c_str());
+               }
+             */
+    }
+}
+
+float PlayerbotClassAI::GetCombatDistance(const Unit* target) const
+{
+    float dist = target->GetCombatReach();
+    if (dist < 0.1f)
+        dist = DEFAULT_COMBAT_REACH;
+    return dist;
+    //float radius = target->GetCombatReach() + m_bot->GetCombatReach();
+    //float dx = m_bot->GetPositionX() - target->GetPositionX();
+    //float dy = m_bot->GetPositionY() - target->GetPositionY();
+    //float dz = m_bot->GetPositionZ() - target->GetPositionZ();
+    //float dist = sqrt((dx*dx) + (dy*dy) + (dz*dz)) - radius;
+    //return ( dist > 0 ? dist : 0);
+}
+
+bool PlayerbotClassAI::HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid) const
+{
+    const SpellInfo *const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!pSpellInfo)
+        return false;
+    uint8 loc = m_master->GetSession()->GetSessionDbcLocale();
+    const std::string  name = pSpellInfo->SpellName[loc];
+    if (name.length() == 0)
+        return false;
+    return HasAuraName(unit, name, casterGuid);
+}
+
+bool PlayerbotClassAI::HasAuraName(Unit *target, std::string spell, uint64 casterGuid) const
+{
+    uint8 loc = m_master->GetSession()->GetSessionDbcLocale();
+
+    Unit::AuraMap const &vAuras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const *spellInfo = itr->second->GetSpellInfo();
+        const std::string name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (casterGuid == 0 || (casterGuid != 0 && casterGuid == itr->second->GetCasterGUID())) //only if correct caster casted it
+                return true;
+    }
+    return false;
+};
+
+//See MainSpec enum in PlayerbotAI.h for details on class return values
+uint32 Player::GetSpec()
+{
+    uint32 row = 0, spec = 0;//disabled
+
+    //Iterate through the 3 talent trees
+    for (uint32 i = 0; i < 3; ++i)
+    {
+        for (PlayerTalentMap::iterator iter = m_talents[m_activeSpec]->begin(); iter != m_talents[m_activeSpec]->end(); ++iter)
+        {
+            TalentEntry const *talentId = sTalentStore.LookupEntry((*iter).first);
+            if (!talentId)
+                continue;
+
+            //If current talent is deeper into a tree, that is our new max talent
+            if (talentId->Row > row)
+            {
+                row = talentId->Row;
+
+                //Set the tree the deepest talent is on
+                spec = talentId->TalentTab;
+            }
+        }
+    }
+
+    //Return the tree with the deepest talent
+    return spec;
+}
+
+void Player::UpdateMail()
+{
+    // save money,items and mail to prevent cheating
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    //SaveGoldToDB(trans);
+    SaveInventoryAndGoldToDB(trans);
+    _SaveMail(trans);
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+bool Player::requiredQuests(const char* pQuestIdString)
+{
+    if (pQuestIdString != NULL)
+    {
+        unsigned int pos = 0;
+        unsigned int id;
+        std::string confString(pQuestIdString);
+        chompAndTrim(confString);
+        while (getNextQuestId(confString, pos, id))
+        {
+            QuestStatus status = GetQuestStatus(id);
+            if (status == QUEST_STATUS_COMPLETE)
+                return true;
+        }
+    }
+    return false;
+}
+
+void Player::chompAndTrim(std::string& str)
+{
+    while (str.length() > 0)
+    {
+        char lc = str[str.length() - 1];
+        if (lc == '\r' || lc == '\n' || lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(0, str.length() - 1);
+        else
+            break;
+    }
+
+    while (str.length() > 0)
+    {
+        char lc = str[0];
+        if (lc == ' ' || lc == '"' || lc == '\'')
+            str = str.substr(1, str.length() - 1);
+        else
+            break;
+    }
+}
+
+bool Player::getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId)
+{
+    bool result = false;
+    unsigned int i;
+    for (i = pStartPos; i < pString.size(); ++i)
+    {
+        if (pString[i] == ',')
+            break;
+    }
+    if (i > pStartPos)
+    {
+        std::string idString = pString.substr(pStartPos, i - pStartPos);
+        pStartPos = i + 1;
+        chompAndTrim(idString);
+        pId = atoi(idString.c_str());
+        result = true;
+    }
+    return(result);
+}
+
+void Player::skill(std::list<uint32>& m_spellsToLearn)
+{
+    for (SkillStatusMap::const_iterator itr = mSkillStatus.begin(); itr != mSkillStatus.end(); ++itr)
+        if (itr->second.uState != SKILL_DELETED)
+            m_spellsToLearn.push_back(itr->first);
+}
+
+void Player::MakeTalentGlyphLink(std::ostringstream &out)
+{
+    // |cff4e96f7|Htalent:1396:4|h[Unleashed Fury]|h|r
+    // |cff66bbff|Hglyph:23:460|h[Glyph of Fortitude]|h|r
+
+    if (m_specsCount)
+        // loop through all specs (only 1 for now)
+        for (uint8 specIdx = 0; specIdx < m_specsCount; ++specIdx)
+        {
+            // find class talent tabs (all players have 3 talent tabs)
+            uint32 const* talentTabIds = GetTalentTabPages(getClass());
+
+            out << "\n" << "Active Talents ";
+
+            for (uint8 i = 0; i < 3; ++i)
+            {
+                uint32 talentTabId = talentTabIds[i];
+                for (PlayerTalentMap::iterator iter = m_talents[specIdx]->begin(); iter != m_talents[specIdx]->end(); ++iter)
+                {
+                    PlayerTalent* talent = (*iter).second;
+                    TalentEntry const *talentId = sTalentStore.LookupEntry((*iter).first);
+                    if (!talentId)
+                        continue;
+
+                    if (talent->state == PLAYERSPELL_REMOVED)
+                        continue;
+
+                    // skip another tab talents
+                    if (talentId->TalentTab != talentTabId)
+                        continue;
+
+                    SpellInfo const *_spellEntry;
+                    int8 rank = 0;
+                    for (rank = MAX_TALENT_RANK-1; rank >= 0; --rank)
+                    {
+                        if (talentId->RankID[rank] == 0)
+                            continue;
+                        _spellEntry = sSpellMgr->GetSpellInfo(talentId->RankID[rank]);
+                        if (!_spellEntry)
+                            continue;
+                        if (m_bot->HasSpell(talentId->RankID[rank]))
+                            break;
+                    }
+
+                    if (rank == 0)
+                        continue;
+
+                    _spellEntry = sSpellMgr->GetSpellInfo(talentId->RankID[rank]);
+
+                    out << "|cff4e96f7|Htalent:" << talentId->TalentID << ":" << rank
+                        << " |h[" << _spellEntry->SpellName[GetSession()->GetSessionDbcLocale()] << "]|h|r";
+                }
+            }
+
+            uint32 freepoints = GetFreeTalentPoints();
+
+            out << " Unspent points : ";
+            out << "|h|cffff0000" << freepoints << "|h|r";
+            out << "\n" << "Active Glyphs ";
+
+            // GlyphProperties.dbc
+            for (uint8 i = 0; i < MAX_GLYPH_SLOT_INDEX; ++i)
+            {
+                GlyphPropertiesEntry const* glyph = sGlyphPropertiesStore.LookupEntry(m_Glyphs[specIdx][i]);
+                if (!glyph)
+                    continue;
+
+                SpellInfo const *spell_entry = sSpellMgr->GetSpellInfo(glyph->SpellId);
+
+                out << "|cff66bbff|Hglyph:" << GetGlyphSlot(i) << ":" << m_Glyphs[specIdx][i]
+                    << " |h[" << spell_entry->SpellName[GetSession()->GetSessionDbcLocale()] << "]|h|r";
+
+            }
+        }
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotAI.h b/src/server/game/AI/PlayerBots/PlayerbotAI.h
new file mode 100644
index 0000000..920ba8f
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotAI.h
@@ -0,0 +1,2113 @@
+#ifndef _PLAYERBOTAI_H
+#define _PLAYERBOTAI_H
+
+#include "Group.h"
+
+class PlayerbotAI;
+class PlayerbotClassAI;
+
+enum Special
+{
+    SPELL_ROOT              = 42716, //Self Root Forever (No Visual)
+};
+
+enum SpellSpecific
+{
+    SPELL_NORMAL            = 0,
+    SPELL_SEAL              = 1,
+    SPELL_BLESSING          = 2,
+    SPELL_AURA              = 3,
+    SPELL_STING             = 4,
+    SPELL_CURSE             = 5,
+    SPELL_ASPECT            = 6,
+    SPELL_TRACKER           = 7,
+    SPELL_WARLOCK_ARMOR     = 8,
+    SPELL_MAGE_ARMOR        = 9,
+    SPELL_ELEMENTAL_SHIELD  = 10,
+    SPELL_MAGE_POLYMORPH    = 11,
+    SPELL_POSITIVE_SHOUT    = 12,
+    SPELL_JUDGEMENT         = 13,
+    SPELL_BATTLE_ELIXIR     = 14,
+    SPELL_GUARDIAN_ELIXIR   = 15,
+    SPELL_FLASK_ELIXIR      = 16,
+    SPELL_PRESENCE          = 17,
+    SPELL_HAND              = 18,
+    SPELL_WELL_FED          = 19,
+    SPELL_FOOD              = 20,
+    SPELL_WATER             = 21,
+    SPELL_FOOD_AND_DRINK    = 22,
+    SPELL_UA_IMMOLATE       = 23,                           // Unstable Affliction and Immolate
+};
+
+enum RacialTraits
+{
+    ARCANE_TORRENT_MANA_CLASSES    = 28730,
+    ARCANE_TORRENT_DEATH_KNIGHT    = 50613,
+    ARCANE_TORRENT_ROGUE           = 25046,
+    BERSERKING_ALL                 = 26297,
+    BLOOD_FURY_MELEE_CLASSES       = 20572,
+    BLOOD_FURY_WARLOCK             = 33702,
+    BLOOD_FURY_SHAMAN              = 33697,
+    ESCAPE_ARTIST_ALL              = 20589,
+    EVERY_MAN_FOR_HIMSELF_ALL      = 59752,
+    GIFT_OF_THE_NAARU_DEATH_KNIGHT = 59545,
+    GIFT_OF_THE_NAARU_HUNTER       = 59543,
+    GIFT_OF_THE_NAARU_MAGE         = 59548,
+    GIFT_OF_THE_NAARU_PALADIN      = 59542,
+    GIFT_OF_THE_NAARU_PRIEST       = 59544,
+    GIFT_OF_THE_NAARU_SHAMAN       = 59547,
+    GIFT_OF_THE_NAARU_WARRIOR      = 28880,
+    SHADOWMELD_ALL                 = 58984,
+    STONEFORM_ALL                  = 20594,
+    WAR_STOMP_ALL                  = 20549,
+    WILL_OF_THE_FORSAKEN_ALL       = 7744
+};
+
+enum BotProfessionSpells
+{
+    ALCHEMY_1                      = 2259,
+    BLACKSMITHING_1                = 2018,
+    COOKING_1                      = 2550,
+    ENCHANTING_1                   = 7411,
+    ENGINEERING_1                  = 4036,
+    FIRST_AID_1                    = 3273,
+    FISHING_1                      = 7620,
+    HERB_GATHERING_1               = 2366,
+    INSCRIPTION_1                  = 45357,
+    JEWELCRAFTING_1                = 25229,
+    MINING_1                       = 2575,
+    SKINNING_1                     = 8613,
+    TAILORING_1                    = 3908,
+    MILLING_1                      = 51005,
+    DISENCHANTING_1                = 13262,
+    PROSPECTING_1                  = 31252
+};
+
+enum TalentsDeathKnight  // 0x020
+{
+    DEATHKNIGHT_BUTCHERY                        = 1939,  // TabId = 398, Tab = 0, Row = 0, Column = 0
+    DEATHKNIGHT_SUBVERSION                      = 1945,  // TabId = 398, Tab = 0, Row = 0, Column = 1
+    DEATHKNIGHT_BLADE_BARRIER                   = 2017,  // TabId = 398, Tab = 0, Row = 0, Column = 2
+    DEATHKNIGHT_BLADED_ARMOR                    = 1938,  // TabId = 398, Tab = 0, Row = 1, Column = 0
+    DEATHKNIGHT_SCENT_OF_BLOOD                  = 1948,  // TabId = 398, Tab = 0, Row = 1, Column = 1
+    DEATHKNIGHT_TWOHANDED_WEAPON_SPECIALIZATION = 2217,  // TabId = 398, Tab = 0, Row = 1, Column = 2
+    DEATHKNIGHT_RUNE_TAP                        = 1941,  // TabId = 398, Tab = 0, Row = 2, Column = 0
+    DEATHKNIGHT_DARK_CONVICTION                 = 1943,  // TabId = 398, Tab = 0, Row = 2, Column = 1
+    DEATHKNIGHT_DEATH_RUNE_MASTERY              = 2086,  // TabId = 398, Tab = 0, Row = 2, Column = 2
+    DEATHKNIGHT_IMPROVED_RUNE_TAP               = 1942,  // TabId = 398, Tab = 0, Row = 3, Column = 0
+    DEATHKNIGHT_SPELL_DEFLECTION                = 2018,  // TabId = 398, Tab = 0, Row = 3, Column = 2
+    DEATHKNIGHT_VENDETTA                        = 1953,  // TabId = 398, Tab = 0, Row = 3, Column = 3
+    DEATHKNIGHT_BLOODY_STRIKES                  = 2015,  // TabId = 398, Tab = 0, Row = 4, Column = 0
+    DEATHKNIGHT_VETERAN_OF_THE_THIRD_WAR        = 1950,  // TabId = 398, Tab = 0, Row = 4, Column = 2
+    DEATHKNIGHT_MARK_OF_BLOOD                   = 1949,  // TabId = 398, Tab = 0, Row = 4, Column = 3
+    DEATHKNIGHT_BLOODY_VENGEANCE                = 1944,  // TabId = 398, Tab = 0, Row = 5, Column = 1
+    DEATHKNIGHT_ABOMINATIONS_MIGHT              = 2105,  // TabId = 398, Tab = 0, Row = 5, Column = 2
+    DEATHKNIGHT_BLOOD_WORMS                     = 1960,  // TabId = 398, Tab = 0, Row = 6, Column = 0
+    DEATHKNIGHT_HYSTERIA                        = 1954,  // TabId = 398, Tab = 0, Row = 6, Column = 1
+    DEATHKNIGHT_IMPROVED_BLOOD_PRESENCE         = 1936,  // TabId = 398, Tab = 0, Row = 6, Column = 2
+    DEATHKNIGHT_IMPROVED_DEATH_STRIKE           = 2259,  // TabId = 398, Tab = 0, Row = 7, Column = 0
+    DEATHKNIGHT_SUDDEN_DOOM                     = 1955,  // TabId = 398, Tab = 0, Row = 7, Column = 1
+    DEATHKNIGHT_VAMPIRIC_BLOOD                  = 2019,  // TabId = 398, Tab = 0, Row = 7, Column = 2
+    DEATHKNIGHT_WILL_OF_THE_NECROPOLIS          = 1959,  // TabId = 398, Tab = 0, Row = 8, Column = 0
+    DEATHKNIGHT_HEART_STRIKE                    = 1957,  // TabId = 398, Tab = 0, Row = 8, Column = 1
+    DEATHKNIGHT_MIGHT_OF_MOGRAINE               = 1958,  // TabId = 398, Tab = 0, Row = 8, Column = 2
+    DEATHKNIGHT_BLOOD_GORGED                    = 2034,  // TabId = 398, Tab = 0, Row = 9, Column = 1
+    DEATHKNIGHT_DANCING_RUNE_WEAPON             = 1961,  // TabId = 398, Tab = 0, Row = 10, Column = 1
+    DEATHKNIGHT_IMPROVED_ICY_TOUCH              = 2031,  // TabId = 399, Tab = 1, Row = 0, Column = 0
+    DEATHKNIGHT_RUNIC_POWER_MASTERY             = 2020,  // TabId = 399, Tab = 1, Row = 0, Column = 1
+    DEATHKNIGHT_TOUGHNESS                       = 1968,  // TabId = 399, Tab = 1, Row = 0, Column = 2
+    DEATHKNIGHT_ICY_REACH                       = 2035,  // TabId = 399, Tab = 1, Row = 1, Column = 1
+    DEATHKNIGHT_BLACK_ICE                       = 1973,  // TabId = 399, Tab = 1, Row = 1, Column = 2
+    DEATHKNIGHT_NERVES_OF_COLD_STEEL            = 2022,  // TabId = 399, Tab = 1, Row = 1, Column = 3
+    DEATHKNIGHT_ICY_TALONS                      = 2042,  // TabId = 399, Tab = 1, Row = 2, Column = 0
+    DEATHKNIGHT_LICHBORNE                       = 2215,  // TabId = 399, Tab = 1, Row = 2, Column = 1
+    DEATHKNIGHT_ANNIHILATION                    = 2048,  // TabId = 399, Tab = 1, Row = 2, Column = 2
+    DEATHKNIGHT_KILLING_MACHINE                 = 2044,  // TabId = 399, Tab = 1, Row = 3, Column = 1
+    DEATHKNIGHT_CHILL_OF_THE_GRAVE              = 1981,  // TabId = 399, Tab = 1, Row = 3, Column = 2
+    DEATHKNIGHT_ENDLESS_WINTER                  = 1971,  // TabId = 399, Tab = 1, Row = 3, Column = 3
+    DEATHKNIGHT_FRIGID_DREADPLATE               = 1990,  // TabId = 399, Tab = 1, Row = 4, Column = 1
+    DEATHKNIGHT_GLACIER_ROT                     = 2030,  // TabId = 399, Tab = 1, Row = 4, Column = 2
+    DEATHKNIGHT_DEATHCHILL                      = 1980,  // TabId = 399, Tab = 1, Row = 4, Column = 3
+    DEATHKNIGHT_IMPROVED_ICY_TALONS             = 2223,  // TabId = 399, Tab = 1, Row = 5, Column = 0
+    DEATHKNIGHT_MERCILESS_COMBAT                = 1993,  // TabId = 399, Tab = 1, Row = 5, Column = 1
+    DEATHKNIGHT_RIME                            = 1992,  // TabId = 399, Tab = 1, Row = 5, Column = 2
+    DEATHKNIGHT_CHILLBLAINS                     = 2260,  // TabId = 399, Tab = 1, Row = 6, Column = 0
+    DEATHKNIGHT_HUNGERING_COLD                  = 1999,  // TabId = 399, Tab = 1, Row = 6, Column = 1
+    DEATHKNIGHT_IMPROVED_FROST_PRESENCE         = 2029,  // TabId = 399, Tab = 1, Row = 6, Column = 2
+    DEATHKNIGHT_THREAT_OF_THASSARIAN            = 2284,  // TabId = 399, Tab = 1, Row = 7, Column = 0
+    DEATHKNIGHT_BLOOD_OF_THE_NORTH              = 2210,  // TabId = 399, Tab = 1, Row = 7, Column = 1
+    DEATHKNIGHT_UNBREAKABLE_ARMOR               = 1979,  // TabId = 399, Tab = 1, Row = 7, Column = 2
+    DEATHKNIGHT_ACCLIMATION                     = 1997,  // TabId = 399, Tab = 1, Row = 8, Column = 0
+    DEATHKNIGHT_FROST_STRIKE                    = 1975,  // TabId = 399, Tab = 1, Row = 8, Column = 1
+    DEATHKNIGHT_GUILE_OF_GOREFIEND              = 2040,  // TabId = 399, Tab = 1, Row = 8, Column = 2
+    DEATHKNIGHT_TUNDRA_STALKER                  = 1998,  // TabId = 399, Tab = 1, Row = 9, Column = 1
+    DEATHKNIGHT_HOWLING_BLAST                   = 1989,  // TabId = 399, Tab = 1, Row = 10, Column = 1
+    DEATHKNIGHT_VICIOUS_STRIKES                 = 2082,  // TabId = 400, Tab = 2, Row = 0, Column = 0
+    DEATHKNIGHT_VIRULENCE                       = 1932,  // TabId = 400, Tab = 2, Row = 0, Column = 1
+    DEATHKNIGHT_ANTICIPATION                    = 2218,  // TabId = 400, Tab = 2, Row = 0, Column = 2
+    DEATHKNIGHT_EPIDEMIC                        = 1963,  // TabId = 400, Tab = 2, Row = 1, Column = 0
+    DEATHKNIGHT_MORBIDITY                       = 1933,  // TabId = 400, Tab = 2, Row = 1, Column = 1
+    DEATHKNIGHT_UNHOLY_COMMAND                  = 2025,  // TabId = 400, Tab = 2, Row = 1, Column = 2
+    DEATHKNIGHT_RAVENOUS_DEAD                   = 1934,  // TabId = 400, Tab = 2, Row = 1, Column = 3
+    DEATHKNIGHT_OUTBREAK                        = 2008,  // TabId = 400, Tab = 2, Row = 2, Column = 0
+    DEATHKNIGHT_NECROSIS                        = 2047,  // TabId = 400, Tab = 2, Row = 2, Column = 1
+    DEATHKNIGHT_CORPSE_EXPLOSION                = 1985,  // TabId = 400, Tab = 2, Row = 2, Column = 2
+    DEATHKNIGHT_ON_A_PALE_HORSE                 = 2039,  // TabId = 400, Tab = 2, Row = 3, Column = 1
+    DEATHKNIGHT_BLOODCAKED_BLADE                = 2004,  // TabId = 400, Tab = 2, Row = 3, Column = 2
+    DEATHKNIGHT_NIGHT_OF_THE_DEAD               = 2225,  // TabId = 400, Tab = 2, Row = 3, Column = 3
+    DEATHKNIGHT_UNHOLY_BLIGHT                   = 1996,  // TabId = 400, Tab = 2, Row = 4, Column = 0
+    DEATHKNIGHT_IMPURITY                        = 2005,  // TabId = 400, Tab = 2, Row = 4, Column = 1
+    DEATHKNIGHT_DIRGE                           = 2011,  // TabId = 400, Tab = 2, Row = 4, Column = 2
+    DEATHKNIGHT_DESECRATION                     = 2226,  // TabId = 400, Tab = 2, Row = 5, Column = 0
+    DEATHKNIGHT_MAGIC_SUPPRESSION               = 2009,  // TabId = 400, Tab = 2, Row = 5, Column = 1
+    DEATHKNIGHT_REAPING                         = 2001,  // TabId = 400, Tab = 2, Row = 5, Column = 2
+    DEATHKNIGHT_MASTER_OF_GHOULS                = 1984,  // TabId = 400, Tab = 2, Row = 5, Column = 3
+    DEATHKNIGHT_DESOLATION                      = 2285,  // TabId = 400, Tab = 2, Row = 6, Column = 0
+    DEATHKNIGHT_ANTIMAGIC_ZONE                  = 2221,  // TabId = 400, Tab = 2, Row = 6, Column = 1
+    DEATHKNIGHT_IMPROVED_UNHOLY_PRESENCE        = 2013,  // TabId = 400, Tab = 2, Row = 6, Column = 2
+    DEATHKNIGHT_GHOUL_FRENZY                    = 2085,  // TabId = 400, Tab = 2, Row = 6, Column = 3
+    DEATHKNIGHT_CRYPT_FEVER                     = 1962,  // TabId = 400, Tab = 2, Row = 7, Column = 1
+    DEATHKNIGHT_BONE_SHIELD                     = 2007,  // TabId = 400, Tab = 2, Row = 7, Column = 2
+    DEATHKNIGHT_WANDERING_PLAGUE                = 2003,  // TabId = 400, Tab = 2, Row = 8, Column = 0
+    DEATHKNIGHT_EBON_PLAGUEBRINGER              = 2043,  // TabId = 400, Tab = 2, Row = 8, Column = 1
+    DEATHKNIGHT_SCOURGE_STRIKE                  = 2216,  // TabId = 400, Tab = 2, Row = 8, Column = 2
+    DEATHKNIGHT_RAGE_OF_RIVENDARE               = 2036,  // TabId = 400, Tab = 2, Row = 9, Column = 1
+    DEATHKNIGHT_SUMMON_GARGOYLE                 = 2000   // TabId = 400, Tab = 2, Row = 10, Column = 1
+};
+
+enum TalentsDruid  // 0x400
+{
+    DRUID_FEROCITY                              = 796,   // TabId = 281, Tab = 1, Row = 0, Column = 1
+    DRUID_FERAL_AGGRESSION                      = 795,   // TabId = 281, Tab = 1, Row = 0, Column = 2
+    DRUID_FERAL_INSTINCT                        = 799,   // TabId = 281, Tab = 1, Row = 1, Column = 0
+    DRUID_SAVAGE_FURY                           = 805,   // TabId = 281, Tab = 1, Row = 1, Column = 1
+    DRUID_THICK_HIDE                            = 794,   // TabId = 281, Tab = 1, Row = 1, Column = 2
+    DRUID_FERAL_SWIFTNESS                       = 807,   // TabId = 281, Tab = 1, Row = 2, Column = 0
+    DRUID_SURVIVAL_INSTINCTS                    = 1162,  // TabId = 281, Tab = 1, Row = 2, Column = 1
+    DRUID_SHARPENED_CLAWS                       = 798,   // TabId = 281, Tab = 1, Row = 2, Column = 2
+    DRUID_SHREDDING_ATTACKS                     = 802,   // TabId = 281, Tab = 1, Row = 3, Column = 0
+    DRUID_PREDATORY_STRIKES                     = 803,   // TabId = 281, Tab = 1, Row = 3, Column = 1
+    DRUID_PRIMAL_FURY                           = 801,   // TabId = 281, Tab = 1, Row = 3, Column = 2
+    DRUID_PRIMAL_PRECISION                      = 1914,  // TabId = 281, Tab = 1, Row = 3, Column = 3
+    DRUID_BRUTAL_IMPACT                         = 797,   // TabId = 281, Tab = 1, Row = 4, Column = 0
+    DRUID_FERAL_CHARGE                          = 804,   // TabId = 281, Tab = 1, Row = 4, Column = 2
+    DRUID_NURTURING_INSTINCT                    = 1792,  // TabId = 281, Tab = 1, Row = 4, Column = 3
+    DRUID_NATURAL_REACTION                      = 2242,  // TabId = 281, Tab = 1, Row = 5, Column = 0
+    DRUID_HEART_OF_THE_WILD                     = 808,   // TabId = 281, Tab = 1, Row = 5, Column = 1
+    DRUID_SURVIVAL_OF_THE_FITTEST               = 1794,  // TabId = 281, Tab = 1, Row = 5, Column = 2
+    DRUID_LEADER_OF_THE_PACK                    = 809,   // TabId = 281, Tab = 1, Row = 6, Column = 1
+    DRUID_IMPROVED_LEADER_OF_THE_PACK           = 1798,  // TabId = 281, Tab = 1, Row = 6, Column = 2
+    DRUID_PRIMAL_TENACITY                       = 1793,  // TabId = 281, Tab = 1, Row = 6, Column = 3
+    DRUID_PROTECTOR_OF_THE_PACK                 = 2241,  // TabId = 281, Tab = 1, Row = 7, Column = 0
+    DRUID_PREDATORY_INSTINCTS                   = 1795,  // TabId = 281, Tab = 1, Row = 7, Column = 2
+    DRUID_INFECTED_WOUNDS                       = 1919,  // TabId = 281, Tab = 1, Row = 7, Column = 3
+    DRUID_KING_OF_THE_JUNGLE                    = 1921,  // TabId = 281, Tab = 1, Row = 8, Column = 0
+    DRUID_MANGLE                                = 1796,  // TabId = 281, Tab = 1, Row = 8, Column = 1
+    DRUID_IMPROVED_MANGLE                       = 1920,  // TabId = 281, Tab = 1, Row = 8, Column = 2
+    DRUID_REND_AND_TEAR                         = 1918,  // TabId = 281, Tab = 1, Row = 9, Column = 1
+    DRUID_PRIMAL_GORE                           = 2266,  // TabId = 281, Tab = 1, Row = 9, Column = 2
+    DRUID_BERSERK                               = 1927,  // TabId = 281, Tab = 1, Row = 10, Column = 1
+    DRUID_IMPROVED_MARK_OF_THE_WILD             = 821,   // TabId = 282, Tab = 2, Row = 0, Column = 0
+    DRUID_NATURES_FOCUS                         = 823,   // TabId = 282, Tab = 2, Row = 0, Column = 1
+    DRUID_FUROR                                 = 822,   // TabId = 282, Tab = 2, Row = 0, Column = 2
+    DRUID_NATURALIST                            = 824,   // TabId = 282, Tab = 2, Row = 1, Column = 0
+    DRUID_SUBTLETY                              = 841,   // TabId = 282, Tab = 2, Row = 1, Column = 1
+    DRUID_NATURAL_SHAPESHIFTER                  = 826,   // TabId = 282, Tab = 2, Row = 1, Column = 2
+    DRUID_INTENSITY                             = 829,   // TabId = 282, Tab = 2, Row = 2, Column = 0
+    DRUID_OMEN_OF_CLARITY                       = 827,   // TabId = 282, Tab = 2, Row = 2, Column = 1
+    DRUID_MASTER_SHAPESHIFTER                   = 1915,  // TabId = 282, Tab = 2, Row = 2, Column = 2
+    DRUID_TRANQUIL_SPIRIT                       = 843,   // TabId = 282, Tab = 2, Row = 3, Column = 1
+    DRUID_IMPROVED_REJUVENATION                 = 830,   // TabId = 282, Tab = 2, Row = 3, Column = 2
+    DRUID_NATURES_SWIFTNESS                     = 831,   // TabId = 282, Tab = 2, Row = 4, Column = 0
+    DRUID_GIFT_OF_NATURE                        = 828,   // TabId = 282, Tab = 2, Row = 4, Column = 1
+    DRUID_IMPROVED_TRANQUILITY                  = 842,   // TabId = 282, Tab = 2, Row = 4, Column = 3
+    DRUID_EMPOWERED_TOUCH                       = 1788,  // TabId = 282, Tab = 2, Row = 5, Column = 0
+    DRUID_NATURES_BOUNTY                        = 825,   // TabId = 282, Tab = 2, Row = 5, Column = 2
+    DRUID_LIVING_SPIRIT                         = 1797,  // TabId = 282, Tab = 2, Row = 6, Column = 0
+    DRUID_SWIFTMEND                             = 844,   // TabId = 282, Tab = 2, Row = 6, Column = 1
+    DRUID_NATURAL_PERFECTION                    = 1790,  // TabId = 282, Tab = 2, Row = 6, Column = 2
+    DRUID_EMPOWERED_REJUVENATION                = 1789,  // TabId = 282, Tab = 2, Row = 7, Column = 1
+    DRUID_LIVING_SEED                           = 1922,  // TabId = 282, Tab = 2, Row = 7, Column = 2
+    DRUID_REVITALIZE                            = 1929,  // TabId = 282, Tab = 2, Row = 8, Column = 0
+    DRUID_TREE_OF_LIFE                          = 1791,  // TabId = 282, Tab = 2, Row = 8, Column = 1
+    DRUID_IMPROVED_TREE_OF_LIFE                 = 1930,  // TabId = 282, Tab = 2, Row = 8, Column = 2
+    DRUID_IMPROVED_BARKSKIN                     = 2264,  // TabId = 282, Tab = 2, Row = 9, Column = 0
+    DRUID_GIFT_OF_THE_EARTHMOTHER               = 1916,  // TabId = 282, Tab = 2, Row = 9, Column = 2
+    DRUID_WILD_GROWTH                           = 1917,  // TabId = 282, Tab = 2, Row = 10, Column = 1
+    DRUID_STARLIGHT_WRATH                       = 762,   // TabId = 283, Tab = 0, Row = 0, Column = 1
+    DRUID_GENESIS                               = 2238,  // TabId = 283, Tab = 0, Row = 0, Column = 2
+    DRUID_MOONGLOW                              = 783,   // TabId = 283, Tab = 0, Row = 1, Column = 0
+    DRUID_NATURES_MAJESTY                       = 1822,  // TabId = 283, Tab = 0, Row = 1, Column = 1
+    DRUID_IMPROVED_MOONFIRE                     = 763,   // TabId = 283, Tab = 0, Row = 1, Column = 3
+    DRUID_BRAMBLES                              = 782,   // TabId = 283, Tab = 0, Row = 2, Column = 0
+    DRUID_NATURES_GRACE                         = 789,   // TabId = 283, Tab = 0, Row = 2, Column = 1
+    DRUID_NATURES_SPLENDOR_A                    = 2240,  // TabId = 283, Tab = 0, Row = 2, Column = 2
+    DRUID_NATURES_REACH                         = 764,   // TabId = 283, Tab = 0, Row = 2, Column = 3
+    DRUID_VENGEANCE                             = 792,   // TabId = 283, Tab = 0, Row = 3, Column = 1
+    DRUID_CELESTIAL_FOCUS                       = 784,   // TabId = 283, Tab = 0, Row = 3, Column = 2
+    DRUID_LUNAR_GUIDANCE                        = 1782,  // TabId = 283, Tab = 0, Row = 4, Column = 0
+    DRUID_INSECT_SWARM                          = 788,   // TabId = 283, Tab = 0, Row = 4, Column = 1
+    DRUID_IMPROVED_INSECT_SWARM                 = 2239,  // TabId = 283, Tab = 0, Row = 4, Column = 2
+    DRUID_DREAMSTATE                            = 1784,  // TabId = 283, Tab = 0, Row = 5, Column = 0
+    DRUID_MOONFURY                              = 790,   // TabId = 283, Tab = 0, Row = 5, Column = 1
+    DRUID_BALANCE_OF_POWER                      = 1783,  // TabId = 283, Tab = 0, Row = 5, Column = 2
+    DRUID_MOONKIN_FORM                          = 793,   // TabId = 283, Tab = 0, Row = 6, Column = 1
+    DRUID_IMPROVED_MOONKIN_FORM                 = 1912,  // TabId = 283, Tab = 0, Row = 6, Column = 2
+    DRUID_IMPROVED_FAERIE_FIRE                  = 1785,  // TabId = 283, Tab = 0, Row = 6, Column = 3
+    DRUID_OWLKIN_FRENZY                         = 1913,  // TabId = 283, Tab = 0, Row = 7, Column = 0
+    DRUID_WRATH_OF_CENARIUS                     = 1786,  // TabId = 283, Tab = 0, Row = 7, Column = 2
+    DRUID_ECLIPSE                               = 1924,  // TabId = 283, Tab = 0, Row = 8, Column = 0
+    DRUID_TYPHOON                               = 1923,  // TabId = 283, Tab = 0, Row = 8, Column = 1
+    DRUID_FORCE_OF_NATURE                       = 1787,  // TabId = 283, Tab = 0, Row = 8, Column = 2
+    DRUID_GALE_WINDS                            = 1925,  // TabId = 283, Tab = 0, Row = 8, Column = 3
+    DRUID_EARTH_AND_MOON                        = 1928,  // TabId = 283, Tab = 0, Row = 9, Column = 1
+    DRUID_STARFALL                              = 1926   // TabId = 283, Tab = 0, Row = 10, Column = 1
+};
+
+enum TalentsHunter  // 0x004
+{
+    HUNTER_IMPROVED_ASPECT_OF_THE_HAWK          = 1382,  // TabId = 361, Tab = 0, Row = 0, Column = 1
+    HUNTER_ENDURANCE_TRAINING                   = 1389,  // TabId = 361, Tab = 0, Row = 0, Column = 2
+    HUNTER_FOCUSED_FIRE                         = 1624,  // TabId = 361, Tab = 0, Row = 1, Column = 0
+    HUNTER_IMPROVED_ASPECT_OF_THE_MONKEY        = 1381,  // TabId = 361, Tab = 0, Row = 1, Column = 1
+    HUNTER_THICK_HIDE                           = 1395,  // TabId = 361, Tab = 0, Row = 1, Column = 2
+    HUNTER_IMPROVED_REVIVE_PET                  = 1625,  // TabId = 361, Tab = 0, Row = 1, Column = 3
+    HUNTER_PATHFINDING                          = 1384,  // TabId = 361, Tab = 0, Row = 2, Column = 0
+    HUNTER_ASPECT_MASTERY                       = 2138,  // TabId = 361, Tab = 0, Row = 2, Column = 1
+    HUNTER_UNLEASHED_FURY                       = 1396,  // TabId = 361, Tab = 0, Row = 2, Column = 2
+    HUNTER_IMPROVED_MEND_PET                    = 1385,  // TabId = 361, Tab = 0, Row = 3, Column = 1
+    HUNTER_FEROCITY                             = 1393,  // TabId = 361, Tab = 0, Row = 3, Column = 2
+    HUNTER_SPIRIT_BOND                          = 1388,  // TabId = 361, Tab = 0, Row = 4, Column = 0
+    HUNTER_INTIMIDATION                         = 1387,  // TabId = 361, Tab = 0, Row = 4, Column = 1
+    HUNTER_BESTIAL_DISCIPLINE                   = 1390,  // TabId = 361, Tab = 0, Row = 4, Column = 3
+    HUNTER_ANIMAL_HANDLER                       = 1799,  // TabId = 361, Tab = 0, Row = 5, Column = 0
+    HUNTER_FRENZY                               = 1397,  // TabId = 361, Tab = 0, Row = 5, Column = 2
+    HUNTER_FEROCIOUS_INSPIRATION                = 1800,  // TabId = 361, Tab = 0, Row = 6, Column = 0
+    HUNTER_BESTIAL_WRATH                        = 1386,  // TabId = 361, Tab = 0, Row = 6, Column = 1
+    HUNTER_CATLIKE_REFLEXES                     = 1801,  // TabId = 361, Tab = 0, Row = 6, Column = 2
+    HUNTER_INVIGORATION                         = 2136,  // TabId = 361, Tab = 0, Row = 7, Column = 0
+    HUNTER_SERPENTS_SWIFTNESS                   = 1802,  // TabId = 361, Tab = 0, Row = 7, Column = 2
+    HUNTER_LONGEVITY                            = 2140,  // TabId = 361, Tab = 0, Row = 8, Column = 0
+    HUNTER_THE_BEAST_WITHIN                     = 1803,  // TabId = 361, Tab = 0, Row = 8, Column = 1
+    HUNTER_COBRA_STRIKES                        = 2137,  // TabId = 361, Tab = 0, Row = 8, Column = 2
+    HUNTER_KINDRED_SPIRITS                      = 2227,  // TabId = 361, Tab = 0, Row = 9, Column = 1
+    HUNTER_BEAST_MASTERY                        = 2139,  // TabId = 361, Tab = 0, Row = 10, Column = 1
+    HUNTER_IMPROVED_TRACKING                    = 1623,  // TabId = 362, Tab = 2, Row = 0, Column = 0
+    HUNTER_HAWK_EYE                             = 1820,  // TabId = 362, Tab = 2, Row = 0, Column = 1
+    HUNTER_SAVAGE_STRIKES                       = 1621,  // TabId = 362, Tab = 2, Row = 0, Column = 2
+    HUNTER_SUREFOOTED                           = 1310,  // TabId = 362, Tab = 2, Row = 1, Column = 0
+    HUNTER_ENTRAPMENT                           = 1304,  // TabId = 362, Tab = 2, Row = 1, Column = 1
+    HUNTER_TRAP_MASTERY                         = 1305,  // TabId = 362, Tab = 2, Row = 1, Column = 2
+    HUNTER_SURVIVAL_INSTINCTS                   = 1810,  // TabId = 362, Tab = 2, Row = 1, Column = 3
+    HUNTER_SURVIVALIST                          = 1622,  // TabId = 362, Tab = 2, Row = 2, Column = 0
+    HUNTER_SCATTER_SHOT                         = 1814,  // TabId = 362, Tab = 2, Row = 2, Column = 1
+    HUNTER_DEFLECTION                           = 1311,  // TabId = 362, Tab = 2, Row = 2, Column = 2
+    HUNTER_SURVIVAL_TACTICS                     = 1309,  // TabId = 362, Tab = 2, Row = 2, Column = 3
+    HUNTER_TNT                                  = 2229,  // TabId = 362, Tab = 2, Row = 3, Column = 1
+    HUNTER_LOCK_AND_LOAD                        = 1306,  // TabId = 362, Tab = 2, Row = 3, Column = 3
+    HUNTER_HUNTER_VS_WILD                       = 2228,  // TabId = 362, Tab = 2, Row = 4, Column = 0
+    HUNTER_KILLER_INSTINCT                      = 1321,  // TabId = 362, Tab = 2, Row = 4, Column = 1
+    HUNTER_COUNTERATTACK                        = 1312,  // TabId = 362, Tab = 2, Row = 4, Column = 2
+    HUNTER_LIGHTNING_REFLEXES                   = 1303,  // TabId = 362, Tab = 2, Row = 5, Column = 0
+    HUNTER_RESOURCEFULNESS                      = 1809,  // TabId = 362, Tab = 2, Row = 5, Column = 2
+    HUNTER_EXPOSE_WEAKNESS                      = 1812,  // TabId = 362, Tab = 2, Row = 6, Column = 0
+    HUNTER_WYVERN_STING                         = 1325,  // TabId = 362, Tab = 2, Row = 6, Column = 1
+    HUNTER_THRILL_OF_THE_HUNT                   = 1811,  // TabId = 362, Tab = 2, Row = 6, Column = 2
+    HUNTER_MASTER_TACTICIAN                     = 1813,  // TabId = 362, Tab = 2, Row = 7, Column = 0
+    HUNTER_NOXIOUS_STINGS                       = 2141,  // TabId = 362, Tab = 2, Row = 7, Column = 1
+    HUNTER_POINT_OF_NO_ESCAPE                   = 2142,  // TabId = 362, Tab = 2, Row = 8, Column = 0
+    HUNTER_BLACK_ARROW                          = 1322,  // TabId = 362, Tab = 2, Row = 8, Column = 1
+    HUNTER_SNIPER_TRAINING                      = 2143,  // TabId = 362, Tab = 2, Row = 8, Column = 3
+    HUNTER_HUNTING_PARTY                        = 2144,  // TabId = 362, Tab = 2, Row = 9, Column = 2
+    HUNTER_EXPLOSIVE_SHOT                       = 2145,  // TabId = 362, Tab = 2, Row = 10, Column = 1
+    HUNTER_IMPROVED_CONCUSSIVE_SHOT             = 1341,  // TabId = 363, Tab = 1, Row = 0, Column = 0
+    HUNTER_FOCUSED_AIM                          = 2197,  // TabId = 363, Tab = 1, Row = 0, Column = 1
+    HUNTER_LETHAL_SHOTS                         = 1344,  // TabId = 363, Tab = 1, Row = 0, Column = 2
+    HUNTER_CAREFUL_AIM                          = 1806,  // TabId = 363, Tab = 1, Row = 1, Column = 0
+    HUNTER_IMPROVED_HUNTERS_MARK                = 1343,  // TabId = 363, Tab = 1, Row = 1, Column = 1
+    HUNTER_MORTAL_SHOTS                         = 1349,  // TabId = 363, Tab = 1, Row = 1, Column = 2
+    HUNTER_GO_FOR_THE_THROAT                    = 1818,  // TabId = 363, Tab = 1, Row = 2, Column = 0
+    HUNTER_IMPROVED_ARCANE_SHOT                 = 1346,  // TabId = 363, Tab = 1, Row = 2, Column = 1
+    HUNTER_AIMED_SHOT                           = 1345,  // TabId = 363, Tab = 1, Row = 2, Column = 2
+    HUNTER_RAPID_KILLING                        = 1819,  // TabId = 363, Tab = 1, Row = 2, Column = 3
+    HUNTER_IMPROVED_STINGS                      = 1348,  // TabId = 363, Tab = 1, Row = 3, Column = 1
+    HUNTER_EFFICIENCY                           = 1342,  // TabId = 363, Tab = 1, Row = 3, Column = 2
+    HUNTER_CONCUSSIVE_BARRAGE                   = 1351,  // TabId = 363, Tab = 1, Row = 4, Column = 0
+    HUNTER_READINESS                            = 1353,  // TabId = 363, Tab = 1, Row = 4, Column = 1
+    HUNTER_BARRAGE                              = 1347,  // TabId = 363, Tab = 1, Row = 4, Column = 2
+    HUNTER_COMBAT_EXPERIENCE                    = 1804,  // TabId = 363, Tab = 1, Row = 5, Column = 0
+    HUNTER_RANGED_WEAPON_SPECIALIZATION         = 1362,  // TabId = 363, Tab = 1, Row = 5, Column = 3
+    HUNTER_PIERCING_SHOTS                       = 2130,  // TabId = 363, Tab = 1, Row = 6, Column = 0
+    HUNTER_TRUESHOT_AURA                        = 1361,  // TabId = 363, Tab = 1, Row = 6, Column = 1
+    HUNTER_IMPROVED_BARRAGE                     = 1821,  // TabId = 363, Tab = 1, Row = 6, Column = 2
+    HUNTER_MASTER_MARKSMAN                      = 1807,  // TabId = 363, Tab = 1, Row = 7, Column = 1
+    HUNTER_RAPID_RECUPERATION                   = 2131,  // TabId = 363, Tab = 1, Row = 7, Column = 2
+    HUNTER_WILD_QUIVER                          = 2132,  // TabId = 363, Tab = 1, Row = 8, Column = 0
+    HUNTER_SILENCING_SHOT                       = 1808,  // TabId = 363, Tab = 1, Row = 8, Column = 1
+    HUNTER_IMPROVED_STEADY_SHOT                 = 2133,  // TabId = 363, Tab = 1, Row = 8, Column = 2
+    HUNTER_MARKED_FOR_DEATH                     = 2134,  // TabId = 363, Tab = 1, Row = 9, Column = 1
+    HUNTER_CHIMERA_SHOT                         = 2135  // TabId = 363, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsMage  // 0x080
+{
+    MAGE_IMPROVED_FIRE_BLAST                    = 27,    // TabId = 41, Tab = 1, Row = 0, Column = 0
+    MAGE_INCINERATION                           = 1141,  // TabId = 41, Tab = 1, Row = 0, Column = 1
+    MAGE_IMPROVED_FIREBALL                      = 26,    // TabId = 41, Tab = 1, Row = 0, Column = 2
+    MAGE_IGNITE                                 = 34,    // TabId = 41, Tab = 1, Row = 1, Column = 0
+    MAGE_BURNING_DETERMINATION                  = 2212,  // TabId = 41, Tab = 1, Row = 1, Column = 1
+    MAGE_WORLD_IN_FLAMES                        = 31,    // TabId = 41, Tab = 1, Row = 1, Column = 2
+    MAGE_FLAME_THROWING                         = 28,    // TabId = 41, Tab = 1, Row = 2, Column = 0
+    MAGE_IMPACT                                 = 30,    // TabId = 41, Tab = 1, Row = 2, Column = 1
+    MAGE_PYROBLAST                              = 29,    // TabId = 41, Tab = 1, Row = 2, Column = 2
+    MAGE_BURNING_SOUL                           = 23,    // TabId = 41, Tab = 1, Row = 2, Column = 3
+    MAGE_IMPROVED_SCORCH                        = 25,    // TabId = 41, Tab = 1, Row = 3, Column = 0
+    MAGE_MOLTEN_SHIELDS                         = 24,    // TabId = 41, Tab = 1, Row = 3, Column = 1
+    MAGE_MASTER_OF_ELEMENTS                     = 1639,  // TabId = 41, Tab = 1, Row = 3, Column = 3
+    MAGE_PLAYING_WITH_FIRE                      = 1730,  // TabId = 41, Tab = 1, Row = 4, Column = 0
+    MAGE_CRITICAL_MASS                          = 33,    // TabId = 41, Tab = 1, Row = 4, Column = 1
+    MAGE_BLAST_WAVE                             = 32,    // TabId = 41, Tab = 1, Row = 4, Column = 2
+    MAGE_BLAZING_SPEED                          = 1731,  // TabId = 41, Tab = 1, Row = 5, Column = 0
+    MAGE_FIRE_POWER                             = 35,    // TabId = 41, Tab = 1, Row = 5, Column = 2
+    MAGE_PYROMANIAC                             = 1733,  // TabId = 41, Tab = 1, Row = 6, Column = 0
+    MAGE_COMBUSTION                             = 36,    // TabId = 41, Tab = 1, Row = 6, Column = 1
+    MAGE_MOLTEN_FURY                            = 1732,  // TabId = 41, Tab = 1, Row = 6, Column = 2
+    MAGE_FIERY_PAYBACK                          = 1848,  // TabId = 41, Tab = 1, Row = 7, Column = 0
+    MAGE_EMPOWERED_FIRE                         = 1734,  // TabId = 41, Tab = 1, Row = 7, Column = 2
+    MAGE_FIRESTARTER                            = 1849,  // TabId = 41, Tab = 1, Row = 8, Column = 0
+    MAGE_DRAGONS_BREATH                         = 1735,  // TabId = 41, Tab = 1, Row = 8, Column = 1
+    MAGE_HOT_STREAK                             = 1850,  // TabId = 41, Tab = 1, Row = 8, Column = 2
+    MAGE_BURNOUT                                = 1851,  // TabId = 41, Tab = 1, Row = 9, Column = 1
+    MAGE_LIVING_BOMB                            = 1852,  // TabId = 41, Tab = 1, Row = 10, Column = 1
+    MAGE_FROSTBITE                              = 38,    // TabId = 61, Tab = 2, Row = 0, Column = 0
+    MAGE_IMPROVED_FROSTBOLT                     = 37,    // TabId = 61, Tab = 2, Row = 0, Column = 1
+    MAGE_ICE_FLOES                              = 62,    // TabId = 61, Tab = 2, Row = 0, Column = 2
+    MAGE_ICE_SHARDS                             = 73,    // TabId = 61, Tab = 2, Row = 1, Column = 0
+    MAGE_FROST_WARDING                          = 70,    // TabId = 61, Tab = 2, Row = 1, Column = 1
+    MAGE_PRECISION                              = 1649,  // TabId = 61, Tab = 2, Row = 1, Column = 2
+    MAGE_PERMAFROST                             = 65,    // TabId = 61, Tab = 2, Row = 1, Column = 3
+    MAGE_PIERCING_ICE                           = 61,    // TabId = 61, Tab = 2, Row = 2, Column = 0
+    MAGE_ICY_VEINS                              = 69,    // TabId = 61, Tab = 2, Row = 2, Column = 1
+    MAGE_IMPROVED_BLIZZARD                      = 63,    // TabId = 61, Tab = 2, Row = 2, Column = 2
+    MAGE_ARCTIC_REACH                           = 741,   // TabId = 61, Tab = 2, Row = 3, Column = 0
+    MAGE_FROST_CHANNELING                       = 66,    // TabId = 61, Tab = 2, Row = 3, Column = 1
+    MAGE_SHATTER                                = 67,    // TabId = 61, Tab = 2, Row = 3, Column = 2
+    MAGE_COLD_SNAP                              = 72,    // TabId = 61, Tab = 2, Row = 4, Column = 1
+    MAGE_IMPROVED_CONE_OF_COLD                  = 64,    // TabId = 61, Tab = 2, Row = 4, Column = 2
+    MAGE_FROZEN_CORE                            = 1736,  // TabId = 61, Tab = 2, Row = 4, Column = 3
+    MAGE_COLD_AS_ICE                            = 1737,  // TabId = 61, Tab = 2, Row = 5, Column = 0
+    MAGE_WINTERS_CHILL                          = 68,    // TabId = 61, Tab = 2, Row = 5, Column = 2
+    MAGE_SHATTERED_BARRIER                      = 2214,  // TabId = 61, Tab = 2, Row = 6, Column = 0
+    MAGE_ICE_BARRIER                            = 71,    // TabId = 61, Tab = 2, Row = 6, Column = 1
+    MAGE_ARCTIC_WINDS                           = 1738,  // TabId = 61, Tab = 2, Row = 6, Column = 2
+    MAGE_EMPOWERED_FROSTBOLT                    = 1740,  // TabId = 61, Tab = 2, Row = 7, Column = 1
+    MAGE_FINGERS_OF_FROST                       = 1853,  // TabId = 61, Tab = 2, Row = 7, Column = 2
+    MAGE_BRAIN_FREEZE                           = 1854,  // TabId = 61, Tab = 2, Row = 8, Column = 0
+    MAGE_SUMMON_WATER_ELEMENTAL                 = 1741,  // TabId = 61, Tab = 2, Row = 8, Column = 1
+    MAGE_ENDURING_WINTER                        = 1855,  // TabId = 61, Tab = 2, Row = 8, Column = 2
+    MAGE_CHILLD_TO_THE_BONE                     = 1856,  // TabId = 61, Tab = 2, Row = 9, Column = 1
+    MAGE_DEEP_FREEZE                            = 1857,  // TabId = 61, Tab = 2, Row = 10, Column = 1
+    MAGE_ARCANE_SUBTLETY                        = 74,    // TabId = 81, Tab = 0, Row = 0, Column = 0
+    MAGE_ARCANE_FOCUS                           = 76,    // TabId = 81, Tab = 0, Row = 0, Column = 1
+    MAGE_ARCANE_STABILITY                       = 80,    // TabId = 81, Tab = 0, Row = 0, Column = 2
+    MAGE_ARCANE_FORTITUDE                       = 85,    // TabId = 81, Tab = 0, Row = 1, Column = 0
+    MAGE_MAGIC_ABSORPTION                       = 1650,  // TabId = 81, Tab = 0, Row = 1, Column = 1
+    MAGE_ARCANE_CONCENTRATION                   = 75,    // TabId = 81, Tab = 0, Row = 1, Column = 2
+    MAGE_MAGIC_ATTUNEMENT                       = 82,    // TabId = 81, Tab = 0, Row = 2, Column = 0
+    MAGE_SPELL_IMPACT                           = 81,    // TabId = 81, Tab = 0, Row = 2, Column = 1
+    MAGE_STUDENT_OF_THE_MIND                    = 1845,  // TabId = 81, Tab = 0, Row = 2, Column = 2
+    MAGE_FOCUS_MAGIC                            = 2211,  // TabId = 81, Tab = 0, Row = 2, Column = 3
+    MAGE_ARCANE_SHIELDING                       = 83,    // TabId = 81, Tab = 0, Row = 3, Column = 0
+    MAGE_IMPROVED_COUNTERSPELL                  = 88,    // TabId = 81, Tab = 0, Row = 3, Column = 1
+    MAGE_ARCANE_MEDITATION                      = 1142,  // TabId = 81, Tab = 0, Row = 3, Column = 2
+    MAGE_TORMENT_THE_WEAK                       = 2222,  // TabId = 81, Tab = 0, Row = 3, Column = 3
+    MAGE_IMPROVED_BLINK                         = 1724,  // TabId = 81, Tab = 0, Row = 4, Column = 0
+    MAGE_PRESENCE_OF_MIND                       = 86,    // TabId = 81, Tab = 0, Row = 4, Column = 1
+    MAGE_ARCANE_MIND                            = 77,    // TabId = 81, Tab = 0, Row = 4, Column = 3
+    MAGE_PRISMATIC_CLOAK                        = 1726,  // TabId = 81, Tab = 0, Row = 5, Column = 0
+    MAGE_ARCANE_INSTABILITY                     = 421,   // TabId = 81, Tab = 0, Row = 5, Column = 1
+    MAGE_ARCANE_POTENCY                         = 1725,  // TabId = 81, Tab = 0, Row = 5, Column = 2
+    MAGE_ARCANE_EMPOWERMENT                     = 1727,  // TabId = 81, Tab = 0, Row = 6, Column = 0
+    MAGE_ARCANE_POWER                           = 87,    // TabId = 81, Tab = 0, Row = 6, Column = 1
+    MAGE_INCANTERS_ABSORPTION                   = 1844,  // TabId = 81, Tab = 0, Row = 6, Column = 2
+    MAGE_ARCANE_FLOWS                           = 1843,  // TabId = 81, Tab = 0, Row = 7, Column = 1
+    MAGE_MIND_MASTERY                           = 1728,  // TabId = 81, Tab = 0, Row = 7, Column = 2
+    MAGE_SLOW                                   = 1729,  // TabId = 81, Tab = 0, Row = 8, Column = 1
+    MAGE_MISSILE_BARRAGE                        = 2209,  // TabId = 81, Tab = 0, Row = 8, Column = 2
+    MAGE_NETHERWIND_PRESENCE                    = 1846,  // TabId = 81, Tab = 0, Row = 9, Column = 1
+    MAGE_SPELL_POWER                            = 1826,  // TabId = 81, Tab = 0, Row = 9, Column = 2
+    MAGE_ARCANE_BARRAGE                         = 1847  // TabId = 81, Tab = 0, Row = 10, Column = 1
+};
+
+enum TalentsPaladin  // 0x002
+{
+    PALADIN_DEFLECTION                          = 1403,  // TabId = 381, Tab = 2, Row = 0, Column = 1
+    PALADIN_BENEDICTION                         = 1407,  // TabId = 381, Tab = 2, Row = 0, Column = 2
+    PALADIN_IMPROVED_JUDGEMENTS                 = 1631,  // TabId = 381, Tab = 2, Row = 1, Column = 0
+    PALADIN_HEART_OF_THE_CRUSADER               = 1464,  // TabId = 381, Tab = 2, Row = 1, Column = 1
+    PALADIN_IMPROVED_BLESSING_OF_MIGHT          = 1401,  // TabId = 381, Tab = 2, Row = 1, Column = 2
+    PALADIN_VINDICATION                         = 1633,  // TabId = 381, Tab = 2, Row = 2, Column = 0
+    PALADIN_CONVICTION                          = 1411,  // TabId = 381, Tab = 2, Row = 2, Column = 1
+    PALADIN_SEAL_OF_COMMAND                     = 1481,  // TabId = 381, Tab = 2, Row = 2, Column = 2
+    PALADIN_PURSUIT_OF_JUSTICE                  = 1634,  // TabId = 381, Tab = 2, Row = 2, Column = 3
+    PALADIN_EYE_FOR_AN_EYE                      = 1632,  // TabId = 381, Tab = 2, Row = 3, Column = 0
+    PALADIN_SANCTITY_OF_BATTLE                  = 1761,  // TabId = 381, Tab = 2, Row = 3, Column = 2
+    PALADIN_CRUSADE                             = 1755,  // TabId = 381, Tab = 2, Row = 3, Column = 3
+    PALADIN_TWOHANDED_WEAPON_SPECIALIZATION     = 1410,  // TabId = 381, Tab = 2, Row = 4, Column = 0
+    PALADIN_SANCTIFIED_RETRIBUTION              = 1756,  // TabId = 381, Tab = 2, Row = 4, Column = 2
+    PALADIN_VENGEANCE                           = 1402,  // TabId = 381, Tab = 2, Row = 5, Column = 1
+    PALADIN_DIVINE_PURPOSE                      = 1757,  // TabId = 381, Tab = 2, Row = 5, Column = 2
+    PALADIN_THE_ART_OF_WAR                      = 2176,  // TabId = 381, Tab = 2, Row = 6, Column = 0
+    PALADIN_REPENTANCE                          = 1441,  // TabId = 381, Tab = 2, Row = 6, Column = 1
+    PALADIN_JUDGEMENTS_OF_THE_WISE              = 1758,  // TabId = 381, Tab = 2, Row = 6, Column = 2
+    PALADIN_FANATICISM                          = 1759,  // TabId = 381, Tab = 2, Row = 7, Column = 1
+    PALADIN_SANCTIFIED_WRATH                    = 2147,  // TabId = 381, Tab = 2, Row = 7, Column = 2
+    PALADIN_SWIFT_RETRIBUTION                   = 2148,  // TabId = 381, Tab = 2, Row = 8, Column = 0
+    PALADIN_CRUSADER_STRIKE                     = 1823,  // TabId = 381, Tab = 2, Row = 8, Column = 1
+    PALADIN_SHEATH_OF_LIGHT                     = 2179,  // TabId = 381, Tab = 2, Row = 8, Column = 2
+    PALADIN_RIGHTEOUS_VENGEANCE                 = 2149,  // TabId = 381, Tab = 2, Row = 9, Column = 1
+    PALADIN_DIVINE_STORM                        = 2150,  // TabId = 381, Tab = 2, Row = 10, Column = 1
+    PALADIN_SPIRITUAL_FOCUS                     = 1432,  // TabId = 382, Tab = 0, Row = 0, Column = 1
+    PALADIN_SEALS_OF_THE_PURE                   = 1463,  // TabId = 382, Tab = 0, Row = 0, Column = 2
+    PALADIN_HEALING_LIGHT                       = 1444,  // TabId = 382, Tab = 0, Row = 1, Column = 0
+    PALADIN_DIVINE_INTELLECT                    = 1449,  // TabId = 382, Tab = 0, Row = 1, Column = 1
+    PALADIN_UNYIELDING_FAITH                    = 1628,  // TabId = 382, Tab = 0, Row = 1, Column = 2
+    PALADIN_AURA_MASTERY                        = 1435,  // TabId = 382, Tab = 0, Row = 2, Column = 0
+    PALADIN_ILLUMINATION                        = 1461,  // TabId = 382, Tab = 0, Row = 2, Column = 1
+    PALADIN_IMPROVED_LAY_ON_HANDS               = 1443,  // TabId = 382, Tab = 0, Row = 2, Column = 2
+    PALADIN_IMPROVED_CONCENTRATION_AURA         = 1450,  // TabId = 382, Tab = 0, Row = 3, Column = 0
+    PALADIN_IMPROVED_BLESSING_OF_WISDOM         = 1446,  // TabId = 382, Tab = 0, Row = 3, Column = 2
+    PALADIN_BLESSED_HANDS                       = 2198,  // TabId = 382, Tab = 0, Row = 3, Column = 3
+    PALADIN_PURE_OF_HEART                       = 1742,  // TabId = 382, Tab = 0, Row = 4, Column = 0
+    PALADIN_DIVINE_FAVOR                        = 1433,  // TabId = 382, Tab = 0, Row = 4, Column = 1
+    PALADIN_SANCTIFIED_LIGHT                    = 1465,  // TabId = 382, Tab = 0, Row = 4, Column = 2
+    PALADIN_PURIFYING_POWER                     = 1743,  // TabId = 382, Tab = 0, Row = 5, Column = 0
+    PALADIN_HOLY_POWER                          = 1627,  // TabId = 382, Tab = 0, Row = 5, Column = 2
+    PALADIN_LIGHTS_GRACE                        = 1745,  // TabId = 382, Tab = 0, Row = 6, Column = 0
+    PALADIN_HOLY_SHOCK                          = 1502,  // TabId = 382, Tab = 0, Row = 6, Column = 1
+    PALADIN_BLESSED_LIFE                        = 1744,  // TabId = 382, Tab = 0, Row = 6, Column = 2
+    PALADIN_SACRED_CLEANSING                    = 2190,  // TabId = 382, Tab = 0, Row = 7, Column = 0
+    PALADIN_HOLY_GUIDANCE                       = 1746,  // TabId = 382, Tab = 0, Row = 7, Column = 2
+    PALADIN_DIVINE_ILLUMINATION                 = 1747,  // TabId = 382, Tab = 0, Row = 8, Column = 0
+    PALADIN_JUDGEMENTS_OF_THE_PURE              = 2199,  // TabId = 382, Tab = 0, Row = 8, Column = 2
+    PALADIN_INFUSION_OF_LIGHT                   = 2193,  // TabId = 382, Tab = 0, Row = 9, Column = 1
+    PALADIN_ENLIGHTENED_JUDGEMENTS              = 2191,  // TabId = 382, Tab = 0, Row = 9, Column = 2
+    PALADIN_BEACON_OF_LIGHT                     = 2192,  // TabId = 382, Tab = 0, Row = 10, Column = 1
+    PALADIN_DIVINITY                            = 1442,  // TabId = 383, Tab = 1, Row = 0, Column = 1
+    PALADIN_DIVINE_STRENGTH                     = 2185,  // TabId = 383, Tab = 1, Row = 0, Column = 2
+    PALADIN_STOICISM                            = 1748,  // TabId = 383, Tab = 1, Row = 1, Column = 0
+    PALADIN_GUARDIANS_FAVOR                     = 1425,  // TabId = 383, Tab = 1, Row = 1, Column = 1
+    PALADIN_ANTICIPATION                        = 1629,  // TabId = 383, Tab = 1, Row = 1, Column = 2
+    PALADIN_DIVINE_SACRIFICE                    = 2280,  // TabId = 383, Tab = 1, Row = 2, Column = 0
+    PALADIN_IMPROVED_RIGHTEOUS_FURY             = 1501,  // TabId = 383, Tab = 1, Row = 2, Column = 1
+    PALADIN_TOUGHNESS                           = 1423,  // TabId = 383, Tab = 1, Row = 2, Column = 2
+    PALADIN_DIVINE_GUARDIAN                     = 2281,  // TabId = 383, Tab = 1, Row = 3, Column = 0
+    PALADIN_IMPROVED_HAMMER_OF_JUSTICE          = 1521,  // TabId = 383, Tab = 1, Row = 3, Column = 1
+    PALADIN_IMPROVED_DEVOTION_AURA              = 1422,  // TabId = 383, Tab = 1, Row = 3, Column = 2
+    PALADIN_BLESSING_OF_SANCTUARY               = 1431,  // TabId = 383, Tab = 1, Row = 4, Column = 1
+    PALADIN_RECKONING                           = 1426,  // TabId = 383, Tab = 1, Row = 4, Column = 2
+    PALADIN_SACRED_DUTY                         = 1750,  // TabId = 383, Tab = 1, Row = 5, Column = 0
+    PALADIN_ONEHANDED_WEAPON_SPECIALIZATION     = 1429,  // TabId = 383, Tab = 1, Row = 5, Column = 2
+    PALADIN_SPIRITUAL_ATTUNEMENT                = 2282,  // TabId = 383, Tab = 1, Row = 6, Column = 0
+    PALADIN_HOLY_SHIELD                         = 1430,  // TabId = 383, Tab = 1, Row = 6, Column = 1
+    PALADIN_ARDENT_DEFENDER                     = 1751,  // TabId = 383, Tab = 1, Row = 6, Column = 2
+    PALADIN_REDOUBT                             = 1421,  // TabId = 383, Tab = 1, Row = 7, Column = 0
+    PALADIN_COMBAT_EXPERTISE                    = 1753,  // TabId = 383, Tab = 1, Row = 7, Column = 2
+    PALADIN_TOUCHER_BY_THE_LIGHT                = 2195,  // TabId = 383, Tab = 1, Row = 8, Column = 0
+    PALADIN_AVENGERS_SHIELD                     = 1754,  // TabId = 383, Tab = 1, Row = 8, Column = 1
+    PALADIN_GUARDED_BY_THE_LIGHT                = 2194,  // TabId = 383, Tab = 1, Row = 8, Column = 2
+    PALADIN_SHIELD_OF_THE_TEMPLAR               = 2204,  // TabId = 383, Tab = 1, Row = 9, Column = 1
+    PALADIN_JUDGEMENT_OF_THE_JUST               = 2200,  // TabId = 383, Tab = 1, Row = 9, Column = 2
+    PALADIN_HAMMER_OF_THE_RIGHTEOUS             = 2196   // TabId = 383, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsPriest  // 0x010
+{
+    PRIEST_UNBREAKABLE_WILL                     = 342,   // TabId = 201, Tab = 0, Row = 0, Column = 1
+    PRIEST_TWIN_DISCIPLINES                     = 1898,  // TabId = 201, Tab = 0, Row = 0, Column = 2
+    PRIEST_SILENT_RESOLVE                       = 352,   // TabId = 201, Tab = 0, Row = 1, Column = 0
+    PRIEST_IMPROVED_INNER_FIRE                  = 346,   // TabId = 201, Tab = 0, Row = 1, Column = 1
+    PRIEST_IMPROVED_POWER_WORD_FORTITUDE        = 344,   // TabId = 201, Tab = 0, Row = 1, Column = 2
+    PRIEST_MARTYRDOM                            = 321,   // TabId = 201, Tab = 0, Row = 1, Column = 3
+    PRIEST_MEDITATION                           = 347,   // TabId = 201, Tab = 0, Row = 2, Column = 0
+    PRIEST_INNER_FOCUS                          = 348,   // TabId = 201, Tab = 0, Row = 2, Column = 1
+    PRIEST_IMPROVED_POWER_WORD_SHIELD           = 343,   // TabId = 201, Tab = 0, Row = 2, Column = 2
+    PRIEST_ABSOLUTION                           = 1769,  // TabId = 201, Tab = 0, Row = 3, Column = 0
+    PRIEST_MENTAL_AGILITY                       = 341,   // TabId = 201, Tab = 0, Row = 3, Column = 1
+    PRIEST_IMPROVED_MANA_BURN                   = 350,   // TabId = 201, Tab = 0, Row = 3, Column = 3
+    PRIEST_REFLECTIVE_SHIELD                    = 2268,  // TabId = 201, Tab = 0, Row = 4, Column = 0
+    PRIEST_MENTAL_STRENGTH                      = 1201,  // TabId = 201, Tab = 0, Row = 4, Column = 1
+    PRIEST_SOUL_WARDING                         = 351,   // TabId = 201, Tab = 0, Row = 4, Column = 2
+    PRIEST_FOCUSED_POWER                        = 1771,  // TabId = 201, Tab = 0, Row = 5, Column = 0
+    PRIEST_ENLIGHTENMENT                        = 1772,  // TabId = 201, Tab = 0, Row = 5, Column = 2
+    PRIEST_FOCUSED_WILL                         = 1858,  // TabId = 201, Tab = 0, Row = 6, Column = 0
+    PRIEST_POWER_INFUSION                       = 322,   // TabId = 201, Tab = 0, Row = 6, Column = 1
+    PRIEST_IMPROVED_FLASH_HEAL                  = 1773,  // TabId = 201, Tab = 0, Row = 6, Column = 2
+    PRIEST_RENEWED_HOPE                         = 2235,  // TabId = 201, Tab = 0, Row = 7, Column = 0
+    PRIEST_RAPTURE                              = 1896,  // TabId = 201, Tab = 0, Row = 7, Column = 1
+    PRIEST_ASPIRATION                           = 1894,  // TabId = 201, Tab = 0, Row = 7, Column = 2
+    PRIEST_DIVINE_AEGIS                         = 1895,  // TabId = 201, Tab = 0, Row = 8, Column = 0
+    PRIEST_PAIN_SUPPRESSION                     = 1774,  // TabId = 201, Tab = 0, Row = 8, Column = 1
+    PRIEST_GRACE                                = 1901,  // TabId = 201, Tab = 0, Row = 8, Column = 2
+    PRIEST_BORROWED_TIME                        = 1202,  // TabId = 201, Tab = 0, Row = 9, Column = 1
+    PRIEST_PENANCE                              = 1897,  // TabId = 201, Tab = 0, Row = 10, Column = 1
+    PRIEST_HEALING_FOCUS                        = 410,   // TabId = 202, Tab = 1, Row = 0, Column = 0
+    PRIEST_IMPROVED_RENEW                       = 406,   // TabId = 202, Tab = 1, Row = 0, Column = 1
+    PRIEST_HOLY_SPECIALIZATION                  = 401,   // TabId = 202, Tab = 1, Row = 0, Column = 2
+    PRIEST_SPELL_WARDING                        = 411,   // TabId = 202, Tab = 1, Row = 1, Column = 1
+    PRIEST_DIVINE_FURY                          = 1181,  // TabId = 202, Tab = 1, Row = 1, Column = 2
+    PRIEST_DESPERATE_PRAYER                     = 442,   // TabId = 202, Tab = 1, Row = 2, Column = 0
+    PRIEST_BLESSED_RECOVERY                     = 1636,  // TabId = 202, Tab = 1, Row = 2, Column = 1
+    PRIEST_INSPIRATION                          = 361,   // TabId = 202, Tab = 1, Row = 2, Column = 3
+    PRIEST_HOLY_REACH                           = 1635,  // TabId = 202, Tab = 1, Row = 3, Column = 0
+    PRIEST_IMPROVED_HEALIN                      = 408,   // TabId = 202, Tab = 1, Row = 3, Column = 1
+    PRIEST_SEARING_LIGHT                        = 403,   // TabId = 202, Tab = 1, Row = 3, Column = 2
+    PRIEST_HEALING_PRAYERS                      = 413,   // TabId = 202, Tab = 1, Row = 4, Column = 0
+    PRIEST_SPIRIT_OF_REDEMPTION                 = 1561,  // TabId = 202, Tab = 1, Row = 4, Column = 1
+    PRIEST_SPIRITUAL_GUIDANCE                   = 402,   // TabId = 202, Tab = 1, Row = 4, Column = 2
+    PRIEST_SURGE_OF_LIGHT                       = 1766,  // TabId = 202, Tab = 1, Row = 5, Column = 0
+    PRIEST_SPIRITUAL_HEALING                    = 404,   // TabId = 202, Tab = 1, Row = 5, Column = 2
+    PRIEST_HOLY_CONCENTRATION                   = 1768,  // TabId = 202, Tab = 1, Row = 6, Column = 0
+    PRIEST_LIGHTWELL                            = 1637,  // TabId = 202, Tab = 1, Row = 6, Column = 1
+    PRIEST_BLESSED_RESILIENCE                   = 1765,  // TabId = 202, Tab = 1, Row = 6, Column = 2
+    PRIEST_BODY_AND_SOUL                        = 2279,  // TabId = 202, Tab = 1, Row = 7, Column = 0
+    PRIEST_EMPOWERED_HEALING                    = 1767,  // TabId = 202, Tab = 1, Row = 7, Column = 1
+    PRIEST_SERENDIPITY                          = 1904,  // TabId = 202, Tab = 1, Row = 7, Column = 2
+    PRIEST_EMPOWERED_RENEW                      = 1902,  // TabId = 202, Tab = 1, Row = 8, Column = 0
+    PRIEST_CIRCLE_OF_HEALING                    = 1815,  // TabId = 202, Tab = 1, Row = 8, Column = 1
+    PRIEST_TEST_OF_FAITH                        = 1903,  // TabId = 202, Tab = 1, Row = 8, Column = 2
+    PRIEST_DIVINE_PROVIDENCE                    = 1905,  // TabId = 202, Tab = 1, Row = 9, Column = 1
+    PRIEST_GUARDIAN_SPIRIT                      = 1911,  // TabId = 202, Tab = 1, Row = 10, Column = 1
+    PRIEST_SPIRIT_TAP                           = 465,   // TabId = 203, Tab = 2, Row = 0, Column = 0
+    PRIEST_IMPROVED_SPIRIT_TAP                  = 2027,  // TabId = 203, Tab = 2, Row = 0, Column = 1
+    PRIEST_DARKNESS                             = 462,   // TabId = 203, Tab = 2, Row = 0, Column = 2
+    PRIEST_SHADOW_AFFINITY                      = 466,   // TabId = 203, Tab = 2, Row = 1, Column = 0
+    PRIEST_IMPROVED_SHADOW_WORD_PAIN            = 482,   // TabId = 203, Tab = 2, Row = 1, Column = 1
+    PRIEST_SHADOW_FOCUS                         = 463,   // TabId = 203, Tab = 2, Row = 1, Column = 2
+    PRIEST_IMPROVED_PSYCHIC_SCREAM              = 542,   // TabId = 203, Tab = 2, Row = 2, Column = 0
+    PRIEST_IMPROVED_MIND_BLAST                  = 481,   // TabId = 203, Tab = 2, Row = 2, Column = 1
+    PRIEST_MIND_FLAY                            = 501,   // TabId = 203, Tab = 2, Row = 2, Column = 2
+    PRIEST_VEILED_SHADOWS                       = 483,   // TabId = 203, Tab = 2, Row = 3, Column = 1
+    PRIEST_SHADOW_REACH                         = 881,   // TabId = 203, Tab = 2, Row = 3, Column = 2
+    PRIEST_SHADOW_WEAVING                       = 461,   // TabId = 203, Tab = 2, Row = 3, Column = 3
+    PRIEST_SILENCE                              = 541,   // TabId = 203, Tab = 2, Row = 4, Column = 0
+    PRIEST_VAMPIRIC_EMBRACE                     = 484,   // TabId = 203, Tab = 2, Row = 4, Column = 1
+    PRIEST_IMPROVED_VAMPIRIC_EMBRACE            = 1638,  // TabId = 203, Tab = 2, Row = 4, Column = 2
+    PRIEST_FOCUSED_MIND                         = 1777,  // TabId = 203, Tab = 2, Row = 4, Column = 3
+    PRIEST_MIND_MELT                            = 1781,  // TabId = 203, Tab = 2, Row = 5, Column = 0
+    PRIEST_IMPROVED_DEVOURING_PLAGUE            = 2267,  // TabId = 203, Tab = 2, Row = 5, Column = 2
+    PRIEST_SHADOWFORM                           = 521,   // TabId = 203, Tab = 2, Row = 6, Column = 1
+    PRIEST_SHADOW_POWER                         = 1778,  // TabId = 203, Tab = 2, Row = 6, Column = 2
+    PRIEST_IMPROVED_SHADOWFORM                  = 1906,  // TabId = 203, Tab = 2, Row = 7, Column = 0
+    PRIEST_MISERY                               = 1816,  // TabId = 203, Tab = 2, Row = 7, Column = 2
+    PRIEST_PSYCHIC_HORROR                       = 1908,  // TabId = 203, Tab = 2, Row = 8, Column = 0
+    PRIEST_VAMPIRIC_TOUCH                       = 1779,  // TabId = 203, Tab = 2, Row = 8, Column = 1
+    PRIEST_PAIN_AND_SUFFERING                   = 1909,  // TabId = 203, Tab = 2, Row = 8, Column = 2
+    PRIEST_TWISTED_FAITH                        = 1907,  // TabId = 203, Tab = 2, Row = 9, Column = 2
+    PRIEST_DISPERSION                           = 1910   // TabId = 203, Tab = 2, Row = 10, Column = 1
+};
+
+enum TalentsRogue  // 0x008
+{
+    ROGUE_IMPROVED_GOUGE                        = 203,   // TabId = 181, Tab = 1, Row = 0, Column = 0
+    ROGUE_IMPROVED_SINISTER_STRIKE              = 201,   // TabId = 181, Tab = 1, Row = 0, Column = 1
+    ROGUE_DUAL_WIELD_SPECIALIZATION             = 221,   // TabId = 181, Tab = 1, Row = 0, Column = 2
+    ROGUE_IMPROVED_SLICE_AND_DICE               = 1827,  // TabId = 181, Tab = 1, Row = 1, Column = 0
+    ROGUE_DEFLECTION                            = 187,   // TabId = 181, Tab = 1, Row = 1, Column = 1
+    ROGUE_PRECISION                             = 181,   // TabId = 181, Tab = 1, Row = 1, Column = 3
+    ROGUE_ENDURANCE                             = 204,   // TabId = 181, Tab = 1, Row = 2, Column = 0
+    ROGUE_RIPOSTE                               = 301,   // TabId = 181, Tab = 1, Row = 2, Column = 1
+    ROGUE_CLOSE_QUARTERS_COMBAT                 = 182,   // TabId = 181, Tab = 1, Row = 2, Column = 2
+    ROGUE_IMPROVED_KICK                         = 206,   // TabId = 181, Tab = 1, Row = 3, Column = 0
+    ROGUE_IMPROVED_SPRINT                       = 222,   // TabId = 181, Tab = 1, Row = 3, Column = 1
+    ROGUE_LIGHTNING_REFLEXES                    = 186,   // TabId = 181, Tab = 1, Row = 3, Column = 2
+    ROGUE_AGGRESSION                            = 1122,  // TabId = 181, Tab = 1, Row = 3, Column = 3
+    ROGUE_MACE_SPECIALIZATION                   = 184,   // TabId = 181, Tab = 1, Row = 4, Column = 0
+    ROGUE_BLADE_FLURRY                          = 223,   // TabId = 181, Tab = 1, Row = 4, Column = 1
+    ROGUE_HACK_AND_SLASH                        = 242,   // TabId = 181, Tab = 1, Row = 4, Column = 2
+    ROGUE_WEAPON_EXPERTISE                      = 1703,  // TabId = 181, Tab = 1, Row = 5, Column = 1
+    ROGUE_BLADE_TWISTING                        = 1706,  // TabId = 181, Tab = 1, Row = 5, Column = 2
+    ROGUE_VITALITY                              = 1705,  // TabId = 181, Tab = 1, Row = 6, Column = 0
+    ROGUE_ADRENALINE_RUSH                       = 205,   // TabId = 181, Tab = 1, Row = 6, Column = 1
+    ROGUE_NERVES_OF_STEEL                       = 1707,  // TabId = 181, Tab = 1, Row = 6, Column = 2
+    ROGUE_THROWING_SPECIALIZATION               = 2072,  // TabId = 181, Tab = 1, Row = 7, Column = 0
+    ROGUE_COMBAT_POTENCY                        = 1825,  // TabId = 181, Tab = 1, Row = 7, Column = 2
+    ROGUE_UNFAIR_ADVANTAGE                      = 2073,  // TabId = 181, Tab = 1, Row = 8, Column = 0
+    ROGUE_SURPRISE_ATTACKS                      = 1709,  // TabId = 181, Tab = 1, Row = 8, Column = 1
+    ROGUE_SAVAGE_COMBAT                         = 2074,  // TabId = 181, Tab = 1, Row = 8, Column = 2
+    ROGUE_PREY_ON_THE_WEAK                      = 2075,  // TabId = 181, Tab = 1, Row = 9, Column = 1
+    ROGUE_KILLING_SPREE                         = 2076,  // TabId = 181, Tab = 1, Row = 10, Column = 1
+    ROGUE_IMPROVED_EVISCERATE                   = 276,   // TabId = 182, Tab = 0, Row = 0, Column = 0
+    ROGUE_REMORSELESS_ATTACKS                   = 272,   // TabId = 182, Tab = 0, Row = 0, Column = 1
+    ROGUE_MALICE                                = 270,   // TabId = 182, Tab = 0, Row = 0, Column = 2
+    ROGUE_RUTHLESSNESS                          = 273,   // TabId = 182, Tab = 0, Row = 1, Column = 0
+    ROGUE_BLOOD_SPATTER                         = 2068,  // TabId = 182, Tab = 0, Row = 1, Column = 1
+    ROGUE_PUNCTURING_WOUNDS                     = 277,   // TabId = 182, Tab = 0, Row = 1, Column = 3
+    ROGUE_VIGOR                                 = 382,   // TabId = 182, Tab = 0, Row = 2, Column = 0
+    ROGUE_IMPROVED_EXPOSE_ARMOR                 = 278,   // TabId = 182, Tab = 0, Row = 2, Column = 1
+    ROGUE_LETHALITY                             = 269,   // TabId = 182, Tab = 0, Row = 2, Column = 2
+    ROGUE_VILE_POISONS                          = 682,   // TabId = 182, Tab = 0, Row = 3, Column = 1
+    ROGUE_IMPROVED_POISONS                      = 268,   // TabId = 182, Tab = 0, Row = 3, Column = 2
+    ROGUE_FLEET_FOOTED                          = 1721,  // TabId = 182, Tab = 0, Row = 4, Column = 0
+    ROGUE_COLD_BLOOD                            = 280,   // TabId = 182, Tab = 0, Row = 4, Column = 1
+    ROGUE_IMPROVED_KIDNEY_SHOT                  = 279,   // TabId = 182, Tab = 0, Row = 4, Column = 2
+    ROGUE_QUICK_RECOVERY                        = 1762,  // TabId = 182, Tab = 0, Row = 4, Column = 3
+    ROGUE_SEAL_FATE                             = 283,   // TabId = 182, Tab = 0, Row = 5, Column = 1
+    ROGUE_MURDER                                = 274,   // TabId = 182, Tab = 0, Row = 5, Column = 2
+    ROGUE_DEADLY_BREW                           = 2065,  // TabId = 182, Tab = 0, Row = 6, Column = 0
+    ROGUE_OVERKILL                              = 281,   // TabId = 182, Tab = 0, Row = 6, Column = 1
+    ROGUE_DEADENED_NERVES                       = 1723,  // TabId = 182, Tab = 0, Row = 6, Column = 2
+    ROGUE_FOCUSED_ATTACKS                       = 2069,  // TabId = 182, Tab = 0, Row = 7, Column = 0
+    ROGUE_FIND_WEAKNESS                         = 1718,  // TabId = 182, Tab = 0, Row = 7, Column = 2
+    ROGUE_MASTER_POISONER                       = 1715,  // TabId = 182, Tab = 0, Row = 8, Column = 0
+    ROGUE_MUTILATE                              = 1719,  // TabId = 182, Tab = 0, Row = 8, Column = 1
+    ROGUE_TURN_THE_TABLES                       = 2066,  // TabId = 182, Tab = 0, Row = 8, Column = 2
+    ROGUE_CUT_TO_THE_CHASE                      = 2070,  // TabId = 182, Tab = 0, Row = 9, Column = 1
+    ROGUE_HUNGER_FOR_BLOOD                      = 2071,  // TabId = 182, Tab = 0, Row = 10, Column = 1
+    ROGUE_RELENTLESS_STRIKES                    = 2244,  // TabId = 183, Tab = 2, Row = 0, Column = 0
+    ROGUE_MASTER_OF_DECEPTION                   = 241,   // TabId = 183, Tab = 2, Row = 0, Column = 1
+    ROGUE_OPPORTUNITY                           = 261,   // TabId = 183, Tab = 2, Row = 0, Column = 2
+    ROGUE_SLEIGHT_OF_HAND                       = 1700,  // TabId = 183, Tab = 2, Row = 1, Column = 0
+    ROGUE_DIRTY_TRICKS                          = 262,   // TabId = 183, Tab = 2, Row = 1, Column = 1
+    ROGUE_CAMOUFLAGE                            = 244,   // TabId = 183, Tab = 2, Row = 1, Column = 2
+    ROGUE_ELUSIVENESS                           = 247,   // TabId = 183, Tab = 2, Row = 2, Column = 0
+    ROGUE_GHOSTLY_STRIKE                        = 303,   // TabId = 183, Tab = 2, Row = 2, Column = 1
+    ROGUE_SERRATED_BLADES                       = 1123,  // TabId = 183, Tab = 2, Row = 2, Column = 2
+    ROGUE_SETUP                                 = 246,   // TabId = 183, Tab = 2, Row = 3, Column = 0
+    ROGUE_INITIATIVE                            = 245,   // TabId = 183, Tab = 2, Row = 3, Column = 1
+    ROGUE_IMPROVED_AMBUSH                       = 263,   // TabId = 183, Tab = 2, Row = 3, Column = 2
+    ROGUE_HEIGHTENED_SENSES                     = 1701,  // TabId = 183, Tab = 2, Row = 4, Column = 0
+    ROGUE_PREPARATION                           = 284,   // TabId = 183, Tab = 2, Row = 4, Column = 1
+    ROGUE_DIRTY_DEEDS                           = 265,   // TabId = 183, Tab = 2, Row = 4, Column = 2
+    ROGUE_HEMORRHAGE                            = 681,   // TabId = 183, Tab = 2, Row = 4, Column = 3
+    ROGUE_MASTER_OF_SUBTLETY                    = 1713,  // TabId = 183, Tab = 2, Row = 5, Column = 0
+    ROGUE_DEADLINESS                            = 1702,  // TabId = 183, Tab = 2, Row = 5, Column = 2
+    ROGUE_ENVELOPING_SHADOWS                    = 1711,  // TabId = 183, Tab = 2, Row = 6, Column = 0
+    ROGUE_PREMEDITATION                         = 381,   // TabId = 183, Tab = 2, Row = 6, Column = 1
+    ROGUE_CHEAT_DEATH                           = 1722,  // TabId = 183, Tab = 2, Row = 6, Column = 2
+    ROGUE_SINISTER_CALLING                      = 1712,  // TabId = 183, Tab = 2, Row = 7, Column = 1
+    ROGUE_WAYLAY                                = 2077,  // TabId = 183, Tab = 2, Row = 7, Column = 2
+    ROGUE_HONOR_AMONG_THIEVES                   = 2078,  // TabId = 183, Tab = 2, Row = 8, Column = 0
+    ROGUE_SHADOWSTEP                            = 1714,  // TabId = 183, Tab = 2, Row = 8, Column = 1
+    ROGUE_FILTHY_TRICKS                         = 2079,  // TabId = 183, Tab = 2, Row = 8, Column = 2
+    ROGUE_SLAUGHTER_FROM_THE_SHADOWS            = 2080,  // TabId = 183, Tab = 2, Row = 9, Column = 1
+    ROGUE_SHADOW_DANCE                          = 2081   // TabId = 183, Tab = 2, Row = 10, Column = 1
+};
+
+enum TalentsShaman  // 0x040
+{
+    SHAMAN_CONVECTION                           = 564,   // TabId = 261, Tab = 0, Row = 0, Column = 1
+    SHAMAN_CONCUSSION                           = 563,   // TabId = 261, Tab = 0, Row = 0, Column = 2
+    SHAMAN_CALL_OF_FLAME                        = 561,   // TabId = 261, Tab = 0, Row = 1, Column = 0
+    SHAMAN_ELEMENTAL_WARDING                    = 1640,  // TabId = 261, Tab = 0, Row = 1, Column = 1
+    SHAMAN_ELEMENTAL_DEVASTATION                = 1645,  // TabId = 261, Tab = 0, Row = 1, Column = 2
+    SHAMAN_REVERBERATION                        = 575,   // TabId = 261, Tab = 0, Row = 2, Column = 0
+    SHAMAN_ELEMENTAL_FOCUS                      = 574,   // TabId = 261, Tab = 0, Row = 2, Column = 1
+    SHAMAN_ELEMENTAL_FURY                       = 565,   // TabId = 261, Tab = 0, Row = 2, Column = 2
+    SHAMAN_IMPROVED_FIRE_NOVA                   = 567,   // TabId = 261, Tab = 0, Row = 3, Column = 0
+    SHAMAN_EYE_OF_THE_STORM                     = 1642,  // TabId = 261, Tab = 0, Row = 3, Column = 3
+    SHAMAN_ELEMENTAL_REACH                      = 1641,  // TabId = 261, Tab = 0, Row = 4, Column = 0
+    SHAMAN_CALL_OF_THUNDER                      = 562,   // TabId = 261, Tab = 0, Row = 4, Column = 1
+    SHAMAN_UNRELENTING_STORM                    = 1682,  // TabId = 261, Tab = 0, Row = 4, Column = 3
+    SHAMAN_ELEMENTAL_PRECISION                  = 1685,  // TabId = 261, Tab = 0, Row = 5, Column = 0
+    SHAMAN_LIGHTNING_MASTERY                    = 721,   // TabId = 261, Tab = 0, Row = 5, Column = 2
+    SHAMAN_ELEMENTAL_MASTERY                    = 573,   // TabId = 261, Tab = 0, Row = 6, Column = 1
+    SHAMAN_STORM_EARTH_AND_FIRE                 = 2052,  // TabId = 261, Tab = 0, Row = 6, Column = 2
+    SHAMAN_BOOMING_ECHOES                       = 2262,  // TabId = 261, Tab = 0, Row = 7, Column = 0
+    SHAMAN_ELEMENTAL_OATH                       = 2049,  // TabId = 261, Tab = 0, Row = 7, Column = 1
+    SHAMAN_LIGHTNING_OVERLOAD                   = 1686,  // TabId = 261, Tab = 0, Row = 7, Column = 2
+    SHAMAN_ASTRAL_SHIFT                         = 2050,  // TabId = 261, Tab = 0, Row = 8, Column = 0
+    SHAMAN_TOTEM_OF_WRATH                       = 1687,  // TabId = 261, Tab = 0, Row = 8, Column = 1
+    SHAMAN_LAVA_FLOWS                           = 2051,  // TabId = 261, Tab = 0, Row = 8, Column = 2
+    SHAMAN_SHAMANISM                            = 2252,  // TabId = 261, Tab = 0, Row = 9, Column = 1
+    SHAMAN_THUNDERSTORM                         = 2053,  // TabId = 261, Tab = 0, Row = 10, Column = 1
+    SHAMAN_IMPROVED_HEALING_WAVE                = 586,   // TabId = 262, Tab = 2, Row = 0, Column = 1
+    SHAMAN_TOTEMIC_FOCUS                        = 595,   // TabId = 262, Tab = 2, Row = 0, Column = 2
+    SHAMAN_IMPROVED_REINCARNATION               = 589,   // TabId = 262, Tab = 2, Row = 1, Column = 0
+    SHAMAN_HEALING_GRACE                        = 1646,  // TabId = 262, Tab = 2, Row = 1, Column = 1
+    SHAMAN_TIDAL_FOCUS                          = 593,   // TabId = 262, Tab = 2, Row = 1, Column = 2
+    SHAMAN_IMPROVED_WATER_SHIELD                = 583,   // TabId = 262, Tab = 2, Row = 2, Column = 0
+    SHAMAN_HEALING_FOCUS                        = 587,   // TabId = 262, Tab = 2, Row = 2, Column = 1
+    SHAMAN_TIDAL_FORCE                          = 582,   // TabId = 262, Tab = 2, Row = 2, Column = 2
+    SHAMAN_ANCESTRAL_HEALING                    = 581,   // TabId = 262, Tab = 2, Row = 2, Column = 3
+    SHAMAN_RESTORATIVE_TOTEMS                   = 588,   // TabId = 262, Tab = 2, Row = 3, Column = 1
+    SHAMAN_TIDAL_MASTERY                        = 594,   // TabId = 262, Tab = 2, Row = 3, Column = 2
+    SHAMAN_HEALING_WAY                          = 1648,  // TabId = 262, Tab = 2, Row = 4, Column = 0
+    SHAMAN_NATURES_SWIFTNESS                    = 591,   // TabId = 262, Tab = 2, Row = 4, Column = 2
+    SHAMAN_FOCUSED_MIND                         = 1695,  // TabId = 262, Tab = 2, Row = 4, Column = 3
+    SHAMAN_PURIFICATION                         = 592,   // TabId = 262, Tab = 2, Row = 5, Column = 2
+    SHAMAN_NATURES_GUARDIAN                     = 1699,  // TabId = 262, Tab = 2, Row = 6, Column = 0
+    SHAMAN_MANA_TIDE_TOTEM                      = 590,   // TabId = 262, Tab = 2, Row = 6, Column = 1
+    SHAMAN_CLEANSE_SPIRIT                       = 2084,  // TabId = 262, Tab = 2, Row = 6, Column = 2
+    SHAMAN_BLESSING_OF_THE_ETERNALS             = 2060,  // TabId = 262, Tab = 2, Row = 7, Column = 0
+    SHAMAN_IMPROVED_CHAIN_HEAL                  = 1697,  // TabId = 262, Tab = 2, Row = 7, Column = 1
+    SHAMAN_NATURES_BLESSING                     = 1696,  // TabId = 262, Tab = 2, Row = 7, Column = 2
+    SHAMAN_ANCESTRAL_AWAKENING                  = 2061,  // TabId = 262, Tab = 2, Row = 8, Column = 0
+    SHAMAN_EARTH_SHIELD                         = 1698,  // TabId = 262, Tab = 2, Row = 8, Column = 1
+    SHAMAN_IMPROVED_EARTH_SHIELD                = 2059,  // TabId = 262, Tab = 2, Row = 8, Column = 2
+    SHAMAN_TIDAL_WAVES                          = 2063,  // TabId = 262, Tab = 2, Row = 9, Column = 1
+    SHAMAN_RIPTIDE                              = 2064,  // TabId = 262, Tab = 2, Row = 10, Column = 1
+    SHAMAN_ENHANCING_TOTEMS                     = 610,   // TabId = 263, Tab = 1, Row = 0, Column = 0
+    SHAMAN_EARTHS_GRASP                         = 2101,  // TabId = 263, Tab = 1, Row = 0, Column = 1
+    SHAMAN_ANCESTRAL_KNOWLEDGE                  = 614,   // TabId = 263, Tab = 1, Row = 0, Column = 2
+    SHAMAN_GUARDIAN_TOTEMS                      = 609,   // TabId = 263, Tab = 1, Row = 1, Column = 0
+    SHAMAN_THUNDERING_STRIKES                   = 613,   // TabId = 263, Tab = 1, Row = 1, Column = 1
+    SHAMAN_IMPROVED_GHOST_WOLF                  = 605,   // TabId = 263, Tab = 1, Row = 1, Column = 2
+    SHAMAN_IMPROVED_SHIELDS                     = 607,   // TabId = 263, Tab = 1, Row = 1, Column = 3
+    SHAMAN_ELEMENTAL_WEAPONS                    = 611,   // TabId = 263, Tab = 1, Row = 2, Column = 0
+    SHAMAN_SHAMANISTIC_FOCUS                    = 617,   // TabId = 263, Tab = 1, Row = 2, Column = 2
+    SHAMAN_ANTICIPATION                         = 601,   // TabId = 263, Tab = 1, Row = 2, Column = 3
+    SHAMAN_FLURRY                               = 602,   // TabId = 263, Tab = 1, Row = 3, Column = 1
+    SHAMAN_TOUGHNESS                            = 615,   // TabId = 263, Tab = 1, Row = 3, Column = 2
+    SHAMAN_IMPROVED_WINDFURY_TOTEM              = 1647,  // TabId = 263, Tab = 1, Row = 4, Column = 0
+    SHAMAN_SPIRIT_WEAPONS                       = 616,   // TabId = 263, Tab = 1, Row = 4, Column = 1
+    SHAMAN_MENTAL_DEXTERITY                     = 2083,  // TabId = 263, Tab = 1, Row = 4, Column = 2
+    SHAMAN_UNLEASHED_RAGE                       = 1689,  // TabId = 263, Tab = 1, Row = 5, Column = 0
+    SHAMAN_WEAPON_MASTERY                       = 1643,  // TabId = 263, Tab = 1, Row = 5, Column = 2
+    SHAMAN_FROZEN_POWER                         = 2263,  // TabId = 263, Tab = 1, Row = 5, Column = 3
+    SHAMAN_DUAL_WIELD_SPECIALIZATION            = 1692,  // TabId = 263, Tab = 1, Row = 6, Column = 0
+    SHAMAN_DUAL_WIELD                           = 1690,  // TabId = 263, Tab = 1, Row = 6, Column = 1
+    SHAMAN_STORMSTRIKE                          = 901,   // TabId = 263, Tab = 1, Row = 6, Column = 2
+    SHAMAN_STATIC_SHOCK                         = 2055,  // TabId = 263, Tab = 1, Row = 7, Column = 0
+    SHAMAN_LAVA_LASH                            = 2249,  // TabId = 263, Tab = 1, Row = 7, Column = 1
+    SHAMAN_IMPROVED_STORMSTRIKE                 = 2054,  // TabId = 263, Tab = 1, Row = 7, Column = 2
+    SHAMAN_MENTAL_QUICKNESS                     = 1691,  // TabId = 263, Tab = 1, Row = 8, Column = 0
+    SHAMAN_SHAMANISTIC_RAGE                     = 1693,  // TabId = 263, Tab = 1, Row = 8, Column = 1
+    SHAMAN_EARTHEN_POWER                        = 2056,  // TabId = 263, Tab = 1, Row = 8, Column = 2
+    SHAMAN_MAELSTROM_WEAPON                     = 2057,  // TabId = 263, Tab = 1, Row = 9, Column = 1
+    SHAMAN_FERAL_SPIRIT                         = 2058   // TabId = 263, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsWarlock  // 0x100
+{
+    WARLOCK_IMPROVED_SHADOW_BOLT                = 944,   // TabId = 301, Tab = 2, Row = 0, Column = 1
+    WARLOCK_BANE                                = 943,   // TabId = 301, Tab = 2, Row = 0, Column = 2
+    WARLOCK_AFTERMATH                           = 982,   // TabId = 301, Tab = 2, Row = 1, Column = 0
+    WARLOCK_MOLTEN_SKIN                         = 1887,  // TabId = 301, Tab = 2, Row = 1, Column = 1
+    WARLOCK_CATACLYSM                           = 941,   // TabId = 301, Tab = 2, Row = 1, Column = 2
+    WARLOCK_DEMONIC_POWER                       = 983,   // TabId = 301, Tab = 2, Row = 2, Column = 0
+    WARLOCK_SHADOWBURN                          = 963,   // TabId = 301, Tab = 2, Row = 2, Column = 1
+    WARLOCK_RUIN                                = 967,   // TabId = 301, Tab = 2, Row = 2, Column = 2
+    WARLOCK_INTENSITY                           = 985,   // TabId = 301, Tab = 2, Row = 3, Column = 0
+    WARLOCK_DESTRUCTIVE_REACH                   = 964,   // TabId = 301, Tab = 2, Row = 3, Column = 1
+    WARLOCK_IMPROVED_SEARING_PAIN               = 965,   // TabId = 301, Tab = 2, Row = 3, Column = 3
+    WARLOCK_BACKLASH                            = 1817,  // TabId = 301, Tab = 2, Row = 4, Column = 0
+    WARLOCK_IMPROVED_IMMOLATE                   = 961,   // TabId = 301, Tab = 2, Row = 4, Column = 1
+    WARLOCK_DEVASTATION                         = 981,   // TabId = 301, Tab = 2, Row = 4, Column = 2
+    WARLOCK_NETHER_PROTECTION                   = 1679,  // TabId = 301, Tab = 2, Row = 5, Column = 0
+    WARLOCK_EMBERSTORM                          = 966,   // TabId = 301, Tab = 2, Row = 5, Column = 2
+    WARLOCK_CONFLAGRATE                         = 968,   // TabId = 301, Tab = 2, Row = 6, Column = 1
+    WARLOCK_SOUL_LEECH                          = 1678,  // TabId = 301, Tab = 2, Row = 6, Column = 2
+    WARLOCK_PYROCLASM                           = 986,   // TabId = 301, Tab = 2, Row = 6, Column = 3
+    WARLOCK_SHADOW_AND_FLAME                    = 1677,  // TabId = 301, Tab = 2, Row = 7, Column = 1
+    WARLOCK_IMPROVED_SOUL_LEECH                 = 1889,  // TabId = 301, Tab = 2, Row = 7, Column = 2
+    WARLOCK_BACKDRAFT                           = 1888,  // TabId = 301, Tab = 2, Row = 8, Column = 0
+    WARLOCK_SHADOWFURY                          = 1676,  // TabId = 301, Tab = 2, Row = 8, Column = 1
+    WARLOCK_EMPOWERED_IMP                       = 2045,  // TabId = 301, Tab = 2, Row = 8, Column = 2
+    WARLOCK_FIRE_AND_BRIMSTONE                  = 1890,  // TabId = 301, Tab = 2, Row = 9, Column = 1
+    WARLOCK_CHAOS_BOLT                          = 1891,  // TabId = 301, Tab = 2, Row = 10, Column = 1
+    WARLOCK_IMPROVED_CURSE_OF_AGONY             = 1284,  // TabId = 302, Tab = 0, Row = 0, Column = 0
+    WARLOCK_SUPPRESSION                         = 1005,  // TabId = 302, Tab = 0, Row = 0, Column = 1
+    WARLOCK_IMPROVED_CORRUPTION                 = 1003,  // TabId = 302, Tab = 0, Row = 0, Column = 2
+    WARLOCK_IMPROVED_CURSE_OF_WEAKNESS          = 1006,  // TabId = 302, Tab = 0, Row = 1, Column = 0
+    WARLOCK_IMPROVED_DRAIN_SOUL                 = 1101,  // TabId = 302, Tab = 0, Row = 1, Column = 1
+    WARLOCK_IMPROVED_LIFE_TAP                   = 1007,  // TabId = 302, Tab = 0, Row = 1, Column = 2
+    WARLOCK_SOUL_SIPHON                         = 1004,  // TabId = 302, Tab = 0, Row = 1, Column = 3
+    WARLOCK_IMPROVED_FEAR                       = 2205,  // TabId = 302, Tab = 0, Row = 2, Column = 0
+    WARLOCK_FEL_CONCENTRATION                   = 1001,  // TabId = 302, Tab = 0, Row = 2, Column = 1
+    WARLOCK_AMPLIFY_CURSE                       = 1061,  // TabId = 302, Tab = 0, Row = 2, Column = 2
+    WARLOCK_GRIM_REACH                          = 1021,  // TabId = 302, Tab = 0, Row = 3, Column = 0
+    WARLOCK_NIGHTFALL                           = 1002,  // TabId = 302, Tab = 0, Row = 3, Column = 1
+    WARLOCK_EMPOWERED_CORRUPTION                = 1764,  // TabId = 302, Tab = 0, Row = 3, Column = 3
+    WARLOCK_SHADOW_EMBRACE                      = 1763,  // TabId = 302, Tab = 0, Row = 4, Column = 0
+    WARLOCK_SIPHON_LIFE                         = 1041,  // TabId = 302, Tab = 0, Row = 4, Column = 1
+    WARLOCK_CURSE_OF_EXHAUSTION                 = 1081,  // TabId = 302, Tab = 0, Row = 4, Column = 2
+    WARLOCK_IMPROVED_FELHUNTER                  = 1873,  // TabId = 302, Tab = 0, Row = 5, Column = 0
+    WARLOCK_SHADOW_MASTERY                      = 1042,  // TabId = 302, Tab = 0, Row = 5, Column = 1
+    WARLOCK_ERADICATION                         = 1878,  // TabId = 302, Tab = 0, Row = 6, Column = 0
+    WARLOCK_CONTAGION                           = 1669,  // TabId = 302, Tab = 0, Row = 6, Column = 1
+    WARLOCK_DARK_PACT                           = 1022,  // TabId = 302, Tab = 0, Row = 6, Column = 2
+    WARLOCK_IMPROVED_HOWL_OF_TERROR             = 1668,  // TabId = 302, Tab = 0, Row = 7, Column = 0
+    WARLOCK_MALEDICTION                         = 1667,  // TabId = 302, Tab = 0, Row = 7, Column = 2
+    WARLOCK_DEATHS_EMBRACE                      = 1875,  // TabId = 302, Tab = 0, Row = 8, Column = 0
+    WARLOCK_UNSTABLE_AFFLICTION                 = 1670,  // TabId = 302, Tab = 0, Row = 8, Column = 1
+    WARLOCK_PANDEMIC                            = 2245,  // TabId = 302, Tab = 0, Row = 8, Column = 2
+    WARLOCK_EVERLASTING_AFFLICTION              = 1876,  // TabId = 302, Tab = 0, Row = 9, Column = 1
+    WARLOCK_HAUNT                               = 2041,  // TabId = 302, Tab = 0, Row = 10, Column = 1
+    WARLOCK_IMPROVED_HEALTHSTONE                = 1221,  // TabId = 303, Tab = 1, Row = 0, Column = 0
+    WARLOCK_IMPROVED_IMP                        = 1222,  // TabId = 303, Tab = 1, Row = 0, Column = 1
+    WARLOCK_DEMONIC_EMBRACE                     = 1223,  // TabId = 303, Tab = 1, Row = 0, Column = 2
+    WARLOCK_FEL_SYNERGY                         = 1883,  // TabId = 303, Tab = 1, Row = 0, Column = 3
+    WARLOCK_IMPROVED_HEALTH_FUNNEL              = 1224,  // TabId = 303, Tab = 1, Row = 1, Column = 0
+    WARLOCK_DEMONIC_BRUTALITY                   = 1225,  // TabId = 303, Tab = 1, Row = 1, Column = 1
+    WARLOCK_FEL_VITALITY                        = 1242,  // TabId = 303, Tab = 1, Row = 1, Column = 2
+    WARLOCK_IMPROVED_SUCCUBUS                   = 1243,  // TabId = 303, Tab = 1, Row = 2, Column = 0
+    WARLOCK_SOUL_LINK                           = 1282,  // TabId = 303, Tab = 1, Row = 2, Column = 1
+    WARLOCK_FEL_DOMINATION                      = 1226,  // TabId = 303, Tab = 1, Row = 2, Column = 2
+    WARLOCK_DEMONIC_AEGIS                       = 1671,  // TabId = 303, Tab = 1, Row = 2, Column = 3
+    WARLOCK_UNHOLY_POWER                        = 1262,  // TabId = 303, Tab = 1, Row = 3, Column = 1
+    WARLOCK_MASTER_SUMMONER                     = 1227,  // TabId = 303, Tab = 1, Row = 3, Column = 2
+    WARLOCK_MANA_FEED                           = 1281,  // TabId = 303, Tab = 1, Row = 4, Column = 0
+    WARLOCK_MASTER_CONJURER                     = 1261,  // TabId = 303, Tab = 1, Row = 4, Column = 2
+    WARLOCK_MASTER_DEMONOLOGIST                 = 1244,  // TabId = 303, Tab = 1, Row = 5, Column = 1
+    WARLOCK_MOLTEN_CORE                         = 1283,  // TabId = 303, Tab = 1, Row = 5, Column = 2
+    WARLOCK_DEMONIC_RESILIENCE                  = 1680,  // TabId = 303, Tab = 1, Row = 6, Column = 0
+    WARLOCK_DEMONIC_EMPOWERMENT                 = 1880,  // TabId = 303, Tab = 1, Row = 6, Column = 1
+    WARLOCK_DEMONIC_KNOWLEDGE                   = 1263,  // TabId = 303, Tab = 1, Row = 6, Column = 2
+    WARLOCK_DEMONIC_TACTICS                     = 1673,  // TabId = 303, Tab = 1, Row = 7, Column = 1
+    WARLOCK_DECIMATION                          = 2261,  // TabId = 303, Tab = 1, Row = 7, Column = 2
+    WARLOCK_IMPROVED_DEMONIC_TACTICS            = 1882,  // TabId = 303, Tab = 1, Row = 8, Column = 0
+    WARLOCK_SUMMON_FELGUARD                     = 1672,  // TabId = 303, Tab = 1, Row = 8, Column = 1
+    WARLOCK_NEMESIS                             = 1884,  // TabId = 303, Tab = 1, Row = 8, Column = 2
+    WARLOCK_DEMONIC_PACT                        = 1885,  // TabId = 303, Tab = 1, Row = 9, Column = 1
+    WARLOCK_METAMORPHOSIS                       = 1886   // TabId = 303, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsWarrior  // 0x001
+{
+    WARRIOR_IMPROVED_HEROIC_STRIKE              = 124,   // TabId = 161, Tab = 0, Row = 0, Column = 0
+    WARRIOR_DEFLECTION                          = 130,   // TabId = 161, Tab = 0, Row = 0, Column = 1
+    WARRIOR_IMPROVED_REND                       = 127,   // TabId = 161, Tab = 0, Row = 0, Column = 2
+    WARRIOR_IMPROVED_CHARGE                     = 126,   // TabId = 161, Tab = 0, Row = 1, Column = 0
+    WARRIOR_IRON_WILL                           = 641,   // TabId = 161, Tab = 0, Row = 1, Column = 1
+    WARRIOR_TACTICAL_MASTERY                    = 128,   // TabId = 161, Tab = 0, Row = 1, Column = 2
+    WARRIOR_IMPROVED_OVERPOWER                  = 131,   // TabId = 161, Tab = 0, Row = 2, Column = 0
+    WARRIOR_ANGER_MANAGEMENT                    = 137,   // TabId = 161, Tab = 0, Row = 2, Column = 1
+    WARRIOR_IMPALE                              = 662,   // TabId = 161, Tab = 0, Row = 2, Column = 2
+    WARRIOR_DEEP_WOUNDS                         = 121,   // TabId = 161, Tab = 0, Row = 2, Column = 3
+    WARRIOR_TWOHANDED_WEAPON_SPECIALIZATION     = 136,   // TabId = 161, Tab = 0, Row = 3, Column = 1
+    WARRIOR_TASTE_FOR_BLOOD                     = 2232,  // TabId = 161, Tab = 0, Row = 3, Column = 2
+    WARRIOR_POLEAXE_SPECIALIZATION              = 132,   // TabId = 161, Tab = 0, Row = 4, Column = 0
+    WARRIOR_SWEEPING_STRIKES                    = 133,   // TabId = 161, Tab = 0, Row = 4, Column = 1
+    WARRIOR_MACE_SPECIALIZATION                 = 125,   // TabId = 161, Tab = 0, Row = 4, Column = 2
+    WARRIOR_SWORD_SPECIALIZATION                = 123,   // TabId = 161, Tab = 0, Row = 4, Column = 3
+    WARRIOR_WEAPON_MASTERY                      = 134,   // TabId = 161, Tab = 0, Row = 5, Column = 0
+    WARRIOR_IMPROVED_HAMSTRING                  = 129,   // TabId = 161, Tab = 0, Row = 5, Column = 2
+    WARRIOR_TRAUMA                              = 1859,  // TabId = 161, Tab = 0, Row = 5, Column = 3
+    WARRIOR_SECOND_WIND                         = 1663,  // TabId = 161, Tab = 0, Row = 6, Column = 0
+    WARRIOR_MORTAL_STRIKE                       = 135,   // TabId = 161, Tab = 0, Row = 6, Column = 1
+    WARRIOR_STRENGTH_OF_ARMS                    = 1862,  // TabId = 161, Tab = 0, Row = 6, Column = 2
+    WARRIOR_IMPROVED_SLAM                       = 2233,  // TabId = 161, Tab = 0, Row = 6, Column = 3
+    WARRIOR_JUGGERNAUT                          = 2283,  // TabId = 161, Tab = 0, Row = 7, Column = 0
+    WARRIOR_IMPROVED_MORTAL_STRIKE              = 1824,  // TabId = 161, Tab = 0, Row = 7, Column = 1
+    WARRIOR_UNRELENTING_ASSAULT                 = 1860,  // TabId = 161, Tab = 0, Row = 7, Column = 2
+    WARRIOR_SUDDEN_DEATH                        = 1662,  // TabId = 161, Tab = 0, Row = 8, Column = 0
+    WARRIOR_ENDLESS_RAGE                        = 1661,  // TabId = 161, Tab = 0, Row = 8, Column = 1
+    WARRIOR_BLOOD_FRENZY                        = 1664,  // TabId = 161, Tab = 0, Row = 8, Column = 2
+    WARRIOR_WRECKING_CREW                       = 2231,  // TabId = 161, Tab = 0, Row = 9, Column = 1
+    WARRIOR_BLADESTORM                          = 1863,  // TabId = 161, Tab = 0, Row = 10, Column = 1
+    WARRIOR_IMPROVED_BLOODRAGE                  = 142,   // TabId = 163, Tab = 2, Row = 0, Column = 0
+    WARRIOR_SHIELD_SPECIALIZATION               = 1601,  // TabId = 163, Tab = 2, Row = 0, Column = 1
+    WARRIOR_IMPROVED_THUNDER_CLAP               = 141,   // TabId = 163, Tab = 2, Row = 0, Column = 2
+    WARRIOR_INCITE                              = 144,   // TabId = 163, Tab = 2, Row = 1, Column = 1
+    WARRIOR_ANTICIPATION                        = 138,   // TabId = 163, Tab = 2, Row = 1, Column = 2
+    WARRIOR_LAST_STAND                          = 153,   // TabId = 163, Tab = 2, Row = 2, Column = 0
+    WARRIOR_IMPROVED_REVENGE                    = 147,   // TabId = 163, Tab = 2, Row = 2, Column = 1
+    WARRIOR_SHIELD_MASTERY                      = 1654,  // TabId = 163, Tab = 2, Row = 2, Column = 2
+    WARRIOR_TOUGHNESS                           = 140,   // TabId = 163, Tab = 2, Row = 2, Column = 3
+    WARRIOR_IMPROVED_SPELL_REFLECTION           = 2247,  // TabId = 163, Tab = 2, Row = 3, Column = 0
+    WARRIOR_IMPROVED_DISARM                     = 151,   // TabId = 163, Tab = 2, Row = 3, Column = 1
+    WARRIOR_PUNCTURE                            = 146,   // TabId = 163, Tab = 2, Row = 3, Column = 2
+    WARRIOR_IMPROVED_DISCIPLINES                = 150,   // TabId = 163, Tab = 2, Row = 4, Column = 0
+    WARRIOR_CONCUSSION_BLOW                     = 152,   // TabId = 163, Tab = 2, Row = 4, Column = 1
+    WARRIOR_GAG_ORDER                           = 149,   // TabId = 163, Tab = 2, Row = 4, Column = 2
+    WARRIOR_ONEHANDED_WEAPON_SPECIALIZATION     = 702,   // TabId = 163, Tab = 2, Row = 5, Column = 2
+    WARRIOR_IMPROVED_DEFENSIVE_STANCE           = 1652,  // TabId = 163, Tab = 2, Row = 6, Column = 0
+    WARRIOR_VIGILANCE                           = 148,   // TabId = 163, Tab = 2, Row = 6, Column = 1
+    WARRIOR_FOCUSED_RAGE                        = 1660,  // TabId = 163, Tab = 2, Row = 6, Column = 2
+    WARRIOR_VITALITY                            = 1653,  // TabId = 163, Tab = 2, Row = 7, Column = 1
+    WARRIOR_SAFEGUARD                           = 1870,  // TabId = 163, Tab = 2, Row = 7, Column = 2
+    WARRIOR_WARBRINGER                          = 2236,  // TabId = 163, Tab = 2, Row = 8, Column = 0
+    WARRIOR_DEVASTATE                           = 1666,  // TabId = 163, Tab = 2, Row = 8, Column = 1
+    WARRIOR_CRITICAL_BLOCK                      = 1893,  // TabId = 163, Tab = 2, Row = 8, Column = 2
+    WARRIOR_SWORD_AND_BOARD                     = 1871,  // TabId = 163, Tab = 2, Row = 9, Column = 1
+    WARRIOR_DAMAGE_SHIELD                       = 2246,  // TabId = 163, Tab = 2, Row = 9, Column = 2
+    WARRIOR_SHOCKWAVE                           = 1872,  // TabId = 163, Tab = 2, Row = 10, Column = 1
+    WARRIOR_ARMORED_TO_THE_TEETH                = 2250,  // TabId = 164, Tab = 1, Row = 0, Column = 0
+    WARRIOR_BOOMING_VOICE                       = 158,   // TabId = 164, Tab = 1, Row = 0, Column = 1
+    WARRIOR_CRUELTY                             = 157,   // TabId = 164, Tab = 1, Row = 0, Column = 2
+    WARRIOR_IMPROVED_DEMORALIZING_SHOUT         = 161,   // TabId = 164, Tab = 1, Row = 1, Column = 1
+    WARRIOR_UNBRIDLED_WRATH                     = 159,   // TabId = 164, Tab = 1, Row = 1, Column = 2
+    WARRIOR_IMPROVED_CLEAVE                     = 166,   // TabId = 164, Tab = 1, Row = 2, Column = 0
+    WARRIOR_PIERCING_HOWL                       = 160,   // TabId = 164, Tab = 1, Row = 2, Column = 1
+    WARRIOR_BLOOD_CRAZE                         = 661,   // TabId = 164, Tab = 1, Row = 2, Column = 2
+    WARRIOR_COMMANDING_PRESENCE                 = 154,   // TabId = 164, Tab = 1, Row = 2, Column = 3
+    WARRIOR_DUAL_WIELD_SPECIALIZATION           = 1581,  // TabId = 164, Tab = 1, Row = 3, Column = 0
+    WARRIOR_IMPROVED_EXECUTE                    = 1542,  // TabId = 164, Tab = 1, Row = 3, Column = 1
+    WARRIOR_ENRAGE                              = 155,   // TabId = 164, Tab = 1, Row = 3, Column = 2
+    WARRIOR_PRECISION                           = 1657,  // TabId = 164, Tab = 1, Row = 4, Column = 0
+    WARRIOR_DEATH_WISH                          = 165,   // TabId = 164, Tab = 1, Row = 4, Column = 1
+    WARRIOR_IMPROVED_INTERCEPT                  = 1543,  // TabId = 164, Tab = 1, Row = 4, Column = 2
+    WARRIOR_IMPROVED_BERSERKER_RAGE             = 1541,  // TabId = 164, Tab = 1, Row = 5, Column = 0
+    WARRIOR_FLURRY                              = 156,   // TabId = 164, Tab = 1, Row = 5, Column = 2
+    WARRIOR_INTENSIFY_RAGE                      = 1864,  // TabId = 164, Tab = 1, Row = 6, Column = 0
+    WARRIOR_BLOODTHIRST                         = 167,   // TabId = 164, Tab = 1, Row = 6, Column = 1
+    WARRIOR_IMPROVED_WHIRLWIND                  = 1655,  // TabId = 164, Tab = 1, Row = 6, Column = 3
+    WARRIOR_FURIOUS_ATTACKS                     = 1865,  // TabId = 164, Tab = 1, Row = 7, Column = 0
+    WARRIOR_IMPROVED_BERSERKER_STANCE           = 1658,  // TabId = 164, Tab = 1, Row = 7, Column = 3
+    WARRIOR_HEROIC_FURY                         = 1868,  // TabId = 164, Tab = 1, Row = 8, Column = 0
+    WARRIOR_RAMPAGE                             = 1659,  // TabId = 164, Tab = 1, Row = 8, Column = 1
+    WARRIOR_BLOODSURGE                          = 1866,  // TabId = 164, Tab = 1, Row = 8, Column = 2
+    WARRIOR_UNENDING_FURY                       = 2234,  // TabId = 164, Tab = 1, Row = 9, Column = 1
+    WARRIOR_TITANS_GRIP                         = 1867   // TabId = 164, Tab = 1, Row = 10, Column = 1
+};
+
+enum TalentsPet  // 0x000
+{
+    PET_TENACITY_COBRA_REFLEXES                 = 2114,  // TabId = 409, Tab = 0, Row = 0, Column = 0
+    PET_TENACITY_CHARGE                         = 2237,  // TabId = 409, Tab = 0, Row = 0, Column = 1
+    PET_TENACITY_GREAT_STAMINA                  = 2116,  // TabId = 409, Tab = 0, Row = 0, Column = 2
+    PET_TENACITY_NATURAL_ARMOR                  = 2117,  // TabId = 409, Tab = 0, Row = 0, Column = 3
+    PET_TENACITY_SPIKED_COLLAR                  = 2126,  // TabId = 409, Tab = 0, Row = 1, Column = 0
+    PET_TENACITY_BOARS_SPEED                    = 2160,  // TabId = 409, Tab = 0, Row = 1, Column = 1
+    PET_TENACITY_BLOOD_OF_THE_RHINO             = 2173,  // TabId = 409, Tab = 0, Row = 1, Column = 2
+    PET_TENACITY_PET_BARDING                    = 2122,  // TabId = 409, Tab = 0, Row = 1, Column = 3
+    PET_TENACITY_CULLING_THE_HERD               = 2110,  // TabId = 409, Tab = 0, Row = 2, Column = 0
+    PET_TENACITY_GUARD_DOG                      = 2123,  // TabId = 409, Tab = 0, Row = 2, Column = 1
+    PET_TENACITY_LIONHEARTED                    = 2162,  // TabId = 409, Tab = 0, Row = 2, Column = 2
+    PET_TENACITY_THUNDERSTOMP                   = 2277,  // TabId = 409, Tab = 0, Row = 2, Column = 3
+    PET_TENACITY_GRACE_OF_THE_MANTIS            = 2163,  // TabId = 409, Tab = 0, Row = 3, Column = 2
+    PET_TENACITY_GREAT_RESISTANCE               = 2161,  // TabId = 409, Tab = 0, Row = 3, Column = 3
+    PET_TENACITY_LAST_STAND                     = 2171,  // TabId = 409, Tab = 0, Row = 4, Column = 0
+    PET_TENACITY_TAUNT                          = 2170,  // TabId = 409, Tab = 0, Row = 4, Column = 1
+    PET_TENACITY_ROAR_OF_SACRIFICE              = 2172,  // TabId = 409, Tab = 0, Row = 4, Column = 2
+    PET_TENACITY_INTERVENE                      = 2169,  // TabId = 409, Tab = 0, Row = 4, Column = 3
+    PET_TENACITY_SILVERBACK                     = 2258,  // TabId = 409, Tab = 0, Row = 5, Column = 1
+    PET_TENACITY_WILD_HUNT                      = 2255,  // TabId = 409, Tab = 0, Row = 5, Column = 2
+    PET_FEROCITY_COBRA_REFLEXES                 = 2107,  // TabId = 410, Tab = 0, Row = 0, Column = 0
+    // TODO: same spell, one for flying pets other for land pets. Figure out which is which if it ever matters.
+    PET_FEROCITY_DASHDIVE1                      = 2109,  // TabId = 410, Tab = 0, Row = 0, Column = 1
+    PET_FEROCITY_DASHDIVE2                      = 2203,  // TabId = 410, Tab = 0, Row = 0, Column = 1
+    PET_FEROCITY_GREAT_STAMINA                  = 2112,  // TabId = 410, Tab = 0, Row = 0, Column = 2
+    PET_FEROCITY_NATURAL_ARMOR                  = 2113,  // TabId = 410, Tab = 0, Row = 0, Column = 3
+    PET_FEROCITY_IMPROVED_COWER                 = 2124,  // TabId = 410, Tab = 0, Row = 1, Column = 0
+    PET_FEROCITY_BLOODTHIRSTY                   = 2128,  // TabId = 410, Tab = 0, Row = 1, Column = 1
+    PET_FEROCITY_SPIKED_COLLAR                  = 2125,  // TabId = 410, Tab = 0, Row = 1, Column = 2
+    PET_FEROCITY_BOARS_SPEED                    = 2151,  // TabId = 410, Tab = 0, Row = 1, Column = 3
+    PET_FEROCITY_CULLING_THE_HERD               = 2106,  // TabId = 410, Tab = 0, Row = 2, Column = 0
+    PET_FEROCITY_LIONHEARTED                    = 2152,  // TabId = 410, Tab = 0, Row = 2, Column = 2
+    // TODO: same spell, one for flying pets other for land pets. Figure out which is which if it ever matters.
+    PET_FEROCITY_CHARGESWOOP1                   = 2111,  // TabId = 410, Tab = 0, Row = 2, Column = 3
+    PET_FEROCITY_CHARGESWOOP2                   = 2219,  // TabId = 410, Tab = 0, Row = 2, Column = 3
+    PET_FEROCITY_HEART_OF_THE_PHOENIX           = 2156,  // TabId = 410, Tab = 0, Row = 3, Column = 1
+    PET_FEROCITY_SPIDERS_BITE                   = 2129,  // TabId = 410, Tab = 0, Row = 3, Column = 2
+    PET_FEROCITY_GREAT_RESISTANCE               = 2154,  // TabId = 410, Tab = 0, Row = 3, Column = 3
+    PET_FEROCITY_RABID                          = 2155,  // TabId = 410, Tab = 0, Row = 4, Column = 0
+    PET_FEROCITY_LICK_YOUR_WOUNDS               = 2153,  // TabId = 410, Tab = 0, Row = 4, Column = 1
+    PET_FEROCITY_CALL_OF_THE_WILD               = 2157,  // TabId = 410, Tab = 0, Row = 4, Column = 2
+    PET_FEROCITY_SHARK_ATTACK                   = 2254,  // TabId = 410, Tab = 0, Row = 5, Column = 0
+    PET_FEROCITY_WILD_HUNT                      = 2253,  // TabId = 410, Tab = 0, Row = 5, Column = 2
+    PET_CUNNING_COBRA_REFLEXES                  = 2118,  // TabId = 411, Tab = 0, Row = 0, Column = 0
+    // TODO: same spell, one for flying pets other for land pets. Figure out which is which if it ever matters.
+    PET_CUNNING_DASHDIVE1                       = 2119,  // TabId = 411, Tab = 0, Row = 0, Column = 1
+    PET_CUNNING_DASHDIVE2                       = 2201,  // TabId = 411, Tab = 0, Row = 0, Column = 1
+    PET_CUNNING_GREAT_STAMINA                   = 2120,  // TabId = 411, Tab = 0, Row = 0, Column = 2
+    PET_CUNNING_NATURAL_ARMOR                   = 2121,  // TabId = 411, Tab = 0, Row = 0, Column = 3
+    PET_CUNNING_BOARS_SPEED                     = 2165,  // TabId = 411, Tab = 0, Row = 1, Column = 0
+    // TODO: Frankly, not sure what the difference is. Presumably one for land, one for air? Because they require Dash or Dive.
+    PET_CUNNING_MOBILITY1                       = 2207,  // TabId = 411, Tab = 0, Row = 1, Column = 1
+    PET_CUNNING_MOBILITY2                       = 2208,  // TabId = 411, Tab = 0, Row = 1, Column = 1
+    PET_CUNNING_OWLS_FOCUS                      = 2182,  // TabId = 411, Tab = 0, Row = 1, Column = 2
+    PET_CUNNING_SPIKED_COLLAR                   = 2127,  // TabId = 411, Tab = 0, Row = 1, Column = 3
+    PET_CUNNING_CULLING_THE_HERD                = 2166,  // TabId = 411, Tab = 0, Row = 2, Column = 0
+    PET_CUNNING_LIONHEARTED                     = 2167,  // TabId = 411, Tab = 0, Row = 2, Column = 1
+    PET_CUNNING_CARRION_FEEDER                  = 2206,  // TabId = 411, Tab = 0, Row = 2, Column = 2
+    PET_CUNNING_GREAT_RESISTANCE                = 2168,  // TabId = 411, Tab = 0, Row = 3, Column = 1
+    PET_CUNNING_CORNERED                        = 2177,  // TabId = 411, Tab = 0, Row = 3, Column = 2
+    PET_CUNNING_FEEDING_FRENZY                  = 2183,  // TabId = 411, Tab = 0, Row = 3, Column = 3
+    PET_CUNNING_WOLVERINE_BITE                  = 2181,  // TabId = 411, Tab = 0, Row = 4, Column = 0
+    PET_CUNNING_ROAR_OF_RECOVERY                = 2184,  // TabId = 411, Tab = 0, Row = 4, Column = 1
+    PET_CUNNING_BULLHEADED                      = 2175,  // TabId = 411, Tab = 0, Row = 4, Column = 2
+    PET_CUNNING_GRACE_OF_THE_MANTIS             = 2257,  // TabId = 411, Tab = 0, Row = 4, Column = 3
+    PET_CUNNING_WILD_HUNT                       = 2256,  // TabId = 411, Tab = 0, Row = 5, Column = 0
+    PET_CUNNING_ROAR_OF_SACRIFICE               = 2278  // TabId = 411, Tab = 0, Row = 5, Column = 3
+};
+
+enum Glyphs
+{
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_COMMAND         = 511,   // Level 55  Spell ID: 58613
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_ANTIMAGIC_SHELL      = 512,   // Level 55  Spell ID: 58623
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_HEART_STRIKE         = 513,   // Unknown   Spell ID: 58616
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_BONE_SHIELD          = 515,   // Level 55  Spell ID: 58673
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_CHAINS_OF_ICE        = 516,   // Level 55  Spell ID: 58620
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_GRIP           = 519,   // Level 55  Spell ID: 62259
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_AND_DECAY      = 520,   // Level 55  Spell ID: 58629
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_FROST_STRIKE         = 521,   // Level 55  Spell ID: 58647
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_ICEBOUND_FORTITUDE   = 523,   // Level 55  Spell ID: 58625
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_ICY_TOUCH            = 524,   // Level 55  Spell ID: 58631
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_OBLITERATE           = 525,   // Level 55  Spell ID: 58671
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_PLAGUE_STRIKE        = 526,   // Level 55  Spell ID: 58657
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_THE_GHOUL            = 527,   // Level 55  Spell ID: 58686
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_STRIKE          = 528,   // Level 55  Spell ID: 58669
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_SCOURGE_STRIKE       = 529,   // Level 55  Spell ID: 58642
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_STRANGULATE          = 530,   // Level 55  Spell ID: 58618
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_UNBREAKABLE_ARMOR    = 531,   // Level 55  Spell ID: 58635
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_VAMPIRIC_BLOOD       = 532,   // Level 55  Spell ID: 58676
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_RUNE_TAP             = 556,   // Level 55  Spell ID: 59327
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_BLOOD_STRIKE         = 557,   // Level 55  Spell ID: 59332
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DEATH_STRIKE         = 558,   // Level 55  Spell ID: 59336
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DANCING_RUNE_WEAPON  = 768,   // Level 60  Spell ID: 63330
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_HUNGERING_COLD       = 769,   // Level 60  Spell ID: 63331
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_UNHOLY_BLIGHT        = 770,   // Level 60  Spell ID: 63332
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DARK_DEATH           = 771,   // Level 55  Spell ID: 63333
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_DISEASE              = 772,   // Level 55  Spell ID: 63334
+    DEATH_KNIGHT_MAJOR_GLYPH_OF_HOWLING_BLAST        = 773,   // Level 60  Spell ID: 63335
+    DEATH_KNIGHT_MINOR_GLYPH_OF_BLOOD_TAP            = 514,   // Level 55  Spell ID: 58640
+    DEATH_KNIGHT_MINOR_GLYPH_OF_DEATHS_EMBRACE       = 518,   // Level 55  Spell ID: 58677
+    DEATH_KNIGHT_MINOR_GLYPH_OF_HORN_OF_WINTER       = 522,   // Level 55  Spell ID: 58680
+    DEATH_KNIGHT_MINOR_GLYPH_OF_PESTILENCE           = 553,   // Level 55  Spell ID: 59309
+    DEATH_KNIGHT_MINOR_GLYPH_OF_CORPSE_EXPLOSION     = 554,   // Level 55  Spell ID: 59307
+    // TODO: Hmm, this looks suspiciously alike... yet not. What's up?
+    DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD           = 555,   // Level 55  Spell ID: 60200
+    DEATH_KNIGHT_MINOR_GLYPH_OF_RAISE_DEAD2          = 571,   // Level 55  Spell ID: 60200
+    DRUID_MAJOR_GLYPH_OF_FRENZIED_REGENERATION       = 161,   // Level 36  Spell ID: 54810
+    DRUID_MAJOR_GLYPH_OF_MAUL                        = 162,   // Level 15  Spell ID: 54811
+    DRUID_MAJOR_GLYPH_OF_MANGLE                      = 164,   // Level 50  Spell ID: 54813
+    DRUID_MAJOR_GLYPH_OF_SHRED                       = 165,   // Level 22  Spell ID: 54815
+    DRUID_MAJOR_GLYPH_OF_RIP                         = 166,   // Level 20  Spell ID: 54818
+    DRUID_MAJOR_GLYPH_OF_RAKE                        = 167,   // Level 24  Spell ID: 54821
+    DRUID_MAJOR_GLYPH_OF_SWIFTMEND                   = 168,   // Level 40  Spell ID: 54824
+    DRUID_MAJOR_GLYPH_OF_INNERVATE                   = 169,   // Level 40  Spell ID: 54832
+    DRUID_MAJOR_GLYPH_OF_REBIRTH                     = 170,   // Level 20  Spell ID: 54733
+    DRUID_MAJOR_GLYPH_OF_REGROWTH                    = 171,   // Level 15  Spell ID: 54743
+    DRUID_MAJOR_GLYPH_OF_REJUVENATION                = 172,   // Level 15  Spell ID: 54754
+    DRUID_MAJOR_GLYPH_OF_HEALING_TOUCH               = 173,   // Level 15  Spell ID: 54825
+    DRUID_MAJOR_GLYPH_OF_LIFEBLOOM                   = 174,   // Level 64  Spell ID: 54826
+    DRUID_MAJOR_GLYPH_OF_STARFIRE                    = 175,   // Level 20  Spell ID: 54845
+    DRUID_MAJOR_GLYPH_OF_INSECT_SWARM                = 176,   // Level 20  Spell ID: 54830
+    DRUID_MAJOR_GLYPH_OF_HURRICANE                   = 177,   // Level 40  Spell ID: 54831
+    DRUID_MAJOR_GLYPH_OF_STARFALL                    = 178,   // Level 60  Spell ID: 54828
+    DRUID_MAJOR_GLYPH_OF_WRATH                       = 179,   // Level 15  Spell ID: 54756
+    DRUID_MAJOR_GLYPH_OF_MOONFIRE                    = 180,   // Level 15  Spell ID: 54829
+    DRUID_MAJOR_GLYPH_OF_ENTANGLING_ROOTS            = 181,   // Level 15  Spell ID: 54760
+    DRUID_MAJOR_GLYPH_OF_FOCUS                       = 631,   // Level 70  Spell ID: 62080
+    DRUID_MAJOR_GLYPH_OF_BERSERK                     = 671,   // Level 60  Spell ID: 62969
+    DRUID_MAJOR_GLYPH_OF_WILD_GROWTH                 = 672,   // Level 60  Spell ID: 62970
+    DRUID_MAJOR_GLYPH_OF_NOURISH                     = 673,   // Level 80  Spell ID: 62971
+    DRUID_MAJOR_GLYPH_OF_SAVAGE_ROAR                 = 674,   // Level 75  Spell ID: 63055
+    DRUID_MAJOR_GLYPH_OF_MONSOON                     = 675,   // Level 50  Spell ID: 63056
+    DRUID_MAJOR_GLYPH_OF_BARKSKIN                    = 676,   // Level 44  Spell ID: 63057
+    DRUID_MAJOR_GLYPH_OF_SURVIVAL_INSTINCTS          = 811,   // Level 20  Spell ID: 65243
+    DRUID_MAJOR_GLYPH_OF_CLAW                        = 831,   // Level 20  Spell ID: 67598
+    DRUID_MAJOR_GLYPH_OF_RAPID_REJUVENATION          = 891,   // Level 15  Spell ID: 71013
+    DRUID_MINOR_GLYPH_OF_AQUATIC_FORM                = 431,   // Level 16  Spell ID: 57856
+    DRUID_MINOR_GLYPH_OF_CHALLENGING_ROAR            = 432,   // Level 28  Spell ID: 57858
+    DRUID_MINOR_GLYPH_OF_THE_WILD                    = 433,   // Level 15  Spell ID: 57855
+    DRUID_MINOR_GLYPH_OF_UNBURDENED_REBIRTH          = 434,   // Level 20  Spell ID: 57857
+    DRUID_MINOR_GLYPH_OF_THORNS                      = 435,   // Level 15  Spell ID: 57862
+    DRUID_MINOR_GLYPH_OF_DASH                        = 551,   // Level 16  Spell ID: 59219
+    DRUID_MINOR_GLYPH_OF_TYPHOON                     = 613,   // Level 70  Spell ID: 62135
+    HUNTER_MAJOR_GLYPH_OF_AIMED_SHOT                 = 351,   // Level 20  Spell ID: 56824
+    HUNTER_MAJOR_GLYPH_OF_ARCANE_SHOT                = 352,   // Level 15  Spell ID: 56841
+    HUNTER_MAJOR_GLYPH_OF_THE_BEAST                  = 353,   // Level 30  Spell ID: 56857
+    HUNTER_MAJOR_GLYPH_OF_MENDING                    = 354,   // Level 15  Spell ID: 56833
+    HUNTER_MAJOR_GLYPH_OF_ASPECT_OF_THE_VIPER        = 355,   // Level 20  Spell ID: 56851
+    HUNTER_MAJOR_GLYPH_OF_BESTIAL_WRATH              = 356,   // Level 40  Spell ID: 56830
+    HUNTER_MAJOR_GLYPH_OF_DETERRENCE                 = 357,   // Level 20  Spell ID: 56850
+    HUNTER_MAJOR_GLYPH_OF_DISENGAGE                  = 358,   // Level 20  Spell ID: 56844
+    HUNTER_MAJOR_GLYPH_OF_FREEZING_TRAP              = 359,   // Level 20  Spell ID: 56845
+    HUNTER_MAJOR_GLYPH_OF_FROST_TRAP                 = 360,   // Level 28  Spell ID: 56847
+    HUNTER_MAJOR_GLYPH_OF_HUNTERS_MARK               = 361,   // Level 15  Spell ID: 56829
+    HUNTER_MAJOR_GLYPH_OF_IMMOLATION_TRAP            = 362,   // Level 16  Spell ID: 56846
+    HUNTER_MAJOR_GLYPH_OF_MULTISHOT                  = 364,   // Level 18  Spell ID: 56836
+    HUNTER_MAJOR_GLYPH_OF_RAPID_FIRE                 = 365,   // Level 26  Spell ID: 56828
+    HUNTER_MAJOR_GLYPH_OF_SERPENT_STING              = 366,   // Level 15  Spell ID: 56832
+    HUNTER_MAJOR_GLYPH_OF_SNAKE_TRAP                 = 367,   // Level 68  Spell ID: 56849
+    HUNTER_MAJOR_GLYPH_OF_STEADY_SHOT                = 368,   // Level 62  Spell ID: 56826
+    HUNTER_MAJOR_GLYPH_OF_TRUESHOT_AURA              = 369,   // Level 40  Spell ID: 56842
+    HUNTER_MAJOR_GLYPH_OF_VOLLEY                     = 370,   // Level 40  Spell ID: 56838
+    HUNTER_MAJOR_GLYPH_OF_WYVERN_STING               = 371,   // Level 40  Spell ID: 56848
+    HUNTER_MAJOR_GLYPH_OF_CHIMERA_SHOT               = 677,   // Level 60  Spell ID: 63065
+    HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_SHOT             = 691,   // Level 60  Spell ID: 63066
+    HUNTER_MAJOR_GLYPH_OF_KILL_SHOT                  = 692,   // Level 71  Spell ID: 63067
+    HUNTER_MAJOR_GLYPH_OF_EXPLOSIVE_TRAP             = 693,   // Level 34  Spell ID: 63068
+    HUNTER_MAJOR_GLYPH_OF_SCATTER_SHOT               = 694,   // Level 20  Spell ID: 63069
+    HUNTER_MAJOR_GLYPH_OF_RAPTOR_STRIKE              = 695,   // Level 15  Spell ID: 63086
+    HUNTER_MINOR_GLYPH_OF_REVIVE_PET                 = 439,   // Level 15  Spell ID: 57866
+    HUNTER_MINOR_GLYPH_OF_MEND_PET                   = 440,   // Level 15  Spell ID: 57870
+    HUNTER_MINOR_GLYPH_OF_FEIGN_DEATH                = 441,   // Level 30  Spell ID: 57903
+    HUNTER_MINOR_GLYPH_OF_SCARE_BEAST                = 442,   // Level 15  Spell ID: 57902
+    HUNTER_MINOR_GLYPH_OF_THE_PACK                   = 443,   // Level 40  Spell ID: 57904
+    HUNTER_MINOR_GLYPH_OF_POSSESSED_STRENGTH         = 444,   // Level 15  Spell ID: 57900
+    MAGE_MAJOR_GLYPH_OF_ARCANE_EXPLOSION             = 311,   // Level 15  Spell ID: 56360
+    MAGE_MAJOR_GLYPH_OF_ARCANE_MISSILES              = 312,   // Level 15  Spell ID: 56363
+    MAGE_MAJOR_GLYPH_OF_ARCANE_POWER                 = 313,   // Level 40  Spell ID: 56381
+    MAGE_MAJOR_GLYPH_OF_BLINK                        = 314,   // Level 20  Spell ID: 56365
+    MAGE_MAJOR_GLYPH_OF_EVOCATION                    = 315,   // Level 20  Spell ID: 56380
+    MAGE_MAJOR_GLYPH_OF_FIREBALL                     = 316,   // Level 15  Spell ID: 56368
+    MAGE_MAJOR_GLYPH_OF_FIRE_BLAST                   = 317,   // Level 15  Spell ID: 56369
+    MAGE_MAJOR_GLYPH_OF_FROST_NOVA                   = 318,   // Level 15  Spell ID: 56376
+    MAGE_MAJOR_GLYPH_OF_FROSTBOLT                    = 319,   // Level 15  Spell ID: 56370
+    MAGE_MAJOR_GLYPH_OF_ICE_ARMOR                    = 320,   // Level 15  Spell ID: 56384
+    MAGE_MAJOR_GLYPH_OF_ICE_BLOCK                    = 321,   // Level 30  Spell ID: 56372
+    MAGE_MAJOR_GLYPH_OF_ICE_LANCE                    = 322,   // Level 66  Spell ID: 56377
+    MAGE_MAJOR_GLYPH_OF_ICY_VEINS                    = 323,   // Level 20  Spell ID: 56374
+    MAGE_MAJOR_GLYPH_OF_SCORCH                       = 324,   // Level 20  Spell ID: 56371
+    MAGE_MAJOR_GLYPH_OF_INVISIBILITY                 = 325,   // Level 68  Spell ID: 56366
+    MAGE_MAJOR_GLYPH_OF_MAGE_ARMOR                   = 326,   // Level 34  Spell ID: 56383
+    MAGE_MAJOR_GLYPH_OF_MANA_GEM                     = 327,   // Level 30  Spell ID: 56367
+    MAGE_MAJOR_GLYPH_OF_MOLTEN_ARMOR                 = 328,   // Level 62  Spell ID: 56382
+    MAGE_MAJOR_GLYPH_OF_POLYMORPH                    = 329,   // Level 15  Spell ID: 56375
+    MAGE_MAJOR_GLYPH_OF_REMOVE_CURSE                 = 330,   // Level 18  Spell ID: 56364
+    MAGE_MAJOR_GLYPH_OF_WATER_ELEMENTAL              = 331,   // Level 50  Spell ID: 56373
+    MAGE_MAJOR_GLYPH_OF_FROSTFIRE                    = 591,   // Level 75  Spell ID: 61205
+    MAGE_MAJOR_GLYPH_OF_ARCANE_BLAST                 = 651,   // Level 64  Spell ID: 62210
+    MAGE_MAJOR_GLYPH_OF_DEEP_FREEZE                  = 696,   // Level 60  Spell ID: 63090
+    MAGE_MAJOR_GLYPH_OF_LIVING_BOMB                  = 697,   // Level 60  Spell ID: 63091
+    MAGE_MAJOR_GLYPH_OF_ARCANE_BARRAGE               = 698,   // Level 60  Spell ID: 63092
+    MAGE_MAJOR_GLYPH_OF_MIRROR_IMAGE                 = 699,   // Level 80  Spell ID: 63093
+    MAGE_MAJOR_GLYPH_OF_ICE_BARRIER                  = 700,   // Level 46  Spell ID: 63095
+    MAGE_MAJOR_GLYPH_OF_ETERNAL_WATER                = 871,   // Level 50  Spell ID: 70937
+    MAGE_MINOR_GLYPH_OF_ARCANE_INTELLECT             = 445,   // Level 15  Spell ID: 57924
+    MAGE_MINOR_GLYPH_OF_BLAST_WAVE                   = 611,   // Level 70  Spell ID: 62126
+    MAGE_MINOR_GLYPH_OF_FIRE_WARD                    = 446,   // Level 20  Spell ID: 57926
+    MAGE_MINOR_GLYPH_OF_FROST_WARD                   = 447,   // Level 22  Spell ID: 57927
+    MAGE_MINOR_GLYPH_OF_FROST_ARMOR                  = 448,   // Level 15  Spell ID: 57928
+    MAGE_MINOR_GLYPH_OF_THE_PENGUIN                  = 450,   // Level 15  Spell ID: 52648
+    MAGE_MINOR_GLYPH_OF_SLOW_FALL                    = 451,   // Level 15  Spell ID: 57925
+    PALADIN_MAJOR_GLYPH_OF_JUDGEMENT                 = 183,   // Level 15  Spell ID: 54922
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_COMMAND           = 184,   // Level 20  Spell ID: 54925
+    PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_JUSTICE         = 185,   // Level 15  Spell ID: 54923
+    PALADIN_MAJOR_GLYPH_OF_SPIRITUAL_ATTUNEMENT      = 186,   // Level 18  Spell ID: 54924
+    PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_WRATH           = 187,   // Level 44  Spell ID: 54926
+    PALADIN_MAJOR_GLYPH_OF_CRUSADER_STRIKE           = 188,   // Level 20  Spell ID: 54927
+    PALADIN_MAJOR_GLYPH_OF_CONSECRATION              = 189,   // Level 20  Spell ID: 54928
+    PALADIN_MAJOR_GLYPH_OF_RIGHTEOUS_DEFENSE         = 190,   // Level 15  Spell ID: 54929
+    PALADIN_MAJOR_GLYPH_OF_AVENGERS_SHIELD           = 191,   // Level 50  Spell ID: 54930
+    PALADIN_MAJOR_GLYPH_OF_TURN_EVIL                 = 192,   // Level 24  Spell ID: 54931
+    PALADIN_MAJOR_GLYPH_OF_EXORCISM                  = 193,   // Level 20  Spell ID: 54934
+    PALADIN_MAJOR_GLYPH_OF_CLEANSING                 = 194,   // Level 35  Spell ID: 54935
+    PALADIN_MAJOR_GLYPH_OF_FLASH_OF_LIGHT            = 195,   // Level 20  Spell ID: 54936
+    PALADIN_MAJOR_GLYPH_OF_HOLY_LIGHT                = 196,   // Level 15  Spell ID: 54937
+    PALADIN_MAJOR_GLYPH_OF_AVENGING_WRATH            = 197,   // Level 70  Spell ID: 54938
+    PALADIN_MAJOR_GLYPH_OF_DIVINITY                  = 198,   // Level 15  Spell ID: 54939
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_WISDOM            = 199,   // Level 38  Spell ID: 54940
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_LIGHT             = 200,   // Level 30  Spell ID: 54943
+    PALADIN_MAJOR_GLYPH_OF_HOLY_WRATH                = 559,   // Unknown   Spell ID: 56420
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_RIGHTEOUSNESS     = 560,   // Level 50  Spell ID: 56414
+    PALADIN_MAJOR_GLYPH_OF_SEAL_OF_VENGEANCE         = 561,   // Level 50  Spell ID: 56416
+    PALADIN_MAJOR_GLYPH_OF_BEACON_OF_LIGHT           = 701,   // Level 60  Spell ID: 63218
+    PALADIN_MAJOR_GLYPH_OF_HAMMER_OF_THE_RIGHTEOUS   = 702,   // Level 60  Spell ID: 63219
+    PALADIN_MAJOR_GLYPH_OF_DIVINE_STORM              = 703,   // Level 60  Spell ID: 63220
+    PALADIN_MAJOR_GLYPH_OF_SHIELD_OF_RIGHTEOUSNESS   = 704,   // Level 75  Spell ID: 63222
+    PALADIN_MAJOR_GLYPH_OF_DIVINE_PLEA               = 705,   // Level 71  Spell ID: 63223
+    PALADIN_MAJOR_GLYPH_OF_HOLY_SHOCK                = 706,   // Level 40  Spell ID: 63224
+    PALADIN_MAJOR_GLYPH_OF_SALVATION                 = 707,   // Level 26  Spell ID: 63225
+    PALADIN_MINOR_GLYPH_OF_BLESSING_OF_KINGS         = 452,   // Level 20  Spell ID: 57937
+    PALADIN_MINOR_GLYPH_OF_BLESSING_OF_MIGHT         = 453,   // Level 15  Spell ID: 57958
+    PALADIN_MINOR_GLYPH_OF_BLESSING_OF_WISDOM        = 454,   // Level 15  Spell ID: 57979
+    PALADIN_MINOR_GLYPH_OF_LAY_ON_HANDS              = 455,   // Level 15  Spell ID: 57955
+    PALADIN_MINOR_GLYPH_OF_SENSE_UNDEAD              = 456,   // Level 20  Spell ID: 57947
+    PALADIN_MINOR_GLYPH_OF_THE_WISE                  = 457,   // Level 15  Spell ID: 57954
+    PRIEST_MAJOR_GLYPH_OF_CIRCLE_OF_HEALING          = 251,   // Level 50  Spell ID: 55675
+    PRIEST_MAJOR_GLYPH_OF_DISPEL_MAGIC               = 252,   // Level 18  Spell ID: 55677
+    PRIEST_MAJOR_GLYPH_OF_FADE                       = 253,   // Level 15  Spell ID: 55684
+    PRIEST_MAJOR_GLYPH_OF_FEAR_WARD                  = 254,   // Level 20  Spell ID: 55678
+    PRIEST_MAJOR_GLYPH_OF_FLASH_HEAL                 = 255,   // Level 20  Spell ID: 55679
+    PRIEST_MAJOR_GLYPH_OF_HOLY_NOVA                  = 256,   // Level 20  Spell ID: 55683
+    PRIEST_MAJOR_GLYPH_OF_INNER_FIRE                 = 257,   // Level 15  Spell ID: 55686
+    PRIEST_MAJOR_GLYPH_OF_LIGHTWELL                  = 258,   // Level 40  Spell ID: 55673
+    PRIEST_MAJOR_GLYPH_OF_MASS_DISPEL                = 259,   // Level 70  Spell ID: 55691
+    PRIEST_MAJOR_GLYPH_OF_MIND_CONTROL               = 260,   // Level 30  Spell ID: 55688
+    PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_PAIN           = 261,   // Level 15  Spell ID: 55681
+    PRIEST_MAJOR_GLYPH_OF_SHADOW                     = 262,   // Level 20  Spell ID: 55689
+    PRIEST_MAJOR_GLYPH_OF_POWER_WORD_SHIELD          = 263,   // Level 15  Spell ID: 55672
+    PRIEST_MAJOR_GLYPH_OF_PRAYER_OF_HEALING          = 264,   // Level 30  Spell ID: 55680
+    PRIEST_MAJOR_GLYPH_OF_PSYCHIC_SCREAM             = 265,   // Level 15  Spell ID: 55676
+    PRIEST_MAJOR_GLYPH_OF_RENEW                      = 266,   // Level 15  Spell ID: 55674
+    PRIEST_MAJOR_GLYPH_OF_SCOURGE_IMPRISONMENT       = 267,   // Level 20  Spell ID: 55690
+    PRIEST_MAJOR_GLYPH_OF_SHADOW_WORD_DEATH          = 268,   // Level 62  Spell ID: 55682
+    PRIEST_MAJOR_GLYPH_OF_MIND_FLAY                  = 269,   // Level 20  Spell ID: 55687
+    PRIEST_MAJOR_GLYPH_OF_SMITE                      = 270,   // Level 15  Spell ID: 55692
+    PRIEST_MAJOR_GLYPH_OF_SPIRIT_OF_REDEMPTION       = 271,   // Level 30  Spell ID: 55685
+    PRIEST_MAJOR_GLYPH_OF_DISPERSION                 = 708,   // Level 60  Spell ID: 63229
+    PRIEST_MAJOR_GLYPH_OF_GUARDIAN_SPIRIT            = 709,   // Level 60  Spell ID: 63231
+    PRIEST_MAJOR_GLYPH_OF_PENANCE                    = 710,   // Level 60  Spell ID: 63235
+    PRIEST_MAJOR_GLYPH_OF_MIND_SEAR                  = 711,   // Level 75  Spell ID: 63237
+    PRIEST_MAJOR_GLYPH_OF_HYMN_OF_HOPE               = 712,   // Level 60  Spell ID: 63246
+    PRIEST_MAJOR_GLYPH_OF_PAIN_SUPPRESSION           = 713,   // Level 50  Spell ID: 63248
+    PRIEST_MINOR_GLYPH_OF_FADING                     = 458,   // Level 15  Spell ID: 57985
+    PRIEST_MINOR_GLYPH_OF_LEVITATE                   = 459,   // Level 34  Spell ID: 57987
+    PRIEST_MINOR_GLYPH_OF_FORTITUDE                  = 460,   // Level 15  Spell ID: 58009
+    PRIEST_MINOR_GLYPH_OF_SHACKLE_UNDEAD             = 461,   // Level 20  Spell ID: 57986
+    PRIEST_MINOR_GLYPH_OF_SHADOW_PROTECTION          = 462,   // Level 30  Spell ID: 58015
+    PRIEST_MINOR_GLYPH_OF_SHADOWFIEND                = 463,   // Level 66  Spell ID: 58228
+    ROGUE_MAJOR_GLYPH_OF_ADRENALINE_RUSH             = 391,   // Level 40  Spell ID: 56808
+    ROGUE_MAJOR_GLYPH_OF_AMBUSH                      = 392,   // Level 18  Spell ID: 56813
+    ROGUE_MAJOR_GLYPH_OF_BACKSTAB                    = 393,   // Level 15  Spell ID: 56800
+    ROGUE_MAJOR_GLYPH_OF_BLADE_FLURRY                = 394,   // Level 30  Spell ID: 56818
+    ROGUE_MAJOR_GLYPH_OF_CRIPPLING_POISON            = 395,   // Level 20  Spell ID: 56820
+    ROGUE_MAJOR_GLYPH_OF_DEADLY_THROW                = 396,   // Level 64  Spell ID: 56806
+    ROGUE_MAJOR_GLYPH_OF_EVASION                     = 397,   // Level 15  Spell ID: 56799
+    ROGUE_MAJOR_GLYPH_OF_EVISCERATE                  = 398,   // Level 15  Spell ID: 56802
+    ROGUE_MAJOR_GLYPH_OF_EXPOSE_ARMOR                = 399,   // Level 15  Spell ID: 56803
+    ROGUE_MAJOR_GLYPH_OF_FEINT                       = 400,   // Level 16  Spell ID: 56804
+    ROGUE_MAJOR_GLYPH_OF_GARROTE                     = 401,   // Level 15  Spell ID: 56812
+    ROGUE_MAJOR_GLYPH_OF_GHOSTLY_STRIKE              = 402,   // Level 20  Spell ID: 56814
+    ROGUE_MAJOR_GLYPH_OF_GOUGE                       = 403,   // Level 15  Spell ID: 56809
+    ROGUE_MAJOR_GLYPH_OF_HEMORRHAGE                  = 404,   // Level 30  Spell ID: 56807
+    ROGUE_MAJOR_GLYPH_OF_PREPARATION                 = 405,   // Level 30  Spell ID: 56819
+    ROGUE_MAJOR_GLYPH_OF_RUPTURE                     = 406,   // Level 20  Spell ID: 56801
+    ROGUE_MAJOR_GLYPH_OF_SAP                         = 407,   // Level 15  Spell ID: 56798
+    ROGUE_MAJOR_GLYPH_OF_VIGOR                       = 408,   // Level 70  Spell ID: 56805
+    ROGUE_MAJOR_GLYPH_OF_SINISTER_STRIKE             = 409,   // Level 15  Spell ID: 56821
+    ROGUE_MAJOR_GLYPH_OF_SLICE_AND_DICE              = 410,   // Level 15  Spell ID: 56810
+    ROGUE_MAJOR_GLYPH_OF_SPRINT                      = 411,   // Level 15  Spell ID: 56811
+    ROGUE_MAJOR_GLYPH_OF_HUNGER_FOR_BLOOD            = 714,   // Level 60  Spell ID: 63249
+    ROGUE_MAJOR_GLYPH_OF_KILLING_SPREE               = 715,   // Level 60  Spell ID: 63252
+    ROGUE_MAJOR_GLYPH_OF_SHADOW_DANCE                = 716,   // Level 60  Spell ID: 63253
+    ROGUE_MAJOR_GLYPH_OF_FAN_OF_KNIVES               = 731,   // Level 80  Spell ID: 63254
+    ROGUE_MAJOR_GLYPH_OF_TRICKS_OF_THE_TRADE         = 732,   // Level 75  Spell ID: 63256
+    ROGUE_MAJOR_GLYPH_OF_MUTILATE                    = 733,   // Level 50  Spell ID: 63268
+    ROGUE_MAJOR_GLYPH_OF_CLOAK_OF_SHADOWS            = 734,   // Level 66  Spell ID: 63269
+    ROGUE_MINOR_GLYPH_OF_DISTRACT                    = 464,   // Level 22  Spell ID: 58032
+    ROGUE_MINOR_GLYPH_OF_PICK_LOCK                   = 465,   // Level 16  Spell ID: 58027
+    ROGUE_MINOR_GLYPH_OF_PICK_POCKET                 = 466,   // Level 15  Spell ID: 58017
+    ROGUE_MINOR_GLYPH_OF_SAFE_FALL                   = 467,   // Level 40  Spell ID: 58033
+    ROGUE_MINOR_GLYPH_OF_BLURRED_SPEED               = 468,   // Level 15  Spell ID: 58039
+    ROGUE_MINOR_GLYPH_OF_VANISH                      = 469,   // Level 22  Spell ID: 58038
+    SHAMAN_MAJOR_GLYPH_OF_WATER_MASTERY              = 211,   // Level 20  Spell ID: 55436
+    SHAMAN_MAJOR_GLYPH_OF_CHAIN_HEAL                 = 212,   // Level 40  Spell ID: 55437
+    SHAMAN_MAJOR_GLYPH_OF_CHAIN_LIGHTNING            = 213,   // Level 32  Spell ID: 55449
+    SHAMAN_MAJOR_GLYPH_OF_LAVA                       = 214,   // Level 66  Spell ID: 55454
+    SHAMAN_MAJOR_GLYPH_OF_SHOCKING                   = 215,   // Unknown   Spell ID: 55442
+    SHAMAN_MAJOR_GLYPH_OF_EARTHLIVING_WEAPON         = 216,   // Level 30  Spell ID: 55439
+    SHAMAN_MAJOR_GLYPH_OF_FIRE_ELEMENTAL_TOTEM       = 217,   // Level 68  Spell ID: 55455
+    SHAMAN_MAJOR_GLYPH_OF_FIRE_NOVA                  = 218,   // Level 15  Spell ID: 55450
+    SHAMAN_MAJOR_GLYPH_OF_FLAME_SHOCK                = 219,   // Level 15  Spell ID: 55447
+    SHAMAN_MAJOR_GLYPH_OF_FLAMETONGUE_WEAPON         = 220,   // Level 15  Spell ID: 55451
+    SHAMAN_MAJOR_GLYPH_OF_FROST_SHOCK                = 221,   // Level 20  Spell ID: 55443
+    SHAMAN_MAJOR_GLYPH_OF_HEALING_STREAM_TOTEM       = 222,   // Level 20  Spell ID: 55456
+    SHAMAN_MAJOR_GLYPH_OF_HEALING_WAVE               = 223,   // Level 15  Spell ID: 55440
+    SHAMAN_MAJOR_GLYPH_OF_LESSER_HEALING_WAVE        = 224,   // Level 20  Spell ID: 55438
+    SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_SHIELD           = 225,   // Level 15  Spell ID: 55448
+    SHAMAN_MAJOR_GLYPH_OF_LIGHTNING_BOLT             = 226,   // Level 15  Spell ID: 55453
+    SHAMAN_MAJOR_GLYPH_OF_STORMSTRIKE                = 228,   // Level 40  Spell ID: 55446
+    SHAMAN_MAJOR_GLYPH_OF_LAVA_LASH                  = 229,   // Level 15  Spell ID: 55444
+    SHAMAN_MAJOR_GLYPH_OF_ELEMENTAL_MASTERY          = 230,   // Level 50  Spell ID: 55452
+    SHAMAN_MAJOR_GLYPH_OF_WINDFURY_WEAPON            = 231,   // Level 30  Spell ID: 55445
+    SHAMAN_MAJOR_GLYPH_OF_THUNDER                    = 735,   // Level 60  Spell ID: 63270
+    SHAMAN_MAJOR_GLYPH_OF_FERAL_SPIRIT               = 736,   // Level 60  Spell ID: 63271
+    SHAMAN_MAJOR_GLYPH_OF_RIPTIDE                    = 737,   // Level 60  Spell ID: 63273
+    SHAMAN_MAJOR_GLYPH_OF_EARTH_SHIELD               = 751,   // Level 50  Spell ID: 63279
+    SHAMAN_MAJOR_GLYPH_OF_TOTEM_OF_WRATH             = 752,   // Level 50  Spell ID: 63280
+    SHAMAN_MAJOR_GLYPH_OF_HEX                        = 753,   // Level 80  Spell ID: 63291
+    SHAMAN_MAJOR_GLYPH_OF_STONECLAW_TOTEM            = 754,   // Level 15  Spell ID: 63298
+    SHAMAN_MINOR_GLYPH_OF_ASTRAL_RECALL              = 470,   // Level 30  Spell ID: 58058
+    SHAMAN_MINOR_GLYPH_OF_RENEWED_LIFE               = 473,   // Level 30  Spell ID: 58059
+    SHAMAN_MINOR_GLYPH_OF_WATER_BREATHING            = 474,   // Level 22  Spell ID: 58055
+    SHAMAN_MINOR_GLYPH_OF_WATER_SHIELD               = 475,   // Level 20  Spell ID: 58063
+    SHAMAN_MINOR_GLYPH_OF_WATER_WALKING              = 476,   // Level 28  Spell ID: 58057
+    SHAMAN_MINOR_GLYPH_OF_GHOST_WOLF                 = 552,   // Level 16  Spell ID: 59289
+    SHAMAN_MINOR_GLYPH_OF_THUNDERSTORM               = 612,   // Level 70  Spell ID: 62132
+    WARLOCK_MAJOR_GLYPH_OF_INCINERATE                = 272,   // Unknown   Spell ID: 56242
+    WARLOCK_MAJOR_GLYPH_OF_CONFLAGRATE               = 273,   // Level 40  Spell ID: 56235
+    WARLOCK_MAJOR_GLYPH_OF_CORRUPTION                = 274,   // Level 15  Spell ID: 56218
+    WARLOCK_MAJOR_GLYPH_OF_CURSE_OF_AGONY            = 275,   // Level 15  Spell ID: 56241
+    WARLOCK_MAJOR_GLYPH_OF_DEATH_COIL                = 276,   // Level 42  Spell ID: 56232
+    WARLOCK_MAJOR_GLYPH_OF_FEAR                      = 277,   // Level 15  Spell ID: 56244
+    WARLOCK_MAJOR_GLYPH_OF_FELGUARD                  = 278,   // Level 50  Spell ID: 56246
+    WARLOCK_MAJOR_GLYPH_OF_FELHUNTER                 = 279,   // Level 30  Spell ID: 56249
+    WARLOCK_MAJOR_GLYPH_OF_HEALTH_FUNNEL             = 280,   // Level 15  Spell ID: 56238
+    WARLOCK_MAJOR_GLYPH_OF_HEALTHSTONE               = 281,   // Level 15  Spell ID: 56224
+    WARLOCK_MAJOR_GLYPH_OF_HOWL_OF_TERROR            = 282,   // Level 40  Spell ID: 56217
+    WARLOCK_MAJOR_GLYPH_OF_IMMOLATE                  = 283,   // Level 15  Spell ID: 56228
+    WARLOCK_MAJOR_GLYPH_OF_IMP                       = 284,   // Level 15  Spell ID: 56248
+    WARLOCK_MAJOR_GLYPH_OF_SEARING_PAIN              = 285,   // Level 18  Spell ID: 56226
+    WARLOCK_MAJOR_GLYPH_OF_SHADOW_BOLT               = 286,   // Level 15  Spell ID: 56240
+    WARLOCK_MAJOR_GLYPH_OF_SHADOWBURN                = 287,   // Level 20  Spell ID: 56229
+    WARLOCK_MAJOR_GLYPH_OF_SIPHON_LIFE               = 288,   // Level 30  Spell ID: 56216
+    WARLOCK_MAJOR_GLYPH_OF_SOULSTONE                 = 289,   // Level 18  Spell ID: 56231
+    WARLOCK_MAJOR_GLYPH_OF_SUCCUBUS                  = 290,   // Level 26  Spell ID: 56250
+    WARLOCK_MAJOR_GLYPH_OF_UNSTABLE_AFFLICTION       = 291,   // Level 50  Spell ID: 56233
+    WARLOCK_MAJOR_GLYPH_OF_VOIDWALKER                = 292,   // Level 15  Spell ID: 56247
+    WARLOCK_MAJOR_GLYPH_OF_HAUNT                     = 755,   // Level 60  Spell ID: 63302
+    WARLOCK_MAJOR_GLYPH_OF_METAMORPHOSIS             = 756,   // Level 60  Spell ID: 63303
+    WARLOCK_MAJOR_GLYPH_OF_CHAOS_BOLT                = 757,   // Level 60  Spell ID: 63304
+    WARLOCK_MAJOR_GLYPH_OF_DEMONIC_CIRCLE            = 758,   // Level 80  Spell ID: 63309
+    WARLOCK_MAJOR_GLYPH_OF_SHADOWFLAME               = 759,   // Level 75  Spell ID: 63310
+    WARLOCK_MAJOR_GLYPH_OF_LIFE_TAP                  = 760,   // Level 15  Spell ID: 63320
+    WARLOCK_MAJOR_GLYPH_OF_SOUL_LINK                 = 761,   // Level 20  Spell ID: 63312
+    WARLOCK_MAJOR_GLYPH_OF_QUICK_DECAY               = 911,   // Level 15  Spell ID: 70947
+    WARLOCK_MINOR_GLYPH_OF_UNENDING_BREATH           = 477,   // Level 15  Spell ID: 58079
+    WARLOCK_MINOR_GLYPH_OF_DRAIN_SOUL                = 478,   // Level 15  Spell ID: 58070
+    WARLOCK_MINOR_GLYPH_OF_KILROGG                   = 479,   // Level 22  Spell ID: 58081
+    WARLOCK_MINOR_GLYPH_OF_ENSLAVE_DEMON             = 481,   // Level 30  Spell ID: 58107
+    WARLOCK_MINOR_GLYPH_OF_SOULS                     = 482,   // Level 68  Spell ID: 58094
+    WARRIOR_MAJOR_GLYPH_OF_MORTAL_STRIKE             = 489,   // Level 40  Spell ID: 58368
+    WARRIOR_MAJOR_GLYPH_OF_BLOODTHIRST               = 490,   // Level 40  Spell ID: 58369
+    WARRIOR_MAJOR_GLYPH_OF_RAPID_CHARGE              = 491,   // Level 15  Spell ID: 58355
+    WARRIOR_MAJOR_GLYPH_OF_CLEAVING                  = 492,   // Level 20  Spell ID: 58366
+    WARRIOR_MAJOR_GLYPH_OF_DEVASTATE                 = 493,   // Level 40  Spell ID: 58388
+    WARRIOR_MAJOR_GLYPH_OF_EXECUTION                 = 494,   // Level 24  Spell ID: 58367
+    WARRIOR_MAJOR_GLYPH_OF_HAMSTRING                 = 495,   // Level 15  Spell ID: 58372
+    WARRIOR_MAJOR_GLYPH_OF_HEROIC_STRIKE             = 496,   // Level 15  Spell ID: 58357
+    WARRIOR_MAJOR_GLYPH_OF_INTERVENE                 = 497,   // Level 70  Spell ID: 58377
+    WARRIOR_MAJOR_GLYPH_OF_BARBARIC_INSULTS          = 498,   // Level 16  Spell ID: 58365
+    WARRIOR_MAJOR_GLYPH_OF_OVERPOWER                 = 499,   // Level 15  Spell ID: 58386
+    WARRIOR_MAJOR_GLYPH_OF_RENDING                   = 500,   // Level 15  Spell ID: 58385
+    WARRIOR_MAJOR_GLYPH_OF_REVENGE                   = 501,   // Level 15  Spell ID: 58364
+    WARRIOR_MAJOR_GLYPH_OF_BLOCKING                  = 502,   // Level 40  Spell ID: 58375
+    WARRIOR_MAJOR_GLYPH_OF_LAST_STAND                = 503,   // Level 20  Spell ID: 58376
+    WARRIOR_MAJOR_GLYPH_OF_SUNDER_ARMOR              = 504,   // Level 15  Spell ID: 58387
+    WARRIOR_MAJOR_GLYPH_OF_SWEEPING_STRIKES          = 505,   // Level 30  Spell ID: 58384
+    WARRIOR_MAJOR_GLYPH_OF_TAUNT                     = 506,   // Level 15  Spell ID: 58353
+    WARRIOR_MAJOR_GLYPH_OF_RESONATING_POWER          = 507,   // Level 15  Spell ID: 58356
+    WARRIOR_MAJOR_GLYPH_OF_VICTORY_RUSH              = 508,   // Level 62  Spell ID: 58382
+    WARRIOR_MAJOR_GLYPH_OF_WHIRLWIND                 = 509,   // Level 36  Spell ID: 58370
+    WARRIOR_MAJOR_GLYPH_OF_BLADESTORM                = 762,   // Level 60  Spell ID: 63324
+    WARRIOR_MAJOR_GLYPH_OF_SHOCKWAVE                 = 763,   // Level 60  Spell ID: 63325
+    WARRIOR_MAJOR_GLYPH_OF_VIGILANCE                 = 764,   // Level 40  Spell ID: 63326
+    WARRIOR_MAJOR_GLYPH_OF_ENRAGED_REGENERATION      = 765,   // Level 75  Spell ID: 63327
+    WARRIOR_MAJOR_GLYPH_OF_SPELL_REFLECTION          = 766,   // Level 64  Spell ID: 63328
+    WARRIOR_MAJOR_GLYPH_OF_SHIELD_WALL               = 767,   // Level 28  Spell ID: 63329
+    WARRIOR_MINOR_GLYPH_OF_BATTLE                    = 483,   // Level 15  Spell ID: 58095
+    WARRIOR_MINOR_GLYPH_OF_BLOODRAGE                 = 484,   // Level 15  Spell ID: 58096
+    WARRIOR_MINOR_GLYPH_OF_CHARGE                    = 485,   // Level 15  Spell ID: 58097
+    WARRIOR_MINOR_GLYPH_OF_MOCKING_BLOW              = 486,   // Level 16  Spell ID: 58099
+    WARRIOR_MINOR_GLYPH_OF_THUNDER_CLAP              = 487,   // Level 15  Spell ID: 58098
+    WARRIOR_MINOR_GLYPH_OF_ENDURING_VICTORY          = 488,   // Level 62  Spell ID: 58104
+    WARRIOR_MINOR_GLYPH_OF_COMMAND                   = 851,   // Level 68  Spell ID: 68164
+};
+
+/**
+ * So they're kept track of somewhere... but let's comment them out.
+   enum GlyphsUnknown
+   {
+    UNKNOWN_MAJOR_GLYPH_OF_NATURAL_FORCE             = 2,     // Unknown   Spell ID: 52084
+    UNKNOWN_UNKNOWN_GLYPH_CRUELTY                    = 21,    // Unknown   Spell ID: 12320
+    UNKNOWN_UNKNOWN_GLYPH_ANTICIPATION               = 22,    // Unknown   Spell ID: 12297
+    UNKNOWN_UNKNOWN_GLYPH_VENOMOUS_MANA              = 61,    // Unknown   Spell ID: 46831
+    UNKNOWN_MINOR_GLYPH_OF_NATURAL_FORCE             = 81,    // Unknown   Spell ID: 52084
+    UNKNOWN_UNKNOWN_GLYPH_GLYPH_OF_MOONFIRE          = 82,    // Unknown   Spell ID: 52085
+    UNKNOWN_MAJOR_                                   = 101,   // Unknown   Spell ID: NULL
+    UNKNOWN_UNKNOWN_GLYPH_COPY_OF_HOLY_BOLT          = 121,   // Unknown   Spell ID: 46487
+    UNKNOWN_MINOR_GLYPH_OF_THE_WHITE_BEAR            = 141,   // Unknown   Spell ID: 54292
+    UNKNOWN_MAJOR_GLYPH_OF_GROWLING                  = 163,   // Unknown   Spell ID: 54812
+    UNKNOWN_MINOR_GLYPH_OF_THE_RED_LYNX              = 182,   // Unknown   Spell ID: 54912
+    UNKNOWN_MAJOR_GLYPH_OF_LAVA                      = 214,   // Unknown   Spell ID: 55454
+    UNKNOWN_MAJOR_GLYPH_OF_MANA_TIDE                 = 227,   // Unknown   Spell ID: 55441
+    UNKNOWN_MAJOR_GLYPH_OF_MOLTEN_ARMOR              = 328,   // Unknown   Spell ID: 56382
+    UNKNOWN_MAJOR_GLYPH_OF_THE_HAWK                  = 363,   // Unknown   Spell ID: 56856
+    UNKNOWN_MINOR_GLYPH_OF_THE_FOREST_LYNX           = 436,   // Unknown   Spell ID: 58133
+    UNKNOWN_MINOR_GLYPH_OF_THE_BLACK_BEAR            = 438,   // Unknown   Spell ID: 58132
+    UNKNOWN_MINOR_GLYPH_OF_THE_BEAR_CUB              = 449,   // Unknown   Spell ID: 58136
+    UNKNOWN_MINOR_GLYPH_OF_THE_ARCTIC_WOLF           = 471,   // Unknown   Spell ID: 58135
+    UNKNOWN_MINOR_GLYPH_OF_THE_BLACK_WOLF            = 472,   // Unknown   Spell ID: 58134
+    UNKNOWN_MINOR_GLYPH_OF_CURSE_OF_EXHAUSION        = 480,   // Unknown   Spell ID: 58080
+    UNKNOWN_MINOR_GLYPH_OF_BLAST_WAVE                = 611,   // Unknown   Spell ID: 62126
+    UNKNOWN_MAJOR_GLYPH_OF_ENVENOM                   = 791,   // Unknown   Spell ID: 64199
+   };*/
+
+// TODO: replace this with mangos data... I mean this has GOT to be out there somewhere already
+//       and when you do, don't forget to change everywhere (including the sql file)
+// But in the meantime, value + 412 = TabId.
+enum ClassesCombatPets
+{
+    CLASS_PET_CUNNING  = -1,
+    CLASS_PET_FEROCITY = -2,
+    CLASS_PET_TENACITY = -3
+};
+
+// reasons for why pet tame may fail
+// in fact, these are also used elsewhere
+enum PetTameFailureReason
+{
+    PETTAME_INVALIDCREATURE         = 1,
+    PETTAME_TOOMANY                 = 2,
+    PETTAME_CREATUREALREADYOWNED    = 3,
+    PETTAME_NOTTAMEABLE             = 4,
+    PETTAME_ANOTHERSUMMONACTIVE     = 5,
+    PETTAME_UNITSCANTTAME           = 6,
+    PETTAME_NOPETAVAILABLE          = 7,                    // not used in taming
+    PETTAME_INTERNALERROR           = 8,
+    PETTAME_TOOHIGHLEVEL            = 9,
+    PETTAME_DEAD                    = 10,                   // not used in taming
+    PETTAME_NOTDEAD                 = 11,                   // not used in taming
+    PETTAME_CANTCONTROLEXOTIC       = 12,                   // 3.x
+    PETTAME_UNKNOWNERROR            = 13
+};
+
+enum TalentSpecPurpose
+{
+    TSP_NONE                        = 0x00000000,  // should probably error out?
+    TSP_PVE_TANK                    = 0x00000001,
+    TSP_PVE_DPS                     = 0x00000002,
+    TSP_PVE_LEVELING                = 0x00000004,
+    TSP_PVE_HEALING                 = 0x00000008,
+    TSP_PVE_INSTANCING              = 0x00000010,
+    TSP_PVE_RAID                    = 0x00000020,
+    TSP_PVE_ALL                     = 0x0000FFFF,  // Highly recommend AGAINST using this
+    TSP_PVP_TANK                    = 0x00010000,
+    TSP_PVP_DPS                     = 0x00020000,
+    TSP_PVP_LEVELING                = 0x00040000,
+    TSP_PVP_TWINK                   = 0x00080000,
+    TSP_PVP_HEALING                 = 0x00100000,
+    TSP_PVP_ARENA                   = 0x00200000,
+    TSP_PVP_ALL                     = 0xFFFF0000   // Highly recommend AGAINST using this
+};
+
+enum MainSpec
+{
+    MAGE_SPEC_FIRE              = 41,
+    MAGE_SPEC_FROST             = 61,
+    MAGE_SPEC_ARCANE            = 81,
+    WARRIOR_SPEC_ARMS           = 161,
+    WARRIOR_APEC_PROTECTION     = 163,
+    WARRIOR_SPEC_FURY           = 164,
+    ROGUE_SPEC_COMBAT           = 181,
+    ROGUE_SPEC_ASSASSINATION    = 182,
+    ROGUE_SPEC_SUBTELTY         = 183,
+    PRIEST_SPEC_DISCIPLINE      = 201,
+    PRIEST_SPEC_HOLY            = 202,
+    PRIEST_SPEC_SHADOW          = 203,
+    SHAMAN_SPEC_ELEMENTAL       = 261,
+    SHAMAN_SPEC_RESTORATION     = 262,
+    SHAMAN_SPEC_ENHANCEMENT     = 263,
+    DRUID_SPEC_FERAL            = 281,
+    DRUID_SPEC_RESTORATION      = 282,
+    DRUID_SPEC_BALANCE          = 283,
+    WARLOCK_SPEC_DESTRUCTION    = 301,
+    WARLOCK_SPEC_AFFLICTION     = 302,
+    WARLOCK_SPEC_DEMONOLOGY     = 303,
+    HUNTER_SPEC_BEASTMASTERY    = 361,
+    HUNTER_SPEC_SURVIVAL        = 362,
+    HUNTER_SPEC_MARKSMANSHIP    = 363,
+    PALADIN_SPEC_RETRIBUTION    = 381,
+    PALADIN_SPEC_HOLY           = 382,
+    PALADIN_SPEC_PROTECTION     = 383,
+    DEATHKNIGHT_SPEC_BLOOD      = 398,
+    DEATHKNIGHT_SPEC_FROST      = 399,
+    DEATHKNIGHT_SPEC_UNHOLY     = 400
+};
+
+struct TalentSpec
+{
+    std::string specName;
+    short specClass;
+    TalentSpecPurpose specPurpose;
+    uint16 talentId[71];
+    uint16 glyphIdMajor[3];
+    uint16 glyphIdMinor[3];
+};
+
+enum NotableItems
+{
+    // Skeleton Keys
+    SILVER_SKELETON_KEY = 15869,
+    GOLDEN_SKELETON_KEY = 15870,
+    TRUESILVER_SKELETON_KEY = 15871,
+    ARCANITE_SKELETON_KEY = 15872,
+    TITANIUM_SKELETON_KEY = 43853,
+    COBALT_SKELETON_KEY = 43854,
+    // Lock Charges
+    SMALL_SEAFORIUM_CHARGE = 4367,
+    LARGE_SEAFORIUM_CHARGE = 4398,
+    POWERFUL_SEAFORIUM_CHARGE = 18594,
+    ELEMENTAL_SEAFORIUM_CHARGE = 23819
+};
+
+class PlayerbotAI
+{
+    //friend class PlayerbotClassAI;
+public:
+    enum ScenarioType
+    {
+        SCENARIO_PVEEASY,
+        SCENARIO_PVEHARD,
+        SCENARIO_DUEL,
+        SCENARIO_PVPEASY,
+        SCENARIO_PVPHARD
+    };
+
+    enum CombatStyle
+    {
+        COMBAT_MELEE                = 0x01,             // class melee attacker
+        COMBAT_RANGED               = 0x02              // class is ranged attacker
+    };
+
+    // masters orders that should be obeyed by the AI during the updateAI routine
+    // the master will auto set the target of the bot
+    enum CombatOrderType
+    {
+        ORDERS_NONE                 = 0x00,             // no special orders given
+        ORDERS_TANK                 = 0x01,             // bind attackers by gaining threat
+        ORDERS_ASSIST               = 0x02,             // assist someone (dps type)
+        ORDERS_HEAL                 = 0x04,             // concentrate on healing (no attacks, only self defense)
+        ORDERS_NODISPEL             = 0x08,
+        ORDERS_PROTECT              = 0x10,             // combinable state: check if protectee is attacked
+        ORDERS_PASSIVE              = 0x20,             // bots do nothing
+        ORDERS_RESIST				= 0x40,				// resist a magic school(see below for types)
+        ORDERS_PRIMARY              = 0x0F,
+        ORDERS_SECONDARY            = 0xF0,
+        ORDERS_RESET                = 0xFF
+    };
+
+    enum ResistType
+    {
+        SCHOOL_NONE		= 0,
+        SCHOOL_FIRE		= 1,
+        SCHOOL_NATURE	= 2,
+        SCHOOL_FROST	= 3,
+        SCHOOL_SHADOW	= 4
+    };
+
+    enum CombatTargetType
+    {
+        TARGET_NORMAL               = 0x00,
+        TARGET_THREATEN             = 0x01
+    };
+
+    enum BotState
+    {
+        BOTSTATE_NORMAL,            // normal AI routines are processed
+        BOTSTATE_COMBAT,            // bot is in combat
+        BOTSTATE_DEAD,              // we are dead and wait for becoming ghost
+        BOTSTATE_DEADRELEASED,      // we released as ghost and wait to revive
+        BOTSTATE_LOOTING,           // looting mode, used just after combat
+        BOTSTATE_FLYING,            // bot is flying
+        BOTSTATE_ENCHANT,           // bot is enchanting
+        BOTSTATE_CRAFT,             // bot is crafting
+        BOTSTATE_TAME               // bot hunter taming
+    };
+
+    enum CollectionFlags
+    {
+        COLLECT_FLAG_NOTHING    = 0x00,     // skip looting of anything
+        COLLECT_FLAG_COMBAT     = 0x01,     // loot after combat
+        COLLECT_FLAG_QUEST      = 0x02,     // quest and needed items
+        COLLECT_FLAG_PROFESSION = 0x04,     // items related to skills
+        COLLECT_FLAG_LOOT       = 0x08,     // all loot on corpses
+        COLLECT_FLAG_SKIN       = 0x10,     // skin creatures if available
+        COLLECT_FLAG_NEAROBJECT = 0x20      // collect specified nearby object
+    };
+
+    enum MovementOrderType
+    {
+        MOVEMENT_NONE               = 0x00,
+        MOVEMENT_FOLLOW             = 0x01,
+        MOVEMENT_STAY               = 0x02
+    };
+
+    enum TaskFlags
+    {
+        NONE                        = 0x00,  // do nothing
+        SELL_ITEMS                  = 0x01,  // sell items
+        REPAIR_ITEMS                = 0x02,  // repair items
+        ADD_AUCTION                 = 0x03,  // add auction
+        REMOVE_AUCTION              = 0x04,  // remove auction
+        RESET_TALENTS               = 0x05,  // reset all talents
+        BANK_WITHDRAW               = 0x06,  // withdraw item from bank
+        BANK_DEPOSIT                = 0x07,  // deposit item in bank
+        LIST_QUEST                  = 0x08,  // list quests
+        END_QUEST                   = 0x09,  // turn in quests
+        TAKE_QUEST                  = 0x0A   // take quest
+    };
+
+    enum AnnounceFlags
+    {
+        NOTHING                     = 0x00,
+        INVENTORY_FULL              = 0x01,
+        CANT_AFFORD                 = 0x02,
+        CANT_USE_TOO_FAR            = 0x03
+    };
+
+    typedef std::pair<enum TaskFlags, uint32> taskPair;
+    typedef std::list<taskPair> BotTaskList;
+    typedef std::list<enum NPCFlags> BotNPCList;
+    typedef std::map<uint32, uint32> BotNeedItem;
+    typedef std::pair<uint32, uint32> talentPair;
+    typedef std::list<uint64> BotObjectList;
+    typedef std::list<uint32> BotEntryList;
+    typedef std::vector<uint32> BotTaxiNode;
+    typedef std::set<uint64> BotObjectSet;
+
+    // attacker query used in PlayerbotAI::FindAttacker()
+    enum ATTACKERINFOTYPE
+    {
+        AIT_NONE                    = 0x00,
+        AIT_LOWESTTHREAT            = 0x01,
+        AIT_HIGHESTTHREAT           = 0x02,
+        AIT_VICTIMSELF              = 0x04,
+        AIT_VICTIMNOTSELF           = 0x08      // !!! must use victim param in FindAttackers
+    };
+    struct AttackerInfo
+    {
+        Unit*    attacker;            // reference to the attacker
+        Unit*    victim;              // combatant's current victim
+        float threat;                 // own threat on this combatant
+        float threat2;                // highest threat not caused by bot
+        uint32 count;                 // number of units attacking
+        uint32 source;                // 1=bot, 2=master, 3=group
+    };
+    typedef std::map<uint64, AttackerInfo> AttackerInfoList;
+    typedef std::map<uint32, float> SpellRanges;
+
+    enum HELPERLINKABLES
+    {
+        HL_NONE,
+        HL_PROFESSION,
+        HL_ITEM,
+        HL_TALENT,
+        HL_SKILL,
+        HL_OPTION,
+        HL_PETAGGRO,
+        HL_QUEST,
+        HL_GAMEOBJECT,
+        HL_SPELL,
+        HL_TARGET,
+        HL_NAME,
+        HL_AUCTION,
+        HL_MAIL,
+        HL_RECIPE
+    };
+
+public:
+    PlayerbotAI(Player * const master, Player * const bot);
+    virtual ~PlayerbotAI();
+
+    // This is called from Unit.cpp and is called every second (I think)
+    void UpdateAI(const uint32 p_time);
+
+    // This is called from ChatHandler.cpp when there is an incoming message to the bot
+    // from a whisper or from the party channel
+    void HandleCommand(const std::string& text, Player& fromPlayer);
+
+    // This is called by WorldSession.cpp
+    // It provides a view of packets normally sent to the client.
+    // Since there is no client at the other end, the packets are dropped of course.
+    // For a list of opcodes that can be caught see Opcodes.cpp (SMSG_* opcodes only)
+    void HandleBotOutgoingPacket(const WorldPacket& packet);
+
+    // This is called by WorldSession.cpp
+    // when it detects that a bot is being teleported. It acknowledges to the server to complete the
+    // teleportation
+    void HandleTeleportAck();
+
+    // Returns what kind of situation we are in so the ai can react accordingly
+    ScenarioType GetScenarioType() { return m_ScenarioType; }
+
+    PlayerbotClassAI* GetClassAI() { return m_classAI; }
+    void ReloadAI();
+
+    // finds spell ID for matching substring args
+    // in priority of full text match, spells not taking reagents, and highest rank
+    uint32 getSpellId(const char* args, bool master = false) const;
+    uint32 getPetSpellId(const char* args) const;
+    // Initialize spell using rank 1 spell id
+    uint32 initSpell(uint32 spellId) const;
+    uint32 initPetSpell(uint32 spellIconId);
+
+    // extract mail ids from links
+    void extractMailIds(const std::string& text, std::list<uint32>& mailIds) const;
+
+    // extract quest ids from links
+    void extractQuestIds(const std::string& text, std::list<uint32>& questIds) const;
+
+    // extract auction ids from links
+    void extractAuctionIds(const std::string& text, std::list<uint32>& auctionIds) const;
+
+    // extracts talent ids to list
+    void extractTalentIds(const std::string& text, std::list<talentPair>& talentIds) const;
+
+    // extracts item ids from links
+    void extractItemIds(const std::string& text, std::list<uint32>& itemIds) const;
+
+    // extract spellid from links
+    void extractSpellId(const std::string& text, uint32 &spellId) const;
+
+    // extract spellids from links to list
+    void extractSpellIdList(const std::string& text, BotEntryList& m_spellsToLearn) const;
+
+    // extracts currency from a string as #g#s#c and returns the total in copper
+    uint32 extractMoney(const std::string& text) const;
+
+    // extracts gameobject info from link
+    void extractGOinfo(const std::string& text, BotObjectList& m_lootTargets) const;
+
+    // finds items in bots equipment and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInEquip(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds items in bots inventory and adds them to foundItemList, removes found items from itemIdSearchList
+    void findItemsInInv(std::list<uint32>& itemIdSearchList, std::list<Item*>& foundItemList) const;
+    // finds nearby game objects that are specified in m_collectObjects then adds them to the m_lootTargets list
+    void findNearbyGO();
+    // finds nearby creatures, whose UNIT_NPC_FLAGS match the flags specified in item list m_itemIds
+    void findNearbyCreature();
+
+    void GiveLevel(uint32 level);
+
+    // Error check the TS DB. Should only be used when admins want to verify their new TS input
+    uint32 TalentSpecDBContainsError();
+
+    // Get talent specs or counts thereof
+    uint32 GetTalentSpecsAmount();
+    uint32 GetTalentSpecsAmount(long specClass);
+    std::list<TalentSpec> GetTalentSpecs(long specClass);
+    TalentSpec GetTalentSpec(long specClass, long choice);
+    TalentSpec GetActiveTalentSpec() { return m_activeTalentSpec; }
+    void ClearActiveTalentSpec() { m_activeTalentSpec.specName = ""; m_activeTalentSpec.specClass = 0; m_activeTalentSpec.specPurpose = TSP_NONE; for (int i = 0; i < 71; i++) m_activeTalentSpec.talentId[i] = 0; for (int i = 0; i < 3; i++) { m_activeTalentSpec.glyphIdMajor[i] = 0; m_activeTalentSpec.glyphIdMinor[i] = 0; } }
+    void SetActiveTalentSpec(TalentSpec ts) { m_activeTalentSpec = ts; }
+    bool ApplyActiveTalentSpec();
+
+    void MakeSpellLink(const SpellEntry *sInfo, std::ostringstream &out);
+    void MakeWeaponSkillLink(const SpellEntry *sInfo, std::ostringstream &out, uint32 skillid);
+
+    // currently bots only obey commands from the master
+    bool canObeyCommandFrom(const Player& player) const;
+
+    // get current casting spell (will return NULL if no spell!)
+    Spell* GetCurrentSpell() const;
+
+    bool HasAura(uint32 spellId, const Unit& player) const;
+    bool HasAura(const char* spellName, const Unit& player) const;
+    bool HasAura(const char* spellName) const;
+
+    bool CanReceiveSpecificSpell(uint8 spec, Unit* target) const;
+    bool IsSingleFromSpellSpecificPerTargetPerCaster(SpellSpecific spellSpec1, SpellSpecific spellSpec2) const;
+
+    bool HasTool(uint32 TC);
+    bool HasSpellReagents(uint32 spellId);
+    void ItemCountInInv(uint32 itemid, uint32 &count);
+    uint32 GetSpellCharges(uint32 spellId);
+
+    uint8 GetHealthPercent(const Unit& target) const;
+    uint8 GetHealthPercent() const;
+    uint8 GetBaseManaPercent(const Unit& target) const;
+    uint8 GetBaseManaPercent() const;
+    uint8 GetManaPercent(const Unit& target) const;
+    uint8 GetManaPercent() const;
+    uint8 GetRageAmount(const Unit& target) const;
+    uint8 GetRageAmount() const;
+    uint8 GetEnergyAmount(const Unit& target) const;
+    uint8 GetEnergyAmount() const;
+    uint8 GetRunicPower(const Unit& target) const;
+    uint8 GetRunicPower() const;
+
+    Item* FindFood() const;
+    Item* FindDrink() const;
+    Item* FindBandage() const;
+    Item* FindPoison() const;
+    Item* FindItem(uint32 ItemId);
+    Item* FindItemInBank(uint32 ItemId);
+    Item* FindKeyForLockValue(uint32 reqSkillValue);
+    Item* FindBombForLockValue(uint32 reqSkillValue);
+    Item* FindConsumable(uint32 displayId) const;
+    uint8 _findItemSlot(Item* target);
+    bool CanStore();
+
+    // ******* Actions ****************************************
+    // Your handlers can call these actions to make the bot do things.
+    void TellMaster(const std::string& text) const;
+    void TellMaster(const char *fmt, ...) const;
+    void SendWhisper(const std::string& text, Player& player) const;
+    bool CastSpell(const char* args);
+    bool CastSpell(uint32 spellId);
+    bool CastSpell(uint32 spellId, Unit& target);
+    bool CastPetSpell(uint32 spellId, Unit* target = NULL);
+    bool Buff(uint32 spellId, Unit * target, void (*beforeCast)(Player *) = NULL);
+    bool SelfBuff(uint32 spellId);
+    bool IsInRange(Unit* Target, uint32 spellId);
+
+    void UseItem(Item *item, uint32 targetFlag, uint64 targetGUID);
+    void UseItem(Item *item, uint8 targetInventorySlot);
+    void UseItem(Item *item, Unit *target);
+    void UseItem(Item *item);
+
+    void BotPlaySound(uint32 soundid);
+    void Announce(AnnounceFlags msg);
+
+    void EquipItem(Item* src_Item);
+    //bool Follow(Player& player);
+    uint32 AutoEquipPlug;               //switch for autoequip
+    uint32 SellWhite;					//switch for white item auto sell
+    uint8 DistOverRide;
+    float gDist[2]; //gDist, gTemp vars are used for variable follow distance
+    float gTempDist;
+    float gTempDist2;
+    uint8 FollowAutoGo;
+    uint8 IsUpOrDown; //tracks variable follow distance
+    void _HandleCommandAutoEquip(std::string &text, Player &fromPlayer);
+    void SendNotEquipList(Player& player);
+    void FollowAutoReset(Player& /*player*/);
+    void AutoUpgradeEquipment(Player& /*player*/); // test for autoequip
+    void AutoEquipComparison(Item *pItem, Item *pItem2);
+    bool ItemStatComparison(const ItemTemplate *pProto, const ItemTemplate *pProto2);
+    void Feast();
+    void InterruptCurrentCastingSpell();
+    void GetCombatTarget(Unit* forcedTarged = 0);
+    void GetDuelTarget(Unit* forcedTarget);
+    Unit *GetCurrentTarget() { return m_targetCombat; }
+    void DoNextCombatManeuver();
+    void DoCombatMovement();
+    void SetIgnoreUpdateTime(uint8 t = 0) { m_ignoreAIUpdatesUntilTime = time(0) + t; }
+
+    Player *GetPlayerBot() const { return m_bot; }
+    Player *GetPlayer() const { return m_bot; }
+    //Player *GetMaster() const { return m_master; }
+
+    BotState GetState() { return m_botState; }
+    void SetState(BotState state);
+    void SetQuestNeedItems();
+    void SetQuestNeedCreatures();
+    void SendQuestNeedList();
+    bool IsInQuestItemList(uint32 itemid) { return m_needItemList.find(itemid) != m_needItemList.end(); }
+    bool IsInQuestCreatureList(uint32 id) { return m_needCreatureOrGOList.find(id) != m_needCreatureOrGOList.end(); }
+    bool IsItemUseful(uint32 itemid);
+    void SendOrders(Player& player);
+    //bool DoTeleport(WorldObject &obj);
+    void DoLoot();
+    void DoFlight();
+    void GetTaxi(uint64 guid, BotTaxiNode& nodes);
+
+    bool HasCollectFlag(uint8 flag) { return m_collectionFlags & flag; }
+    void SetCollectFlag(uint8 flag)
+    {
+        if (HasCollectFlag(flag)) m_collectionFlags &= ~flag;
+        else m_collectionFlags |= flag;
+    }
+
+    uint32 EstRepairAll();
+    uint32 EstRepair(uint16 pos);
+
+    void AcceptQuest(Quest const *qInfo, Player *pGiver);
+    void TurnInQuests(WorldObject *questgiver);
+    void ListQuests(WorldObject* questgiver);
+    bool AddQuest(const uint32 entry, WorldObject* questgiver);
+
+    bool IsInCombat();
+    void UpdateAttackerInfo();
+    Unit* FindAttacker(ATTACKERINFOTYPE ait = AIT_NONE, Unit *victim = 0);
+    uint32 GetAttackerCount() { return m_attackerInfo.size(); }
+    void SetCombatOrderByStr(std::string str, Unit *target = 0);
+    void SetCombatOrder(CombatOrderType co, Unit *target = 0);
+    CombatOrderType GetCombatOrder() { return this->m_combatOrder; }
+    ResistType GetResistType() { return m_resistType; }
+    void SetMovementOrder(MovementOrderType mo, Unit *followTarget = 0);
+    MovementOrderType GetMovementOrder() { return this->m_movementOrder; }
+    void MovementReset();
+    void MovementClear();
+    bool IsMoving();
+
+    //void SetInFront(const Unit* obj);
+
+    void ItemLocalization(std::string& itemName, const uint32 itemID) const;
+    void QuestLocalization(std::string& questTitle, const uint32 questID) const;
+    void CreatureLocalization(std::string& creatureName, const uint32 entry) const;
+    void GameObjectLocalization(std::string& gameobjectName, const uint32 entry) const;
+
+    uint8 GetFreeBagSpace() const;
+    void SellGarbage(Player & /*plyer*/, bool listNonTrash = true, bool bDetailTrashSold = false, bool verbose = true);
+    void Sell(const uint32 itemid);
+    void Buy(uint64 vendorguid, const uint32 itemid);
+    std::string DropItem(const uint32 itemid);
+    void AddAuction(const uint32 itemid, Creature* aCreature);
+    void ListAuctions();
+    bool RemoveAuction(const uint32 auctionid);
+    void Repair(const uint32 itemid, Creature* rCreature);
+    bool Talent(Creature* tCreature);
+    void InspectUpdate();
+    bool Withdraw(const uint32 itemid);
+    bool Deposit(const uint32 itemid);
+    void BankBalance();
+    std::string Cash(uint32 copper);
+    std::string AuctionResult(std::string subject, std::string body);
+
+    //TEMP PlayerbotMgr
+    void HandleMasterIncomingPacket(const WorldPacket& packet, WorldSession& session);
+
+    bool m_confDebugWhisper;
+private:
+    // config variables
+    uint32 m_confRestrictBotLevel;
+    uint32 m_confDisableBotsInRealm;
+    uint32 m_confMaxNumBots;
+    bool m_confDisableBots;
+    float m_confFollowDistance[2];
+    bool m_confCollectCombat;
+    bool m_confCollectQuest;
+    bool m_confCollectProfession;
+    bool m_confCollectLoot;
+    bool m_confCollectSkin;
+    bool m_confCollectObjects;
+    uint32 gConfigSellLevelDiff;
+    uint32 m_confCollectDistance;
+    uint32 m_confCollectDistanceMax;
+    bool m_confSellGarbage;
+
+    bool m_changeFaction;
+
+protected:
+    bool ValidateTalent(uint16 talent, long charClass);
+    bool ValidateGlyph(uint16 glyph, long charClass);
+    bool ValidateMajorGlyph(uint16 glyph, long charClass);
+    bool ValidateMinorGlyph(uint16 glyph, long charClass);
+
+private:
+    bool ExtractCommand(const std::string sLookingFor, std::string &text, bool bUseShort = false);
+    // outsource commands for code clarity
+    void _HandleCommandReset(std::string &text, Player &fromPlayer);
+    void _HandleCommandOrders(std::string &text, Player &fromPlayer);
+    void _HandleCommandFollow(std::string &text, Player &fromPlayer);
+    void _HandleCommandStay(std::string &text, Player &fromPlayer);
+    void _HandleCommandAttack(std::string &text, Player &fromPlayer);
+    void _HandleCommandCast(std::string &text, Player &fromPlayer);
+    void _HandleCommandSell(std::string &text, Player &fromPlayer);
+    void _HandleCommandBuy(std::string &text, Player &fromPlayer);
+    void _HandleCommandDrop(std::string &text, Player &fromPlayer);
+    void _HandleCommandRepair(std::string &text, Player &fromPlayer);
+    void _HandleCommandAuction(std::string &text, Player &fromPlayer);
+    void _HandleCommandMail(std::string &text, Player &fromPlayer);
+    void _HandleCommandBank(std::string &text, Player &fromPlayer);
+    void _HandleCommandTalent(std::string &text, Player &fromPlayer);
+    void _HandleCommandUse(std::string &text, Player &fromPlayer);
+    void _HandleCommandEquip(std::string &text, Player &fromPlayer);
+    void _HandleCommandFind(std::string &text, Player &fromPlayer);
+    void _HandleCommandGet(std::string &text, Player &fromPlayer);
+    void _HandleCommandCollect(std::string &text, Player &fromPlayer);
+    void _HandleCommandQuest(std::string &text, Player &fromPlayer);
+    void _HandleCommandCraft(std::string &text, Player &fromPlayer);
+    void _HandleCommandEnchant(std::string &text, Player &fromPlayer);
+    void _HandleCommandProcess(std::string &text, Player &fromPlayer);
+    void _HandleCommandPet(std::string &text, Player &fromPlayer);
+    void _HandleCommandSpells(std::string &text, Player &fromPlayer);
+    void _HandleCommandSurvey(std::string &text, Player &fromPlayer);
+    void _HandleCommandSkill(std::string &text, Player &fromPlayer);
+    void _HandleCommandStats(std::string &text, Player &fromPlayer);
+    void _HandleCommandHelp(std::string &text, Player &fromPlayer);
+    void _HandleCommandHelp(const char* szText, Player &fromPlayer) { std::string text = szText; _HandleCommandHelp(text, fromPlayer); }
+    void _HandleCommandGM(std::string &text, Player &fromPlayer);
+    std::string _HandleCommandHelpHelper(std::string sCommand, std::string sExplain, HELPERLINKABLES reqLink = HL_NONE, bool bReqLinkMultiples = false, bool bCommandShort = false);
+
+    // ****** Closed Actions ********************************
+    // These actions may only be called at special times.
+    // Trade methods are only applicable when the trade window is open
+    // and are only called from within HandleCommand.
+    bool TradeItem(const Item& item, int8 slot = -1);
+    bool TradeCopper(uint32 copper);
+
+    // Helper routines not needed by class AIs.
+    void UpdateAttackersForTarget(Unit *victim);
+
+    void _doSellItem(Item *item, std::ostringstream &report, std::ostringstream &canSell, uint32 &TotalCost, uint32 &TotalSold);
+    void MakeItemLink(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+    void MakeItemText(const Item *item, std::ostringstream &out, bool IncludeQuantity = true);
+    void MakeItemLink(const ItemTemplate *item, std::ostringstream &out);
+
+    // it is safe to keep these back reference pointers because m_bot
+    // owns the "this" object and m_master owns m_bot. The owner always cleans up.
+    Player* const m_bot;
+    Player* const m_master;
+    PlayerbotClassAI* m_classAI;
+
+    // ignores AI updates until time specified
+    // no need to waste CPU cycles during casting etc
+    time_t m_ignoreAIUpdatesUntilTime;
+
+    CombatStyle m_combatStyle;
+    CombatOrderType m_combatOrder;
+    ResistType m_resistType;
+    MovementOrderType m_movementOrder;
+
+    TalentSpec m_activeTalentSpec;
+
+    ScenarioType m_ScenarioType;
+
+    // defines the state of behaviour of the bot
+    BotState m_botState;
+
+    // list of items, creatures or gameobjects needed to fullfill quests
+    BotNeedItem m_needItemList;
+    BotNeedItem m_needCreatureOrGOList;
+
+    // list of creatures we recently attacked and want to loot
+    BotNPCList m_findNPC;               // list of NPCs
+    BotTaskList m_tasks;                // list of tasks
+    BotObjectList m_lootTargets;        // list of targets
+    BotEntryList m_spellsToLearn;       // list of spells
+    uint64 m_lootCurrent;               // current remains of interest
+    uint64 m_lootPrev;                  // previous loot
+    BotEntryList m_collectObjects;      // object entries searched for in findNearbyGO
+    BotTaxiNode m_taxiNodes;            // flight node chain;
+    BotEntryList m_noToolList;          // list of required tools
+
+    uint8 m_collectionFlags;            // what the bot should look for to loot
+    //uint32 m_collectDist;               // distance to collect objects
+    bool m_inventory_full;
+    uint32 m_itemTarget;
+
+    time_t m_TimeDoneEating;
+    time_t m_TimeDoneDrinking;
+    uint32 m_CurrentlyCastingSpellId;
+    //bool m_IsFollowingMaster;
+
+    // if master commands bot to do something, store here until updateAI
+    // can do it
+    uint32 m_spellIdCommand;
+    uint64 m_targetGuidCommand;
+    uint64 m_taxiMaster;
+
+    BotObjectSet m_ignorePlayersChat;  // list of players that the bot will not respond to
+
+    AttackerInfoList m_attackerInfo;
+
+    bool m_targetChanged;
+    CombatTargetType m_targetType;
+
+    uint64 m_targetCombatGUID;
+    Unit *m_targetCombat;       // current combat target
+    Unit *m_targetAssist;       // get new target by checking attacker list of assisted player
+    Unit *m_targetProtect;      // check
+
+    Unit *m_followTarget;       // whom to follow in non combat situation?
+
+    uint32 FISHING,
+           HERB_GATHERING,
+           MINING,
+           SKINNING,
+           ASPECT_OF_THE_MONKEY;
+
+    SpellRanges m_spellRangeMap;
+
+    float m_destX, m_destY, m_destZ; // latest coordinates for chase and point movement types
+
+};
+
+class PlayerbotClassAI
+{
+    friend class PlayerbotAI;
+public:
+    PlayerbotClassAI(Player * const master, Player * const bot, PlayerbotAI * const ai) : m_master(master), m_bot(bot), m_ai(ai) {}
+    virtual ~PlayerbotClassAI() {}
+
+    // all combat actions go here
+    virtual bool DoFirstCombatManeuver(Unit*) { return false; }
+    virtual void DoNextCombatManeuver(Unit*) {}
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    virtual void DoNonCombatActions() {}
+
+    // buff a specific player, usually a real PC who is not in group
+    virtual bool BuffPlayer(Player* /*target*/) { return false; }
+
+    float GetCombatDistance(const Unit* target) const;
+
+    //More generalized method than HasAura().  It looks for
+    //any rank of the spell and it doesn't care which
+    //spell effect you want.  If it has the spell aura than
+    //it returns true
+    bool HasAuraName(Unit *unit, std::string spell, uint64 casterGuid = 0) const;
+    bool HasAuraName(Unit *unit, uint32 spellId, uint64 casterGuid = 0) const;
+
+    // Utilities
+    Player* GetMaster() { return m_master; }
+    Player* GetPlayerBot() { return m_bot; }
+    PlayerbotAI* GetAI() { return m_ai; };
+
+
+private:
+    Player* m_master;
+    Player* m_bot;
+    PlayerbotAI* m_ai;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
new file mode 100644
index 0000000..d15485e
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.cpp
@@ -0,0 +1,499 @@
+// a simple DK class by rrtn :)
+#include "PlayerbotDeathKnightAI.h"
+
+PlayerbotDeathKnightAI::PlayerbotDeathKnightAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+
+    PLAGUE_STRIKE     = ai->initSpell(PLAGUE_STRIKE_1); // Unholy
+    DEATH_GRIP        = ai->initSpell(DEATH_GRIP_1);
+    DEATH_COIL        = ai->initSpell(DEATH_COIL_DEATH_KNIGHT_1);
+    DEATH_STRIKE      = ai->initSpell(DEATH_STRIKE_1);
+    UNHOLY_BLIGHT     = 0; // Passive
+    SCOURGE_STRIKE    = ai->initSpell(SCOURGE_STRIKE_1);
+    DEATH_AND_DECAY   = ai->initSpell(DEATH_AND_DECAY_1);
+    CORPSE_EXPLOSION  = ai->initSpell(CORPSE_EXPLOSION_1);
+    BONE_SHIELD       = ai->initSpell(BONE_SHIELD_1); // buffs
+    ANTI_MAGIC_SHELL  = ai->initSpell(ANTI_MAGIC_SHELL_1);
+    ANTI_MAGIC_ZONE   = ai->initSpell(ANTI_MAGIC_ZONE_1);
+    GHOUL_FRENZY      = ai->initSpell(GHOUL_FRENZY_1);
+    RAISE_DEAD        = ai->initSpell(RAISE_DEAD_1); // pets
+    SUMMON_GARGOYLE   = ai->initSpell(SUMMON_GARGOYLE_1);
+    ARMY_OF_THE_DEAD  = ai->initSpell(ARMY_OF_THE_DEAD_1);
+    ICY_TOUCH         = ai->initSpell(ICY_TOUCH_1); // Frost
+    OBLITERATE        = ai->initSpell(OBLITERATE_1);
+    HOWLING_BLAST     = ai->initSpell(HOWLING_BLAST_1);
+    FROST_STRIKE      = ai->initSpell(FROST_STRIKE_1);
+    CHAINS_OF_ICE     = ai->initSpell(CHAINS_OF_ICE_1);
+    RUNE_STRIKE       = ai->initSpell(RUNE_STRIKE_1);
+    ICY_CLUTCH        = 0; // No such spell
+    MIND_FREEZE       = ai->initSpell(MIND_FREEZE_1);
+    HUNGERING_COLD    = ai->initSpell(HUNGERING_COLD_1);
+    KILLING_MACHINE   = 0; // Passive
+    DEATHCHILL        = ai->initSpell(DEATHCHILL_1);
+    HORN_OF_WINTER    = ai->initSpell(HORN_OF_WINTER_1);
+    ICEBOUND_FORTITUDE = ai->initSpell(ICEBOUND_FORTITUDE_1);
+    EMPOWER_WEAPON    = ai->initSpell(EMPOWER_RUNE_WEAPON_1);
+    UNBREAKABLE_ARMOR = ai->initSpell(UNBREAKABLE_ARMOR_1);
+    BLOOD_STRIKE      = ai->initSpell(BLOOD_STRIKE_1); // Blood
+    PESTILENCE        = ai->initSpell(PESTILENCE_1);
+    STRANGULATE       = ai->initSpell(STRANGULATE_1);
+    BLOOD_BOIL        = ai->initSpell(BLOOD_BOIL_1);
+    HEART_STRIKE      = ai->initSpell(HEART_STRIKE_1);
+    DANCING_WEAPON    = ai->initSpell(DANCING_RUNE_WEAPON_1);
+    DARK_COMMAND      = ai->initSpell(DARK_COMMAND_1);
+    MARK_OF_BLOOD     = ai->initSpell(MARK_OF_BLOOD_1); // buffs
+    RUNE_TAP          = ai->initSpell(RUNE_TAP_1);
+    VAMPIRIC_BLOOD    = ai->initSpell(VAMPIRIC_BLOOD_1);
+    DEATH_PACT        = ai->initSpell(DEATH_PACT_1);
+    HYSTERIA          = ai->initSpell(HYSTERIA_1);
+    UNHOLY_PRESENCE   = ai->initSpell(UNHOLY_PRESENCE_1); // presence (TODO: better spell == presence)
+    FROST_PRESENCE    = ai->initSpell(FROST_PRESENCE_1);
+    BLOOD_PRESENCE    = ai->initSpell(BLOOD_PRESENCE_1);
+
+    RECENTLY_BANDAGED = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->initSpell(ARCANE_TORRENT_DEATH_KNIGHT); // blood elf
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_DEATH_KNIGHT); // draenei
+    STONEFORM               = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BLOOD_FURY              = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP               = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotDeathKnightAI::~PlayerbotDeathKnightAI() {}
+
+bool PlayerbotDeathKnightAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotDeathKnightAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(PLAGUE_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // DK Attacks: Unholy, Frost & Blood
+
+    // damage spells
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    Pet *pet = m_bot->GetPet();
+    float dist = GetCombatDistance(pTarget);
+    std::ostringstream out;
+
+    switch (SpellSequence)
+    {
+        case SPELL_DK_UNHOLY:
+            if (UNHOLY_PRESENCE > 0)
+                (!m_bot->HasAura(UNHOLY_PRESENCE, 0) && !m_bot->HasAura(BLOOD_PRESENCE, 0) && !m_bot->HasAura(FROST_PRESENCE, 0) && ai->CastSpell (UNHOLY_PRESENCE, *m_bot));
+
+            // check for BONE_SHIELD in combat
+            if (BONE_SHIELD > 0)
+                (!m_bot->HasAura(BONE_SHIELD, 0) && !m_bot->HasAura(ARMY_OF_THE_DEAD, 0) && ai->CastSpell (BONE_SHIELD, *m_bot));
+
+            if (ARMY_OF_THE_DEAD > 0 && ai->GetAttackerCount() >= 5 && LastSpellUnholyDK < 1)
+            {
+                ai->CastSpell(ARMY_OF_THE_DEAD);
+                out << " summoning Army of the Dead!";
+                if (ARMY_OF_THE_DEAD > 0 && m_bot->HasAura(ARMY_OF_THE_DEAD, 0))
+                    ai->SetIgnoreUpdateTime(7);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (PLAGUE_STRIKE > 0 && !pTarget->HasAura(PLAGUE_STRIKE, 0) && LastSpellUnholyDK < 2)
+            {
+                ai->CastSpell(PLAGUE_STRIKE, *pTarget);
+                out << " Plague Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_GRIP > 0 && !pTarget->HasAura(DEATH_GRIP, 0) && LastSpellUnholyDK < 3)
+            {
+                ai->CastSpell(DEATH_GRIP, *pTarget);
+                out << " Death Grip";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_COIL > 0 && LastSpellUnholyDK < 4 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(DEATH_COIL, *pTarget);
+                out << " Death Coil";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_STRIKE > 0 && !pTarget->HasAura(DEATH_STRIKE, 0) && LastSpellUnholyDK < 5)
+            {
+                ai->CastSpell(DEATH_STRIKE, *pTarget);
+                out << " Death Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (UNHOLY_BLIGHT > 0 && !pTarget->HasAura(UNHOLY_BLIGHT, 0) && LastSpellUnholyDK < 6)
+            {
+                ai->CastSpell(UNHOLY_BLIGHT);
+                out << " Unholy Blight";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (SCOURGE_STRIKE > 0 && LastSpellUnholyDK < 7)
+            {
+                ai->CastSpell(SCOURGE_STRIKE, *pTarget);
+                out << " Scourge Strike";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (DEATH_AND_DECAY > 0 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(DEATH_AND_DECAY, 0) && LastSpellUnholyDK < 8)
+            {
+                ai->CastSpell(DEATH_AND_DECAY);
+                out << " Death and Decay";
+                ai->SetIgnoreUpdateTime(1);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (SUMMON_GARGOYLE > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD, 0) && !pTarget->HasAura(SUMMON_GARGOYLE, 0) && LastSpellUnholyDK < 9 && ai->GetRunicPower() >= 60)
+            {
+                ai->CastSpell(SUMMON_GARGOYLE, *pTarget);
+                out << " summoning Gargoyle";
+                ai->SetIgnoreUpdateTime(2);
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (CORPSE_EXPLOSION > 0 && dist <= ATTACK_DISTANCE && LastSpellUnholyDK < 10)
+            {
+                ai->CastSpell(CORPSE_EXPLOSION, *pTarget);
+                out << " Corpse Explosion";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (ANTI_MAGIC_SHELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL, 0) && LastSpellUnholyDK < 11 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(ANTI_MAGIC_SHELL, *m_bot);
+                out << " Anti-Magic Shell";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (ANTI_MAGIC_ZONE > 0 && pTarget->IsNonMeleeSpellCasted(true) && !m_bot->HasAura(ANTI_MAGIC_SHELL, 0) && LastSpellUnholyDK < 12)
+            {
+                ai->CastSpell(ANTI_MAGIC_ZONE, *m_bot);
+                out << " Anti-Magic Zone";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if ((!pet)
+                     && (RAISE_DEAD > 0 && !m_bot->HasAura(ARMY_OF_THE_DEAD, 0) && LastSpellUnholyDK < 13))
+            {
+                ai->CastSpell(RAISE_DEAD);
+                out << " summoning Ghoul";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if ((pet)
+                     && (GHOUL_FRENZY > 0 && pVictim == pet && !pet->HasAura(GHOUL_FRENZY, 0) && LastSpellUnholyDK < 14))
+            {
+                ai->CastSpell(GHOUL_FRENZY, *pet);
+                out << " casting Ghoul Frenzy on pet";
+                SpellSequence = SPELL_DK_FROST;
+                LastSpellUnholyDK = LastSpellUnholyDK + 1;
+                break;
+            }
+            else if (LastSpellUnholyDK > 15)
+            {
+                LastSpellUnholyDK = 0;
+                SpellSequence = SPELL_DK_FROST;
+                break;
+            }
+
+            LastSpellUnholyDK = 0;
+
+        case SPELL_DK_FROST:
+            if (FROST_PRESENCE > 0)
+                (!m_bot->HasAura(FROST_PRESENCE, 0) && !m_bot->HasAura(BLOOD_PRESENCE, 0) && !m_bot->HasAura(UNHOLY_PRESENCE, 0) && ai->CastSpell (FROST_PRESENCE, *m_bot));
+
+            if (DEATHCHILL > 0)
+                (!m_bot->HasAura(DEATHCHILL, 0) && !m_bot->HasAura(KILLING_MACHINE, 0) && ai->CastSpell (DEATHCHILL, *m_bot));
+            else if (KILLING_MACHINE > 0)
+                (!m_bot->HasAura(KILLING_MACHINE, 0) && !m_bot->HasAura(DEATHCHILL, 0) && ai->CastSpell (KILLING_MACHINE, *m_bot));
+
+            if (ICY_TOUCH > 0 && !pTarget->HasAura(ICY_TOUCH, 0) && LastSpellFrostDK < 1)
+            {
+                ai->CastSpell(ICY_TOUCH, *pTarget);
+                out << " Icy Touch";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (OBLITERATE > 0 && LastSpellFrostDK < 2)
+            {
+                ai->CastSpell(OBLITERATE, *pTarget);
+                out << " Obliterate";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (FROST_STRIKE > 0 && LastSpellFrostDK < 3 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(FROST_STRIKE, *pTarget);
+                out << " Frost Strike";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (HOWLING_BLAST > 0 && ai->GetAttackerCount() >= 3 && LastSpellFrostDK < 4)
+            {
+                ai->CastSpell(HOWLING_BLAST, *pTarget);
+                out << " Howling Blast";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (CHAINS_OF_ICE > 0 && !pTarget->HasAura(CHAINS_OF_ICE, 0) && LastSpellFrostDK < 5)
+            {
+                ai->CastSpell(CHAINS_OF_ICE, *pTarget);
+                out << " Chains of Ice";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (RUNE_STRIKE > 0 && LastSpellFrostDK < 6 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(RUNE_STRIKE, *pTarget);
+                out << " Rune Strike";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (ICY_CLUTCH > 0 && !pTarget->HasAura(ICY_CLUTCH, 0) && LastSpellFrostDK < 7)
+            {
+                ai->CastSpell(ICY_CLUTCH, *pTarget);
+                out << " Icy Clutch";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (ICEBOUND_FORTITUDE > 0 && ai->GetHealthPercent() < 50 && pVictim == m_bot && !m_bot->HasAura(ICEBOUND_FORTITUDE, 0) && LastSpellFrostDK < 8 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(ICEBOUND_FORTITUDE, *m_bot);
+                out << " Icebound Fortitude";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (MIND_FREEZE > 0 && pTarget->IsNonMeleeSpellCasted(true) && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 9 && ai->GetRunicPower() >= 20)
+            {
+                ai->CastSpell(MIND_FREEZE, *pTarget);
+                out << " Mind Freeze";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (HUNGERING_COLD > 0 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && LastSpellFrostDK < 10 && ai->GetRunicPower() >= 40)
+            {
+                ai->CastSpell(HUNGERING_COLD, *pTarget);
+                out << " Hungering Cold";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (EMPOWER_WEAPON > 0 && ai->GetRunicPower() < 20 && LastSpellFrostDK < 11)
+            {
+                ai->CastSpell(EMPOWER_WEAPON, *m_bot);
+                out << " Empower Rune Weapon";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (UNBREAKABLE_ARMOR > 0 && !m_bot->HasAura(UNBREAKABLE_ARMOR, 0) && ai->GetHealthPercent() < 70 && pVictim == m_bot && LastSpellFrostDK < 12)
+            {
+                ai->CastSpell(UNBREAKABLE_ARMOR, *m_bot);
+                out << " Unbreakable Armor";
+                SpellSequence = SPELL_DK_BLOOD;
+                LastSpellFrostDK = LastSpellFrostDK + 1;
+                break;
+            }
+            else if (LastSpellFrostDK > 13)
+            {
+                LastSpellFrostDK = 0;
+                SpellSequence = SPELL_DK_BLOOD;
+                break;
+            }
+
+            LastSpellFrostDK = 0;
+
+        case SPELL_DK_BLOOD:
+            if (BLOOD_PRESENCE > 0)
+                (!m_bot->HasAura(BLOOD_PRESENCE, 0) && !m_bot->HasAura(UNHOLY_PRESENCE, 0) && !m_bot->HasAura(FROST_PRESENCE, 0) && ai->CastSpell (BLOOD_PRESENCE, *m_bot));
+
+            if (MARK_OF_BLOOD > 0 && !pTarget->HasAura(MARK_OF_BLOOD, 0) && LastSpellBloodDK < 1)
+            {
+                ai->CastSpell(MARK_OF_BLOOD, *pTarget);
+                out << " Mark of Blood";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (BLOOD_STRIKE > 0 && LastSpellBloodDK < 2)
+            {
+                ai->CastSpell(BLOOD_STRIKE, *pTarget);
+                out << " Blood Strike";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK =  LastSpellBloodDK + 1;
+                break;
+            }
+            else if (PESTILENCE > 0 && dist <= ATTACK_DISTANCE && ai->GetAttackerCount() >= 3 && LastSpellBloodDK < 3)
+            {
+                ai->CastSpell(PESTILENCE, *pTarget);
+                out << " Pestilence";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (STRANGULATE > 0 && !pTarget->HasAura(STRANGULATE, 0) && LastSpellBloodDK < 4)
+            {
+                ai->CastSpell(STRANGULATE, *pTarget);
+                out << " Strangulate";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (BLOOD_BOIL > 0 && ai->GetAttackerCount() >= 5 && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 5)
+            {
+                ai->CastSpell(BLOOD_BOIL, *pTarget);
+                out << " Blood Boil";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (HEART_STRIKE > 0 && LastSpellBloodDK < 6)
+            {
+                ai->CastSpell(HEART_STRIKE, *pTarget);
+                out << " Heart Strike";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (VAMPIRIC_BLOOD > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD, 0) && LastSpellBloodDK < 7)
+            {
+                ai->CastSpell(VAMPIRIC_BLOOD, *m_bot);
+                out << " Vampiric Blood";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (RUNE_TAP > 0 && ai->GetHealthPercent() < 70 && !m_bot->HasAura(VAMPIRIC_BLOOD, 0) && LastSpellBloodDK < 8)
+            {
+                ai->CastSpell(RUNE_TAP, *m_bot);
+                out << " Rune Tap";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (HYSTERIA > 0 && ai->GetHealthPercent() > 25 && !m_bot->HasAura(HYSTERIA, 0) && LastSpellBloodDK < 9)
+            {
+                ai->CastSpell(HYSTERIA, *m_bot);
+                out << " Hysteria";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (DANCING_WEAPON > 0 && !m_bot->HasAura(DANCING_WEAPON, 0) && ai->GetRunicPower() >= 60 && LastSpellBloodDK < 10)
+            {
+                ai->CastSpell(DANCING_WEAPON, *pTarget);
+                out << " summoning Dancing Rune Weapon";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (DARK_COMMAND > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !pTarget->HasAura(DARK_COMMAND, 0) && dist <= ATTACK_DISTANCE && LastSpellBloodDK < 11)
+            {
+                ai->CastSpell(DARK_COMMAND, *pTarget);
+                out << " Dark Command";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if ((pet)
+                     && (DEATH_PACT > 0 && ai->GetHealthPercent() < 50 && LastSpellBloodDK < 12 && ai->GetRunicPower() >= 40))
+            {
+                ai->CastSpell(DEATH_PACT, *pet);
+                out << " Death Pact (sacrifice pet)";
+                SpellSequence = SPELL_DK_UNHOLY;
+                LastSpellBloodDK = LastSpellBloodDK + 1;
+                break;
+            }
+            else if (LastSpellBloodDK > 13)
+            {
+                LastSpellBloodDK = 0;
+                SpellSequence = SPELL_DK_UNHOLY;
+                break;
+            }
+            else
+            {
+                LastSpellBloodDK = 0;
+                SpellSequence = SPELL_DK_UNHOLY;
+            }
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+
+} // end DoNextCombatManeuver
+
+void PlayerbotDeathKnightAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_DK_UNHOLY;
+
+    // buff master with HORN_OF_WINTER
+    if (HORN_OF_WINTER > 0)
+        (!GetMaster()->HasAura(HORN_OF_WINTER, 0) && ai->CastSpell (HORN_OF_WINTER, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
new file mode 100644
index 0000000..792ecdf
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDeathKnightAI.h
@@ -0,0 +1,100 @@
+#ifndef _PLAYERDEATHKNIGHTAI_H
+#define _PLAYERDEATHKNIGHTAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_DK_UNHOLY,
+    SPELL_DK_FROST,
+    SPELL_DK_BLOOD
+};
+
+enum DeathKnightSpells
+{
+    ANTI_MAGIC_SHELL_1              = 48707,
+    ANTI_MAGIC_ZONE_1               = 51052,
+    ARMY_OF_THE_DEAD_1              = 42650,
+    BLOOD_BOIL_1                    = 48721,
+    BLOOD_PRESENCE_1                = 48266,
+    BLOOD_STRIKE_1                  = 45902,
+    BLOOD_TAP_1                     = 45529,
+    BONE_SHIELD_1                   = 49222,
+    CHAINS_OF_ICE_1                 = 45524,
+    CORPSE_EXPLOSION_1              = 49158,
+    DANCING_RUNE_WEAPON_1           = 49028,
+    DARK_COMMAND_1                  = 56222,
+    DEATH_AND_DECAY_1               = 43265,
+    DEATH_COIL_DEATH_KNIGHT_1       = 47541,
+    DEATH_GRIP_1                    = 49576,
+    DEATH_PACT_1                    = 48743,
+    DEATH_STRIKE_1                  = 49998,
+    DEATHCHILL_1                    = 49796,
+    EMPOWER_RUNE_WEAPON_1           = 47568,
+    FROST_PRESENCE_1                = 48263,
+    FROST_STRIKE_1                  = 49143,
+    GHOUL_FRENZY_1                  = 63560,
+    HEART_STRIKE_1                  = 55050,
+    HORN_OF_WINTER_1                = 57330,
+    HOWLING_BLAST_1                 = 49184,
+    HUNGERING_COLD_1                = 49203,
+    HYSTERIA_1                      = 49016,
+    ICEBOUND_FORTITUDE_1            = 48792,
+    ICY_TOUCH_1                     = 45477,
+    LICHBORNE_1                     = 49039,
+    MARK_OF_BLOOD_1                 = 49005,
+    MIND_FREEZE_1                   = 47528,
+    OBLITERATE_1                    = 49020,
+    PATH_OF_FROST_1                 = 3714,
+    PESTILENCE_1                    = 50842,
+    PLAGUE_STRIKE_1                 = 45462,
+    RAISE_ALLY_1                    = 61999,
+    RAISE_DEAD_1                    = 46584,
+    RUNE_STRIKE_1                   = 56815,
+    RUNE_TAP_1                      = 48982,
+    SCOURGE_STRIKE_1                = 55090,
+    STRANGULATE_1                   = 47476,
+    SUMMON_GARGOYLE_1               = 49206,
+    UNBREAKABLE_ARMOR_1             = 51271,
+    UNHOLY_PRESENCE_1               = 48265,
+    VAMPIRIC_BLOOD_1                = 55233
+};
+//class Player;
+
+class PlayerbotDeathKnightAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDeathKnightAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDeathKnightAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+
+    // Unholy
+    uint32 BONE_SHIELD, PLAGUE_STRIKE, DEATH_GRIP, DEATH_COIL, DEATH_STRIKE, UNHOLY_BLIGHT, SCOURGE_STRIKE, DEATH_AND_DECAY, UNHOLY_PRESENCE, RAISE_DEAD, ARMY_OF_THE_DEAD, SUMMON_GARGOYLE, ANTI_MAGIC_SHELL, ANTI_MAGIC_ZONE, GHOUL_FRENZY, CORPSE_EXPLOSION;
+
+    // Frost
+    uint32 ICY_TOUCH, OBLITERATE, HOWLING_BLAST, FROST_STRIKE, CHAINS_OF_ICE, RUNE_STRIKE, ICY_CLUTCH, HORN_OF_WINTER, KILLING_MACHINE, FROST_PRESENCE, DEATHCHILL, ICEBOUND_FORTITUDE, MIND_FREEZE, EMPOWER_WEAPON, HUNGERING_COLD, UNBREAKABLE_ARMOR;
+
+    // Blood
+    uint32 BLOOD_STRIKE, PESTILENCE, STRANGULATE, BLOOD_BOIL, HEART_STRIKE, MARK_OF_BLOOD, BLOOD_PRESENCE, RUNE_TAP, VAMPIRIC_BLOOD, DEATH_PACT, DEATH_RUNE_MASTERY, HYSTERIA, DANCING_WEAPON, DARK_COMMAND;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellUnholyDK, LastSpellFrostDK, LastSpellBloodDK;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
new file mode 100644
index 0000000..139b6c4
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.cpp
@@ -0,0 +1,713 @@
+/*
+    Name    : PlayerbotDruidAI.cpp
+    Complete: maybe around 33%
+    Authors : rrtn, Natsukawa
+    Version : 0.42
+ */
+#include "PlayerbotDruidAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+
+PlayerbotDruidAI::PlayerbotDruidAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    MOONFIRE                      = ai->initSpell(MOONFIRE_1); // attacks
+    STARFIRE                      = ai->initSpell(STARFIRE_1);
+    STARFALL                      = ai->initSpell(STARFALL_1);
+    WRATH                         = ai->initSpell(WRATH_1);
+    ROOTS                         = ai->initSpell(ENTANGLING_ROOTS_1);
+    INSECT_SWARM                  = ai->initSpell(INSECT_SWARM_1);
+    FORCE_OF_NATURE               = ai->initSpell(FORCE_OF_NATURE_1);
+    HURRICANE                     = ai->initSpell(HURRICANE_1);
+    MARK_OF_THE_WILD              = ai->initSpell(MARK_OF_THE_WILD_1); // buffs
+    GIFT_OF_THE_WILD              = ai->initSpell(GIFT_OF_THE_WILD_1);
+    THORNS                        = ai->initSpell(THORNS_1);
+    BARKSKIN                      = ai->initSpell(BARKSKIN_1);
+    INNERVATE                     = ai->initSpell(INNERVATE_1);
+    FAERIE_FIRE                   = ai->initSpell(FAERIE_FIRE_1); // debuffs
+    FAERIE_FIRE_FERAL             = ai->initSpell(FAERIE_FIRE_FERAL_1);
+    REJUVENATION                  = ai->initSpell(REJUVENATION_1); // heals
+    REGROWTH                      = ai->initSpell(REGROWTH_1);
+    WILD_GROWTH                   = ai->initSpell(WILD_GROWTH_1);
+    LIFEBLOOM                     = ai->initSpell(LIFEBLOOM_1);
+    NOURISH                       = ai->initSpell(NOURISH_1);
+    HEALING_TOUCH                 = ai->initSpell(HEALING_TOUCH_1);
+    SWIFTMEND                     = ai->initSpell(SWIFTMEND_1);
+    TRANQUILITY                   = ai->initSpell(TRANQUILITY_1);
+    REVIVE                        = ai->initSpell(REVIVE_1);
+    REMOVE_CURSE                  = ai->initSpell(REMOVE_CURSE_DRUID_1);
+    ABOLISH_POISON                = ai->initSpell(ABOLISH_POISON_1);
+    // Druid Forms
+    MOONKIN_FORM                  = ai->initSpell(MOONKIN_FORM_1);
+    DIRE_BEAR_FORM                = ai->initSpell(DIRE_BEAR_FORM_1);
+    BEAR_FORM                     = ai->initSpell(BEAR_FORM_1);
+    CAT_FORM                      = ai->initSpell(CAT_FORM_1);
+    TREE_OF_LIFE                  = ai->initSpell(TREE_OF_LIFE_1);
+    TRAVEL_FORM                   = ai->initSpell(TRAVEL_FORM_1);
+    // Cat Attack type's
+    RAKE                          = ai->initSpell(RAKE_1);
+    CLAW                          = ai->initSpell(CLAW_1); // 45
+    COWER                         = ai->initSpell(COWER_1); // 20
+    MANGLE                        = ai->initSpell(MANGLE_1); // 45
+    TIGERS_FURY                   = ai->initSpell(TIGERS_FURY_1);
+    // Cat Finishing Move's
+    RIP                           = ai->initSpell(RIP_1); // 30
+    FEROCIOUS_BITE                = ai->initSpell(FEROCIOUS_BITE_1); // 35
+    MAIM                          = ai->initSpell(MAIM_1); // 35
+    // Bear/Dire Bear Attacks & Buffs
+    BASH                          = ai->initSpell(BASH_1);
+    MAUL                          = ai->initSpell(MAUL_1); // 15
+    SWIPE                         = ai->initSpell(SWIPE_BEAR_1); // 20
+    DEMORALIZING_ROAR             = ai->initSpell(DEMORALIZING_ROAR_1); // 10
+    CHALLENGING_ROAR              = ai->initSpell(CHALLENGING_ROAR_1);
+    ENRAGE                        = ai->initSpell(ENRAGE_1);
+    GROWL                         = ai->initSpell(GROWL_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    WAR_STOMP                     = ai->initSpell(WAR_STOMP_ALL); // tauren
+}
+
+PlayerbotDruidAI::~PlayerbotDruidAI() {}
+
+bool PlayerbotDruidAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotDruidAI::HealTarget(Unit *target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    //If spell exists and orders say we should be dispelling
+    if ((REMOVE_CURSE > 0 || ABOLISH_POISON > 0) && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        //This does something important(lol)
+        //Get a list of all the targets auras(spells affecting target)
+        Unit::AuraMap const& auras = target->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+            if ((ABOLISH_POISON > 0 && dispel == DISPEL_POISON) || 
+                (REMOVE_CURSE > 0 && dispel == DISPEL_CURSE))
+            {
+                uint32 DISPEL = (REMOVE_CURSE > 0 && dispel == DISPEL_CURSE) ? REMOVE_CURSE : \
+                    (ABOLISH_POISON > 0 && dispel == DISPEL_POISON) ? ABOLISH_POISON : 0;
+                if (DISPEL)
+                {
+                    AuraApplication *aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                    if (!aurApp)
+                        continue;
+                    if (!aurApp->IsPositive())
+                        ai->CastSpell(DISPEL, *target);
+                }
+            }
+        }
+    }
+
+    if (hp >= 70)
+        return false;
+
+    // Reset form if needed
+    GoBuffForm(GetPlayerBot());
+
+    if (hp < 70 && REJUVENATION > 0 && !target->HasAura(REJUVENATION) && ai->CastSpell(REJUVENATION, *target))
+        return true;
+
+    if (hp < 60 && LIFEBLOOM > 0 && !target->HasAura(LIFEBLOOM) && ai->CastSpell(LIFEBLOOM, *target))
+        return true;
+
+    if (hp < 55 && REGROWTH > 0 && !target->HasAura(REGROWTH) && ai->CastSpell(REGROWTH, *target))
+        return true;
+
+    if (hp < 50 && SWIFTMEND > 0 && (target->HasAura(REJUVENATION) || target->HasAura(REGROWTH)) && ai->CastSpell(SWIFTMEND, *target))
+        return true;
+
+    if (hp < 45 && WILD_GROWTH > 0 && !target->HasAura(WILD_GROWTH) && ai->CastSpell(WILD_GROWTH, *target))
+        return true;
+
+    if (hp < 30 && NOURISH > 0 && ai->CastSpell(NOURISH, *target))
+        return true;
+
+    if (hp < 25 && HEALING_TOUCH > 0 && ai->CastSpell(HEALING_TOUCH, *target))
+        return true;
+
+    return false;
+} // end HealTarget
+
+void PlayerbotDruidAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(MOONFIRE);
+            return;
+    }
+
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_HEAL)
+        SpellSequence = DruidHeal;
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST && CAT_FORM > 0)
+        SpellSequence = DruidCombat;
+    // No check for Dire Bear here: you must have Bear form to learn Dire Bear form.
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK && BEAR_FORM > 0)
+        SpellSequence = DruidTank;
+    else
+        SpellSequence = DruidSpell;
+
+    switch (SpellSequence)
+    {
+        case DruidTank: // Its now a tank druid!
+            //ai->TellMaster("DruidTank");
+            _DoNextPVECombatManeuverBear(pTarget);
+            break;
+
+        case DruidSpell:
+            //ai->TellMaster("DruidSpell");
+            _DoNextPVECombatManeuverSpellDPS(pTarget);
+            break;
+
+        case DruidHeal:
+            //ai->TellMaster("DruidHeal");
+            _DoNextPVECombatManeuverHeal(pTarget);
+            break;
+
+        case DruidCombat:
+            //ai->TellMaster("DruidCombat");
+            _DoNextPVECombatManeuverMeleeDPS(pTarget);
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverBear(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    // Face your enemy!
+    if (!m_bot->HasInArc(M_PI, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (pVictim)
+            pVictim->Attack(pTarget, true);
+    }
+
+    // Try and go into [dire] bear form first
+    if (DIRE_BEAR_FORM > 0 && !m_bot->HasAura(DIRE_BEAR_FORM, 0))
+        ai->CastSpell(DIRE_BEAR_FORM);
+    else if (BEAR_FORM > 0 && DIRE_BEAR_FORM == 0 && !m_bot->HasAura(DIRE_BEAR_FORM, 0) && !m_bot->HasAura(BEAR_FORM, 0))
+        ai->CastSpell(BEAR_FORM);
+    else if (DEMORALIZING_ROAR > 0 && (m_bot->HasAura(DIRE_BEAR_FORM, 0) || m_bot->HasAura(BEAR_FORM, 0)) && !pTarget->HasAura(DEMORALIZING_ROAR, 0) && ai->GetRageAmount() >= 10)
+        ai->CastSpell(DEMORALIZING_ROAR, *pTarget);
+
+    // entire tank spell sequence is predicated on being in [dire] bear form. If not in it, exit (*before* going out of other forms)
+    if (!m_bot->HasAura(DIRE_BEAR_FORM) && !m_bot->HasAura(BEAR_FORM))
+        return _DoNextPVECombatManeuverMeleeDPS(pTarget); // bear = melee so...
+
+    // Impossible due to check above
+    // If still in cat/moonkin/tree form, go out of it
+    //if (m_bot->HasAura(CAT_FORM, 0))
+    //    m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+    //if (m_bot->HasAura(MOONKIN_FORM, 0))
+    //    m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    //if (m_bot->HasAura(TREE_OF_LIFE, 0))
+    //    m_bot->RemoveAurasDueToSpell(TREE_OF_LIFE_1);
+
+    if (FAERIE_FIRE_FERAL > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE_FERAL, 0))
+    {
+        ai->CastSpell(FAERIE_FIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (ENRAGE > 0 && DruidSpellCombat < 2 && !m_bot->HasAura(ENRAGE, 0))
+    {
+        ai->CastSpell(ENRAGE, *m_bot);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (SWIPE > 0 && DruidSpellCombat < 3 && ai->GetRageAmount() >= 20)
+    {
+        ai->CastSpell(SWIPE, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (MAUL > 0 && DruidSpellCombat < 4 && ai->GetRageAmount() >= 15)
+    {
+        ai->CastSpell(MAUL, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (BASH > 0 && !pTarget->HasAura(BASH, 0) && DruidSpellCombat < 5 && ai->GetRageAmount() >= 10)
+    {
+        ai->CastSpell(BASH, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (CHALLENGING_ROAR > 0 && pVictim != m_bot && DruidSpellCombat < 6 && !pTarget->HasAura(CHALLENGING_ROAR, 0) && !pTarget->HasAura(GROWL, 0) && ai->GetRageAmount() >= 15)
+    {
+        ai->CastSpell(CHALLENGING_ROAR, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (GROWL > 0 && pVictim != m_bot && DruidSpellCombat < 7 && !pTarget->HasAura(CHALLENGING_ROAR, 0) && !pTarget->HasAura(GROWL, 0))
+    {
+        ai->CastSpell(GROWL, *pTarget);
+        DruidSpellCombat += 2;
+        return;
+    }
+
+    DruidSpellCombat = 0;
+}
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverSpellDPS(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    if (MOONKIN_FORM > 0 && !m_bot->HasAura(MOONKIN_FORM, 0))
+        ai->CastSpell (MOONKIN_FORM);
+
+    // NOTE: Tree of Life is beneficial to armor and Wrath - leave on if not in Moonkin (not talented or OutOfMana)
+    if (m_bot->HasAura(CAT_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+        //ai->TellMaster("FormClearCat");
+        return;
+    }
+    if (m_bot->HasAura(BEAR_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+        //ai->TellMaster("FormClearBear");
+        return;
+    }
+    if (m_bot->HasAura(DIRE_BEAR_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+        //ai->TellMaster("FormClearDireBear");
+        return;
+    }
+
+    if (FAERIE_FIRE > 0 && DruidSpellCombat < 1 && !pTarget->HasAura(FAERIE_FIRE, 0) && ai->GetManaPercent() >= 8)
+    {
+        ai->CastSpell(FAERIE_FIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (MOONFIRE > 0 && DruidSpellCombat < 2 && !pTarget->HasAura(MOONFIRE, 0) && ai->GetManaPercent() >= 24)
+    {
+        ai->CastSpell(MOONFIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (ROOTS > 0 && DruidSpellCombat < 3 && !pTarget->HasAura(ROOTS, 0) && ai->GetManaPercent() >= 8)
+    {
+        ai->CastSpell(ROOTS, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (HURRICANE > 0 && ai->GetAttackerCount() >= 5 && DruidSpellCombat < 4 && ai->GetManaPercent() >= 91)
+    {
+        ai->CastSpell(HURRICANE, *pTarget);
+        ai->SetIgnoreUpdateTime(10);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (WRATH > 0 && DruidSpellCombat < 5 && ai->GetManaPercent() >= 13)
+    {
+        ai->CastSpell(WRATH, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (INSECT_SWARM > 0 && DruidSpellCombat < 6 && !pTarget->HasAura(INSECT_SWARM, 0) && ai->GetManaPercent() >= 9)
+    {
+        ai->CastSpell(INSECT_SWARM, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (STARFIRE > 0 && DruidSpellCombat < 7 && ai->GetManaPercent() >= 18)
+    {
+        ai->CastSpell(STARFIRE, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (FORCE_OF_NATURE > 0 && DruidSpellCombat < 8 && ai->GetManaPercent() >= 12)
+    {
+        ai->CastSpell(FORCE_OF_NATURE);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (STARFALL > 0 && !m_bot->HasAura(STARFALL, 0) && ai->GetAttackerCount() >= 3 && DruidSpellCombat < 9 && ai->GetManaPercent() >= 39)
+    {
+        ai->CastSpell(STARFALL, *pTarget);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (BARKSKIN > 0 && pVictim == m_bot && ai->GetHealthPercent() < 75 && DruidSpellCombat < 10 && !m_bot->HasAura(BARKSKIN, 0))
+    {
+        ai->CastSpell(BARKSKIN, *m_bot);
+        return;
+    }
+
+    DruidSpellCombat++;
+    if (INNERVATE > 0 && ai->GetManaPercent() < 50 && DruidSpellCombat < 11 && !m_bot->HasAura(INNERVATE, 0))
+    {
+        ai->CastSpell(INNERVATE, *m_bot);
+        return;
+    }
+
+    DruidSpellCombat = 0;
+}
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverMeleeDPS(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    // True, bear form is set up for tanking but even then it's better DPS for levels 10-19 than humanoid form
+    if (CAT_FORM == 0 && BEAR_FORM > 0)
+        // but only go there if you can get into bear form. else stay here.
+        if (ai->CastSpell(BEAR_FORM))
+            return _DoNextPVECombatManeuverBear(pTarget);
+
+    //uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    if (!m_bot->HasInArc(M_PI, pTarget))
+    {
+        m_bot->SetFacingTo(m_bot->GetAngle(pTarget));
+        if (pVictim)
+            pVictim->Attack(pTarget, true);
+    }
+
+    if (CAT_FORM > 0 && !m_bot->HasAura(CAT_FORM, 0))
+        if (!ai->CastSpell(CAT_FORM))
+        {
+            if (ai->GetManaPercent() < 30) // TODO: tweak this value. Pretty sure bear form mana Req is way less than 30% of base mana, let alone total mana
+                return;  // conserve mana
+            else
+                _DoNextPVECombatManeuverSpellDPS(pTarget);
+        }
+
+    // Commented out: Above should take care of it
+    //// Technically bear form is better than no form for melee druids levels 10-19.
+    //if (m_bot->HasAura(BEAR_FORM, 0))
+    //{
+    //    m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+    //    //ai->TellMaster("FormClearBear");
+    //    return;
+    //}
+    //if (m_bot->HasAura(DIRE_BEAR_FORM, 0))
+    //{
+    //    m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+    //    //ai->TellMaster("FormClearDireBear");
+    //    return;
+    //}
+    //if (m_bot->HasAura(MOONKIN_FORM, 0))
+    //{
+    //    m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    //    //ai->TellMaster("FormClearMoonkin");
+    //    return;
+    //}
+
+    //if (COWER > 0 && m_bot->GetComboPoints() == 1 && ai->GetEnergyAmount() >= 20) // && HasAnyAggroWhereSecondAggroIsNotHealer()
+    //{
+    //    ai->CastSpell(COWER);
+    //    //ai->TellMaster("Cower");
+    //}
+    if (MAIM > 0 && m_bot->GetComboPoints() >= 1 && pTarget->IsNonMeleeSpellCasted(true))
+    {
+        ai->CastSpell(MAIM, *pTarget);
+        //ai->TellMaster("SpellPreventing Maim");
+        return;
+    }
+
+    if (RAKE > 0 && m_bot->GetComboPoints() < 1 && ai->GetEnergyAmount() >= 40) // should be replaced by a check for the bleed effect it causes (along with Combo != 5)
+    {
+        ai->CastSpell(RAKE, *pTarget);
+        //ai->TellMaster("Rake");
+        return;
+    }
+    if (MANGLE > 0 && m_bot->GetComboPoints() == 1 && ai->GetEnergyAmount() >= 45)
+    {
+        ai->CastSpell(MANGLE, *pTarget);
+        //ai->TellMaster("Mangle");
+        return;
+    }
+    if (CLAW > 0 && m_bot->GetComboPoints() < 5 && ai->GetEnergyAmount() >= 45)
+    {
+        ai->CastSpell(CLAW, *pTarget);
+        //ai->TellMaster("Claw");
+        return;
+    }
+
+    if (m_bot->GetComboPoints() == 5)
+    {
+        if (RIP > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 30)
+            ai->CastSpell(RIP, *pTarget);
+        else if (FEROCIOUS_BITE > 0 && ai->GetEnergyAmount() >= 35 &&
+                 (pTarget->getClass() == CLASS_HUNTER || pTarget->getClass() == CLASS_WARRIOR ||
+                  pTarget->getClass() == CLASS_PALADIN || pTarget->getClass() == CLASS_DEATH_KNIGHT))
+            ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+        else if (ai->GetEnergyAmount() >= 35)
+        {
+            //ai->TellMaster("Else Maim, Ferocious Bite or Rip.");
+            // MAIM must be first check, best option against other classes
+            if (MAIM > 0)
+                ai->CastSpell(MAIM, *pTarget);
+            else if (FEROCIOUS_BITE > 0)
+                ai->CastSpell(FEROCIOUS_BITE, *pTarget);
+            else if (RIP > 0) // Fair enough, only needs 30 energy... but that means 35 is plenty
+                ai->CastSpell(RIP, *pTarget);
+        }
+        return;
+    }
+}
+
+void PlayerbotDruidAI::_DoNextPVECombatManeuverHeal(Unit* pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    if (TREE_OF_LIFE > 0 && !m_bot->HasAura(TREE_OF_LIFE, 0))
+        ai->CastSpell(TREE_OF_LIFE, *m_bot);
+
+    if (m_bot->HasAura(CAT_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(CAT_FORM_1);
+        //ai->TellMaster("FormClearCat");
+        return;
+    }
+    if (m_bot->HasAura(BEAR_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(BEAR_FORM_1);
+        //ai->TellMaster("FormClearBear");
+        return;
+    }
+    if (m_bot->HasAura(DIRE_BEAR_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+        //ai->TellMaster("FormClearDireBear");
+        return;
+    }
+    // spellcasting form, but disables healing spells so it's got to go
+    if (m_bot->HasAura(MOONKIN_FORM, 0))
+    {
+        m_bot->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+        //ai->TellMaster("FormClearMoonkin");
+        return;
+    }
+
+    if (ai->GetHealthPercent() <= 60)
+    {
+        HealTarget(m_bot);
+        return;
+    }
+    if (masterHP <= 50)
+    {
+        HealTarget(GetMaster());
+        return;
+    }
+    // TODO: err... what about the other teammates?
+
+    DruidSpellCombat = 0;
+}
+
+void PlayerbotDruidAI::DoNonCombatActions()
+{
+    Player* m_bot = GetPlayerBot();
+    Player* master = GetMaster();
+    if (!m_bot || !master)
+        return;
+
+    PlayerbotAI* ai = GetAI();
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (!pItem && INNERVATE > 0 && !m_bot->HasAura(INNERVATE) && ai->GetManaPercent() <= 20 && ai->CastSpell(INNERVATE, *m_bot))
+        return;
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // buff and heal master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buff
+        if (!master->duel)
+            if (master->isAlive() && GIFT_OF_THE_WILD && ai->HasSpellReagents(GIFT_OF_THE_WILD) && ai->Buff(GIFT_OF_THE_WILD, master))
+                return;
+
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectAccessor->FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            // Resurrect member if needed
+            if (!tPlayer->isAlive())
+            {
+                if (ai->CastSpell(REVIVE, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+            else
+            {
+                // buff and heal
+                if (BuffPlayer(tPlayer))
+                    return;
+
+                if (HealTarget(tPlayer))
+                    return;
+            }
+        }
+    }
+    else
+    {
+        if (master->duel)
+            return;
+
+        if (master->isAlive())
+        {
+            if (BuffPlayer(master))
+                return;
+            if (HealTarget(master))
+                return;
+        }
+        else
+        if (ai->CastSpell(REVIVE, *master))
+            ai->TellMaster("Resurrecting you, Master.");
+    }
+
+    BuffPlayer(m_bot);
+} // end DoNonCombatActions
+
+bool PlayerbotDruidAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+
+    Pet * pet = target->GetPet();
+    if (pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+    {
+        if (ai->Buff(MARK_OF_THE_WILD, pet, &(PlayerbotDruidAI::GoBuffForm)))
+            return true;
+        else if (ai->Buff(THORNS, pet, &(PlayerbotDruidAI::GoBuffForm)))
+            return true;
+    }
+
+    if (ai->Buff(MARK_OF_THE_WILD, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+    else if (ai->Buff(THORNS, target, &(PlayerbotDruidAI::GoBuffForm)))
+        return true;
+    else
+        return false;
+}
+
+void PlayerbotDruidAI::GoBuffForm(Player *self)
+{
+    // RANK_1 spell ids used because this is a static method which does not have access to instance.
+    // There is only one rank for these spells anyway.
+    if (self->HasAura(CAT_FORM_1))
+        self->RemoveAurasDueToSpell(CAT_FORM_1);
+    if (self->HasAura(BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(BEAR_FORM_1);
+    if (self->HasAura(DIRE_BEAR_FORM_1))
+        self->RemoveAurasDueToSpell(DIRE_BEAR_FORM_1);
+    if (self->HasAura(MOONKIN_FORM_1))
+        self->RemoveAurasDueToSpell(MOONKIN_FORM_1);
+    if (self->HasAura(TRAVEL_FORM_1))
+        self->RemoveAurasDueToSpell(TRAVEL_FORM_1);
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
new file mode 100644
index 0000000..45102b4
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotDruidAI.h
@@ -0,0 +1,199 @@
+#ifndef _PLAYERBOTDRUIDAI_H
+#define _PLAYERBOTDRUIDAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    DruidCombat,
+    DruidTank,
+    DruidHeal,
+    DruidSpell
+};
+
+enum DruidSpells
+{
+    ABOLISH_POISON_1                = 2893,
+    AQUATIC_FORM_1                  = 1066,
+    BARKSKIN_1                      = 22812,
+    BASH_1                          = 5211,
+    BEAR_FORM_1                     = 5487,
+    BERSERK_1                       = 50334,
+    CAT_FORM_1                      = 768,
+    CHALLENGING_ROAR_1              = 5209,
+    CLAW_1                          = 1082,
+    COWER_1                         = 8998,
+    CURE_POISON_1                   = 8946,
+    CYCLONE_1                       = 33786,
+    DASH_1                          = 1850,
+    DEMORALIZING_ROAR_1             = 99,
+    DIRE_BEAR_FORM_1                = 9634,
+    ENRAGE_1                        = 5229,
+    ENTANGLING_ROOTS_1              = 339,
+    FAERIE_FIRE_1                   = 770,
+    FAERIE_FIRE_FERAL_1             = 16857,
+    FERAL_CHARGE_1                  = 49377,
+    FERAL_CHARGE_BEAR_1             = 16979,
+    FERAL_CHARGE_CAT_1              = 49376,
+    FEROCIOUS_BITE_1                = 22568,
+    FLIGHT_FORM_1                   = 33943,
+    FORCE_OF_NATURE_1               = 33831,
+    FRENZIED_REGENERATION_1         = 22842,
+    GIFT_OF_THE_WILD_1              = 21849,
+    GROWL_1                         = 6795,
+    HEALING_TOUCH_1                 = 5185,
+    HIBERNATE_1                     = 2637,
+    HURRICANE_1                     = 16914,
+    INNERVATE_1                     = 29166,
+    INSECT_SWARM_1                  = 5570,
+    LACERATE_1                      = 33745,
+    LIFEBLOOM_1                     = 33763,
+    MAIM_1                          = 22570,
+    MANGLE_1                        = 33917,
+    MANGLE_BEAR_1                   = 33878,
+    MANGLE_CAT_1                    = 33876,
+    MARK_OF_THE_WILD_1              = 1126,
+    MAUL_1                          = 6807,
+    MOONFIRE_1                      = 8921,
+    MOONKIN_FORM_1                  = 24858,
+    NATURES_GRASP_1                 = 16689,
+    NATURES_SWIFTNESS_DRUID_1       = 17116,
+    NOURISH_1                       = 50464,
+    POUNCE_1                        = 9005,
+    PROWL_1                         = 5215,
+    RAKE_1                          = 1822,
+    RAVAGE_1                        = 6785,
+    REBIRTH_1                       = 20484,
+    REGROWTH_1                      = 8936,
+    REJUVENATION_1                  = 774,
+    REMOVE_CURSE_DRUID_1            = 2782,
+    REVIVE_1                        = 50769,
+    RIP_1                           = 1079,
+    SAVAGE_ROAR_1                   = 52610,
+    SHRED_1                         = 5221,
+    SOOTHE_ANIMAL_1                 = 2908,
+    STARFALL_1                      = 48505,
+    STARFIRE_1                      = 2912,
+    SURVIVAL_INSTINCTS_1            = 61336,
+    SWIFTMEND_1                     = 18562,
+    SWIFT_FLIGHT_FORM_1             = 40120,
+    SWIPE_BEAR_1                    = 779,
+    SWIPE_CAT_1                     = 62078,
+    THORNS_1                        = 467,
+    TIGERS_FURY_1                   = 5217,
+    TRANQUILITY_1                   = 740,
+    TRAVEL_FORM_1                   = 783,
+    TREE_OF_LIFE_1                  = 33891,
+    TYPHOON_1                       = 50516,
+    WILD_GROWTH_1                   = 48438,
+    WRATH_1                         = 5176
+};
+
+//class Player;
+
+class PlayerbotDruidAI : PlayerbotClassAI
+{
+public:
+    PlayerbotDruidAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotDruidAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Combat Maneuver helper functions
+    void _DoNextPVECombatManeuverBear(Unit* pTarget);
+    void _DoNextPVECombatManeuverSpellDPS(Unit* pTarget);
+    void _DoNextPVECombatManeuverMeleeDPS(Unit* pTarget);
+    void _DoNextPVECombatManeuverHeal(Unit* pTarget);
+
+    // Heals the target based off its hps
+    bool HealTarget (Unit *target);
+    // Callback method to reset shapeshift forms blocking buffs and heals
+    static void GoBuffForm(Player *self);
+
+    // druid cat/bear/dire bear/moonkin/tree of life forms
+    uint32 CAT_FORM,
+           BEAR_FORM,
+           DIRE_BEAR_FORM,
+           MOONKIN_FORM,
+           TREE_OF_LIFE,
+           TRAVEL_FORM;
+
+    // druid cat attacks
+    uint32 CLAW,
+           COWER,
+           TIGERS_FURY,
+           RAKE,
+           RIP,
+           FEROCIOUS_BITE,
+           MAIM,
+           MANGLE;
+
+    // druid bear/dire bear attacks & buffs
+    uint32 BASH,
+           MAUL,
+           SWIPE,
+           DEMORALIZING_ROAR,
+           CHALLENGING_ROAR,
+           GROWL,
+           ENRAGE,
+           FAERIE_FIRE_FERAL;
+
+    // druid caster DPS attacks & debuffs
+    uint32 MOONFIRE,
+           ROOTS,
+           WRATH,
+           STARFALL,
+           STARFIRE,
+           INSECT_SWARM,
+           FAERIE_FIRE,
+           FORCE_OF_NATURE,
+           HURRICANE;
+
+    // druid buffs
+    uint32 MARK_OF_THE_WILD,
+           GIFT_OF_THE_WILD,
+           THORNS,
+           INNERVATE,
+           BARKSKIN;
+
+    // druid heals
+    uint32 LIFEBLOOM,
+           REJUVENATION,
+           REGROWTH,
+           NOURISH,
+           HEALING_TOUCH,
+           WILD_GROWTH,
+           SWIFTMEND,
+           TRANQUILITY,
+           REVIVE,
+           REMOVE_CURSE,
+           ABOLISH_POISON;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, DruidSpellCombat;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
new file mode 100644
index 0000000..3541b3e
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.cpp
@@ -0,0 +1,393 @@
+// an improved Hunter by rrtn & Runsttren :)
+#include "PlayerbotHunterAI.h"
+
+PlayerbotHunterAI::PlayerbotHunterAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // PET CTRL
+    PET_SUMMON                    = ai->initSpell(CALL_PET_1);
+    PET_DISMISS                   = ai->initSpell(DISMISS_PET_1);
+    PET_REVIVE                    = ai->initSpell(REVIVE_PET_1);
+    PET_MEND                      = ai->initSpell(MEND_PET_1);
+    PET_FEED                      = 1539;
+
+    INTIMIDATION                  = ai->initSpell(INTIMIDATION_1); // (generic)
+
+    // PET SKILLS must be initialized by pets
+    SONIC_BLAST                   = 0; // bat
+    DEMORALIZING_SCREECH          = 0;
+    BAD_ATTITUDE                  = 0; // crocolisk
+    NETHER_SHOCK                  = 0;
+
+    // RANGED COMBAT
+    AUTO_SHOT                     = ai->initSpell(AUTO_SHOT_1);
+    HUNTERS_MARK                  = ai->initSpell(HUNTERS_MARK_1);
+    ARCANE_SHOT                   = ai->initSpell(ARCANE_SHOT_1);
+    CONCUSSIVE_SHOT               = ai->initSpell(CONCUSSIVE_SHOT_1);
+    DISTRACTING_SHOT              = ai->initSpell(DISTRACTING_SHOT_1);
+    MULTI_SHOT                    = ai->initSpell(MULTISHOT_1);
+    EXPLOSIVE_SHOT                = ai->initSpell(EXPLOSIVE_SHOT_1);
+    SERPENT_STING                 = ai->initSpell(SERPENT_STING_1);
+    SCORPID_STING                 = ai->initSpell(SCORPID_STING_1);
+    WYVERN_STING                  = ai->initSpell(WYVERN_STING_1);
+    VIPER_STING                   = ai->initSpell(VIPER_STING_1);
+    AIMED_SHOT                    = ai->initSpell(AIMED_SHOT_1);
+    STEADY_SHOT                   = ai->initSpell(STEADY_SHOT_1);
+    CHIMERA_SHOT                  = ai->initSpell(CHIMERA_SHOT_1);
+    VOLLEY                        = ai->initSpell(VOLLEY_1);
+    BLACK_ARROW                   = ai->initSpell(BLACK_ARROW_1);
+    KILL_SHOT                     = ai->initSpell(KILL_SHOT_1);
+
+    // MELEE
+    RAPTOR_STRIKE                 = ai->initSpell(RAPTOR_STRIKE_1);
+    WING_CLIP                     = ai->initSpell(WING_CLIP_1);
+    MONGOOSE_BITE                 = ai->initSpell(MONGOOSE_BITE_1);
+    DISENGAGE                     = ai->initSpell(DISENGAGE_1);
+    MISDIRECTION                  = ai->initSpell(MISDIRECTION_1);
+    DETERRENCE                    = ai->initSpell(DETERRENCE_1);
+
+    // TRAPS
+    BEAR_TRAP                     = 0; // non-player spell
+    FREEZING_TRAP                 = ai->initSpell(FREEZING_TRAP_1);
+    IMMOLATION_TRAP               = ai->initSpell(IMMOLATION_TRAP_1);
+    FROST_TRAP                    = ai->initSpell(FROST_TRAP_1);
+    EXPLOSIVE_TRAP                = ai->initSpell(EXPLOSIVE_TRAP_1);
+    ARCANE_TRAP                   = 0; // non-player spell
+    SNAKE_TRAP                    = ai->initSpell(SNAKE_TRAP_1);
+
+    // BUFFS
+    ASPECT_OF_THE_HAWK            = ai->initSpell(ASPECT_OF_THE_HAWK_1);
+    ASPECT_OF_THE_MONKEY          = ai->initSpell(ASPECT_OF_THE_MONKEY_1);
+    RAPID_FIRE                    = ai->initSpell(RAPID_FIRE_1);
+    TRUESHOT_AURA                 = ai->initSpell(TRUESHOT_AURA_1);
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_HUNTER); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY                    = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP                     = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING                    = ai->initSpell(BERSERKING_ALL); // troll
+
+    m_petSummonFailed = false;
+    m_rangedCombat = true;
+}
+
+PlayerbotHunterAI::~PlayerbotHunterAI() {}
+
+bool PlayerbotHunterAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotHunterAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(RAPTOR_STRIKE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Hunter
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+
+    // check for pet and heal if neccessary
+    Pet *pet = m_bot->GetPet();
+    if ((pet)
+        && (((float) pet->GetHealth() / (float) pet->GetMaxHealth()) < 0.5f)
+        && (PET_MEND > 0 && !pet->getDeathState() != ALIVE && pVictim != m_bot && !pet->HasAura(PET_MEND, 0) && ai->GetManaPercent() >= 13 && ai->CastSpell(PET_MEND, *m_bot)))
+    {
+        ai->TellMaster("healing pet.");
+        return;
+    }
+    else if ((pet)
+             && (INTIMIDATION > 0 && pVictim == pet && !pet->HasAura(INTIMIDATION, 0) && ai->CastSpell(INTIMIDATION, *m_bot)))
+        //ai->TellMaster( "casting intimidation." ); // if pet has aggro :)
+        return;
+
+    // racial traits
+    if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, 0))
+        ai->CastSpell(BLOOD_FURY, *m_bot);
+    //ai->TellMaster( "Blood Fury." );
+    else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, 0))
+        ai->CastSpell(BERSERKING, *m_bot);
+    //ai->TellMaster( "Berserking." );
+
+    // check if ranged combat is possible (set m_rangedCombat and switch auras
+    float dist = GetCombatDistance(pTarget);
+    //bool useAmmo = m_bot->GetAuraEffectsByType(SPELL_AURA_ABILITY_CONSUME_NO_AMMO).empty();
+    if ((dist <= ATTACK_DISTANCE/* || (!m_bot->GetUInt32Value(PLAYER_AMMO_ID) && useAmmo)*/) && m_rangedCombat)
+    {
+        // switch to melee combat (target in melee range, out of ammo)
+        m_rangedCombat = false;
+        //if (!m_bot->GetUInt32Value(PLAYER_AMMO_ID))
+        //    ai->TellMaster("Out of ammo!");
+        // become monkey (increases dodge chance)...
+        (ASPECT_OF_THE_MONKEY > 0 && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, 0) && ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot));
+    }
+    else if (dist > ATTACK_DISTANCE && !m_rangedCombat)
+    {
+        // switch to ranged combat
+        m_rangedCombat = true;
+        // increase ranged attack power...
+        (ASPECT_OF_THE_HAWK > 0 && !m_bot->HasAura(ASPECT_OF_THE_HAWK, 0) && ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot));
+    }
+    else if (m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_HAWK, 0))
+        // check if we have hawk aspect in ranged combat
+        (ASPECT_OF_THE_HAWK > 0 && ai->CastSpell(ASPECT_OF_THE_HAWK, *m_bot));
+    else if (!m_rangedCombat && !m_bot->HasAura(ASPECT_OF_THE_MONKEY, 0))
+        // check if we have monkey aspect in melee combat
+        (ASPECT_OF_THE_MONKEY > 0 && ai->CastSpell(ASPECT_OF_THE_MONKEY, *m_bot));
+
+    // activate auto shot
+    if (AUTO_SHOT > 0 && m_rangedCombat && !m_bot->FindCurrentSpellBySpellId(AUTO_SHOT))
+        ai->CastSpell(AUTO_SHOT, *pTarget);
+    //ai->TellMaster( "started auto shot." );
+    else if (AUTO_SHOT > 0 && m_bot->FindCurrentSpellBySpellId(AUTO_SHOT))
+        m_bot->InterruptNonMeleeSpells(true, AUTO_SHOT);
+    //ai->TellMaster( "stopped auto shot." );
+
+    // damage spells
+    std::ostringstream out;
+    if (m_rangedCombat)
+    {
+        out << "Case Ranged";
+        if (HUNTERS_MARK > 0 && ai->GetManaPercent() >= 3 && !pTarget->HasAura(HUNTERS_MARK, 0) && ai->CastSpell(HUNTERS_MARK, *pTarget))
+            out << " > Hunter's Mark";
+        else if (RAPID_FIRE > 0 && ai->GetManaPercent() >= 3 && !m_bot->HasAura(RAPID_FIRE, 0) && ai->CastSpell(RAPID_FIRE, *m_bot))
+            out << " > Rapid Fire";
+        else if (MULTI_SHOT > 0 && ai->GetManaPercent() >= 13 && ai->GetAttackerCount() >= 3 && ai->CastSpell(MULTI_SHOT, *pTarget))
+            out << " > Multi-Shot";
+        else if (ARCANE_SHOT > 0 && ai->GetManaPercent() >= 7 && ai->CastSpell(ARCANE_SHOT, *pTarget))
+            out << " > Arcane Shot";
+        else if (CONCUSSIVE_SHOT > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(CONCUSSIVE_SHOT, 0) && ai->CastSpell(CONCUSSIVE_SHOT, *pTarget))
+            out << " > Concussive Shot";
+        else if (EXPLOSIVE_SHOT > 0 && ai->GetManaPercent() >= 10 && !pTarget->HasAura(EXPLOSIVE_SHOT, 0) && ai->CastSpell(EXPLOSIVE_SHOT, *pTarget))
+            out << " > Explosive Shot";
+        else if (VIPER_STING > 0 && ai->GetManaPercent() >= 8 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && !pTarget->HasAura(VIPER_STING, 0) && ai->CastSpell(VIPER_STING, *pTarget))
+            out << " > Viper Sting";
+        else if (SERPENT_STING > 0 && ai->GetManaPercent() >= 13 && !pTarget->HasAura(SERPENT_STING, 0) && !pTarget->HasAura(SCORPID_STING, 0) &&  !pTarget->HasAura(VIPER_STING, 0) && ai->CastSpell(SERPENT_STING, *pTarget))
+            out << " > Serpent Sting";
+        else if (SCORPID_STING > 0 && ai->GetManaPercent() >= 11 && !pTarget->HasAura(WYVERN_STING, 0) && !pTarget->HasAura(SCORPID_STING, 0) && !pTarget->HasAura(SERPENT_STING, 0) && !pTarget->HasAura(VIPER_STING, 0) && ai->CastSpell(SCORPID_STING, *pTarget))
+            out << " > Scorpid Sting";
+        else if (CHIMERA_SHOT > 0 && ai->GetManaPercent() >= 12 && ai->CastSpell(CHIMERA_SHOT, *pTarget))
+            out << " > Chimera Shot";
+        else if (VOLLEY > 0 && ai->GetManaPercent() >= 24 && ai->GetAttackerCount() >= 3 && ai->CastSpell(VOLLEY, *pTarget))
+            out << " > Volley";
+        else if (BLACK_ARROW > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(BLACK_ARROW, 0) && ai->CastSpell(BLACK_ARROW, *pTarget))
+            out << " > Black Arrow";
+        else if (AIMED_SHOT > 0 && ai->GetManaPercent() >= 12 && ai->CastSpell(AIMED_SHOT, *pTarget))
+            out << " > Aimed Shot";
+        else if (STEADY_SHOT > 0 && ai->GetManaPercent() >= 5 && ai->CastSpell(STEADY_SHOT, *pTarget))
+            out << " > Steady Shot";
+        else if (KILL_SHOT > 0 && ai->GetManaPercent() >= 7 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.2 && ai->CastSpell(KILL_SHOT, *pTarget))
+            out << " > Kill Shot!";
+        else
+            out << " NONE!";
+    }
+    else
+    {
+        out << "Case Melee";
+        if (RAPTOR_STRIKE > 0 && ai->GetManaPercent() >= 6 && ai->CastSpell(RAPTOR_STRIKE, *pTarget))
+            out << " > Raptor Strike";
+        else if (EXPLOSIVE_TRAP > 0 && ai->GetManaPercent() >= 27 && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && !pTarget->HasAura(BEAR_TRAP, 0) && ai->CastSpell(EXPLOSIVE_TRAP, *pTarget))
+            out << " > Explosive Trap";
+        else if (WING_CLIP > 0 && ai->GetManaPercent() >= 6 && !pTarget->HasAura(WING_CLIP, 0) && ai->CastSpell(WING_CLIP, *pTarget))
+            out << " > Wing Clip";
+        else if (IMMOLATION_TRAP > 0 && ai->GetManaPercent() >= 13 && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && !pTarget->HasAura(BEAR_TRAP, 0) && ai->CastSpell(IMMOLATION_TRAP, *pTarget))
+            out << " > Immolation Trap";
+        else if (MONGOOSE_BITE > 0 && ai->GetManaPercent() >= 4 && ai->CastSpell(MONGOOSE_BITE, *pTarget))
+            out << " > Mongoose Bite";
+        else if (FROST_TRAP > 0 && ai->GetManaPercent() >= 2 && !pTarget->HasAura(FROST_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(BEAR_TRAP, 0) && ai->CastSpell(FROST_TRAP, *pTarget))
+            out << " > Frost Trap";
+        else if (ARCANE_TRAP > 0 && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(BEAR_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && ai->CastSpell(ARCANE_TRAP, *pTarget))
+            out << " > Arcane Trap";
+        else if (DETERRENCE > 0 && pVictim == m_bot && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && !m_bot->HasAura(DETERRENCE, 0) && ai->CastSpell(DETERRENCE, *m_bot))
+            out << " > Deterrence";
+        else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, 0) && ai->CastSpell(WAR_STOMP, *pTarget))
+            out << " > War Stomp";
+        else if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT, 0) && ai->CastSpell(ARCANE_TORRENT, *pTarget))
+            out << " > Arcane Torrent";
+        else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+            out << " > Stoneform";
+        else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD, 0) && ai->CastSpell(SHADOWMELD, *m_bot))
+            out << " > Shadowmeld";
+        else if (m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, 0) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
+            out << " > Gift of the Naaru";
+        else if ((pet && !pet->getDeathState() != ALIVE)
+                 && (MISDIRECTION > 0 && pVictim == m_bot && !m_bot->HasAura(MISDIRECTION, 0) && ai->GetManaPercent() >= 9 && ai->CastSpell(MISDIRECTION, *pet)))
+            out << " > Misdirection";  // give threat to pet
+        /*else if( FREEZING_TRAP>0 && ai->GetManaPercent()>=5 && !pTarget->HasAura(FREEZING_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(BEAR_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && ai->CastSpell(FREEZING_TRAP,*pTarget) )
+            out << " > Freezing Trap"; // this can trap your bots too
+           else if( BEAR_TRAP>0 && !pTarget->HasAura(BEAR_TRAP, 0) && !pTarget->HasAura(ARCANE_TRAP, 0) && !pTarget->HasAura(EXPLOSIVE_TRAP, 0) && !pTarget->HasAura(IMMOLATION_TRAP, 0) && !pTarget->HasAura(FROST_TRAP, 0) && ai->CastSpell(BEAR_TRAP,*pTarget) )
+            out << " > Bear Trap"; // this was just too annoying :)
+           else if( DISENGAGE>0 && pVictim && ai->GetManaPercent()>=5 && ai->CastSpell(DISENGAGE,*pTarget) )
+            out << " > Disengage!"; // attempt to return to ranged combat*/
+        else
+            out << " NONE!";
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+} // end DoNextCombatManeuver
+
+void PlayerbotHunterAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if (!ai)
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // reset ranged combat state
+    if (!m_rangedCombat)
+        m_rangedCombat = true;
+
+    // buff group
+    if (TRUESHOT_AURA > 0)
+        (!m_bot->HasAura(TRUESHOT_AURA, 0) && ai->CastSpell (TRUESHOT_AURA, *m_bot));
+
+    // buff myself
+    if (ASPECT_OF_THE_HAWK > 0)
+        (!m_bot->HasAura(ASPECT_OF_THE_HAWK, 0) && ai->CastSpell (ASPECT_OF_THE_HAWK, *m_bot));
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+
+    // check for pet
+    if (PET_SUMMON > 0 && !m_petSummonFailed && m_bot->GetPetGUID())
+    {
+        // we can summon pet, and no critical summon errors before
+        Pet *pet = m_bot->GetPet();
+        if (!pet)
+        {
+            // summon pet
+            if (PET_SUMMON > 0 && ai->CastSpell(PET_SUMMON, *m_bot))
+                ai->TellMaster("summoning pet.");
+            else
+            {
+                m_petSummonFailed = true;
+                ai->TellMaster("summon pet failed!");
+            }
+        }
+        else if (pet->getDeathState() != ALIVE)
+        {
+            // revive pet
+            if (PET_REVIVE > 0 && ai->GetManaPercent() >= 80 && ai->CastSpell(PET_REVIVE, *m_bot))
+                ai->TellMaster("reviving pet.");
+        }
+        else if (((float) pet->GetHealth() / (float) pet->GetMaxHealth()) < 0.5f)
+        {
+            // heal pet when health lower 50%
+            if (PET_MEND > 0 && !pet->getDeathState() != ALIVE && !pet->HasAura(PET_MEND, 0) && ai->GetManaPercent() >= 13 && ai->CastSpell(PET_MEND, *m_bot))
+                ai->TellMaster("healing pet.");
+        }
+        else if (pet->GetHappinessState() != HAPPY) // if pet is hungry
+        {
+            Unit *caster = (Unit *) m_bot;
+            // list out items in main backpack
+            for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+            {
+                Item* const pItem = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                    {
+                        // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                        caster->CastSpell(caster, 51284, true); // pet feed visual
+                        uint32 count = 1; // number of items used
+                        int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                        m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                        m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, NULL, NULL, true); // feed pet
+                        ai->TellMaster("feeding pet.");
+                        ai->SetIgnoreUpdateTime(10);
+                        return;
+                    }
+                }
+            }
+            // list out items in other removable backpacks
+            for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+            {
+                const Bag* const pBag = (Bag *) m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+                if (pBag)
+                    for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+                    {
+                        Item* const pItem = m_bot->GetItemByPos(bag, slot);
+                        if (pItem)
+                        {
+                            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                            if (!pItemProto)
+                                continue;
+
+                            if (pet->HaveInDiet(pItemProto)) // is pItem in pets diet
+                            {
+                                // DEBUG_LOG ("[PlayerbotHunterAI]: DoNonCombatActions - Food for pet: %s",pItemProto->Name1);
+                                caster->CastSpell(caster, 51284, true); // pet feed visual
+                                uint32 count = 1; // number of items used
+                                int32 benefit = pet->GetCurrentFoodBenefitLevel(pItemProto->ItemLevel); // nutritional value of food
+                                m_bot->DestroyItemCount(pItem, count, true); // remove item from inventory
+                                m_bot->CastCustomSpell(m_bot, PET_FEED, &benefit, NULL, NULL, true); // feed pet
+                                ai->TellMaster("feeding pet.");
+                                ai->SetIgnoreUpdateTime(10);
+                                return;
+                            }
+                        }
+                    }
+            }
+            if (pet->HasAura(PET_MEND, 0) && !pet->HasAura(PET_FEED, 0))
+                ai->TellMaster("..no pet food!");
+            ai->SetIgnoreUpdateTime(7);
+        }
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
new file mode 100644
index 0000000..388d203
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotHunterAI.h
@@ -0,0 +1,121 @@
+#ifndef _PLAYERHUNTERAI_H
+#define _PLAYERHUNTERAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_HUNTER
+};
+
+enum HunterSpells
+{
+    ARCANE_SHOT_1                   = 3044,
+    ASPECT_OF_THE_BEAST_1           = 13161,
+    ASPECT_OF_THE_CHEETAH_1         = 5118,
+    ASPECT_OF_THE_DRAGONHAWK_1      = 61846,
+    ASPECT_OF_THE_HAWK_1            = 13165,
+    ASPECT_OF_THE_MONKEY_1          = 13163,
+    ASPECT_OF_THE_PACK_1            = 13159,
+    ASPECT_OF_THE_VIPER_1           = 34074,
+    ASPECT_OF_THE_WILD_1            = 20043,
+    AUTO_SHOT_1                     = 75,
+    BEAST_LORE_1                    = 1462,
+    CALL_PET_1                      = 883,
+    CALL_STABLED_PET_1              = 62757,
+    CONCUSSIVE_SHOT_1               = 5116,
+    DETERRENCE_1                    = 19263,
+    DISENGAGE_1                     = 781,
+    DISMISS_PET_1                   = 2641,
+    DISTRACTING_SHOT_1              = 20736,
+    EAGLE_EYE_1                     = 6197,
+    EXPLOSIVE_TRAP_1                = 13813,
+    EYES_OF_THE_BEAST_1             = 1002,
+    FEED_PET_1                      = 6991,
+    FEIGN_DEATH_1                   = 5384,
+    FLARE_1                         = 1543,
+    FREEZING_ARROW_1                = 60192,
+    FREEZING_TRAP_1                 = 1499,
+    FROST_TRAP_1                    = 13809,
+    HUNTERS_MARK_1                  = 1130,
+    IMMOLATION_TRAP_1               = 13795,
+    KILL_COMMAND_1                  = 34026,
+    KILL_SHOT_1                     = 53351,
+    MASTERS_CALL_1                  = 53271,
+    MEND_PET_1                      = 136,
+    MISDIRECTION_1                  = 34477,
+    MONGOOSE_BITE_1                 = 1495,
+    MULTISHOT_1                     = 2643,
+    RAPID_FIRE_1                    = 3045,
+    RAPTOR_STRIKE_1                 = 2973,
+    REVIVE_PET_1                    = 982,
+    SCARE_BEAST_1                   = 1513,
+    SCORPID_STING_1                 = 3043,
+    SERPENT_STING_1                 = 1978,
+    SNAKE_TRAP_1                    = 34600,
+    STEADY_SHOT_1                   = 56641,
+    TAME_BEAST_1                    = 1515,
+    TRACK_BEASTS_1                  = 1494,
+    TRACK_DEMONS_1                  = 19878,
+    TRACK_DRAGONKIN_1               = 19879,
+    TRACK_ELEMENTALS_1              = 19880,
+    TRACK_GIANTS_1                  = 19882,
+    TRACK_HIDDEN_1                  = 19885,
+    TRACK_HUMANOIDS_1               = 19883,
+    TRACK_UNDEAD_1                  = 19884,
+    TRANQUILIZING_SHOT_1            = 19801,
+    VIPER_STING_1                   = 3034,
+    VOLLEY_1                        = 1510,
+    WING_CLIP_1                     = 2974,
+    AIMED_SHOT_1                    = 19434,
+    BESTIAL_WRATH_1                 = 19574,
+    BLACK_ARROW_1                   = 3674,
+    CHIMERA_SHOT_1                  = 53209,
+    COUNTERATTACK_1                 = 19306,
+    EXPLOSIVE_SHOT_1                = 53301,
+    INTIMIDATION_1                  = 19577,
+    READINESS_1                     = 23989,
+    SCATTER_SHOT_1                  = 19503,
+    SILENCING_SHOT_1                = 34490,
+    TRUESHOT_AURA_1                 = 19506,
+    WYVERN_STING_1                  = 19386
+};
+
+//class Player;
+
+class PlayerbotHunterAI : PlayerbotClassAI
+{
+public:
+    PlayerbotHunterAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotHunterAI();
+    bool HasPet(Player* bot);
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+    // Hunter
+    bool m_petSummonFailed;
+    bool m_rangedCombat;
+
+    uint32 PET_SUMMON, PET_DISMISS, PET_REVIVE, PET_MEND, PET_FEED, BAD_ATTITUDE, SONIC_BLAST, NETHER_SHOCK, DEMORALIZING_SCREECH, INTIMIDATION;
+    uint32 AUTO_SHOT, HUNTERS_MARK, ARCANE_SHOT, CONCUSSIVE_SHOT, DISTRACTING_SHOT, MULTI_SHOT, EXPLOSIVE_SHOT, SERPENT_STING, SCORPID_STING, VIPER_STING, WYVERN_STING, AIMED_SHOT, STEADY_SHOT, CHIMERA_SHOT, VOLLEY, BLACK_ARROW, KILL_SHOT;
+    uint32 RAPTOR_STRIKE, WING_CLIP, MONGOOSE_BITE, DISENGAGE, DETERRENCE;
+    uint32 BEAR_TRAP, FREEZING_TRAP, IMMOLATION_TRAP, FROST_TRAP, EXPLOSIVE_TRAP, ARCANE_TRAP, SNAKE_TRAP;
+    uint32 ASPECT_OF_THE_HAWK, ASPECT_OF_THE_MONKEY, RAPID_FIRE, TRUESHOT_AURA, MISDIRECTION;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
new file mode 100644
index 0000000..53d23ea
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.cpp
@@ -0,0 +1,470 @@
+#include "PlayerbotMageAI.h"
+#include "ObjectAccessor.h"
+
+PlayerbotMageAI::PlayerbotMageAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    ARCANE_MISSILES         = ai->initSpell(ARCANE_MISSILES_1);
+    ARCANE_EXPLOSION        = ai->initSpell(ARCANE_EXPLOSION_1);
+    COUNTERSPELL            = ai->initSpell(COUNTERSPELL_1);
+    SLOW                    = ai->initSpell(SLOW_1);
+    ARCANE_BARRAGE          = ai->initSpell(ARCANE_BARRAGE_1);
+    ARCANE_BLAST            = ai->initSpell(ARCANE_BLAST_1);
+    ARCANE_POWER            = ai->initSpell(ARCANE_POWER_1);
+    DAMPEN_MAGIC            = ai->initSpell(DAMPEN_MAGIC_1);
+    AMPLIFY_MAGIC           = ai->initSpell(AMPLIFY_MAGIC_1);
+    MAGE_ARMOR              = ai->initSpell(MAGE_ARMOR_1);
+    MIRROR_IMAGE            = ai->initSpell(MIRROR_IMAGE_1);
+    ARCANE_INTELLECT        = ai->initSpell(ARCANE_INTELLECT_1);
+    ARCANE_BRILLIANCE       = ai->initSpell(ARCANE_BRILLIANCE_1);
+    DALARAN_INTELLECT       = ai->initSpell(DALARAN_INTELLECT_1);
+    DALARAN_BRILLIANCE      = ai->initSpell(DALARAN_BRILLIANCE_1);
+    MANA_SHIELD             = ai->initSpell(MANA_SHIELD_1);
+    CONJURE_WATER           = ai->initSpell(CONJURE_WATER_1);
+    CONJURE_FOOD            = ai->initSpell(CONJURE_FOOD_1);
+    FIREBALL                = ai->initSpell(FIREBALL_1);
+    FIRE_BLAST              = ai->initSpell(FIRE_BLAST_1);
+    FLAMESTRIKE             = ai->initSpell(FLAMESTRIKE_1);
+    SCORCH                  = ai->initSpell(SCORCH_1);
+    PYROBLAST               = ai->initSpell(PYROBLAST_1);
+    BLAST_WAVE              = ai->initSpell(BLAST_WAVE_1);
+    COMBUSTION              = ai->initSpell(COMBUSTION_1);
+    DRAGONS_BREATH          = ai->initSpell(DRAGONS_BREATH_1);
+    LIVING_BOMB             = ai->initSpell(LIVING_BOMB_1);
+    FROSTFIRE_BOLT          = ai->initSpell(FROSTFIRE_BOLT_1);
+    FIRE_WARD               = ai->initSpell(FIRE_WARD_1);
+    MOLTEN_ARMOR            = ai->initSpell(MOLTEN_ARMOR_1);
+    ICY_VEINS               = ai->initSpell(ICY_VEINS_1);
+    DEEP_FREEZE             = ai->initSpell(DEEP_FREEZE_1);
+    FROSTBOLT               = ai->initSpell(FROSTBOLT_1);
+    FROST_NOVA              = ai->initSpell(FROST_NOVA_1);
+    BLIZZARD                = ai->initSpell(BLIZZARD_1);
+    CONE_OF_COLD            = ai->initSpell(CONE_OF_COLD_1);
+    ICE_BARRIER             = ai->initSpell(ICE_BARRIER_1);
+    SUMMON_WATER_ELEMENTAL  = ai->initSpell(SUMMON_WATER_ELEMENTAL_1);
+    FROST_WARD              = ai->initSpell(FROST_WARD_1);
+    ICE_LANCE               = ai->initSpell(ICE_LANCE_1);
+    FROST_ARMOR             = ai->initSpell(FROST_ARMOR_1);
+    ICE_ARMOR               = ai->initSpell(ICE_ARMOR_1);
+    ICE_BLOCK               = ai->initSpell(ICE_BLOCK_1);
+    COLD_SNAP               = ai->initSpell(COLD_SNAP_1);
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT          = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_MAGE); // draenei
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotMageAI::~PlayerbotMageAI() {}
+
+bool PlayerbotMageAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotMageAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (FIREBALL > 0)
+                ai->CastSpell(FIREBALL);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    // Damage Spells (primitive example)
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float dist = GetCombatDistance(pTarget);
+
+    switch (SpellSequence)
+    {
+        case SPELL_FROST:
+            if (ICY_VEINS > 0 && !m_bot->HasAura(ICY_VEINS, 0) && LastSpellFrost < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(ICY_VEINS, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROSTBOLT > 0 && LastSpellFrost < 2 && !pTarget->HasAura(FROSTBOLT, 0) && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(FROSTBOLT, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROST_WARD > 0 && LastSpellFrost < 3 && !m_bot->HasAura(FROST_WARD, 0) && ai->GetManaPercent() >= 19)
+            {
+                ai->CastSpell(FROST_WARD, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (FROST_NOVA > 0 && LastSpellFrost < 4 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(FROST_NOVA, 0) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_NOVA, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_LANCE > 0 && LastSpellFrost < 5 && ai->GetManaPercent() >= 7)
+            {
+                ai->CastSpell(ICE_LANCE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (BLIZZARD > 0 && LastSpellFrost < 6 && ai->GetAttackerCount() >= 5 && ai->GetManaPercent() >= 89)
+            {
+                ai->CastSpell(BLIZZARD, *pTarget);
+                ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (CONE_OF_COLD > 0 && LastSpellFrost < 7 && dist <= ATTACK_DISTANCE && !pTarget->HasAura(CONE_OF_COLD, 0) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(CONE_OF_COLD, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (DEEP_FREEZE > 0 && LastSpellFrost < 8 && pTarget->HasAura(AURA_STATE_FROZEN, 0) && !pTarget->HasAura(DEEP_FREEZE, 0) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(DEEP_FREEZE, *pTarget);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_BARRIER > 0 && LastSpellFrost < 9 && pVictim == m_bot && !m_bot->HasAura(ICE_BARRIER, 0) && ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 30)
+            {
+                ai->CastSpell(ICE_BARRIER, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (SUMMON_WATER_ELEMENTAL > 0 && LastSpellFrost < 10 && ai->GetManaPercent() >= 16)
+            {
+                ai->CastSpell(SUMMON_WATER_ELEMENTAL);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (ICE_BLOCK > 0 && LastSpellFrost < 11 && pVictim == m_bot && !m_bot->HasAura(ICE_BLOCK, 0) && ai->GetHealthPercent() < 30)
+            {
+                ai->CastSpell(ICE_BLOCK, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            else if (COLD_SNAP > 0 && LastSpellFrost < 12)
+            {
+                ai->CastSpell(COLD_SNAP, *m_bot);
+                SpellSequence = SPELL_FIRE;
+                LastSpellFrost = LastSpellFrost + 1;
+                break;
+            }
+            LastSpellFrost = 0;
+        //SpellSequence = SPELL_FIRE;
+        //break;
+
+        case SPELL_FIRE:
+            if (FIRE_WARD > 0 && !m_bot->HasAura(FIRE_WARD, 0) && LastSpellFire < 1 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(FIRE_WARD, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (COMBUSTION > 0 && !m_bot->HasAura(COMBUSTION, 0) && LastSpellFire < 2)
+            {
+                ai->CastSpell(COMBUSTION, *m_bot);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FIREBALL > 0 && LastSpellFire < 3 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIREBALL, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FIRE_BLAST > 0 && LastSpellFire < 4 && ai->GetManaPercent() >= 25)
+            {
+                ai->CastSpell(FIRE_BLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FLAMESTRIKE > 0 && LastSpellFire < 5 && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(FLAMESTRIKE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (SCORCH > 0 && LastSpellFire < 6 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(SCORCH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (PYROBLAST > 0 && LastSpellFire < 7 && !pTarget->HasAura(PYROBLAST, 0) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(PYROBLAST, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (BLAST_WAVE > 0 && LastSpellFire < 8 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 34)
+            {
+                ai->CastSpell(BLAST_WAVE, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (DRAGONS_BREATH > 0 && LastSpellFire < 9 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(DRAGONS_BREATH, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (LIVING_BOMB > 0 && LastSpellFire < 10 && !pTarget->HasAura(LIVING_BOMB, 0) && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(LIVING_BOMB, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            else if (FROSTFIRE_BOLT > 0 && LastSpellFire < 11 && !pTarget->HasAura(FROSTFIRE_BOLT, 0) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FROSTFIRE_BOLT, *pTarget);
+                SpellSequence = SPELL_ARCANE;
+                LastSpellFire = LastSpellFire + 1;
+                break;
+            }
+            LastSpellFire = 0;
+        //SpellSequence = SPELL_ARCANE;
+        //break;
+
+        case SPELL_ARCANE:
+            if (ARCANE_POWER > 0 && LastSpellArcane < 1 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_POWER, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_MISSILES > 0 && LastSpellArcane < 2 && ai->GetManaPercent() >= 37)
+            {
+                ai->CastSpell(ARCANE_MISSILES, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_EXPLOSION > 0 && LastSpellArcane < 3 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_EXPLOSION, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (COUNTERSPELL > 0 && pTarget->IsNonMeleeSpellCasted(true) && LastSpellArcane < 4 && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(COUNTERSPELL, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (SLOW > 0 && LastSpellArcane < 5 && !pTarget->HasAura(SLOW, 0) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(SLOW, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_BARRAGE > 0 && LastSpellArcane < 6 && ai->GetManaPercent() >= 27)
+            {
+                ai->CastSpell(ARCANE_BARRAGE, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (ARCANE_BLAST > 0 && LastSpellArcane < 7 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(ARCANE_BLAST, *pTarget);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (MIRROR_IMAGE > 0 && LastSpellArcane < 8 && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(MIRROR_IMAGE);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else if (MANA_SHIELD > 0 && LastSpellArcane < 9 && ai->GetHealthPercent() < 70 && pVictim == m_bot && !m_bot->HasAura(MANA_SHIELD, 0) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(MANA_SHIELD, *m_bot);
+                SpellSequence = SPELL_FROST;
+                LastSpellArcane = LastSpellArcane + 1;
+                break;
+            }
+            else
+            {
+                LastSpellArcane = 0;
+                SpellSequence = SPELL_FROST;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotMageAI::DoNonCombatActions()
+{
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+
+    if (!m_bot || !master)
+        return;
+
+    SpellSequence = SPELL_FROST;
+    PlayerbotAI* ai = GetAI();
+
+    // Buff armor
+    if (MOLTEN_ARMOR)
+    {
+        if (ai->SelfBuff(MOLTEN_ARMOR))
+            return;
+    }
+    else if (MAGE_ARMOR)
+    {
+        if (ai->SelfBuff(MAGE_ARMOR))
+            return;
+    }
+    else if (ICE_ARMOR)
+    {
+        if (ai->SelfBuff(ICE_ARMOR))
+            return;
+    }
+    else if (FROST_ARMOR)
+        if (ai->SelfBuff(FROST_ARMOR))
+            return;
+
+    // buff master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buff...
+        if (!(master->duel && master->duel->initiator == master && master->duel->startTime != 0))
+            if (ARCANE_BRILLIANCE && master->getPowerType() == POWER_MANA && ai->HasSpellReagents(ARCANE_BRILLIANCE))
+                if (ai->Buff(ARCANE_BRILLIANCE, master))
+                    return;
+
+        // ...and check group for new members joined or resurrected, or just buff everyone if no group buff available
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectAccessor->FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == master && tPlayer->duel->startTime != 0)
+                continue;
+
+            if (tPlayer->getPowerType() != POWER_MANA)
+                continue;
+
+            // buff
+            if (BuffPlayer(tPlayer))
+                return;
+        }
+
+    }
+    // There is no group, buff master
+    else if (master->isAlive() && !(master->duel && master->duel->initiator == master && master->duel->startTime != 0))
+        if (BuffPlayer(master))
+            return;
+
+    // Buff self finally
+    if (BuffPlayer(m_bot))
+        return;
+
+    // conjure food & water
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem == NULL && CONJURE_WATER && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some water.");
+        ai->CastSpell(CONJURE_WATER, *m_bot);
+        ai->SetIgnoreUpdateTime(3);
+        return;
+    }
+    else if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    pItem = ai->FindFood();
+
+    if (pItem == NULL && CONJURE_FOOD && ai->GetBaseManaPercent() >= 48)
+    {
+        ai->TellMaster("I'm conjuring some food.");
+        ai->CastSpell(CONJURE_FOOD, *m_bot);
+        ai->SetIgnoreUpdateTime(3);
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+} // end DoNonCombatActions
+
+bool PlayerbotMageAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    Pet * pet = target->GetPet();
+
+    if ((pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE)) && pet->getPowerType() == POWER_MANA && ai->Buff(ARCANE_INTELLECT, pet))
+        return true;
+
+    if (ARCANE_INTELLECT)
+        return ai->Buff(ARCANE_INTELLECT, target);
+    else
+        return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotMageAI.h b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
new file mode 100644
index 0000000..c618473
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotMageAI.h
@@ -0,0 +1,163 @@
+#ifndef _PlayerbotMageAI_H
+#define _PlayerbotMageAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_FROST,
+    SPELL_FIRE,
+    SPELL_ARCANE
+};
+
+enum MageSpells
+{
+    AMPLIFY_MAGIC_1                 = 1008,
+    ARCANE_BARRAGE_1                = 44425,
+    ARCANE_BLAST_1                  = 30451,
+    ARCANE_BRILLIANCE_1             = 23028,
+    ARCANE_EXPLOSION_1              = 1449,
+    ARCANE_INTELLECT_1              = 1459,
+    ARCANE_MISSILES_1               = 5143,
+    ARCANE_POWER_1                  = 12042,
+    BLAST_WAVE_1                    = 11113,
+    BLINK_1                         = 1953,
+    BLIZZARD_1                      = 10,
+    COLD_SNAP_1                     = 11958,
+    COMBUSTION_1                    = 11129,
+    CONE_OF_COLD_1                  = 120,
+    CONJURE_FOOD_1                  = 587,
+    CONJURE_MANA_GEM_1              = 759,
+    CONJURE_REFRESHMENT_1           = 42955,
+    CONJURE_WATER_1                 = 5504,
+    COUNTERSPELL_1                  = 2139,
+    DALARAN_BRILLIANCE_1            = 61316,
+    DALARAN_INTELLECT_1             = 61024,
+    DAMPEN_MAGIC_1                  = 604,
+    DEEP_FREEZE_1                   = 44572,
+    DRAGONS_BREATH_1                = 31661,
+    EVOCATION_1                     = 12051,
+    FIRE_BLAST_1                    = 2136,
+    FIRE_WARD_1                     = 543,
+    FIREBALL_1                      = 133,
+    FLAMESTRIKE_1                   = 2120,
+    FOCUS_MAGIC_1                   = 54646,
+    FROST_ARMOR_1                   = 168,
+    FROST_NOVA_1                    = 122,
+    FROST_WARD_1                    = 6143,
+    FROSTBOLT_1                     = 116,
+    FROSTFIRE_BOLT_1                = 44614,
+    ICE_ARMOR_1                     = 7302,
+    ICE_BARRIER_1                   = 11426,
+    ICE_BLOCK_1                     = 45438,
+    ICE_LANCE_1                     = 30455,
+    ICY_VEINS_1                     = 12472,
+    INVISIBILITY_1                  = 66,
+    LIVING_BOMB_1                   = 44457,
+    MAGE_ARMOR_1                    = 6117,
+    MANA_SHIELD_1                   = 1463,
+    MIRROR_IMAGE_1                  = 55342,
+    MOLTEN_ARMOR_1                  = 30482,
+    PRESENCE_OF_MIND_1              = 12043,
+    PYROBLAST_1                     = 11366,
+    REMOVE_CURSE_MAGE_1             = 475,
+    RITUAL_OF_REFRESHMENT_1         = 43987,
+    SCORCH_1                        = 2948,
+    SLOW_1                          = 31589,
+    SLOW_FALL_1                     = 130,
+    SPELLSTEAL_1                    = 30449,
+    SUMMON_WATER_ELEMENTAL_1        = 31687
+};
+//class Player;
+
+class PlayerbotMageAI : PlayerbotClassAI
+{
+public:
+    PlayerbotMageAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotMageAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // ARCANE
+    uint32 ARCANE_MISSILES,
+           ARCANE_EXPLOSION,
+           COUNTERSPELL,
+           SLOW,
+           ARCANE_BARRAGE,
+           ARCANE_BLAST,
+           MIRROR_IMAGE,
+           ARCANE_POWER;
+
+    // FIRE
+    uint32 FIREBALL,
+           FIRE_BLAST,
+           FLAMESTRIKE,
+           SCORCH,
+           PYROBLAST,
+           BLAST_WAVE,
+           COMBUSTION,
+           DRAGONS_BREATH,
+           LIVING_BOMB,
+           FROSTFIRE_BOLT,
+           FIRE_WARD;
+
+    // FROST
+    uint32 DEEP_FREEZE,
+           FROSTBOLT,
+           FROST_NOVA,
+           BLIZZARD,
+           ICY_VEINS,
+           CONE_OF_COLD,
+           ICE_BARRIER,
+           SUMMON_WATER_ELEMENTAL,
+           ICE_LANCE,
+           FROST_WARD,
+           ICE_BLOCK,
+           COLD_SNAP;
+
+    // buffs
+    uint32 FROST_ARMOR,
+           ICE_ARMOR,
+           MAGE_ARMOR,
+           MOLTEN_ARMOR,
+           ARCANE_INTELLECT,
+           ARCANE_BRILLIANCE,
+           DALARAN_INTELLECT,
+           DALARAN_BRILLIANCE,
+           MANA_SHIELD,
+           DAMPEN_MAGIC,
+           AMPLIFY_MAGIC;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence,
+           LastSpellArcane,
+           LastSpellFire,
+           LastSpellFrost,
+           CONJURE_WATER,
+           CONJURE_FOOD;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
new file mode 100644
index 0000000..2d61666
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.cpp
@@ -0,0 +1,616 @@
+/*
+   Name    : PlayerbotPaladinAI.cpp
+   Complete: maybe around 27% :D
+   Author  : Natsukawa
+   Version : 0.35
+ */
+#include "PlayerbotPaladinAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+
+PlayerbotPaladinAI::PlayerbotPaladinAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RETRIBUTION_AURA              = ai->initSpell(RETRIBUTION_AURA_1);
+    CRUSADER_AURA                 = ai->initSpell(CRUSADER_AURA_1);
+    CRUSADER_STRIKE               = ai->initSpell(CRUSADER_STRIKE_1);
+    SEAL_OF_COMMAND               = ai->initSpell(SEAL_OF_COMMAND_1);
+    SEAL_OF_RIGHTEOUSNESS         = ai->initSpell(SEAL_OF_RIGHTEOUSNESS_1);
+    SEAL_OF_CORRUPTION            = ai->initSpell(SEAL_OF_CORRUPTION_1);
+    SEAL_OF_JUSTICE               = ai->initSpell(SEAL_OF_JUSTICE_1);
+    SEAL_OF_LIGHT                 = ai->initSpell(SEAL_OF_LIGHT_1);
+    SEAL_OF_VENGEANCE             = ai->initSpell(SEAL_OF_VENGEANCE_1);
+    SEAL_OF_WISDOM                = ai->initSpell(SEAL_OF_WISDOM_1);
+    JUDGEMENT_OF_LIGHT            = ai->initSpell(JUDGEMENT_OF_LIGHT_1);
+    JUDGEMENT_OF_WISDOM           = ai->initSpell(JUDGEMENT_OF_WISDOM_1);
+    JUDGEMENT_OF_JUSTICE          = ai->initSpell(JUDGEMENT_OF_JUSTICE_1);
+    DIVINE_STORM                  = ai->initSpell(DIVINE_STORM_1);
+    BLESSING_OF_MIGHT             = ai->initSpell(BLESSING_OF_MIGHT_1);
+    GREATER_BLESSING_OF_MIGHT     = ai->initSpell(GREATER_BLESSING_OF_MIGHT_1);
+    HAMMER_OF_WRATH               = ai->initSpell(HAMMER_OF_WRATH_1);
+    FLASH_OF_LIGHT                = ai->initSpell(FLASH_OF_LIGHT_1); // Holy
+    HOLY_LIGHT                    = ai->initSpell(HOLY_LIGHT_1);
+    HOLY_SHOCK                    = ai->initSpell(HOLY_SHOCK_1);
+    HOLY_WRATH                    = ai->initSpell(HOLY_WRATH_1);
+    DIVINE_FAVOR                  = ai->initSpell(DIVINE_FAVOR_1);
+    CONCENTRATION_AURA            = ai->initSpell(CONCENTRATION_AURA_1);
+    BLESSING_OF_WISDOM            = ai->initSpell(BLESSING_OF_WISDOM_1);
+    GREATER_BLESSING_OF_WISDOM    = ai->initSpell(GREATER_BLESSING_OF_WISDOM_1);
+    CONSECRATION                  = ai->initSpell(CONSECRATION_1);
+    AVENGING_WRATH                = ai->initSpell(AVENGING_WRATH_1);
+    LAY_ON_HANDS                  = ai->initSpell(LAY_ON_HANDS_1);
+    EXORCISM                      = ai->initSpell(EXORCISM_1);
+    SACRED_SHIELD                 = ai->initSpell(SACRED_SHIELD_1);
+    DIVINE_PLEA                   = ai->initSpell(DIVINE_PLEA_1);
+    BLESSING_OF_KINGS             = ai->initSpell(BLESSING_OF_KINGS_1);
+    GREATER_BLESSING_OF_KINGS     = ai->initSpell(GREATER_BLESSING_OF_KINGS_1);
+    BLESSING_OF_SANCTUARY         = ai->initSpell(BLESSING_OF_SANCTUARY_1);
+    GREATER_BLESSING_OF_SANCTUARY = ai->initSpell(GREATER_BLESSING_OF_SANCTUARY_1);
+    HAMMER_OF_JUSTICE             = ai->initSpell(HAMMER_OF_JUSTICE_1);
+    RIGHTEOUS_FURY                = ai->initSpell(RIGHTEOUS_FURY_1);
+    RIGHTEOUS_DEFENSE             = ai->initSpell(RIGHTEOUS_DEFENSE_1);
+    SHADOW_RESISTANCE_AURA        = ai->initSpell(SHADOW_RESISTANCE_AURA_1);
+    DEVOTION_AURA                 = ai->initSpell(DEVOTION_AURA_1);
+    FIRE_RESISTANCE_AURA          = ai->initSpell(FIRE_RESISTANCE_AURA_1);
+    FROST_RESISTANCE_AURA         = ai->initSpell(FROST_RESISTANCE_AURA_1);
+    HAND_OF_PROTECTION            = ai->initSpell(HAND_OF_PROTECTION_1);
+    DIVINE_PROTECTION             = ai->initSpell(DIVINE_PROTECTION_1);
+    DIVINE_INTERVENTION           = ai->initSpell(DIVINE_INTERVENTION_1);
+    DIVINE_SACRIFICE              = ai->initSpell(DIVINE_SACRIFICE_1);
+    DIVINE_SHIELD                 = ai->initSpell(DIVINE_SHIELD_1);
+    HOLY_SHIELD                   = ai->initSpell(HOLY_SHIELD_1);
+    AVENGERS_SHIELD               = ai->initSpell(AVENGERS_SHIELD_1);
+    HAND_OF_SACRIFICE             = ai->initSpell(HAND_OF_SACRIFICE_1);
+    SHIELD_OF_RIGHTEOUSNESS       = ai->initSpell(SHIELD_OF_RIGHTEOUSNESS_1);
+    REDEMPTION                    = ai->initSpell(REDEMPTION_1);
+    PURIFY                        = ai->initSpell(PURIFY_1);
+    CLEANSE                       = ai->initSpell(CLEANSE_1);
+
+    // Warrior auras
+    DEFENSIVE_STANCE              = 71;   //Def Stance
+    BERSERKER_STANCE              = 2458; //Ber Stance
+    BATTLE_STANCE                 = 2457; //Bat Stance
+
+    FORBEARANCE                   = 25771; // cannot be protected
+
+    RECENTLY_BANDAGED             = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_PALADIN); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    EVERY_MAN_FOR_HIMSELF         = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+}
+
+PlayerbotPaladinAI::~PlayerbotPaladinAI() {}
+
+bool PlayerbotPaladinAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotPaladinAI::HealTarget(Unit *target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+
+    if (hp < 25 && ai->CastSpell(LAY_ON_HANDS, *target))
+        return true;
+
+    if (hp < 30 && ai->CastSpell(FLASH_OF_LIGHT, *target))
+        return true;
+
+    if (hp < 35 && ai->CastSpell(HOLY_SHOCK, *target))
+        return true;
+
+    if (hp < 40 && ai->CastSpell(HOLY_LIGHT, *target))
+        return true;
+
+    if (PURIFY > 0 && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        uint32 DISPEL = CLEANSE > 0 ? CLEANSE : PURIFY;
+        Unit::AuraMap const& auras = target->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            const SpellInfo* spellInfo = aura->GetSpellInfo();
+            if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(spellInfo->Dispel);
+            if (dispel == DISPEL_POISON || 
+                dispel == DISPEL_DISEASE || 
+                (DISPEL == CLEANSE && dispel == DISPEL_MAGIC))
+            {
+                AuraApplication *aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+                if (!aurApp)
+                    continue;
+                if (!aurApp->IsPositive())
+                    if (ai->CastSpell(DISPEL, *target))//additional check for cd
+                        return true;
+            }
+        }
+    }
+
+    return false;
+} // end HealTarget
+
+void PlayerbotPaladinAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->getVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HAMMER_OF_JUSTICE > 0)
+                ai->CastSpell(HAMMER_OF_JUSTICE);
+            return;
+    }
+
+    // damage spells
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+    float dist = GetCombatDistance(pTarget);
+    std::ostringstream out;
+
+    //Shield master if low hp.
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+
+    if (GetMaster()->isAlive())
+        if (masterHP < 25 && HAND_OF_PROTECTION > 0 && !GetMaster()->HasAura(FORBEARANCE, 0) && !GetMaster()->HasAura(HAND_OF_PROTECTION, 0) && !GetMaster()->HasAura(DIVINE_PROTECTION, 0) && !GetMaster()->HasAura(DIVINE_SHIELD, 0))
+            ai->CastSpell(HAND_OF_PROTECTION, *GetMaster());
+
+    // heal group inside combat, but do not heal if tank
+    if (m_group && pVictim != m_bot)  // possible tank
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = sObjectAccessor->FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->isAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 40 && ai->GetManaPercent() >= 40)  // do not heal bots without plenty of mana for master & self
+                if (HealTarget(m_groupMember))
+                    return;
+        }
+    }
+
+    if (RIGHTEOUS_FURY > 0 && !m_bot->HasAura(RIGHTEOUS_FURY, 0) && ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK)
+        ai->CastSpell (RIGHTEOUS_FURY, *m_bot);
+
+    if (SHADOW_RESISTANCE_AURA > 0 && !m_bot->HasAura(SHADOW_RESISTANCE_AURA, 0) && pTarget->getClass() == CLASS_WARLOCK)
+        ai->CastSpell (SHADOW_RESISTANCE_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, 0) && pTarget->getClass() == CLASS_WARRIOR)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (FIRE_RESISTANCE_AURA > 0 && !m_bot->HasAura(FIRE_RESISTANCE_AURA, 0) && pTarget->getClass() == CLASS_MAGE)
+        ai->CastSpell (FIRE_RESISTANCE_AURA, *m_bot);
+
+    if (RETRIBUTION_AURA > 0 && !m_bot->HasAura(RETRIBUTION_AURA, 0) && pTarget->getClass() == CLASS_PRIEST)
+        ai->CastSpell (RETRIBUTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, 0) && pTarget->getClass() == CLASS_SHAMAN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, 0) && pTarget->getClass() == CLASS_ROGUE)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (DEVOTION_AURA > 0 && !m_bot->HasAura(DEVOTION_AURA, 0) && pTarget->getClass() == CLASS_PALADIN)
+        ai->CastSpell (DEVOTION_AURA, *m_bot);
+
+    if (ai->GetHealthPercent() <= 40 || GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth() * 0.4)
+        SpellSequence = Healing;
+    else
+        SpellSequence = Combat;
+
+    switch (SpellSequence)
+    {
+        case Combat:
+            if (JUDGEMENT_OF_LIGHT > 0 && !pTarget->HasAura(JUDGEMENT_OF_LIGHT, 0) && CombatCounter < 1 && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell (JUDGEMENT_OF_LIGHT, *pTarget);
+                out << " Judgement of Light";
+                CombatCounter++;
+                break;
+            }
+            else if (SEAL_OF_COMMAND > 0 && !m_bot->HasAura(SEAL_OF_COMMAND, 0) && CombatCounter < 2 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (SEAL_OF_COMMAND, *m_bot);
+                out << " Seal of Command";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_JUSTICE > 0 && !pTarget->HasAura(HAMMER_OF_JUSTICE, 0) && CombatCounter < 3 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell (HAMMER_OF_JUSTICE, *pTarget);
+                out << " Hammer of Justice";
+                CombatCounter++;
+                break;
+            }
+            else if (CRUSADER_STRIKE > 0 && CombatCounter < 4 && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell (CRUSADER_STRIKE, *pTarget);
+                out << " Crusader Strike";
+                CombatCounter++;
+                break;
+            }
+            else if (AVENGING_WRATH > 0 && CombatCounter < 5 && !m_bot->HasAura(AVENGING_WRATH, 0) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell (AVENGING_WRATH, *m_bot);
+                out << " Avenging Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (SACRED_SHIELD > 0 && CombatCounter < 6 && pVictim == m_bot && ai->GetHealthPercent() < 70 && !m_bot->HasAura(SACRED_SHIELD, 0) && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell (SACRED_SHIELD, *m_bot);
+                out << " Sacred Shield";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_STORM > 0 && CombatCounter < 7 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell (DIVINE_STORM, *pTarget);
+                out << " Divine Storm";
+                CombatCounter++;
+                break;
+            }
+            else if (HAMMER_OF_WRATH > 0 && CombatCounter < 8 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell (HAMMER_OF_WRATH, *pTarget);
+                out << " Hammer of Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HOLY_WRATH > 0 && CombatCounter < 9 && ai->GetAttackerCount() >= 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell (HOLY_WRATH, *pTarget);
+                out << " Holy Wrath";
+                CombatCounter++;
+                break;
+            }
+            else if (HAND_OF_SACRIFICE > 0 && pVictim == GetMaster() && !GetMaster()->HasAura(HAND_OF_SACRIFICE, 0) && CombatCounter < 10 && ai->GetManaPercent() >= 6)
+            {
+                ai->CastSpell (HAND_OF_SACRIFICE, *GetMaster());
+                out << " Hand of Sacrifice";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PROTECTION > 0 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE, 0) && ai->GetHealthPercent() < 30 && CombatCounter < 11 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell (DIVINE_PROTECTION, *m_bot);
+                out << " Divine Protection";
+                CombatCounter++;
+                break;
+            }
+            else if (RIGHTEOUS_DEFENSE > 0 && pVictim != m_bot && ai->GetHealthPercent() > 70 && CombatCounter < 12)
+            {
+                ai->CastSpell (RIGHTEOUS_DEFENSE, *pTarget);
+                out << " Righteous Defense";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_PLEA > 0 && !m_bot->HasAura(DIVINE_PLEA, 0) && ai->GetManaPercent() < 50 && CombatCounter < 13)
+            {
+                ai->CastSpell (DIVINE_PLEA, *m_bot);
+                out << " Divine Plea";
+                CombatCounter++;
+                break;
+            }
+            else if (DIVINE_FAVOR > 0 && !m_bot->HasAura(DIVINE_FAVOR, 0) && CombatCounter < 14)
+            {
+                ai->CastSpell (DIVINE_FAVOR, *m_bot);
+                out << " Divine Favor";
+                CombatCounter++;
+                break;
+            }
+            else if (CombatCounter > 15)
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("CombatCounter Reset");
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+
+        case Healing:
+            if (ai->GetHealthPercent() <= 40)
+            {
+                HealTarget (m_bot);
+                out << " ...healing bot";
+                break;
+            }
+            if (masterHP <= 40)
+            {
+                HealTarget (GetMaster());
+                out << " ...healing master";
+                break;
+            }
+            else
+            {
+                CombatCounter = 0;
+                //ai->TellMaster("Counter = 0");
+                break;
+            }
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+
+    if (AVENGING_WRATH > 0 && !m_bot->HasAura(AVENGING_WRATH, 0) && ai->GetManaPercent() >= 8)
+        ai->CastSpell(AVENGING_WRATH, *m_bot);
+
+    if (DIVINE_SHIELD > 0 && ai->GetHealthPercent() < 30 && pVictim == m_bot && !m_bot->HasAura(FORBEARANCE, 0) && !m_bot->HasAura(DIVINE_SHIELD, 0) && ai->GetManaPercent() >= 3)
+        ai->CastSpell(DIVINE_SHIELD, *m_bot);
+
+    if (DIVINE_SACRIFICE > 0 && ai->GetHealthPercent() > 50 && pVictim != m_bot && !m_bot->HasAura(DIVINE_SACRIFICE, 0))
+        ai->CastSpell(DIVINE_SACRIFICE, *m_bot);
+}
+
+void PlayerbotPaladinAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // Buff myself
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_TANK) ai->SelfBuff(RIGHTEOUS_FURY);
+    if (SEAL_OF_WISDOM > 0 && !m_bot->HasAura(SEAL_OF_WISDOM, 0) && ai->GetManaPercent() <= 30)
+        ai->CastSpell(SEAL_OF_WISDOM, *m_bot);
+    else if (m_bot->HasAura(SEAL_OF_WISDOM, 0) && ai->GetManaPercent() < 85)
+    { }
+    else if (SEAL_OF_LIGHT > 0 && !m_bot->HasAura(SEAL_OF_LIGHT, 0) && ai->GetHealthPercent() < 40)
+        ai->CastSpell(SEAL_OF_LIGHT, *m_bot);
+    else if (SEAL_OF_RIGHTEOUSNESS > 0 && !m_bot->HasAura(SEAL_OF_RIGHTEOUSNESS, 0))
+        ai->CastSpell(SEAL_OF_RIGHTEOUSNESS, *m_bot);
+    BuffPlayer(m_bot);
+
+    // Buff master
+    if (!GetMaster()->duel || !GetMaster()->duel->opponent)
+        BuffPlayer(GetMaster());
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 40)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check original
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 40)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // heal and buff group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectAccessor->FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            if (!tPlayer->isAlive())
+            {
+                if (ai->CastSpell(REDEMPTION, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+
+            if (HealTarget(tPlayer))
+                return;
+
+            if (tPlayer != m_bot && tPlayer != GetMaster())
+                if (BuffPlayer(tPlayer))
+                    return;
+        }
+    }
+}
+
+bool PlayerbotPaladinAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    //uint8 SPELL_BLESSING = 2; // See SpellSpecific enum in SpellMgr.h
+
+    Pet * pet = target->GetPet();
+    bool targetCanBeBlessed = ai->CanReceiveSpecificSpell(SPELL_BLESSING, target);
+    bool petCanBeBlessed = false;
+    if (pet)
+        petCanBeBlessed = ai->CanReceiveSpecificSpell(SPELL_BLESSING, pet);
+
+    if (!ai->CanReceiveSpecificSpell(SPELL_BLESSING, target) && !petCanBeBlessed)
+        return false;
+
+    if (HasAuraName(target, BLESSING_OF_WISDOM,             GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, BLESSING_OF_KINGS,              GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, BLESSING_OF_MIGHT,              GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, BLESSING_OF_SANCTUARY,          GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_WISDOM,     GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_KINGS,      GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_MIGHT,      GetPlayerBot()->GetGUID()) ||
+        HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY,  GetPlayerBot()->GetGUID())
+    ) return false;
+
+    switch (target->getClass())
+    {
+        case CLASS_DRUID:
+        case CLASS_SHAMAN:
+        case CLASS_PALADIN:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_WISDOM, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            break;
+        case CLASS_DEATH_KNIGHT:
+        case CLASS_HUNTER:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            if (petCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, pet))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, pet))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, pet))
+                    return true;
+            }
+            break;
+        case CLASS_ROGUE:
+        case CLASS_WARRIOR:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_MIGHT, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            break;
+        case CLASS_WARLOCK:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_WISDOM, target))
+                    return true;
+                else
+                    return false;
+            }
+            if (petCanBeBlessed && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE))
+            {
+                if (pet->getPowerType() == POWER_MANA)
+                {
+                    if (Bless(BLESSING_OF_WISDOM, pet))
+                        return true;
+                }
+                else if (Bless(BLESSING_OF_MIGHT, pet))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, pet))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, pet))
+                    return true;
+            }
+            break;
+        case CLASS_PRIEST:
+        case CLASS_MAGE:
+            if (targetCanBeBlessed)
+            {
+                if (Bless(BLESSING_OF_WISDOM, target))
+                    return true;
+                if (Bless(BLESSING_OF_KINGS, target))
+                    return true;
+                if (Bless(BLESSING_OF_SANCTUARY, target))
+                    return true;
+                else
+                    return false;
+            }
+            break;
+        default:
+            break;
+    }
+    return false;
+}
+
+bool PlayerbotPaladinAI::Bless(uint32 spellId, Unit *target)
+{
+    if (spellId == 0)
+        return false;
+
+    PlayerbotAI * ai = GetAI();
+
+    if (spellId == BLESSING_OF_MIGHT)
+    {
+        if (GREATER_BLESSING_OF_MIGHT && ai->HasSpellReagents(GREATER_BLESSING_OF_MIGHT) && ai->Buff(GREATER_BLESSING_OF_MIGHT, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_WISDOM)
+    {
+        if (GREATER_BLESSING_OF_WISDOM && ai->HasSpellReagents(GREATER_BLESSING_OF_WISDOM) && ai->Buff(GREATER_BLESSING_OF_WISDOM, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_KINGS)
+    {
+        if (GREATER_BLESSING_OF_KINGS && ai->HasSpellReagents(GREATER_BLESSING_OF_KINGS) && ai->Buff(GREATER_BLESSING_OF_KINGS, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+    else if (spellId == BLESSING_OF_SANCTUARY)
+    {
+        if (GREATER_BLESSING_OF_SANCTUARY && ai->HasSpellReagents(GREATER_BLESSING_OF_SANCTUARY) && ai->Buff(GREATER_BLESSING_OF_SANCTUARY, target))
+            return true;
+        else
+            return ai->Buff(spellId, target);
+    }
+
+    // Should not happen, but let it be here
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
new file mode 100644
index 0000000..c6fa9f9
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPaladinAI.h
@@ -0,0 +1,187 @@
+#ifndef _PlayerbotPaladinAI_H
+#define _PlayerbotPaladinAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    Combat,
+    Healing
+};
+
+enum PaladinSpells
+{
+    AURA_MASTERY_1                  = 31821,
+    AVENGERS_SHIELD_1               = 31935,
+    AVENGING_WRATH_1                = 31884,
+    BEACON_OF_LIGHT_1               = 53563,
+    BLESSING_OF_KINGS_1             = 20217,
+    BLESSING_OF_MIGHT_1             = 19740,
+    BLESSING_OF_SANCTUARY_1         = 20911,
+    BLESSING_OF_WISDOM_1            = 19742,
+    CLEANSE_1                       = 4987,
+    CONCENTRATION_AURA_1            = 19746,
+    CONSECRATION_1                  = 26573,
+    CRUSADER_AURA_1                 = 32223,
+    CRUSADER_STRIKE_1               = 35395,
+    DEVOTION_AURA_1                 = 465,
+    DIVINE_FAVOR_1                  = 20216,
+    DIVINE_ILLUMINATION_1           = 31842,
+    DIVINE_INTERVENTION_1           = 19752,
+    DIVINE_PLEA_1                   = 54428,
+    DIVINE_PROTECTION_1             = 498,
+    DIVINE_SACRIFICE_1              = 64205,
+    DIVINE_SHIELD_1                 = 642,
+    DIVINE_STORM_1                  = 53385,
+    EXORCISM_1                      = 879,
+    FIRE_RESISTANCE_AURA_1          = 19891,
+    FLASH_OF_LIGHT_1                = 19750,
+    FROST_RESISTANCE_AURA_1         = 19888,
+    GREATER_BLESSING_OF_KINGS_1     = 25898,
+    GREATER_BLESSING_OF_MIGHT_1     = 25782,
+    GREATER_BLESSING_OF_SANCTUARY_1 = 25899,
+    GREATER_BLESSING_OF_WISDOM_1    = 25894,
+    HAMMER_OF_JUSTICE_1             = 853,
+    HAMMER_OF_THE_RIGHTEOUS_1       = 53595,
+    HAMMER_OF_WRATH_1               = 24275,
+    HAND_OF_FREEDOM_1               = 1044,
+    HAND_OF_PROTECTION_1            = 1022,
+    HAND_OF_RECKONING_1             = 62124,
+    HAND_OF_SACRIFICE_1             = 6940,
+    HAND_OF_SALVATION_1             = 1038,
+    HOLY_LIGHT_1                    = 635,
+    HOLY_SHIELD_1                   = 20925,
+    HOLY_SHOCK_1                    = 20473,
+    HOLY_WRATH_1                    = 2812,
+    JUDGEMENT_OF_JUSTICE_1          = 53407,
+    JUDGEMENT_OF_LIGHT_1            = 20271,
+    JUDGEMENT_OF_WISDOM_1           = 53408,
+    LAY_ON_HANDS_1                  = 633,
+    PURIFY_1                        = 1152,
+    REDEMPTION_1                    = 7328,
+    REPENTANCE_1                    = 20066,
+    RETRIBUTION_AURA_1              = 7294,
+    RIGHTEOUS_DEFENSE_1             = 31789,
+    RIGHTEOUS_FURY_1                = 25780,
+    SACRED_SHIELD_1                 = 53601,
+    SEAL_OF_COMMAND_1               = 20375,
+    SEAL_OF_CORRUPTION_1            = 53736,
+    SEAL_OF_JUSTICE_1               = 20164,
+    SEAL_OF_LIGHT_1                 = 20165,
+    SEAL_OF_RIGHTEOUSNESS_1         = 21084,
+    SEAL_OF_VENGEANCE_1             = 31801,
+    SEAL_OF_WISDOM_1                = 20166,
+    SENSE_UNDEAD_1                  = 5502,
+    SHADOW_RESISTANCE_AURA_1        = 19876,
+    SHIELD_OF_RIGHTEOUSNESS_1       = 53600,
+    TURN_EVIL_1                     = 10326
+};
+//class Player;
+
+class PlayerbotPaladinAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPaladinAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPaladinAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit *target);
+    // Bless target using greater blessing if possible
+    bool Bless(uint32 spellId, Unit *target);
+
+    // Retribution
+    uint32 RETRIBUTION_AURA,
+           SEAL_OF_COMMAND,
+           JUDGEMENT_OF_LIGHT,
+           JUDGEMENT_OF_WISDOM,
+           GREATER_BLESSING_OF_WISDOM,
+           GREATER_BLESSING_OF_MIGHT,
+           BLESSING_OF_WISDOM,
+           BLESSING_OF_MIGHT,
+           HAMMER_OF_JUSTICE,
+           RIGHTEOUS_FURY,
+           CRUSADER_AURA,
+           CRUSADER_STRIKE,
+           AVENGING_WRATH,
+           DIVINE_STORM,
+           JUDGEMENT_OF_JUSTICE;
+
+    // Holy
+    uint32 FLASH_OF_LIGHT,
+           HOLY_LIGHT,
+           DIVINE_SHIELD,
+           HAMMER_OF_WRATH,
+           CONSECRATION,
+           CONCENTRATION_AURA,
+           DIVINE_FAVOR,
+           SACRED_SHIELD,
+           HOLY_SHOCK,
+           HOLY_WRATH,
+           LAY_ON_HANDS,
+           EXORCISM,
+           REDEMPTION,
+           DIVINE_PLEA,
+           SEAL_OF_CORRUPTION,
+           SEAL_OF_JUSTICE,
+           SEAL_OF_LIGHT,
+           SEAL_OF_RIGHTEOUSNESS,
+           SEAL_OF_VENGEANCE,
+           SEAL_OF_WISDOM,
+           PURIFY,
+           CLEANSE;
+
+    // Protection
+    uint32 GREATER_BLESSING_OF_KINGS,
+           BLESSING_OF_KINGS,
+           HAND_OF_PROTECTION,
+           SHADOW_RESISTANCE_AURA,
+           DEVOTION_AURA,
+           FIRE_RESISTANCE_AURA,
+           FROST_RESISTANCE_AURA,
+           DEFENSIVE_STANCE,
+           BERSERKER_STANCE,
+           BATTLE_STANCE,
+           DIVINE_SACRIFICE,
+           DIVINE_PROTECTION,
+           DIVINE_INTERVENTION,
+           HOLY_SHIELD,
+           AVENGERS_SHIELD,
+           RIGHTEOUS_DEFENSE,
+           BLESSING_OF_SANCTUARY,
+           GREATER_BLESSING_OF_SANCTUARY,
+           HAND_OF_SACRIFICE,
+           SHIELD_OF_RIGHTEOUSNESS;
+
+    // cannot be protected
+    uint32 FORBEARANCE;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, CombatCounter, HealCounter;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
new file mode 100644
index 0000000..49b582d
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.cpp
@@ -0,0 +1,480 @@
+#include "PlayerbotPriestAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+
+PlayerbotPriestAI::PlayerbotPriestAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    RENEW                         = ai->initSpell(RENEW_1);
+    LESSER_HEAL                   = ai->initSpell(LESSER_HEAL_1);
+    FLASH_HEAL                    = ai->initSpell(FLASH_HEAL_1);
+    (FLASH_HEAL > 0) ? FLASH_HEAL : FLASH_HEAL = LESSER_HEAL;
+    HEAL                          = ai->initSpell(HEAL_1);
+    (HEAL > 0) ? HEAL : HEAL = FLASH_HEAL;
+    GREATER_HEAL                  = ai->initSpell(GREATER_HEAL_1);
+    (GREATER_HEAL > 0) ? GREATER_HEAL : GREATER_HEAL = HEAL;
+    RESURRECTION                  = ai->initSpell(RESURRECTION_1);
+    SMITE                         = ai->initSpell(SMITE_1);
+    MANA_BURN                     = ai->initSpell(MANA_BURN_1);
+    HOLY_NOVA                     = ai->initSpell(HOLY_NOVA_1);
+    HOLY_FIRE                     = ai->initSpell(HOLY_FIRE_1);
+    DESPERATE_PRAYER              = ai->initSpell(DESPERATE_PRAYER_1);
+    PRAYER_OF_HEALING             = ai->initSpell(PRAYER_OF_HEALING_1);
+    CIRCLE_OF_HEALING             = ai->initSpell(CIRCLE_OF_HEALING_1);
+    BINDING_HEAL                  = ai->initSpell(BINDING_HEAL_1);
+    PRAYER_OF_MENDING             = ai->initSpell(PRAYER_OF_MENDING_1);
+    CURE_DISEASE                  = ai->initSpell(CURE_DISEASE_1);
+
+    // SHADOW
+    FADE                          = ai->initSpell(FADE_1);
+    SHADOW_WORD_PAIN              = ai->initSpell(SHADOW_WORD_PAIN_1);
+    MIND_BLAST                    = ai->initSpell(MIND_BLAST_1);
+    SCREAM                        = ai->initSpell(PSYCHIC_SCREAM_1);
+    MIND_FLAY                     = ai->initSpell(MIND_FLAY_1);
+    DEVOURING_PLAGUE              = ai->initSpell(DEVOURING_PLAGUE_1);
+    SHADOW_PROTECTION             = ai->initSpell(SHADOW_PROTECTION_1);
+    VAMPIRIC_TOUCH                = ai->initSpell(VAMPIRIC_TOUCH_1);
+    PRAYER_OF_SHADOW_PROTECTION   = ai->initSpell(PRAYER_OF_SHADOW_PROTECTION_1);
+    SHADOWFIEND                   = ai->initSpell(SHADOWFIEND_1);
+    MIND_SEAR                     = ai->initSpell(MIND_SEAR_1);
+
+    // DISCIPLINE
+    PENANCE                       = ai->initSpell(PENANCE_1);
+    INNER_FIRE                    = ai->initSpell(INNER_FIRE_1);
+    POWER_WORD_SHIELD             = ai->initSpell(POWER_WORD_SHIELD_1);
+    POWER_WORD_FORTITUDE          = ai->initSpell(POWER_WORD_FORTITUDE_1);
+    PRAYER_OF_FORTITUDE           = ai->initSpell(PRAYER_OF_FORTITUDE_1);
+    FEAR_WARD                     = ai->initSpell(FEAR_WARD_1);
+    DIVINE_SPIRIT                 = ai->initSpell(DIVINE_SPIRIT_1);
+    PRAYER_OF_SPIRIT              = ai->initSpell(PRAYER_OF_SPIRIT_1);
+    MASS_DISPEL                   = ai->initSpell(MASS_DISPEL_1);
+    POWER_INFUSION                = ai->initSpell(POWER_INFUSION_1);
+    INNER_FOCUS                   = ai->initSpell(INNER_FOCUS_1);
+
+    RECENTLY_BANDAGED  = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT                = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES);
+    GIFT_OF_THE_NAARU             = ai->initSpell(GIFT_OF_THE_NAARU_PRIEST); // draenei
+    STONEFORM                     = ai->initSpell(STONEFORM_ALL); // dwarf
+    EVERY_MAN_FOR_HIMSELF         = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD                    = ai->initSpell(SHADOWMELD_ALL);
+    BERSERKING                    = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN          = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotPriestAI::~PlayerbotPriestAI() {}
+
+bool PlayerbotPriestAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+bool PlayerbotPriestAI::HealTarget(Unit* target)
+{
+    PlayerbotAI* ai = GetAI();
+    uint8 hp = target->GetHealth() * 100 / target->GetMaxHealth();
+    uint8 hpSelf = GetAI()->GetHealthPercent();
+
+    if (CURE_DISEASE > 0 && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        Unit::AuraMap const& auras = target->GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+            if (dispel != DISPEL_DISEASE)
+                continue;
+            AuraApplication *aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+            if (!aurApp)
+                continue;
+            if (!aurApp->IsPositive() && ai->CastSpell(CURE_DISEASE, *target))
+                return true;
+        }
+    }
+
+    if (hp >= 80)
+        return false;
+
+    if (hp < 30 && FLASH_HEAL > 0 && ai->CastSpell(FLASH_HEAL, *target))
+        return true;
+    else if (hp < 40 && GREATER_HEAL > 0 && ai->CastSpell(GREATER_HEAL, *target))
+        return true;
+    // Heals target AND self for equal amount
+    else if (hp < 60 && hpSelf < 80 && BINDING_HEAL > 0 && ai->CastSpell(BINDING_HEAL, *target))
+        return true;
+    else if (hp < 60 && HEAL > 0 && ai->CastSpell(HEAL, *target))
+        return true;
+    else if (hp < 80 && RENEW > 0 && !target->HasAura(RENEW) && ai->CastSpell(RENEW, *target))
+        return true;
+    else
+        return false;
+} // end HealTarget
+
+void PlayerbotPriestAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    Unit* pVictim = pTarget->getVictim();
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            (ai->HasAura(SCREAM, *pTarget) && ai->GetHealthPercent() < 60 && ai->CastSpell(HEAL)) ||
+            ai->CastSpell(SHADOW_WORD_PAIN) ||
+            (ai->GetHealthPercent() < 80 && ai->CastSpell(RENEW)) ||
+            (GetCombatDistance(pTarget) <= 5 && ai->CastSpell(SCREAM)) ||
+            ai->CastSpell(MIND_BLAST) ||
+            (ai->GetHealthPercent() < 20 && ai->CastSpell(GREATER_HEAL)) ||
+            ai->CastSpell(SMITE);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Fade has nothing to do with health and everything to do with having aggro/threat
+    Unit *newTarget = ai->FindAttacker((PlayerbotAI::ATTACKERINFOTYPE) (PlayerbotAI::AIT_VICTIMSELF | PlayerbotAI::AIT_HIGHESTTHREAT), m_bot);
+    if (newTarget && FADE > 0 && !m_bot->HasAura(FADE, 0))
+    {
+        ai->TellMaster("I'm casting fade.");
+        ai->CastSpell(FADE, *m_bot);
+    }
+    // Heal myself
+    else if (ai->GetHealthPercent() < 25 && POWER_WORD_SHIELD > 0 && !m_bot->HasAura(POWER_WORD_SHIELD, 0))
+    {
+        ai->TellMaster("I'm casting PW:S on myself.");
+        ai->CastSpell(POWER_WORD_SHIELD);
+    }
+    else if (ai->GetHealthPercent() < 35 && DESPERATE_PRAYER > 0)
+    {
+        ai->TellMaster("I'm casting desperate prayer.");
+        ai->CastSpell(DESPERATE_PRAYER, *m_bot);
+    }
+    else if (ai->GetHealthPercent() < 60 || (BINDING_HEAL == 0 && ai->GetHealthPercent() < 80))
+        HealTarget(m_bot);
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->isAlive())
+    {
+        if (masterHP < 25 && POWER_WORD_SHIELD > 0 && !GetMaster()->HasAura(POWER_WORD_SHIELD, 0))
+            ai->CastSpell(POWER_WORD_SHIELD, *(GetMaster()));
+        else if (masterHP < 25 || ((GetAI()->GetCombatOrder() & PlayerbotAI::ORDERS_HEAL) && masterHP < 80))
+            HealTarget(GetMaster());
+    }
+
+    // TODO: Prioritize group healing in some way. If 3 members (including master/self) should be healed, pick one of these:
+    // Group heal. Not really useful until a group check is available?
+    //else if (hp < 40 && PRAYER_OF_HEALING > 0 && ai->CastSpell(PRAYER_OF_HEALING, *target))
+    //    return true;
+    // Group heal. Not really useful until a group check is available?
+    //else if (hp < 50 && CIRCLE_OF_HEALING > 0 && ai->CastSpell(CIRCLE_OF_HEALING, *target))
+    //    return true;
+
+    // Heal group
+    if (m_group)
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = sObjectAccessor->FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->isAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 25 && POWER_WORD_SHIELD > 0 && !m_groupMember->HasAura(POWER_WORD_SHIELD, 0))
+                ai->CastSpell(POWER_WORD_SHIELD, *(GetMaster()));
+            else if (memberHP < 25 || ((GetAI()->GetCombatOrder() & PlayerbotAI::ORDERS_HEAL) && memberHP < 80))
+                HealTarget(m_groupMember);
+        }
+    }
+
+    if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_HEAL)
+        SpellSequence = SPELL_HOLY;
+    else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+        SpellSequence = SPELL_SHADOWMAGIC;
+    else
+        SpellSequence = SPELL_HOLY;
+
+    // Damage Spells
+    float dist = GetCombatDistance(pTarget);
+
+    switch (SpellSequence)
+    {
+        case SPELL_HOLY:
+            if (SMITE > 0 && LastSpellHoly < 1 && !pTarget->HasAura(SMITE, 0) && ai->GetManaPercent() >= 17)
+            {
+                ai->CastSpell(SMITE, *pTarget);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (MANA_BURN > 0 && LastSpellHoly < 2 && pTarget->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() < 70 && ai->GetManaPercent() >= 14)
+            {
+                //ai->TellMaster("I'm casting mana burn.");
+                ai->CastSpell(MANA_BURN, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (HOLY_NOVA > 0 && LastSpellHoly < 3 && dist <= ATTACK_DISTANCE && ai->GetManaPercent() >= 22)
+            {
+                //ai->TellMaster("I'm casting holy nova.");
+                ai->CastSpell(HOLY_NOVA);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (HOLY_FIRE > 0 && LastSpellHoly < 4 && !pTarget->HasAura(HOLY_FIRE, 0) && ai->GetManaPercent() >= 13)
+            {
+                //ai->TellMaster("I'm casting holy fire.");
+                ai->CastSpell(HOLY_FIRE, *pTarget);
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else if (PRAYER_OF_MENDING > 0 && LastSpellHoly < 5 && pVictim == GetMaster() && GetMaster()->GetHealth() <= GetMaster()->GetMaxHealth() * 0.7 && !GetMaster()->HasAura(PRAYER_OF_MENDING, 0) && ai->GetManaPercent() >= 15)
+            {
+                //ai->TellMaster("I'm casting prayer of mending on master.");
+                ai->CastSpell(PRAYER_OF_MENDING, *GetMaster());
+                LastSpellHoly = LastSpellHoly + 1;
+            }
+            else
+                LastSpellHoly = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE)
+                SpellSequence = SPELL_SHADOWMAGIC;
+            break;
+
+        case SPELL_SHADOWMAGIC:
+            if (SHADOW_WORD_PAIN > 0 && LastSpellShadowMagic < 1 && !pTarget->HasAura(SHADOW_WORD_PAIN, 0) && ai->GetManaPercent() >= 25)
+            {
+                //ai->TellMaster("I'm casting pain.");
+                ai->CastSpell(SHADOW_WORD_PAIN, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_BLAST > 0 && LastSpellShadowMagic < 2 && ai->GetManaPercent() >= 19)
+            {
+                //ai->TellMaster("I'm casting mind blast.");
+                ai->CastSpell(MIND_BLAST, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SCREAM > 0 && LastSpellShadowMagic < 3 && ai->GetAttackerCount() >= 3 && ai->GetManaPercent() >= 15)
+            {
+                ai->TellMaster("I'm casting scream.");
+                ai->CastSpell(SCREAM);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_FLAY > 0 && LastSpellShadowMagic < 4 && !pTarget->HasAura(MIND_FLAY, 0) && ai->GetManaPercent() >= 10)
+            {
+                //ai->TellMaster("I'm casting mind flay.");
+                ai->CastSpell(MIND_FLAY, *pTarget);
+                ai->SetIgnoreUpdateTime(3);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (DEVOURING_PLAGUE > 0 && LastSpellShadowMagic < 5 && !pTarget->HasAura(DEVOURING_PLAGUE, 0) && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(DEVOURING_PLAGUE, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SHADOW_PROTECTION > 0 && LastSpellShadowMagic < 6 && ai->GetManaPercent() >= 60)
+            {
+                ai->CastSpell(SHADOW_PROTECTION, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (VAMPIRIC_TOUCH > 0 && LastSpellShadowMagic < 7 && !pTarget->HasAura(VAMPIRIC_TOUCH, 0) && ai->GetManaPercent() >= 18)
+            {
+                ai->CastSpell(VAMPIRIC_TOUCH, *pTarget);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (SHADOWFIEND > 0 && LastSpellShadowMagic < 8)
+            {
+                ai->CastSpell(SHADOWFIEND);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else if (MIND_SEAR > 0 && LastSpellShadowMagic < 9 && ai->GetAttackerCount() >= 3 && ai->GetManaPercent() >= 28)
+            {
+                ai->CastSpell(MIND_SEAR, *pTarget);
+                ai->SetIgnoreUpdateTime(5);
+                LastSpellShadowMagic = LastSpellShadowMagic + 1;
+            }
+            else
+                LastSpellShadowMagic = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE || ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+                SpellSequence = SPELL_DISCIPLINE;
+            break;
+
+        case SPELL_DISCIPLINE:
+            if (FEAR_WARD > 0 && LastSpellDiscipline < 1 && ai->GetManaPercent() >= 3)
+            {
+                //ai->TellMaster("I'm casting fear ward");
+                ai->CastSpell(FEAR_WARD, *(GetMaster()));
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (POWER_INFUSION > 0 && LastSpellDiscipline < 2 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting power infusion");
+                ai->CastSpell(POWER_INFUSION, *(GetMaster()));
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (MASS_DISPEL > 0 && LastSpellDiscipline < 3 && ai->GetManaPercent() >= 33)
+            {
+                //ai->TellMaster("I'm casting mass dispel");
+                ai->CastSpell(MASS_DISPEL);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (INNER_FOCUS > 0 && !m_bot->HasAura(INNER_FOCUS, 0) && LastSpellDiscipline < 4)
+            {
+                //ai->TellMaster("I'm casting inner focus");
+                ai->CastSpell(INNER_FOCUS, *m_bot);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else if (PENANCE > 0 && LastSpellDiscipline < 5 && ai->GetManaPercent() >= 16)
+            {
+                //ai->TellMaster("I'm casting PENANCE");
+                ai->CastSpell(PENANCE);
+                LastSpellDiscipline = LastSpellDiscipline + 1;
+            }
+            else
+                LastSpellDiscipline = 0;
+
+            if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_NONE)
+                SpellSequence = SPELL_HOLY;
+            else if (ai->GetCombatOrder() == PlayerbotAI::ORDERS_ASSIST)
+                SpellSequence = SPELL_SHADOWMAGIC;
+            break;
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotPriestAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    Player * master = GetMaster();
+    if (!m_bot || !master)
+        return;
+
+    SpellSequence = SPELL_HOLY;
+
+    // selfbuff goes first
+    if (ai->SelfBuff(INNER_FIRE))
+        return;
+
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // buff and heal master's group
+    if (master->GetGroup())
+    {
+        // Buff master with group buffs
+        if (!master->duel && master->isAlive())
+        {
+            if (PRAYER_OF_FORTITUDE && ai->HasSpellReagents(PRAYER_OF_FORTITUDE) && ai->Buff(PRAYER_OF_FORTITUDE, master))
+                return;
+
+            if (PRAYER_OF_SPIRIT && ai->HasSpellReagents(PRAYER_OF_SPIRIT) && ai->Buff(PRAYER_OF_SPIRIT, master))
+                return;
+
+            if (PRAYER_OF_SHADOW_PROTECTION && ai->HasSpellReagents(PRAYER_OF_SHADOW_PROTECTION) && ai->Buff(PRAYER_OF_SHADOW_PROTECTION, master))
+                return;
+        }
+
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectAccessor->FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            // first rezz em
+            if (!tPlayer->isAlive())
+            {
+                if (ai->CastSpell(RESURRECTION, *tPlayer))
+                {
+                    std::string msg = "Resurrecting ";
+                    msg += tPlayer->GetName();
+                    m_bot->Say(msg, LANG_UNIVERSAL);
+                    return;
+                }
+                else
+                    continue;
+            }
+            else
+            {
+                // buff and heal
+                if (BuffPlayer(tPlayer))
+                    return;
+
+                if (HealTarget(tPlayer))
+                    return;
+            }
+        }
+    }
+    else
+    {
+        if (master->isAlive() && !master->duel)
+        {
+            if (BuffPlayer(master))
+                return;
+            if (HealTarget(master))
+                return;
+        }
+        else if (ai->CastSpell(RESURRECTION, *master))
+            ai->TellMaster("Resurrecting you, Master.");
+    }
+
+    BuffPlayer(m_bot);
+} // end DoNonCombatActions
+
+bool PlayerbotPriestAI::BuffPlayer(Player* target)
+{
+    PlayerbotAI * ai = GetAI();
+    Pet * pet = target->GetPet();
+
+    if ((pet && !pet->HasAuraType(SPELL_AURA_MOD_UNATTACKABLE)) && ai->Buff(POWER_WORD_FORTITUDE, pet))
+        return true;
+
+    if (ai->Buff(POWER_WORD_FORTITUDE, target))
+        return true;
+
+    if ((target->getClass() == CLASS_DRUID || target->getPowerType() == POWER_MANA) && ai->Buff(DIVINE_SPIRIT, target))
+        return true;
+
+    return false;
+}
diff --git a/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
new file mode 100644
index 0000000..3dad67e
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotPriestAI.h
@@ -0,0 +1,157 @@
+#ifndef _PLAYERBOTPRIESTAI_H
+#define _PLAYERBOTPRIESTAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_HOLY,
+    SPELL_SHADOWMAGIC,
+    SPELL_DISCIPLINE
+};
+
+enum PriestSpells
+{
+    ABOLISH_DISEASE_1               = 552,
+    BINDING_HEAL_1                  = 32546,
+    BLESSED_HEALING_1               = 70772,
+    CIRCLE_OF_HEALING_1             = 34861,
+    CURE_DISEASE_1                  = 528,
+    DESPERATE_PRAYER_1              = 19236,
+    DEVOURING_PLAGUE_1              = 2944,
+    DISPEL_MAGIC_1                  = 527,
+    DISPERSION_1                    = 47585,
+    DIVINE_HYMN_1                   = 64843,
+    DIVINE_SPIRIT_1                 = 14752,
+    FADE_1                          = 586,
+    FEAR_WARD_1                     = 6346,
+    FLASH_HEAL_1                    = 2061,
+    GREATER_HEAL_1                  = 2060,
+    GUARDIAN_SPIRIT_1               = 47788,
+    HEAL_1                          = 2054,
+    HOLY_FIRE_1                     = 14914,
+    HOLY_NOVA_1                     = 15237,
+    HYMN_OF_HOPE_1                  = 64901,
+    INNER_FIRE_1                    = 588,
+    INNER_FOCUS_1                   = 14751,
+    LESSER_HEAL_1                   = 2050,
+    LEVITATE_1                      = 1706,
+    LIGHTWELL_1                     = 724,
+    MANA_BURN_1                     = 8129,
+    MASS_DISPEL_1                   = 32375,
+    MIND_BLAST_1                    = 8092,
+    MIND_CONTROL_1                  = 605,
+    MIND_FLAY_1                     = 15407,
+    MIND_SEAR_1                     = 48045,
+    MIND_SOOTHE_1                   = 453,
+    MIND_VISION_1                   = 2096,
+    PAIN_SUPPRESSION_1              = 33206,
+    PENANCE_1                       = 47540,
+    POWER_INFUSION_1                = 10060,
+    POWER_WORD_FORTITUDE_1          = 1243,
+    POWER_WORD_SHIELD_1             = 17,
+    PRAYER_OF_FORTITUDE_1           = 21562,
+    PRAYER_OF_HEALING_1             = 596,
+    PRAYER_OF_MENDING_1             = 33076,
+    PRAYER_OF_SHADOW_PROTECTION_1   = 27683,
+    PRAYER_OF_SPIRIT_1              = 27681,
+    PSYCHIC_HORROR_1                = 64044,
+    PSYCHIC_SCREAM_1                = 8122,
+    RENEW_1                         = 139,
+    RESURRECTION_1                  = 2006,
+    SHACKLE_UNDEAD_1                = 9484,
+    SHADOW_PROTECTION_1             = 976,
+    SHADOW_WORD_DEATH_1             = 32379,
+    SHADOW_WORD_PAIN_1              = 589,
+    SHADOWFIEND_1                   = 34433,
+    SHADOWFORM_1                    = 15473,
+    SILENCE_1                       = 15487,
+    SMITE_1                         = 585,
+    VAMPIRIC_EMBRACE_1              = 15286,
+    VAMPIRIC_TOUCH_1                = 34914
+};
+//class Player;
+
+class PlayerbotPriestAI : PlayerbotClassAI
+{
+public:
+    PlayerbotPriestAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotPriestAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    bool BuffPlayer(Player *target);
+
+private:
+    // Heals the target based off its hps
+    bool HealTarget (Unit* target);
+
+    // holy
+    uint32 BINDING_HEAL,
+           CIRCLE_OF_HEALING,
+           CLEARCASTING,
+           DESPERATE_PRAYER,
+           FLASH_HEAL,
+           GREATER_HEAL,
+           HEAL,
+           HOLY_FIRE,
+           HOLY_NOVA,
+           LESSER_HEAL,
+           MANA_BURN,
+           PRAYER_OF_HEALING,
+           PRAYER_OF_MENDING,
+           RENEW,
+           RESURRECTION,
+           SMITE,
+           CURE_DISEASE;
+
+    // shadowmagic
+    uint32 FADE,
+           SHADOW_WORD_PAIN,
+           MIND_BLAST,
+           SCREAM,
+           MIND_FLAY,
+           DEVOURING_PLAGUE,
+           SHADOW_PROTECTION,
+           VAMPIRIC_TOUCH,
+           PRAYER_OF_SHADOW_PROTECTION,
+           SHADOWFIEND,
+           MIND_SEAR;
+
+    // discipline
+    uint32 POWER_WORD_SHIELD,
+           INNER_FIRE,
+           POWER_WORD_FORTITUDE,
+           PRAYER_OF_FORTITUDE,
+           FEAR_WARD,
+           POWER_INFUSION,
+           MASS_DISPEL,
+           PENANCE,
+           DIVINE_SPIRIT,
+           PRAYER_OF_SPIRIT,
+           INNER_FOCUS;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellHoly, LastSpellShadowMagic, LastSpellDiscipline;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
new file mode 100644
index 0000000..6dd688c
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.cpp
@@ -0,0 +1,344 @@
+/*
+   Name    : PlayerbotRogueAI.cpp
+   Complete: maybe around 28%
+   Author    : Natsukawa
+   Version : 0.37
+ */
+#include "PlayerbotRogueAI.h"
+
+PlayerbotRogueAI::PlayerbotRogueAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    SINISTER_STRIKE          = ai->initSpell(SINISTER_STRIKE_1);
+    BACKSTAB                 = ai->initSpell(BACKSTAB_1);
+    KICK                     = ai->initSpell(KICK_1);
+    FEINT                    = ai->initSpell(FEINT_1);
+    FAN_OF_KNIVES            = ai->initSpell(FAN_OF_KNIVES_1);
+    GOUGE                    = ai->initSpell(GOUGE_1);
+    SPRINT                   = ai->initSpell(SPRINT_1);
+
+    SHADOWSTEP               = ai->initSpell(SHADOWSTEP_1);
+    STEALTH                  = ai->initSpell(STEALTH_1);
+    VANISH                   = ai->initSpell(VANISH_1);
+    EVASION                  = ai->initSpell(EVASION_1);
+    CLOAK_OF_SHADOWS         = ai->initSpell(CLOAK_OF_SHADOWS_1);
+    HEMORRHAGE               = ai->initSpell(HEMORRHAGE_1);
+    GHOSTLY_STRIKE           = ai->initSpell(GHOSTLY_STRIKE_1);
+    SHADOW_DANCE             = ai->initSpell(SHADOW_DANCE_1);
+    BLIND                    = ai->initSpell(BLIND_1);
+    DISTRACT                 = ai->initSpell(DISTRACT_1);
+    PREPARATION              = ai->initSpell(PREPARATION_1);
+    PREMEDITATION            = ai->initSpell(PREMEDITATION_1);
+    PICK_POCKET              = ai->initSpell(PICK_POCKET_1);
+
+    EVISCERATE               = ai->initSpell(EVISCERATE_1);
+    KIDNEY_SHOT              = ai->initSpell(KIDNEY_SHOT_1);
+    SLICE_DICE               = ai->initSpell(SLICE_AND_DICE_1);
+    GARROTE                  = ai->initSpell(GARROTE_1);
+    EXPOSE_ARMOR             = ai->initSpell(EXPOSE_ARMOR_1);
+    RUPTURE                  = ai->initSpell(RUPTURE_1);
+    DISMANTLE                = ai->initSpell(DISMANTLE_1);
+    CHEAP_SHOT               = ai->initSpell(CHEAP_SHOT_1);
+    AMBUSH                   = ai->initSpell(AMBUSH_1);
+    MUTILATE                 = ai->initSpell(MUTILATE_1);
+
+    RECENTLY_BANDAGED   = 11196; // first aid check
+    // racial
+    ARCANE_TORRENT           = ai->initSpell(ARCANE_TORRENT_ROGUE);
+    STONEFORM                = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST            = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF    = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD               = ai->initSpell(SHADOWMELD_ALL);
+    BLOOD_FURY               = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    BERSERKING               = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN     = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+
+PlayerbotRogueAI::~PlayerbotRogueAI() {}
+
+bool PlayerbotRogueAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+
+    if (STEALTH > 0 && !m_bot->HasAura(STEALTH, 0) && ai->CastSpell(STEALTH, *m_bot))
+    {
+
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Stealth (%d)", STEALTH);
+
+        m_bot->AddUnitState(UNIT_STATE_CHASE); // ensure that the bot does not use MoveChase(), as this doesn't seem to work with STEALTH
+
+        return true;
+    }
+    else if (m_bot->HasAura(STEALTH, 0))
+    {
+        m_bot->GetMotionMaster()->MoveFollow(pTarget, 4.5f, m_bot->GetOrientation());
+        return false;
+    }
+    return false;
+}
+
+void PlayerbotRogueAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    if (!pTarget)
+        return;
+
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+        {
+            if (SINISTER_STRIKE > 0)
+                ai->CastSpell(SINISTER_STRIKE);
+            return;
+        }
+        default:
+            break;
+    }
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float fTargetDist = GetCombatDistance(pTarget);
+
+    // TODO: make this work better...
+    /*if (pVictim)
+       {
+        if( pVictim!=m_bot && !m_bot->HasUnitState(UNIT_STATE_FOLLOW) && !pTarget->isInBackInMap(m_bot,10) ) {
+            GetAI()->TellMaster( "getting behind target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveFollow( pTarget, 1, 2*M_PI );
+        }
+        else if( pVictim==m_bot && m_bot->HasUnitState(UNIT_STATE_FOLLOW) )
+        {
+            GetAI()->TellMaster( "chasing attacking target" );
+            m_bot->GetMotionMaster()->Clear( true );
+            m_bot->GetMotionMaster()->MoveChase( pTarget );
+        }
+       }*/
+
+    //Rouge like behaviour. ^^
+/*    if (VANISH > 0 && GetMaster()->isDead()) { //Causes the server to crash :( removed for now.
+        m_bot->AttackStop();
+        m_bot->RemoveAllAttackers();
+        ai->CastSpell(VANISH);
+   //        m_bot->RemoveAllSpellCooldown();
+        GetAI()->TellMaster("AttackStop, CombatStop, Vanish");
+    }*/
+
+    // decide what to do:
+    if (pVictim == m_bot && CLOAK_OF_SHADOWS > 0 && pVictim->HasAura(SPELL_AURA_PERIODIC_DAMAGE) && !m_bot->HasAura(CLOAK_OF_SHADOWS, 0) && ai->CastSpell(CLOAK_OF_SHADOWS))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("CoS!");
+        return;
+    }
+    else if (m_bot->HasAura(STEALTH, 0))
+        SpellSequence = RogueStealth;
+    else if (pTarget->IsNonMeleeSpellCasted(true))
+        SpellSequence = RogueSpellPreventing;
+    else if (pVictim == m_bot && ai->GetHealthPercent() < 40)
+        SpellSequence = RogueThreat;
+    else
+        SpellSequence = RogueCombat;
+
+    // we fight in melee, target is not in range, skip the next part!
+    if (fTargetDist > ATTACK_DISTANCE)
+        return;
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case RogueStealth:
+            out << "Case Stealth";
+            if (PICK_POCKET > 0 && (pTarget->GetCreatureTypeMask() & CREATURE_TYPEMASK_HUMANOID_OR_UNDEAD) != 0 &&
+                !((Creature *) pTarget)->lootForPickPocketed && ai->CastSpell(PICK_POCKET, *pTarget))
+                out << " > Pick Pocket";
+            else if (PREMEDITATION > 0 && ai->CastSpell(PREMEDITATION, *pTarget))
+                out << " > Premeditation";
+            else if (AMBUSH > 0 && ai->GetEnergyAmount() >= 60 && ai->CastSpell(AMBUSH, *pTarget))
+                out << " > Ambush";
+            else if (CHEAP_SHOT > 0 && !pTarget->HasAura(CHEAP_SHOT, 0) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(CHEAP_SHOT, *pTarget))
+                out << " > Cheap Shot";
+            else if (GARROTE > 0 && ai->GetEnergyAmount() >= 50 && ai->CastSpell(GARROTE, *pTarget))
+                out << " > Garrote";
+            else
+                m_bot->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+            break;
+        case RogueThreat:
+            out << "Case Threat";
+            if (GOUGE > 0 && ai->GetEnergyAmount() >= 45 && !pTarget->HasAura(GOUGE, 0) && ai->CastSpell(GOUGE, *pTarget))
+                out << " > Gouge";
+            else if (EVASION > 0 && ai->GetHealthPercent() <= 35 && !m_bot->HasAura(EVASION, 0) && ai->CastSpell(EVASION))
+                out << " > Evasion";
+            else if (BLIND > 0 && ai->GetHealthPercent() <= 30 && !pTarget->HasAura(BLIND, 0) && ai->GetEnergyAmount() >= 30 && ai->CastSpell(BLIND, *pTarget))
+                out << " > Blind";
+            else if (FEINT > 0 && ai->GetHealthPercent() <= 25 && ai->GetEnergyAmount() >= 20 && ai->CastSpell(FEINT))
+                out << " > Feint";
+            else if (VANISH > 0 && ai->GetHealthPercent() <= 20 && !m_bot->HasAura(FEINT, 0) && ai->CastSpell(VANISH))
+                out << " > Vanish";
+            else if (PREPARATION > 0 && ai->CastSpell(PREPARATION))
+                out << " > Preparation";
+            else if (m_bot->getRace() == RACE_NIGHTELF && ai->GetHealthPercent() <= 15 && !m_bot->HasAura(SHADOWMELD, 0) && ai->CastSpell(SHADOWMELD, *m_bot))
+                out << " > Shadowmeld";
+            else
+                out << " NONE!";
+            break;
+        case RogueSpellPreventing:
+            out << "Case Prevent";
+            if (KIDNEY_SHOT > 0 && ai->GetEnergyAmount() >= 25 && m_bot->GetComboPoints() >= 2 && ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                out << " > Kidney Shot";
+            else if (KICK > 0 && ai->GetEnergyAmount() >= 25  && ai->CastSpell(KICK, *pTarget))
+                out << " > Kick";
+            else
+                out << " NONE!";
+            break;
+        case RogueCombat:
+        default:
+            out << "Case Combat";
+            if (m_bot->GetComboPoints() <= 4)
+            {
+                if (SHADOW_DANCE > 0 && !m_bot->HasAura(SHADOW_DANCE, 0) && ai->CastSpell(SHADOW_DANCE, *m_bot))
+                    out << " > Shadow Dance";
+                else if (CHEAP_SHOT > 0 && m_bot->HasAura(SHADOW_DANCE, 0) && !pTarget->HasAura(CHEAP_SHOT, 0) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(CHEAP_SHOT, *pTarget))
+                    out << " > Cheap Shot";
+                else if (AMBUSH > 0 && m_bot->HasAura(SHADOW_DANCE, 0) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(AMBUSH, *pTarget))
+                    out << " > Ambush";
+                else if (GARROTE > 0 && m_bot->HasAura(SHADOW_DANCE, 0) && ai->GetEnergyAmount() >= 50 && ai->CastSpell(GARROTE, *pTarget))
+                    out << " > Garrote";
+                else if (BACKSTAB > 0 && pTarget->isInBackInMap(m_bot, 1) && ai->GetEnergyAmount() >= 60 && ai->CastSpell(BACKSTAB, *pTarget))
+                    out << " > Backstab";
+                else if (MUTILATE > 0 && ai->GetEnergyAmount() >= 60 && ai->CastSpell(MUTILATE, *pTarget))
+                    out << " > Mutilate";
+                else if (SINISTER_STRIKE > 0 && ai->GetEnergyAmount() >= 45 && ai->CastSpell(SINISTER_STRIKE, *pTarget))
+                    out << " > Sinister Strike";
+                else if (GHOSTLY_STRIKE > 0 && ai->GetEnergyAmount() >= 40 && ai->CastSpell(GHOSTLY_STRIKE, *pTarget))
+                    out << " > Ghostly Strike";
+                else if (HEMORRHAGE > 0 && ai->GetEnergyAmount() >= 35 && ai->CastSpell(HEMORRHAGE, *pTarget))
+                    out << " > Hemorrhage";
+                else if (DISMANTLE > 0 && !pTarget->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_DISARMED) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(DISMANTLE, *pTarget))
+                    out << " > Dismantle";
+                else if (SHADOWSTEP > 0 && ai->GetEnergyAmount() >= 10 && ai->CastSpell(SHADOWSTEP, *pTarget))
+                    out << " > Shadowstep";
+                else if (m_bot->getRace() == RACE_BLOODELF && !pTarget->HasAura(ARCANE_TORRENT, 0) && ai->CastSpell(ARCANE_TORRENT, *pTarget))
+                    out << " > Arcane Torrent";
+                else if ((m_bot->getRace() == RACE_HUMAN && m_bot->HasUnitState(UNIT_STATE_STUNNED)) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || (m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot)))
+                    out << " > Every Man for Himself";
+                else if ((m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR)) || (m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot)))
+                    out << " > Will of the Forsaken";
+                else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+                    out << " > Stoneform";
+                else if ((m_bot->getRace() == RACE_GNOME && m_bot->HasUnitState(UNIT_STATE_STUNNED)) || (m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && ai->CastSpell(ESCAPE_ARTIST, *m_bot)))
+                    out << " > Escape Artist";
+                else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, 0) && ai->CastSpell(BLOOD_FURY, *m_bot))
+                    out << " > Blood Fury";
+                else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, 0) && ai->CastSpell(BERSERKING, *m_bot))
+                    out << " > Berserking";
+                else
+                    out << " NONE!";
+            }
+            else
+            {
+                if (EVISCERATE > 0 && pTarget->getClass() == CLASS_ROGUE && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Rogue Eviscerate";
+                else if (EVISCERATE > 0 && pTarget->getClass() == CLASS_DRUID && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Druid Eviscerate";
+                else if (KIDNEY_SHOT > 0 && pTarget->getClass() == CLASS_SHAMAN && ai->GetEnergyAmount() >= 25 && ai->CastSpell(KIDNEY_SHOT, *pTarget))
+                    out << " > Shaman Kidney";
+                else if (SLICE_DICE > 0 && pTarget->getClass() == CLASS_WARLOCK && ai->GetEnergyAmount() >= 25 && ai->CastSpell(SLICE_DICE, *pTarget))
+                    out << " > Warlock Slice & Dice";
+                else if (SLICE_DICE > 0 && pTarget->getClass() == CLASS_HUNTER && ai->GetEnergyAmount() >= 25 && ai->CastSpell(SLICE_DICE, *pTarget))
+                    out << " > Hunter Slice & Dice";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_WARRIOR && !pTarget->HasAura(EXPOSE_ARMOR, 0) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > Warrior Expose Armor";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_PALADIN && !pTarget->HasAura(EXPOSE_ARMOR, 0) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > Paladin Expose Armor";
+                else if (EXPOSE_ARMOR > 0 && pTarget->getClass() == CLASS_DEATH_KNIGHT && !pTarget->HasAura(EXPOSE_ARMOR, 0) && ai->GetEnergyAmount() >= 25 && ai->CastSpell(EXPOSE_ARMOR, *pTarget))
+                    out << " > DK Expose Armor";
+                else if (RUPTURE > 0 && pTarget->getClass() == CLASS_MAGE && ai->GetEnergyAmount() >= 25 && ai->CastSpell(RUPTURE, *pTarget))
+                    out << " > Mage Rupture";
+                else if (RUPTURE > 0 && pTarget->getClass() == CLASS_PRIEST && ai->GetEnergyAmount() >= 25 && ai->CastSpell(RUPTURE, *pTarget))
+                    out << " > Priest Rupture";
+                else if (EVISCERATE > 0 && ai->GetEnergyAmount() >= 35 && ai->CastSpell(EVISCERATE, *pTarget))
+                    out << " > Eviscerate";
+                else
+                    out << " NONE!";
+            }
+            break;
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+}
+
+// end DoNextCombatManeuver
+
+void PlayerbotRogueAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    if (!ai)
+        return;
+
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // remove stealth
+    if (m_bot->HasAura(STEALTH))
+        m_bot->RemoveAurasByType(SPELL_AURA_MOD_STEALTH);
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // Search and apply poisons to weapons
+    // Mainhand ...
+    Item * poison, * weapon;
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (poison)
+        {
+            ai->UseItem(poison, EQUIPMENT_SLOT_MAINHAND);
+            ai->SetIgnoreUpdateTime(5);
+        }
+    }
+    //... and offhand
+    weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        poison = ai->FindConsumable(DEADLY_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(WOUND_POISON_DISPLAYID);
+        if (!poison)
+            poison = ai->FindConsumable(INSTANT_POISON_DISPLAYID);
+        if (poison)
+        {
+            ai->UseItem(poison, EQUIPMENT_SLOT_OFFHAND);
+            ai->SetIgnoreUpdateTime(5);
+        }
+    }
+
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
new file mode 100644
index 0000000..8b955d8
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotRogueAI.h
@@ -0,0 +1,102 @@
+
+#ifndef _PlayerbotRogueAI_H
+#define _PlayerbotRogueAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    RogueCombat,
+    RogueSpellPreventing,
+    RogueThreat,
+    RogueStealth
+};
+
+enum RoguePoisonDisplayId
+{
+    DEADLY_POISON_DISPLAYID  = 13707,
+    INSTANT_POISON_DISPLAYID = 13710,
+    WOUND_POISON_DISPLAYID   = 37278
+};
+
+enum RogueSpells
+{
+    ADRENALINE_RUSH_1               = 13750,
+    AMBUSH_1                        = 8676,
+    BACKSTAB_1                      = 53,
+    BLADE_FLURRY_1                  = 13877,
+    BLIND_1                         = 2094,
+    CHEAP_SHOT_1                    = 1833,
+    CLOAK_OF_SHADOWS_1              = 31224,
+    COLD_BLOOD_1                    = 14177,
+    DEADLY_THROW_1                  = 26679,
+    DISARM_TRAP_1                   = 1842,
+    DISMANTLE_1                     = 51722,
+    DISTRACT_1                      = 1725,
+    ENVENOM_1                       = 32645,
+    EVASION_1                       = 5277,
+    EVISCERATE_1                    = 2098,
+    EXPOSE_ARMOR_1                  = 8647,
+    FAN_OF_KNIVES_1                 = 51723,
+    FEINT_1                         = 1966,
+    GARROTE_1                       = 703,
+    GHOSTLY_STRIKE_1                = 14278,
+    GOUGE_1                         = 1776,
+    HEMORRHAGE_1                    = 16511,
+    HUNGER_FOR_BLOOD_1              = 51662,
+    KICK_1                          = 1766,
+    KIDNEY_SHOT_1                   = 408,
+    KILLING_SPREE_1                 = 51690,
+    MUTILATE_1                      = 1329,
+    PICK_LOCK_1                     = 1804,
+    PICK_POCKET_1                   = 921,
+    PREMEDITATION_1                 = 14183,
+    PREPARATION_1                   = 14185,
+    RIPOSTE_1                       = 14251,
+    RUPTURE_1                       = 1943,
+    SAP_1                           = 6770,
+    SHADOW_DANCE_1                  = 51713,
+    SHADOWSTEP_1                    = 36554,
+    SHIV_1                          = 5938,
+    SINISTER_STRIKE_1               = 1752,
+    SLICE_AND_DICE_1                = 5171,
+    SPRINT_1                        = 2983,
+    STEALTH_1                       = 1784,
+    TRICKS_OF_THE_TRADE_1           = 57934,
+    VANISH_1                        = 1856
+};
+//class Player;
+
+class PlayerbotRogueAI : PlayerbotClassAI
+{
+public:
+    PlayerbotRogueAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotRogueAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // COMBAT
+    uint32 SINISTER_STRIKE, BACKSTAB, GOUGE, EVASION, SPRINT, KICK, FEINT, SHIV, FAN_OF_KNIVES;
+
+    // SUBTLETY
+    uint32 SHADOWSTEP, STEALTH, VANISH, HEMORRHAGE, BLIND, SHADOW_DANCE, PICK_POCKET, CLOAK_OF_SHADOWS, TRICK_TRADE, CRIPPLING_POISON, DEADLY_POISON, MIND_NUMBING_POISON, GHOSTLY_STRIKE, DISTRACT, PREPARATION, PREMEDITATION;
+
+    // ASSASSINATION
+    uint32 EVISCERATE, SLICE_DICE, GARROTE, EXPOSE_ARMOR, AMBUSH, RUPTURE, DISMANTLE, CHEAP_SHOT, KIDNEY_SHOT, MUTILATE, ENVENOM, DEADLY_THROW;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellCombat, LastSpellSubtlety, LastSpellAssassination, Aura;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
new file mode 100644
index 0000000..cffada2
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.cpp
@@ -0,0 +1,554 @@
+#include "PlayerbotShamanAI.h"
+#include "ObjectAccessor.h"
+#include "SpellAuras.h"
+
+PlayerbotShamanAI::PlayerbotShamanAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // restoration
+    CHAIN_HEAL               = ai->initSpell(CHAIN_HEAL_1);
+    HEALING_WAVE             = ai->initSpell(HEALING_WAVE_1);
+    LESSER_HEALING_WAVE      = ai->initSpell(LESSER_HEALING_WAVE_1);
+    RIPTIDE                  = ai->initSpell(RIPTIDE_1);
+    ANCESTRAL_SPIRIT         = ai->initSpell(ANCESTRAL_SPIRIT_1);
+    EARTH_SHIELD             = ai->initSpell(EARTH_SHIELD_1);
+    WATER_SHIELD             = ai->initSpell(WATER_SHIELD_1);
+    EARTHLIVING_WEAPON       = ai->initSpell(EARTHLIVING_WEAPON_1);
+    TREMOR_TOTEM             = ai->initSpell(TREMOR_TOTEM_1); // totems
+    HEALING_STREAM_TOTEM     = ai->initSpell(HEALING_STREAM_TOTEM_1);
+    MANA_SPRING_TOTEM        = ai->initSpell(MANA_SPRING_TOTEM_1);
+    MANA_TIDE_TOTEM          = ai->initSpell(MANA_TIDE_TOTEM_1);
+    CURE_TOXINS              = ai->initSpell(CURE_TOXINS_1);
+    CLEANSE_SPIRIT           = ai->initSpell(CLEANSE_SPIRIT_1);
+    // enhancement
+    FOCUSED                  = 0; // Focused what?
+    STORMSTRIKE              = ai->initSpell(STORMSTRIKE_1);
+    LAVA_LASH                = ai->initSpell(LAVA_LASH_1);
+    SHAMANISTIC_RAGE         = ai->initSpell(SHAMANISTIC_RAGE_1);
+    BLOODLUST                = ai->initSpell(BLOODLUST_1);
+    HEROISM                  = ai->initSpell(HEROISM_1);
+    FERAL_SPIRIT             = ai->initSpell(FERAL_SPIRIT_1);
+    LIGHTNING_SHIELD         = ai->initSpell(LIGHTNING_SHIELD_1);
+    ROCKBITER_WEAPON         = ai->initSpell(ROCKBITER_WEAPON_1);
+    FLAMETONGUE_WEAPON       = ai->initSpell(FLAMETONGUE_WEAPON_1);
+    FROSTBRAND_WEAPON        = ai->initSpell(FROSTBRAND_WEAPON_1);
+    WINDFURY_WEAPON          = ai->initSpell(WINDFURY_WEAPON_1);
+    STONESKIN_TOTEM          = ai->initSpell(STONESKIN_TOTEM_1); // totems
+    STRENGTH_OF_EARTH_TOTEM  = ai->initSpell(STRENGTH_OF_EARTH_TOTEM_1);
+    FROST_RESISTANCE_TOTEM   = ai->initSpell(FROST_RESISTANCE_TOTEM_1);
+    FLAMETONGUE_TOTEM        = ai->initSpell(FLAMETONGUE_TOTEM_1);
+    FIRE_RESISTANCE_TOTEM    = ai->initSpell(FIRE_RESISTANCE_TOTEM_1);
+    GROUNDING_TOTEM          = ai->initSpell(GROUNDING_TOTEM_1);
+    NATURE_RESISTANCE_TOTEM  = ai->initSpell(NATURE_RESISTANCE_TOTEM_1);
+    WIND_FURY_TOTEM          = ai->initSpell(WINDFURY_TOTEM_1);
+    STONESKIN_TOTEM          = ai->initSpell(STONESKIN_TOTEM_1);
+    WRATH_OF_AIR_TOTEM       = ai->initSpell(WRATH_OF_AIR_TOTEM_1);
+    EARTH_ELEMENTAL_TOTEM    = ai->initSpell(EARTH_ELEMENTAL_TOTEM_1);
+    // elemental
+    LIGHTNING_BOLT           = ai->initSpell(LIGHTNING_BOLT_1);
+    EARTH_SHOCK              = ai->initSpell(EARTH_SHOCK_1);
+    FLAME_SHOCK              = ai->initSpell(FLAME_SHOCK_1);
+    PURGE                    = ai->initSpell(PURGE_1);
+    WIND_SHOCK               = 0; //NPC spell
+    FROST_SHOCK              = ai->initSpell(FROST_SHOCK_1);
+    CHAIN_LIGHTNING          = ai->initSpell(CHAIN_LIGHTNING_1);
+    LAVA_BURST               = ai->initSpell(LAVA_BURST_1);
+    HEX                      = ai->initSpell(HEX_1);
+    STONECLAW_TOTEM          = ai->initSpell(STONECLAW_TOTEM_1); // totems
+    SEARING_TOTEM            = ai->initSpell(SEARING_TOTEM_1);
+    FIRE_NOVA_TOTEM          = 0; // NPC only spell, check FIRE_NOVA_1
+    MAGMA_TOTEM              = ai->initSpell(MAGMA_TOTEM_1);
+    EARTHBIND_TOTEM          = ai->initSpell(EARTHBIND_TOTEM_1);
+    TOTEM_OF_WRATH           = ai->initSpell(TOTEM_OF_WRATH_1);
+    FIRE_ELEMENTAL_TOTEM     = ai->initSpell(FIRE_ELEMENTAL_TOTEM_1);
+
+    RECENTLY_BANDAGED        = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU        = ai->initSpell(GIFT_OF_THE_NAARU_SHAMAN); // draenei
+    BLOOD_FURY               = ai->initSpell(BLOOD_FURY_SHAMAN); // orc
+    WAR_STOMP                = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING               = ai->initSpell(BERSERKING_ALL); // troll
+}
+
+PlayerbotShamanAI::~PlayerbotShamanAI() {}
+
+bool PlayerbotShamanAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotShamanAI::HealTarget(Unit &target, uint8 hp)
+{
+    PlayerbotAI* ai = GetAI();
+    Player *m_bot = GetPlayerBot();
+
+    if (hp < 30 && HEALING_WAVE > 0 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE, target);
+    else if (hp < 45 && LESSER_HEALING_WAVE > 0 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE, target);
+    else if (hp < 55 && RIPTIDE > 0 && !target.HasAura(RIPTIDE, 0) && ai->GetManaPercent() >= 21)
+        ai->CastSpell(RIPTIDE, target);
+    else if (hp < 70 && CHAIN_HEAL > 0 && ai->GetManaPercent() >= 24)
+        ai->CastSpell(CHAIN_HEAL, target);
+    if (CURE_TOXINS > 0 && ai->GetCombatOrder() != PlayerbotAI::ORDERS_NODISPEL)
+    {
+        uint32 DISPEL = CLEANSE_SPIRIT > 0 ? CLEANSE_SPIRIT : CURE_TOXINS;
+        Unit::AuraMap const& auras = target.GetOwnedAuras();
+        for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); itr++)
+        {
+            Aura *aura = itr->second;
+            if (aura->IsPassive()) continue;
+            if (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+            if (aura->GetId() == 64844 || //Divine Hymn
+                aura->GetId() == 6346) // Fear Ward
+                continue;
+            DispelType dispel = DispelType(aura->GetSpellInfo()->Dispel);
+            if (dispel == DISPEL_POISON || dispel == DISPEL_DISEASE || 
+                (DISPEL == CLEANSE_SPIRIT && dispel == DISPEL_CURSE))
+            {
+                AuraApplication *aurApp = aura->GetApplicationOfTarget(target.GetGUID());
+                if (!aurApp)
+                    continue;
+                if (!aurApp->IsPositive())
+                    ai->CastSpell(DISPEL, target);
+            }
+        }
+    }
+    // end HealTarget
+}
+
+void PlayerbotShamanAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            ai->CastSpell(LIGHTNING_BOLT);
+            return;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Group *m_group = m_bot->GetGroup();
+
+    // Heal myself
+    if (ai->GetHealthPercent() < 30 && ai->GetManaPercent() >= 32)
+        ai->CastSpell(HEALING_WAVE);
+    else if (ai->GetHealthPercent() < 50 && ai->GetManaPercent() >= 19)
+        ai->CastSpell(LESSER_HEALING_WAVE);
+    else if (ai->GetHealthPercent() < 70)
+        HealTarget (*m_bot, ai->GetHealthPercent());
+
+    // Heal master
+    uint32 masterHP = GetMaster()->GetHealth() * 100 / GetMaster()->GetMaxHealth();
+    if (GetMaster()->isAlive())
+    {
+        if (masterHP < 30 && ai->GetManaPercent() >= 32)
+            ai->CastSpell(HEALING_WAVE, *(GetMaster()));
+        else if (masterHP < 70)
+            HealTarget (*GetMaster(), masterHP);
+    }
+
+    // Heal group
+    if (m_group)
+    {
+        Group::MemberSlotList const& groupSlot = m_group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *m_groupMember = sObjectAccessor->FindPlayer(itr->guid);
+            if (!m_groupMember || !m_groupMember->isAlive())
+                continue;
+
+            uint32 memberHP = m_groupMember->GetHealth() * 100 / m_groupMember->GetMaxHealth();
+            if (memberHP < 30)
+                HealTarget(*m_groupMember, memberHP);
+        }
+    }
+
+    // Damage Spells
+
+    switch (SpellSequence)
+    {
+        case SPELL_ENHANCEMENT:
+            if (STRENGTH_OF_EARTH_TOTEM > 0 && LastSpellEnhancement == 1 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, 0)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STRENGTH_OF_EARTH_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (STONESKIN_TOTEM > 0 && LastSpellEnhancement == 5 && (!m_bot->HasAura(STONESKIN_TOTEM, 0)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, 0)) && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(STONESKIN_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FOCUSED > 0 && LastSpellEnhancement == 2)
+            {
+                ai->CastSpell(FOCUSED, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FROST_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 10 && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM, 0)) && (!m_bot->HasAura(TOTEM_OF_WRATH, 0)) && (!m_bot->HasAura(FLAMETONGUE_TOTEM, 0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FROST_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FLAMETONGUE_TOTEM > 0 && LastSpellEnhancement == 15 && (!m_bot->HasAura(FLAMETONGUE_TOTEM, 0)) && (!m_bot->HasAura(TOTEM_OF_WRATH, 0)) && (!m_bot->HasAura(FROST_RESISTANCE_TOTEM, 0)) && ai->GetManaPercent() >= 14)
+            {
+                ai->CastSpell(FLAMETONGUE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FIRE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 20 && (!m_bot->HasAura(FIRE_RESISTANCE_TOTEM, 0)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM, 0)) && (!m_bot->HasAura(MANA_SPRING_TOTEM, 0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(FIRE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (GROUNDING_TOTEM > 0 && LastSpellEnhancement == 25 && (!m_bot->HasAura(GROUNDING_TOTEM, 0)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, 0)) && (!m_bot->HasAura(WIND_FURY_TOTEM, 0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(GROUNDING_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (NATURE_RESISTANCE_TOTEM > 0 && LastSpellEnhancement == 30 && (!m_bot->HasAura(NATURE_RESISTANCE_TOTEM, 0)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, 0)) && (!m_bot->HasAura(GROUNDING_TOTEM, 0)) && (!m_bot->HasAura(WIND_FURY_TOTEM, 0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(NATURE_RESISTANCE_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (WIND_FURY_TOTEM > 0 && LastSpellEnhancement == 35 && (!m_bot->HasAura(WIND_FURY_TOTEM, 0)) && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, 0)) && (!m_bot->HasAura(GROUNDING_TOTEM, 0)) && ai->GetManaPercent() >= 11)
+            {
+                ai->CastSpell(WIND_FURY_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (STORMSTRIKE > 0 && LastSpellEnhancement == 4 && (!pTarget->HasAura(STORMSTRIKE, 0)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STORMSTRIKE, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (LAVA_LASH > 0 && LastSpellEnhancement == 6 && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(LAVA_LASH, *pTarget);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (FERAL_SPIRIT > 0 && LastSpellEnhancement == 7 && ai->GetManaPercent() >= 12)
+            {
+                ai->CastSpell(FERAL_SPIRIT);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (WRATH_OF_AIR_TOTEM > 0 && (!m_bot->HasAura(WRATH_OF_AIR_TOTEM, 0)) && (!m_bot->HasAura(GROUNDING_TOTEM, 0)) && LastSpellEnhancement == 40)
+            {
+                ai->CastSpell(WRATH_OF_AIR_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (EARTH_ELEMENTAL_TOTEM > 0 && LastSpellEnhancement == 45 && ai->GetManaPercent() >= 24)
+            {
+                ai->CastSpell(EARTH_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (BLOODLUST > 0 && LastSpellEnhancement == 8 && (!GetMaster()->HasAura(BLOODLUST, 0)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(BLOODLUST);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (HEROISM > 0 && LastSpellEnhancement == 10 && (!GetMaster()->HasAura(HEROISM, 0)) && ai->GetManaPercent() >= 26)
+            {
+                ai->CastSpell(HEROISM);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (SHAMANISTIC_RAGE > 0 && (!m_bot->HasAura(SHAMANISTIC_RAGE, 0)) && LastSpellEnhancement == 11)
+            {
+                ai->CastSpell(SHAMANISTIC_RAGE, *m_bot);
+                SpellSequence = SPELL_RESTORATION;
+                LastSpellEnhancement = LastSpellEnhancement + 1;
+                break;
+            }
+            else if (LastSpellEnhancement > 50)
+            {
+                LastSpellEnhancement = 1;
+                SpellSequence = SPELL_RESTORATION;
+                break;
+            }
+            LastSpellEnhancement = LastSpellEnhancement + 1;
+        //SpellSequence = SPELL_RESTORATION;
+        //break;
+
+        case SPELL_RESTORATION:
+            if (HEALING_STREAM_TOTEM > 0 && LastSpellRestoration < 3 && ai->GetHealthPercent() < 50 && (!m_bot->HasAura(HEALING_STREAM_TOTEM, 0)) && (!m_bot->HasAura(MANA_SPRING_TOTEM, 0)) && ai->GetManaPercent() >= 4)
+            {
+                ai->CastSpell(HEALING_STREAM_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            else if (MANA_SPRING_TOTEM > 0 && LastSpellRestoration < 4 && (!m_bot->HasAura(MANA_SPRING_TOTEM, 0)) && (!m_bot->HasAura(HEALING_STREAM_TOTEM, 0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(MANA_SPRING_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            else if (MANA_TIDE_TOTEM > 0 && LastSpellRestoration < 5 && ai->GetManaPercent() < 50 && ai->GetManaPercent() >= 3)
+            {
+                ai->CastSpell(MANA_TIDE_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration + 1;
+                break;
+            }
+            /*else if (TREMOR_TOTEM > 0 && LastSpellRestoration < 6 && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, 0)) && ai->GetManaPercent() >= 2)
+               {
+                ai->CastSpell(TREMOR_TOTEM);
+                SpellSequence = SPELL_ELEMENTAL;
+                LastSpellRestoration = LastSpellRestoration +1;
+                break;
+               }*/
+            else if (LastSpellRestoration > 6)
+            {
+                LastSpellRestoration = 0;
+                SpellSequence = SPELL_ELEMENTAL;
+                break;
+            }
+            LastSpellRestoration = LastSpellRestoration + 1;
+        //SpellSequence = SPELL_ELEMENTAL;
+        //break;
+
+        case SPELL_ELEMENTAL:
+            if (LIGHTNING_BOLT > 0 && LastSpellElemental == 1 && ai->GetManaPercent() >= 13)
+            {
+                ai->CastSpell(LIGHTNING_BOLT, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (SEARING_TOTEM > 0 && LastSpellElemental == 2 && (!pTarget->HasAura(SEARING_TOTEM, 0)) && (!m_bot->HasAura(TOTEM_OF_WRATH, 0)) && ai->GetManaPercent() >= 9)
+            {
+                ai->CastSpell(SEARING_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (STONECLAW_TOTEM > 0 && ai->GetHealthPercent() < 51 && LastSpellElemental == 3 && (!pTarget->HasAura(STONECLAW_TOTEM, 0)) && (!pTarget->HasAura(EARTHBIND_TOTEM, 0)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, 0)) && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(STONECLAW_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FLAME_SHOCK > 0 && LastSpellElemental == 4 && (!pTarget->HasAura(FLAME_SHOCK, 0)) && ai->GetManaPercent() >= 22)
+            {
+                ai->CastSpell(FLAME_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (LAVA_BURST > 0 && LastSpellElemental == 5 && (pTarget->HasAura(FLAME_SHOCK, 0)) && ai->GetManaPercent() >= 10)
+            {
+                ai->CastSpell(LAVA_BURST, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (MAGMA_TOTEM > 0 && LastSpellElemental == 6 && (!m_bot->HasAura(TOTEM_OF_WRATH, 0)) && ai->GetManaPercent() >= 35)
+            {
+                ai->CastSpell(MAGMA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTHBIND_TOTEM > 0 && LastSpellElemental == 7 && (!pTarget->HasAura(EARTHBIND_TOTEM, 0)) && (!m_bot->HasAura(STRENGTH_OF_EARTH_TOTEM, 0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(EARTHBIND_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (EARTH_SHOCK > 0 && LastSpellElemental == 8 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(EARTH_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (PURGE > 0 && LastSpellElemental == 9 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(PURGE, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (WIND_SHOCK > 0 && LastSpellElemental == 10 && ai->GetManaPercent() >= 8)
+            {
+                ai->CastSpell(WIND_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_NOVA_TOTEM > 0 && LastSpellElemental == 11 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(FIRE_NOVA_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FROST_SHOCK > 0 && LastSpellElemental == 12 && (!pTarget->HasAura(FROST_SHOCK, 0)) && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FROST_SHOCK, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (CHAIN_LIGHTNING > 0 && LastSpellElemental == 13 && ai->GetManaPercent() >= 33)
+            {
+                ai->CastSpell(CHAIN_LIGHTNING, *pTarget);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (TOTEM_OF_WRATH > 0 && LastSpellElemental == 14 && (!m_bot->HasAura(TOTEM_OF_WRATH, 0)) && ai->GetManaPercent() >= 5)
+            {
+                ai->CastSpell(TOTEM_OF_WRATH);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            else if (FIRE_ELEMENTAL_TOTEM > 0 && LastSpellElemental == 15 && ai->GetManaPercent() >= 23)
+            {
+                ai->CastSpell(FIRE_ELEMENTAL_TOTEM);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+            }
+            /*else if (HEX > 0 && LastSpellElemental == 16 && (!pTarget->HasAura(HEX, 0)) && ai->GetManaPercent() >= 3)
+               {
+                ai->CastSpell(HEX);
+                SpellSequence = SPELL_ENHANCEMENT;
+                LastSpellElemental = LastSpellElemental + 1;
+                break;
+               }*/
+            else if (LastSpellElemental > 16)
+            {
+                LastSpellElemental = 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+                break;
+            }
+            else
+            {
+                LastSpellElemental = LastSpellElemental + 1;
+                SpellSequence = SPELL_ENHANCEMENT;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotShamanAI::DoNonCombatActions()
+{
+    PlayerbotAI* ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    SpellSequence = SPELL_ENHANCEMENT;
+
+    // buff master with EARTH_SHIELD
+    if (EARTH_SHIELD > 0)
+        (!GetMaster()->HasAura(EARTH_SHIELD, 0) && ai->CastSpell(EARTH_SHIELD, *(GetMaster())));
+
+    // buff myself with WATER_SHIELD, LIGHTNING_SHIELD
+    if (WATER_SHIELD > 0)
+        (!m_bot->HasAura(WATER_SHIELD, 0) && !m_bot->HasAura(LIGHTNING_SHIELD, 0) && ai->CastSpell(WATER_SHIELD, *m_bot));
+    else if (LIGHTNING_SHIELD > 0)
+        (!m_bot->HasAura(LIGHTNING_SHIELD, 0) && !m_bot->HasAura(WATER_SHIELD, 0) && ai->CastSpell(LIGHTNING_SHIELD, *m_bot));
+/*
+       // buff myself weapon
+       if (ROCKBITER_WEAPON > 0)
+            (!m_bot->HasAura(ROCKBITER_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && ai->CastSpell(ROCKBITER_WEAPON,*m_bot) );
+       else if (EARTHLIVING_WEAPON > 0)
+            (!m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (WINDFURY_WEAPON > 0)
+            (!m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(WINDFURY_WEAPON,*m_bot) );
+       else if (FLAMETONGUE_WEAPON > 0)
+            (!m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(FLAMETONGUE_WEAPON,*m_bot) );
+       else if (FROSTBRAND_WEAPON > 0)
+            (!m_bot->HasAura(FROSTBRAND_WEAPON, 0) && !m_bot->HasAura(EARTHLIVING_WEAPON, 0) && !m_bot->HasAura(WINDFURY_WEAPON, 0) && !m_bot->HasAura(FLAMETONGUE_WEAPON, 0) && !m_bot->HasAura(ROCKBITER_WEAPON, 0) && ai->CastSpell(FROSTBRAND_WEAPON,*m_bot) );
+ */
+    // mana check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindDrink();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetManaPercent() < 30)
+    {
+        ai->TellMaster("I could use a drink.");
+        ai->UseItem(pItem);
+        return;
+    }
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    pItem = ai->FindFood();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+
+    // heal master's group
+    if (GetMaster()->GetGroup())
+    {
+        Group::MemberSlotList const& groupSlot = GetMaster()->GetGroup()->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *tPlayer = sObjectAccessor->FindPlayer(itr->guid);
+            if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported() || 
+                tPlayer->GetMap() != m_bot->GetMap() || tPlayer->GetDistance(m_bot) > 30)
+                continue;
+
+            if (tPlayer->duel && tPlayer->duel->opponent == GetMaster())
+                continue;
+
+            // heal
+            (HealTarget(*tPlayer, tPlayer->GetHealth() * 100 / tPlayer->GetMaxHealth()));
+        }
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
new file mode 100644
index 0000000..72324ed
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotShamanAI.h
@@ -0,0 +1,119 @@
+#ifndef _PLAYERBOTSHAMANAI_H
+#define _PLAYERBOTSHAMANAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    SPELL_ENHANCEMENT,
+    SPELL_RESTORATION,
+    SPELL_ELEMENTAL
+};
+
+enum
+{
+    ANCESTRAL_SPIRIT_1              = 2008,
+    ASTRAL_RECALL_1                 = 556,
+    BLOODLUST_1                     = 2825,
+    CALL_OF_THE_ANCESTORS_1         = 66843,
+    CALL_OF_THE_ELEMENTS_1          = 66842,
+    CALL_OF_THE_SPIRITS_1           = 66844,
+    CHAIN_HEAL_1                    = 1064,
+    CHAIN_LIGHTNING_1               = 421,
+    CHAINED_HEAL_1                  = 70809,
+    CLEANSE_SPIRIT_1                = 51886,
+    CLEANSING_TOTEM_1               = 8170,
+    CURE_TOXINS_1                   = 526,
+    EARTH_ELEMENTAL_TOTEM_1         = 2062,
+    EARTH_SHIELD_1                  = 974,
+    EARTH_SHOCK_1                   = 8042,
+    EARTHBIND_TOTEM_1               = 2484,
+    EARTHLIVING_WEAPON_1            = 51730,
+    ELEMENTAL_MASTERY_1             = 16166,
+    FERAL_SPIRIT_1                  = 51533,
+    FIRE_ELEMENTAL_TOTEM_1          = 2894,
+    FIRE_NOVA_1                     = 1535,
+    FIRE_RESISTANCE_TOTEM_1         = 8184,
+    FLAME_SHOCK_1                   = 8050,
+    FLAMETONGUE_TOTEM_1             = 8227,
+    FLAMETONGUE_WEAPON_1            = 8024,
+    FROST_RESISTANCE_TOTEM_1        = 8181,
+    FROST_SHOCK_1                   = 8056,
+    FROSTBRAND_WEAPON_1             = 8033,
+    GHOST_WOLF_1                    = 2645,
+    GROUNDING_TOTEM_1               = 8177,
+    HEALING_STREAM_TOTEM_1          = 5394,
+    HEALING_WAVE_1                  = 331,
+    HEROISM_1                       = 32182,
+    HEX_1                           = 51514,
+    LAVA_BURST_1                    = 51505,
+    LAVA_LASH_1                     = 60103,
+    LESSER_HEALING_WAVE_1           = 8004,
+    LIGHTNING_BOLT_1                = 403,
+    LIGHTNING_SHIELD_1              = 324,
+    MAGMA_TOTEM_1                   = 8190,
+    MANA_SPRING_TOTEM_1             = 5675,
+    MANA_TIDE_TOTEM_1               = 16190,
+    NATURE_RESISTANCE_TOTEM_1       = 10595,
+    NATURES_SWIFTNESS_SHAMAN_1      = 16188,
+    PURGE_1                         = 370,
+    RIPTIDE_1                       = 61295,
+    ROCKBITER_WEAPON_1              = 8017,
+    SEARING_TOTEM_1                 = 3599,
+    SENTRY_TOTEM_1                  = 6495,
+    SHAMANISTIC_RAGE_1              = 30823,
+    STONECLAW_TOTEM_1               = 5730,
+    STONESKIN_TOTEM_1               = 8071,
+    STORMSTRIKE_1                   = 17364,
+    STRENGTH_OF_EARTH_TOTEM_1       = 8075,
+    THUNDERSTORM_1                  = 51490,
+    TIDAL_FORCE_1                   = 55198,
+    TOTEM_OF_WRATH_1                = 30706,
+    TOTEMIC_RECALL_1                = 36936,
+    TREMOR_TOTEM_1                  = 8143,
+    WATER_BREATHING_1               = 131,
+    WATER_SHIELD_1                  = 52127,
+    WATER_WALKING_1                 = 546,
+    WIND_SHEAR_1                    = 57994,
+    WINDFURY_TOTEM_1                = 8512,
+    WINDFURY_WEAPON_1               = 8232,
+    WRATH_OF_AIR_TOTEM_1            = 3738
+};
+//class Player;
+
+class PlayerbotShamanAI : PlayerbotClassAI
+{
+public:
+    PlayerbotShamanAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotShamanAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // Heals the target based off its hps
+    void HealTarget (Unit& target, uint8 hp);
+
+    // ENHANCEMENT
+    uint32 ROCKBITER_WEAPON, STONESKIN_TOTEM, LIGHTNING_SHIELD, FLAMETONGUE_WEAPON, STRENGTH_OF_EARTH_TOTEM, FOCUSED, FROSTBRAND_WEAPON, FROST_RESISTANCE_TOTEM, FLAMETONGUE_TOTEM, FIRE_RESISTANCE_TOTEM, WINDFURY_WEAPON, GROUNDING_TOTEM, NATURE_RESISTANCE_TOTEM, WIND_FURY_TOTEM, STORMSTRIKE, LAVA_LASH, SHAMANISTIC_RAGE, WRATH_OF_AIR_TOTEM, EARTH_ELEMENTAL_TOTEM, BLOODLUST, HEROISM, FERAL_SPIRIT;
+
+    // RESTORATION
+    uint32 HEALING_WAVE, LESSER_HEALING_WAVE, ANCESTRAL_SPIRIT, TREMOR_TOTEM, HEALING_STREAM_TOTEM, MANA_SPRING_TOTEM, CHAIN_HEAL, MANA_TIDE_TOTEM, EARTH_SHIELD, WATER_SHIELD, EARTHLIVING_WEAPON, RIPTIDE, CURE_TOXINS, CLEANSE_SPIRIT;
+
+    // ELEMENTAL
+    uint32 LIGHTNING_BOLT, EARTH_SHOCK, STONECLAW_TOTEM, FLAME_SHOCK, SEARING_TOTEM, PURGE, FIRE_NOVA_TOTEM, WIND_SHOCK, FROST_SHOCK, MAGMA_TOTEM, CHAIN_LIGHTNING, TOTEM_OF_WRATH, FIRE_ELEMENTAL_TOTEM, LAVA_BURST, EARTHBIND_TOTEM, HEX;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence, LastSpellEnhancement, LastSpellRestoration, LastSpellElemental;
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
new file mode 100644
index 0000000..d5ce6cb
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.cpp
@@ -0,0 +1,568 @@
+#include "PlayerbotWarlockAI.h"
+
+PlayerbotWarlockAI::PlayerbotWarlockAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    // DESTRUCTION
+    SHADOW_BOLT           = ai->initSpell(SHADOW_BOLT_1);
+    IMMOLATE              = ai->initSpell(IMMOLATE_1);
+    INCINERATE            = ai->initSpell(INCINERATE_1);
+    SEARING_PAIN          = ai->initSpell(SEARING_PAIN_1);
+    CONFLAGRATE           = ai->initSpell(CONFLAGRATE_1);
+    SHADOWFURY            = ai->initSpell(SHADOWFURY_1);
+    CHAOS_BOLT            = ai->initSpell(CHAOS_BOLT_1);
+    SHADOWFLAME           = ai->initSpell(SHADOWFLAME_1);
+    HELLFIRE              = ai->initSpell(HELLFIRE_1);
+    RAIN_OF_FIRE          = ai->initSpell(RAIN_OF_FIRE_1);
+    SOUL_FIRE             = ai->initSpell(SOUL_FIRE_1); // soul shard spells
+    SHADOWBURN            = ai->initSpell(SHADOWBURN_1);
+    // CURSE
+    CURSE_OF_WEAKNESS     = ai->initSpell(CURSE_OF_WEAKNESS_1);
+    CURSE_OF_THE_ELEMENTS = ai->initSpell(CURSE_OF_THE_ELEMENTS_1);
+    CURSE_OF_AGONY        = ai->initSpell(CURSE_OF_AGONY_1);
+    CURSE_OF_EXHAUSTION   = ai->initSpell(CURSE_OF_EXHAUSTION_1);
+    CURSE_OF_TONGUES      = ai->initSpell(CURSE_OF_TONGUES_1);
+    CURSE_OF_DOOM         = ai->initSpell(CURSE_OF_DOOM_1);
+    // AFFLICTION
+    CORRUPTION            = ai->initSpell(CORRUPTION_1);
+    DRAIN_SOUL            = ai->initSpell(DRAIN_SOUL_1);
+    DRAIN_LIFE            = ai->initSpell(DRAIN_LIFE_1);
+    DRAIN_MANA            = ai->initSpell(DRAIN_MANA_1);
+    LIFE_TAP              = ai->initSpell(LIFE_TAP_1);
+    UNSTABLE_AFFLICTION   = ai->initSpell(UNSTABLE_AFFLICTION_1);
+    HAUNT                 = ai->initSpell(HAUNT_1);
+    SEED_OF_CORRUPTION    = ai->initSpell(SEED_OF_CORRUPTION_1);
+    DARK_PACT             = ai->initSpell(DARK_PACT_1);
+    HOWL_OF_TERROR        = ai->initSpell(HOWL_OF_TERROR_1);
+    FEAR                  = ai->initSpell(FEAR_1);
+    // DEMONOLOGY
+    DEMON_SKIN            = ai->initSpell(DEMON_SKIN_1);
+    DEMON_ARMOR           = ai->initSpell(DEMON_ARMOR_1);
+    DEMONIC_EMPOWERMENT   = ai->initSpell(DEMONIC_EMPOWERMENT_1);
+    FEL_ARMOR             = ai->initSpell(FEL_ARMOR_1);
+    SHADOW_WARD           = ai->initSpell(SHADOW_WARD_1);
+    SOULSHATTER           = ai->initSpell(SOULSHATTER_1);
+    SOUL_LINK             = ai->initSpell(SOUL_LINK_1);
+    SOUL_LINK_AURA        = 25228; // dummy aura applied, after spell SOUL_LINK
+    HEALTH_FUNNEL         = ai->initSpell(HEALTH_FUNNEL_1);
+    DETECT_INVISIBILITY   = ai->initSpell(DETECT_INVISIBILITY_1);
+    CREATE_FIRESTONE      = ai->initSpell(CREATE_FIRESTONE_1);
+    CREATE_HEALTHSTONE    = ai->initSpell(CREATE_HEALTHSTONE_1);
+    CREATE_SOULSTONE      = ai->initSpell(CREATE_SOULSTONE_1);
+    // demon summon
+    SUMMON_IMP            = ai->initSpell(SUMMON_IMP_1);
+    SUMMON_VOIDWALKER     = ai->initSpell(SUMMON_VOIDWALKER_1);
+    SUMMON_SUCCUBUS       = ai->initSpell(SUMMON_SUCCUBUS_1);
+    SUMMON_FELHUNTER      = ai->initSpell(SUMMON_FELHUNTER_1);
+    SUMMON_FELGUARD       = ai->initSpell(SUMMON_FELGUARD_1);
+    // demon skills should be initialized on demons
+    BLOOD_PACT            = 0; // imp skill
+    CONSUME_SHADOWS       = 0; // voidwalker skill
+    FEL_INTELLIGENCE      = 0; // felhunter skill
+
+    RECENTLY_BANDAGED     = 11196; // first aid check
+
+    // racial
+    ARCANE_TORRENT        = ai->initSpell(ARCANE_TORRENT_MANA_CLASSES); // blood elf
+    ESCAPE_ARTIST         = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    BLOOD_FURY            = ai->initSpell(BLOOD_FURY_WARLOCK); // orc
+    WILL_OF_THE_FORSAKEN  = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+
+    m_lastDemon = 0;
+    m_demonOfChoice = DEMON_IMP;
+    m_isTempImp = false;
+}
+
+PlayerbotWarlockAI::~PlayerbotWarlockAI() {}
+
+bool PlayerbotWarlockAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    return false;
+}
+
+void PlayerbotWarlockAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+        {
+            if (SHADOW_BOLT > 0)
+                ai->CastSpell(SHADOW_BOLT);
+            return;
+        }
+        default:
+            break;
+    }
+
+    // ------- Non Duel combat ----------
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    Pet *pet = m_bot->GetPet();
+
+    // Empower demon
+    if (pet && DEMONIC_EMPOWERMENT && !m_bot->HasSpellCooldown(DEMONIC_EMPOWERMENT))
+        ai->CastSpell(DEMONIC_EMPOWERMENT);
+
+    // Use voidwalker sacrifice on low health if possible
+    if (ai->GetHealthPercent() < 50)
+        if (pet && pet->GetEntry() == DEMON_VOIDWALKER && SACRIFICE && !m_bot->HasAura(SACRIFICE))
+            ai->CastPetSpell(SACRIFICE);
+
+    // Use healthstone
+    if (ai->GetHealthPercent() < 30)
+    {
+        Item* healthStone = ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (healthStone)
+            ai->UseItem(healthStone);
+    }
+
+    // Damage Spells
+    switch (SpellSequence)
+    {
+        case SPELL_CURSES:
+            if (CURSE_OF_AGONY && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(SHADOWFLAME) && LastSpellCurse < 1)
+            {
+                ai->CastSpell(CURSE_OF_AGONY, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_THE_ELEMENTS && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_WEAKNESS) && LastSpellCurse < 2)
+            {
+                ai->CastSpell(CURSE_OF_THE_ELEMENTS, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_WEAKNESS && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && LastSpellCurse < 3)
+            {
+                ai->CastSpell(CURSE_OF_WEAKNESS, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            else if (CURSE_OF_TONGUES && !pTarget->HasAura(CURSE_OF_TONGUES) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(CURSE_OF_WEAKNESS) && !pTarget->HasAura(CURSE_OF_AGONY) && !pTarget->HasAura(CURSE_OF_THE_ELEMENTS) && LastSpellCurse < 4)
+            {
+                ai->CastSpell(CURSE_OF_TONGUES, *pTarget);
+                SpellSequence = SPELL_AFFLICTION;
+                ++LastSpellCurse;
+                break;
+            }
+            LastSpellCurse = 0;
+        //SpellSequence = SPELL_AFFLICTION;
+        //break;
+
+        case SPELL_AFFLICTION:
+            if (LIFE_TAP && LastSpellAffliction < 1 && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 50)
+            {
+                ai->CastSpell(LIFE_TAP, *m_bot);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (CORRUPTION && !pTarget->HasAura(CORRUPTION) && !pTarget->HasAura(SHADOWFLAME) && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 2)
+            {
+                ai->CastSpell(CORRUPTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (DRAIN_SOUL && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.40 && !pTarget->HasAura(DRAIN_SOUL) && LastSpellAffliction < 3)
+            {
+                ai->CastSpell(DRAIN_SOUL, *pTarget);
+                //ai->SetIgnoreUpdateTime(15);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (DRAIN_LIFE && LastSpellAffliction < 4 && !pTarget->HasAura(DRAIN_SOUL) && !pTarget->HasAura(SEED_OF_CORRUPTION) && !pTarget->HasAura(DRAIN_LIFE) && !pTarget->HasAura(DRAIN_MANA) && ai->GetHealthPercent() <= 70)
+            {
+                ai->CastSpell(DRAIN_LIFE, *pTarget);
+                //ai->SetIgnoreUpdateTime(5);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (UNSTABLE_AFFLICTION && LastSpellAffliction < 5 && !pTarget->HasAura(UNSTABLE_AFFLICTION) && !pTarget->HasAura(SHADOWFLAME))
+            {
+                ai->CastSpell(UNSTABLE_AFFLICTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (HAUNT && LastSpellAffliction < 6 && !pTarget->HasAura(HAUNT))
+            {
+                ai->CastSpell(HAUNT, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (SEED_OF_CORRUPTION && !pTarget->HasAura(SEED_OF_CORRUPTION) && LastSpellAffliction < 7)
+            {
+                ai->CastSpell(SEED_OF_CORRUPTION, *pTarget);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (HOWL_OF_TERROR && !pTarget->HasAura(HOWL_OF_TERROR) && ai->GetAttackerCount() > 3 && LastSpellAffliction < 8)
+            {
+                ai->CastSpell(HOWL_OF_TERROR, *pTarget);
+                ai->TellMaster("casting howl of terror!");
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if (FEAR && !pTarget->HasAura(FEAR) && pVictim == m_bot && ai->GetAttackerCount() >= 2 && LastSpellAffliction < 9)
+            {
+                ai->CastSpell(FEAR, *pTarget);
+                //ai->TellMaster("casting fear!");
+                //ai->SetIgnoreUpdateTime(1.5);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            else if ((pet)
+                     && (DARK_PACT > 0 && ai->GetManaPercent() <= 50 && LastSpellAffliction < 10 && pet->GetPower(POWER_MANA) > 0))
+            {
+                ai->CastSpell(DARK_PACT, *m_bot);
+                SpellSequence = SPELL_DESTRUCTION;
+                ++LastSpellAffliction;
+                break;
+            }
+            LastSpellAffliction = 0;
+        //SpellSequence = SPELL_DESTRUCTION;
+        //break;
+
+        case SPELL_DESTRUCTION:
+            if (SHADOWFURY && LastSpellDestruction < 1 && !pTarget->HasAura(SHADOWFURY))
+            {
+                ai->CastSpell(SHADOWFURY, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOW_BOLT && LastSpellDestruction < 2)
+            {
+                ai->CastSpell(SHADOW_BOLT, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (RAIN_OF_FIRE && LastSpellDestruction < 3 && ai->GetAttackerCount() >= 3)
+            {
+                ai->CastSpell(RAIN_OF_FIRE, *pTarget);
+                //ai->TellMaster("casting rain of fire!");
+                //ai->SetIgnoreUpdateTime(8);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOWFLAME && !pTarget->HasAura(SHADOWFLAME) && LastSpellDestruction < 4)
+            {
+                ai->CastSpell(SHADOWFLAME, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (IMMOLATE && !pTarget->HasAura(IMMOLATE) && !pTarget->HasAura(SHADOWFLAME) && LastSpellDestruction < 5)
+            {
+                ai->CastSpell(IMMOLATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (CONFLAGRATE && LastSpellDestruction < 6)
+            {
+                ai->CastSpell(CONFLAGRATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (INCINERATE && LastSpellDestruction < 7)
+            {
+                ai->CastSpell(INCINERATE, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SEARING_PAIN && LastSpellDestruction < 8)
+            {
+                ai->CastSpell(SEARING_PAIN, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SOUL_FIRE && LastSpellDestruction < 9)
+            {
+                ai->CastSpell(SOUL_FIRE, *pTarget);
+                //ai->SetIgnoreUpdateTime(6);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (CHAOS_BOLT && LastSpellDestruction < 10)
+            {
+                ai->CastSpell(CHAOS_BOLT, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (SHADOWBURN && LastSpellDestruction < 11 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.20 && !pTarget->HasAura(SHADOWBURN))
+            {
+                ai->CastSpell(SHADOWBURN, *pTarget);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else if (HELLFIRE && LastSpellDestruction < 12 && !m_bot->HasAura(HELLFIRE) && ai->GetAttackerCount() >= 5 && ai->GetHealthPercent() >= 50)
+            {
+                ai->CastSpell(HELLFIRE);
+                ai->TellMaster("casting hellfire!");
+                //ai->SetIgnoreUpdateTime(15);
+                SpellSequence = SPELL_CURSES;
+                ++LastSpellDestruction;
+                break;
+            }
+            else
+            {
+                LastSpellDestruction = 0;
+                SpellSequence = SPELL_CURSES;
+            }
+    }
+} // end DoNextCombatManeuver
+
+void PlayerbotWarlockAI::DoNonCombatActions()
+{
+    SpellSequence = SPELL_CURSES;
+
+    PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!ai || !m_bot)
+        return;
+
+    Pet *pet = m_bot->GetPet();
+
+    // Initialize pet spells
+    if (pet && pet->GetEntry() != m_lastDemon)
+    {
+        switch (pet->GetEntry())
+        {
+            case DEMON_IMP:
+            {
+                BLOOD_PACT       = ai->initPetSpell(BLOOD_PACT_ICON);
+                FIREBOLT         = ai->initPetSpell(FIREBOLT_ICON);
+                FIRE_SHIELD      = ai->initPetSpell(FIRE_SHIELD_ICON);
+                break;
+            }
+            case DEMON_VOIDWALKER:
+            {
+                CONSUME_SHADOWS  = ai->initPetSpell(CONSUME_SHADOWS_ICON);
+                SACRIFICE        = ai->initPetSpell(SACRIFICE_ICON);
+                SUFFERING        = ai->initPetSpell(SUFFERING_ICON);
+                TORMENT          = ai->initPetSpell(TORMENT_ICON);
+                break;
+            }
+            case DEMON_SUCCUBUS:
+            {
+                LASH_OF_PAIN     = ai->initPetSpell(LASH_OF_PAIN_ICON);
+                SEDUCTION        = ai->initPetSpell(SEDUCTION_ICON);
+                SOOTHING_KISS    = ai->initPetSpell(SOOTHING_KISS_ICON);
+                break;
+            }
+            case DEMON_FELHUNTER:
+            {
+                DEVOUR_MAGIC     = ai->initPetSpell(DEVOUR_MAGIC_ICON);
+                FEL_INTELLIGENCE = ai->initPetSpell(FEL_INTELLIGENCE_ICON);
+                SHADOW_BITE      = ai->initPetSpell(SHADOW_BITE_ICON);
+                SPELL_LOCK       = ai->initPetSpell(SPELL_LOCK_ICON);
+                break;
+            }
+            case DEMON_FELGUARD:
+            {
+                ANGUISH          = ai->initPetSpell(ANGUISH_ICON);
+                CLEAVE           = ai->initPetSpell(CLEAVE_ICON);
+                INTERCEPT        = ai->initPetSpell(INTERCEPT_ICON);
+                break;
+            }
+        }
+
+        m_lastDemon = pet->GetEntry();
+
+        if (!m_isTempImp)
+            m_demonOfChoice = pet->GetEntry();
+    }
+
+    // Destroy extra soul shards
+    uint8 shardCount = m_bot->GetItemCount(SOUL_SHARD, false, NULL);
+    uint8 freeSpace = ai->GetFreeBagSpace();
+    if (shardCount > MAX_SHARD_COUNT || (freeSpace == 0 && shardCount > 1))
+        m_bot->DestroyItemCount(SOUL_SHARD, shardCount > MAX_SHARD_COUNT ? shardCount - MAX_SHARD_COUNT : 1, true, false);
+
+    // buff myself DEMON_SKIN, DEMON_ARMOR, FEL_ARMOR
+    if (FEL_ARMOR)
+    {
+        if (ai->SelfBuff(FEL_ARMOR))
+            return;
+    }
+    else if (DEMON_ARMOR)
+    {
+        if (ai->SelfBuff(DEMON_ARMOR))
+            return;
+    }
+    else if (DEMON_SKIN)
+        if (ai->SelfBuff(DEMON_SKIN))
+            return;
+
+    // healthstone creation
+    if (CREATE_HEALTHSTONE && shardCount > 0)
+    {
+        Item* const healthStone = ai->FindConsumable(HEALTHSTONE_DISPLAYID);
+        if (!healthStone && ai->CastSpell(CREATE_HEALTHSTONE))
+            return;
+    }
+
+    // soulstone creation and use
+    if (CREATE_SOULSTONE)
+    {
+        Item* soulStone = ai->FindConsumable(SOULSTONE_DISPLAYID);
+        if (!soulStone)
+        {
+            if (shardCount > 0 && !m_bot->HasSpellCooldown(CREATE_SOULSTONE) && ai->CastSpell(CREATE_SOULSTONE))
+                return;
+        }
+        else
+        {
+            uint32 soulStoneSpell = soulStone->GetTemplate()->Spells[0].SpellId;
+            Player * master = GetMaster();
+            if (!master->HasAura(soulStoneSpell) && !m_bot->HasSpellCooldown(soulStoneSpell))
+            {
+                ai->UseItem(soulStone, master);
+                return;
+            }
+        }
+    }
+
+    // firestone creation and use
+    Item* const weapon = m_bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+    if (weapon && weapon->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) == 0)
+    {
+        Item* const stone = ai->FindConsumable(FIRESTONE_DISPLAYID);
+        if (!stone)
+        {
+            if (CREATE_FIRESTONE && shardCount > 0 && ai->CastSpell(CREATE_FIRESTONE))
+                return;
+        }
+        else
+        {
+            ai->UseItem(stone, EQUIPMENT_SLOT_MAINHAND);
+            return;
+        }
+    }
+
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    // mana check
+    if (pet && DARK_PACT && pet->GetPower(POWER_MANA) > 0 && ai->GetManaPercent() <= 50)
+        if (ai->CastSpell(DARK_PACT, *m_bot))
+            return;
+
+    if (LIFE_TAP && ai->GetManaPercent() <= 50 && ai->GetHealthPercent() > 50)
+        if (ai->CastSpell(LIFE_TAP, *m_bot))
+            return;
+
+    if (ai->GetManaPercent() < 25)
+    {
+        Item* pItem = ai->FindDrink();
+        if (pItem)
+        {
+            ai->TellMaster("I could use a drink.");
+            ai->UseItem(pItem);
+            return;
+        }
+    }
+
+    // hp check
+    if (ai->GetHealthPercent() < 30)
+    {
+        Item* pItem = ai->FindFood();
+        if (pItem)
+        {
+            ai->TellMaster("I could use some food.");
+            ai->UseItem(pItem);
+            return;
+        }
+    }
+
+    if (ai->GetHealthPercent() < 50 && !m_bot->HasAura(RECENTLY_BANDAGED))
+    {
+        Item* fItem = ai->FindBandage();
+        if (fItem)
+        {
+            ai->TellMaster("I could use first aid.");
+            ai->UseItem(fItem);
+            return;
+        }
+    }
+
+    //Heal Voidwalker
+    if (pet && pet->GetEntry() == DEMON_VOIDWALKER && CONSUME_SHADOWS && pet->GetHealthPct() < 75 && !pet->HasAura(CONSUME_SHADOWS))
+        ai->CastPetSpell(CONSUME_SHADOWS);
+
+    // Summon demon
+    if (!pet || m_isTempImp)
+    {
+        uint32 summonSpellId;
+        if (m_demonOfChoice != DEMON_IMP && shardCount > 0)
+        {
+            switch (m_demonOfChoice)
+            {
+                case DEMON_VOIDWALKER:
+                    summonSpellId = SUMMON_VOIDWALKER;
+                    break;
+                case DEMON_FELGUARD:
+                    summonSpellId = SUMMON_FELGUARD;
+                    break;
+                case DEMON_FELHUNTER:
+                    summonSpellId = SUMMON_FELHUNTER;
+                    break;
+                case DEMON_SUCCUBUS:
+                    summonSpellId = SUMMON_SUCCUBUS;
+                    break;
+                default:
+                    summonSpellId = 0;
+            }
+            if (ai->CastSpell(summonSpellId))
+            {
+                ai->TellMaster("Summoning favorite demon...");
+                m_isTempImp = false;
+                return;
+            }
+        }
+        else if (!pet && SUMMON_IMP && ai->CastSpell(SUMMON_IMP))
+        {
+            if (m_demonOfChoice != DEMON_IMP)
+                m_isTempImp = true;
+
+            ai->TellMaster("Summoning Imp...");
+            return;
+        }
+    }
+
+    // Soul link demon
+    if (pet && SOUL_LINK && !m_bot->HasAura(SOUL_LINK_AURA) && ai->CastSpell(SOUL_LINK, *m_bot))
+        return;
+
+    // Check demon buffs
+    if (pet && pet->GetEntry() == DEMON_IMP && BLOOD_PACT && !m_bot->HasAura(BLOOD_PACT) && ai->CastPetSpell(BLOOD_PACT))
+        return;
+
+    if (pet && pet->GetEntry() == DEMON_FELHUNTER && FEL_INTELLIGENCE && !m_bot->HasAura(FEL_INTELLIGENCE) && ai->CastPetSpell(FEL_INTELLIGENCE))
+        return;
+
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
new file mode 100644
index 0000000..a12023f
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarlockAI.h
@@ -0,0 +1,250 @@
+#ifndef _PlayerbotWarlockAI_H
+#define _PlayerbotWarlockAI_H
+
+#include "PlayerbotAI.h"
+
+#define SOUL_SHARD 6265
+#define MAX_SHARD_COUNT 4 // Maximum soul shard count bot should keep
+
+enum
+{
+    SPELL_CURSES,
+    SPELL_AFFLICTION,
+    SPELL_DESTRUCTION,
+    SPELL_DEMONOLOGY
+};
+
+enum StoneDisplayId
+{
+    FIRESTONE_DISPLAYID   = 7409,
+    SPELLSTONE_DISPLAYID  = 13291,
+    SOULSTONE_DISPLAYID   = 6009,
+    HEALTHSTONE_DISPLAYID = 8026
+};
+
+enum DemonEntry
+{
+    DEMON_IMP        = 416,
+    DEMON_VOIDWALKER = 1860,
+    DEMON_SUCCUBUS   = 1863,
+    DEMON_FELHUNTER  = 417,
+    DEMON_FELGUARD   = 17252
+};
+
+enum DemonSpellIconIds
+{
+    // Imp
+    BLOOD_PACT_ICON       = 541,
+    FIREBOLT_ICON         = 18,
+    FIRE_SHIELD_ICON      = 16,
+    // Felguard
+    ANGUISH_ICON          = 173,
+    CLEAVE_ICON           = 277,
+    INTERCEPT_ICON        = 516,
+    // Felhunter
+    DEVOUR_MAGIC_ICON     = 47,
+    FEL_INTELLIGENCE_ICON = 1940,
+    SHADOW_BITE_ICON      = 2027,
+    SPELL_LOCK_ICON       = 77,
+    // Succubus
+    LASH_OF_PAIN_ICON     = 596,
+    SEDUCTION_ICON        = 48,
+    SOOTHING_KISS_ICON    = 694,
+    // Voidwalker
+    CONSUME_SHADOWS_ICON  = 207,
+    SACRIFICE_ICON        = 693,
+    SUFFERING_ICON        = 9,
+    TORMENT_ICON          = 173
+};
+
+enum WarlockSpells
+{
+    BANISH_1                        = 710,
+    CHALLENGING_HOWL_1              = 59671,
+    CHAOS_BOLT_1                    = 50796,
+    CONFLAGRATE_1                   = 17962,
+    CORRUPTION_1                    = 172,
+    CREATE_FIRESTONE_1              = 6366,
+    CREATE_HEALTHSTONE_1            = 6201,
+    CREATE_SOULSTONE_1              = 693,
+    CREATE_SPELLSTONE_1             = 2362,
+    CURSE_OF_AGONY_1                = 980,
+    CURSE_OF_DOOM_1                 = 603,
+    CURSE_OF_EXHAUSTION_1           = 18223,
+    CURSE_OF_THE_ELEMENTS_1         = 1490,
+    CURSE_OF_TONGUES_1              = 1714,
+    CURSE_OF_WEAKNESS_1             = 702,
+    DARK_PACT_1                     = 18220,
+    DEATH_COIL_WARLOCK_1            = 6789,
+    DEMON_ARMOR_1                   = 706,
+    DEMON_CHARGE_1                  = 54785,
+    DEMON_SKIN_1                    = 687,
+    DEMONIC_CIRCLE_SUMMON_1         = 48018,
+    DEMONIC_CIRCLE_TELEPORT_1       = 48020,
+    DEMONIC_EMPOWERMENT_1           = 47193,
+    DEMONIC_IMMOLATE_1              = 75445,
+    DETECT_INVISIBILITY_1           = 132,
+    DRAIN_LIFE_1                    = 689,
+    DRAIN_MANA_1                    = 5138,
+    DRAIN_SOUL_1                    = 1120,
+    ENSLAVE_DEMON_1                 = 1098,
+    EYE_OF_KILROGG_1                = 126,
+    FEAR_1                          = 5782,
+    FEL_ARMOR_1                     = 28176,
+    FEL_DOMINATION_1                = 18708,
+    HAUNT_1                         = 48181,
+    HEALTH_FUNNEL_1                 = 755,
+    HELLFIRE_1                      = 1949,
+    HOWL_OF_TERROR_1                = 5484,
+    IMMOLATE_1                      = 348,
+    IMMOLATION_AURA_1               = 50589,
+    INCINERATE_1                    = 29722,
+    INFERNO_1                       = 1122,
+    LIFE_TAP_1                      = 1454,
+    METAMORPHOSIS_1                 = 59672,
+    RAIN_OF_FIRE_1                  = 5740,
+    RITUAL_OF_DOOM_1                = 18540,
+    RITUAL_OF_SOULS_1               = 29893,
+    RITUAL_OF_SUMMONING_1           = 698,
+    SEARING_PAIN_1                  = 5676,
+    SEED_OF_CORRUPTION_1            = 27243,
+    SENSE_DEMONS_1                  = 5500,
+    SHADOW_BOLT_1                   = 686,
+    SHADOW_CLEAVE_1                 = 50581,
+    SHADOW_WARD_1                   = 6229,
+    SHADOWBURN_1                    = 17877,
+    SHADOWFLAME_1                   = 47897,
+    SHADOWFURY_1                    = 30283,
+    SOUL_FIRE_1                     = 6353,
+    SOUL_LINK_1                     = 19028,
+    SOULSHATTER_1                   = 29858,
+    SUMMON_FELGUARD_1               = 30146,
+    SUMMON_FELHUNTER_1              = 691,
+    SUMMON_IMP_1                    = 688,
+    SUMMON_SUCCUBUS_1               = 712,
+    SUMMON_VOIDWALKER_1             = 697,
+    UNENDING_BREATH_1               = 5697,
+    UNSTABLE_AFFLICTION_1           = 30108
+};
+
+//class Player;
+class PlayerbotWarlockAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarlockAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarlockAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+    // buff a specific player, usually a real PC who is not in group
+    //void BuffPlayer(Player *target);
+
+private:
+
+    // CURSES
+    uint32 CURSE_OF_WEAKNESS,
+           CURSE_OF_AGONY,
+           CURSE_OF_EXHAUSTION,
+           CURSE_OF_TONGUES,
+           CURSE_OF_THE_ELEMENTS,
+           CURSE_OF_DOOM;
+
+    // AFFLICTION
+    uint32 CORRUPTION,
+           DRAIN_SOUL,
+           DRAIN_LIFE,
+           DRAIN_MANA,
+           LIFE_TAP,
+           UNSTABLE_AFFLICTION,
+           HAUNT,
+           SEED_OF_CORRUPTION,
+           DARK_PACT,
+           HOWL_OF_TERROR,
+           FEAR;
+
+    // DESTRUCTION
+    uint32 SHADOW_BOLT,
+           IMMOLATE,
+           INCINERATE,
+           SEARING_PAIN,
+           CONFLAGRATE,
+           SOUL_FIRE,
+           SHADOWFURY,
+           CHAOS_BOLT,
+           SHADOWFLAME,
+           HELLFIRE,
+           RAIN_OF_FIRE,
+           SHADOWBURN;
+
+    // DEMONOLOGY
+    uint32 DEMON_SKIN,
+           DEMON_ARMOR,
+           DEMONIC_EMPOWERMENT,
+           SHADOW_WARD,
+           FEL_ARMOR,
+           SOULSHATTER,
+           SOUL_LINK,
+           SOUL_LINK_AURA,
+           HEALTH_FUNNEL,
+           DETECT_INVISIBILITY,
+           CREATE_FIRESTONE,
+           CREATE_SOULSTONE,
+           CREATE_HEALTHSTONE;
+
+    // DEMON SUMMON
+    uint32 SUMMON_IMP,
+           SUMMON_VOIDWALKER,
+           SUMMON_SUCCUBUS,
+           SUMMON_FELHUNTER,
+           SUMMON_FELGUARD;
+
+    // DEMON SKILLS
+    uint32 BLOOD_PACT,
+           FIREBOLT,
+           FIRE_SHIELD,
+           ANGUISH,
+           CLEAVE,
+           INTERCEPT,
+           DEVOUR_MAGIC,
+           FEL_INTELLIGENCE,
+           SHADOW_BITE,
+           SPELL_LOCK,
+           LASH_OF_PAIN,
+           SEDUCTION,
+           SOOTHING_KISS,
+           CONSUME_SHADOWS,
+           SACRIFICE,
+           SUFFERING,
+           TORMENT;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT,
+           GIFT_OF_THE_NAARU,
+           STONEFORM,
+           ESCAPE_ARTIST,
+           EVERY_MAN_FOR_HIMSELF,
+           SHADOWMELD,
+           BLOOD_FURY,
+           WAR_STOMP,
+           BERSERKING,
+           WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence,
+           LastSpellCurse,
+           LastSpellAffliction,
+           LastSpellDestruction;
+
+    uint32 m_lastDemon;      // Last demon entry used for spell initialization
+    uint32 m_demonOfChoice;  // Preferred demon entry
+    bool m_isTempImp;        // True if imp summoned temporarily until soul shard acquired for demon of choice.
+};
+
+#endif
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
new file mode 100644
index 0000000..5d72d15
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.cpp
@@ -0,0 +1,353 @@
+/*
+   Name    : PlayerbotWarriorAI.cpp
+   Complete: maybe around 37%
+   Author  : Natsukawa
+   Version : 0.39
+ */
+#include "PlayerbotWarriorAI.h"
+
+PlayerbotWarriorAI::PlayerbotWarriorAI(Player* const master, Player* const bot, PlayerbotAI* const ai) : PlayerbotClassAI(master, bot, ai)
+{
+    BATTLE_STANCE           = ai->initSpell(BATTLE_STANCE_1); //ARMS
+    CHARGE                  = ai->initSpell(CHARGE_1); //ARMS
+    OVERPOWER               = ai->initSpell(OVERPOWER_1); // ARMS
+    HEROIC_STRIKE           = ai->initSpell(HEROIC_STRIKE_1); //ARMS
+    REND                    = ai->initSpell(REND_1); //ARMS
+    THUNDER_CLAP            = ai->initSpell(THUNDER_CLAP_1);  //ARMS
+    HAMSTRING               = ai->initSpell(HAMSTRING_1);  //ARMS
+    MOCKING_BLOW            = ai->initSpell(MOCKING_BLOW_1);  //ARMS
+    RETALIATION             = ai->initSpell(RETALIATION_1);  //ARMS
+    SWEEPING_STRIKES        = ai->initSpell(SWEEPING_STRIKES_1); //ARMS
+    MORTAL_STRIKE           = ai->initSpell(MORTAL_STRIKE_1);  //ARMS
+    BLADESTORM              = ai->initSpell(BLADESTORM_1);  //ARMS
+    HEROIC_THROW            = ai->initSpell(HEROIC_THROW_1);  //ARMS
+    SHATTERING_THROW        = ai->initSpell(SHATTERING_THROW_1);  //ARMS
+    BLOODRAGE               = ai->initSpell(BLOODRAGE_1); //PROTECTION
+    DEFENSIVE_STANCE        = ai->initSpell(DEFENSIVE_STANCE_1); //PROTECTION
+    DEVASTATE               = ai->initSpell(DEVASTATE_1); //PROTECTION
+    SUNDER_ARMOR            = ai->initSpell(SUNDER_ARMOR_1); //PROTECTION
+    TAUNT                   = ai->initSpell(TAUNT_1); //PROTECTION
+    SHIELD_BASH             = ai->initSpell(SHIELD_BASH_1); //PROTECTION
+    REVENGE                 = ai->initSpell(REVENGE_1); //PROTECTION
+    SHIELD_BLOCK            = ai->initSpell(SHIELD_BLOCK_1); //PROTECTION
+    DISARM                  = ai->initSpell(DISARM_1); //PROTECTION
+    SHIELD_WALL             = ai->initSpell(SHIELD_WALL_1); //PROTECTION
+    SHIELD_SLAM             = ai->initSpell(SHIELD_SLAM_1); //PROTECTION
+    VIGILANCE               = ai->initSpell(VIGILANCE_1); //PROTECTION
+    DEVASTATE               = ai->initSpell(DEVASTATE_1); //PROTECTION
+    SHOCKWAVE               = ai->initSpell(SHOCKWAVE_1); //PROTECTION
+    CONCUSSION_BLOW         = ai->initSpell(CONCUSSION_BLOW_1); //PROTECTION
+    SPELL_REFLECTION        = ai->initSpell(SPELL_REFLECTION_1); //PROTECTION
+    LAST_STAND              = ai->initSpell(LAST_STAND_1); //PROTECTION
+    BATTLE_SHOUT            = ai->initSpell(BATTLE_SHOUT_1); //FURY
+    DEMORALIZING_SHOUT      = ai->initSpell(DEMORALIZING_SHOUT_1); //FURY
+    CLEAVE                  = ai->initSpell(CLEAVE_1); //FURY
+    INTIMIDATING_SHOUT      = ai->initSpell(INTIMIDATING_SHOUT_1); //FURY
+    EXECUTE                 = ai->initSpell(EXECUTE_1); //FURY
+    CHALLENGING_SHOUT       = ai->initSpell(CHALLENGING_SHOUT_1); //FURY
+    SLAM                    = ai->initSpell(SLAM_1); //FURY
+    BERSERKER_STANCE        = ai->initSpell(BERSERKER_STANCE_1); //FURY
+    INTERCEPT               = ai->initSpell(INTERCEPT_1); //FURY
+    DEATH_WISH              = ai->initSpell(DEATH_WISH_1); //FURY
+    BERSERKER_RAGE          = ai->initSpell(BERSERKER_RAGE_1); //FURY
+    WHIRLWIND               = ai->initSpell(WHIRLWIND_1); //FURY
+    PUMMEL                  = ai->initSpell(PUMMEL_1); //FURY
+    BLOODTHIRST             = ai->initSpell(BLOODTHIRST_1); //FURY
+    RECKLESSNESS            = ai->initSpell(RECKLESSNESS_1); //FURY
+    RAMPAGE                 = 0; // passive
+    HEROIC_FURY             = ai->initSpell(HEROIC_FURY_1); //FURY
+    COMMANDING_SHOUT        = ai->initSpell(COMMANDING_SHOUT_1); //FURY
+    ENRAGED_REGENERATION    = ai->initSpell(ENRAGED_REGENERATION_1); //FURY
+    PIERCING_HOWL           = ai->initSpell(PIERCING_HOWL_1); //FURY
+
+    RECENTLY_BANDAGED       = 11196; // first aid check
+
+    // racial
+    GIFT_OF_THE_NAARU       = ai->initSpell(GIFT_OF_THE_NAARU_WARRIOR); // draenei
+    STONEFORM               = ai->initSpell(STONEFORM_ALL); // dwarf
+    ESCAPE_ARTIST           = ai->initSpell(ESCAPE_ARTIST_ALL); // gnome
+    EVERY_MAN_FOR_HIMSELF   = ai->initSpell(EVERY_MAN_FOR_HIMSELF_ALL); // human
+    SHADOWMELD              = ai->initSpell(SHADOWMELD_ALL); // night elf
+    BLOOD_FURY              = ai->initSpell(BLOOD_FURY_MELEE_CLASSES); // orc
+    WAR_STOMP               = ai->initSpell(WAR_STOMP_ALL); // tauren
+    BERSERKING              = ai->initSpell(BERSERKING_ALL); // troll
+    WILL_OF_THE_FORSAKEN    = ai->initSpell(WILL_OF_THE_FORSAKEN_ALL); // undead
+}
+PlayerbotWarriorAI::~PlayerbotWarriorAI() {}
+
+bool PlayerbotWarriorAI::DoFirstCombatManeuver(Unit *pTarget)
+{
+    Player *m_bot = GetPlayerBot();
+    PlayerbotAI *ai = GetAI();
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+    float fTargetDist = GetCombatDistance(pTarget);
+
+    if ((co & PlayerbotAI::ORDERS_TANK) && DEFENSIVE_STANCE > 0 && !m_bot->HasAura(DEFENSIVE_STANCE, 0) && ai->CastSpell(DEFENSIVE_STANCE))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Defensive Stance (%d)", DEFENSIVE_STANCE);
+        return true;
+    }
+    else if ((co & PlayerbotAI::ORDERS_TANK) && TAUNT > 0 && m_bot->HasAura(DEFENSIVE_STANCE, 0) && ai->CastSpell(TAUNT, *pTarget))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Taunt (%d)", TAUNT);
+        return false;
+    }
+    else if (BATTLE_STANCE > 0 && !m_bot->HasAura(BATTLE_STANCE, 0) && ai->CastSpell(BATTLE_STANCE))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("First > Battle Stance (%d)", BATTLE_STANCE);
+        return true;
+    }
+    else if (BATTLE_STANCE > 0 && CHARGE > 0 && m_bot->HasAura(BATTLE_STANCE, 0))
+    {
+        if (fTargetDist < 8.0f)
+            return false;
+        else if (fTargetDist > 25.0f)
+            return true;
+        else if (CHARGE > 0 && ai->CastSpell(CHARGE, *pTarget))
+        {
+            float x, y, z;
+            pTarget->GetContactPoint(m_bot, x, y, z, 3.666666f);
+            m_bot->Relocate(x, y, z);
+
+            if (ai->m_confDebugWhisper)
+                ai->TellMaster("First > Charge (%d)", CHARGE);
+            return false;
+        }
+    }
+
+    return false;
+}
+
+void PlayerbotWarriorAI::DoNextCombatManeuver(Unit *pTarget)
+{
+    PlayerbotAI* ai = GetAI();
+    if (!ai)
+        return;
+
+    switch (ai->GetScenarioType())
+    {
+        case PlayerbotAI::SCENARIO_DUEL:
+            if (HEROIC_STRIKE > 0)
+                ai->CastSpell(HEROIC_STRIKE);
+            return;
+    }
+    // ------- Non Duel combat ----------
+
+    // Damage Attacks
+
+    Player *m_bot = GetPlayerBot();
+    Unit* pVictim = pTarget->getVictim();
+    float fTargetDist = GetCombatDistance(pTarget);
+    PlayerbotAI::CombatOrderType co = ai->GetCombatOrder();
+
+    // decide what stance to use
+    if ((co & PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(DEFENSIVE_STANCE, 0) && ai->CastSpell(DEFENSIVE_STANCE))
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Stance > Defensive");
+        else if (!(co & PlayerbotAI::ORDERS_TANK) && !m_bot->HasAura(BATTLE_STANCE, 0) && ai->CastSpell(BATTLE_STANCE))
+            if (ai->m_confDebugWhisper)
+                ai->TellMaster("Stance > Battle");
+
+    // get spell sequence
+    if (pTarget->IsNonMeleeSpellCasted(true))
+        SpellSequence = WarriorSpellPreventing;
+    else if (m_bot->HasAura(BATTLE_STANCE, 0))
+        SpellSequence = WarriorBattle;
+    else if (m_bot->HasAura(DEFENSIVE_STANCE, 0))
+        SpellSequence = WarriorDefensive;
+    else if (m_bot->HasAura(BERSERKER_STANCE, 0))
+        SpellSequence = WarriorBerserker;
+
+    // do shouts, berserker rage, etc...
+    if (BERSERKER_RAGE > 0 && !m_bot->HasAura(BERSERKER_RAGE, 0) && ai->CastSpell(BERSERKER_RAGE))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Pre > Berseker Rage");
+    }
+    else if (DEMORALIZING_SHOUT > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(DEMORALIZING_SHOUT, 0) && ai->CastSpell(DEMORALIZING_SHOUT))
+    {
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Pre > Demoralizing Shout");
+    }
+    else if (BATTLE_SHOUT > 0 && ai->GetRageAmount() >= 10 && !m_bot->HasAura(BATTLE_SHOUT, 0) && ai->CastSpell(BATTLE_SHOUT))
+        if (ai->m_confDebugWhisper)
+            ai->TellMaster("Pre > Battle Shout");
+
+    std::ostringstream out;
+    switch (SpellSequence)
+    {
+        case WarriorSpellPreventing:
+            out << "Case Prevent";
+            if (SHIELD_BASH > 0 && ai->GetRageAmount() >= 10 && ai->CastSpell(SHIELD_BASH, *pTarget))
+                out << " > Shield Bash";
+            else if (PUMMEL > 0 && ai->GetRageAmount() >= 10 && ai->CastSpell(PUMMEL, *pTarget))
+                out << " > Pummel";
+            else if (SPELL_REFLECTION > 0 && ai->GetRageAmount() >= 15 && !m_bot->HasAura(SPELL_REFLECTION, 0) && ai->CastSpell(SPELL_REFLECTION, *m_bot))
+                out << " > Spell Reflection";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBattle:
+            out << "Case Battle";
+            if (EXECUTE > 0 && ai->GetRageAmount() >= 15 && pTarget->GetHealth() < pTarget->GetMaxHealth() * 0.2 && ai->CastSpell(EXECUTE, *pTarget))
+                out << " > Execute!";
+            else if (LAST_STAND > 0 && !m_bot->HasAura(LAST_STAND, 0) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && ai->CastSpell(LAST_STAND, *m_bot))
+                out << " > Last Stand!";
+            else if (BLOODRAGE > 0 && ai->GetRageAmount() < 50 && !m_bot->HasAura(BLOODRAGE, 0) && ai->CastSpell(BLOODRAGE, *m_bot))
+                out << " > Bloodrage";
+            else if (DEATH_WISH > 0 && ai->GetRageAmount() >= 10 && !m_bot->HasAura(DEATH_WISH, 0) && ai->CastSpell(DEATH_WISH, *m_bot))
+                out << " > Death Wish";
+            else if (RETALIATION > 0 && pVictim == m_bot && ai->GetAttackerCount() >= 2 && !m_bot->HasAura(RETALIATION, 0) && ai->CastSpell(RETALIATION, *m_bot))
+                out << " > Retaliation";
+            else if (DEMORALIZING_SHOUT > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(DEMORALIZING_SHOUT, 0) && ai->CastSpell(DEMORALIZING_SHOUT, *pTarget))
+                out << " > Demoralizing Shout";
+            else if (SWEEPING_STRIKES > 0 && ai->GetRageAmount() >= 30 && ai->GetAttackerCount() >= 2 && !m_bot->HasAura(SWEEPING_STRIKES, 0) && ai->CastSpell(SWEEPING_STRIKES, *m_bot))
+                out << " > Sweeping Strikes!";
+            else if (BLADESTORM > 0 && ai->GetRageAmount() >= 25 && pVictim == m_bot && !m_bot->HasAura(BLADESTORM, 0) && ai->GetAttackerCount() >= 3 && ai->CastSpell(BLADESTORM, *pTarget))
+                out << " > Bladestorm!";
+            else if (MORTAL_STRIKE > 0 && ai->GetRageAmount() >= 30 && !pTarget->HasAura(MORTAL_STRIKE, 0) && ai->CastSpell(MORTAL_STRIKE, *pTarget))
+                out << " > Mortal Strike";
+            else if (INTIMIDATING_SHOUT > 0 && ai->GetRageAmount() >= 25 && ai->GetAttackerCount() > 5 && ai->CastSpell(INTIMIDATING_SHOUT, *pTarget))
+                out << " > Intimidating Shout";
+            else if (THUNDER_CLAP > 0 && ai->GetRageAmount() >= 20 && pVictim == m_bot && !pTarget->HasAura(THUNDER_CLAP, 0) && ai->CastSpell(THUNDER_CLAP, *pTarget))
+                out << " > Thunder Clap";
+            else if (ENRAGED_REGENERATION > 0 && ai->GetRageAmount() >= 15 && !m_bot->HasAura(BERSERKER_RAGE, 0) && !m_bot->HasAura(ENRAGED_REGENERATION, 0) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.5 && ai->CastSpell(ENRAGED_REGENERATION, *m_bot))
+                out << " > Enraged Regeneration";
+            else if (SHOCKWAVE > 0 && ai->GetRageAmount() >= 15 && pVictim == m_bot && !pTarget->HasAura(WAR_STOMP, 0) && !pTarget->HasAura(PIERCING_HOWL, 0) && !pTarget->HasAura(SHOCKWAVE, 0) && !pTarget->HasAura(CONCUSSION_BLOW, 0) && ai->CastSpell(SHOCKWAVE, *pTarget))
+                out << " > Shockwave";
+            else if (REND > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(REND, 0) && ai->CastSpell(REND, *pTarget))
+                out << " > Rend";
+            else if (HAMSTRING > 0 && ai->GetRageAmount() >= 10 && !pTarget->HasAura(HAMSTRING, 0) && ai->CastSpell(HAMSTRING, *pTarget))
+                out << " > Hamstring";
+            else if (CHALLENGING_SHOUT > 0 && ai->GetRageAmount() >= 5 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, 0) && !pTarget->HasAura(CHALLENGING_SHOUT, 0) && ai->CastSpell(CHALLENGING_SHOUT, *pTarget))
+                out << " > Challenging Shout";
+            else if (BLOODTHIRST > 0 && ai->GetRageAmount() >= 20 && !m_bot->HasAura(BLOODTHIRST, 0) && m_bot->GetHealth() < m_bot->GetMaxHealth() * 0.7 && ai->CastSpell(BLOODTHIRST, *pTarget))
+                out << " > Bloodthrist";
+            else if (CLEAVE > 0 && ai->GetRageAmount() >= 20 && ai->CastSpell(CLEAVE, *pTarget))
+                out << " > Cleave";
+            else if (HEROIC_STRIKE > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(HEROIC_STRIKE, *pTarget))
+                out << " > Heroic Strike";
+            else if (CONCUSSION_BLOW > 0 && ai->GetRageAmount() >= 15 && !pTarget->HasAura(WAR_STOMP, 0) && !pTarget->HasAura(PIERCING_HOWL, 0) && !pTarget->HasAura(SHOCKWAVE, 0) && !pTarget->HasAura(CONCUSSION_BLOW, 0) && ai->CastSpell(CONCUSSION_BLOW, *pTarget))
+                out << " > Concussion Blow";
+            else if (SLAM > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(SLAM, *pTarget))
+                out << " > Slam";
+            else if (PIERCING_HOWL > 0 && ai->GetRageAmount() >= 10 && ai->GetAttackerCount() >= 3 && !pTarget->HasAura(WAR_STOMP, 0) && !pTarget->HasAura(PIERCING_HOWL, 0) && !pTarget->HasAura(SHOCKWAVE, 0) && !pTarget->HasAura(CONCUSSION_BLOW, 0) && ai->CastSpell(PIERCING_HOWL, *pTarget))
+                out << " > Piercing Howl";
+            else if (MOCKING_BLOW > 0 && ai->GetRageAmount() >= 10 && pVictim != m_bot && ai->GetHealthPercent() > 25 && !pTarget->HasAura(MOCKING_BLOW, 0) && !pTarget->HasAura(CHALLENGING_SHOUT, 0) && ai->CastSpell(MOCKING_BLOW, *pTarget))
+                out << " > Mocking Blow";
+            else if (OVERPOWER > 0 && ai->GetRageAmount() >= 5 && ai->CastSpell(OVERPOWER, *pTarget))
+                out << " > Overpower";
+            else if (SUNDER_ARMOR > 0 && ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                out << " > Sunder Armor";
+            else if (SHATTERING_THROW > 0 && !pTarget->HasAura(SHATTERING_THROW, 0) && ai->CastSpell(SHATTERING_THROW, *pTarget))
+                out << " > Shattering Throw";
+            else if (HEROIC_THROW > 0 && ai->CastSpell(HEROIC_THROW, *pTarget))
+                out << " > Heroic Throw";
+            else if (m_bot->getRace() == RACE_TAUREN && !pTarget->HasAura(WAR_STOMP, 0) && !pTarget->HasAura(PIERCING_HOWL, 0) && !pTarget->HasAura(SHOCKWAVE, 0) && !pTarget->HasAura(CONCUSSION_BLOW, 0) && ai->CastSpell(WAR_STOMP, *pTarget))
+                out << " > War Stomp";
+            else if (m_bot->getRace() == RACE_HUMAN && m_bot->HasUnitState(UNIT_STATE_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(EVERY_MAN_FOR_HIMSELF, *m_bot))
+                out << " > Every Man for Himself";
+            else if (m_bot->getRace() == RACE_UNDEAD_PLAYER && m_bot->HasAuraType(SPELL_AURA_MOD_FEAR) || m_bot->HasAuraType(SPELL_AURA_MOD_CHARM) && ai->CastSpell(WILL_OF_THE_FORSAKEN, *m_bot))
+                out << " > Will of the Forsaken";
+            else if (m_bot->getRace() == RACE_DWARF && m_bot->HasAuraState(AURA_STATE_DEADLY_POISON) && ai->CastSpell(STONEFORM, *m_bot))
+                out << " > Stoneform";
+            else if (m_bot->getRace() == RACE_GNOME && m_bot->HasUnitState(UNIT_STATE_STUNNED) || m_bot->HasAuraType(SPELL_AURA_MOD_DECREASE_SPEED) && ai->CastSpell(ESCAPE_ARTIST, *m_bot))
+                out << " > Escape Artist";
+            else if (m_bot->getRace() == RACE_NIGHTELF && pVictim == m_bot && ai->GetHealthPercent() < 25 && !m_bot->HasAura(SHADOWMELD, 0) && ai->CastSpell(SHADOWMELD, *m_bot))
+                out << " > Shadowmeld";
+            else if (m_bot->getRace() == RACE_ORC && !m_bot->HasAura(BLOOD_FURY, 0) && ai->CastSpell(BLOOD_FURY, *m_bot))
+                out << " > Blood Fury";
+            else if (m_bot->getRace() == RACE_TROLL && !m_bot->HasAura(BERSERKING, 0) && ai->CastSpell(BERSERKING, *m_bot))
+                out << " > Berserking";
+            else if (m_bot->getRace() == RACE_DRAENEI && ai->GetHealthPercent() < 25 && !m_bot->HasAura(GIFT_OF_THE_NAARU, 0) && ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot))
+                out << " > Gift of the Naaru";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorDefensive:
+            out << "Case Defensive";
+            if (DISARM > 0 && ai->GetRageAmount() >= 15 && !pTarget->HasAura(DISARM, 0) && ai->CastSpell(DISARM, *pTarget))
+                out << " > Disarm";
+            else if (SUNDER_ARMOR > 0 && ai->GetRageAmount() >= 15 && ai->CastSpell(SUNDER_ARMOR, *pTarget))
+                out << " > Sunder Armor";
+            else if (REVENGE > 0 && ai->GetRageAmount() >= 5 && ai->CastSpell(REVENGE, *pTarget))
+                out << " > Revenge";
+            else if (SHIELD_BLOCK > 0 && !m_bot->HasAura(SHIELD_BLOCK, 0) && ai->CastSpell(SHIELD_BLOCK, *m_bot))
+                out << " > Shield Block";
+            else if (SHIELD_WALL > 0 && !m_bot->HasAura(SHIELD_WALL, 0) && ai->CastSpell(SHIELD_WALL, *m_bot))
+                out << " > Shield Wall";
+            else
+                out << " > NONE";
+            break;
+
+        case WarriorBerserker:
+            out << "Case Berserker";
+            if (WHIRLWIND > 0 && ai->GetRageAmount() >= 25 && ai->CastSpell(WHIRLWIND, *pTarget))
+                out << " > Whirlwind";
+            out << " > NONE";
+            break;
+    }
+    if (ai->m_confDebugWhisper)
+        ai->TellMaster(out.str().c_str());
+}
+
+void PlayerbotWarriorAI::DoNonCombatActions()
+{
+    PlayerbotAI *ai = GetAI();
+    Player * m_bot = GetPlayerBot();
+    if (!m_bot)
+        return;
+
+    // TODO (by Runsttren): check if shout aura bot has is casted by this bot,
+    // otherwise cast other useful shout
+    // If the bot is protect talented, she/he needs stamina not attack power.
+    // With stance change can the shout change to.
+    // Inserted line to battle shout m_bot->HasAura( COMMANDING_SHOUT, 0)
+    // Natsukawa
+    if (((COMMANDING_SHOUT > 0 && !m_bot->HasAura(COMMANDING_SHOUT, 0)) ||
+         (BATTLE_SHOUT > 0 && !m_bot->HasAura(BATTLE_SHOUT, 0))) &&
+        ai->GetRageAmount() < 10 && BLOODRAGE > 0 && !m_bot->HasAura(BLOODRAGE, 0))
+        // we do have a useful shout, no rage coming but can cast bloodrage... do it
+        ai->CastSpell(BLOODRAGE, *m_bot);
+    else if (COMMANDING_SHOUT > 0 && !m_bot->HasAura(COMMANDING_SHOUT, 0))
+        // use commanding shout now
+        ai->CastSpell(COMMANDING_SHOUT, *m_bot);
+    else if (BATTLE_SHOUT > 0 && !m_bot->HasAura(BATTLE_SHOUT, 0) && !m_bot->HasAura(COMMANDING_SHOUT, 0))
+        // use battle shout
+        ai->CastSpell(BATTLE_SHOUT, *m_bot);
+
+    // buff master with VIGILANCE
+    if (VIGILANCE > 0)
+        (!GetMaster()->HasAura(VIGILANCE, 0) && ai->CastSpell(VIGILANCE, *GetMaster()));
+
+    // hp check
+    if (m_bot->getStandState() != UNIT_STAND_STATE_STAND)
+        m_bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Item* pItem = ai->FindFood();
+    Item* fItem = ai->FindBandage();
+
+    if (pItem != NULL && ai->GetHealthPercent() < 30)
+    {
+        ai->TellMaster("I could use some food.");
+        ai->UseItem(pItem);
+        return;
+    }
+    else if (pItem == NULL && fItem != NULL && !m_bot->HasAura(RECENTLY_BANDAGED, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I could use first aid.");
+        ai->UseItem(fItem);
+        return;
+    }
+    else if (pItem == NULL && fItem == NULL && m_bot->getRace() == RACE_DRAENEI && !m_bot->HasAura(GIFT_OF_THE_NAARU, 0) && ai->GetHealthPercent() < 70)
+    {
+        ai->TellMaster("I'm casting gift of the naaru.");
+        ai->CastSpell(GIFT_OF_THE_NAARU, *m_bot);
+        return;
+    }
+} // end DoNonCombatActions
diff --git a/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
new file mode 100644
index 0000000..5c003d7
--- /dev/null
+++ b/src/server/game/AI/PlayerBots/PlayerbotWarriorAI.h
@@ -0,0 +1,103 @@
+#ifndef _PlayerbotWarriorAI_H
+#define _PlayerbotWarriorAI_H
+
+#include "PlayerbotAI.h"
+
+enum
+{
+    WarriorSpellPreventing,
+    WarriorBattle,
+    WarriorDefensive,
+    WarriorBerserker
+};
+
+enum WarriorSpells
+{
+    BATTLE_SHOUT_1                  = 6673,
+    BATTLE_STANCE_1                 = 2457,
+    BERSERKER_RAGE_1                = 18499,
+    BERSERKER_STANCE_1              = 2458,
+    BLADESTORM_1                    = 46924,
+    BLOODRAGE_1                     = 2687,
+    BLOODTHIRST_1                   = 23881,
+    CHALLENGING_SHOUT_1             = 1161,
+    CHARGE_1                        = 100,
+    CLEAVE_1                        = 845,
+    COMMANDING_SHOUT_1              = 469,
+    CONCUSSION_BLOW_1               = 12809,
+    DEATH_WISH_1                    = 12292,
+    DEFENSIVE_STANCE_1              = 71,
+    DEMORALIZING_SHOUT_1            = 1160,
+    DEVASTATE_1                     = 20243,
+    DISARM_1                        = 676,
+    ENRAGED_REGENERATION_1          = 55694,
+    EXECUTE_1                       = 5308,
+    HAMSTRING_1                     = 1715,
+    HEROIC_FURY_1                   = 60970,
+    HEROIC_STRIKE_1                 = 78,
+    HEROIC_THROW_1                  = 57755,
+    INTERCEPT_1                     = 20252,
+    INTERVENE_1                     = 3411,
+    INTIMIDATING_SHOUT_1            = 5246,
+    LAST_STAND_1                    = 12975,
+    MOCKING_BLOW_1                  = 694,
+    MORTAL_STRIKE_1                 = 12294,
+    OVERPOWER_1                     = 7384,
+    PIERCING_HOWL_1                 = 12323,
+    PUMMEL_1                        = 6552,
+    RECKLESSNESS_1                  = 1719,
+    REND_1                          = 772,
+    RETALIATION_1                   = 20230,
+    REVENGE_1                       = 6572,
+    SHATTERING_THROW_1              = 64382,
+    SHIELD_BASH_1                   = 72,
+    SHIELD_BLOCK_1                  = 2565,
+    SHIELD_SLAM_1                   = 23922,
+    SHIELD_WALL_1                   = 871,
+    SHOCKWAVE_1                     = 46968,
+    SLAM_1                          = 1464,
+    SPELL_REFLECTION_1              = 23920,
+    SUNDER_ARMOR_1                  = 7386,
+    SWEEPING_STRIKES_1              = 12328,
+    TAUNT_1                         = 355,
+    THUNDER_CLAP_1                  = 6343,
+    VICTORY_RUSH_1                  = 34428,
+    VIGILANCE_1                     = 50720,
+    WHIRLWIND_1                     = 1680
+};
+
+//class Player;
+
+class PlayerbotWarriorAI : PlayerbotClassAI
+{
+public:
+    PlayerbotWarriorAI(Player * const master, Player * const bot, PlayerbotAI * const ai);
+    virtual ~PlayerbotWarriorAI();
+
+    // all combat actions go here
+    bool DoFirstCombatManeuver(Unit*);
+    void DoNextCombatManeuver(Unit*);
+
+    // all non combat actions go here, ex buffs, heals, rezzes
+    void DoNonCombatActions();
+
+private:
+    // ARMS
+    uint32 BATTLE_STANCE, CHARGE, HEROIC_STRIKE, REND, THUNDER_CLAP, HAMSTRING, MOCKING_BLOW, RETALIATION, SWEEPING_STRIKES, MORTAL_STRIKE, BLADESTORM, HEROIC_THROW, SHATTERING_THROW;
+
+    // PROTECTION
+    uint32 DEFENSIVE_STANCE, BLOODRAGE, SUNDER_ARMOR, TAUNT, SHIELD_BASH, REVENGE, SHIELD_BLOCK, DISARM, SHIELD_WALL, SHIELD_SLAM, VIGILANCE, DEVASTATE, SHOCKWAVE, CONCUSSION_BLOW, SPELL_REFLECTION, LAST_STAND;
+
+    // FURY
+    uint32 BERSERKER_STANCE, BATTLE_SHOUT, DEMORALIZING_SHOUT, OVERPOWER, CLEAVE, INTIMIDATING_SHOUT, EXECUTE, CHALLENGING_SHOUT, SLAM, INTERCEPT, DEATH_WISH, BERSERKER_RAGE, WHIRLWIND, PUMMEL, BLOODTHIRST, RECKLESSNESS, RAMPAGE, HEROIC_FURY, COMMANDING_SHOUT, ENRAGED_REGENERATION, PIERCING_HOWL;
+
+    // first aid
+    uint32 RECENTLY_BANDAGED;
+
+    // racial
+    uint32 ARCANE_TORRENT, GIFT_OF_THE_NAARU, STONEFORM, ESCAPE_ARTIST, EVERY_MAN_FOR_HIMSELF, SHADOWMELD, BLOOD_FURY, WAR_STOMP, BERSERKING, WILL_OF_THE_FORSAKEN;
+
+    uint32 SpellSequence;
+};
+
+#endif
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index a83e77e..474160e 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -131,6 +131,8 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/PlayerBots
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/EventAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 866437d..69ec1fd 100755
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -52,6 +52,9 @@
 #include "MoveSpline.h"
 // apply implementation of the singletons
 
+// npcbot
+#include "bot_ai.h"
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -163,6 +166,13 @@ m_creatureInfo(NULL), m_creatureData(NULL), m_path_id(0), m_formation(NULL)
     ResetLootMode(); // restore default loot mode
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
+    //bot
+    is_a_bot = false;
+    m_TankGuid = 0;
+    m_bot_owner = NULL;
+    m_bot_class = 0;
+    m_botsPet = NULL;
+    m_bot_must_die = false;
 }
 
 Creature::~Creature()
@@ -233,6 +243,8 @@ void Creature::RemoveCorpse(bool setSpawnTime)
 {
     if (getDeathState() != CORPSE)
         return;
+    if (is_a_bot)
+        return;
 
     m_corpseRemoveTime = time(NULL);
     setDeathState(DEAD);
@@ -2503,3 +2515,122 @@ bool Creature::SetHover(bool enable)
     SendMessageToSet(&data, false);
     return true;
 }
+
+Creature *Creature::GetBotsPet(uint32 entry)
+{
+    //TODO: add few new pets and //implement stat system //move into script
+    Creature *pet = m_bot_owner->SummonCreature(entry, *m_bot_owner);
+
+    QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi FROM pet_levelstats WHERE creature_entry = 1860 AND level=%u", m_bot_owner->getLevel() > 80 ? 80 : m_bot_owner->getLevel());
+
+    if (result)
+    {
+        Field *fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt32();
+        uint32 mana = fields[1].GetUInt32();
+        uint32 armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt32();
+        uint32 agi = fields[4].GetUInt32();
+
+        pet->SetMaxHealth(hp);
+        pet->SetMaxPower(POWER_MANA, mana);
+        pet->SetArmor(armor);
+        pet->SetStat(STAT_STRENGTH, str);
+        pet->SetStat(STAT_AGILITY, agi);
+
+        //delete result;
+    }
+    pet->SetCharmerGUID(m_bot_owner->GetGUID());
+    m_bot_owner->SetMinion((Minion*)pet, true);
+    pet->SetLevel(getLevel());
+    pet->AIM_Initialize();
+    pet->SetReactState(REACT_DEFENSIVE);
+    pet->setFaction(m_bot_owner->getFaction());
+    pet->GetMotionMaster()->MoveFollow(this, PET_FOLLOW_DIST*urand(1, 2),PET_FOLLOW_ANGLE);
+    pet->SetFullHealth();
+    if (pet->getPowerType() == POWER_MANA)
+        pet->SetPower(POWER_MANA, pet->GetMaxPower(POWER_MANA));
+
+    m_botsPet = pet;
+
+    return pet;
+} //end GetBotsPet
+
+void Creature::SetBotsPetDied()
+{
+    if (m_botsPet != NULL && m_botsPet->IsInWorld())
+    {
+        m_botsPet->SetCharmerGUID(0);
+        m_botsPet->CombatStop();
+        m_bot_owner->SetMinion((Minion*)m_botsPet, false);
+        m_botsPet->CleanupsBeforeDelete();
+        m_botsPet->AddObjectToRemoveList();
+    }
+    m_botsPet = NULL;
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    if (!bot)
+    {
+        m_bot_owner = NULL;
+        m_TankGuid = 0;
+        m_botsPet = NULL;
+        if (bot_AI)
+            bot_AI = NULL;
+        SetUInt64Value(UNIT_FIELD_CREATEDBY, NULL);
+    }
+    is_a_bot = bot;
+    m_bot_must_die = false;
+}
+
+void Creature::SetBotTank(Unit *newtank)
+{
+    if (newtank && newtank->GetGUID() == m_TankGuid) return;
+    if (Unit *oldtank = m_TankGuid ? sObjectAccessor->FindUnit(m_TankGuid) : NULL)
+        if (oldtank->IsInWorld() && oldtank->ToCreature() && oldtank->HasAura(7376))//bots only
+            oldtank->RemoveAurasDueToSpell(7376);//defensivestancepassive
+    if (newtank == this)
+    {
+        for (uint8 i = 0; i < 3; ++i)
+            AddAura(7376, this);
+        if (Player *owner = !m_bot_owner->GetPlayerbotAI() ? m_bot_owner : m_bot_owner->GetSession()->m_master)
+        {
+            switch (rand()%5)
+            {
+            case 1: MonsterWhisper("I am tank here!", owner->GetGUID()); break;
+            case 2: MonsterWhisper("I will tank now.", owner->GetGUID()); break;
+            case 3: MonsterWhisper("I gonna tank", owner->GetGUID()); break;
+            case 4: MonsterWhisper("I think I will be best tank here...", owner->GetGUID()); break;
+            case 5: MonsterWhisper("I AM the tank!", owner->GetGUID()); break;
+            }
+        }
+        bot_AI->UpdateHealth();
+        SetBotCommandState(COMMAND_FOLLOW, !isInCombat());
+    }
+    m_TankGuid = newtank ? newtank->GetGUID() : 0;
+    if (m_TankGuid == 0)
+        bot_AI->SetBotTank(NULL);
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI)
+        bot_AI->SetBotCommandState(st, force);
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32 &damage) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage);
+}
+void Creature::ApplyBotDamageMultiplierMelee(int32 &damage) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage);
+}
+void Creature::ApplyBotDamageMultiplierSpell(int32 &damage) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage);
+}
\ No newline at end of file
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index c8ebf1a..b84e7ac 100755
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,9 @@ class Player;
 class WorldSession;
 class CreatureGroup;
 
+// npcbot
+class bot_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND   = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -719,6 +722,26 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
 
         bool m_isTempWorldObject; //true when possessed
 
+        //Bot commands
+        void SetOwner(Player *newowner) { m_bot_owner = newowner; }
+        Player *GetBotOwner() const { return m_bot_owner; }
+        Creature *GetBotsPet(uint32 entry);
+        Creature *getBotsPet() const { return m_botsPet; }
+        void SetBotsPetDied();
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const { return is_a_bot; }
+        void SetBotClass(uint8 myclass) { m_bot_class = myclass; }
+        uint8 GetBotClass() const { return m_bot_class; }
+        void SetBotTank(Unit* newtank);
+        uint64 GetBotTankGuid() const { return m_TankGuid; }
+        bot_ai *GetBotAI() const { return bot_AI; }
+        void SetBotAI(CreatureAI *ai) { bot_AI = (bot_ai*)ai; }
+        void SetBotCommandState(CommandStates st, bool force = false);
+        void ApplyBotDamageMultiplierMelee(uint32 &damage) const;
+        void ApplyBotDamageMultiplierMelee(int32 &damage) const;
+        void ApplyBotDamageMultiplierSpell(int32 &damage) const;
+        //Bot commands
+
     protected:
         bool CreateFromProto(uint32 guidlow, uint32 Entry, uint32 vehId, uint32 team, const CreatureData* data = NULL);
         bool InitEntry(uint32 entry, uint32 team=ALLIANCE, const CreatureData* data=NULL);
@@ -768,6 +791,16 @@ class Creature : public Unit, public GridObject<Creature>, public MapCreature
         bool IsInvisibleDueToDespawn() const;
         bool CanAlwaysSee(WorldObject const* obj) const;
     private:
+        //bot system
+        bot_ai *bot_AI;
+        bool is_a_bot;
+        Player *m_bot_owner;
+        Creature *m_botsPet;
+        uint64 m_TankGuid;
+        bool m_bot_must_die;
+        uint8 m_bot_class;
+        //bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
 
         //WaypointMovementGenerator vars
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 43b29c6..98ba8c3 100755
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -246,6 +246,13 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+//npcbot
+    if (GetIAmABot())
+    {
+        //sLog->outError("TempSummon::UnSummon(): Trying to unsummon Bot %s(owner: %s). Aborted", GetName(), GetBotOwner()->GetName());
+        return;
+    }
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 2fd80b7..25e9741 100755
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -75,6 +75,10 @@
 #include <cmath>
 #include "AccountMgr.h"
 
+// Playerbot mod
+#include "PlayerbotAI.h"
+#include "Config.h"
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -519,6 +523,21 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPctN(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1 Apply NpcBotReductionRate
+        if (player->HaveBot() && player->GetNpcBotsCount() > 1)
+        {
+            uint32 XPRate = ConfigMgr::GetIntDefault("Bot.XpReductionPercent", 0);
+            if (XPRate > 100) XPRate = 100;
+            if (XPRate)
+            {
+                int32 ratePct = 100 - (player->GetNpcBotsCount() - 1) * XPRate;
+                if (ratePct < 10) ratePct = 10;//minimum
+                if (ratePct > 100) ratePct = 100;//maximum
+                if (ratePct <= 100)
+                    xp = xp * ratePct / 100;
+            }
+        }
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -850,6 +869,17 @@ Player::Player(WorldSession* session): Unit(true), m_achievementMgr(this), m_rep
 
     m_ChampioningFaction = 0;
 
+    ///////////////////// Bot System ////////////////////////
+    //Playerbot mod
+    m_playerbotAI = NULL;
+    //npcbot
+    m_botTimer = 500;
+    m_bot = NULL;
+    m_botTankGuid = 0;
+    m_followdist = ConfigMgr::GetIntDefault("Bot.BaseFollowDistance", 30);
+    m_MaxClassNpcBots = ConfigMgr::GetIntDefault("Bot.MaxNpcBotsPerClass", 1) > 0 ? ConfigMgr::GetIntDefault("Bot.MaxNpcBotsPerClass", 1) : MAX_NPCBOTS;
+    ///////////////////// End Bot System ////////////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -896,6 +926,13 @@ Player::~Player()
     delete m_declinedname;
     delete m_runes;
 
+    //Playerbot mod: remove AI if exists
+    if (m_playerbotAI != NULL)
+    {
+        delete m_playerbotAI;
+        m_playerbotAI = NULL;
+    }
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1809,6 +1846,20 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && isAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    //Playerbot mod: UpdateAI
+    if (m_playerbotAI != NULL)
+        m_playerbotAI->UpdateAI(p_time);
+    //NpcBot mod: Update
+    if (m_botTimer > 0)
+    {
+        if (p_time >= m_botTimer)
+            m_botTimer = 0;
+        else
+            m_botTimer -= p_time;
+    }
+    else
+        RefreshBot(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -2078,6 +2129,18 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
         return false;
     }
 
+    // Playerbot mod: if this user has bots, tell them to stop following master
+    // so they don't try to follow the master after the master teleports
+    for (PlayerBotMap::const_iterator itr = GetSession()->GetPlayerBotsBegin(); itr != GetSession()->GetPlayerBotsEnd(); ++itr)
+        if (Player *botPlayer = itr->second)
+            botPlayer->GetMotionMaster()->Clear();
+    //Npcbot mod: prevent crash on InstanceMap::DestroyInstance()... Unit::RemoveFromWorld()
+    //if last player being kicked out of instance while having npcbots
+    //we must remove creature Before it will be removed in Map::UnloadAll()
+    if (GetMapId() != mapid)
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            RemoveBot(m_botmap[i].m_guid);
+
     // preparing unsummon pet if lost (we must get pet before teleportation or will not find it later)
     Pet* pet = GetPet();
 
@@ -2432,6 +2495,550 @@ void Player::RemoveFromWorld()
     }
 }
 
+void Player::RefreshBot(uint32 diff)
+{
+    if (m_botTimer > 0) return;
+    if (!HaveBot()) return;
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        uint64 guid = m_botmap[i].m_guid;
+        m_bot = m_botmap[i].m_creature;
+        if (!m_bot && guid != 0)
+            m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+        if (!m_bot || !m_bot->IsInWorld())
+            continue;
+        //BOT REVIVE SUPPORT
+        if (m_botmap[i].m_reviveTimer > diff)
+        {
+            if (!isInCombat())
+                m_botmap[i].m_reviveTimer -= diff;
+        }
+        else if (m_botmap[i].m_reviveTimer > 0)
+            m_botmap[i].m_reviveTimer = 0;
+        if ((m_bot->isDead() || !m_bot->isAlive()) && isAlive() && !isInCombat() && !InArena() && !isInFlight() && 
+            !HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) && 
+            m_botmap[i].m_reviveTimer == 0 && 
+            !HasInvisibilityAura() && !HasStealthAura())
+        {
+            CreateBot(0, 0, 0, false, true);//revive
+            continue;
+        }
+        //BOT MUST DIE SUPPORT
+        if (isInFlight() || !GetGroup() || !GetGroup()->IsMember(m_bot->GetGUID()))//even if bot is dead
+        {
+            RemoveBot(guid, !isInFlight());
+            continue;
+        }
+        //TELEPORT/OUTRUN SUPPORT
+        if (!isInFlight() && isAlive() && m_bot->isAlive()/* && !HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST)*/)
+        {
+            float maxdist = sWorld->GetMaxVisibleDistanceOnContinents();
+            if (GetMap()->IsDungeon())
+                maxdist = sWorld->GetMaxVisibleDistanceInInstances();
+            else if (GetMap()->IsBattlegroundOrArena())
+                maxdist = sWorld->GetMaxVisibleDistanceInBGArenas();
+            maxdist += 20.0f; //allow player to recall it by moving back
+            if (abs(m_bot->GetPositionX() - GetPositionX()) > maxdist || 
+                abs(m_bot->GetPositionY() - GetPositionY()) > maxdist || 
+                m_bot->GetMapId() != GetMapId())
+            //bot is too far away
+            {
+                RemoveBot(guid);
+                continue;
+            }
+        }
+        m_bot = NULL;
+    }//end for botmap
+    m_botTimer = 100 + isInFlight()*3000;//x2 ms //temp hack
+    //BOT CREATION/RECREATION SUPPORT
+    if (!isInFlight() && isAlive() && GetBotMustBeCreated())
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos].m_entry != 0 && m_botmap[pos].m_guid == 0)
+                CreateBot(m_botmap[pos].m_entry, m_botmap[pos].m_race, m_botmap[pos].m_class, m_botmap[pos].tank);
+}
+
+void Player::SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, bool istank)
+{
+    if (ConfigMgr::GetBoolDefault("Bot.EnableNpcBots", true) == false)
+    {
+        ChatHandler ch(this);
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact your administration.");
+        ClearBotMustBeCreated(0, 0, true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos].m_entry == 0)
+        {
+            m_botmap[pos].m_guid = 0;//we need it to make sure Player::CreateBot will find this slot
+            m_botmap[pos].m_entry = m_entry;
+            m_botmap[pos].m_race = m_race;
+            m_botmap[pos].m_class = m_class;
+            m_botmap[pos].tank = istank;
+            break;
+        }
+    }
+}
+
+bool Player::GetBotMustBeCreated()
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos].m_entry != 0 && 
+            (m_botmap[pos].m_guid == 0 || !sObjectAccessor->FindUnit(m_botmap[pos].m_guid)))
+        {
+            m_botmap[pos].m_guid = 0;
+            return true;
+        }
+    }
+    return false;
+}
+
+void Player::ClearBotMustBeCreated(uint64 guidOrSlot, bool guid, bool fully)
+{
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if ((guid == true && m_botmap[pos].m_guid == guidOrSlot) || 
+            (guid == false && pos == guidOrSlot) || 
+            fully)
+        {
+            m_botmap[pos].m_guid = 0;
+            m_botmap[pos].m_entry = 0;
+            m_botmap[pos].m_race = 0;
+            m_botmap[pos].m_class = 0;
+            m_botmap[pos].m_creature = NULL;
+            m_botmap[pos].tank = false;
+            if (!fully)
+                break;
+        }
+    }
+}
+
+void Player::RemoveBot(uint64 guid, bool final, bool eraseFromDB)
+{
+    if (guid == 0) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_guid == guid)
+            m_bot = m_botmap[i].m_creature;
+    if (!m_bot)
+        m_bot = sObjectAccessor->GetObjectInWorld(guid, (Creature*)NULL);
+    if (m_bot)
+    {
+        if (m_bot->getBotsPet())
+            m_bot->SetBotsPetDied();
+
+        //do not disband group unless not in dungeon or forced or on logout (Check WorldSession::LogoutPlayer())
+        Group *gr = GetGroup();
+        if (gr && gr->IsMember(guid))
+        {
+            if (gr->GetMembersCount() > 2 || /*!GetMap()->Instanceable() || */(final && eraseFromDB))
+                gr->RemoveMember(guid);
+            else //just cleanup
+            {
+                PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_GROUP_MEMBER);
+                stmt->setUInt32(0, GUID_LOPART(guid));
+                CharacterDatabase.Execute(stmt);
+            }
+        }
+
+        m_bot->SetCharmerGUID(0);
+        m_bot->SetBotAI(NULL);
+        SetMinion((Minion*)m_bot, false);
+
+        m_bot->CleanupsBeforeDelete();
+        m_bot->SetIAmABot(false); //this HAS to come after CleanupsBeforeDelete
+        m_bot->AddObjectToRemoveList();
+
+        if (final)//on logout or by command
+        {
+            ClearBotMustBeCreated(guid);
+            if (eraseFromDB)//by command
+                CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_bot->GetEntry());
+        }
+        else
+        {
+            for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            {
+                if (m_botmap[pos].m_guid == guid)
+                {
+                    m_botmap[pos].m_guid = 0;//reset guid so it can be set during recreation
+                    m_botmap[pos].m_creature = NULL;
+                }
+            }
+        }
+        m_bot = NULL;
+    }
+} //end RemoveBot
+
+void Player::CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool istank, bool revive)
+{
+    if (IsBeingTeleported() || isInFlight()) return; //don't create bot yet
+    if (isDead() && !revive) return; //not to revive by command so abort
+    if (isInCombat()) return;
+
+    if (m_bot != NULL && revive)
+    {
+        m_bot->SetHealth(uint32(float(m_bot->GetCreateHealth()) * 0.15f));//15% of base health
+        if (m_bot->getPowerType() == POWER_MANA)
+            m_bot->SetPower(POWER_MANA, m_bot->GetCreateMana());
+        m_bot->setDeathState(ALIVE);
+        m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        return;
+    }
+    if (ConfigMgr::GetBoolDefault("Bot.EnableNpcBots", true) == false && revive == false)
+    {
+        ChatHandler ch(this);
+        ch.SendSysMessage("NpcBot system currently disabled. Please contact administration.");
+        return;
+    }
+    if (!botentry || !botrace || !botclass)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "ERROR! CreateBot(): player %s (%u) trying to create bot with entry = %u, race = %u, class = %u, ignored", GetName(), GetGUIDLow(), botentry, botrace, botclass);
+        return;
+    }
+
+    if (GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(this);
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            if (m_botmap[pos].m_entry == botentry)
+                ClearBotMustBeCreated(pos, false);
+        ch.PSendSysMessage("Youre exceed max npcbots");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    if (GetGroup() && GetGroup()->isRaidGroup() && GetGroup()->IsFull())
+    {
+        ChatHandler ch(this);
+        ch.PSendSysMessage("Your group if Full!");
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos].m_entry == botentry)
+            if (m_botmap[pos].m_reviveTimer != 0)
+                return;
+
+    m_bot = SummonCreature(botentry, *this);
+
+    //m_bot->SetCharmerGUID(GetGUID());
+    m_bot->SetOwner(this);
+    m_bot->SetIAmABot(true);
+    m_bot->SetUInt64Value(UNIT_FIELD_CREATEDBY, GetGUID());
+    SetMinion((Minion*)m_bot, true);
+    m_bot->CombatStop();
+    m_bot->DeleteThreatList();
+    m_bot->AddUnitTypeMask(UNIT_MASK_MINION);
+
+    //check if we have free slot
+    bool _set = false;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+    {
+        if (m_botmap[pos].m_entry == botentry && m_botmap[pos].m_guid == 0)
+        {
+            m_botmap[pos].m_guid = m_bot->GetGUID();
+            m_botmap[pos].m_creature = m_bot;//this will save some time but we need guid as well
+            m_botmap[pos].tank = istank;
+            _set = true;
+            break;
+        }
+    }
+    if (!_set)
+    {
+        sLog->outError(LOG_FILTER_PLAYER, "character %s (%u) is failed to create npcbot! Removing all bots", GetName(), GetGUIDLow());
+        m_bot->SetCharmerGUID(0);
+        SetMinion((Minion*)m_bot, false);
+        m_bot->RemoveFromWorld();
+        m_bot->CombatStop();
+        m_bot->CleanupsBeforeDelete();
+        m_bot->SetIAmABot(false); //this HAS to come after CleanupsBeforeDelete
+        m_bot->AddObjectToRemoveList();
+        for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+            RemoveBot(m_botmap[pos].m_guid, true);
+        ClearBotMustBeCreated(0, false, true);
+        return;
+    }
+
+    m_bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    m_bot->setFaction(getFaction());
+    m_bot->SetLevel(getLevel());
+    m_bot->SetBotClass(botclass);
+    m_bot->AIM_Initialize();
+    m_bot->SetBotAI(m_bot->AI());
+    m_bot->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    //entry is unique for each master's bot so clean it up just in case 
+    CharacterDatabase.PExecute("DELETE FROM `character_npcbot` WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), botentry);
+    //add the new entry
+    CharacterDatabase.PExecute("INSERT INTO `character_npcbot` (owner,entry,race,class,istank) VALUES ('%u','%u','%u','%u','%u')", GetGUIDLow(), m_bot->GetEntry(), botrace, botclass, uint8(istank));
+    //If we have a group, just add bot
+    if (Group *gr = GetGroup())
+    {
+        if (!(m_group->isRaidGroup() && m_group->IsFull()))
+        {
+            if (m_group->IsFull())
+                gr->ConvertToRaid();
+            if (!gr->AddMember((Player*)m_bot))
+                RemoveBot(m_bot->GetGUID(), true);
+        }
+        else//raid group is full
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(this))
+        {
+            delete gr;
+            return;
+        }
+        sGroupMgr->AddGroup(gr);
+        if (!m_group->AddMember((Player*)m_bot))
+            RemoveBot(m_bot->GetGUID(), true);
+    }
+
+    if (Group *gr = GetGroup())
+    {
+        Group::MemberSlotList const a = gr->GetMemberSlots();
+        //try to remove 'absent' bots
+        for (Group::member_citerator itr = a.begin(); itr != a.end(); ++itr)
+        {
+            if (itr->guid == 0)
+                continue;
+            if (IS_PLAYER_GUID(itr->guid))
+                continue;
+            if (!sObjectAccessor->FindUnit(itr->guid))
+                gr->RemoveMember(itr->guid);
+        }
+    }
+
+} //end Player::CreateBot
+
+uint8 Player::GetMaxNpcBots() const
+{
+    if (GetSession()->GetSecurity() == SEC_PLAYER)
+        return ConfigMgr::GetIntDefault("Bot.MaxNpcBots", 1);
+    return MAX_NPCBOTS;
+}
+bool Player::HaveBot()
+{
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_entry != 0)
+            return true;
+    return false;
+}
+void Player::SendBotCommandState(Creature *cre, CommandStates state)
+{
+    if (!cre) return;
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_creature == cre)
+            cre->SetBotCommandState(state, true);
+}
+//finds bot's slot into master's botmap
+uint8 Player::GetNpcBotSlot(uint64 guid)
+{
+    if (guid)
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i].m_guid == guid)
+                return i;
+    return 0;
+}
+
+void Player::SetBotTank(uint64 guid)
+{
+    m_botTankGuid = guid;
+    if (guid == 0 || !IS_CREATURE_GUID(guid))
+    {
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        {
+            if (m_botmap[i].tank == true)
+            {
+                CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '0' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i].m_entry);
+                m_botmap[i].tank = false;
+            }
+        }
+        return;
+    }
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i].tank == true && m_botmap[i].m_guid != guid)
+            CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '0' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i].m_entry);
+        m_botmap[i].tank = false;
+        if (m_botmap[i].m_guid == guid)
+        {
+            m_botmap[i].tank = true;
+            CharacterDatabase.PExecute("UPDATE `character_npcbot` SET `istank` = '1' WHERE `owner` = '%u' AND `entry` = '%u'", GetGUIDLow(), m_botmap[i].m_entry);
+        }
+    }
+}
+
+Unit *Player::GetBotTank(uint32 entry)
+{
+    if (!entry) return NULL;
+
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+        if (m_botmap[i].m_entry == entry && m_botmap[i].tank == true)
+            return m_botmap[i].m_creature;
+
+    Player *owner = GetPlayerbotAI() ? GetSession()->m_master : this;
+    for (PlayerBotMap::const_iterator itr = owner->GetSession()->GetPlayerBotsBegin(); itr != owner->GetSession()->GetPlayerBotsEnd(); ++itr)
+    {
+        Player *player = itr->second;
+        if (!player || !player->IsInWorld()) continue;
+        for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+            if (player->GetBotMap()[i].m_entry == entry && player->GetBotMap()[i].tank == true)
+                return player->GetBotMap()[i].m_creature;
+    }
+    return NULL;
+}
+
+void Player::SetNpcBotDied(uint64 guid)
+{
+    if (!guid) return;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos].m_guid == guid)
+        {
+            m_botmap[pos].m_reviveTimer = 5000;//10 sec
+            break;
+        }
+}
+
+uint8 Player::GetNpcBotsCount() const
+{
+    uint8 bots = 0;
+    for (uint8 pos = 0; pos != GetMaxNpcBots(); ++pos)
+        if (m_botmap[pos].m_entry != 0)
+            ++bots;
+    return bots;
+}
+//This is called from script_bot_giver.cpp
+std::list<std::string> *Player::GetCharacterList()
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT name FROM characters WHERE account = '%u' AND guid != '%u'", m_session->GetAccountId(), GetGUIDLow());
+
+    if (!results) return NULL;
+    std::string plName;
+    std::list<std::string> *names = new std::list<std::string>;
+    do
+    {
+        Field *fields = results->Fetch();
+        plName = fields[0].GetString();
+        //if (plName.compare(GetName()) == 0) continue;
+        if (sObjectAccessor->FindPlayerByName(plName.c_str())) continue;
+        names->insert(names->end(), plName);
+    } while(results->NextRow());
+    return names;
+}
+
+//NPCbot base setup
+void Player::CreateNPCBot(uint8 bot_class)
+{
+    //check if we have too many bots of that class
+    if (HaveBot())
+    {
+        uint8 count = 0;
+        for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+            if (m_botmap[i].m_class == bot_class)
+                ++count;
+        if (count >= m_MaxClassNpcBots)
+        {
+            ChatHandler ch(this);
+            ch.PSendSysMessage("You cannot have more bots of that class! Max: %u", m_MaxClassNpcBots);
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    //check if not allowed class chosen (exclude warlock)
+    bool allow = ConfigMgr::GetBoolDefault("Bot.AllowAllClasses", false);
+    if (!allow && 
+        (bot_class != CLASS_WARRIOR && 
+        bot_class != CLASS_PALADIN && 
+        bot_class != CLASS_PRIEST && 
+        bot_class != CLASS_MAGE && 
+        bot_class != CLASS_DRUID && 
+        bot_class != CLASS_WARLOCK))
+    {
+        ChatHandler ch(this);
+        const char *bclass;
+        switch(bot_class)
+        {
+        case CLASS_DEATH_KNIGHT: bclass = "DeathKnight"; break;
+        case CLASS_ROGUE: bclass = "Rogue"; break;
+        case CLASS_SHAMAN: bclass = "Shaman"; break;
+        case CLASS_HUNTER: bclass = "Hunter"; break;
+        default: bclass = "Unknown Class"; break;
+        }
+        sLog->outError(LOG_FILTER_PLAYER, "Player::CreateNPCBot(): Character %u tried to create npcbot of class %s, which is not allowed on your server!", GetGUIDLow(), bclass);
+        ch.PSendSysMessage("You've tried to create npcbot of class %s, which is not allowed on this server!", bclass);
+        ch.SetSentErrorMessage(true);
+        return;
+    }
+
+    uint32 entry = 0;
+    uint32 bot_race = 0;
+
+    QueryResult result;
+
+    //maybe we should remove this check? ;
+    switch (getRace())
+    {
+    case RACE_NONE: case RACE_HUMAN: case RACE_DWARF: case RACE_NIGHTELF: case RACE_GNOME: case RACE_DRAENEI:
+        if (bot_class == CLASS_ROGUE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='rogue_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_PRIEST) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='priest_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_DRUID) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='druid_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_SHAMAN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='shaman_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_MAGE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='mage_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_WARLOCK) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warlock_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_WARRIOR) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warrior_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_PALADIN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='paladin_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else if (bot_class == CLASS_HUNTER) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='hunter_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        else result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='script_bot' and trainer_class=%u and trainer_race IN(1,3,4,7,11)", bot_class);
+        break;
+
+    case RACE_ORC: case RACE_UNDEAD_PLAYER: case RACE_TAUREN: case RACE_TROLL: case RACE_BLOODELF:
+        if (bot_class == CLASS_ROGUE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='rogue_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_PRIEST) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='priest_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_SHAMAN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='shaman_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_MAGE) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='mage_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_WARLOCK) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warlock_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_WARRIOR) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='warrior_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_DRUID) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='druid_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_PALADIN) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='paladin_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else if (bot_class == CLASS_HUNTER) result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='hunter_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        else result = WorldDatabase.PQuery("SELECT entry,trainer_race FROM creature_template WHERE scriptname='script_bot' and trainer_class=%u and trainer_race IN(2,5,6,8,10)", bot_class);
+        break;
+    }
+
+    //randomly select one of NPCs
+    if (result)
+    {
+        uint32 m_rand = urand(1, uint32(result->GetRowCount()));
+        uint32 tmp_rand = 0;
+        do
+        {
+            Field *fields = result->Fetch();
+            entry = fields[0].GetUInt32();
+            bot_race = fields[1].GetUInt32();
+            ++tmp_rand;
+            if (tmp_rand == m_rand)
+                break;
+        } while (result->NextRow());
+       // delete result;
+    }
+    for (uint8 i = 0; i != GetMaxNpcBots(); ++i)
+    {
+        if (m_botmap[i].m_entry == entry)//do not allow duplicates on every single char
+        {
+            ChatHandler ch(this);
+            ch.PSendSysMessage("OOPs! You've rolled a duplicate bot! maybe you should try again?");
+            ch.SetSentErrorMessage(true);
+            return;
+        }
+    }
+    SetBotMustBeCreated(entry, bot_race, bot_class);
+} //end CreateNPCBot
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2907,6 +3514,47 @@ void Player::RemoveFromGroup(Group* group, uint64 guid, RemoveMethod method /* =
 {
     if (group)
     {
+        uint8 players = 0;
+        Group::MemberSlotList const &members = group->GetMemberSlots();
+        for (Group::member_citerator itr = members.begin(); itr!= members.end(); ++itr)
+        {
+            if (Player *pl = sObjectAccessor->FindPlayer(itr->guid))
+                if (!pl->GetPlayerbotAI())
+                    ++players;
+        }
+        if (Player *player = sObjectAccessor->FindPlayer(guid))
+        {
+            if (player->GetPlayerbotAI())
+            {
+                if (player->HaveBot())
+                    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                        player->RemoveBot(player->GetBotMap()[i].m_guid, true, false);
+            }
+            else
+            {
+                //first remove npcbots so group will be disbanded if only 1 player
+                if (player->HaveBot())
+                {
+                    for (uint8 i = 0; i != player->GetMaxNpcBots(); ++i)
+                        player->RemoveBot(player->GetBotMap()[i].m_guid, players <= 1);
+                }
+                //second save playerbot map and remove them
+                WorldSession *session = player->GetSession();
+                PlayerBotMap m_playerBots;
+                for (PlayerBotMap::const_iterator itr = session->GetPlayerBotsBegin(); itr != session->GetPlayerBotsEnd(); ++itr)
+                {
+                    Player *bot = itr->second;
+                    (m_playerBots)[itr->first] = bot;
+                }
+                for (PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+                {
+                    Player *bot = itr2->second;
+                    session->LogoutPlayerBot(bot->GetGUID());
+                }
+            }
+            if (!(group = player->GetGroup()))
+                return;//prevent removing from already disbanded group
+        }
         group->RemoveMember(guid, method, kicker, reason);
         group = NULL;
     }
@@ -3086,6 +3734,9 @@ void Player::GiveLevel(uint8 level)
             }
 
     sScriptMgr->OnPlayerLevelChanged(this, oldLevel);
+
+    if (m_playerbotAI)
+        m_playerbotAI->GiveLevel(level);
 }
 
 void Player::InitTalentForLevel()
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 774e751..36db936 100755
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -55,6 +55,9 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// Playerbot mod
+class PlayerbotAI;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2525,6 +2528,53 @@ class Player : public Unit, public GridObject<Player>
             }
         }
 
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        // Playerbot mod:
+        void SetPlayerbotAI(PlayerbotAI* ai) { m_playerbotAI = ai; }
+        PlayerbotAI* GetPlayerbotAI() const { return m_playerbotAI; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        std::list<std::string> *GetCharacterList();
+        PlayerTalentMap *GetTalents(uint8 spec) { return m_talents[spec]; }
+        void chompAndTrim(std::string& str);
+        bool getNextQuestId(const std::string& pString, unsigned int& pStartPos, unsigned int& pId);
+        void skill(std::list<uint32>& m_spellsToLearn);
+        void MakeTalentGlyphLink(std::ostringstream &out);
+        bool requiredQuests(const char* pQuestIdString);
+        PlayerMails::reverse_iterator GetMailRBegin() { return m_mail.rbegin();}
+        PlayerMails::reverse_iterator GetMailREnd() { return m_mail.rend();}
+        void UpdateMail();
+        uint32 GetSpec();
+
+        //adds
+        void SetBotTeam(Team team) { if (m_playerbotAI != NULL) m_team = team; }
+
+        //npcbot
+        void RefreshBot(uint32 p_time);
+        void CreateBot(uint32 botentry, uint8 botrace, uint8 botclass, bool istank = false, bool revive = false);
+        void CreateNPCBot(uint8 botclass);
+        uint8 GetNpcBotSlot(uint64 guid);
+        void SendBotCommandState(Creature *cre, CommandStates state);
+        bool HaveBot();
+        void RemoveBot(uint64 guid, bool final = false, bool eraseFromDB = true);
+        void SetBot(Creature *cre) { m_bot = cre; }
+        uint8 GetNpcBotsCount() const;
+        void SetBotMustBeCreated(uint32 m_entry, uint8 m_race, uint8 m_class, bool istank = false);
+        void ClearBotMustBeCreated(uint64 value, bool guid = true, bool fully = false);
+        bool GetBotMustBeCreated();
+        uint64 GetBotTankGuid() const { return m_botTankGuid; }
+        void SetBotTank(uint64 guid);
+        Unit *GetBotTank(uint32 entry);
+        uint8 GetBotFollowDist() const { return m_followdist; }
+        void SetBotFollowDist(int8 dist) { m_followdist = dist; }
+        void SetNpcBotDied(uint64 guid);
+        NpcBotMap const *GetBotMap() { return m_botmap; }
+        uint8 GetMaxNpcBots() const;
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2786,6 +2836,22 @@ class Player : public Unit, public GridObject<Player>
         uint8 m_grantableLevels;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        //Playerbot mod
+        PlayerbotAI* m_playerbotAI;
+        //npcbot
+        Creature *m_bot;
+        int8 m_followdist;
+        uint64 m_botTankGuid;
+        uint8 m_MaxClassNpcBots;
+        uint32 m_botTimer;
+        NpcBotMap m_botmap[MAX_NPCBOTS];
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index d65d717..ac758c1 100755
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -947,6 +947,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_RANGED:
         case SPELL_DAMAGE_CLASS_MELEE:
         {
+            //Npcbot mod: apply bot damage mods
+            if (GetTypeId() == TYPEID_UNIT)
+                if (ToCreature()->GetIAmABot())
+                    ToCreature()->ApplyBotDamageMultiplierMelee(damage);
+
             // Physical Damage
             if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
             {
@@ -1004,6 +1009,11 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
         case SPELL_DAMAGE_CLASS_NONE:
         case SPELL_DAMAGE_CLASS_MAGIC:
         {
+            //Npcbot mod: apply bot damage mods
+            if (GetTypeId() == TYPEID_UNIT)
+                if (ToCreature()->GetIAmABot())
+                    ToCreature()->ApplyBotDamageMultiplierSpell(damage);
+
             // If crit add critical bonus
             if (crit)
             {
@@ -1114,6 +1124,11 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     damage = MeleeDamageBonusDone(damageInfo->target, damage, damageInfo->attackType);
     damage = damageInfo->target->MeleeDamageBonusTaken(this, damage, damageInfo->attackType);
 
+    //Npcbot mod: apply bot damage mods
+    if (GetTypeId() == TYPEID_UNIT)
+        if (ToCreature()->GetIAmABot())
+            ToCreature()->ApplyBotDamageMultiplierMelee(damage);
+
     // Calculate armor reduction
     if (IsDamageReducedByArmor((SpellSchoolMask)(damageInfo->damageSchoolMask)))
     {
@@ -10856,6 +10871,7 @@ bool Unit::isSpellCrit(Unit* victim, SpellInfo const* spellProto, SpellSchoolMas
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (IS_CREATURE_GUID(GetGUID()) && !(isTotem() && IS_PLAYER_GUID(GetOwnerGUID())) && GetEntry() != 15438)
+        if (!ToCreature()->GetIAmABot())
         return false;
 
     // not critting spell
@@ -16635,6 +16651,8 @@ uint32 Unit::GetCombatRatingDamageReduction(CombatRating cr, float rate, float c
 
 uint32 Unit::GetModelForForm(ShapeshiftForm form)
 {
+    if (ToPlayer())
+    {
     switch (form)
     {
         case FORM_CAT:
@@ -16806,6 +16824,183 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form)
         default:
             break;
     }
+    }
+    else if (ToCreature() && ToCreature()->GetIAmABot())
+    {
+        Player const *player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+            case FORM_CAT:
+                // Based on master's Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 7: // Violet
+                        case 8:
+                            return 29405;
+                        case 3: // Light Blue
+                            return 29406;
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29407;
+                        case 4: // White
+                            return 29408;
+                        default: // original - Dark Blue
+                            return 892;
+                    }
+                }
+                // Based on master's Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male master
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 12: // White
+                            case 13:
+                            case 14:
+                            case 18: // Completly White
+                                return 29409;
+                            case 9: // Light Brown
+                            case 10:
+                            case 11:
+                                return 29410;
+                            case 6: // Brown
+                            case 7:
+                            case 8:
+                                return 29411;
+                            case 0: // Dark
+                            case 1:
+                            case 2:
+                            case 3: // Dark Grey
+                            case 4:
+                            case 5:
+                                return 29412;
+                            default: // original - Grey
+                                return 8571;
+                        }
+                    }
+                    // Female master
+                    else switch (skinColor)
+                    {
+                        case 10: // White
+                            return 29409;
+                        case 6: // Light Brown
+                        case 7:
+                            return 29410;
+                        case 4: // Brown
+                        case 5:
+                            return 29411;
+                        case 0: // Dark
+                        case 1:
+                        case 2:
+                        case 3:
+                            return 29412;
+                        default: // original - Grey
+                            return 8571;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 892;
+                else
+                    return 8571;
+            case FORM_DIREBEAR:
+            case FORM_BEAR:
+                // Based on Hair color
+                if (player->getRace() == RACE_NIGHTELF)
+                {
+                    uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                    switch (hairColor)
+                    {
+                        case 0: // Green
+                        case 1: // Light Green
+                        case 2: // Dark Green
+                            return 29413; // 29415?
+                        case 6: // Dark Blue
+                            return 29414;
+                        case 4: // White
+                            return 29416;
+                        case 3: // Light Blue
+                            return 29417;
+                        default: // original - Violet
+                            return 2281;
+                    }
+                }
+                // Based on Skin color
+                else if (player->getRace() == RACE_TAUREN)
+                {
+                    uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                    // Male
+                    if (player->getGender() == GENDER_MALE)
+                    {
+                        switch (skinColor)
+                        {
+                            case 0: // Dark (Black)
+                            case 1:
+                            case 2:
+                                return 29418;
+                            case 3: // White
+                            case 4:
+                            case 5:
+                            case 12:
+                            case 13:
+                            case 14:
+                                return 29419;
+                            case 9: // Light Brown/Grey
+                            case 10:
+                            case 11:
+                            case 15:
+                            case 16:
+                            case 17:
+                                return 29420;
+                            case 18: // Completly White
+                                return 29421;
+                            default: // original - Brown
+                                return 2289;
+                        }
+                    }
+                    // Female
+                    else switch (skinColor)
+                    {
+                        case 0: // Dark (Black)
+                        case 1:
+                            return 29418;
+                        case 2: // White
+                        case 3:
+                            return 29419;
+                        case 6: // Light Brown/Grey
+                        case 7:
+                        case 8:
+                        case 9:
+                            return 29420;
+                        case 10: // Completly White
+                            return 29421;
+                        default: // original - Brown
+                            return 2289;
+                    }
+                }
+                else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 2281;
+                else
+                    return 2289;
+            case FORM_FLIGHT:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 20857;
+                return 20872;
+            case FORM_FLIGHT_EPIC:
+                if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                    return 21243;
+                return 21244;
+            default:
+                break;
+        }
+    }
 
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 5ace6da..e164cd8 100755
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -35,6 +35,8 @@
 #include "Util.h"
 #include "LFGMgr.h"
 #include "UpdateFieldFlags.h"
+//Playerbot mod
+#include "Config.h"
 
 Roll::Roll(uint64 _guid, LootItem const& li) : itemGUID(_guid), itemid(li.itemid),
 itemRandomPropId(li.randomPropertyId), itemRandomSuffix(li.randomSuffix), itemCount(li.count),
@@ -109,7 +111,13 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    if (leader->HaveBot())//npcbots so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
+        m_lootMethod = (LootMethod)ConfigMgr::GetIntDefault("Bot.LootMethod", 0);
+/*
     m_lootMethod = GROUP_LOOT;
+*/
     m_lootThreshold = ITEM_QUALITY_UNCOMMON;
     m_looterGuid = leaderGuid;
 
@@ -369,6 +377,7 @@ bool Group::AddMember(Player* player)
     SubGroupCounterIncrease(subGroup);
 
     if (player)
+    if (IS_PLAYER_GUID(player->GetGUID()))
     {
         player->SetGroupInvite(NULL);
         if (player->GetGroup() && isBGGroup()) //if player is in group and he is being added to BG raid group, then call SetBattlegroundRaid()
@@ -409,6 +418,7 @@ bool Group::AddMember(Player* player)
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
     if (player)
+    if (IS_PLAYER_GUID(player->GetGUID()))
     {
         if (!IsLeader(player->GetGUID()) && !isBGGroup())
         {
@@ -605,6 +615,9 @@ bool Group::RemoveMember(uint64 guid, const RemoveMethod &method /*= GROUP_REMOV
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isBGGroup() || isLFGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index e5f174c..f3cff9a 100755
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -304,6 +304,9 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        //Bot
+        uint64 const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(uint64 guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index e4926bf..15d1899 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -45,6 +45,10 @@
 #include "AccountMgr.h"
 #include "LFGMgr.h"
 
+// Playerbot mod
+#include "Config.h"
+#include "PlayerbotAI.h"
+
 class LoginQueryHolder : public SQLQueryHolder
 {
     private:
@@ -1010,10 +1014,98 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
 
     m_playerLoading = false;
 
+    //the only place where we check if it has NPC bots
+    QueryResult results;
+    results = CharacterDatabase.PQuery("SELECT entry,race,class,istank FROM `character_npcbot` WHERE `owner` = '%u'", pCurrChar->GetGUIDLow());
+    if (results)
+    {
+        do
+        {
+            uint32 m_bot_entry = 0;
+            uint8 m_bot_race = 0;
+            uint8 m_bot_class = 0;
+            bool Tank = false;
+            Field *fields = results->Fetch();
+            m_bot_entry = fields[0].GetUInt32();
+            m_bot_race = fields[1].GetUInt8();
+            m_bot_class = fields[2].GetInt8();
+            Tank = fields[3].GetInt8();
+            if (m_bot_entry && m_bot_race && m_bot_class) pCurrChar->SetBotMustBeCreated(m_bot_entry, m_bot_race, m_bot_class, Tank);
+        } while (results->NextRow());
+    }
+
     sScriptMgr->OnPlayerLogin(pCurrChar);
     delete holder;
 }
 
+//Playerbot mod: is different from the normal
+//HandlePlayerLoginCallback in that it sets up the bot's
+//world session and also stores the pointer to the bot player
+//in the master's world session m_playerBots map
+void WorldSession::HandlePlayerBotLogin(SQLQueryHolder *holder)
+{
+    if (!holder) return;
+
+    LoginQueryHolder *lqh = (LoginQueryHolder *)holder;
+
+    if (!lqh || !lqh->GetAccountId()) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #1 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        return;
+    }
+
+    WorldSession *masterSession = sWorld->FindSession(lqh->GetAccountId());
+
+    if (!masterSession) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #2 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        return;
+    }
+
+    //This WorldSession is owned by the bot player object
+    //it will deleted in the Player class constructor for Playerbots
+    //only
+    WorldSession *botSession = new WorldSession(lqh->GetAccountId(), NULL, masterSession->GetSecurity(), masterSession->Expansion(), 0, masterSession->GetSessionDbcLocale(), 0, false);
+
+    if (!botSession) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #3 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        return;
+    }
+
+    uint64 guid = lqh->GetGuid();
+    if (!guid) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #4 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        if (botSession) delete botSession;
+        return;
+    }
+
+    botSession->HandlePlayerLogin(lqh);
+    Player* const botPlayer = botSession->GetPlayer();
+
+    if (!botPlayer) // Probably excessively verbose..
+    {
+        //sLog->outError("Excessively verbose Playerbot error checkpoint #5 hit. Please report this error immediately.");
+        if (holder) delete holder;
+        if (botSession) delete botSession;
+        return;
+    }
+
+    //give the bot some AI, object is owned by the player class
+    PlayerbotAI *ai = new PlayerbotAI(masterSession->GetPlayer(), botPlayer);
+    botPlayer->SetPlayerbotAI(ai);
+
+    //tell the world session that they now manage this new bot
+    (masterSession->m_playerBots)[guid] = botPlayer;
+
+    botSession->m_master = masterSession->GetPlayer();
+}
+
 void WorldSession::HandleSetFactionAtWar(WorldPacket & recv_data)
 {
     sLog->outDebug(LOG_FILTER_NETWORKIO, "WORLD: Received CMSG_SET_FACTION_ATWAR");
@@ -1190,6 +1282,57 @@ void WorldSession::HandleChangePlayerNameOpcodeCallBack(PreparedQueryResult resu
     sWorld->UpdateCharacterNameData(guidLow, newName);
 }
 
+//Playerbot mod - add new player bot for this master. This definition must
+//appear in this file because it utilizes the CharacterHandler class
+//which isn't accessible outside this file
+void WorldSession::AddPlayerBot(uint64 playerGuid)
+{
+    //has bot already been added?
+    if (GetPlayerBot(playerGuid) != 0) return;
+
+    ChatHandler ch = ChatHandler(GetPlayer());
+
+    //check if bots are enabled
+    if (ConfigMgr::GetBoolDefault("Bot.EnablePlayerBots", true) == false)
+    {
+        ch.SendSysMessage("PlayerBot System is currently disabled. Please contact administration.");
+        return;
+    }
+    //check if max playerbots are exceeded
+    uint8 count = m_playerBots.size();//0;
+    uint8 MaxPlayerbots = ConfigMgr::GetIntDefault("Bot.MaxPlayerbots", 9);
+    if (count >= MaxPlayerbots)
+    {
+        ch.PSendSysMessage("You have reached the maximum number of Player Bots allowed (%u).", MaxPlayerbots);
+        return;
+    }
+    //check level difference
+    uint8 maxDiff = abs(ConfigMgr::GetIntDefault("Bot.MaxLevelDiff", 79));
+    uint8 diff = 0;
+    QueryResult result = CharacterDatabase.PQuery("SELECT level FROM characters WHERE guid = '%u'", GUID_LOPART(playerGuid));
+    if (result)
+    {
+        uint8 botlevel = (*result)[0].GetUInt8();
+        diff = abs(botlevel - GetPlayer()->getLevel());
+        if (diff > maxDiff)
+        {
+            const char *expr = GetPlayer()->getLevel() > botlevel ? "low" : "high";
+            ch.PSendSysMessage("This player is too %s level! (max difference: %u)", expr, maxDiff);
+            return;
+        }
+    }
+
+    LoginQueryHolder *holder = new LoginQueryHolder(GetAccountId(), playerGuid);
+
+    if (!holder->Initialize())
+    {
+        delete holder; //delete all unprocessed queries
+        return;
+    }
+    _charBotLoginCallback = CharacterDatabase.DelayQueryHolder(holder);
+    ch.PSendSysMessage("Bot added successfully.");
+}
+
 void WorldSession::HandleSetPlayerDeclinedNames(WorldPacket& recv_data)
 {
     uint64 guid;
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 880f2df..ad0d7a5 100755
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -41,6 +41,9 @@
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
 
+//Playerbot mod
+#include "PlayerbotAI.h"
+
 bool WorldSession::processChatmessageFurtherAfterSecurityChecks(std::string& msg, uint32 lang)
 {
     if (lang != LANG_ADDON)
@@ -295,6 +298,16 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
             if (!senderIsPlayer && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID()))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
+            //Playerbot mod: handle whispered command to bot
+            if (receiver->GetPlayerbotAI())
+            {
+                if (lang != LANG_ADDON)
+                    receiver->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());
+                GetPlayer()->m_speakTime = 0;
+                GetPlayer()->m_speakCount = 0;
+            }
+            else
+            //end Playerbot mod
             GetPlayer()->Whisper(msg, lang, receiver->GetGUID());
         } break;
         case CHAT_MSG_PARTY:
@@ -314,6 +327,24 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket & recv_data)
 
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
+
+            //Playerbot mod: broadcast message to bot members
+            for(GroupReference *itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player *player = itr->getSource();
+
+                if (player && player->GetPlayerbotAI() && (msg.find("help",0) != -1))
+                {
+                    //only whispered commands should be handled
+                    //so in party chat accept only help request 
+                    player->GetPlayerbotAI()->HandleCommand(msg, *GetPlayer());//send help 
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                    break;//only once
+                }
+            }
+            //end Playerbot mod
+
             WorldPacket data;
             ChatHandler::FillMessageData(&data, this, uint8(type), lang, NULL, 0, msg.c_str(), NULL);
             group->BroadcastPacket(&data, false, group->GetMemberGroup(GetPlayer()->GetGUID()));
diff --git a/src/server/game/Handlers/GroupHandler.cpp b/src/server/game/Handlers/GroupHandler.cpp
index e0ff393..99663a7 100755
--- a/src/server/game/Handlers/GroupHandler.cpp
+++ b/src/server/game/Handlers/GroupHandler.cpp
@@ -306,6 +306,15 @@ void WorldSession::HandleGroupUninviteGuidOpcode(WorldPacket & recv_data)
 
     if (grp->IsMember(guid))
     {
+        Player* player = sObjectAccessor->FindPlayer(guid);
+        if (player && player->GetPlayerbotAI())
+        {
+            if (WorldSession *session = player->GetSession())
+                if (Player *master = session->m_master)
+                    if (master == GetPlayer())
+                        LogoutPlayerBot(guid);
+        }
+        else
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID(), reason.c_str());
         return;
     }
@@ -350,6 +359,15 @@ void WorldSession::HandleGroupUninviteOpcode(WorldPacket & recv_data)
 
     if (uint64 guid = grp->GetMemberGUID(membername))
     {
+        Player* player = sObjectAccessor->FindPlayer(guid);
+        if (player && player->GetPlayerbotAI())
+        {
+            if (WorldSession *session = player->GetSession())
+                if (Player *master = session->m_master)
+                    if (master == GetPlayer())
+                        LogoutPlayerBot(guid);
+        }
+        else
         Player::RemoveFromGroup(grp, guid, GROUP_REMOVEMETHOD_KICK, GetPlayer()->GetGUID());
         return;
     }
diff --git a/src/server/game/Handlers/QuestHandler.cpp b/src/server/game/Handlers/QuestHandler.cpp
index 7492edb..65dc6a6 100755
--- a/src/server/game/Handlers/QuestHandler.cpp
+++ b/src/server/game/Handlers/QuestHandler.cpp
@@ -33,6 +33,9 @@
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
 
+// Playerbot mod:
+#include "PlayerbotAI.h"
+
 void WorldSession::HandleQuestgiverStatusQueryOpcode(WorldPacket & recv_data)
 {
     uint64 guid;
@@ -582,8 +585,13 @@ void WorldSession::HandlePushQuestToParty(WorldPacket& recvPacket)
                     continue;
                 }
 
+                if (player->GetPlayerbotAI())
+                    player->GetPlayerbotAI()->AcceptQuest(quest, _player);
+                else
+                {
                 player->PlayerTalkClass->SendQuestGiverQuestDetails(quest, _player->GetGUID(), true);
                 player->SetDivider(_player->GetGUID());
+                }
             }
         }
     }
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 319fd1e..44d949a 100755
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1250,6 +1250,18 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
+//Bots
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_script_bot_giver();
+void AddSC_script_bot_commands();
 
 #endif
 
@@ -1257,6 +1269,18 @@ void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
+    //Bots
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_script_bot_giver();
+    AddSC_script_bot_commands();
 
 #endif
 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 6fdbf8a..88fd84a 100755
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -45,6 +45,9 @@
 #include "WardenWin.h"
 #include "WardenMac.h"
 
+//Playerbot mod
+#include "PlayerbotAI.h"
+
 bool MapSessionFilter::Process(WorldPacket* packet)
 {
     OpcodeHandler const& opHandle = opcodeTable[packet->GetOpcode()];
@@ -114,6 +117,20 @@ isRecruiter(isARecruiter), timeLastWhoCommand(0)
 /// WorldSession destructor
 WorldSession::~WorldSession()
 {
+    //Playerbot mod: log out any PlayerBots owned in this WorldSession
+    PlayerBotMap m_playerBots;
+    for(PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player *bot = itr->second;
+        (m_playerBots)[itr->first] = bot;
+    }
+    for(PlayerBotMap::const_iterator itr2 = m_playerBots.begin(); itr2 != m_playerBots.end(); ++itr2)
+    {
+        Player *botPlayer = itr2->second;
+        if (!botPlayer) continue;
+            LogoutPlayerBot(botPlayer->GetGUID());
+    }
+
     ///- unload player if not unloaded
     if (_player)
         LogoutPlayer (true);
@@ -158,6 +175,10 @@ uint32 WorldSession::GetGuidLow() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket const* packet)
 {
+    //Playerbot mod: send packet to bot AI
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI())
+        GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+
     if (!m_Socket)
         return;
 
@@ -229,8 +250,10 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 
     ///- Before we process anything:
     /// If necessary, kick the player from the character select screen
+    /*
     if (IsConnectionIdle())
         m_Socket->CloseSocket();
+    */
 
     ///- Retrieve packets from the receive queue and call the appropriate handlers
     /// not process packets if socket already closed
@@ -287,6 +310,18 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             if (sLog->ShouldLog(LOG_FILTER_NETWORKIO, LOG_LEVEL_TRACE) && packet->rpos() < packet->wpos())
                                 LogUnprocessedTail(packet);
                         }
+                        // Playerbot mod: if this player has bots let the
+                        // botAI see the masters packet
+                        if (!m_playerBots.empty())
+                        {
+                            for (PlayerBotMap::const_iterator itr = m_playerBots.begin(); itr != m_playerBots.end(); ++itr)
+                            {
+                                Player *bot = itr->second;
+                                if (bot)
+                                    bot->GetPlayerbotAI()->HandleMasterIncomingPacket(*packet, *this);
+                            }
+                        }
+
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
                     case STATUS_LOGGEDIN_OR_RECENTLY_LOGGOUT:
@@ -375,6 +410,28 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
         if (m_Socket && GetPlayer() && _warden)
             _warden->Update();
 
+        // Playerbot mod - Process player bot packets
+        // The PlayerbotAI class adds to the packet queue to simulate a real player
+        // since Playerbots are known to the World obj only by its master's WorldSession object
+        // we need to process all master's bot's packets.
+        for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+        {
+            Player *const botPlayer = itr->second;
+            WorldSession *const pBotWorldSession = botPlayer->GetSession();
+            if (botPlayer->IsBeingTeleportedFar())
+                pBotWorldSession->HandleMoveWorldportAckOpcode();
+            else if (botPlayer->IsInWorld())
+            {
+                WorldPacket *packet;
+                while (pBotWorldSession->_recvQueue.next(packet))
+                {
+                    OpcodeHandler &opHandle = opcodeTable[packet->GetOpcode()];
+                    (pBotWorldSession->*opHandle.handler)(*packet);
+                    delete packet;
+                }
+            }
+        }
+
         ///- Cleanup socket pointer if need
         if (m_Socket && m_Socket->IsClosed())
         {
@@ -392,6 +449,25 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 /// %Log the player out
 void WorldSession::LogoutPlayer(bool Save)
 {
+    if (!_player)
+    {
+        return;
+    }
+
+    if (_player->IsMounted()) _player->Dismount();
+
+    //remove npcbots but do not delete from DB so it can be reaccured on next login
+    uint8 nBotCount = 0;
+    for (uint8 i = 0; i != _player->GetMaxNpcBots(); ++i)
+        if (_player->GetBotMap()[i]._Guid())
+        {
+            _player->RemoveBot(_player->GetBotMap()[i]._Guid(), true, false);
+            ++nBotCount;
+        }
+    // Playerbot mod: log out all player bots owned by this toon
+    while (!m_playerBots.empty())
+        LogoutPlayerBot(m_playerBots.begin()->first);
+
     // finish pending transfers before starting the logout
     while (_player && _player->IsBeingTeleportedFar())
         HandleMoveWorldportAckOpcode();
@@ -513,6 +589,9 @@ void WorldSession::LogoutPlayer(bool Save)
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
         if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+            //bot d) if has no NpcBots or not in instance (trying to save instance)
+            if (nBotCount == 0 || !_player->GetMap()->Instanceable())
+            //end bot
             _player->RemoveFromGroup();
 
         //! Send update to group and reset stored max enchanting level
@@ -658,6 +737,33 @@ void WorldSession::LoadGlobalAccountData()
     LoadAccountData(CharacterDatabase.Query(stmt), GLOBAL_CACHE_MASK);
 }
 
+//Playerbot mod: logs out a Playerbot.
+void WorldSession::LogoutPlayerBot(uint64 guid)
+{
+    Player *pPlayerBot = GetPlayerBot(guid);
+
+    if (pPlayerBot) //log out any playbots I have
+    {
+        pPlayerBot->CombatStop();
+        // remove from group
+        Player::RemoveFromGroup(pPlayerBot->GetGroup(), pPlayerBot->GetGUID());
+
+        WorldSession *pPlayerBotWorldSession = pPlayerBot->GetSession();
+        pPlayerBotWorldSession->m_master = NULL;
+        m_playerBots.erase(guid); //deletes bot player ptr inside this WorldSession PlayerBotMap
+        pPlayerBotWorldSession->LogoutPlayer(true); //this will delete the bot Player object and PlayerbotAI object
+        delete pPlayerBotWorldSession; //finally delete the bot's WorldSession
+        pPlayerBotWorldSession = NULL;
+    }
+}
+
+//Playerbot mod: Gets a player bot Player object for this WorldSession master
+Player *WorldSession::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = m_playerBots.find(playerGuid);
+    return(it == m_playerBots.end()) ? 0 : it->second;
+}
+
 void WorldSession::LoadAccountData(PreparedQueryResult result, uint32 mask)
 {
     for (uint32 i = 0; i < NUM_ACCOUNT_DATA_TYPES; ++i)
@@ -1109,6 +1215,15 @@ void WorldSession::ProcessQueryCallbacks()
         _charLoginCallback.cancel();
     }
 
+    //! HandlePlayerBotLogin
+    if (_charBotLoginCallback.ready())
+    {
+        SQLQueryHolder* param;
+        _charBotLoginCallback.get(param);
+        HandlePlayerBotLogin((SQLQueryHolder*)param);
+        _charBotLoginCallback.cancel();
+    }
+
     //! HandleAddFriendOpcode
     if (_addFriendCallback.IsReady())
     {
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index b8b0953..e47337b 100755
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -211,6 +211,28 @@ class CharacterCreateInfo
         virtual ~CharacterCreateInfo(){};
 };
 
+//Playerbot mod
+typedef UNORDERED_MAP<uint64, Player*> PlayerBotMap;
+//npcbot
+struct NpcBotMap
+{
+    friend class Player;
+    protected:
+        NpcBotMap() : m_guid(0), m_entry(0), m_race(0), m_class(0), m_creature(NULL), m_reviveTimer(0), tank(false) {}
+        uint64 m_guid;
+        uint32 m_entry;
+        uint8  m_race;
+        uint8  m_class;
+        Creature *m_creature;
+        uint32 m_reviveTimer;
+        bool tank;
+    public:
+        uint64 _Guid() const { return m_guid; }
+        Creature *_Cre() const { return m_creature; }
+};
+#define MAX_NPCBOTS 40
+//end bot mods
+
 /// Player session in the World
 class WorldSession
 {
@@ -218,6 +240,16 @@ class WorldSession
         WorldSession(uint32 id, WorldSocket* sock, AccountTypes sec, uint8 expansion, time_t mute_time, LocaleConstant locale, uint32 recruiter, bool isARecruiter);
         ~WorldSession();
 
+        //Playerbot mod
+        void AddPlayerBot(uint64 guid);
+        void LogoutPlayerBot(uint64 guid);
+        Player *GetPlayerBot(uint64 guid) const;
+        PlayerBotMap m_playerBots;
+        PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return m_playerBots.begin(); }
+        PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return m_playerBots.end();   }
+        Player *m_master;
+        //end Playerbot mod
+
         bool PlayerLoading() const { return m_playerLoading; }
         bool PlayerLogout() const { return m_playerLogout; }
         bool PlayerLogoutWithSave() const { return m_playerLogout && m_playerSave; }
@@ -407,6 +439,7 @@ class WorldSession
         void HandlePlayerLoginOpcode(WorldPacket& recvPacket);
         void HandleCharEnum(PreparedQueryResult result);
         void HandlePlayerLogin(LoginQueryHolder * holder);
+        void HandlePlayerBotLogin(SQLQueryHolder * holder);
         void HandleCharFactionOrRaceChange(WorldPacket& recv_data);
 
         // played time
@@ -930,6 +963,9 @@ class WorldSession
         QueryCallback<PreparedQueryResult, CharacterCreateInfo*, true> _charCreateCallback;
         QueryResultHolderFuture _charLoginCallback;
 
+        // Playerbot
+        QueryResultHolderFuture _charBotLoginCallback;
+
     private:
         // private trade methods
         void moveItems(Item* myItems[], Item* hisItems[]);
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 3d8ca3e..b57da4b 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -192,6 +192,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load()
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -232,6 +233,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -386,6 +389,7 @@ class spell_priest_renew : public SpellScriptLoader
 
             bool Load()
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->GetIAmABot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 3fe9ab4..87aaf17 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2751,3 +2751,191 @@ Logger.SQL.Appenders=Console Server SQL
 Logger.GM.Type=27
 Logger.GM.Level=3
 Logger.GM.Appenders=Console Server GM
+
+
+###################################################################################################
+################################## BOTS CONFIGURATION ############################################
+###################################################################################################
+# PLAYERBOT CONFIGURATION
+#
+#    Bot.EnablePlayerBots
+#        Disable the bot command and bot menu
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnablePlayerBots = 1
+
+#    Bot.FollowDistanceMin
+#    Bot.FollowDistanceMax
+#        Min. and max. follow distance for bots
+#        Default: 0.5 / 2.0
+
+Bot.FollowDistanceMin = 0.5
+Bot.FollowDistanceMax = 1.0
+
+#    Bot.DebugWhisper
+#        Enable debug output by whispering master
+#        Default: 0 - off
+#                 1 - on
+
+Bot.DebugWhisper = 0
+
+#    Bot.MaxPlayerbots
+#        Limits the number of bots per account (Max 9)
+#        Default: 9
+
+Bot.MaxPlayerBots = 9
+
+#    Bot.MaxLevelDiff
+#        Maximum level difference between summoner and bot
+#        Default: 79
+
+Bot.MaxLevelDiff = 79
+
+#    Bot.Collect.Combat
+#    Bot.Collect.Quest
+#    Bot.Collect.Profession
+#    Bot.Collect.Loot
+#    Bot.Collect.Skin
+#    Bot.Collect.Objects
+#        Enable collection options for after combat, quest items, profession, all loot, skin, or nearby objects
+#                 0 - off
+#        Default: 1 - on
+
+Bot.Collect.Combat = 1
+Bot.Collect.Quest = 1
+Bot.Collect.Profession = 1
+Bot.Collect.Loot = 1
+Bot.Collect.Skin = 1
+Bot.Collect.Objects = 1
+
+#    Bot.Collect.Distance
+#        Default distance that bots will search within for collection.
+#        Default: 25 (cannot be more than DistanceMax)
+#
+#    Bot.Collect.DistanceMax
+#        Maximum distance that can be configured for bots to collect objects. Allowing a higher
+#        distance could increase processor usage for object searching.
+#                 1-100
+#        Default: 30
+
+Bot.Collect.Distance = 25
+Bot.Collect.DistanceMax = 30
+
+#    Bot.SellGarbage
+#        Allow bots to automatically sell all [GRAY|POOR] quality items as the player activates vendor
+#        Default: 0 - off
+#                 1 - on
+
+Bot.SellGarbage = 0
+
+#    Bot.SellAll.LevelDiff
+#         If 'sell all' command is given prior to selling, bots will sell all low level white items.. this number is the number
+#         of levels LOWER than the bots level the Item must be before bot will sell it.
+#         Default: 10 (10 levels lower than the bot) Don't set to 0 or they'll sell everything! *SellGarbage must be set to 1 to use this*
+
+Bot.SellAll.LevelDiff = 10
+
+#    Bot.LootMethod
+#        Type of loot method
+#        Default: 2
+#        0 = Free for all
+#        1 = Round robin
+#        2 = Master loot
+#        3 = Group loot
+#        4 = Need before greed
+
+Bot.LootMethod = 2
+
+#    Bot.ChangeFaction
+#        Change bot's faction on login (thy will restore their faction of logout)
+#        Default = 1
+#        0 = false - Do not change
+#        1 = true - Bot and his npcbots will change their faction to master's
+
+Bot.ChangeFaction = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#     Bot.EnableNpcBots
+#        Enable NpcBot system
+#        Default: 1 - enable
+#                       0 - disable
+
+Bot.EnableNpcBots = 1
+
+#    Bot.MaxNpcBots
+#        Maximum number of Npc Bots allowed per character (disabled for GM accounts)
+#        Default: 1
+#        Recomended: 4
+#        Max: 9
+#        Absolute Max: 39
+
+Bot.MaxNpcBots = 1
+
+#    Bot.MaxNpcBotsPerClass
+#        Maximum Npc Bots of each class allowed per character
+#        If set to 0, no restriction
+#        Default: 1
+
+Bot.MaxNpcBotsPerClass = 1
+
+#    Bot.BaseFollowDistance
+#        Default follow distance set at login
+#        Default: 30
+
+Bot.BaseFollowDistance = 30
+
+#    Bot.XpReductionPercent
+#        Since bot party can be pretty large, it can become an exploit to farm xp so you can reduce xp gain here
+#        PERCENT of  'XP.KILL'  reward reduction from each Npc Bots used (Starting with second)
+#        Example:
+#            You have 3 bots, xp reduction is 20 then reduction will be ((3-1)*20) = 40%; 60% exp gained only
+#        Note: Minimum xp rate will be 10%
+#        Min: 0
+#        Max: 90
+#        Default: 0
+
+Bot.XpReductionPercent = 0
+
+#    Bot.HealTargetIconsMask
+#        Icon number bitmask which bots are using to search for additional targets to heal (out of party)
+#        1 - Star
+#        2 - Circle
+#        4 - Diamond
+#        8 - Triangle
+#        16 - Moon
+#        32 - Square
+#        64 - Cross
+#        128 - Skull
+#        Example: to check Star, Triangle and Square we need 1+8+32 = 41
+#        Note that many creatures cannot accept heal
+#        Min: 0 (Disable)
+#        Max: 255 (Any Icon)
+#        Default: 8 (Triangle)
+
+Bot.HealTargetIconsMask = 8
+
+#    Bot.DamageMult
+#        Myltiplier for bot's damage dealt. Allows to balance bots' compared to players' damage
+#        Any damage done by bots will be modified
+#        Range: 0.01 - 10.0
+#        Default: 1.0
+
+Bot.DamageMult.Melee = 1.0
+Bot.DamageMult.Spell = 1.0
+
+#    Bot.AllowAllClasses
+#        If set to 0 will not allow to create bots (through command) with classes which not yet implemented (in development)
+#        and not shown in botgiver's dialog
+#        Warning: Enabling this can cause crashes!
+#        Default: 0
+
+Bot.AllowAllClasses = 0
+
+#
+###################################################################################################
\ No newline at end of file
-- 
1.7.6.msysgit.0

